# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1504758735 14400
#      Thu Sep 07 00:32:15 2017 -0400
# Node ID 387be1a6c3dc1639cef69d00bf28cb1ce6b3c67c
# Parent  fc4ba8b1ff875e668b888a1d42451e9314840a3b
style fixes for GUI editor

* file-editor-interface.h, file-editor.cc, file-editor.h, marker.cc,
marker.h, octave-qscintilla.cc, octave-qscintilla.h,
octave-txt-lexer.cc, octave-txt-lexer.h:  Use m_ prefix for member
variables, order functions consistently in header and source files,
delete declarations for nonexistent functions, and follow more Octave
coding conventions.

diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -28,27 +28,28 @@ along with Octave; see the file COPYING.
 #include <QSettings>
 #include "octave-dock-widget.h"
 
 class file_editor_interface : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
+
   file_editor_interface (QWidget *p)
     : octave_dock_widget (p)
   {
     setObjectName ("FileEditor");
   }
 
-  virtual ~file_editor_interface () { }
+  virtual ~file_editor_interface (void) = default;
 
-  virtual QMenu * get_mru_menu () = 0;
-  virtual QMenu * debug_menu () = 0;
-  virtual QToolBar * toolbar () = 0;
+  virtual QMenu * get_mru_menu (void) = 0;
+  virtual QMenu * debug_menu (void) = 0;
+  virtual QToolBar * toolbar (void) = 0;
 
   virtual void insert_global_actions (QList<QAction*>) = 0;
   virtual void handle_enter_debug_mode (void) = 0;
   virtual void handle_exit_debug_mode (void) = 0;
 
   virtual void
   handle_insert_debugger_pointer_request (const QString& file, int line) = 0;
 
@@ -65,25 +66,21 @@ public:
 
   virtual void empty_script (bool, bool) = 0;
 
   virtual void restore_session (QSettings *) = 0;
 
   virtual void enable_menu_shortcuts (bool enable) = 0;
 
 public slots:
+
   virtual void request_new_file (const QString& command = QString ()) = 0;
+
   virtual void request_open_file (const QString& openFileName,
                                   const QString& encoding = QString (),
                                   int line = -1,
                                   bool debug_pointer = false,
                                   bool breakpoint_marker = false,
                                   bool insert = true,
                                   const QString& cond = "") = 0;
-//signals:
-
-//protected:
-
-//protected slots:
-
 };
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -43,60 +43,410 @@ along with Octave; see the file COPYING.
 #include <QVBoxLayout>
 #include <Qsci/qscicommandset.h>
 
 #include "main-window.h"
 #include "oct-map.h"
 #include "octave-link.h"
 #include "utils.h"
 
+// Functions of the the reimplemented tab bar
+
+file_editor_tab_bar::file_editor_tab_bar (QWidget *p)
+  : QTabBar (p), m_context_menu (new QMenu (this))
+{ }
+
+file_editor_tab_bar::~file_editor_tab_bar (void)
+{
+  delete m_context_menu;
+}
+
+// Create the context menu and fill it with actions from the editor
+void
+file_editor_tab_bar::create_context_menu (QList<QAction*> *actions)
+{
+  for (int i = 0; i < actions->count (); i++)
+    m_context_menu->addAction (actions->at (i));
+}
+
+// Reimplement mouse event for filtering out the desired mouse clicks
+void
+file_editor_tab_bar::mousePressEvent (QMouseEvent *me)
+{
+  QPoint click_pos;
+  int clicked_idx = -1;
+
+  // detect the tab where the click occured
+  for (int i = 0; i < count (); i++)
+    {
+      click_pos = mapToGlobal (me->pos ());
+      if (tabRect (i).contains (mapFromGlobal (click_pos)))
+        {
+          clicked_idx = i;
+          break;
+        }
+    }
+
+  // If a tab was clicked
+  if (clicked_idx >= 0)
+    {
+      int current_idx = currentIndex ();
+      // detect the mouse click
+      if ((me->type () == QEvent::MouseButtonDblClick &&
+           me->button() == Qt::LeftButton) ||
+          (me->type () != QEvent::MouseButtonDblClick &&
+           me->button() == Qt::MidButton))
+        {
+          // Middle click or double click -> close the tab
+          // Make the clicked tab the current one and close it
+          setCurrentIndex (clicked_idx);
+          emit close_current_tab_signal (true);
+          // Was the closed tab before or after the previously current tab?
+          // According to the result, use previous index or reduce it by one
+          if (current_idx - clicked_idx > 0)
+            setCurrentIndex (current_idx - 1);
+          else if (current_idx - clicked_idx < 0)
+            setCurrentIndex (current_idx);
+        }
+      else if (me->type () != QEvent::MouseButtonDblClick &&
+               me->button() == Qt::RightButton)
+        {
+          // Right click, show context menu
+          setCurrentIndex (clicked_idx);
+          if (! m_context_menu->exec (click_pos))
+            {
+              // No action selected, back to previous tab
+              setCurrentIndex (current_idx);
+            }
+          else
+            {
+              // Was the possibly only closed tab before or after the
+              // previously current tab? According to the result, use previous
+              // index or reduce it by one. Also prevent using a too large
+              // if other or all files were closed.
+              int new_idx = count () - 1;
+              if (new_idx > 0)
+                {
+                  if (current_idx - clicked_idx > 0)
+                    new_idx = current_idx - 1;
+                  else if (current_idx - clicked_idx < 0)
+                    new_idx = current_idx;
+                }
+              if (new_idx >= 0)
+                setCurrentIndex (new_idx);
+            }
+        }
+      else
+        {
+          // regular handling of the mouse event
+          QTabBar::mousePressEvent (me);
+        }
+    }
+  else
+    {
+      // regular handling of the mouse event
+      QTabBar::mousePressEvent (me);
+    }
+}
+
+// Functions of the the reimplemented tab widget
+
+file_editor_tab_widget::file_editor_tab_widget (QWidget *p)
+  : QTabWidget (p)
+{
+  file_editor_tab_bar *bar;
+  bar = new file_editor_tab_bar (this);
+
+  connect (bar, SIGNAL (close_current_tab_signal (bool)),
+           p->parent (), SLOT (request_close_file (bool)));
+
+  this->setTabBar (bar);
+}
+
+QTabBar*
+file_editor_tab_widget::tabBar (void) const
+{
+  return (QTabWidget::tabBar ());
+}
+
 file_editor::file_editor (QWidget *p)
   : file_editor_interface (p)
 {
   // Set current editing directory before construct because loaded
   // files will change ced accordingly.
-  ced = QDir::currentPath ();
+  m_ced = QDir::currentPath ();
 
   // set action that are later added by the main window to null,
   // preventing access to them when they are still undefined
-  _undo_action = nullptr;
-  _copy_action = nullptr;
-  _paste_action = nullptr;
-  _selectall_action = nullptr;
-  _closed = false;
-  _no_focus = false;
+  m_undo_action = nullptr;
+  m_copy_action = nullptr;
+  m_paste_action = nullptr;
+  m_selectall_action = nullptr;
+  m_closed = false;
+  m_no_focus = false;
 
   construct ();
 
   // actions that should also be available in the find dialog
-  _fetab_actions << _find_next_action;
-  _fetab_actions << _find_previous_action;
+  m_fetab_actions << m_find_next_action;
+  m_fetab_actions << m_find_previous_action;
 
   setVisible (false);
   setAcceptDrops (true);
 }
 
 file_editor::~file_editor (void)
 {
-  if (_mru_file_menu)
-    delete _mru_file_menu;
+  delete m_mru_file_menu;
+}
+
+// insert global actions, that should also be displayed in the editor window,
+// into the editor's menu and/or toolbar
+void
+file_editor::insert_global_actions (QList<QAction*> shared_actions)
+{
+  // actions/menus that have to be added to the toolbar or the menu
+  QAction *open_action = shared_actions.at (OPEN_ACTION);
+  QAction *new_action = shared_actions.at (NEW_SCRIPT_ACTION);
+  QAction *new_fcn_action = shared_actions.at (NEW_FUNCTION_ACTION);
+  m_fileMenu->insertAction (m_mru_file_menu->menuAction (), open_action);
+  m_fileMenu->insertAction (open_action, new_fcn_action);
+  m_fileMenu->insertAction (new_fcn_action, new_action);
+  m_tool_bar->insertAction (m_popdown_mru_action, open_action);
+  m_tool_bar->insertAction (open_action, new_action);
+
+  // actions that are additionally enabled/disabled later by the editor
+  // undo
+  m_undo_action = shared_actions.at (UNDO_ACTION);
+  m_tool_bar->insertAction (m_redo_action,m_undo_action);
+  m_edit_menu->insertAction (m_redo_action,m_undo_action);
+  // copy
+  m_copy_action = shared_actions.at (COPY_ACTION);
+  m_tool_bar->insertAction (m_cut_action,m_copy_action);
+  m_edit_menu->insertAction (m_cut_action,m_copy_action);
+  // select all
+  m_selectall_action = shared_actions.at (SELECTALL_ACTION);
+  m_edit_menu->insertAction (m_find_action,m_selectall_action);
+  m_edit_menu->insertSeparator (m_find_action);
+  // paste
+  m_paste_action = shared_actions.at (PASTE_ACTION);
+  m_tool_bar->insertAction (m_find_action,m_paste_action);
+  m_edit_menu->insertAction (m_selectall_action,m_paste_action);
+  m_edit_menu->insertSeparator (m_selectall_action);
+  // find files
+  m_find_files_action = shared_actions.at (FIND_FILES_ACTION);
+  m_edit_menu->insertAction (m_find_action, m_find_files_action);
+}
+
+void
+file_editor::handle_enter_debug_mode (void)
+{
+  m_run_action->setEnabled (false);
+  m_run_action->setShortcut (QKeySequence ());
+}
+
+void
+file_editor::handle_exit_debug_mode (void)
+{
+  m_run_action->setEnabled (true);
+  shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
+}
+
+void
+file_editor::check_actions (void)
+{
+  bool have_tabs = m_tab_widget->count () > 0;
+
+  m_edit_cmd_menu->setEnabled (have_tabs);
+  m_edit_fmt_menu->setEnabled (have_tabs);
+  m_edit_nav_menu->setEnabled (have_tabs);
+
+  m_comment_selection_action->setEnabled (have_tabs);
+  m_uncomment_selection_action->setEnabled (have_tabs);
+  m_indent_selection_action->setEnabled (have_tabs);
+  m_unindent_selection_action->setEnabled (have_tabs);
+
+  m_context_help_action->setEnabled (have_tabs);
+  m_context_doc_action->setEnabled (have_tabs);
+
+  m_view_editor_menu->setEnabled (have_tabs);
+  m_zoom_in_action->setEnabled (have_tabs);
+  m_zoom_out_action->setEnabled (have_tabs);
+  m_zoom_normal_action->setEnabled (have_tabs);
+
+  m_find_action->setEnabled (have_tabs);
+  m_find_next_action->setEnabled (have_tabs);
+  m_find_previous_action->setEnabled (have_tabs);
+  m_print_action->setEnabled (have_tabs);
+  m_run_action->setEnabled (have_tabs);
+
+  m_edit_function_action->setEnabled (have_tabs);
+  m_save_action->setEnabled (have_tabs);
+  m_save_as_action->setEnabled (have_tabs);
+  m_close_action->setEnabled (have_tabs);
+  m_close_all_action->setEnabled (have_tabs);
+  m_close_others_action->setEnabled (have_tabs && m_tab_widget->count () > 1);
+}
+
+// empty_script determines whether we have to create an empty script
+// 1. At startup, when the editor has to be (really) visible
+//    (Here we can not use the visibility changed signal)
+// 2. When the editor becomes visible when octave is running
+void
+file_editor::empty_script (bool startup, bool visible)
+{
+  QSettings *settings = resource_manager::get_settings ();
+  if (settings->value ("useCustomFileEditor",false).toBool ())
+    return;  // do not open an empty script in the external editor
+
+  bool real_visible;
+
+  if (startup)
+    real_visible = isVisible ();
+  else
+    real_visible = visible;
+
+  if (! real_visible || m_tab_widget->count () > 0)
+    return;
+
+  if (startup && ! isFloating ())
+    {
+      // check is editor is really visible or hidden between tabbed widgets
+      QList<QTabBar *> tab_list = main_win ()->findChildren<QTabBar *>();
+
+      bool in_tab = false;
+      int i = 0;
+      while ((i < tab_list.count ()) && (! in_tab))
+        {
+          QTabBar *tab = tab_list.at (i);
+          i++;
+
+          int j = 0;
+          while ((j < tab->count ()) && (! in_tab))
+            {
+              // check all tabs for the editor
+              if (tab->tabText (j) == windowTitle ())
+                {
+                  // editor is in this tab widget
+                  in_tab = true;
+                  int top = tab->currentIndex ();
+                  if (top > -1 && tab->tabText (top) == windowTitle ())
+                    real_visible = true;  // and is the current tab
+                  else
+                    return; // not current tab -> not visible
+                }
+              j++;
+            }
+        }
+    }
+
+  request_new_file ("");
+}
+
+void
+file_editor::restore_session (QSettings *settings)
+{
+  //restore previous session
+  if (! settings->value ("editor/restoreSession", true).toBool ())
+    return;
+
+  // get the data from the settings file
+  QStringList sessionFileNames = settings->value ("editor/savedSessionTabs",
+                                          QStringList ()).toStringList ();
+  QStringList session_encodings = settings->value ("editor/saved_session_encodings",
+                                          QStringList ()).toStringList ();
+  QStringList session_index = settings->value ("editor/saved_session_tab_index",
+                                          QStringList ()).toStringList ();
+
+  // fill a list of the struct and sort it (depending on index)
+  QList<session_data> s_data;
+
+  bool do_encoding = (session_encodings.count () == sessionFileNames.count ());
+  bool do_index    = (session_index.count () == sessionFileNames.count ());
+
+  for (int n = 0; n < sessionFileNames.count (); ++n)
+    {
+      QFileInfo file = QFileInfo (sessionFileNames.at (n));
+      if (! file.exists ())
+        continue;
+
+      session_data item = { QString (), sessionFileNames.at (n), QString ()};
+      if (do_index)
+        item.index = session_index.at (n);
+      if (do_encoding)
+        item.encoding = session_encodings.at (n);
+
+      s_data << item;
+    }
+
+  qSort (s_data);
+
+  // finally open the file with the desired encoding in the desired order
+  for (int n = 0; n < s_data.count (); ++n)
+    request_open_file (s_data.at (n).file_name, s_data.at (n).encoding);
+}
+
+void
+file_editor::focus (void)
+{
+  if (m_no_focus)
+    return;  // No focus for the editor if external open/close request
+
+  octave_dock_widget::focus ();
+
+  // set focus to current tab
+  QWidget *fileEditorTab = m_tab_widget->currentWidget ();
+  if (fileEditorTab)
+    emit fetab_set_focus (fileEditorTab);
+}
+
+void
+file_editor::set_focus (QWidget *fet)
+{
+  octave_dock_widget::focus ();
+
+  // set focus to desired tab
+  if (fet)
+    m_tab_widget->setCurrentWidget (fet);
+}
+
+// function enabling/disabling the menu accelerators depending on the
+// focus of the editor
+void
+file_editor::enable_menu_shortcuts (bool enable)
+{
+  QHash<QMenu*, QStringList>::const_iterator i = m_hash_menu_text.constBegin ();
+
+  while (i != m_hash_menu_text.constEnd ())
+    {
+      i.key ()->setTitle (i.value ().at (! enable));
+      ++i;
+    }
+
+  // when editor loses focus, enable the actions, which are always active
+  // in the main window due to missing info on selected text and undo actions
+  if (! enable && m_copy_action && m_undo_action)
+    {
+      m_copy_action->setEnabled (true);
+      m_undo_action->setEnabled (true);
+    }
 }
 
 bool
 file_editor::check_closing (void)
 {
   // When the application or the editor is closing and the user wants to close
   // all files in the latter case all editor tabs are checked whether
   // they need to be saved. During these ckecked the tabs are not closed
   // since the user might cancel closing octave during one of these saving
   // dialogs. Therefore, saving the session for restoring at next start
   // is not done before the application is definitely closing
 
   // Have all file editor tabs signal what their filenames are.
-  editor_tab_map.clear ();
+  m_editor_tab_map.clear ();
   emit fetab_file_name_query (nullptr);
 
   // Save all tabs with confirmation.
   file_editor_tab::reset_cancel ();
   emit fetab_check_modified_file ();
 
   // If there was a cancellation, make the already saved/discarded tabs
   // recovering from the exit by removing the read-only state and by
@@ -115,187 +465,862 @@ file_editor::check_closing (void)
 
   // save filenames (even if last session will not be restored next time)
   // together with encoding and the tab index
   QStringList fetFileNames;
   QStringList fet_encodings;
   QStringList fet_index;
 
   // save all open tabs before they are definitely closed
-  for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
-       p != editor_tab_map.end (); p++)
+  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+       p != m_editor_tab_map.end (); p++)
     {
       QString file_name = p->first;   // get file name of tab
       if (! file_name.isEmpty ())      // do not append unnamed files
         {
           fetFileNames.append (file_name);
-          fet_encodings.append (editor_tab_map[file_name].encoding);
+          fet_encodings.append (m_editor_tab_map[file_name].encoding);
           QString index;
           fet_index.append (index.setNum
-             (_tab_widget->indexOf (editor_tab_map[file_name].fet_ID)));
+             (m_tab_widget->indexOf (m_editor_tab_map[file_name].fet_ID)));
         }
     }
 
   settings->setValue ("editor/savedSessionTabs", fetFileNames);
   settings->setValue ("editor/saved_session_encodings", fet_encodings);
   settings->setValue ("editor/saved_session_tab_index", fet_index);
   settings->sync ();
 
   // Finally close all the tabs and return indication that we can exit
   // the application or close the editor
-  for (int i = _tab_widget->count () - 1; i >= 0; i--)
+  for (int i = m_tab_widget->count () - 1; i >= 0; i--)
     {
-      // backwards loop since _tab_widget->count () changes during the loop
-      delete _tab_widget->widget (i);
-      _tab_widget->removeTab (i);
+      // backwards loop since m_tab_widget->count () changes during the loop
+      delete m_tab_widget->widget (i);
+      m_tab_widget->removeTab (i);
     }
 
   return true;
 }
 
 void
-file_editor::focus (void)
-{
-  if (_no_focus)
-    return;  // No focus for the editor if external open/close request
-
-  octave_dock_widget::focus ();
-
-  // set focus to current tab
-  QWidget *fileEditorTab = _tab_widget->currentWidget ();
-  if (fileEditorTab)
-    emit fetab_set_focus (fileEditorTab);
-}
-
-void
-file_editor::set_focus (QWidget *fet)
-{
-  octave_dock_widget::focus ();
-
-  // set focus to desired tab
-  if (fet)
-    _tab_widget->setCurrentWidget (fet);
-}
-
-void
-file_editor::update_octave_directory (const QString& dir)
-{
-  ced = dir;
-  emit fetab_set_directory (ced);  // for save dialog
-}
-
-QMenu *
-file_editor::debug_menu (void)
-{
-  return _debug_menu;
-}
-
-QToolBar *
-file_editor::toolbar (void)
-{
-  return _tool_bar;
-}
-
-void
-file_editor::handle_enter_debug_mode (void)
-{
-  _run_action->setEnabled (false);
-  _run_action->setShortcut (QKeySequence ());
-}
-
-void
-file_editor::handle_exit_debug_mode (void)
-{
-  _run_action->setEnabled (true);
-  shortcut_manager::set_shortcut (_run_action, "editor_run:run_file");
-}
-
-void
 file_editor::request_new_file (const QString& commands)
 {
   // Custom editor? If yes, we can only call the editor without passing
   // some initial contents and even without being sure a new file is opened
   if (call_custom_editor ())
     return;
 
   // New file isn't a file_editor_tab function since the file
   // editor tab has yet to be created and there is no object to
   // pass a signal to.  Hence, functionality is here.
 
-  file_editor_tab *fileEditorTab = new file_editor_tab (ced);
+  file_editor_tab *fileEditorTab = new file_editor_tab (m_ced);
   if (fileEditorTab)
     {
       add_file_editor_tab (fileEditorTab, "");  // new tab with empty title
       fileEditorTab->new_file (commands);       // title is updated here
       focus ();                                 // focus editor and new tab
     }
 }
 
-// Check whether this file is already open in the editor.
-QWidget *
-file_editor::find_tab_widget (const QString& file)
+void
+file_editor::request_close_file (bool)
+{
+  file_editor_tab *editor_tab
+    = static_cast<file_editor_tab *> (m_tab_widget->currentWidget ());
+  editor_tab->conditional_close ();
+}
+
+void
+file_editor::request_close_all_files (bool)
+{
+  file_editor_tab *editor_tab;
+
+  // loop over all tabs starting from last one otherwise deletion changes index
+  for (int index = m_tab_widget->count ()-1; index >= 0; index--)
+    {
+      editor_tab = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+      editor_tab->conditional_close ();
+    }
+}
+
+void
+file_editor::request_close_other_files (bool)
+{
+  file_editor_tab *editor_tab;
+  QWidget *tabID = m_tab_widget->currentWidget ();
+
+  // loop over all tabs starting from last one otherwise deletion changes index
+  for (int index = m_tab_widget->count ()-1; index >= 0; index--)
+    {
+      if (tabID != m_tab_widget->widget (index))
+        {
+          editor_tab
+            = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+          editor_tab->conditional_close ();
+        }
+    }
+}
+
+// open a file from the mru list
+void
+file_editor::request_mru_open_file (QAction *action)
+{
+  if (action)
+    {
+      request_open_file (action->data ().toStringList ().at (0),
+                         action->data ().toStringList ().at (1));
+    }
+}
+
+void
+file_editor::request_print_file (bool)
+{
+  emit fetab_print_file (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_redo (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_REDO);
+}
+
+void
+file_editor::request_cut (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_CUT);
+}
+
+void
+file_editor::request_context_help (bool)
+{
+  emit fetab_context_help (m_tab_widget->currentWidget (), false);
+}
+
+void
+file_editor::request_context_doc (bool)
+{
+  emit fetab_context_help (m_tab_widget->currentWidget (), true);
+}
+
+void
+file_editor::request_context_edit (bool)
+{
+  emit fetab_context_edit (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_save_file (bool)
+{
+  emit fetab_save_file (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_save_file_as (bool)
+{
+  emit fetab_save_file_as (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_run_file (bool)
+{
+  emit fetab_run_file (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_context_run (bool)
+{
+  emit fetab_context_run (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_toggle_bookmark (bool)
+{
+  emit fetab_toggle_bookmark (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_next_bookmark (bool)
+{
+  emit fetab_next_bookmark (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_previous_bookmark (bool)
+{
+  emit fetab_previous_bookmark (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_remove_bookmark (bool)
+{
+  emit fetab_remove_bookmark (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_move_match_brace (bool)
+{
+  emit fetab_move_match_brace (m_tab_widget->currentWidget (), false);
+}
+
+void
+file_editor::request_sel_match_brace (bool)
+{
+  emit fetab_move_match_brace (m_tab_widget->currentWidget (), true);
+}
+
+// FIXME: What should this do with conditional breakpoints?
+void
+file_editor::request_toggle_breakpoint (bool)
+{
+  emit fetab_toggle_breakpoint (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_next_breakpoint (bool)
+{
+  emit fetab_next_breakpoint (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_previous_breakpoint (bool)
+{
+  emit fetab_previous_breakpoint (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_remove_breakpoint (bool)
+{
+  emit fetab_remove_all_breakpoints (m_tab_widget->currentWidget ());
+}
+
+// slots for Edit->Commands actions
+void
+file_editor::request_delete_start_word (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_DELWORDLEFT);
+}
+
+void
+file_editor::request_delete_end_word (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_DELWORDRIGHT);
+}
+
+void
+file_editor::request_delete_start_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_DELLINELEFT);
+}
+
+void
+file_editor::request_delete_end_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_DELLINERIGHT);
+}
+
+void
+file_editor::request_delete_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_LINEDELETE);
+}
+
+void
+file_editor::request_copy_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_LINECOPY);
+}
+
+void
+file_editor::request_cut_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_LINECUT);
+}
+
+void
+file_editor::request_duplicate_selection (bool)
 {
-  // Have all file editor tabs signal what their filenames are.
-  editor_tab_map.clear ();
-  emit fetab_file_name_query (nullptr);
-
-  // Check all tabs for the given file name
-  QWidget *retval = nullptr;
-
-  for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
-       p != editor_tab_map.end (); p++)
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_SELECTIONDUPLICATE);
+}
+
+void
+file_editor::request_transpose_line (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_LINETRANSPOSE);
+}
+
+void
+file_editor::request_comment_selected_text (bool)
+{
+  emit fetab_comment_selected_text (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_uncomment_selected_text (bool)
+{
+  emit fetab_uncomment_selected_text (m_tab_widget->currentWidget ());
+}
+
+// slots for Edit->Format actions
+void
+file_editor::request_upper_case (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_UPPERCASE);
+}
+void
+file_editor::request_lower_case (bool)
+{
+  emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_LOWERCASE);
+}
+void
+file_editor::request_indent_selected_text (bool)
+{
+  emit fetab_indent_selected_text (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_unindent_selected_text (bool)
+{
+  emit fetab_unindent_selected_text (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_conv_eol_windows (bool)
+{
+  emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                          QsciScintilla::EolWindows);
+}
+void
+file_editor::request_conv_eol_unix (bool)
+{
+  emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                          QsciScintilla::EolUnix);
+}
+void
+file_editor::request_conv_eol_mac (bool)
+{
+  emit fetab_convert_eol (m_tab_widget->currentWidget (),
+                          QsciScintilla::EolMac);
+}
+
+void
+file_editor::request_find (bool)
+{
+  emit fetab_find (m_tab_widget->currentWidget (), m_fetab_actions);
+}
+
+void
+file_editor::request_find_next (bool)
+{
+  emit fetab_find_next (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_find_previous (bool)
+{
+  emit fetab_find_previous (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_goto_line (bool)
+{
+  emit fetab_goto_line (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_completion (bool)
+{
+  emit fetab_completion (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::handle_file_name_changed (const QString& fname,
+                                       const QString& tip)
+{
+  QObject *fileEditorTab = sender ();
+  if (fileEditorTab)
     {
-      QString tab_file = p->first;
-      if (same_file (file.toStdString (), tab_file.toStdString ())
-          || file == tab_file)     // needed as same_file ("","") is false.
+      for (int i = 0; i < m_tab_widget->count (); i++)
+        {
+          if (m_tab_widget->widget (i) == fileEditorTab)
+            {
+              m_tab_widget->setTabText (i, fname);
+              m_tab_widget->setTabToolTip (i, tip);
+            }
+        }
+    }
+}
+
+void
+file_editor::handle_tab_close_request (int index)
+{
+  file_editor_tab *editor_tab
+    = static_cast<file_editor_tab *> (m_tab_widget->widget (index));
+  editor_tab->conditional_close ();
+}
+
+void
+file_editor::handle_tab_remove_request (void)
+{
+  QObject *fileEditorTab = sender ();
+  if (fileEditorTab)
+    {
+      for (int i = 0; i < m_tab_widget->count (); i++)
         {
-          retval = p->second.fet_ID;
+          if (m_tab_widget->widget (i) == fileEditorTab)
+            {
+              m_tab_widget->removeTab (i);
+              // Deleting sender is dodgy, but works because the signal
+              // is the last item in the sender's routines.
+              delete fileEditorTab;
+              break;
+            }
+        }
+    }
+  check_actions ();
+
+  focus ();     // focus stays in editor when tab is closed
+
+}
+
+void
+file_editor::handle_add_filename_to_list (const QString& fileName,
+                                          const QString& encoding, QWidget *ID)
+{
+  // Should we allow multiple tabs for a single file?
+  m_editor_tab_map[fileName].fet_ID = ID;
+  m_editor_tab_map[fileName].encoding = encoding;
+}
+
+// context menu of edit area
+void
+file_editor::active_tab_changed (int index)
+{
+  emit fetab_change_request (m_tab_widget->widget (index));
+}
+
+void
+file_editor::handle_editor_state_changed (bool copy_available,
+                                          bool is_octave_file)
+{
+  // In case there is some scenario where traffic could be coming from
+  // all the file editor tabs, just process info from the current active tab.
+  if (sender () == m_tab_widget->currentWidget ())
+    {
+      if (m_copy_action)
+        m_copy_action->setEnabled (copy_available);
+      m_cut_action->setEnabled (copy_available);
+      m_run_selection_action->setEnabled (copy_available);
+      m_run_action->setEnabled (is_octave_file);
+
+      setFocusProxy (m_tab_widget->currentWidget ());
+    }
+}
+
+void
+file_editor::handle_mru_add_file (const QString& file_name,
+                                  const QString& encoding)
+{
+  int index;
+  while ((index = m_mru_files.indexOf (file_name)) >= 0)
+    {
+      m_mru_files.removeAt (index);
+      m_mru_files_encodings.removeAt (index);
+    }
+
+  m_mru_files.prepend (file_name);
+  m_mru_files_encodings.prepend (encoding);
+
+  mru_menu_update ();
+}
+
+void
+file_editor::check_conflict_save (const QString& saveFileName,
+                                  bool remove_on_success)
+{
+  // Check whether this file is already open in the editor.
+  QWidget *tab = find_tab_widget (saveFileName);
+
+  if (tab)
+    {
+      // Note: to overwrite the contents of some other file editor tab
+      // with the same name requires identifying which file editor tab
+      // that is (not too difficult) then close that tab.  Of course,
+      // that could trigger another dialog box if the file editor tab
+      // with the same name has modifications in it.  This could become
+      // somewhat confusing to the user.  For now, opt to do nothing.
+
+      // Create a NonModal message about error.
+      QMessageBox *msgBox
+        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
+                           tr ("File not saved! A file with the selected name\n%1\n"
+                               "is already open in the editor").
+                           arg (saveFileName),
+                           QMessageBox::Ok, nullptr);
+
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+
+      return;
+    }
+
+  QObject *saveFileObject = sender ();
+  QWidget *saveFileWidget = nullptr;
+
+  for (int i = 0; i < m_tab_widget->count (); i++)
+    {
+      if (m_tab_widget->widget (i) == saveFileObject)
+        {
+          saveFileWidget = m_tab_widget->widget (i);
           break;
         }
     }
-
-  return retval;
+  if (! saveFileWidget)
+    {
+      // Create a NonModal message about error.
+      QMessageBox *msgBox
+        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
+                           tr ("The associated file editor tab has disappeared."),
+                           QMessageBox::Ok, nullptr);
+
+      msgBox->setWindowModality (Qt::NonModal);
+      msgBox->setAttribute (Qt::WA_DeleteOnClose);
+      msgBox->show ();
+
+      return;
+    }
+
+  // Can save without conflict, have the file editor tab do so.
+  emit fetab_save_file (saveFileWidget, saveFileName, remove_on_success);
+}
+
+void
+file_editor::handle_insert_debugger_pointer_request (const QString& file,
+                                                     int line)
+{
+  request_open_file (file, QString (), line, true); // default encoding
+}
+
+void
+file_editor::handle_delete_debugger_pointer_request (const QString& file,
+                                                     int line)
+{
+  if (! file.isEmpty ())
+    {
+      // Check whether this file is already open in the editor.
+      QWidget *tab = find_tab_widget (file);
+
+      if (tab)
+        {
+          m_tab_widget->setCurrentWidget (tab);
+
+          if (line > 0)
+            emit fetab_delete_debugger_pointer (tab, line);
+
+          emit fetab_set_focus (tab);
+        }
+    }
+}
+
+void
+file_editor::handle_update_breakpoint_marker_request (bool insert,
+                                                      const QString& file,
+                                                      int line,
+                                                      const QString& cond)
+{
+  request_open_file (file, QString (), line, false, true, insert, cond);
+}
+
+void
+file_editor::handle_edit_file_request (const QString& file)
+{
+  request_open_file (file);
 }
 
-bool
-file_editor::call_custom_editor (const QString& file_name, int line)
+// Slot used for signals indicating that a file was changed/rename or
+// is going to be deleted/renamed
+void
+file_editor::handle_file_remove (const QString& old_name,
+                                 const QString& new_name)
 {
-  // Check if the user wants to use a custom file editor.
-  QSettings *settings = resource_manager::get_settings ();
-
-  if (settings->value ("useCustomFileEditor",false).toBool ())
+  // Clear old lsit of files to reload
+  m_tmp_closed_files.clear ();
+
+  // Check if old name is a file or directory
+  QFileInfo old (old_name);
+  if (old.isDir ())
+    {
+      // Call the function which handles directories and return
+      handle_dir_remove (old_name, new_name);
+      return;
+    }
+
+  // Is old file open?
+  file_editor_tab *editor_tab
+    = static_cast<file_editor_tab *> (find_tab_widget (old_name));
+
+  if (editor_tab)
+    {
+      // Yes, close it silently
+      m_no_focus = true;  // Remember for not focussing editor
+      editor_tab->file_has_changed (QString (), true);  // Close the tab
+      m_no_focus = false;  // Back to normal
+
+      m_tmp_closed_files << old_name;  // for reloading if error removing
+
+      if (! new_name.isEmpty ())
+        m_tmp_closed_files << new_name;  // store new name
+      else
+        m_tmp_closed_files << ""; // no new name, just removing this file
+
+      // Get and store the related encoding
+      for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+           p != m_editor_tab_map.end (); p++)
+        {
+          if (editor_tab == p->second.fet_ID)
+            {
+              m_tmp_closed_files << p->second.encoding;
+              break;
+            }
+        }
+    }
+}
+
+// Slot for signal indicating that a file was renamed
+void
+file_editor::handle_file_renamed (bool load_new)
+{
+  m_no_focus = true;  // Remember for not focussing editor
+  for (int i = 0; i < m_tmp_closed_files.count (); i = i + 3)
+    {
+      if (! m_tmp_closed_files.at (i + load_new).isEmpty ())
+        request_open_file (m_tmp_closed_files.at (i + load_new),
+                           m_tmp_closed_files.at (i+2));
+    }
+  m_no_focus = false;  // Back to normal focus
+}
+
+void
+file_editor::notice_settings (const QSettings *settings)
+{
+  int icon_size_settings = settings->value ("toolbar_icon_size",0).toInt ();
+  QStyle *st = style ();
+  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
+
+  if (icon_size_settings == 1)
+    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
+  else if (icon_size_settings == -1)
+    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
+
+  m_tool_bar->setIconSize (QSize (icon_size,icon_size));
+
+  int tab_width_min = settings->value ("editor/notebook_tab_width_min", 160)
+                                      .toInt ();
+  int tab_width_max = settings->value ("editor/notebook_tab_width_max", 300)
+                                      .toInt ();
+
+  if (settings->value ("editor/longWindowTitle", false).toBool ())
     {
-      // use the external editor interface for handling the call
-      emit request_open_file_external (file_name, line);
-
-      if (line < 0 && ! file_name.isEmpty ())
-        handle_mru_add_file (QFileInfo (file_name).canonicalFilePath (),
-                             QString ());
-
-      return true;
+      QString style_sheet = QString ("QTabBar::tab "
+                                     "{min-width: %1px; max-width: %2px;}")
+                             .arg (tab_width_min).arg (tab_width_max);
+      m_tab_widget->setElideMode (Qt::ElideLeft);
+      m_tab_widget->setStyleSheet (style_sheet);
     }
-
-  return false;
+  else
+    m_tab_widget->setElideMode (Qt::ElideNone);
+
+  m_tab_widget->setUsesScrollButtons (true);
+
+  bool show_it;
+  show_it = settings->value ("editor/showLineNumbers",true).toBool ();
+  m_show_linenum_action->setChecked (show_it);
+  show_it = settings->value ("editor/show_white_space",false).toBool ();
+  m_show_whitespace_action->setChecked (show_it);
+  show_it = settings->value ("editor/show_eol_chars",false).toBool ();
+  m_show_eol_action->setChecked (show_it);
+  show_it = settings->value ("editor/show_indent_guides",false).toBool ();
+  m_show_indguide_action->setChecked (show_it);
+  show_it = settings->value ("editor/long_line_marker",true).toBool ();
+  m_show_longline_action->setChecked (show_it);
+
+  show_it = settings->value ("editor/show_toolbar",true).toBool ();
+  m_show_toolbar_action->setChecked (show_it);
+  m_tool_bar->setVisible (show_it);
+  show_it = settings->value ("editor/show_edit_status_bar",true).toBool ();
+  m_show_statusbar_action->setChecked (show_it);
+  show_it = settings->value ("editor/show_hscroll_bar",true).toBool ();
+  m_show_hscrollbar_action->setChecked (show_it);
+
+  set_shortcuts ();
+
+  // Relay signal to file editor tabs.
+  emit fetab_settings_changed (settings);
 }
 
-bool
-file_editor::is_editor_console_tabbed ()
+void
+file_editor::set_shortcuts (void)
 {
-  main_window *w = static_cast<main_window *>(main_win ());
-  QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
-  QDockWidget *console =
-    static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
-
-  for (int i = 0; i < w_list.count (); i++)
+  // Shortcuts also available in the main window, as well as the realted
+  // ahotcuts, are defined in main_window and added to the editor
+
+  // File menu
+  shortcut_manager::set_shortcut (m_edit_function_action, "editor_file:edit_function");
+  shortcut_manager::set_shortcut (m_save_action, "editor_file:save");
+  shortcut_manager::set_shortcut (m_save_as_action, "editor_file:save_as");
+  shortcut_manager::set_shortcut (m_close_action, "editor_file:close");
+  shortcut_manager::set_shortcut (m_close_all_action, "editor_file:close_all");
+  shortcut_manager::set_shortcut (m_close_others_action, "editor_file:close_other");
+  shortcut_manager::set_shortcut (m_print_action, "editor_file:print");
+
+  // Edit menu
+  shortcut_manager::set_shortcut (m_redo_action, "editor_edit:redo");
+  shortcut_manager::set_shortcut (m_cut_action, "editor_edit:cut");
+  shortcut_manager::set_shortcut (m_find_action, "editor_edit:find_replace");
+  shortcut_manager::set_shortcut (m_find_next_action, "editor_edit:find_next");
+  shortcut_manager::set_shortcut (m_find_previous_action, "editor_edit:find_previous");
+
+  shortcut_manager::set_shortcut (m_delete_start_word_action, "editor_edit:delete_start_word");
+  shortcut_manager::set_shortcut (m_delete_end_word_action, "editor_edit:delete_end_word");
+  shortcut_manager::set_shortcut (m_delete_start_line_action, "editor_edit:delete_start_line");
+  shortcut_manager::set_shortcut (m_delete_end_line_action, "editor_edit:delete_end_line");
+  shortcut_manager::set_shortcut (m_delete_line_action, "editor_edit:delete_line");
+  shortcut_manager::set_shortcut (m_copy_line_action, "editor_edit:copy_line");
+  shortcut_manager::set_shortcut (m_cut_line_action, "editor_edit:cut_line");
+  shortcut_manager::set_shortcut (m_duplicate_selection_action, "editor_edit:duplicate_selection");
+  shortcut_manager::set_shortcut (m_transpose_line_action, "editor_edit:transpose_line");
+  shortcut_manager::set_shortcut (m_comment_selection_action, "editor_edit:comment_selection");
+  shortcut_manager::set_shortcut (m_uncomment_selection_action, "editor_edit:uncomment_selection");
+
+  shortcut_manager::set_shortcut (m_upper_case_action, "editor_edit:upper_case");
+  shortcut_manager::set_shortcut (m_lower_case_action, "editor_edit:lower_case");
+  shortcut_manager::set_shortcut (m_indent_selection_action, "editor_edit:indent_selection");
+  shortcut_manager::set_shortcut (m_unindent_selection_action, "editor_edit:unindent_selection");
+  shortcut_manager::set_shortcut (m_completion_action, "editor_edit:completion_list");
+  shortcut_manager::set_shortcut (m_goto_line_action, "editor_edit:goto_line");
+  shortcut_manager::set_shortcut (m_move_to_matching_brace, "editor_edit:move_to_brace");
+  shortcut_manager::set_shortcut (m_sel_to_matching_brace, "editor_edit:select_to_brace");
+  shortcut_manager::set_shortcut (m_toggle_bookmark_action, "editor_edit:toggle_bookmark");
+  shortcut_manager::set_shortcut (m_next_bookmark_action, "editor_edit:next_bookmark");
+  shortcut_manager::set_shortcut (m_previous_bookmark_action, "editor_edit:previous_bookmark");
+  shortcut_manager::set_shortcut (m_remove_bookmark_action, "editor_edit:remove_bookmark");
+  shortcut_manager::set_shortcut (m_preferences_action, "editor_edit:preferences");
+  shortcut_manager::set_shortcut (m_styles_preferences_action, "editor_edit:styles_preferences");
+
+  shortcut_manager::set_shortcut (m_conv_eol_windows_action, "editor_edit:conv_eol_winows");
+  shortcut_manager::set_shortcut (m_conv_eol_unix_action,    "editor_edit:conv_eol_unix");
+  shortcut_manager::set_shortcut (m_conv_eol_mac_action,     "editor_edit:conv_eol_mac");
+
+  // View menu
+  shortcut_manager::set_shortcut (m_show_linenum_action, "editor_view:show_line_numbers");
+  shortcut_manager::set_shortcut (m_show_whitespace_action, "editor_view:show_white_spaces");
+  shortcut_manager::set_shortcut (m_show_eol_action, "editor_view:show_eol_chars");
+  shortcut_manager::set_shortcut (m_show_indguide_action, "editor_view:show_ind_guides");
+  shortcut_manager::set_shortcut (m_show_longline_action, "editor_view:show_long_line");
+  shortcut_manager::set_shortcut (m_show_toolbar_action, "editor_view:show_toolbar");
+  shortcut_manager::set_shortcut (m_show_statusbar_action, "editor_view:show_statusbar");
+  shortcut_manager::set_shortcut (m_show_hscrollbar_action, "editor_view:show_hscrollbar");
+  shortcut_manager::set_shortcut (m_zoom_in_action, "editor_view:zoom_in");
+  shortcut_manager::set_shortcut (m_zoom_out_action, "editor_view:zoom_out");
+  shortcut_manager::set_shortcut (m_zoom_normal_action, "editor_view:zoom_normal");
+
+  // Debug menu
+  shortcut_manager::set_shortcut (m_toggle_breakpoint_action, "editor_debug:toggle_breakpoint");
+  shortcut_manager::set_shortcut (m_next_breakpoint_action, "editor_debug:next_breakpoint");
+  shortcut_manager::set_shortcut (m_previous_breakpoint_action, "editor_debug:previous_breakpoint");
+  shortcut_manager::set_shortcut (m_remove_all_breakpoints_action, "editor_debug:remove_breakpoints");
+
+  // Run menu
+  shortcut_manager::set_shortcut (m_run_action, "editor_run:run_file");
+  shortcut_manager::set_shortcut (m_run_selection_action, "editor_run:run_selection");
+
+  // Help menu
+  shortcut_manager::set_shortcut (m_context_help_action, "editor_help:help_keyword");
+  shortcut_manager::set_shortcut (m_context_doc_action,  "editor_help:doc_keyword");
+
+  // Tab navigation without menu entries
+  shortcut_manager::set_shortcut (m_switch_left_tab_action, "editor_tabs:switch_left_tab");
+  shortcut_manager::set_shortcut (m_switch_right_tab_action, "editor_tabs:switch_right_tab");
+  shortcut_manager::set_shortcut (m_move_tab_left_action, "editor_tabs:move_tab_left");
+  shortcut_manager::set_shortcut (m_move_tab_right_action, "editor_tabs:move_tab_right");
+
+}
+
+// This slot is a reimplementation of the virtual slot in octave_dock_widget.
+// We need this for creating an empty script when the editor has no open files
+// and is made visible
+void
+file_editor::handle_visibility (bool visible)
+{
+  if (m_closed && visible)
     {
-      if (w_list.at (i) == console)
-        return true;
+      m_closed = false;
+      QSettings *settings = resource_manager::get_settings ();
+      restore_session (settings);
     }
 
-  return false;
+  empty_script (false, visible);
+
+  if (visible && ! isFloating ())
+    focus ();
+
+}
+
+void
+file_editor::update_octave_directory (const QString& dir)
+{
+  m_ced = dir;
+  emit fetab_set_directory (m_ced);  // for save dialog
+}
+
+void
+file_editor::copyClipboard (void)
+{
+  if (editor_tab_has_focus ())
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_COPY);
+}
+
+void
+file_editor::pasteClipboard (void)
+{
+  if (editor_tab_has_focus ())
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_PASTE);
+}
+
+void
+file_editor::selectAll (void)
+{
+  if (editor_tab_has_focus ())
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_SELECTALL);
+}
+
+void
+file_editor::do_undo (void)
+{
+  if (editor_tab_has_focus ())
+    emit fetab_scintilla_command (m_tab_widget->currentWidget (),
+                                  QsciScintillaBase::SCI_UNDO);
 }
 
 // Open a file, if not already open, and mark the current execution location
 // and/or a breakpoint with condition cond.
 void
 file_editor::request_open_file (const QString& openFileName,
                                 const QString& encoding,
                                 int line, bool debug_pointer,
@@ -313,17 +1338,17 @@ file_editor::request_open_file (const QS
     }
   else
     {
       // Check whether this file is already open in the editor.
       QWidget *tab = find_tab_widget (openFileName);
 
       if (tab)
         {
-          _tab_widget->setCurrentWidget (tab);
+          m_tab_widget->setCurrentWidget (tab);
 
           if (line > 0)
             {
               emit fetab_goto_line (tab, line);
 
               if (debug_pointer)
                 emit fetab_insert_debugger_pointer (tab, line);
 
@@ -462,1403 +1487,590 @@ file_editor::request_open_file (const QS
               // really show editor and the current editor tab
               focus ();
               emit file_loaded_signal ();
             }
         }
     }
 }
 
-// open a file from the mru list
-void
-file_editor::request_mru_open_file (QAction *action)
-{
-  if (action)
-    {
-      request_open_file (action->data ().toStringList ().at (0),
-                         action->data ().toStringList ().at (1));
-    }
-}
-
-void
-file_editor::check_conflict_save (const QString& saveFileName,
-                                  bool remove_on_success)
-{
-  // Check whether this file is already open in the editor.
-  QWidget *tab = find_tab_widget (saveFileName);
-
-  if (tab)
-    {
-      // Note: to overwrite the contents of some other file editor tab
-      // with the same name requires identifying which file editor tab
-      // that is (not too difficult) then close that tab.  Of course,
-      // that could trigger another dialog box if the file editor tab
-      // with the same name has modifications in it.  This could become
-      // somewhat confusing to the user.  For now, opt to do nothing.
-
-      // Create a NonModal message about error.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
-                           tr ("File not saved! A file with the selected name\n%1\n"
-                               "is already open in the editor").
-                           arg (saveFileName),
-                           QMessageBox::Ok, nullptr);
-
-      msgBox->setWindowModality (Qt::NonModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
-
-      return;
-    }
-
-  QObject *saveFileObject = sender ();
-  QWidget *saveFileWidget = nullptr;
-
-  for (int i = 0; i < _tab_widget->count (); i++)
-    {
-      if (_tab_widget->widget (i) == saveFileObject)
-        {
-          saveFileWidget = _tab_widget->widget (i);
-          break;
-        }
-    }
-  if (! saveFileWidget)
-    {
-      // Create a NonModal message about error.
-      QMessageBox *msgBox
-        = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
-                           tr ("The associated file editor tab has disappeared."),
-                           QMessageBox::Ok, nullptr);
-
-      msgBox->setWindowModality (Qt::NonModal);
-      msgBox->setAttribute (Qt::WA_DeleteOnClose);
-      msgBox->show ();
-
-      return;
-    }
-
-  // Can save without conflict, have the file editor tab do so.
-  emit fetab_save_file (saveFileWidget, saveFileName, remove_on_success);
-}
-
-void
-file_editor::handle_insert_debugger_pointer_request (const QString& file,
-                                                     int line)
-{
-  request_open_file (file, QString (), line, true); // default encoding
-}
-
-void
-file_editor::handle_delete_debugger_pointer_request (const QString& file,
-                                                     int line)
-{
-  if (! file.isEmpty ())
-    {
-      // Check whether this file is already open in the editor.
-      QWidget *tab = find_tab_widget (file);
-
-      if (tab)
-        {
-          _tab_widget->setCurrentWidget (tab);
-
-          if (line > 0)
-            emit fetab_delete_debugger_pointer (tab, line);
-
-          emit fetab_set_focus (tab);
-        }
-    }
-}
-
-void
-file_editor::handle_update_breakpoint_marker_request (bool insert,
-                                                      const QString& file,
-                                                      int line,
-                                                      const QString& cond)
-{
-  request_open_file (file, QString (), line, false, true, insert, cond);
-}
-
-void
-file_editor::handle_edit_file_request (const QString& file)
-{
-  request_open_file (file);
-}
-
-
-// Slot used for signals indicating that a file was changed/rename or
-// is going to be deleted/renamed
-void
-file_editor::handle_file_remove (const QString& old_name,
-                                 const QString& new_name)
-{
-  // Clear old lsit of files to reload
-  _tmp_closed_files.clear ();
-
-  // Check if old name is a file or directory
-  QFileInfo old (old_name);
-  if (old.isDir ())
-    {
-      // Call the function which handles directories and return
-      handle_dir_remove (old_name, new_name);
-      return;
-    }
-
-  // Is old file open?
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (find_tab_widget (old_name));
-
-  if (editor_tab)
-    {
-      // Yes, close it silently
-      _no_focus = true;  // Remember for not focussing editor
-      editor_tab->file_has_changed (QString (), true);  // Close the tab
-      _no_focus = false;  // Back to normal
-
-      _tmp_closed_files << old_name;  // for reloading if error removing
-
-      if (! new_name.isEmpty ())
-        _tmp_closed_files << new_name;  // store new name
-      else
-        _tmp_closed_files << ""; // no new name, just removing this file
-
-      // Get and store the related encoding
-      for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
-           p != editor_tab_map.end (); p++)
-        {
-          if (editor_tab == p->second.fet_ID)
-            {
-              _tmp_closed_files << p->second.encoding;
-              break;
-            }
-        }
-    }
-}
-
-
-// Function for closing the files in a removed directory
-void
-file_editor::handle_dir_remove (const QString& old_name,
-                                const QString& new_name)
-{
-  QDir old_dir (old_name);
-
-  // Have all file editor tabs signal what their filenames are.
-  editor_tab_map.clear ();
-  emit fetab_file_name_query (nullptr);
-
-  // Loop over all open files and pick those within old_dir
-  for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
-       p != editor_tab_map.end (); p++)
-    {
-      QString rel_path_to_file = old_dir.relativeFilePath (p->first);
-      if (rel_path_to_file.left (3) != QString ("../"))
-        {
-          // We directly go down from old_dir to reach our file: Our
-          // file is included in the removed/renamed diectory.
-          // Thus delete it.
-          _no_focus = true;  // Remember for not focussing editor
-          file_editor_tab *editor_tab
-              = static_cast<file_editor_tab *> (p->second.fet_ID);
-          editor_tab->file_has_changed (QString (), true);  // Close
-          _no_focus = false;  // Back to normal
-
-          // Store file for possible later reload
-          _tmp_closed_files << p->first;
-
-          // Add the new file path and the encoding for later reloading
-          // if new_name is given
-          if (! new_name.isEmpty ())
-            {
-              QDir new_dir (new_name);
-              _tmp_closed_files << new_dir.absoluteFilePath (rel_path_to_file);
-            }
-          else
-            _tmp_closed_files << ""; // no new name, just removing this file
-
-          _tmp_closed_files << p->second.encoding; // store the encoding
-        }
-    }
-}
-
-// Slot for signal indicating that a file was renamed
-void
-file_editor::handle_file_renamed (bool load_new)
-{
-  _no_focus = true;  // Remember for not focussing editor
-  for (int i = 0; i < _tmp_closed_files.count (); i = i + 3)
-    {
-      if (! _tmp_closed_files.at (i + load_new).isEmpty ())
-        request_open_file (_tmp_closed_files.at (i + load_new),
-                           _tmp_closed_files.at (i+2));
-    }
-  _no_focus = false;  // Back to normal focus
-}
-
-
-void
-file_editor::do_undo ()
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_UNDO);
-}
-
-void
-file_editor::request_redo (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_REDO);
-}
-
-void
-file_editor::copyClipboard ()
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_COPY);
-}
-
-void
-file_editor::request_cut (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_CUT);
-}
-
-void
-file_editor::pasteClipboard ()
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_PASTE);
-}
-
-void
-file_editor::selectAll ()
-{
-  if (editor_tab_has_focus ())
-    emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                  QsciScintillaBase::SCI_SELECTALL);
-}
-
-void
-file_editor::request_context_help (bool)
-{
-  emit fetab_context_help (_tab_widget->currentWidget (), false);
-}
-void
-file_editor::request_context_doc (bool)
-{
-  emit fetab_context_help (_tab_widget->currentWidget (), true);
-}
-
-void
-file_editor::request_context_edit (bool)
-{
-  emit fetab_context_edit (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_save_file (bool)
-{
-  emit fetab_save_file (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_save_file_as (bool)
-{
-  emit fetab_save_file_as (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_print_file (bool)
-{
-  emit fetab_print_file (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_run_file (bool)
-{
-  emit fetab_run_file (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_context_run (bool)
-{
-  emit fetab_context_run (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_toggle_bookmark (bool)
-{
-  emit fetab_toggle_bookmark (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_next_bookmark (bool)
-{
-  emit fetab_next_bookmark (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_previous_bookmark (bool)
-{
-  emit fetab_previous_bookmark (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_remove_bookmark (bool)
-{
-  emit fetab_remove_bookmark (_tab_widget->currentWidget ());
-}
-
-// FIXME: What should this do with conditional breakpoints?
-void
-file_editor::request_toggle_breakpoint (bool)
-{
-  emit fetab_toggle_breakpoint (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_next_breakpoint (bool)
-{
-  emit fetab_next_breakpoint (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_previous_breakpoint (bool)
-{
-  emit fetab_previous_breakpoint (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_remove_breakpoint (bool)
-{
-  emit fetab_remove_all_breakpoints (_tab_widget->currentWidget ());
-}
-
-// slots for Edit->Commands actions
-void
-file_editor::request_delete_start_word (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELWORDLEFT);
-}
-void
-file_editor::request_delete_end_word (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELWORDRIGHT);
-}
-void
-file_editor::request_delete_start_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELLINELEFT);
-}
-void
-file_editor::request_delete_end_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_DELLINERIGHT);
-}
-void
-file_editor::request_delete_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINEDELETE);
-}
-void
-file_editor::request_copy_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINECOPY);
-}
-void
-file_editor::request_cut_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINECUT);
-}
-void
-file_editor::request_duplicate_selection (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_SELECTIONDUPLICATE);
-}
-void
-file_editor::request_transpose_line (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LINETRANSPOSE);
-}
-void
-file_editor::request_comment_selected_text (bool)
-{
-  emit fetab_comment_selected_text (_tab_widget->currentWidget ());
-}
-void
-file_editor::request_uncomment_selected_text (bool)
-{
-  emit fetab_uncomment_selected_text (_tab_widget->currentWidget ());
-}
-
-// slots for Edit->Format actions
-void
-file_editor::request_upper_case (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_UPPERCASE);
-}
-void
-file_editor::request_lower_case (bool)
-{
-  emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciScintillaBase::SCI_LOWERCASE);
-}
-void
-file_editor::request_indent_selected_text (bool)
-{
-  emit fetab_indent_selected_text (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_unindent_selected_text (bool)
-{
-  emit fetab_unindent_selected_text (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_conv_eol_windows (bool)
-{
-  emit fetab_convert_eol (_tab_widget->currentWidget (),
-                          QsciScintilla::EolWindows);
-}
-void
-file_editor::request_conv_eol_unix (bool)
-{
-  emit fetab_convert_eol (_tab_widget->currentWidget (),
-                          QsciScintilla::EolUnix);
-}
-void
-file_editor::request_conv_eol_mac (bool)
-{
-  emit fetab_convert_eol (_tab_widget->currentWidget (),
-                          QsciScintilla::EolMac);
-}
-
-void
-file_editor::request_find (bool)
-{
-  emit fetab_find (_tab_widget->currentWidget (), _fetab_actions);
-}
-
-void
-file_editor::request_find_next (bool)
-{
-  emit fetab_find_next (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_find_previous (bool)
-{
-  emit fetab_find_previous (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_goto_line (bool)
-{
-  emit fetab_goto_line (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::request_move_match_brace (bool)
-{
-  emit fetab_move_match_brace (_tab_widget->currentWidget (), false);
-}
-
-void
-file_editor::request_sel_match_brace (bool)
-{
-  emit fetab_move_match_brace (_tab_widget->currentWidget (), true);
-}
-
-void
-file_editor::request_completion (bool)
-{
-  emit fetab_completion (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::handle_mru_add_file (const QString& file_name,
-                                  const QString& encoding)
-{
-  int index;
-  while ((index = _mru_files.indexOf (file_name)) >= 0)
-    {
-      _mru_files.removeAt (index);
-      _mru_files_encodings.removeAt (index);
-    }
-
-  _mru_files.prepend (file_name);
-  _mru_files_encodings.prepend (encoding);
-
-  mru_menu_update ();
-}
-
-void
-file_editor::mru_menu_update (void)
-{
-  int num_files = qMin (_mru_files.size (), int (MaxMRUFiles));
-
-  // configure and show active actions of mru-menu
-  for (int i = 0; i < num_files; ++i)
-    {
-      QString text = tr ("&%1 %2").
-                     arg ((i+1) % int (MaxMRUFiles)).arg (_mru_files.at (i));
-      _mru_file_actions[i]->setText (text);
-
-      QStringList action_data;
-      action_data << _mru_files.at (i) << _mru_files_encodings.at (i);
-      _mru_file_actions[i]->setData (action_data);
-
-      _mru_file_actions[i]->setVisible (true);
-    }
-
-  // hide unused mru-menu entries
-  for (int j = num_files; j < MaxMRUFiles; ++j)
-    _mru_file_actions[j]->setVisible (false);
-
-  // delete entries in string-list beyond MaxMRUFiles
-  while (_mru_files.size () > MaxMRUFiles)
-    {
-      _mru_files.removeLast ();
-      _mru_files_encodings.removeLast ();
-    }
-
-  // save actual mru-list in settings
-  QSettings *settings = resource_manager::get_settings ();
-
-  settings->setValue ("editor/mru_file_list", _mru_files);
-  settings->setValue ("editor/mru_file_encodings", _mru_files_encodings);
-  settings->sync ();
-}
-
-void
-file_editor::handle_file_name_changed (const QString& fname,
-                                       const QString& tip)
-{
-  QObject *fileEditorTab = sender ();
-  if (fileEditorTab)
-    {
-      for (int i = 0; i < _tab_widget->count (); i++)
-        {
-          if (_tab_widget->widget (i) == fileEditorTab)
-            {
-              _tab_widget->setTabText (i, fname);
-              _tab_widget->setTabToolTip (i, tip);
-            }
-        }
-    }
-}
-
-void
-file_editor::request_close_file (bool)
-{
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (_tab_widget->currentWidget ());
-  editor_tab->conditional_close ();
-}
-
-void
-file_editor::request_close_all_files (bool)
-{
-  file_editor_tab *editor_tab;
-
-  // loop over all tabs starting from last one otherwise deletion changes index
-  for (int index = _tab_widget->count ()-1; index >= 0; index--)
-    {
-      editor_tab = static_cast<file_editor_tab *> (_tab_widget->widget (index));
-      editor_tab->conditional_close ();
-    }
-}
-
-void
-file_editor::request_close_other_files (bool)
-{
-  file_editor_tab *editor_tab;
-  QWidget *tabID = _tab_widget->currentWidget ();
-
-  // loop over all tabs starting from last one otherwise deletion changes index
-  for (int index = _tab_widget->count ()-1; index >= 0; index--)
-    {
-      if (tabID != _tab_widget->widget (index))
-        {
-          editor_tab
-            = static_cast<file_editor_tab *> (_tab_widget->widget (index));
-          editor_tab->conditional_close ();
-        }
-    }
-}
-
-void
-file_editor::handle_tab_close_request (int index)
-{
-  file_editor_tab *editor_tab
-    = static_cast<file_editor_tab *> (_tab_widget->widget (index));
-  editor_tab->conditional_close ();
-}
-
-void
-file_editor::handle_tab_remove_request (void)
-{
-  QObject *fileEditorTab = sender ();
-  if (fileEditorTab)
-    {
-      for (int i = 0; i < _tab_widget->count (); i++)
-        {
-          if (_tab_widget->widget (i) == fileEditorTab)
-            {
-              _tab_widget->removeTab (i);
-              // Deleting sender is dodgy, but works because the signal
-              // is the last item in the sender's routines.
-              delete fileEditorTab;
-              break;
-            }
-        }
-    }
-  check_actions ();
-
-  focus ();     // focus stays in editor when tab is closed
-
-}
-
-void
-file_editor::handle_add_filename_to_list (const QString& fileName,
-                                          const QString& encoding, QWidget *ID)
-{
-  // Should we allow multiple tabs for a single file?
-  editor_tab_map[fileName].fet_ID = ID;
-  editor_tab_map[fileName].encoding = encoding;
-}
-
-// context menu of edit area
-void
-file_editor::active_tab_changed (int index)
-{
-  emit fetab_change_request (_tab_widget->widget (index));
-}
-
-void file_editor::create_context_menu (QMenu *menu)
-{
-  // remove all standard actions from scintilla
-  QList<QAction *> all_actions = menu->actions ();
-  QAction *a;
-
-  foreach (a, all_actions)
-    menu->removeAction (a);
-
-  // add editor's actions with icons and customized shortcuts
-  menu->addAction (_undo_action);
-  menu->addAction (_redo_action);
-  menu->addSeparator ();
-  menu->addAction (_cut_action);
-  menu->addAction (_copy_action);
-  menu->addAction (_paste_action);
-  menu->addSeparator ();
-  menu->addAction (_selectall_action);
-  menu->addSeparator ();
-  menu->addAction (_run_selection_action);
-}
-
-void
-file_editor::toggle_preference (const QString& preference, bool def)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  bool old = settings->value (preference,def).toBool ();
-  settings->setValue (preference,! old);
-  notice_settings (settings);
-}
-
-void
-file_editor::show_line_numbers (bool)
-{
-  toggle_preference ("editor/showLineNumbers",true);
-}
-void
-file_editor::show_white_space (bool)
-{
-  toggle_preference ("editor/show_white_space",false);
-}
-void
-file_editor::show_eol_chars (bool)
-{
-  toggle_preference ("editor/show_eol_chars",false);
-}
-void
-file_editor::show_indent_guides (bool)
-{
-  toggle_preference ("editor/show_indent_guides",false);
-}
-void
-file_editor::show_long_line (bool)
-{
-  toggle_preference ("editor/long_line_marker",true);
-}
-void
-file_editor::show_toolbar (bool)
-{
-  toggle_preference ("editor/show_toolbar",true);
-}
-void
-file_editor::show_statusbar (bool)
-{
-  toggle_preference ("editor/show_edit_status_bar",true);
-}
-void
-file_editor::show_hscrollbar (bool)
-{
-  toggle_preference ("editor/show_hscroll_bar",true);
-}
-
-void
-file_editor::zoom_in (bool)
-{
-  emit fetab_zoom_in (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::zoom_out (bool)
-{
-  emit fetab_zoom_out (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::zoom_normal (bool)
-{
-  emit fetab_zoom_normal (_tab_widget->currentWidget ());
-}
-
-void
-file_editor::edit_status_update (bool undo, bool redo)
-{
-  if (_undo_action)
-    _undo_action->setEnabled (undo);
-  _redo_action->setEnabled (redo);
-}
-
-void
-file_editor::handle_editor_state_changed (bool copy_available,
-                                          bool is_octave_file)
-{
-  // In case there is some scenario where traffic could be coming from
-  // all the file editor tabs, just process info from the current active tab.
-  if (sender () == _tab_widget->currentWidget ())
-    {
-      if (_copy_action)
-        _copy_action->setEnabled (copy_available);
-      _cut_action->setEnabled (copy_available);
-      _run_selection_action->setEnabled (copy_available);
-      _run_action->setEnabled (is_octave_file);
-
-      setFocusProxy (_tab_widget->currentWidget ());
-    }
-}
-
-void
-file_editor::notice_settings (const QSettings *settings)
-{
-  int icon_size_settings = settings->value ("toolbar_icon_size",0).toInt ();
-  QStyle *st = style ();
-  int icon_size = st->pixelMetric (QStyle::PM_ToolBarIconSize);
-
-  if (icon_size_settings == 1)
-    icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
-  else if (icon_size_settings == -1)
-    icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
-
-  _tool_bar->setIconSize (QSize (icon_size,icon_size));
-
-  int tab_width_min = settings->value ("editor/notebook_tab_width_min", 160)
-                                      .toInt ();
-  int tab_width_max = settings->value ("editor/notebook_tab_width_max", 300)
-                                      .toInt ();
-
-  if (settings->value ("editor/longWindowTitle", false).toBool ())
-    {
-      QString style_sheet = QString ("QTabBar::tab "
-                                     "{min-width: %1px; max-width: %2px;}")
-                             .arg (tab_width_min).arg (tab_width_max);
-      _tab_widget->setElideMode (Qt::ElideLeft);
-      _tab_widget->setStyleSheet (style_sheet);
-    }
-  else
-    _tab_widget->setElideMode (Qt::ElideNone);
-
-  _tab_widget->setUsesScrollButtons (true);
-
-  bool show_it;
-  show_it = settings->value ("editor/showLineNumbers",true).toBool ();
-  _show_linenum_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_white_space",false).toBool ();
-  _show_whitespace_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_eol_chars",false).toBool ();
-  _show_eol_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_indent_guides",false).toBool ();
-  _show_indguide_action->setChecked (show_it);
-  show_it = settings->value ("editor/long_line_marker",true).toBool ();
-  _show_longline_action->setChecked (show_it);
-
-  show_it = settings->value ("editor/show_toolbar",true).toBool ();
-  _show_toolbar_action->setChecked (show_it);
-  _tool_bar->setVisible (show_it);
-  show_it = settings->value ("editor/show_edit_status_bar",true).toBool ();
-  _show_statusbar_action->setChecked (show_it);
-  show_it = settings->value ("editor/show_hscroll_bar",true).toBool ();
-  _show_hscrollbar_action->setChecked (show_it);
-
-  set_shortcuts ();
-
-  // Relay signal to file editor tabs.
-  emit fetab_settings_changed (settings);
-}
-
 void
 file_editor::request_preferences (bool)
 {
   emit request_settings_dialog ("editor");
 }
 
 void
 file_editor::request_styles_preferences (bool)
 {
   emit request_settings_dialog ("editor_styles");
 }
 
-// insert global actions, that should also be displayed in the editor window,
-// into the editor's menu and/or toolbar
+void
+file_editor::show_line_numbers (bool)
+{
+  toggle_preference ("editor/showLineNumbers",true);
+}
+
+void
+file_editor::show_white_space (bool)
+{
+  toggle_preference ("editor/show_white_space",false);
+}
+
 void
-file_editor::insert_global_actions (QList<QAction*> shared_actions)
+file_editor::show_eol_chars (bool)
+{
+  toggle_preference ("editor/show_eol_chars",false);
+}
+
+void
+file_editor::show_indent_guides (bool)
+{
+  toggle_preference ("editor/show_indent_guides",false);
+}
+
+void
+file_editor::show_long_line (bool)
+{
+  toggle_preference ("editor/long_line_marker",true);
+}
+
+void
+file_editor::show_toolbar (bool)
 {
-  // actions/menus that have to be added to the toolbar or the menu
-  QAction *open_action = shared_actions.at (OPEN_ACTION);
-  QAction *new_action = shared_actions.at (NEW_SCRIPT_ACTION);
-  QAction *new_fcn_action = shared_actions.at (NEW_FUNCTION_ACTION);
-  _fileMenu->insertAction (_mru_file_menu->menuAction (), open_action);
-  _fileMenu->insertAction (open_action, new_fcn_action);
-  _fileMenu->insertAction (new_fcn_action, new_action);
-  _tool_bar->insertAction (_popdown_mru_action, open_action);
-  _tool_bar->insertAction (open_action, new_action);
-
-  // actions that are additionally enabled/disabled later by the editor
-  // undo
-  _undo_action = shared_actions.at (UNDO_ACTION);
-  _tool_bar->insertAction (_redo_action,_undo_action);
-  _edit_menu->insertAction (_redo_action,_undo_action);
-  // copy
-  _copy_action = shared_actions.at (COPY_ACTION);
-  _tool_bar->insertAction (_cut_action,_copy_action);
-  _edit_menu->insertAction (_cut_action,_copy_action);
-  // select all
-  _selectall_action = shared_actions.at (SELECTALL_ACTION);
-  _edit_menu->insertAction (_find_action,_selectall_action);
-  _edit_menu->insertSeparator (_find_action);
-  // paste
-  _paste_action = shared_actions.at (PASTE_ACTION);
-  _tool_bar->insertAction (_find_action,_paste_action);
-  _edit_menu->insertAction (_selectall_action,_paste_action);
-  _edit_menu->insertSeparator (_selectall_action);
-  // find files
-  _find_files_action = shared_actions.at (FIND_FILES_ACTION);
-  _edit_menu->insertAction (_find_action, _find_files_action);
+  toggle_preference ("editor/show_toolbar",true);
+}
+
+void
+file_editor::show_statusbar (bool)
+{
+  toggle_preference ("editor/show_edit_status_bar",true);
+}
+
+void
+file_editor::show_hscrollbar (bool)
+{
+  toggle_preference ("editor/show_hscroll_bar",true);
+}
+
+void
+file_editor::zoom_in (bool)
+{
+  emit fetab_zoom_in (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::zoom_out (bool)
+{
+  emit fetab_zoom_out (m_tab_widget->currentWidget ());
+}
+
+void
+file_editor::zoom_normal (bool)
+{
+  emit fetab_zoom_normal (m_tab_widget->currentWidget ());
+}
+
+// slots for tab navigation
+void
+file_editor::switch_left_tab (void)
+{
+  switch_tab (-1);
 }
 
-QAction*
-file_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                         const char *member)
+void
+file_editor::switch_right_tab (void)
+{
+  switch_tab (1);
+}
+
+void
+file_editor::move_tab_left (void)
 {
-  QAction *a;
-
-  if (menu)
-    a = menu->addAction (icon, text, this, member);
-  else
-    {
-      a = new QAction (this);
-      connect (a, SIGNAL (triggered ()), this, member);
-    }
-
-  addAction (a);  // important for shortcut context
-  a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
-
-  return a;
+#if defined (HAVE_QTABWIDGET_SETMOVABLE)
+  switch_tab (-1, true);
+#endif
+}
+
+void
+file_editor::move_tab_right (void)
+{
+#if defined (HAVE_QTABWIDGET_SETMOVABLE)
+  switch_tab (1, true);
+#endif
 }
 
-// function enabling/disabling the menu accelerators depending on the
-// focus of the editor
 void
-file_editor::enable_menu_shortcuts (bool enable)
+file_editor::create_context_menu (QMenu *menu)
 {
-  QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin ();
-
-  while (i != _hash_menu_text.constEnd ())
+  // remove all standard actions from scintilla
+  QList<QAction *> all_actions = menu->actions ();
+  QAction *a;
+
+  foreach (a, all_actions)
+    menu->removeAction (a);
+
+  // add editor's actions with icons and customized shortcuts
+  menu->addAction (m_undo_action);
+  menu->addAction (m_redo_action);
+  menu->addSeparator ();
+  menu->addAction (m_cut_action);
+  menu->addAction (m_copy_action);
+  menu->addAction (m_paste_action);
+  menu->addSeparator ();
+  menu->addAction (m_selectall_action);
+  menu->addSeparator ();
+  menu->addAction (m_run_selection_action);
+}
+
+void
+file_editor::edit_status_update (bool undo, bool redo)
+{
+  if (m_undo_action)
+    m_undo_action->setEnabled (undo);
+  m_redo_action->setEnabled (redo);
+}
+
+// handler for the close event
+void
+file_editor::closeEvent (QCloseEvent *e)
+{
+  QSettings *settings = resource_manager::get_settings ();
+  if (settings->value ("editor/hiding_closes_files",false).toBool ())
     {
-      i.key ()->setTitle (i.value ().at (! enable));
-      ++i;
+      if (check_closing ())
+        {
+          // all tabs are closed without cancelling,
+          // store closing state for restoring session when shown again
+          m_closed = true;
+          e->accept ();
+        }
+      else
+        e->ignore ();
     }
-
-  // when editor loses focus, enable the actions, which are always active
-  // in the main window due to missing info on selected text and undo actions
-  if (! enable && _copy_action && _undo_action)
+  else
+   e->accept ();
+}
+
+void
+file_editor::dragEnterEvent (QDragEnterEvent *e)
+{
+  if (e->mimeData ()->hasUrls ())
     {
-      _copy_action->setEnabled (true);
-      _undo_action->setEnabled (true);
+      e->acceptProposedAction ();
     }
 }
 
-QMenu*
-file_editor::m_add_menu (QMenuBar *p, QString name)
+void
+file_editor::dropEvent (QDropEvent *e)
+{
+  if (e->mimeData ()->hasUrls ())
+    {
+      foreach (QUrl url, e->mimeData ()->urls ())
+        request_open_file (url.toLocalFile ());
+    }
+}
+
+bool
+file_editor::is_editor_console_tabbed (void)
 {
-  QMenu *menu = p->addMenu (name);
-
-  QString base_name = name;  // get a copy
-  // replace intended '&' ("&&") by a temp. string
-  base_name.replace ("&&", "___octave_amp_replacement___");
-  // remove single '&' (shortcut)
-  base_name.remove ("&");
-  // restore intended '&'
-  base_name.replace ("___octave_amp_replacement___", "&&");
-
-  // remember names with and without shortcut
-  _hash_menu_text[menu] = QStringList () << name << base_name;
-
-  return menu;
+  main_window *w = static_cast<main_window *>(main_win ());
+  QList<QDockWidget *> w_list = w->tabifiedDockWidgets (this);
+  QDockWidget *console =
+    static_cast<QDockWidget *> (w->get_dock_widget_list ().at (0));
+
+  for (int i = 0; i < w_list.count (); i++)
+    {
+      if (w_list.at (i) == console)
+        return true;
+    }
+
+  return false;
 }
 
 void
 file_editor::construct (void)
 {
   QWidget *editor_widget = new QWidget (this);
 
   // FIXME: what was the intended purpose of this unused variable?
   // QStyle *editor_style = QApplication::style ();
-  _menu_bar = new QMenuBar (editor_widget);
+  m_menu_bar = new QMenuBar (editor_widget);
 #if defined (Q_OS_MAC)
-  _menu_bar->setNativeMenuBar (false);
+  m_menu_bar->setNativeMenuBar (false);
 #endif
-  _tool_bar = new QToolBar (editor_widget);
-  _tool_bar->setMovable (true);
-
-  _tab_widget = new file_editor_tab_widget (editor_widget);
-  _tab_widget->setTabsClosable (true);
+  m_tool_bar = new QToolBar (editor_widget);
+  m_tool_bar->setMovable (true);
+
+  m_tab_widget = new file_editor_tab_widget (editor_widget);
+  m_tab_widget->setTabsClosable (true);
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  _tab_widget->setMovable (true);
+  m_tab_widget->setMovable (true);
 #endif
 
   // the mru-list and an empty array of actions
   QSettings *settings = resource_manager::get_settings ();
-  _mru_files = settings->value ("editor/mru_file_list").toStringList ();
-  _mru_files_encodings = settings->value ("editor/mru_file_encodings")
+  m_mru_files = settings->value ("editor/mru_file_list").toStringList ();
+  m_mru_files_encodings = settings->value ("editor/mru_file_encodings")
                                    .toStringList ();
 
-  if (_mru_files_encodings.count () != _mru_files.count ())
+  if (m_mru_files_encodings.count () != m_mru_files.count ())
     {
       // encodings don't have the same count -> do not use them!
-      _mru_files_encodings = QStringList ();
-      for (int i = 0; i < _mru_files.count (); i++)
-        _mru_files_encodings << QString ();
+      m_mru_files_encodings = QStringList ();
+      for (int i = 0; i < m_mru_files.count (); i++)
+        m_mru_files_encodings << QString ();
     }
 
   for (int i = 0; i < MaxMRUFiles; ++i)
     {
-      _mru_file_actions[i] = new QAction (this);
-      _mru_file_actions[i]->setVisible (false);
+      m_mru_file_actions[i] = new QAction (this);
+      m_mru_file_actions[i]->setVisible (false);
     }
 
   // menu bar
 
   // file menu
 
-  _fileMenu = m_add_menu (_menu_bar, tr ("&File"));
+  m_fileMenu = add_menu (m_menu_bar, tr ("&File"));
 
   // new and open menus are inserted later by the main window
-  _mru_file_menu = new QMenu (tr ("&Recent Editor Files"), _fileMenu);
+  m_mru_file_menu = new QMenu (tr ("&Recent Editor Files"), m_fileMenu);
   for (int i = 0; i < MaxMRUFiles; ++i)
-    _mru_file_menu->addAction (_mru_file_actions[i]);
-  _fileMenu->addMenu (_mru_file_menu);
-
-  _fileMenu->addSeparator ();
-
-  _edit_function_action = add_action (_fileMenu, QIcon (),
+    m_mru_file_menu->addAction (m_mru_file_actions[i]);
+  m_fileMenu->addMenu (m_mru_file_menu);
+
+  m_fileMenu->addSeparator ();
+
+  m_edit_function_action = add_action (m_fileMenu, QIcon (),
           tr ("&Edit Function"), SLOT (request_context_edit (bool)));
 
-  _fileMenu->addSeparator ();
-
-  _save_action = add_action (_fileMenu, resource_manager::icon ("document-save"),
+  m_fileMenu->addSeparator ();
+
+  m_save_action = add_action (m_fileMenu, resource_manager::icon ("document-save"),
           tr ("&Save File"), SLOT (request_save_file (bool)));
-  _save_as_action = add_action (_fileMenu, resource_manager::icon ("document-save-as"),
+  m_save_as_action = add_action (m_fileMenu, resource_manager::icon ("document-save-as"),
           tr ("Save File &As..."), SLOT (request_save_file_as (bool)));
 
-  _fileMenu->addSeparator ();
-
-  _close_action = add_action (_fileMenu, resource_manager::icon ("window-close",false),
+  m_fileMenu->addSeparator ();
+
+  m_close_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
           tr ("&Close"), SLOT (request_close_file (bool)));
-  _close_all_action = add_action (_fileMenu, resource_manager::icon ("window-close",false),
+  m_close_all_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
           tr ("Close All"), SLOT (request_close_all_files (bool)));
-  _close_others_action = add_action (_fileMenu, resource_manager::icon ("window-close",false),
+  m_close_others_action = add_action (m_fileMenu, resource_manager::icon ("window-close",false),
           tr ("Close Other Files"), SLOT (request_close_other_files (bool)));
 
-  _fileMenu->addSeparator ();
-
-  _print_action = add_action (_fileMenu, resource_manager::icon ("document-print"),
+  m_fileMenu->addSeparator ();
+
+  m_print_action = add_action (m_fileMenu, resource_manager::icon ("document-print"),
           tr ("Print..."), SLOT (request_print_file (bool)));
 
   // edit menu (undo, copy, paste and select all later via main window)
 
-  _edit_menu = m_add_menu (_menu_bar, tr ("&Edit"));
-
-  _redo_action = add_action (_edit_menu, resource_manager::icon ("edit-redo"),
+  m_edit_menu = add_menu (m_menu_bar, tr ("&Edit"));
+
+  m_redo_action = add_action (m_edit_menu, resource_manager::icon ("edit-redo"),
           tr ("&Redo"), SLOT (request_redo (bool)));
-  _redo_action->setEnabled (false);
-
-  _edit_menu->addSeparator ();
-
-  _cut_action = add_action (_edit_menu, resource_manager::icon ("edit-cut"),
+  m_redo_action->setEnabled (false);
+
+  m_edit_menu->addSeparator ();
+
+  m_cut_action = add_action (m_edit_menu, resource_manager::icon ("edit-cut"),
           tr ("Cu&t"), SLOT (request_cut (bool)));
-  _cut_action->setEnabled (false);
-
-  _find_action = add_action (_edit_menu, resource_manager::icon ("edit-find-replace"),
+  m_cut_action->setEnabled (false);
+
+  m_find_action = add_action (m_edit_menu, resource_manager::icon ("edit-find-replace"),
           tr ("&Find and Replace..."), SLOT (request_find (bool)));
 
-  _find_next_action = add_action (_edit_menu, QIcon (),
+  m_find_next_action = add_action (m_edit_menu, QIcon (),
           tr ("Find &Next..."), SLOT (request_find_next (bool)));
 
-  _find_previous_action = add_action (_edit_menu, QIcon (),
+  m_find_previous_action = add_action (m_edit_menu, QIcon (),
           tr ("Find &Previous..."), SLOT (request_find_previous (bool)));
 
-  _edit_menu->addSeparator ();
-
-  _edit_cmd_menu = _edit_menu->addMenu (tr ("&Commands"));
-
-  _delete_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_edit_menu->addSeparator ();
+
+  m_edit_cmd_menu = m_edit_menu->addMenu (tr ("&Commands"));
+
+  m_delete_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Delete Line"), SLOT (request_delete_line (bool)));
-  _copy_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_copy_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Copy Line"), SLOT (request_copy_line (bool)));
-  _cut_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_cut_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Cut Line"), SLOT (request_cut_line (bool)));
 
-  _edit_cmd_menu->addSeparator ();
-
-  _delete_start_word_action = add_action (_edit_cmd_menu, QIcon (),
+  m_edit_cmd_menu->addSeparator ();
+
+  m_delete_start_word_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Delete to Start of Word"), SLOT (request_delete_start_word (bool)));
-  _delete_end_word_action = add_action (_edit_cmd_menu, QIcon (),
+  m_delete_end_word_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Delete to End of Word"), SLOT (request_delete_end_word (bool)));
-  _delete_start_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_delete_start_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Delete to Start of Line"), SLOT (request_delete_start_line (bool)));
-  _delete_end_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_delete_end_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Delete to End of Line"), SLOT (request_delete_end_line (bool)));
 
-  _edit_cmd_menu->addSeparator ();
-
-  _duplicate_selection_action = add_action (_edit_cmd_menu, QIcon (),
+  m_edit_cmd_menu->addSeparator ();
+
+  m_duplicate_selection_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Duplicate Selection/Line"), SLOT (request_duplicate_selection (bool)));
-  _transpose_line_action = add_action (_edit_cmd_menu, QIcon (),
+  m_transpose_line_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("Transpose Line"), SLOT (request_transpose_line (bool)));
 
-  _edit_cmd_menu->addSeparator ();
-
-  _completion_action = add_action (_edit_cmd_menu, QIcon (),
+  m_edit_cmd_menu->addSeparator ();
+
+  m_completion_action = add_action (m_edit_cmd_menu, QIcon (),
           tr ("&Show Completion List"), SLOT (request_completion (bool)));
 
-  _edit_fmt_menu = _edit_menu->addMenu (tr ("&Format"));
-
-  _upper_case_action = add_action (_edit_fmt_menu, QIcon (),
+  m_edit_fmt_menu = m_edit_menu->addMenu (tr ("&Format"));
+
+  m_upper_case_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Uppercase Selection"), SLOT (request_upper_case (bool)));
-  _lower_case_action = add_action (_edit_fmt_menu, QIcon (),
+  m_lower_case_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Lowercase Selection"), SLOT (request_lower_case (bool)));
 
-  _edit_fmt_menu->addSeparator ();
-
-  _comment_selection_action = add_action (_edit_fmt_menu, QIcon (),
+  m_edit_fmt_menu->addSeparator ();
+
+  m_comment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Comment"), SLOT (request_comment_selected_text (bool)));
-  _uncomment_selection_action = add_action (_edit_fmt_menu, QIcon (),
+  m_uncomment_selection_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Uncomment"), SLOT (request_uncomment_selected_text (bool)));
 
-  _edit_fmt_menu->addSeparator ();
-
-  _indent_selection_action = add_action (_edit_fmt_menu, QIcon (),
+  m_edit_fmt_menu->addSeparator ();
+
+  m_indent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Indent"), SLOT (request_indent_selected_text (bool)));
-  _unindent_selection_action = add_action (_edit_fmt_menu, QIcon (),
+  m_unindent_selection_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("&Unindent"), SLOT (request_unindent_selected_text (bool)));
 
-  _edit_fmt_menu->addSeparator ();
-
-  _conv_eol_windows_action = add_action (_edit_fmt_menu, QIcon (),
+  m_edit_fmt_menu->addSeparator ();
+
+  m_conv_eol_windows_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("Convert Line Endings to &Windows (CRLF)"),
           SLOT (request_conv_eol_windows (bool)));
-  _conv_eol_unix_action = add_action (_edit_fmt_menu, QIcon (),
+  m_conv_eol_unix_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("Convert Line Endings to &Unix (LF)"),
           SLOT (request_conv_eol_unix (bool)));
-  _conv_eol_mac_action = add_action (_edit_fmt_menu, QIcon (),
+  m_conv_eol_mac_action = add_action (m_edit_fmt_menu, QIcon (),
           tr ("Convert Line Endings to &Mac (CR)"),
           SLOT (request_conv_eol_mac (bool)));
 
-  _edit_nav_menu = _edit_menu->addMenu (tr ("Navi&gation"));
-
-  _goto_line_action = add_action (_edit_nav_menu, QIcon (),
+  m_edit_nav_menu = m_edit_menu->addMenu (tr ("Navi&gation"));
+
+  m_goto_line_action = add_action (m_edit_nav_menu, QIcon (),
           tr ("Go &to Line..."), SLOT (request_goto_line (bool)));
 
-  _edit_cmd_menu->addSeparator ();
-
-  _move_to_matching_brace = add_action (_edit_nav_menu, QIcon (),
+  m_edit_cmd_menu->addSeparator ();
+
+  m_move_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
           tr ("Move to Matching Brace"), SLOT (request_move_match_brace (bool)));
-  _sel_to_matching_brace = add_action (_edit_nav_menu, QIcon (),
+  m_sel_to_matching_brace = add_action (m_edit_nav_menu, QIcon (),
           tr ("Select to Matching Brace"), SLOT (request_sel_match_brace (bool)));
 
-  _edit_nav_menu->addSeparator ();
-
-  _next_bookmark_action = add_action (_edit_nav_menu, QIcon (),
+  m_edit_nav_menu->addSeparator ();
+
+  m_next_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
           tr ("&Next Bookmark"), SLOT (request_next_bookmark (bool)));
-  _previous_bookmark_action = add_action (_edit_nav_menu, QIcon (),
+  m_previous_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
           tr ("Pre&vious Bookmark"), SLOT (request_previous_bookmark (bool)));
-  _toggle_bookmark_action = add_action (_edit_nav_menu, QIcon (),
+  m_toggle_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
           tr ("Toggle &Bookmark"), SLOT (request_toggle_bookmark (bool)));
-  _remove_bookmark_action = add_action (_edit_nav_menu, QIcon (),
+  m_remove_bookmark_action = add_action (m_edit_nav_menu, QIcon (),
           tr ("&Remove All Bookmarks"), SLOT (request_remove_bookmark (bool)));
 
-  _edit_menu->addSeparator ();
-
-  _preferences_action = add_action (_edit_menu, resource_manager::icon ("preferences-system"),
+  m_edit_menu->addSeparator ();
+
+  m_preferences_action = add_action (m_edit_menu, resource_manager::icon ("preferences-system"),
           tr ("&Preferences..."), SLOT (request_preferences (bool)));
-  _styles_preferences_action = add_action (_edit_menu,  resource_manager::icon ("preferences-system"),
+  m_styles_preferences_action = add_action (m_edit_menu,  resource_manager::icon ("preferences-system"),
           tr ("&Styles Preferences..."), SLOT (request_styles_preferences (bool)));
 
   // view menu
 
-  QMenu *view_menu = m_add_menu (_menu_bar, tr ("&View"));
-
-  _view_editor_menu = view_menu->addMenu (tr ("&Editor"));
-
-  _show_linenum_action = add_action (_view_editor_menu, QIcon (),
+  QMenu *view_menu = add_menu (m_menu_bar, tr ("&View"));
+
+  m_view_editor_menu = view_menu->addMenu (tr ("&Editor"));
+
+  m_show_linenum_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Line Numbers"), SLOT (show_line_numbers (bool)));
-  _show_linenum_action->setCheckable (true);
-
-  _show_whitespace_action = add_action (_view_editor_menu, QIcon (),
+  m_show_linenum_action->setCheckable (true);
+
+  m_show_whitespace_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Whitespace Characters"), SLOT (show_white_space (bool)));
-  _show_whitespace_action->setCheckable (true);
-
-  _show_eol_action = add_action (_view_editor_menu, QIcon (),
+  m_show_whitespace_action->setCheckable (true);
+
+  m_show_eol_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show Line &Endings"), SLOT (show_eol_chars (bool)));
-  _show_eol_action->setCheckable (true);
-
-  _show_indguide_action = add_action (_view_editor_menu, QIcon (),
+  m_show_eol_action->setCheckable (true);
+
+  m_show_indguide_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Indentation Guides"), SLOT (show_indent_guides (bool)));
-  _show_indguide_action->setCheckable (true);
-
-  _show_longline_action = add_action (_view_editor_menu, QIcon (),
+  m_show_indguide_action->setCheckable (true);
+
+  m_show_longline_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show Long Line &Marker"), SLOT (show_long_line (bool)));
-  _show_longline_action->setCheckable (true);
-
-  _view_editor_menu->addSeparator ();
-
-  _show_toolbar_action = add_action (_view_editor_menu, QIcon (),
+  m_show_longline_action->setCheckable (true);
+
+  m_view_editor_menu->addSeparator ();
+
+  m_show_toolbar_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Toolbar"), SLOT (show_toolbar (bool)));
-  _show_toolbar_action->setCheckable (true);
-
-  _show_statusbar_action = add_action (_view_editor_menu, QIcon (),
+  m_show_toolbar_action->setCheckable (true);
+
+  m_show_statusbar_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Statusbar"), SLOT (show_statusbar (bool)));
-  _show_statusbar_action->setCheckable (true);
-
-  _show_hscrollbar_action = add_action (_view_editor_menu, QIcon (),
+  m_show_statusbar_action->setCheckable (true);
+
+  m_show_hscrollbar_action = add_action (m_view_editor_menu, QIcon (),
           tr ("Show &Horizontal Scrollbar"), SLOT (show_hscrollbar (bool)));
-  _show_hscrollbar_action->setCheckable (true);
+  m_show_hscrollbar_action->setCheckable (true);
 
   view_menu->addSeparator ();
 
-  _zoom_in_action = add_action (view_menu, resource_manager::icon ("zoom-in"),
+  m_zoom_in_action = add_action (view_menu, resource_manager::icon ("zoom-in"),
           tr ("Zoom &In"), SLOT (zoom_in (bool)));
-  _zoom_out_action = add_action (view_menu, resource_manager::icon ("zoom-out"),
+  m_zoom_out_action = add_action (view_menu, resource_manager::icon ("zoom-out"),
           tr ("Zoom &Out"), SLOT (zoom_out (bool)));
-  _zoom_normal_action = add_action (view_menu,  QIcon (),
+  m_zoom_normal_action = add_action (view_menu,  QIcon (),
           tr ("&Normal Size"), SLOT (zoom_normal (bool)));
 
-  _menu_bar->addMenu (view_menu);
+  m_menu_bar->addMenu (view_menu);
 
   // debug menu
 
-  _debug_menu = m_add_menu (_menu_bar, tr ("&Debug"));
-
-  _toggle_breakpoint_action = add_action (_debug_menu,
+  m_debug_menu = add_menu (m_menu_bar, tr ("&Debug"));
+
+  m_toggle_breakpoint_action = add_action (m_debug_menu,
           resource_manager::icon ("bp-toggle"), tr ("Toggle &Breakpoint"),
           SLOT (request_toggle_breakpoint (bool)));
-  _next_breakpoint_action = add_action (_debug_menu,
+  m_next_breakpoint_action = add_action (m_debug_menu,
           resource_manager::icon ("bp-next"), tr ("&Next Breakpoint"),
           SLOT (request_next_breakpoint (bool)));
-  _previous_breakpoint_action = add_action (_debug_menu,
+  m_previous_breakpoint_action = add_action (m_debug_menu,
           resource_manager::icon ("bp-prev"), tr ("Pre&vious Breakpoint"),
           SLOT (request_previous_breakpoint (bool)));
-  _remove_all_breakpoints_action = add_action (_debug_menu,
+  m_remove_all_breakpoints_action = add_action (m_debug_menu,
           resource_manager::icon ("bp-rm-all"), tr ("&Remove All Breakpoints"),
           SLOT (request_remove_breakpoint (bool)));
 
-  _debug_menu->addSeparator ();
+  m_debug_menu->addSeparator ();
 
   // The other debug actions will be added by the main window.
 
   // run menu
 
-  QMenu *_run_menu = m_add_menu (_menu_bar, tr ("&Run"));
-
-  _run_action = add_action (_run_menu,  resource_manager::icon ("system-run"),
+  QMenu *_run_menu = add_menu (m_menu_bar, tr ("&Run"));
+
+  m_run_action = add_action (_run_menu,  resource_manager::icon ("system-run"),
           tr ("Save File and Run"), SLOT (request_run_file (bool)));
-  _run_selection_action = add_action (_run_menu, QIcon (),
+  m_run_selection_action = add_action (_run_menu, QIcon (),
           tr ("Run &Selection"), SLOT (request_context_run (bool)));
-  _run_selection_action->setEnabled (false);
+  m_run_selection_action->setEnabled (false);
 
   // help menu
 
-  QMenu *_help_menu = m_add_menu (_menu_bar, tr ("&Help"));
-
-  _context_help_action = add_action (_help_menu, QIcon (),
+  QMenu *_help_menu = add_menu (m_menu_bar, tr ("&Help"));
+
+  m_context_help_action = add_action (_help_menu, QIcon (),
           tr ("&Help on Keyword"), SLOT (request_context_help (bool)));
-  _context_doc_action = add_action (_help_menu, QIcon (),
+  m_context_doc_action = add_action (_help_menu, QIcon (),
           tr ("&Documentation on Keyword"), SLOT (request_context_doc (bool)));
 
   // tab navigation (no menu, only actions)
 
-  _switch_left_tab_action = add_action (nullptr, QIcon (), "",
-                                        SLOT (switch_left_tab ()));
-  _switch_right_tab_action = add_action (nullptr, QIcon (), "",
-                                         SLOT (switch_right_tab ()));
-  _move_tab_left_action = add_action (nullptr, QIcon (), "",
-                                      SLOT (move_tab_left ()));
-  _move_tab_right_action = add_action (nullptr, QIcon (), "",
-                                       SLOT (move_tab_right ()));
+  m_switch_left_tab_action = add_action (nullptr, QIcon (), "",
+                                        SLOT (switch_left_tab (void)));
+  m_switch_right_tab_action = add_action (nullptr, QIcon (), "",
+                                         SLOT (switch_right_tab (void)));
+  m_move_tab_left_action = add_action (nullptr, QIcon (), "",
+                                      SLOT (move_tab_left (void)));
+  m_move_tab_right_action = add_action (nullptr, QIcon (), "",
+                                       SLOT (move_tab_right (void)));
 
   // toolbar
 
   // popdown menu with mru files
   QToolButton *popdown_button = new QToolButton ();
   popdown_button->setToolTip (tr ("Recent Files"));
-  popdown_button->setMenu (_mru_file_menu);
+  popdown_button->setMenu (m_mru_file_menu);
   popdown_button->setPopupMode (QToolButton::InstantPopup);
   popdown_button->setToolButtonStyle (Qt::ToolButtonTextOnly);
 
   // new and open actions are inserted later from main window
-  _popdown_mru_action = _tool_bar->addWidget (popdown_button);
-  _tool_bar->addAction (_save_action);
-  _tool_bar->addAction (_save_as_action);
-  _tool_bar->addAction (_print_action);
-  _tool_bar->addSeparator ();
-  // _undo_action: later via main window
-  _tool_bar->addAction (_redo_action);
-  // _copy_action: later via the main window
-  _tool_bar->addAction (_cut_action);
-  // _paste_action: later via the main window
-  _tool_bar->addAction (_find_action);
-  //_tool_bar->addAction (_find_next_action);
-  //_tool_bar->addAction (_find_previous_action);
-  _tool_bar->addSeparator ();
-  _tool_bar->addAction (_run_action);
-  _tool_bar->addSeparator ();
-  _tool_bar->addAction (_toggle_breakpoint_action);
-  _tool_bar->addAction (_previous_breakpoint_action);
-  _tool_bar->addAction (_next_breakpoint_action);
-  _tool_bar->addAction (_remove_all_breakpoints_action);
+  m_popdown_mru_action = m_tool_bar->addWidget (popdown_button);
+  m_tool_bar->addAction (m_save_action);
+  m_tool_bar->addAction (m_save_as_action);
+  m_tool_bar->addAction (m_print_action);
+  m_tool_bar->addSeparator ();
+  // m_undo_action: later via main window
+  m_tool_bar->addAction (m_redo_action);
+  // m_copy_action: later via the main window
+  m_tool_bar->addAction (m_cut_action);
+  // m_paste_action: later via the main window
+  m_tool_bar->addAction (m_find_action);
+  //m_tool_bar->addAction (m_find_next_action);
+  //m_tool_bar->addAction (m_find_previous_action);
+  m_tool_bar->addSeparator ();
+  m_tool_bar->addAction (m_run_action);
+  m_tool_bar->addSeparator ();
+  m_tool_bar->addAction (m_toggle_breakpoint_action);
+  m_tool_bar->addAction (m_previous_breakpoint_action);
+  m_tool_bar->addAction (m_next_breakpoint_action);
+  m_tool_bar->addAction (m_remove_all_breakpoints_action);
 
   // layout
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
-  vbox_layout->addWidget (_menu_bar);
-  vbox_layout->addWidget (_tool_bar);
-  vbox_layout->addWidget (_tab_widget);
+  vbox_layout->addWidget (m_menu_bar);
+  vbox_layout->addWidget (m_tool_bar);
+  vbox_layout->addWidget (m_tab_widget);
   vbox_layout->setMargin (0);
   editor_widget->setLayout (vbox_layout);
   setWidget (editor_widget);
 
   // create the context menu of the tab bar
   file_editor_tab_bar *bar
-      = static_cast<file_editor_tab_bar *>(_tab_widget->tabBar ());
+      = static_cast<file_editor_tab_bar *>(m_tab_widget->tabBar ());
   QList<QAction *> tab_bar_actions;
-  tab_bar_actions.append (_close_action);
-  tab_bar_actions.append (_close_all_action);
-  tab_bar_actions.append (_close_others_action);
+  tab_bar_actions.append (m_close_action);
+  tab_bar_actions.append (m_close_all_action);
+  tab_bar_actions.append (m_close_others_action);
   bar->create_context_menu (&tab_bar_actions);
 
   // signals
   connect (this, SIGNAL (execute_command_in_terminal_signal (const QString&)),
            main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
   connect (this, SIGNAL (request_settings_dialog (const QString&)),
            main_win (),
            SLOT (process_settings_dialog_request (const QString&)));
 
-  connect (_mru_file_menu, SIGNAL (triggered (QAction *)),
+  connect (m_mru_file_menu, SIGNAL (triggered (QAction *)),
            this, SLOT (request_mru_open_file (QAction *)));
 
   mru_menu_update ();
 
-  connect (_tab_widget, SIGNAL (tabCloseRequested (int)),
+  connect (m_tab_widget, SIGNAL (tabCloseRequested (int)),
            this, SLOT (handle_tab_close_request (int)));
 
-  connect (_tab_widget, SIGNAL (currentChanged (int)),
+  connect (m_tab_widget, SIGNAL (currentChanged (int)),
            this, SLOT (active_tab_changed (int)));
 
   resize (500, 400);
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Editor"));
 
   check_actions ();
 }
 
 void
-file_editor::restore_session (QSettings *settings)
-{
-  //restore previous session
-  if (! settings->value ("editor/restoreSession", true).toBool ())
-    return;
-
-  // get the data from the settings file
-  QStringList sessionFileNames = settings->value ("editor/savedSessionTabs",
-                                          QStringList ()).toStringList ();
-  QStringList session_encodings = settings->value ("editor/saved_session_encodings",
-                                          QStringList ()).toStringList ();
-  QStringList session_index = settings->value ("editor/saved_session_tab_index",
-                                          QStringList ()).toStringList ();
-
-  // fill a list of the struct and sort it (depending on index)
-  QList<session_data> s_data;
-
-  bool do_encoding = (session_encodings.count () == sessionFileNames.count ());
-  bool do_index    = (session_index.count () == sessionFileNames.count ());
-
-  for (int n = 0; n < sessionFileNames.count (); ++n)
-    {
-      QFileInfo file = QFileInfo (sessionFileNames.at (n));
-      if (! file.exists ())
-        continue;
-
-      session_data item = { QString (), sessionFileNames.at (n), QString ()};
-      if (do_index)
-        item.index = session_index.at (n);
-      if (do_encoding)
-        item.encoding = session_encodings.at (n);
-
-      s_data << item;
-    }
-
-  qSort (s_data);
-
-  // finally open the file with the desired encoding in the desired order
-  for (int n = 0; n < s_data.count (); ++n)
-    request_open_file (s_data.at (n).file_name, s_data.at (n).encoding);
-}
-
-void
 file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
 {
-  _tab_widget->addTab (f, fn);
+  m_tab_widget->addTab (f, fn);
 
   // signals from the qscintilla edit area
   connect (f->qsci_edit_area (), SIGNAL (status_update (bool, bool)),
            this, SLOT (edit_status_update (bool, bool)));
 
   connect (f->qsci_edit_area (), SIGNAL (show_doc_signal (const QString&)),
            main_win (), SLOT (handle_show_doc (const QString&)));
 
@@ -2033,446 +2245,228 @@ file_editor::add_file_editor_tab (file_e
   connect (this, SIGNAL (fetab_delete_debugger_pointer (const QWidget*, int)),
            f, SLOT (delete_debugger_pointer (const QWidget*, int)));
 
   connect (this, SIGNAL (fetab_do_breakpoint_marker (bool, const QWidget*,
                                                      int, const QString&)),
            f, SLOT (do_breakpoint_marker (bool, const QWidget*, int,
                                           const QString&)));
 
-  _tab_widget->setCurrentWidget (f);
+  m_tab_widget->setCurrentWidget (f);
 
   check_actions ();
 }
 
+void
+file_editor::mru_menu_update (void)
+{
+  int num_files = qMin (m_mru_files.size (), int (MaxMRUFiles));
+
+  // configure and show active actions of mru-menu
+  for (int i = 0; i < num_files; ++i)
+    {
+      QString text = tr ("&%1 %2").
+                     arg ((i+1) % int (MaxMRUFiles)).arg (m_mru_files.at (i));
+      m_mru_file_actions[i]->setText (text);
+
+      QStringList action_data;
+      action_data << m_mru_files.at (i) << m_mru_files_encodings.at (i);
+      m_mru_file_actions[i]->setData (action_data);
+
+      m_mru_file_actions[i]->setVisible (true);
+    }
+
+  // hide unused mru-menu entries
+  for (int j = num_files; j < MaxMRUFiles; ++j)
+    m_mru_file_actions[j]->setVisible (false);
+
+  // delete entries in string-list beyond MaxMRUFiles
+  while (m_mru_files.size () > MaxMRUFiles)
+    {
+      m_mru_files.removeLast ();
+      m_mru_files_encodings.removeLast ();
+    }
+
+  // save actual mru-list in settings
+  QSettings *settings = resource_manager::get_settings ();
+
+  settings->setValue ("editor/mru_file_list", m_mru_files);
+  settings->setValue ("editor/mru_file_encodings", m_mru_files_encodings);
+  settings->sync ();
+}
+
 bool
-file_editor::editor_tab_has_focus ()
+file_editor::call_custom_editor (const QString& file_name, int line)
 {
-  QWidget *foc_w = focusWidget ();
-  if (foc_w && foc_w->inherits ("octave_qscintilla"))
-    return true;
+  // Check if the user wants to use a custom file editor.
+  QSettings *settings = resource_manager::get_settings ();
+
+  if (settings->value ("useCustomFileEditor",false).toBool ())
+    {
+      // use the external editor interface for handling the call
+      emit request_open_file_external (file_name, line);
+
+      if (line < 0 && ! file_name.isEmpty ())
+        handle_mru_add_file (QFileInfo (file_name).canonicalFilePath (),
+                             QString ());
+
+      return true;
+    }
+
   return false;
 }
 
 void
-file_editor::set_shortcuts ()
+file_editor::toggle_preference (const QString& preference, bool def)
 {
-  // Shortcuts also available in the main window, as well as the realted
-  // ahotcuts, are defined in main_window and added to the editor
-
-  // File menu
-  shortcut_manager::set_shortcut (_edit_function_action, "editor_file:edit_function");
-  shortcut_manager::set_shortcut (_save_action, "editor_file:save");
-  shortcut_manager::set_shortcut (_save_as_action, "editor_file:save_as");
-  shortcut_manager::set_shortcut (_close_action, "editor_file:close");
-  shortcut_manager::set_shortcut (_close_all_action, "editor_file:close_all");
-  shortcut_manager::set_shortcut (_close_others_action, "editor_file:close_other");
-  shortcut_manager::set_shortcut (_print_action, "editor_file:print");
-
-  // Edit menu
-  shortcut_manager::set_shortcut (_redo_action, "editor_edit:redo");
-  shortcut_manager::set_shortcut (_cut_action, "editor_edit:cut");
-  shortcut_manager::set_shortcut (_find_action, "editor_edit:find_replace");
-  shortcut_manager::set_shortcut (_find_next_action, "editor_edit:find_next");
-  shortcut_manager::set_shortcut (_find_previous_action, "editor_edit:find_previous");
-
-  shortcut_manager::set_shortcut (_delete_start_word_action, "editor_edit:delete_start_word");
-  shortcut_manager::set_shortcut (_delete_end_word_action, "editor_edit:delete_end_word");
-  shortcut_manager::set_shortcut (_delete_start_line_action, "editor_edit:delete_start_line");
-  shortcut_manager::set_shortcut (_delete_end_line_action, "editor_edit:delete_end_line");
-  shortcut_manager::set_shortcut (_delete_line_action, "editor_edit:delete_line");
-  shortcut_manager::set_shortcut (_copy_line_action, "editor_edit:copy_line");
-  shortcut_manager::set_shortcut (_cut_line_action, "editor_edit:cut_line");
-  shortcut_manager::set_shortcut (_duplicate_selection_action, "editor_edit:duplicate_selection");
-  shortcut_manager::set_shortcut (_transpose_line_action, "editor_edit:transpose_line");
-  shortcut_manager::set_shortcut (_comment_selection_action, "editor_edit:comment_selection");
-  shortcut_manager::set_shortcut (_uncomment_selection_action, "editor_edit:uncomment_selection");
-
-  shortcut_manager::set_shortcut (_upper_case_action, "editor_edit:upper_case");
-  shortcut_manager::set_shortcut (_lower_case_action, "editor_edit:lower_case");
-  shortcut_manager::set_shortcut (_indent_selection_action, "editor_edit:indent_selection");
-  shortcut_manager::set_shortcut (_unindent_selection_action, "editor_edit:unindent_selection");
-  shortcut_manager::set_shortcut (_completion_action, "editor_edit:completion_list");
-  shortcut_manager::set_shortcut (_goto_line_action, "editor_edit:goto_line");
-  shortcut_manager::set_shortcut (_move_to_matching_brace, "editor_edit:move_to_brace");
-  shortcut_manager::set_shortcut (_sel_to_matching_brace, "editor_edit:select_to_brace");
-  shortcut_manager::set_shortcut (_toggle_bookmark_action, "editor_edit:toggle_bookmark");
-  shortcut_manager::set_shortcut (_next_bookmark_action, "editor_edit:next_bookmark");
-  shortcut_manager::set_shortcut (_previous_bookmark_action, "editor_edit:previous_bookmark");
-  shortcut_manager::set_shortcut (_remove_bookmark_action, "editor_edit:remove_bookmark");
-  shortcut_manager::set_shortcut (_preferences_action, "editor_edit:preferences");
-  shortcut_manager::set_shortcut (_styles_preferences_action, "editor_edit:styles_preferences");
-
-  shortcut_manager::set_shortcut (_conv_eol_windows_action, "editor_edit:conv_eol_winows");
-  shortcut_manager::set_shortcut (_conv_eol_unix_action,    "editor_edit:conv_eol_unix");
-  shortcut_manager::set_shortcut (_conv_eol_mac_action,     "editor_edit:conv_eol_mac");
-
-  // View menu
-  shortcut_manager::set_shortcut (_show_linenum_action, "editor_view:show_line_numbers");
-  shortcut_manager::set_shortcut (_show_whitespace_action, "editor_view:show_white_spaces");
-  shortcut_manager::set_shortcut (_show_eol_action, "editor_view:show_eol_chars");
-  shortcut_manager::set_shortcut (_show_indguide_action, "editor_view:show_ind_guides");
-  shortcut_manager::set_shortcut (_show_longline_action, "editor_view:show_long_line");
-  shortcut_manager::set_shortcut (_show_toolbar_action, "editor_view:show_toolbar");
-  shortcut_manager::set_shortcut (_show_statusbar_action, "editor_view:show_statusbar");
-  shortcut_manager::set_shortcut (_show_hscrollbar_action, "editor_view:show_hscrollbar");
-  shortcut_manager::set_shortcut (_zoom_in_action, "editor_view:zoom_in");
-  shortcut_manager::set_shortcut (_zoom_out_action, "editor_view:zoom_out");
-  shortcut_manager::set_shortcut (_zoom_normal_action, "editor_view:zoom_normal");
-
-  // Debug menu
-  shortcut_manager::set_shortcut (_toggle_breakpoint_action, "editor_debug:toggle_breakpoint");
-  shortcut_manager::set_shortcut (_next_breakpoint_action, "editor_debug:next_breakpoint");
-  shortcut_manager::set_shortcut (_previous_breakpoint_action, "editor_debug:previous_breakpoint");
-  shortcut_manager::set_shortcut (_remove_all_breakpoints_action, "editor_debug:remove_breakpoints");
-
-  // Run menu
-  shortcut_manager::set_shortcut (_run_action, "editor_run:run_file");
-  shortcut_manager::set_shortcut (_run_selection_action, "editor_run:run_selection");
-
-  // Help menu
-  shortcut_manager::set_shortcut (_context_help_action, "editor_help:help_keyword");
-  shortcut_manager::set_shortcut (_context_doc_action,  "editor_help:doc_keyword");
-
-  // Tab navigation without menu entries
-  shortcut_manager::set_shortcut (_switch_left_tab_action, "editor_tabs:switch_left_tab");
-  shortcut_manager::set_shortcut (_switch_right_tab_action, "editor_tabs:switch_right_tab");
-  shortcut_manager::set_shortcut (_move_tab_left_action, "editor_tabs:move_tab_left");
-  shortcut_manager::set_shortcut (_move_tab_right_action, "editor_tabs:move_tab_right");
-
+  QSettings *settings = resource_manager::get_settings ();
+  bool old = settings->value (preference,def).toBool ();
+  settings->setValue (preference,! old);
+  notice_settings (settings);
 }
 
 void
-file_editor::check_actions ()
-{
-  bool have_tabs = _tab_widget->count () > 0;
-
-  _edit_cmd_menu->setEnabled (have_tabs);
-  _edit_fmt_menu->setEnabled (have_tabs);
-  _edit_nav_menu->setEnabled (have_tabs);
-
-  _comment_selection_action->setEnabled (have_tabs);
-  _uncomment_selection_action->setEnabled (have_tabs);
-  _indent_selection_action->setEnabled (have_tabs);
-  _unindent_selection_action->setEnabled (have_tabs);
-
-  _context_help_action->setEnabled (have_tabs);
-  _context_doc_action->setEnabled (have_tabs);
-
-  _view_editor_menu->setEnabled (have_tabs);
-  _zoom_in_action->setEnabled (have_tabs);
-  _zoom_out_action->setEnabled (have_tabs);
-  _zoom_normal_action->setEnabled (have_tabs);
-
-  _find_action->setEnabled (have_tabs);
-  _find_next_action->setEnabled (have_tabs);
-  _find_previous_action->setEnabled (have_tabs);
-  _print_action->setEnabled (have_tabs);
-  _run_action->setEnabled (have_tabs);
-
-  _edit_function_action->setEnabled (have_tabs);
-  _save_action->setEnabled (have_tabs);
-  _save_as_action->setEnabled (have_tabs);
-  _close_action->setEnabled (have_tabs);
-  _close_all_action->setEnabled (have_tabs);
-  _close_others_action->setEnabled (have_tabs && _tab_widget->count () > 1);
-}
-
-// empty_script determines whether we have to create an empty script
-// 1. At startup, when the editor has to be (really) visible
-//    (Here we can not use the visibility changed signal)
-// 2. When the editor becomes visible when octave is running
-void
-file_editor::empty_script (bool startup, bool visible)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings->value ("useCustomFileEditor",false).toBool ())
-    return;  // do not open an empty script in the external editor
-
-  bool real_visible;
-
-  if (startup)
-    real_visible = isVisible ();
-  else
-    real_visible = visible;
-
-  if (! real_visible || _tab_widget->count () > 0)
-    return;
-
-  if (startup && ! isFloating ())
-    {
-      // check is editor is really visible or hidden between tabbed widgets
-      QList<QTabBar *> tab_list = main_win ()->findChildren<QTabBar *>();
-
-      bool in_tab = false;
-      int i = 0;
-      while ((i < tab_list.count ()) && (! in_tab))
-        {
-          QTabBar *tab = tab_list.at (i);
-          i++;
-
-          int j = 0;
-          while ((j < tab->count ()) && (! in_tab))
-            {
-              // check all tabs for the editor
-              if (tab->tabText (j) == windowTitle ())
-                {
-                  // editor is in this tab widget
-                  in_tab = true;
-                  int top = tab->currentIndex ();
-                  if (top > -1 && tab->tabText (top) == windowTitle ())
-                    real_visible = true;  // and is the current tab
-                  else
-                    return; // not current tab -> not visible
-                }
-              j++;
-            }
-        }
-    }
-
-  request_new_file ("");
-}
-
-// This slot is a reimplementation of the virtual slot in octave_dock_widget.
-// We need this for creating an empty script when the editor has no open files
-// and is made visible
-void
-file_editor::handle_visibility (bool visible)
-{
-  if (_closed && visible)
-    {
-      _closed = false;
-      QSettings *settings = resource_manager::get_settings ();
-      restore_session (settings);
-    }
-
-  empty_script (false, visible);
-
-  if (visible && ! isFloating ())
-    focus ();
-
-}
-
-void
-file_editor::dragEnterEvent (QDragEnterEvent *e)
-{
-  if (e->mimeData ()->hasUrls ())
-    {
-      e->acceptProposedAction ();
-    }
-}
-
-void
-file_editor::dropEvent (QDropEvent *e)
-{
-  if (e->mimeData ()->hasUrls ())
-    {
-      foreach (QUrl url, e->mimeData ()->urls ())
-        request_open_file (url.toLocalFile ());
-    }
-}
-
-// handler for the close event
-void
-file_editor::closeEvent (QCloseEvent *e)
-{
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings->value ("editor/hiding_closes_files",false).toBool ())
-    {
-      if (check_closing ())
-        {
-          // all tabs are closed without cancelling,
-          // store closing state for restoring session when shown again
-          _closed = true;
-          e->accept ();
-        }
-      else
-        e->ignore ();
-    }
-  else
-   e->accept ();
-}
-
-// slots for tab navigation
-void
-file_editor::switch_left_tab ()
-{
-  switch_tab (-1);
-}
-void
-file_editor::switch_right_tab ()
-{
-  switch_tab (1);
-}
-void
-file_editor::move_tab_left ()
-{
-#if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  switch_tab (-1, true);
-#endif
-}
-void
-file_editor::move_tab_right ()
-{
-#if defined (HAVE_QTABWIDGET_SETMOVABLE)
-  switch_tab (1, true);
-#endif
-}
-void
 file_editor::switch_tab (int direction, bool movetab)
 {
-  int tabs = _tab_widget->count ();
+  int tabs = m_tab_widget->count ();
 
   if (tabs < 2)
     return;
 
-  int old_pos = _tab_widget->currentIndex ();
-  int new_pos = _tab_widget->currentIndex () + direction;
+  int old_pos = m_tab_widget->currentIndex ();
+  int new_pos = m_tab_widget->currentIndex () + direction;
 
   if (new_pos < 0 || new_pos >= tabs)
     new_pos = new_pos - direction*tabs;
 
   if (movetab)
     {
 #if defined (HAVE_QTABWIDGET_SETMOVABLE)
-      _tab_widget->tabBar ()->moveTab (old_pos, new_pos);
-      _tab_widget->setCurrentIndex (old_pos);
-      _tab_widget->setCurrentIndex (new_pos);
+      m_tab_widget->tabBar ()->moveTab (old_pos, new_pos);
+      m_tab_widget->setCurrentIndex (old_pos);
+      m_tab_widget->setCurrentIndex (new_pos);
       focus ();
 #endif
     }
   else
-    _tab_widget->setCurrentIndex (new_pos);
+    m_tab_widget->setCurrentIndex (new_pos);
 }
 
-
-//
-// Functions of the the reimplemented tab bar
-//
-
-file_editor_tab_bar::file_editor_tab_bar (QWidget *p)
-  : QTabBar (p)
-{
-  _context_menu = new QMenu (this);
-}
-
-file_editor_tab_bar::~file_editor_tab_bar ()
-{
-  delete _context_menu;
-}
-
-// Create the context menu and fill it with actions from the editor
+// Function for closing the files in a removed directory
 void
-file_editor_tab_bar::create_context_menu (QList<QAction*> *actions)
-{
-  for (int i = 0; i < actions->count (); i++)
-    _context_menu->addAction (actions->at (i));
-}
-
-// Reimplement mouse event for filtering out the desired mouse clicks
-void
-file_editor_tab_bar::mousePressEvent (QMouseEvent *me)
+file_editor::handle_dir_remove (const QString& old_name,
+                                const QString& new_name)
 {
-  QPoint click_pos;
-  int clicked_idx = -1;
-
-  // detect the tab where the click occured
-  for (int i = 0; i < count (); i++)
+  QDir old_dir (old_name);
+
+  // Have all file editor tabs signal what their filenames are.
+  m_editor_tab_map.clear ();
+  emit fetab_file_name_query (nullptr);
+
+  // Loop over all open files and pick those within old_dir
+  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+       p != m_editor_tab_map.end (); p++)
     {
-      click_pos = mapToGlobal (me->pos ());
-      if (tabRect (i).contains (mapFromGlobal (click_pos)))
+      QString rel_path_to_file = old_dir.relativeFilePath (p->first);
+      if (rel_path_to_file.left (3) != QString ("../"))
         {
-          clicked_idx = i;
+          // We directly go down from old_dir to reach our file: Our
+          // file is included in the removed/renamed diectory.
+          // Thus delete it.
+          m_no_focus = true;  // Remember for not focussing editor
+          file_editor_tab *editor_tab
+              = static_cast<file_editor_tab *> (p->second.fet_ID);
+          editor_tab->file_has_changed (QString (), true);  // Close
+          m_no_focus = false;  // Back to normal
+
+          // Store file for possible later reload
+          m_tmp_closed_files << p->first;
+
+          // Add the new file path and the encoding for later reloading
+          // if new_name is given
+          if (! new_name.isEmpty ())
+            {
+              QDir new_dir (new_name);
+              m_tmp_closed_files << new_dir.absoluteFilePath (rel_path_to_file);
+            }
+          else
+            m_tmp_closed_files << ""; // no new name, just removing this file
+
+          m_tmp_closed_files << p->second.encoding; // store the encoding
+        }
+    }
+}
+
+bool
+file_editor::editor_tab_has_focus (void)
+{
+  QWidget *foc_w = focusWidget ();
+  if (foc_w && foc_w->inherits ("octave_qscintilla"))
+    return true;
+  return false;
+}
+
+// Check whether this file is already open in the editor.
+QWidget *
+file_editor::find_tab_widget (const QString& file)
+{
+  // Have all file editor tabs signal what their filenames are.
+  m_editor_tab_map.clear ();
+  emit fetab_file_name_query (nullptr);
+
+  // Check all tabs for the given file name
+  QWidget *retval = nullptr;
+
+  for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+       p != m_editor_tab_map.end (); p++)
+    {
+      QString tab_file = p->first;
+      if (same_file (file.toStdString (), tab_file.toStdString ())
+          || file == tab_file)     // needed as same_file ("","") is false.
+        {
+          retval = p->second.fet_ID;
           break;
         }
     }
 
-  // If a tab was clicked
-  if (clicked_idx >= 0)
-    {
-      int current_idx = currentIndex ();
-      // detect the mouse click
-      if ((me->type () == QEvent::MouseButtonDblClick &&
-           me->button() == Qt::LeftButton) ||
-          (me->type () != QEvent::MouseButtonDblClick &&
-           me->button() == Qt::MidButton))
-        {
-          // Middle click or double click -> close the tab
-          // Make the clicked tab the current one and close it
-          setCurrentIndex (clicked_idx);
-          emit close_current_tab_signal (true);
-          // Was the closed tab before or after the previously current tab?
-          // According to the result, use previous index or reduce it by one
-          if (current_idx - clicked_idx > 0)
-            setCurrentIndex (current_idx - 1);
-          else if (current_idx - clicked_idx < 0)
-            setCurrentIndex (current_idx);
-        }
-      else if (me->type () != QEvent::MouseButtonDblClick &&
-               me->button() == Qt::RightButton)
-        {
-          // Right click, show context menu
-          setCurrentIndex (clicked_idx);
-          if (! _context_menu->exec (click_pos))
-            {
-              // No action selected, back to previous tab
-              setCurrentIndex (current_idx);
-            }
-          else
-            {
-              // Was the possibly only closed tab before or after the
-              // previously current tab? According to the result, use previous
-              // index or reduce it by one. Also prevent using a too large
-              // if other or all files were closed.
-              int new_idx = count () - 1;
-              if (new_idx > 0)
-                {
-                  if (current_idx - clicked_idx > 0)
-                    new_idx = current_idx - 1;
-                  else if (current_idx - clicked_idx < 0)
-                    new_idx = current_idx;
-                }
-              if (new_idx >= 0)
-                setCurrentIndex (new_idx);
-            }
-        }
-      else
-        {
-          // regular handling of the mouse event
-          QTabBar::mousePressEvent (me);
-        }
-    }
+  return retval;
+}
+
+QAction*
+file_editor::add_action (QMenu *menu, const QIcon& icon, const QString& text,
+                         const char *member)
+{
+  QAction *a;
+
+  if (menu)
+    a = menu->addAction (icon, text, this, member);
   else
     {
-      // regular handling of the mouse event
-      QTabBar::mousePressEvent (me);
+      a = new QAction (this);
+      connect (a, SIGNAL (triggered ()), this, member);
     }
+
+  addAction (a);  // important for shortcut context
+  a->setShortcutContext (Qt::WidgetWithChildrenShortcut);
+
+  return a;
 }
 
-
-
-//
-// Functions of the the reimplemented tab widget
-//
-
-file_editor_tab_widget::file_editor_tab_widget (QWidget *p)
-  : QTabWidget (p)
+QMenu*
+file_editor::add_menu (QMenuBar *p, QString name)
 {
-  file_editor_tab_bar *bar;
-  bar = new file_editor_tab_bar (this);
-
-  connect (bar, SIGNAL (close_current_tab_signal (bool)),
-           p->parent (), SLOT (request_close_file (bool)));
-
-  this->setTabBar(bar);
+  QMenu *menu = p->addMenu (name);
+
+  QString base_name = name;  // get a copy
+  // replace intended '&' ("&&") by a temp. string
+  base_name.replace ("&&", "___octave_amp_replacement___");
+  // remove single '&' (shortcut)
+  base_name.remove ("&");
+  // restore intended '&'
+  base_name.replace ("___octave_amp_replacement___", "&&");
+
+  // remember names with and without shortcut
+  m_hash_menu_text[menu] = QStringList () << name << base_name;
+
+  return menu;
 }
 
-file_editor_tab_widget::~file_editor_tab_widget ()
-{ }
-
-QTabBar*
-file_editor_tab_widget::tabBar () const
-{
-  return (QTabWidget::tabBar ());
-}
-
-
 #endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -34,73 +34,71 @@ along with Octave; see the file COPYING.
 #include <QDragEnterEvent>
 #include <QDropEvent>
 
 #include <map>
 
 #include "file-editor-interface.h"
 #include "file-editor-tab.h"
 
-//
+
 // subclassed QTabBar for usable tab-bar and reimplemented mouse event
-//
+
 class file_editor_tab_bar : public QTabBar
 {
   Q_OBJECT
 
 public:
 
   file_editor_tab_bar (QWidget *p);
-  ~file_editor_tab_bar ();
+
+  ~file_editor_tab_bar (void);
+
   void create_context_menu (QList<QAction*> *actions);
 
 signals:
 
   void close_current_tab_signal (bool);
 
 protected:
 
   void mousePressEvent(QMouseEvent *event);
 
 private:
 
-  QMenu *_context_menu;
+  QMenu *m_context_menu;
 };
 
+// subclassed QTabWidget for using custom tabbar
 
-//
-// subclassed QTabWidget for using custom tabbar
-//
 class file_editor_tab_widget : public QTabWidget
 {
   Q_OBJECT
 
 public:
 
   file_editor_tab_widget (QWidget *p);
-  ~file_editor_tab_widget ();
 
-  QTabBar * tabBar () const;
+  ~file_editor_tab_widget (void) = default;
 
+  QTabBar * tabBar (void) const;
 };
 
+// the class for the file editor
 
-//
-// the class for the file editor
-//
 class file_editor : public file_editor_interface
 {
   Q_OBJECT
 
 public:
 
   struct tab_info
   {
     QWidget *fet_ID;
-    QString  encoding;
+    QString encoding;
   };
 
   typedef std::map<QString, tab_info>::iterator editor_tab_map_iterator;
   typedef std::map<QString, tab_info>::const_iterator editor_tab_map_const_iterator;
 
   // struct that allows to sort with respect to the tab index
   struct session_data
   {
@@ -110,25 +108,27 @@ public:
 
     bool operator < (const session_data& other) const
     {
       return index < other.index;
     }
   };
 
   file_editor (QWidget *p);
+
   ~file_editor (void);
 
-  void loadFile (const QString& fileName);
+  QMenu * get_mru_menu (void) { return m_mru_file_menu; }
 
-  QMenu * get_mru_menu (void) { return _mru_file_menu; }
-  QMenu * debug_menu (void);
-  QToolBar * toolbar (void);
+  QMenu * debug_menu (void) { return m_debug_menu; }
+
+  QToolBar * toolbar (void) { return m_tool_bar; }
 
   void insert_global_actions (QList<QAction*>);
+
   enum shared_actions_idx
   {
     NEW_SCRIPT_ACTION = 0,
     NEW_FUNCTION_ACTION,
     OPEN_ACTION,
     FIND_FILES_ACTION,
     UNDO_ACTION,
     COPY_ACTION,
@@ -192,17 +192,17 @@ signals:
   void fetab_zoom_normal (const QWidget *ID);
 
   void fetab_set_directory (const QString& dir);
   void fetab_recover_from_exit (void);
 
   void request_settings_dialog (const QString&);
   void execute_command_in_terminal_signal (const QString&);
   void request_open_file_external (const QString& file_name, int line);
-  void file_loaded_signal ();
+  void file_loaded_signal (void);
 
 public slots:
 
   void focus (void);
   void set_focus (QWidget *fet);
   void enable_menu_shortcuts (bool);
   bool check_closing (void);
 
@@ -282,28 +282,28 @@ public slots:
   void handle_edit_file_request (const QString& file);
 
   void handle_file_remove (const QString&, const QString&);
   void handle_file_renamed (bool load_new = true);
 
   // Tells the editor to react on changed settings.
   void notice_settings (const QSettings *settings);
 
-  void set_shortcuts ();
+  void set_shortcuts (void);
 
   void handle_visibility (bool visible);
 
   void update_octave_directory (const QString& dir);
 
 protected slots:
 
-  void copyClipboard ();
-  void pasteClipboard ();
-  void selectAll ();
-  void do_undo ();
+  void copyClipboard (void);
+  void pasteClipboard (void);
+  void selectAll (void);
+  void do_undo (void);
 
 private slots:
 
   void request_open_file (const QString& fileName,
                           const QString& encoding = QString (),
                           int line = -1, bool debug_pointer = false,
                           bool breakpoint_marker = false, bool insert = true,
                           const QString& cond = "");
@@ -317,169 +317,168 @@ private slots:
   void show_long_line (bool);
   void show_toolbar (bool);
   void show_statusbar (bool);
   void show_hscrollbar (bool);
   void zoom_in (bool);
   void zoom_out (bool);
   void zoom_normal (bool);
 
-  void switch_left_tab ();
-  void switch_right_tab ();
-  void move_tab_left ();
-  void move_tab_right ();
+  void switch_left_tab (void);
+  void switch_right_tab (void);
+  void move_tab_left (void);
+  void move_tab_right (void);
 
   void create_context_menu (QMenu *);
   void edit_status_update (bool, bool);
 
 protected:
 
   void closeEvent (QCloseEvent *event);
   void dragEnterEvent (QDragEnterEvent *event);
   void dropEvent (QDropEvent *event);
 
 private:
 
-  bool is_editor_console_tabbed ();
+  bool is_editor_console_tabbed (void);
   void construct (void);
   void add_file_editor_tab (file_editor_tab *f, const QString& fn);
-  void save_file_as (QWidget *fetabID = nullptr);
   void mru_menu_update (void);
   bool call_custom_editor (const QString& file_name = QString (), int line = -1);
 
   void toggle_preference (const QString& preference, bool def);
 
   void switch_tab (int direction, bool movetab = false);
 
   void handle_dir_remove (const QString& old_name, const QString& new_name);
 
-  bool editor_tab_has_focus ();
+  bool editor_tab_has_focus (void);
 
   QWidget * find_tab_widget (const QString& openFileName);
   QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
                         const char *member);
 
-  QMenu * m_add_menu (QMenuBar *p, QString text);
+  QMenu * add_menu (QMenuBar *p, QString text);
 
-  std::map<QString, tab_info> editor_tab_map;
-  QHash<QMenu*, QStringList> _hash_menu_text;
+  std::map<QString, tab_info> m_editor_tab_map;
+  QHash<QMenu*, QStringList> m_hash_menu_text;
 
-  QString ced;
+  QString m_ced;
 
-  QMenuBar *_menu_bar;
-  QToolBar *_tool_bar;
-  QMenu *_debug_menu;
+  QMenuBar *m_menu_bar;
+  QToolBar *m_tool_bar;
+  QMenu *m_debug_menu;
 
-  QAction *_new_action;
-  QAction *_new_function_action;
-  QAction *_open_action;
+  QAction *m_new_action;
+  QAction *m_new_function_action;
+  QAction *m_open_action;
 
-  QAction *_upper_case_action;
-  QAction *_lower_case_action;
-  QAction *_comment_selection_action;
-  QAction *_uncomment_selection_action;
-  QAction *_indent_selection_action;
-  QAction *_unindent_selection_action;
-  QAction *_conv_eol_windows_action;
-  QAction *_conv_eol_unix_action;
-  QAction *_conv_eol_mac_action;
+  QAction *m_upper_case_action;
+  QAction *m_lower_case_action;
+  QAction *m_comment_selection_action;
+  QAction *m_uncomment_selection_action;
+  QAction *m_indent_selection_action;
+  QAction *m_unindent_selection_action;
+  QAction *m_conv_eol_windows_action;
+  QAction *m_conv_eol_unix_action;
+  QAction *m_conv_eol_mac_action;
 
-  QAction *_copy_action;
-  QAction *_cut_action;
-  QAction *_paste_action;
-  QAction *_selectall_action;
-  QAction *_context_help_action;
-  QAction *_context_doc_action;
+  QAction *m_copy_action;
+  QAction *m_cut_action;
+  QAction *m_paste_action;
+  QAction *m_selectall_action;
+  QAction *m_context_help_action;
+  QAction *m_context_doc_action;
 
-  QAction *_show_linenum_action;
-  QAction *_show_whitespace_action;
-  QAction *_show_eol_action;
-  QAction *_show_indguide_action;
-  QAction *_show_longline_action;
-  QAction *_show_toolbar_action;
-  QAction *_show_statusbar_action;
-  QAction *_show_hscrollbar_action;
-  QAction *_zoom_in_action;
-  QAction *_zoom_out_action;
-  QAction *_zoom_normal_action;
+  QAction *m_show_linenum_action;
+  QAction *m_show_whitespace_action;
+  QAction *m_show_eol_action;
+  QAction *m_show_indguide_action;
+  QAction *m_show_longline_action;
+  QAction *m_show_toolbar_action;
+  QAction *m_show_statusbar_action;
+  QAction *m_show_hscrollbar_action;
+  QAction *m_zoom_in_action;
+  QAction *m_zoom_out_action;
+  QAction *m_zoom_normal_action;
 
-  QAction *_delete_start_word_action;
-  QAction *_delete_end_word_action;
-  QAction *_delete_start_line_action;
-  QAction *_delete_end_line_action;
-  QAction *_delete_line_action;
-  QAction *_copy_line_action;
-  QAction *_cut_line_action;
-  QAction *_duplicate_selection_action;
-  QAction *_transpose_line_action;
+  QAction *m_delete_start_word_action;
+  QAction *m_delete_end_word_action;
+  QAction *m_delete_start_line_action;
+  QAction *m_delete_end_line_action;
+  QAction *m_delete_line_action;
+  QAction *m_copy_line_action;
+  QAction *m_cut_line_action;
+  QAction *m_duplicate_selection_action;
+  QAction *m_transpose_line_action;
 
-  QAction *_find_action;
-  QAction *_find_next_action;
-  QAction *_find_previous_action;
-  QAction *_find_files_action;
-  QAction *_goto_line_action;
-  QAction *_completion_action;
+  QAction *m_find_action;
+  QAction *m_find_next_action;
+  QAction *m_find_previous_action;
+  QAction *m_find_files_action;
+  QAction *m_goto_line_action;
+  QAction *m_completion_action;
 
-  QAction *_move_to_matching_brace;
-  QAction *_sel_to_matching_brace;
-  QAction *_next_bookmark_action;
-  QAction *_previous_bookmark_action;
-  QAction *_toggle_bookmark_action;
-  QAction *_remove_bookmark_action;
+  QAction *m_move_to_matching_brace;
+  QAction *m_sel_to_matching_brace;
+  QAction *m_next_bookmark_action;
+  QAction *m_previous_bookmark_action;
+  QAction *m_toggle_bookmark_action;
+  QAction *m_remove_bookmark_action;
 
-  QAction *_print_action;
-  QAction *_run_action;
-  QAction *_run_selection_action;
+  QAction *m_print_action;
+  QAction *m_run_action;
+  QAction *m_run_selection_action;
 
-  QAction *_edit_function_action;
-  QAction *_popdown_mru_action;
-  QAction *_save_action;
-  QAction *_save_as_action;
-  QAction *_close_action;
-  QAction *_close_all_action;
-  QAction *_close_others_action;
+  QAction *m_edit_function_action;
+  QAction *m_popdown_mru_action;
+  QAction *m_save_action;
+  QAction *m_save_as_action;
+  QAction *m_close_action;
+  QAction *m_close_all_action;
+  QAction *m_close_others_action;
 
-  QAction *_redo_action;
-  QAction *_undo_action;
+  QAction *m_redo_action;
+  QAction *m_undo_action;
 
-  QAction *_preferences_action;
-  QAction *_styles_preferences_action;
+  QAction *m_preferences_action;
+  QAction *m_styles_preferences_action;
 
-  QAction *_switch_left_tab_action;
-  QAction *_switch_right_tab_action;
-  QAction *_move_tab_left_action;
-  QAction *_move_tab_right_action;
+  QAction *m_switch_left_tab_action;
+  QAction *m_switch_right_tab_action;
+  QAction *m_move_tab_left_action;
+  QAction *m_move_tab_right_action;
 
-  QAction *_toggle_breakpoint_action;
-  QAction *_next_breakpoint_action;
-  QAction *_previous_breakpoint_action;
-  QAction *_remove_all_breakpoints_action;
+  QAction *m_toggle_breakpoint_action;
+  QAction *m_next_breakpoint_action;
+  QAction *m_previous_breakpoint_action;
+  QAction *m_remove_all_breakpoints_action;
 
-  QMenu *_edit_menu;
-  QMenu *_edit_cmd_menu;
-  QMenu *_edit_fmt_menu;
-  QMenu *_edit_nav_menu;
-  QMenu *_fileMenu;
-  QMenu *_view_editor_menu;
+  QMenu *m_edit_menu;
+  QMenu *m_edit_cmd_menu;
+  QMenu *m_edit_fmt_menu;
+  QMenu *m_edit_nav_menu;
+  QMenu *m_fileMenu;
+  QMenu *m_view_editor_menu;
 
-  QList<QAction*> _fetab_actions;
+  QList<QAction*> m_fetab_actions;
 
-  file_editor_tab_widget *_tab_widget;
+  file_editor_tab_widget *m_tab_widget;
 
-  int _marker_breakpoint;
+  int m_marker_breakpoint;
 
-  bool _closed;
-  bool _no_focus;
+  bool m_closed;
+  bool m_no_focus;
 
   enum { MaxMRUFiles = 10 };
-  QMenu *_mru_file_menu;
-  QAction *_mru_file_actions[MaxMRUFiles];
-  QStringList _mru_files;
-  QStringList _mru_files_encodings;
+  QMenu *m_mru_file_menu;
+  QAction *m_mru_file_actions[MaxMRUFiles];
+  QStringList m_mru_files;
+  QStringList m_mru_files_encodings;
 
   // List of temporarily closed files for later reloading.
   // Order: first closed old file
   //        first new location of closed file
   //        encoding to use for reload
-  QStringList _tmp_closed_files;
+  QStringList m_tmp_closed_files;
 };
 
 #endif
diff --git a/libgui/src/m-editor/marker.cc b/libgui/src/m-editor/marker.cc
--- a/libgui/src/m-editor/marker.cc
+++ b/libgui/src/m-editor/marker.cc
@@ -23,165 +23,149 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #if defined (HAVE_QSCINTILLA)
 
 #include "marker.h"
 
-
 marker::marker (QsciScintilla *area, int original_linenr, editor_markers type,
-                int editor_linenr, const QString& condition) : QObject ()
+                int editor_linenr, const QString& condition)
+  : QObject ()
 {
   construct (area, original_linenr, type, editor_linenr, condition);
 }
 
-
 marker::marker (QsciScintilla *area, int original_linenr,
-                editor_markers type, const QString& condition) : QObject ()
+                editor_markers type, const QString& condition)
+  : QObject ()
 {
   construct (area, original_linenr, type, original_linenr - 1, condition);
 }
 
-
-marker::~marker (void)
-{ }
-
-
 void
 marker::construct (QsciScintilla *area, int original_linenr,
                    editor_markers type, int editor_linenr,
                    const QString& condition)
 {
-  _edit_area = area;
-  _original_linenr = original_linenr;
-  _marker_type = type;
-  _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
-  _condition = condition;
+  m_edit_area = area;
+  m_original_linenr = original_linenr;
+  m_marker_type = type;
+  m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
+  m_condition = condition;
 }
 
-
 void
 marker::handle_remove_via_original_linenr (int linenr)
 {
-  if (_original_linenr == linenr)
+  if (m_original_linenr == linenr)
     {
-      _edit_area->markerDeleteHandle (_mhandle);
+      m_edit_area->markerDeleteHandle (m_mhandle);
       delete this;
     }
 }
 
-
 void
 marker::handle_request_remove_via_editor_linenr (int linenr)
 {
   // Get line number from the edit area and if it matches
   // the requested line number, remove.
-  if (_edit_area->markerLine (_mhandle) == linenr)
+  if (m_edit_area->markerLine (m_mhandle) == linenr)
     {
       // Rather than delete editor marker directly, issue command
       // to Octave core.  Octave core should signal back to remove
       // this breakpoint via debugger line number.
-      emit request_remove (_original_linenr);
+      emit request_remove (m_original_linenr);
     }
 }
 
-
 void
 marker::handle_remove (void)
 {
-  _edit_area->markerDeleteHandle (_mhandle);
+  m_edit_area->markerDeleteHandle (m_mhandle);
   delete this;
 }
 
-
 void
 marker::handle_find_translation (int linenr, int& translation_linenr,
                                  marker *& bp)
 {
-  if (_original_linenr == linenr)
+  if (m_original_linenr == linenr)
     {
-      translation_linenr = _edit_area->markerLine (_mhandle);
+      translation_linenr = m_edit_area->markerLine (m_mhandle);
       bp = this;
     }
 }
 
-
 void
 marker::handle_find_just_before (int linenr, int& original_linenr,
                                  int& editor_linenr)
 {
-  if (_original_linenr < linenr && _original_linenr >= original_linenr)
+  if (m_original_linenr < linenr && m_original_linenr >= original_linenr)
     {
-      original_linenr = _original_linenr;
-      editor_linenr = _edit_area->markerLine (_mhandle);
+      original_linenr = m_original_linenr;
+      editor_linenr = m_edit_area->markerLine (m_mhandle);
     }
 }
 
-
 void
 marker::handle_find_just_after (int linenr, int& original_linenr,
                                 int& editor_linenr)
 {
-  if (_original_linenr > linenr && _original_linenr <= original_linenr)
+  if (m_original_linenr > linenr && m_original_linenr <= original_linenr)
     {
-      original_linenr = _original_linenr;
-      editor_linenr = _edit_area->markerLine (_mhandle);
+      original_linenr = m_original_linenr;
+      editor_linenr = m_edit_area->markerLine (m_mhandle);
     }
 }
 
-
 void
 marker::handle_report_editor_linenr (QIntList& lines, QStringList& conditions)
 {
-  lines << _edit_area->markerLine (_mhandle);
-  conditions << _condition;
+  lines << m_edit_area->markerLine (m_mhandle);
+  conditions << m_condition;
 }
 
-
 void
 marker::handle_marker_line_deleted (int mhandle)
 {
   // FUTURE SUPPORT: There really should be a signal in QsciScintilla
   // called markerLineDeleted (int mhandle) because there is no way
   // of knowing this.  QsciScintilla will place the marker at a
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
-  if (_mhandle == mhandle)
+  if (m_mhandle == mhandle)
     {
-      if (_marker_type == breakpoint || _marker_type == debugger_position)
+      if (m_marker_type == breakpoint || m_marker_type == debugger_position)
         {
-          int editor_linenr = _edit_area->markerLine (_mhandle);
-          _edit_area->markerDeleteHandle (_mhandle);
-          _marker_type = (_marker_type == breakpoint
-                          ? unsure_breakpoint
-                          : unsure_debugger_position);
-          _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
+          int editor_linenr = m_edit_area->markerLine (m_mhandle);
+          m_edit_area->markerDeleteHandle (m_mhandle);
+          m_marker_type = (m_marker_type == breakpoint
+                           ? unsure_breakpoint : unsure_debugger_position);
+          m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
         }
     }
 }
 
-
 void
 marker::handle_marker_line_undeleted (int mhandle)
 {
   // FUTURE SUPPORT: There really should be a signal in QsciScintilla
   // called markerLineUndeleted (int mhandle) because there is no way
   // of knowing this.  QsciScintilla will place the marker at a
   // different line rather than remove it from the margin.  I (DJS) will
   // lobby for such a signal.
-  if (_mhandle == mhandle)
+  if (m_mhandle == mhandle)
     {
-      if (_marker_type == unsure_breakpoint
-          || _marker_type == unsure_debugger_position)
+      if (m_marker_type == unsure_breakpoint
+          || m_marker_type == unsure_debugger_position)
         {
-          int editor_linenr = _edit_area->markerLine (_mhandle);
-          _edit_area->markerDeleteHandle (_mhandle);
-          _marker_type = (_marker_type == unsure_breakpoint
-                          ? breakpoint
-                          : debugger_position);
-          _mhandle = _edit_area->markerAdd (editor_linenr, _marker_type);
+          int editor_linenr = m_edit_area->markerLine (m_mhandle);
+          m_edit_area->markerDeleteHandle (m_mhandle);
+          m_marker_type = (m_marker_type == unsure_breakpoint
+                           ? breakpoint : debugger_position);
+          m_mhandle = m_edit_area->markerAdd (editor_linenr, m_marker_type);
         }
     }
 }
 
 #endif
diff --git a/libgui/src/m-editor/marker.h b/libgui/src/m-editor/marker.h
--- a/libgui/src/m-editor/marker.h
+++ b/libgui/src/m-editor/marker.h
@@ -30,17 +30,16 @@ along with Octave; see the file COPYING.
 typedef QList<int> QIntList;
 
 // The breakpoint class keeps track of the debug line number that Octave core
 // uses and the handle of the marker inside the editor file.  If the editor
 // contents is modified, the debug line number and editor line number can be
 // out of alignment.  The marker handle can be used to retrieve the editor
 // line.
 
-class marker;
 class marker : public QObject
 {
   Q_OBJECT
 
 public:
 
   // List of all marker types
   // If multiple markers are on the same line, the first one listed
@@ -52,48 +51,53 @@ public:
     unsure_breakpoint,
     bookmark,
     debugger_position,
     unsure_debugger_position
   };
 
   marker (QsciScintilla *edit_area, int original_linenr,
           editor_markers marker_type, const QString& condition = "");
+
   marker (QsciScintilla *edit_area, int original_linenr,
           editor_markers marker_type, int editor_linenr,
           const QString& condition = "");
-  ~marker (void);
+
+  ~marker (void) = default;
 
-  const QString& get_cond (void) const { return _condition; }
+  const QString& get_cond (void) const { return m_condition; }
 
-  void set_cond (const QString& cond) { _condition = cond; }
+  void set_cond (const QString& cond) { m_condition = cond; }
 
 public slots:
+
   void handle_remove_via_original_linenr (int original_linenr);
   void handle_request_remove_via_editor_linenr (int editor_linenr);
   void handle_remove (void);
   void handle_find_translation (int original_linenr, int& editor_linenr,
                                 marker*& bp);
   void handle_find_just_before (int linenr, int& original_linenr,
                                 int& editor_linenr);
   void handle_find_just_after (int linenr, int& original_linenr,
                                int& editor_linenr);
   /*  void handle_lines_changed (void);*/
   void handle_marker_line_deleted (int mhandle);
   void handle_marker_line_undeleted (int mhandle);
   void handle_report_editor_linenr (QIntList& lines, QStringList& conditions);
 
 signals:
+
   void request_remove (int original_linenr);
 
 private:
+
   void construct (QsciScintilla *edit_area, int original_linenr,
                   editor_markers marker_type, int editor_linenr,
                   const QString& condition);
 
-  QsciScintilla *       _edit_area;
-  int                   _original_linenr;
-  editor_markers        _marker_type;
-  int                   _mhandle;
-  QString               _condition;
+  QsciScintilla *m_edit_area;
+  int m_original_linenr;
+  editor_markers m_marker_type;
+  int m_mhandle;
+  QString m_condition;
 };
 
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -47,20 +47,61 @@ along with Octave; see the file COPYING.
 #include <QShortcut>
 #include <QMessageBox>
 
 #include "octave-qscintilla.h"
 #include "file-editor-tab.h"
 #include "shortcut-manager.h"
 #include "resource-manager.h"
 
+// Return true if CANDIDATE is a "closing" that matches OPENING,
+// such as "end" or "endif" for "if", or "catch" for "try".
+// Used for testing the last word of an "if" etc. line,
+// or the first word of the following line.
+static bool
+is_end (const QString& candidate, const QString& opening)
+{
+  bool retval = false;
+
+  if (opening == "do")          // The only one that can't be ended by "end"
+    {
+      if (candidate == "until")
+        retval = true;
+    }
+  else
+    {
+      if (candidate == "end")
+        retval =  true;
+      else
+        {
+          if (opening == "try")
+            {
+              if (candidate == "catch" || candidate == "end_try_catch")
+                retval = true;
+            }
+          else if (opening == "unwind_protect")
+            {
+              if (candidate == "unwind_protect_cleanup"
+                  || candidate == "end_unwind_protect")
+                retval = true;
+            }
+          else if (candidate == "end" + opening)
+            retval = true;
+          else if (opening == "if" && candidate == "else")
+            retval = true;
+        }
+    }
+
+  return retval;
+}
+
 octave_qscintilla::octave_qscintilla (QWidget *p)
   : QsciScintilla (p)
 {
-  connect (this, SIGNAL (textChanged ()), this, SLOT (text_changed ()));
+  connect (this, SIGNAL (textChanged (void)), this, SLOT (text_changed (void)));
 
   // clear scintilla edit shortcuts that are handled by the editor
   QsciCommandSet *cmd_set = standardCommands ();
 
 #if defined (HAVE_QSCI_VERSION_2_6_0)
   // find () was added in QScintilla 2.6
   cmd_set->find (QsciCommand::SelectionCopy)->setKey (0);
   cmd_set->find (QsciCommand::SelectionCut)->setKey (0);
@@ -144,68 +185,16 @@ octave_qscintilla::octave_qscintilla (QW
       cmd_list_mac.at (i)->setAlternateKey (key);
     }
 #endif
 
   // init state of undo/redo action for this tab
   emit status_update (isUndoAvailable (), isRedoAvailable ());
 }
 
-octave_qscintilla::~octave_qscintilla ()
-{ }
-
-void
-octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
-                                              QPoint *local_pos)
-{
-  long position = SendScintilla (SCI_GETCURRENTPOS);
-  long point_x  = SendScintilla
-                    (SCI_POINTXFROMPOSITION,0,position);
-  long point_y  = SendScintilla
-                    (SCI_POINTYFROMPOSITION,0,position);
-  *local_pos = QPoint (point_x,point_y);  // local cursor position
-  *global_pos = mapToGlobal (*local_pos); // global position of cursor
-}
-
-// determine the actual word and whether we are in an octave or matlab script
-bool
-octave_qscintilla::get_actual_word ()
-{
-  QPoint global_pos, local_pos;
-  get_global_textcursor_pos (&global_pos, &local_pos);
-  _word_at_cursor = wordAtPoint (local_pos);
-  QString lexer_name = lexer ()->lexer ();
-  return ((lexer_name == "octave" || lexer_name == "matlab")
-          && ! _word_at_cursor.isEmpty ());
-}
-
-// call documentation or help on the current word
-void
-octave_qscintilla::context_help_doc (bool documentation)
-{
-  if (get_actual_word ())
-    contextmenu_help_doc (documentation);
-}
-
-// call edit the function related to the current word
-void
-octave_qscintilla::context_edit ()
-{
-  if (get_actual_word ())
-    contextmenu_edit (true);
-}
-
-// call edit the function related to the current word
-void
-octave_qscintilla::context_run ()
-{
-  if (hasSelectedText ())
-    contextmenu_run (true);
-}
-
 // context menu requested
 void
 octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
 {
 #if defined (HAVE_QSCI_VERSION_2_6_0)
   QPoint global_pos, local_pos;                         // the menu's position
   QMenu *context_menu = createStandardContextMenu ();  // standard menu
 
@@ -241,25 +230,25 @@ octave_qscintilla::contextMenuEvent (QCo
       // additional custom entries of the context menu
       context_menu->addSeparator ();   // separator before custom entries
 
       // help menu: get the position of the mouse or the text cursor
       // (only for octave files)
       QString lexer_name = lexer ()->lexer ();
       if (lexer_name == "octave" || lexer_name == "matlab")
         {
-          _word_at_cursor = wordAtPoint (local_pos);
-          if (! _word_at_cursor.isEmpty ())
+          m_word_at_cursor = wordAtPoint (local_pos);
+          if (! m_word_at_cursor.isEmpty ())
             {
-              context_menu->addAction (tr ("Help on") + ' ' + _word_at_cursor,
+              context_menu->addAction (tr ("Help on") + ' ' + m_word_at_cursor,
                                        this, SLOT (contextmenu_help (bool)));
               context_menu->addAction (tr ("Documentation on")
-                                       + ' ' + _word_at_cursor,
+                                       + ' ' + m_word_at_cursor,
                                        this, SLOT (contextmenu_doc (bool)));
-              context_menu->addAction (tr ("Edit") + ' ' + _word_at_cursor,
+              context_menu->addAction (tr ("Edit") + ' ' + m_word_at_cursor,
                                        this, SLOT (contextmenu_edit (bool)));
             }
         }
     }
 #if defined (HAVE_QSCI_VERSION_2_6_0)
   else
     {
       // remove all standard actions from scintilla
@@ -275,96 +264,90 @@ octave_qscintilla::contextMenuEvent (QCo
     }
 #endif
 
   // finaly show the menu
   context_menu->exec (global_pos);
 #endif
 }
 
-// handle the menu entry for calling help or doc
-void
-octave_qscintilla::contextmenu_doc (bool)
-{
-  contextmenu_help_doc (true);
-}
-void
-octave_qscintilla::contextmenu_help (bool)
-{
-  contextmenu_help_doc (false);
-}
-
 // common function with flag for documentation
 void
 octave_qscintilla::contextmenu_help_doc (bool documentation)
 {
   if (documentation)
-    emit show_doc_signal (_word_at_cursor);
+    emit show_doc_signal (m_word_at_cursor);
   else
-    emit execute_command_in_terminal_signal ("help " + _word_at_cursor);
+    emit execute_command_in_terminal_signal ("help " + m_word_at_cursor);
 }
 
+// call edit the function related to the current word
 void
-octave_qscintilla::contextmenu_edit (bool)
+octave_qscintilla::context_edit (void)
 {
-  emit context_menu_edit_signal (_word_at_cursor);
+  if (get_actual_word ())
+    contextmenu_edit (true);
+}
+
+// call edit the function related to the current word
+void
+octave_qscintilla::context_run (void)
+{
+  if (hasSelectedText ())
+    contextmenu_run (true);
 }
 
 void
-octave_qscintilla::contextmenu_run (bool)
+octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
+                                              QPoint *local_pos)
 {
-  QStringList commands = selectedText ().split (QRegExp ("[\r\n]"),
-                                                QString::SkipEmptyParts);
-  for (int i = 0; i < commands.size (); i++)
-    emit execute_command_in_terminal_signal (commands.at (i));
+  long position = SendScintilla (SCI_GETCURRENTPOS);
+  long point_x  = SendScintilla
+                    (SCI_POINTXFROMPOSITION,0,position);
+  long point_y  = SendScintilla
+                    (SCI_POINTYFROMPOSITION,0,position);
+  *local_pos = QPoint (point_x,point_y);  // local cursor position
+  *global_pos = mapToGlobal (*local_pos); // global position of cursor
 }
 
-// wrappers for dbstop related context menu items
-
-// FIXME: Why can't the data be sent as the argument to the function???
-void
-octave_qscintilla::contextmenu_break_condition (bool)
+// determine the actual word and whether we are in an octave or matlab script
+bool
+octave_qscintilla::get_actual_word (void)
 {
-#if defined (HAVE_QSCI_VERSION_2_6_0)
-  QAction *action = qobject_cast<QAction *>(sender ());
-  QPoint local_pos = action->data ().value<QPoint> ();
-
-  // pick point just right of margins, so lineAt doesn't give -1
-  int margins = marginWidth (1) + marginWidth (2) + marginWidth (3);
-  local_pos = QPoint (margins + 1, local_pos.y ());
-
-  emit context_menu_break_condition_signal (lineAt (local_pos));
-#endif
+  QPoint global_pos, local_pos;
+  get_global_textcursor_pos (&global_pos, &local_pos);
+  m_word_at_cursor = wordAtPoint (local_pos);
+  QString lexer_name = lexer ()->lexer ();
+  return ((lexer_name == "octave" || lexer_name == "matlab")
+          && ! m_word_at_cursor.isEmpty ());
 }
 
+// helper function for clearing all indicators of a specific style
 void
-octave_qscintilla::contextmenu_break_once (const QPoint& local_pos)
+octave_qscintilla::clear_indicator (int indicator_style)
 {
-#if defined (HAVE_QSCI_VERSION_2_6_0)
-  emit context_menu_break_once (lineAt (local_pos));
-#endif
+  int end_pos = text ().length ();
+  int end_line, end_col;
+  lineIndexFromPosition (end_pos, &end_line, &end_col);
+  clearIndicatorRange (0, 0, end_line, end_col, indicator_style);
 }
 
+// Function returning the true cursor position where the tab length
+// is taken into account.
 void
-octave_qscintilla::text_changed ()
+octave_qscintilla::get_current_position (int *pos, int *line, int *col)
 {
-  emit status_update (isUndoAvailable (), isRedoAvailable ());
-}
-
-// when edit area gets focus update information on undo/redo actions
-void octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
-{
-  emit status_update (isUndoAvailable (), isRedoAvailable ());
-
-  QsciScintilla::focusInEvent (focusEvent);
+  *pos = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
+  *line = SendScintilla (QsciScintillaBase::SCI_LINEFROMPOSITION, *pos);
+  *col = SendScintilla (QsciScintillaBase::SCI_GETCOLUMN, *pos);
 }
 
 // Function returning the comment string of the current lexer
 QString
-octave_qscintilla::comment_string ()
+octave_qscintilla::comment_string (void)
 {
   int lexer = SendScintilla (SCI_GETLEXER);
 
   switch (lexer)
     {
 #if defined (HAVE_LEXER_MATLAB)
       case SCLEX_MATLAB:
 #if defined (HAVE_LEXER_OCTAVE)
@@ -393,160 +376,76 @@ octave_qscintilla::comment_string ()
 
       case SCLEX_BATCH:
         return QString ("REM ");
     }
 
     return QString ("%");  // should never happen
 }
 
-// helper function for clearing all indicators of a specific style
-void
-octave_qscintilla::clear_indicator (int indicator_style)
-{
-  int end_pos = text ().length ();
-  int end_line, end_col;
-  lineIndexFromPosition (end_pos, &end_line, &end_col);
-  clearIndicatorRange (0, 0, end_line, end_col, indicator_style);
-}
-
 // provide the style at a specific position
 int
 octave_qscintilla::get_style (int pos)
 {
   int position;
   if (pos < 0)
     // The positition has to be reduced by 2 for getting the real style (?)
     position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS) - 2;
   else
     position = pos;
 
   return SendScintilla (QsciScintillaBase::SCI_GETSTYLEAT, position);
 }
 
-// Return true if CANDIDATE is a "closing" that matches OPENING,
-// such as "end" or "endif" for "if", or "catch" for "try".
-// Used for testing the last word of an "if" etc. line,
-// or the first word of the following line.
-static bool
-is_end (const QString& candidate, const QString& opening)
+// Is a specific cursor position in a line or block comment?
+int
+octave_qscintilla::is_style_comment (int pos)
 {
-  bool retval = false;
+  int lexer = SendScintilla (QsciScintillaBase::SCI_GETLEXER);
+  int style = get_style (pos);
 
-  if (opening == "do")          // The only one that can't be ended by "end"
-    {
-      if (candidate == "until")
-        retval = true;
-    }
-  else
+  switch (lexer)
     {
-      if (candidate == "end")
-        retval =  true;
-      else
-        {
-          if (opening == "try")
-            {
-              if (candidate == "catch" || candidate == "end_try_catch")
-                retval = true;
-            }
-          else if (opening == "unwind_protect")
-            {
-              if (candidate == "unwind_protect_cleanup"
-                  || candidate == "end_unwind_protect")
-                retval = true;
-            }
-          else if (candidate == "end" + opening)
-            retval = true;
-          else if (opening == "if" && candidate == "else")
-            retval = true;
-        }
+      case SCLEX_CPP:
+        return (ST_LINE_COMMENT * (
+                          style == QsciLexerCPP::CommentLine
+                       || style == QsciLexerCPP::CommentLineDoc)
+              + ST_BLOCK_COMMENT * (
+                           style == QsciLexerCPP::Comment
+                        || style == QsciLexerCPP::CommentDoc
+                        || style == QsciLexerCPP::CommentDocKeyword
+                        || style == QsciLexerCPP::CommentDocKeywordError)
+                );
+
+#if defined (HAVE_LEXER_MATLAB)
+      case SCLEX_MATLAB:
+        return (ST_LINE_COMMENT * (style == QsciLexerMatlab::Comment));
+#endif
+#if  defined (HAVE_LEXER_OCTAVE)
+      case SCLEX_OCTAVE:
+        return (ST_LINE_COMMENT * (style == QsciLexerOctave::Comment));
+#endif
+
+      case SCLEX_PERL:
+        return (ST_LINE_COMMENT * (style == QsciLexerPerl::Comment));
+
+      case SCLEX_BATCH:
+        return (ST_LINE_COMMENT * (style == QsciLexerBatch::Comment));
+
+      case SCLEX_DIFF:
+        return (ST_LINE_COMMENT * (style == QsciLexerDiff::Comment));
+
+      case SCLEX_BASH:
+        return (ST_LINE_COMMENT * (style == QsciLexerBash::Comment));
+
     }
 
-  return retval;
+  return ST_NONE;
 }
 
-void
-octave_qscintilla::auto_close (int auto_endif, int linenr,
-                               const QString& line, QString& first_word)
-{
-  // Insert and "end" for an "if" etc., if needed.
-  // (Use of "while" allows "return" to skip the rest.
-  // It may be clearer to use "if" and "goto",
-  // but that violates the coding standards.)
-
-  bool autofill_simple_end = (auto_endif == 2);
-
-  size_t start = line.toStdString ().find_first_not_of (" \t");
-
-  // Check if following line has the same or less indentation
-  // Check if the following line does not start with
-  //       end* (until) (catch)
-  if (linenr < lines () - 1)
-    {
-      int offset = 1;
-      size_t next_start;
-      QString next_line;
-      do                            // find next non-blank line
-        {
-          next_line = text (linenr + offset++);
-          next_start = next_line.toStdString ().find_first_not_of (" \t\n");
-        }
-      while (linenr + offset < lines ()
-             && next_start == std::string::npos);
-      if (next_start == std::string::npos)
-        next_start = 0;
-      if (next_start > start)       // more indented => don't add "end"
-        return;
-      if (next_start == start)      // same => check if already is "end"
-        {
-          QRegExp rx_start = QRegExp (R"((\w+))");
-          int tmp = rx_start.indexIn (next_line, start);
-           if (tmp != -1 && is_end (rx_start.cap(1), first_word))
-             return;
-        }
-    }
-
-    // If all of the above, insert a new line, with matching indent
-    // and either 'end' or 'end...', depending on a flag.
-
-    // If we insert directly after the last line, the "end" is autoindented,
-    // so add a dummy line.
-    if (linenr + 2 == lines ())
-      insertAt (QString ("\n"), linenr + 2, 0);
-
-    // For try/catch/end, fill "end" first, so "catch" is top of undo stack
-    if (first_word == "try")
-      insertAt (QString (start, ' ')
-                + (autofill_simple_end ? "end\n" : "end_try_catch\n"),
-                linenr + 2, 0);
-    else if (first_word == "unwind_protect")
-      insertAt (QString (start, ' ')
-                + (autofill_simple_end ? "end\n" : "end_unwind_protect\n"),
-                linenr + 2, 0);
-
-    QString next_line;
-    if (first_word == "do")
-      next_line = "until\n";
-    else if (first_word == "try")
-      next_line = "catch\n";
-    else if (first_word == "unwind_protect")
-      next_line = "unwind_protect_cleanup\n";
-    else if (autofill_simple_end)
-      next_line = "end\n";
-    else
-      {
-        if (first_word == "unwind_protect")
-          first_word = '_' + first_word;
-        next_line = "end" + first_word + "\n";
-      }
-
-    insertAt (QString (start, ' ') + next_line, linenr + 2, 0);
-}
-
-
 // Do smart indendation after if, for, ...
 void
 octave_qscintilla::smart_indent (bool do_smart_indent,
                                  int do_auto_close, int line)
 {
   QString prevline = text (line);
 
   QRegExp bkey = QRegExp ("^[\t ]*(if|for|while|switch|case|do|function"
@@ -617,64 +516,161 @@ octave_qscintilla::smart_indent (bool do
           setCursorPosition (line+1,
                                          indentation (line));
         }
       return;
     }
 
 }
 
-// Is a specific cursor position in a line or block comment?
-int
-octave_qscintilla::is_style_comment (int pos)
+void
+octave_qscintilla::contextmenu_help (bool)
+{
+  contextmenu_help_doc (false);
+}
+
+void
+octave_qscintilla::contextmenu_doc (bool)
 {
-  int lexer = SendScintilla (QsciScintillaBase::SCI_GETLEXER);
-  int style = get_style (pos);
+  contextmenu_help_doc (true);
+}
+
+void
+octave_qscintilla::context_help_doc (bool documentation)
+{
+  if (get_actual_word ())
+    contextmenu_help_doc (documentation);
+}
+
+void
+octave_qscintilla::contextmenu_edit (bool)
+{
+  emit context_menu_edit_signal (m_word_at_cursor);
+}
 
-  switch (lexer)
-    {
-      case SCLEX_CPP:
-        return (ST_LINE_COMMENT * (
-                          style == QsciLexerCPP::CommentLine
-                       || style == QsciLexerCPP::CommentLineDoc)
-              + ST_BLOCK_COMMENT * (
-                           style == QsciLexerCPP::Comment
-                        || style == QsciLexerCPP::CommentDoc
-                        || style == QsciLexerCPP::CommentDocKeyword
-                        || style == QsciLexerCPP::CommentDocKeywordError)
-                );
+void
+octave_qscintilla::contextmenu_run (bool)
+{
+  QStringList commands = selectedText ().split (QRegExp ("[\r\n]"),
+                                                QString::SkipEmptyParts);
+  for (int i = 0; i < commands.size (); i++)
+    emit execute_command_in_terminal_signal (commands.at (i));
+}
+
+// wrappers for dbstop related context menu items
+
+// FIXME: Why can't the data be sent as the argument to the function???
+void
+octave_qscintilla::contextmenu_break_condition (bool)
+{
+#if defined (HAVE_QSCI_VERSION_2_6_0)
+  QAction *action = qobject_cast<QAction *>(sender ());
+  QPoint local_pos = action->data ().value<QPoint> ();
+
+  // pick point just right of margins, so lineAt doesn't give -1
+  int margins = marginWidth (1) + marginWidth (2) + marginWidth (3);
+  local_pos = QPoint (margins + 1, local_pos.y ());
+
+  emit context_menu_break_condition_signal (lineAt (local_pos));
+#endif
+}
 
-#if defined (HAVE_LEXER_MATLAB)
-      case SCLEX_MATLAB:
-        return (ST_LINE_COMMENT * (style == QsciLexerMatlab::Comment));
+void
+octave_qscintilla::contextmenu_break_once (const QPoint& local_pos)
+{
+#if defined (HAVE_QSCI_VERSION_2_6_0)
+  emit context_menu_break_once (lineAt (local_pos));
 #endif
-#if  defined (HAVE_LEXER_OCTAVE)
-      case SCLEX_OCTAVE:
-        return (ST_LINE_COMMENT * (style == QsciLexerOctave::Comment));
-#endif
+}
+
+void
+octave_qscintilla::text_changed (void)
+{
+  emit status_update (isUndoAvailable (), isRedoAvailable ());
+}
+
+// when edit area gets focus update information on undo/redo actions
+void octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
+{
+  emit status_update (isUndoAvailable (), isRedoAvailable ());
+
+  QsciScintilla::focusInEvent (focusEvent);
+}
+
+void
+octave_qscintilla::auto_close (int auto_endif, int linenr,
+                               const QString& line, QString& first_word)
+{
+  // Insert and "end" for an "if" etc., if needed.
+  // (Use of "while" allows "return" to skip the rest.
+  // It may be clearer to use "if" and "goto",
+  // but that violates the coding standards.)
 
-      case SCLEX_PERL:
-        return (ST_LINE_COMMENT * (style == QsciLexerPerl::Comment));
+  bool autofill_simple_end = (auto_endif == 2);
 
-      case SCLEX_BATCH:
-        return (ST_LINE_COMMENT * (style == QsciLexerBatch::Comment));
+  size_t start = line.toStdString ().find_first_not_of (" \t");
 
-      case SCLEX_DIFF:
-        return (ST_LINE_COMMENT * (style == QsciLexerDiff::Comment));
-
-      case SCLEX_BASH:
-        return (ST_LINE_COMMENT * (style == QsciLexerBash::Comment));
-
+  // Check if following line has the same or less indentation
+  // Check if the following line does not start with
+  //       end* (until) (catch)
+  if (linenr < lines () - 1)
+    {
+      int offset = 1;
+      size_t next_start;
+      QString next_line;
+      do                            // find next non-blank line
+        {
+          next_line = text (linenr + offset++);
+          next_start = next_line.toStdString ().find_first_not_of (" \t\n");
+        }
+      while (linenr + offset < lines ()
+             && next_start == std::string::npos);
+      if (next_start == std::string::npos)
+        next_start = 0;
+      if (next_start > start)       // more indented => don't add "end"
+        return;
+      if (next_start == start)      // same => check if already is "end"
+        {
+          QRegExp rx_start = QRegExp (R"((\w+))");
+          int tmp = rx_start.indexIn (next_line, start);
+           if (tmp != -1 && is_end (rx_start.cap(1), first_word))
+             return;
+        }
     }
 
-  return ST_NONE;
+    // If all of the above, insert a new line, with matching indent
+    // and either 'end' or 'end...', depending on a flag.
+
+    // If we insert directly after the last line, the "end" is autoindented,
+    // so add a dummy line.
+    if (linenr + 2 == lines ())
+      insertAt (QString ("\n"), linenr + 2, 0);
+
+    // For try/catch/end, fill "end" first, so "catch" is top of undo stack
+    if (first_word == "try")
+      insertAt (QString (start, ' ')
+                + (autofill_simple_end ? "end\n" : "end_try_catch\n"),
+                linenr + 2, 0);
+    else if (first_word == "unwind_protect")
+      insertAt (QString (start, ' ')
+                + (autofill_simple_end ? "end\n" : "end_unwind_protect\n"),
+                linenr + 2, 0);
+
+    QString next_line;
+    if (first_word == "do")
+      next_line = "until\n";
+    else if (first_word == "try")
+      next_line = "catch\n";
+    else if (first_word == "unwind_protect")
+      next_line = "unwind_protect_cleanup\n";
+    else if (autofill_simple_end)
+      next_line = "end\n";
+    else
+      {
+        if (first_word == "unwind_protect")
+          first_word = '_' + first_word;
+        next_line = "end" + first_word + "\n";
+      }
+
+    insertAt (QString (start, ' ') + next_line, linenr + 2, 0);
 }
 
-// Function returning the true cursor position where the tab length
-// is taken into account.
-void
-octave_qscintilla::get_current_position (int *pos, int *line, int *col)
-{
-  *pos = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
-  *line = SendScintilla (QsciScintillaBase::SCI_LINEFROMPOSITION, *pos);
-  *col = SendScintilla (QsciScintillaBase::SCI_GETCOLUMN, *pos);
-}
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -31,46 +31,47 @@ along with Octave; see the file COPYING.
 
 class octave_qscintilla : public QsciScintilla
 {
   Q_OBJECT
 
 public:
 
   octave_qscintilla (QWidget *p);
-  ~octave_qscintilla ();
+
+  ~octave_qscintilla (void) = default;
 
   enum
     {
       ST_NONE = 0,
       ST_LINE_COMMENT,
       ST_BLOCK_COMMENT
     };
 
   virtual void contextMenuEvent (QContextMenuEvent *e);
 
   void context_help_doc (bool);
-  void context_edit ();
-  void context_run ();
+  void context_edit (void);
+  void context_run (void);
   void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
-  bool get_actual_word ();
+  bool get_actual_word (void);
   void clear_indicator (int indicator_style);
   void get_current_position (int *pos, int *line, int *col);
-  QString comment_string ();
+  QString comment_string (void);
   int get_style (int pos = -1);
   int is_style_comment (int pos = -1);
   void smart_indent (bool do_smart_indent, int do_auto_close, int line);
 
 signals:
 
   void execute_command_in_terminal_signal (const QString&);
   void create_context_menu_signal (QMenu*);
   void context_menu_edit_signal (const QString&);
   void qsci_has_focus_signal (bool);
-  void status_update (bool,bool);
+  void status_update (bool, bool);
   void show_doc_signal (const QString&);
   void context_menu_break_condition_signal (int);
   void context_menu_break_once (int);
 
 private slots:
 
   void contextmenu_help (bool);
   void contextmenu_doc (bool);
@@ -87,13 +88,12 @@ protected:
 
   void focusInEvent (QFocusEvent *focusEvent);
 
 private:
 
   void auto_close (int auto_endif, int l,
                    const QString& line, QString& first_word);
 
-  QString _word_at_cursor;
-
+  QString m_word_at_cursor;
 };
 
 #endif
diff --git a/libgui/src/m-editor/octave-txt-lexer.cc b/libgui/src/m-editor/octave-txt-lexer.cc
--- a/libgui/src/m-editor/octave-txt-lexer.cc
+++ b/libgui/src/m-editor/octave-txt-lexer.cc
@@ -37,20 +37,20 @@ octave_txt_lexer::description (int style
 {
   if (style == 0)
     return tr ("Default");
   else
     return QString ();
 };
 
 const char*
-octave_txt_lexer::language () const
+octave_txt_lexer::language (void) const
 {
   return "Text";
 }
 
 const char*
-octave_txt_lexer::lexer () const
+octave_txt_lexer::lexer (void) const
 {
   return "text";
 }
 
 #endif
diff --git a/libgui/src/m-editor/octave-txt-lexer.h b/libgui/src/m-editor/octave-txt-lexer.h
--- a/libgui/src/m-editor/octave-txt-lexer.h
+++ b/libgui/src/m-editor/octave-txt-lexer.h
@@ -30,15 +30,16 @@ along with Octave; see the file COPYING.
 
 
 class octave_txt_lexer : public QsciLexer
 {
   Q_OBJECT
 
 public:
 
-  virtual const char * language () const;
-  virtual const char * lexer () const;
+  virtual const char * language (void) const;
+
+  virtual const char * lexer (void) const;
+
   virtual QString description (int style) const;
-
 };
 
 #endif
