# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1446670582 18000
#      Wed Nov 04 15:56:22 2015 -0500
# Node ID 4b00afb5e9c3aaf20bdde71ec16a708e273abdea
# Parent  0d5d8db5579095e632e906b6105aeb9e2116824c
eliminate more uses of error_state

* __lin_interpn__.cc, __qp__.cc, error.cc, file-io.cc, help.cc,
hex2num.cc, inv.cc, load-save.cc, rand.cc, symtab.cc, toplev.cc,
amd.cc, qr.cc, ov-base.cc, ov-classdef.cc:
Eliminate most  trivial uses of error_state.

diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -288,66 +288,42 @@ Undocumented internal function.\n\
 
   if (args(n).is_single_type ())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
 
       const FloatNDArray V = args(n).float_array_value ();
 
-      if (error_state)
-        {
-          print_usage ();
-          return retval;
-        }
-
       for (int i = 0; i < n; i++)
         {
           X[i] = args(i).float_array_value ();
           Y[i] = args(n+i+1).float_array_value ();
 
-          if (error_state)
-            {
-              print_usage ();
-              return retval;
-            }
-
           if (Y[0].dims () != Y[i].dims ())
             {
               error ("interpn: incompatible size of argument number %d", n+i+2);
               return retval;
             }
         }
 
       retval = lin_interpn<float, FloatNDArray> (n, X, V, Y);
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (NDArray, X, n);
       OCTAVE_LOCAL_BUFFER (NDArray, Y, n);
 
       const NDArray V = args(n).array_value ();
 
-      if (error_state)
-        {
-          print_usage ();
-          return retval;
-        }
-
       for (int i = 0; i < n; i++)
         {
           X[i] = args(i).array_value ();
           Y[i] = args(n+i+1).array_value ();
 
-          if (error_state)
-            {
-              print_usage ();
-              return retval;
-            }
-
           if (Y[0].dims () != Y[i].dims ())
             {
               error ("interpn: incompatible size of argument number %d", n+i+2);
               return retval;
             }
         }
 
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -493,40 +493,30 @@ Undocumented internal function.\n\
       const Matrix H         (args(1) . matrix_value ());
       const ColumnVector q   (args(2) . vector_value ());
       const Matrix Aeq       (args(3) . matrix_value ());
       const ColumnVector beq (args(4) . vector_value ());
       const Matrix Ain       (args(5) . matrix_value ());
       const ColumnVector bin (args(6) . vector_value ());
       const int maxit        (args(7) . int_value ());
 
-      if (! error_state)
-        {
-          int iter = 0;
+      int iter = 0;
 
-          // Copying the initial guess in the working variable
-          ColumnVector x = x0;
-
-          // Reordering the Lagrange multipliers
-          ColumnVector lambda;
-
-          int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
+      // Copying the initial guess in the working variable
+      ColumnVector x = x0;
 
-          if (! error_state)
-            {
-              retval(3) = iter;
-              retval(2) = info;
-              retval(1) = lambda;
-              retval(0) = x;
-            }
-          else
-            error ("qp: internal error");
-        }
-      else
-        error ("__qp__: invalid arguments");
+      // Reordering the Lagrange multipliers
+      ColumnVector lambda;
+
+      int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
+
+      retval(3) = iter;
+      retval(2) = info;
+      retval(1) = lambda;
+      retval(0) = x;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1419,230 +1419,221 @@ disable escape sequence expansion use a 
   int argc = nargin + 1;
 
   bool done = false;
 
   if (argc > 1 && args.all_strings_p ())
     {
       string_vector argv = args.make_argv ("warning");
 
-      if (! error_state)
-        {
-          std::string arg1 = argv(1);
-          std::string arg2 = "all";
-
-          if (argc >= 3)
-            arg2 = argv(2);
+      std::string arg1 = argv(1);
+      std::string arg2 = "all";
 
-          if (arg1 == "on" || arg1 == "off" || arg1 == "error")
-            {
-              octave_map old_warning_options = warning_options;
+      if (argc >= 3)
+        arg2 = argv(2);
 
-              if (argc == 4 && argv(3) == "local"
-                  && ! symbol_table::at_top_level ())
-                {
-                  symbol_table::scope_id scope
-                    = octave_call_stack::current_scope ();
-
-                  symbol_table::context_id context
-                    = octave_call_stack::current_context ();
+      if (arg1 == "on" || arg1 == "off" || arg1 == "error")
+        {
+          octave_map old_warning_options = warning_options;
 
-                  octave_scalar_map val = warning_query (arg2);
-
-                  octave_value curr_state = val.contents ("state");
-
-                  // FIXME: this might be better with a dictionary object.
+          if (argc == 4 && argv(3) == "local"
+              && ! symbol_table::at_top_level ())
+            {
+              symbol_table::scope_id scope
+                = octave_call_stack::current_scope ();
 
-                  octave_value curr_warning_states
-                    = symbol_table::varval (".saved_warning_states.",
-                                            scope, context);
-
-                  octave_map m;
+              symbol_table::context_id context
+                = octave_call_stack::current_context ();
 
-                  if (curr_warning_states.is_defined ())
-                    m = curr_warning_states.map_value ();
-                  else
-                    {
-                      string_vector fields (2);
+              octave_scalar_map val = warning_query (arg2);
+
+              octave_value curr_state = val.contents ("state");
 
-                      fields(0) = "identifier";
-                      fields(1) = "state";
+              // FIXME: this might be better with a dictionary object.
 
-                      m = octave_map (dim_vector (0, 1), fields);
-                    }
+              octave_value curr_warning_states
+                = symbol_table::varval (".saved_warning_states.",
+                                        scope, context);
 
-                  if (error_state)
-                    panic_impossible ();
-
-                  Cell ids = m.contents ("identifier");
-                  Cell states = m.contents ("state");
+              octave_map m;
 
-                  octave_idx_type nel = states.numel ();
-                  bool found = false;
-                  octave_idx_type i;
-                  for (i = 0; i < nel; i++)
-                    {
-                      std::string id = ids(i).string_value ();
+              if (curr_warning_states.is_defined ())
+                m = curr_warning_states.map_value ();
+              else
+                {
+                  string_vector fields (2);
 
-                      if (error_state)
-                        panic_impossible ();
+                  fields(0) = "identifier";
+                  fields(1) = "state";
+
+                  m = octave_map (dim_vector (0, 1), fields);
+                }
 
-                      if (id == arg2)
-                        {
-                          states(i) = curr_state;
-                          found = true;
-                          break;
-                        }
-                    }
-
-                  if (! found)
-                    {
-                      m.resize (dim_vector (nel+1, 1));
+              Cell ids = m.contents ("identifier");
+              Cell states = m.contents ("state");
 
-                      ids.resize (dim_vector (nel+1, 1));
-                      states.resize (dim_vector (nel+1, 1));
-
-                      ids(nel) = arg2;
-                      states(nel) = curr_state;
-                    }
+              octave_idx_type nel = states.numel ();
+              bool found = false;
+              octave_idx_type i;
+              for (i = 0; i < nel; i++)
+                {
+                  std::string id = ids(i).string_value ();
 
-                  m.contents ("identifier") = ids;
-                  m.contents ("state") = states;
-
-                  symbol_table::assign
-                    (".saved_warning_states.", m, scope, context);
-
-                  // Now ignore the "local" argument and continue to
-                  // handle the current setting.
-                  argc--;
+                  if (id == arg2)
+                    {
+                      states(i) = curr_state;
+                      found = true;
+                      break;
+                    }
                 }
 
-              if (arg2 == "all")
+              if (! found)
                 {
-                  octave_map tmp;
+                  m.resize (dim_vector (nel+1, 1));
+
+                  ids.resize (dim_vector (nel+1, 1));
+                  states.resize (dim_vector (nel+1, 1));
 
-                  Cell id (1, 1);
-                  Cell st (1, 1);
+                  ids(nel) = arg2;
+                  states(nel) = curr_state;
+                }
 
-                  id(0) = arg2;
-                  st(0) = arg1;
+              m.contents ("identifier") = ids;
+              m.contents ("state") = states;
 
-                  // Since internal Octave functions are not
-                  // compatible, turning all warnings into errors
-                  // should leave the state of
-                  // Octave:language-extension alone.
+              symbol_table::assign
+                (".saved_warning_states.", m, scope, context);
+
+              // Now ignore the "local" argument and continue to
+              // handle the current setting.
+              argc--;
+            }
 
-                  if (arg1 == "error"
-                      && warning_options.contains ("identifier"))
-                    {
-                      octave_idx_type n = 1;
+          if (arg2 == "all")
+            {
+              octave_map tmp;
+
+              Cell id (1, 1);
+              Cell st (1, 1);
+
+              id(0) = arg2;
+              st(0) = arg1;
 
-                      Cell tid = warning_options.contents ("identifier");
-                      Cell tst = warning_options.contents ("state");
+              // Since internal Octave functions are not
+              // compatible, turning all warnings into errors
+              // should leave the state of
+              // Octave:language-extension alone.
 
-                      for (octave_idx_type i = 0; i < tid.numel (); i++)
-                        {
-                          octave_value vid = tid(i);
+              if (arg1 == "error"
+                  && warning_options.contains ("identifier"))
+                {
+                  octave_idx_type n = 1;
 
-                          if (vid.is_string ())
-                            {
-                              std::string key = vid.string_value ();
+                  Cell tid = warning_options.contents ("identifier");
+                  Cell tst = warning_options.contents ("state");
 
-                              if (key == "Octave:language-extension"
-                                  || key == "Octave:single-quote-string")
-                                {
-                                  id.resize (dim_vector (1, n+1));
-                                  st.resize (dim_vector (1, n+1));
+                  for (octave_idx_type i = 0; i < tid.numel (); i++)
+                    {
+                      octave_value vid = tid(i);
+
+                      if (vid.is_string ())
+                        {
+                          std::string key = vid.string_value ();
 
-                                  id(n) = tid(i);
-                                  st(n) = tst(i);
+                          if (key == "Octave:language-extension"
+                              || key == "Octave:single-quote-string")
+                            {
+                              id.resize (dim_vector (1, n+1));
+                              st.resize (dim_vector (1, n+1));
 
-                                  n++;
-                                }
+                              id(n) = tid(i);
+                              st(n) = tst(i);
+
+                              n++;
                             }
                         }
                     }
-
-                  tmp.assign ("identifier", id);
-                  tmp.assign ("state", st);
-
-                  warning_options = tmp;
-
-                  done = true;
-                }
-              else if (arg2 == "backtrace")
-                {
-                  if (arg1 != "error")
-                    {
-                      Vbacktrace_on_warning = (arg1 == "on");
-                      done = true;
-                    }
-                }
-              else if (arg2 == "debug")
-                {
-                  if (arg1 != "error")
-                    {
-                      Vdebug_on_warning = (arg1 == "on");
-                      done = true;
-                    }
-                }
-              else if (arg2 == "verbose")
-                {
-                  if (arg1 != "error")
-                    {
-                      Vverbose_warning = (arg1 == "on");
-                      done = true;
-                    }
-                }
-              else if (arg2 == "quiet")
-                {
-                  if (arg1 != "error")
-                    {
-                      Vquiet_warning = (arg1 == "on");
-                      done = true;
-                    }
-                }
-              else
-                {
-                  if (arg2 == "last")
-                    arg2 = Vlast_warning_id;
-
-                  set_warning_option (arg1, arg2);
-
-                  done = true;
                 }
 
-              if (done && nargout > 0)
-                retval = old_warning_options;
-            }
-          else if (arg1 == "query")
-            {
-              if (arg2 == "all")
-                retval = warning_options;
-              else if (arg2 == "backtrace" || arg2 == "debug"
-                       || arg2 == "verbose" || arg2 == "quiet")
-                {
-                  octave_scalar_map tmp;
-                  tmp.assign ("identifier", arg2);
-                  if (arg2 == "backtrace")
-                    tmp.assign ("state", Vbacktrace_on_warning ? "on" : "off");
-                  else if (arg2 == "debug")
-                    tmp.assign ("state", Vdebug_on_warning ? "on" : "off");
-                  else if (arg2 == "verbose")
-                    tmp.assign ("state", Vverbose_warning ? "on" : "off");
-                  else
-                    tmp.assign ("state", Vquiet_warning ? "on" : "off");
+              tmp.assign ("identifier", id);
+              tmp.assign ("state", st);
 
-                  retval = tmp;
-                }
-              else
-                retval = warning_query (arg2);
+              warning_options = tmp;
 
               done = true;
             }
+          else if (arg2 == "backtrace")
+            {
+              if (arg1 != "error")
+                {
+                  Vbacktrace_on_warning = (arg1 == "on");
+                  done = true;
+                }
+            }
+          else if (arg2 == "debug")
+            {
+              if (arg1 != "error")
+                {
+                  Vdebug_on_warning = (arg1 == "on");
+                  done = true;
+                }
+            }
+          else if (arg2 == "verbose")
+            {
+              if (arg1 != "error")
+                {
+                  Vverbose_warning = (arg1 == "on");
+                  done = true;
+                }
+            }
+          else if (arg2 == "quiet")
+            {
+              if (arg1 != "error")
+                {
+                  Vquiet_warning = (arg1 == "on");
+                  done = true;
+                }
+            }
+          else
+            {
+              if (arg2 == "last")
+                arg2 = Vlast_warning_id;
+
+              set_warning_option (arg1, arg2);
+
+              done = true;
+            }
+
+          if (done && nargout > 0)
+            retval = old_warning_options;
+        }
+      else if (arg1 == "query")
+        {
+          if (arg2 == "all")
+            retval = warning_options;
+          else if (arg2 == "backtrace" || arg2 == "debug"
+                   || arg2 == "verbose" || arg2 == "quiet")
+            {
+              octave_scalar_map tmp;
+              tmp.assign ("identifier", arg2);
+              if (arg2 == "backtrace")
+                tmp.assign ("state", Vbacktrace_on_warning ? "on" : "off");
+              else if (arg2 == "debug")
+                tmp.assign ("state", Vdebug_on_warning ? "on" : "off");
+              else if (arg2 == "verbose")
+                tmp.assign ("state", Vverbose_warning ? "on" : "off");
+              else
+                tmp.assign ("state", Vquiet_warning ? "on" : "off");
+
+              retval = tmp;
+            }
+          else
+            retval = warning_query (arg2);
+
+          done = true;
         }
     }
   else if (argc == 1)
     {
       if (nargout > 0)
         retval = warning_options;
       else
         display_warning_options (octave_stdout);
@@ -1668,43 +1659,37 @@ disable escape sequence expansion use a 
 
               octave_idx_type nel = ident.numel ();
 
               for (octave_idx_type i = 0; i < nel; i++)
                 {
                   std::string tst = state(i).string_value ();
                   std::string tid = ident(i).string_value ();
 
-                  if (error_state)
-                    return retval;
-
                   set_warning_option (tst, tid);
                 }
             }
           else
             error ("warning: expecting structure with fields 'identifier' and 'state'");
 
           done = true;
 
           if (nargout > 0)
             retval = old_warning_options;
         }
     }
 
-  if (! (error_state || done))
+  if (! done)
     {
       octave_value_list nargs = args;
 
       std::string id;
 
       bool have_fmt = maybe_extract_message_id ("warning", args, nargs, id);
 
-      if (error_state)
-        return retval;
-
       std::string prev_msg = Vlast_warning_message;
 
       std::string curr_msg = handle_message (warning_with_id, id.c_str (),
                                              "unspecified warning", nargs,
                                              have_fmt);
 
       if (nargout > 0)
         retval = prev_msg;
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1223,32 +1223,27 @@ character to be read is returned in @var
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       std::string data = get_sscanf_data (args(0));
 
-      if (! error_state)
-        {
-          octave_stream os = octave_istrstream::create (data);
+      octave_stream os = octave_istrstream::create (data);
 
-          if (os.is_valid ())
-            {
-              if (args(1).is_string ())
-                retval = os.oscanf (args(1), who);
-              else
-                error ("%s: format TEMPLATE must be a string", who.c_str ());
-            }
+      if (os.is_valid ())
+        {
+          if (args(1).is_string ())
+            retval = os.oscanf (args(1), who);
           else
-            error ("%s: unable to create temporary input buffer", who.c_str ());
+            error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
       else
-        error ("%s: argument STRING must be a string", who.c_str ());
+        error ("%s: unable to create temporary input buffer", who.c_str ());
     }
   else
     {
       if (nargin == 2 || nargin == 3)
         {
           retval(3) = -1.0;
           retval(2) = "unknown error";
           retval(1) = 0.0;
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -930,26 +930,27 @@ raw_help (const std::string& nm, bool& s
 {
   std::string h;
   std::string w;
   std::string f;
 
   bool found;
 
   found = raw_help_from_symbol_table (nm, h, w, symbol_found);
-  if (! found && ! error_state)
+
+  if (! found)
     {
       found = raw_help_from_file (nm, h, f, symbol_found);
-      if (! found && ! error_state)
+
+      if (! found)
         {
           found = raw_help_from_map (nm, h, operators_map, symbol_found);
-          if (! found && ! error_state)
-            {
-              raw_help_from_map (nm, h, keywords_map, symbol_found);
-            }
+
+          if (! found)
+            raw_help_from_map (nm, h, keywords_map, symbol_found);
         }
     }
 
   return h;
 }
 
 DEFUN (built_in_docstrings_file, args, nargout,
        "-*- texinfo -*-\n\
@@ -1286,50 +1287,47 @@ DEFUN (__which__, args, ,
 @deftypefn {Built-in Function} {} __which__ (@var{name}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   string_vector argv = args.make_argv ("which");
 
-  if (! error_state)
-    {
-      int argc = argv.numel ();
+  int argc = argv.numel ();
 
-      if (argc > 1)
-        {
-          octave_map m (dim_vector (1, argc-1));
+  if (argc > 1)
+    {
+      octave_map m (dim_vector (1, argc-1));
 
-          Cell names (1, argc-1);
-          Cell files (1, argc-1);
-          Cell types (1, argc-1);
+      Cell names (1, argc-1);
+      Cell files (1, argc-1);
+      Cell types (1, argc-1);
 
-          for (int i = 1; i < argc; i++)
-            {
-              std::string name = argv[i];
+      for (int i = 1; i < argc; i++)
+        {
+          std::string name = argv[i];
+
+          std::string type;
 
-              std::string type;
-
-              std::string file = do_which (name, type);
+          std::string file = do_which (name, type);
 
-              names(i-1) = name;
-              files(i-1) = file;
-              types(i-1) = type;
-            }
+          names(i-1) = name;
+          files(i-1) = file;
+          types(i-1) = type;
+        }
 
-          m.assign ("name", names);
-          m.assign ("file", files);
-          m.assign ("type", types);
+      m.assign ("name", names);
+      m.assign ("file", files);
+      m.assign ("type", types);
 
-          retval = m;
-        }
-      else
-        print_usage ();
+      retval = m;
     }
+  else
+    print_usage ();
 
   return retval;
 }
 
 // FIXME: Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -78,17 +78,17 @@ hex2num ([\"402df854\"; \"41200000\"], \
       std::string prec = (nargin == 2) ? args(1).string_value () : "double";
       bool is_single = (prec == "single");
       octave_idx_type nchars = (is_single) ? 8 : 16;
 
       if (cmat.columns () > nchars)
         error ("hex2num: S must be no more than %d characters", nchars);
       else if (prec != "double" && prec != "single")
         error ("hex2num: CLASS must be either \"double\" or \"single\"");
-      else if (! error_state)
+      else
         {
           octave_idx_type nr = cmat.rows ();
           octave_idx_type nc = cmat.columns ();
 
           if (is_single)
             {
               FloatColumnVector m (nr);
 
@@ -118,29 +118,23 @@ hex2num ([\"402df854\"; \"41200000\"], \
                         }
                       else
                         {
                           error ("hex2num: illegal character found in string S");
                           break;
                         }
                     }
 
-                  if (error_state)
-                    break;
-                  else
-                    {
-                      if (nc < nchars)
-                        num.ival <<= (nchars - nc) * 4;
+                  if (nc < nchars)
+                    num.ival <<= (nchars - nc) * 4;
 
-                      m(i) = num.dval;
-                    }
+                  m(i) = num.dval;
                 }
 
-              if (! error_state)
-                retval =  m;
+              retval =  m;
             }
           else
             {
               ColumnVector m (nr);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   union
@@ -167,29 +161,23 @@ hex2num ([\"402df854\"; \"41200000\"], \
                         }
                       else
                         {
                           error ("hex2num: illegal character found in string S");
                           break;
                         }
                     }
 
-                  if (error_state)
-                    break;
-                  else
-                    {
-                      if (nc < nchars)
-                        num.ival <<= (nchars - nc) * 4;
+                  if (nc < nchars)
+                    num.ival <<= (nchars - nc) * 4;
 
-                      m(i) = num.dval;
-                    }
+                  m(i) = num.dval;
                 }
 
-              if (! error_state)
-                retval =  m;
+              retval =  m;
             }
         }
     }
 
   return retval;
 }
 
 /*
@@ -234,85 +222,79 @@ num2hex (single ([-1, 1, e, Inf]))\n\
   octave_value retval;
 
   if (nargin != 1)
     print_usage ();
   else if (args(0).is_single_type ())
     {
       const FloatColumnVector v (args(0).float_vector_value ());
 
-      if (! error_state)
-        {
-          octave_idx_type nchars = 8;
-          octave_idx_type nr = v.numel ();
-          charMatrix m (nr, nchars);
-          const float *pv = v.fortran_vec ();
+      octave_idx_type nchars = 8;
+      octave_idx_type nr = v.numel ();
+      charMatrix m (nr, nchars);
+      const float *pv = v.fortran_vec ();
 
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              union
-              {
-                uint32_t ival;
-                float dval;
-              } num;
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          union
+          {
+            uint32_t ival;
+            float dval;
+          } num;
+
+          num.dval = *pv++;
 
-              num.dval = *pv++;
+          for (octave_idx_type j = 0; j < nchars; j++)
+            {
+              unsigned char ch =
+                static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
+              if (ch >= 10)
+                ch += 'a' - 10;
+              else
+                ch += '0';
 
-              for (octave_idx_type j = 0; j < nchars; j++)
-                {
-                  unsigned char ch =
-                    static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
-                  if (ch >= 10)
-                    ch += 'a' - 10;
-                  else
-                    ch += '0';
+              m.elem (i, j) = ch;
+            }
+        }
 
-                  m.elem (i, j) = ch;
-                }
-            }
-
-          retval = m;
-        }
+      retval = m;
     }
   else
     {
       const ColumnVector v (args(0).vector_value ());
 
-      if (! error_state)
-        {
-          octave_idx_type nchars = 16;
-          octave_idx_type nr = v.numel ();
-          charMatrix m (nr, nchars);
-          const double *pv = v.fortran_vec ();
+      octave_idx_type nchars = 16;
+      octave_idx_type nr = v.numel ();
+      charMatrix m (nr, nchars);
+      const double *pv = v.fortran_vec ();
 
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              union
-              {
-                uint64_t ival;
-                double dval;
-              } num;
+      for (octave_idx_type i = 0; i < nr; i++)
+        {
+          union
+          {
+            uint64_t ival;
+            double dval;
+          } num;
+
+          num.dval = *pv++;
 
-              num.dval = *pv++;
+          for (octave_idx_type j = 0; j < nchars; j++)
+            {
+              unsigned char ch =
+                static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
+              if (ch >= 10)
+                ch += 'a' - 10;
+              else
+                ch += '0';
 
-              for (octave_idx_type j = 0; j < nchars; j++)
-                {
-                  unsigned char ch =
-                    static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
-                  if (ch >= 10)
-                    ch += 'a' - 10;
-                  else
-                    ch += '0';
+              m.elem (i, j) = ch;
+            }
+        }
 
-                  m.elem (i, j) = ch;
-                }
-            }
-
-          retval = m;
-        }
+      retval = m;
     }
 
   return retval;
 }
 
 /*
 %!assert (num2hex (-2:2), ["c000000000000000";"bff0000000000000";"0000000000000000";"3ff0000000000000";"4000000000000000"])
 %!assert (num2hex (single (-2:2)), ["c0000000";"bf800000";"00000000";"3f800000";"40000000"])
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -133,109 +133,94 @@ sparse matrix if possible.\n\
       info = 0;
       result = arg.perm_matrix_value ().inverse ();
     }
   else if (isfloat)
     {
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
-          if (! error_state)
-            {
-              MatrixType mattyp = args(0).matrix_type ();
-              result = m.inverse (mattyp, info, frcond, 1);
-              args(0).matrix_type (mattyp);
-            }
+
+          MatrixType mattyp = args(0).matrix_type ();
+          result = m.inverse (mattyp, info, frcond, 1);
+          args(0).matrix_type (mattyp);
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
-          if (! error_state)
-            {
-              MatrixType mattyp = args(0).matrix_type ();
-              result = m.inverse (mattyp, info, frcond, 1);
-              args(0).matrix_type (mattyp);
-            }
+
+          MatrixType mattyp = args(0).matrix_type ();
+          result = m.inverse (mattyp, info, frcond, 1);
+          args(0).matrix_type (mattyp);
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
-              if (! error_state)
-                {
-                  MatrixType mattyp = args(0).matrix_type ();
-                  result = m.inverse (mattyp, info, rcond, 1);
-                  args(0).matrix_type (mattyp);
-                }
+
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, rcond, 1);
+              args(0).matrix_type (mattyp);
             }
           else
             {
               Matrix m = arg.matrix_value ();
-              if (! error_state)
-                {
-                  MatrixType mattyp = args(0).matrix_type ();
-                  result = m.inverse (mattyp, info, rcond, 1);
-                  args(0).matrix_type (mattyp);
-                }
+
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, rcond, 1);
+              args(0).matrix_type (mattyp);
             }
         }
       else if (arg.is_complex_type ())
         {
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
-              if (! error_state)
-                {
-                  MatrixType mattyp = args(0).matrix_type ();
-                  result = m.inverse (mattyp, info, rcond, 1);
-                  args(0).matrix_type (mattyp);
-                }
+
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, rcond, 1);
+              args(0).matrix_type (mattyp);
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
-              if (! error_state)
-                {
-                  MatrixType mattyp = args(0).matrix_type ();
-                  result = m.inverse (mattyp, info, rcond, 1);
-                  args(0).matrix_type (mattyp);
-                }
+
+              MatrixType mattyp = args(0).matrix_type ();
+              result = m.inverse (mattyp, info, rcond, 1);
+              args(0).matrix_type (mattyp);
             }
         }
       else
         gripe_wrong_type_arg ("inv", arg);
     }
 
-  if (! error_state)
-    {
-      if (nargout > 1)
-        retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
+  if (nargout > 1)
+    retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
 
-      retval(0) = result;
+  retval(0) = result;
 
-      bool rcond_plus_one_eq_one = false;
+  bool rcond_plus_one_eq_one = false;
 
-      if (isfloat)
-        {
-          volatile float xrcond = frcond;
-          rcond_plus_one_eq_one = xrcond + 1.0F == 1.0F;
-        }
-      else
-        {
-          volatile double xrcond = rcond;
-          rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
-        }
+  if (isfloat)
+    {
+      volatile float xrcond = frcond;
+      rcond_plus_one_eq_one = xrcond + 1.0F == 1.0F;
+    }
+  else
+    {
+      volatile double xrcond = rcond;
+      rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
+    }
 
-      if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
-        gripe_singular_matrix (isfloat ? frcond : rcond);
-    }
+  if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
+    gripe_singular_matrix (isfloat ? frcond : rcond);
 
   return retval;
 }
 
 /*
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -629,19 +629,16 @@ Force Octave to assume the file is in Oc
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("load");
 
-  if (error_state)
-    return retval;
-
   int i = 1;
   std::string orig_fname = "";
 
   // Function called with Matlab-style ["filename", options] syntax
   if (argc > 1 && ! argv[1].empty () && argv[1].at (0) != '-')
     {
       orig_fname = argv[1];
       i++;
@@ -756,19 +753,16 @@ Force Octave to assume the file is in Oc
         error ("load: must specify file format if reading from stdin");
     }
   else
     {
       std::string fname = file_ops::tilde_expand (orig_fname);
 
       fname = find_file_to_load (fname, orig_fname);
 
-      if (error_state)
-        return retval;
-
       bool use_zlib = false;
 
       if (format == LS_UNKNOWN)
         format = get_file_format (fname, orig_fname, use_zlib);
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         {
@@ -1025,19 +1019,16 @@ save_vars (std::ostream& os, const std::
 
   typedef std::list<symbol_table::symbol_record>::const_iterator
     const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       do_save (os, *p, fmt, save_as_floats);
 
-      if (error_state)
-        break;
-
       saved++;
     }
 
   return saved;
 }
 
 static string_vector
 parse_save_options (const string_vector &argv,
@@ -1367,19 +1358,16 @@ dump_octave_core (std::ostream& os, cons
           // FIXME: maybe we should try to throw out the largest first...
 
           if (Voctave_core_file_limit < 0
               || save_mem_size + val_size < Voctave_core_file_limit)
             {
               save_mem_size += val_size;
 
               do_save (os, val, name, help, global, fmt, save_as_floats);
-
-              if (error_state)
-                break;
             }
         }
     }
 
   message (0, "save to '%s' complete", fname);
 }
 
 void
@@ -1602,19 +1590,16 @@ saves the variable @samp{a} and all vari
 the file @file{data} in Octave's binary format.\n\
 @seealso{load, save_default_options, save_header_format_string, dlmread, csvread, fread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   string_vector argv = args.make_argv ();
 
-  if (error_state)
-    return retval;
-
   // Here is where we would get the default save format if it were
   // stored in a user preference variable.
 
   bool save_as_floats = false;
 
   load_save_format format = LS_TEXT;
 
   bool append = false;
@@ -1626,19 +1611,16 @@ the file @file{data} in Octave's binary 
                       use_zlib);
 
   // override from command line
   argv = parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
   int argc = argv.numel ();
   int i = 0;
 
-  if (error_state)
-    return retval;
-
   if (i == argc)
     {
       print_usage ();
       return retval;
     }
 
   if (save_as_floats && format == LS_TEXT)
     {
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -175,18 +175,17 @@ do_rand (const octave_value_list& args, 
               }
             else
               {
                 dims.resize (2);
 
                 dims(0) = NINTbig (tmp.double_value ());
                 dims(1) = NINTbig (tmp.double_value ());
 
-                if (! error_state)
-                  goto gen_matrix;
+                goto gen_matrix;
               }
           }
         else if (tmp.is_range ())
           {
             Range r = tmp.range_value ();
 
             if (r.all_elements_are_ints ())
               {
@@ -252,18 +251,17 @@ do_rand (const octave_value_list& args, 
             std::string ts = tmp.string_value ();
 
             if (ts == "seed")
               {
                 if (args(idx+1).is_real_scalar ())
                   {
                     double d = args(idx+1).double_value ();
 
-                    if (! error_state)
-                      octave_rand::seed (d);
+                    octave_rand::seed (d);
                   }
                 else if (args(idx+1).is_string ()
                          && args(idx+1).string_value () == "reset")
                   octave_rand::reset ();
                 else
                   error ("%s: seed must be a real scalar", fcn);
               }
             else if (ts == "state" || ts == "twister")
@@ -271,18 +269,17 @@ do_rand (const octave_value_list& args, 
                 if (args(idx+1).is_string ()
                     && args(idx+1).string_value () == "reset")
                   octave_rand::reset (fcn);
                 else
                   {
                     ColumnVector s =
                       ColumnVector (args(idx+1).vector_value(false, true));
 
-                    if (! error_state)
-                      octave_rand::state (s, fcn);
+                    octave_rand::state (s, fcn);
                   }
               }
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else
           {
             dims.resize (nargin);
@@ -1164,90 +1161,87 @@ using std::unordered_map;
 
       if (m > n)
         error ("randperm: M must be less than or equal to N");
 
       // Quick and dirty heuristic to decide if we allocate or not the
       // whole vector for tracking the truncated shuffle.
       bool short_shuffle = m < n/5;
 
-      if (! error_state)
-        {
-          // Generate random numbers.
-          NDArray r = octave_rand::nd_array (dim_vector (1, m));
-          double *rvec = r.fortran_vec ();
+      // Generate random numbers.
+      NDArray r = octave_rand::nd_array (dim_vector (1, m));
+      double *rvec = r.fortran_vec ();
 
-          octave_idx_type idx_len = short_shuffle ? m : n;
-          Array<octave_idx_type> idx;
-          try
-            {
-              idx = Array<octave_idx_type> (dim_vector (1, idx_len));
-            }
-          catch (const std::bad_alloc&)
-            {
-              // Looks like n is too big and short_shuffle is false.
-              // Let's try again, but this time with the alternative.
-              idx_len = m;
-              short_shuffle = true;
-              idx = Array<octave_idx_type> (dim_vector (1, idx_len));
-            }
+      octave_idx_type idx_len = short_shuffle ? m : n;
+      Array<octave_idx_type> idx;
+      try
+        {
+          idx = Array<octave_idx_type> (dim_vector (1, idx_len));
+        }
+      catch (const std::bad_alloc&)
+        {
+          // Looks like n is too big and short_shuffle is false.
+          // Let's try again, but this time with the alternative.
+          idx_len = m;
+          short_shuffle = true;
+          idx = Array<octave_idx_type> (dim_vector (1, idx_len));
+        }
 
-          octave_idx_type *ivec = idx.fortran_vec ();
+      octave_idx_type *ivec = idx.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < idx_len; i++)
+        ivec[i] = i;
 
-          for (octave_idx_type i = 0; i < idx_len; i++)
-            ivec[i] = i;
-
-          if (short_shuffle)
-            {
-              unordered_map<octave_idx_type, octave_idx_type> map (m);
+      if (short_shuffle)
+        {
+          unordered_map<octave_idx_type, octave_idx_type> map (m);
 
-              // Perform the Knuth shuffle only keeping track of moved
-              // entries in the map
-              for (octave_idx_type i = 0; i < m; i++)
-                {
-                  octave_idx_type k = i +
-                                      gnulib::floor (rvec[i] * (n - i));
+          // Perform the Knuth shuffle only keeping track of moved
+          // entries in the map
+          for (octave_idx_type i = 0; i < m; i++)
+            {
+              octave_idx_type k = i +
+                gnulib::floor (rvec[i] * (n - i));
 
-                  //For shuffling first m entries, no need to use extra
-                  //storage
-                  if (k < m)
-                    {
-                      std::swap (ivec[i], ivec[k]);
-                    }
-                  else
-                    {
-                      if (map.find (k) == map.end ())
-                        map[k] = k;
+              //For shuffling first m entries, no need to use extra
+              //storage
+              if (k < m)
+                {
+                  std::swap (ivec[i], ivec[k]);
+                }
+              else
+                {
+                  if (map.find (k) == map.end ())
+                    map[k] = k;
 
-                      std::swap (ivec[i], map[k]);
-                    }
+                  std::swap (ivec[i], map[k]);
                 }
             }
-          else
-            {
+        }
+      else
+        {
 
-              // Perform the Knuth shuffle of the first m entries
-              for (octave_idx_type i = 0; i < m; i++)
-                {
-                  octave_idx_type k = i +
-                                      gnulib::floor (rvec[i] * (n - i));
-                  std::swap (ivec[i], ivec[k]);
-                }
+          // Perform the Knuth shuffle of the first m entries
+          for (octave_idx_type i = 0; i < m; i++)
+            {
+              octave_idx_type k = i +
+                gnulib::floor (rvec[i] * (n - i));
+              std::swap (ivec[i], ivec[k]);
             }
+        }
 
-          // Convert to doubles, reusing r.
-          for (octave_idx_type i = 0; i < m; i++)
-            rvec[i] = ivec[i] + 1;
+      // Convert to doubles, reusing r.
+      for (octave_idx_type i = 0; i < m; i++)
+        rvec[i] = ivec[i] + 1;
 
-          if (m < n)
-            idx.resize (dim_vector (1, m));
+      if (m < n)
+        idx.resize (dim_vector (1, m));
 
-          // Now create an array object with a cached idx_vector.
-          retval = new octave_matrix (r, idx_vector (idx));
-        }
+      // Now create an array object with a cached idx_vector.
+      retval = new octave_matrix (r, idx_vector (idx));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -691,17 +691,17 @@ get_dispatch_type (const octave_value_li
 // than methods, but that does not seem to be the case.
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find (const octave_value_list& args,
                                             bool local_funcs)
 {
   octave_value retval = xfind (args, local_funcs);
 
-  if (! (error_state || retval.is_defined ()))
+  if (retval.is_undefined ())
     {
       // It is possible that the user created a file on the fly since
       // the last prompt or chdir, so try updating the load path and
       // searching again.
 
       load_path::update ();
 
       retval = xfind (args, local_funcs);
@@ -1071,17 +1071,17 @@ symbol_table::fcn_info::fcn_info_rep::fi
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
 {
   // Function on the path.
 
   if (function_on_path.is_defined ())
     out_of_date_check (function_on_path);
 
-  if (! (error_state || function_on_path.is_defined ()))
+  if (function_on_path.is_undefined ())
     {
       std::string dir_name;
 
       std::string file_name = load_path::find_fcn (name, dir_name,
                                                    package_name);
 
       if (! file_name.empty ())
         {
@@ -1098,17 +1098,17 @@ symbol_table::fcn_info::fcn_info_rep::fi
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_package (void)
 {
   // FIXME: implement correct way to check out of date package
   //if (package.is_defined ())
   //  out_of_date_check (package);
 
-  if (! (error_state || package.is_defined ()))
+  if (package.is_undefined ())
     {
       octave_function * fcn =
         cdef_manager::find_package_symbol (full_name ());
 
       if (fcn)
         package = octave_value (fcn);
     }
 
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -840,34 +840,30 @@ to run using @code{atexit}.\n\
   if (! quit_allowed)
     error ("quit: not supported in embedded mode");
   else
     {
       if (args.length () > 0)
         {
           int tmp = args(0).nint_value ();
 
-          if (! error_state)
-            exit_status = tmp;
+          exit_status = tmp;
         }
 
-      if (! error_state)
-        {
-          // Instead of simply calling exit, we simulate an interrupt
-          // with a request to exit cleanly so that no matter where the
-          // call to quit occurs, we will run the unwind_protect stack,
-          // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
-          // exiting.
+      // Instead of simply calling exit, we simulate an interrupt
+      // with a request to exit cleanly so that no matter where the
+      // call to quit occurs, we will run the unwind_protect stack,
+      // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
+      // exiting.
 
-          quitting_gracefully = true;
+      quitting_gracefully = true;
 
-          octave_interrupt_state = -1;
+      octave_interrupt_state = -1;
 
-          octave_throw_interrupt_exception ();
-        }
+      octave_throw_interrupt_exception ();
     }
 
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
 DEFUN (warranty, , ,
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -125,17 +125,17 @@ The author of the code itself is Timothy
             sm = SparseMatrix (args(0).matrix_value ());
 
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
-      if (!error_state && n_row != n_col)
+      if (n_row != n_col)
         error ("amd: matrix S must be square");
 
       OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
       AMD_NAME (_defaults) (Control) ;
       if (nargin > 1)
         {
           octave_scalar_map arg1 = args(1).scalar_map_value ();
 
@@ -150,55 +150,52 @@ The author of the code itself is Timothy
               tmp = arg1.getfield ("aggressive");
               if (tmp.is_defined ())
                 Control[AMD_AGGRESSIVE] = tmp.double_value ();
             }
           else
             error ("amd: OPTS argument must be a scalar structure");
         }
 
-      if (!error_state)
-        {
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
-          Matrix xinfo (AMD_INFO, 1);
-          double *Info = xinfo.fortran_vec ();
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
+      Matrix xinfo (AMD_INFO, 1);
+      double *Info = xinfo.fortran_vec ();
 
-          // FIXME: how can we manage the memory allocation of amd
-          //        in a cleaner manner?
-          SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
-          SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
-          SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
-          SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
-          SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
+      // FIXME: how can we manage the memory allocation of amd
+      //        in a cleaner manner?
+      SUITESPARSE_ASSIGN_FPTR (malloc_func, amd_malloc, malloc);
+      SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
+      SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
+      SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
+      SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
 
-          octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
-                                                      Control, Info);
+      octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
+                                                  Control, Info);
 
-          switch (result)
-            {
-            case AMD_OUT_OF_MEMORY:
-              error ("amd: out of memory");
-              break;
+      switch (result)
+        {
+        case AMD_OUT_OF_MEMORY:
+          error ("amd: out of memory");
+          break;
 
-            case AMD_INVALID:
-              error ("amd: matrix S is corrupted");
-              break;
+        case AMD_INVALID:
+          error ("amd: matrix S is corrupted");
+          break;
 
-            default:
-              {
-                if (nargout > 1)
-                  retval(1) = xinfo;
+        default:
+          {
+            if (nargout > 1)
+              retval(1) = xinfo;
 
-                Matrix Pout (1, n_col);
-                for (octave_idx_type i = 0; i < n_col; i++)
-                  Pout.xelem (i) = P[i] + 1;
+            Matrix Pout (1, n_col);
+            for (octave_idx_type i = 0; i < n_col; i++)
+              Pout.xelem (i) = P[i] + 1;
 
-                retval(0) = Pout;
-              }
-            }
+            retval(0) = Pout;
+          }
         }
     }
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
 
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -235,225 +235,206 @@ x = @var{R} \\ @var{C}\n\
                   economy = true;
                   have_b = (nargin > 2 ? 2 : 0);
                 }
             }
           if (have_b > 0 && args(have_b).is_complex_type ())
             is_cmplx = true;
         }
 
-      if (!error_state)
+      if (have_b && nargout < 2)
+        error ("qr: incorrect number of output arguments");
+      else if (is_cmplx)
         {
-          if (have_b && nargout < 2)
-            error ("qr: incorrect number of output arguments");
-          else if (is_cmplx)
+          SparseComplexQR q (arg.sparse_complex_matrix_value ());
+
+          if (have_b > 0)
             {
-              SparseComplexQR q (arg.sparse_complex_matrix_value ());
-              if (!error_state)
-                {
-                  if (have_b > 0)
-                    {
-                      retval(1) = q.R (economy);
-                      retval(0) = q.C (args(have_b).complex_matrix_value ());
-                      if (arg.rows () < arg.columns ())
-                        warning ("qr: non minimum norm solution for under-determined problem");
-                    }
-                  else if (nargout > 1)
-                    {
-                      retval(1) = q.R (economy);
-                      retval(0) = q.Q ();
-                    }
-                  else
-                    retval(0) = q.R (economy);
-                }
+              retval(1) = q.R (economy);
+              retval(0) = q.C (args(have_b).complex_matrix_value ());
+              if (arg.rows () < arg.columns ())
+                warning ("qr: non minimum norm solution for under-determined problem");
+            }
+          else if (nargout > 1)
+            {
+              retval(1) = q.R (economy);
+              retval(0) = q.Q ();
             }
           else
+            retval(0) = q.R (economy);
+        }
+      else
+        {
+          SparseQR q (arg.sparse_matrix_value ());
+
+          if (have_b > 0)
             {
-              SparseQR q (arg.sparse_matrix_value ());
-              if (!error_state)
-                {
-                  if (have_b > 0)
-                    {
-                      retval(1) = q.R (economy);
-                      retval(0) = q.C (args(have_b).matrix_value ());
-                      if (args(0).rows () < args(0).columns ())
-                        warning ("qr: non minimum norm solution for under-determined problem");
-                    }
-                  else if (nargout > 1)
-                    {
-                      retval(1) = q.R (economy);
-                      retval(0) = q.Q ();
-                    }
-                  else
-                    retval(0) = q.R (economy);
-                }
+              retval(1) = q.R (economy);
+              retval(0) = q.C (args(have_b).matrix_value ());
+              if (args(0).rows () < args(0).columns ())
+                warning ("qr: non minimum norm solution for under-determined problem");
             }
+          else if (nargout > 1)
+            {
+              retval(1) = q.R (economy);
+              retval(0) = q.Q ();
+            }
+          else
+            retval(0) = q.R (economy);
         }
     }
   else
     {
       QR::type type = (nargout == 0 || nargout == 1) ? QR::raw
                                                      : nargin == 2
                                                        ? QR::economy : QR::std;
 
       if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
-              if (! error_state)
+              switch (nargout)
                 {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      {
-                        FloatQR fact (m, type);
-                        retval(0) = fact.R ();
-                      }
-                      break;
+                case 0:
+                case 1:
+                  {
+                    FloatQR fact (m, type);
+                    retval(0) = fact.R ();
+                  }
+                  break;
 
-                    case 2:
-                      {
-                        FloatQR fact (m, type);
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
+                case 2:
+                  {
+                    FloatQR fact (m, type);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
 
-                    default:
-                      {
-                        FloatQRP fact (m, type);
-                        if (type == QR::economy)
-                          retval(2) = fact.Pvec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
-                    }
+                default:
+                  {
+                    FloatQRP fact (m, type);
+                    if (type == QR::economy)
+                      retval(2) = fact.Pvec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
                 }
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-              if (! error_state)
+              switch (nargout)
                 {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      {
-                        FloatComplexQR fact (m, type);
-                        retval(0) = fact.R ();
-                      }
-                      break;
+                case 0:
+                case 1:
+                  {
+                    FloatComplexQR fact (m, type);
+                    retval(0) = fact.R ();
+                  }
+                  break;
 
-                    case 2:
-                      {
-                        FloatComplexQR fact (m, type);
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
+                case 2:
+                  {
+                    FloatComplexQR fact (m, type);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
 
-                    default:
-                      {
-                        FloatComplexQRP fact (m, type);
-                        if (type == QR::economy)
-                          retval(2) = fact.Pvec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
-                    }
+                default:
+                  {
+                    FloatComplexQRP fact (m, type);
+                    if (type == QR::economy)
+                      retval(2) = fact.Pvec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
                 }
             }
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
-              if (! error_state)
+              switch (nargout)
                 {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      {
-                        QR fact (m, type);
-                        retval(0) = fact.R ();
-                      }
-                      break;
+                case 0:
+                case 1:
+                  {
+                    QR fact (m, type);
+                    retval(0) = fact.R ();
+                  }
+                  break;
 
-                    case 2:
-                      {
-                        QR fact (m, type);
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
+                case 2:
+                  {
+                    QR fact (m, type);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
 
-                    default:
-                      {
-                        QRP fact (m, type);
-                        if (type == QR::economy)
-                          retval(2) = fact.Pvec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
-                    }
+                default:
+                  {
+                    QRP fact (m, type);
+                    if (type == QR::economy)
+                      retval(2) = fact.Pvec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
                 }
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
-              if (! error_state)
+              switch (nargout)
                 {
-                  switch (nargout)
-                    {
-                    case 0:
-                    case 1:
-                      {
-                        ComplexQR fact (m, type);
-                        retval(0) = fact.R ();
-                      }
-                      break;
+                case 0:
+                case 1:
+                  {
+                    ComplexQR fact (m, type);
+                    retval(0) = fact.R ();
+                  }
+                  break;
 
-                    case 2:
-                      {
-                        ComplexQR fact (m, type);
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
+                case 2:
+                  {
+                    ComplexQR fact (m, type);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
 
-                    default:
-                      {
-                        ComplexQRP fact (m, type);
-                        if (type == QR::economy)
-                          retval(2) = fact.Pvec ();
-                        else
-                          retval(2) = fact.P ();
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
-                      break;
-                    }
+                default:
+                  {
+                    ComplexQRP fact (m, type);
+                    if (type == QR::economy)
+                      retval(2) = fact.Pvec ();
+                    else
+                      retval(2) = fact.P ();
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                  break;
                 }
             }
           else
             gripe_wrong_type_arg ("qr", arg);
         }
     }
 
   return retval;
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -983,27 +983,26 @@ octave_base_value::map_value (void) cons
   octave_map retval;
   gripe_wrong_type_arg ("octave_base_value::map_value()", type_name ());
   return retval;
 }
 
 octave_scalar_map
 octave_base_value::scalar_map_value (void) const
 {
+  octave_scalar_map retval;
+
   octave_map tmp = map_value ();
 
   if (tmp.numel () == 1)
-    return tmp.checkelem (0);
+    retval = tmp.checkelem (0);
   else
-    {
-      if (! error_state)
-        error ("invalid conversion of multi-dimensional struct to scalar struct");
+    error ("invalid conversion of multi-dimensional struct to scalar struct");
 
-      return octave_scalar_map ();
-    }
+  return retval;
 }
 
 string_vector
 octave_base_value::map_keys (void) const
 {
   string_vector retval;
   gripe_wrong_type_arg ("octave_base_value::map_keys()", type_name ());
   return retval;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -189,23 +189,17 @@ static std::list<cdef_class>
 lookup_classes (const Cell& cls_list)
 {
   std::list<cdef_class> retval;
 
   for (int i = 0; i < cls_list.numel (); i++)
     {
       cdef_class c = lookup_class (cls_list(i));
 
-      if (! error_state)
-        retval.push_back (c);
-      else
-        {
-          retval.clear ();
-          break;
-        }
+      retval.push_back (c);
     }
 
   return retval;
 }
 
 static octave_value
 to_ov (const std::list<cdef_class>& class_list)
 {
@@ -1184,17 +1178,17 @@ public:
     octave_value_list retval;
 
     std::string meth_name;
     bool in_constructor;
     cdef_class ctx;
 
     ctx = get_class_context (meth_name, in_constructor);
 
-    if (! error_state && ctx.ok ())
+    if (ctx.ok ())
       {
         std::string mname = args(0).string_value ();
         std::string cname = args(1).string_value ();
 
         cdef_class cls = lookup_class (cname);
 
         if (in_constructor)
           {
@@ -1246,17 +1240,17 @@ public:
                   error ("`%s' is not a superclass of `%s'",
                          cname.c_str (), ctx.get_name ().c_str ());
               }
             else
               error ("method name mismatch (`%s' != `%s')",
                      mname.c_str (), meth_name.c_str ());
           }
       }
-    else if (! error_state)
+    else
       error ("superclass calls can only occur in methods or constructors");
 
     return retval;
   }
 
 private:
   bool is_constructed_object (const std::string nm)
   {
@@ -3479,17 +3473,17 @@ cdef_package::cdef_package_rep::meta_sub
                     retval = retval(0).next_subsref (nargout, type,
                                                      idx, 1);
                 }
               else if (type.size () > 1 && idx.size () > 1)
                 retval = o.next_subsref (nargout, type, idx, 1);
               else
                 retval(0) = o;
             }
-          else if (! error_state)
+          else
             error ("member `%s' in package `%s' does not exist",
                    nm.c_str (), get_name ().c_str ());
         }
       else
         error ("invalid meta.package indexing");
       break;
 
     default:
@@ -3881,20 +3875,17 @@ Returns the meta.class object correspond
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       cdef_object obj = to_cdef (args(0));
 
-      if (! error_state)
-        retval = to_ov (obj.get_class ());
-      else
-        print_usage ();
+      retval = to_ov (obj.get_class ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
