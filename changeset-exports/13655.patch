# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@gmail.com>
# Date 1314384010 18000
#      Fri Aug 26 13:40:10 2011 -0500
# Node ID 7df7650492e85245c6653062ad4610af4bb6fd6c
# Parent  c67f7d390a1a6d1794b43cd8cc0aa09e7e5cee0d
# Parent  38b52a073cfaeaafb412368f88a3df76d065c35f
Merge with Savannah

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,28 +1,44 @@
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.
 
+ ** Octave now features a profiler, thanks to the work of Daniel Kraft
+    under the Google Summer of Code mentorship program. The manual has
+    been updated to reflect this addition.
+
  ** strread, textscan, and textread have been completely revamped.
 
     They now support nearly all Matlab functionality including:
 
     * ML-compatible whitespace and delimiter defaults
 
     * ML-compatible options: 'whitespace', treatasempty',
     format string repeat count, user-specified comment style, uneven-length
     output arrays, %n and %u conversion specifiers (provisionally)
+
+ ** Certain string functions have been modified for greater Matlab compatibility
+    and for 15X greater performance when operating on cell array of strings.
+
+    deblank : Now requires character or cellstr input
+    strtrim : Now requires character or cellstr input.
+              No longer trims nulls ("\0") from string for ML compatibility.
+    strmatch: Follows documentation precisely and ignores trailing spaces
+              in pattern and in string.  Note that Matlab documents this 
+              behavior but the implementation does *not* always follow it.
  
  ** New functions added.
 
     iscolumn
     issrow
     zscore
+    profile
+    profshow
 
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -20,16 +20,20 @@
 gnulib_modules="
   c-strcase
   copysign
   crypto/md5
   fclose
   fcntl
   filemode
   fnmatch
+  fopen
+  fflush
+  fseek
+  ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
   link
   lstat
   mkdir
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -558,26 +558,21 @@ c@{1@}
 
 @noindent
 As with numerical arrays several elements of a cell array can be
 extracted by indexing with a vector of indexes
 
 @example
 @group
 c@{1:2@}
+     @result{} ans = a string
      @result{} ans =
           
-          (,
-            [1] = a string
-            [2] =
-          
                0.593993   0.627732
                0.377037   0.033643
-          
-          ,)
 @end group
 @end example
 
 The indexing operators can also be used to insert or overwrite elements
 of a cell array.  The following code inserts the scalar 3 on the
 third place of the previously created cell array
 
 @example
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -144,16 +144,17 @@ Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 Thorsten Meyer
 Petr Mikulik
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
+Hannes Müller
 Victor Munoz
 Carmen Navarrete
 Todd Neal
 Philip Nienhuis
 Al Niessner
 Rick Niles
 Takuji Nishimura
 Kai Noda
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -30,16 +30,18 @@ The normal command-line editing and hist
 debug mode.
 
 @menu
 * Entering Debug Mode::
 * Leaving Debug Mode::
 * Breakpoints::
 * Debug Mode::
 * Call Stack::
+* Profiling::
+* Profiler Example::
 @end menu
 
 @node Entering Debug Mode
 @section Entering Debug Mode
 
 There are two basic means of interrupting the execution of an Octave
 script.  These are breakpoints @pxref{Breakpoints}, discussed in the next
 section and interruption based on some condition.
@@ -177,8 +179,261 @@ the commands @code{dbstep}.
 @node Call Stack
 @section Call Stack
 
 @DOCSTRING(dbstack)
 
 @DOCSTRING(dbup)
 
 @DOCSTRING(dbdown)
+
+@node Profiling
+@section Profiling
+@cindex profiler
+@cindex code profiling
+
+Octave supports profiling of code execution on a per-function level. If
+profiling is enabled, each call to a function (supporting built-ins,
+operators, functions in oct- and mex-files, user-defined functions in
+Octave code and anonymous functions) is recorded while running Octave
+code. After that, this data can aid in analyzing the code behaviour, and
+is in particular helpful for finding ``hot spots'' in the code which use
+up a lot of computation time and are the best targets to spend
+optimization efforts on.
+
+The main command for profiling is @code{profile}, which can be used to
+start or stop the profiler and also to query collected data afterwards.
+The data is returned in an Octave data structure which can then be
+examined or further processed by other routines or tools.
+
+@DOCSTRING(profile)
+
+An easy way to get an overview over the collected data is
+@code{profshow}. This function takes the profiler data returned by
+@code{profile} as input and prints a flat profile, for instance:
+
+@example
+@group
+ Function Attr     Time (s)        Calls
+----------------------------------------
+   >myfib    R        2.195        13529
+binary <=             0.061        13529
+ binary -             0.050        13528
+ binary +             0.026         6764
+@end group
+@end example
+
+This shows that most of the runtime was spent executing the function
+@samp{myfib}, and some minor proportion evaluating the listed binary
+operators. Furthermore, it is shown how often the function was called
+and the profiler also records that it is recursive.
+
+@DOCSTRING(profshow)
+
+@node Profiler Example
+@section Profiler Example
+
+Below, we will give a short example of a profiler session. See also
+@ref{Profiling} for the documentation of the profiler functions in
+detail. Consider the code:
+
+@example
+@group
+global N A;
+
+N = 300;
+A = rand (N, N);
+
+function xt = timesteps (steps, x0, expM)
+  global N;
+
+  if (steps == 0)
+    xt = NA (N, 0);
+  else
+    xt = NA (N, steps);
+    x1 = expM * x0;
+    xt(:, 1) = x1;
+    xt(:, 2 : end) = timesteps (steps - 1, x1, expM);
+  endif
+endfunction
+
+function foo ()
+  global N A;
+
+  initial = @@(x) sin (x);
+  x0 = (initial (linspace (0, 2 * pi, N)))';
+
+  expA = expm (A);
+  xt = timesteps (100, x0, expA);
+endfunction
+
+function fib = bar (N)
+  if (N <= 2)
+    fib = 1;
+  else
+    fib = bar (N - 1) + bar (N - 2);
+  endif
+endfunction
+@end group
+@end example
+
+If we execute the two main functions, we get:
+
+@example
+@group
+tic; foo; toc;
+@result{} Elapsed time is 2.37338 seconds.
+
+tic; bar (20); toc;
+@result{} Elapsed time is 2.04952 seconds.
+@end group
+@end example
+
+But this does not give much information about where this time is spent;
+for instance, whether the single call to @code{expm} is more expensive
+or the recursive time-stepping itself. To get a more detailed picture,
+we can use the profiler.
+
+@example
+@group
+profile on;
+foo;
+profile off;
+
+data = profile ('info');
+profshow (data, 10);
+@end group
+@end example
+
+This prints a table like:
+
+@example
+@group
+   #  Function Attr     Time (s)        Calls
+---------------------------------------------
+   7      expm             1.034            1
+   3  binary *             0.823          117
+  41  binary \             0.188            1
+  38  binary ^             0.126            2
+  43 timesteps    R        0.111          101
+  44        NA             0.029          101
+  39  binary +             0.024            8
+  34      norm             0.011            1
+  40  binary -             0.004          101
+  33   balance             0.003            1
+@end group
+@end example
+
+The entries are the individual functions which have been executed (only
+the 10 most important ones), together with some information for each of
+them. The entries like @samp{binary *} denote operators, while other
+entries are ordinary functions. They include both built-ins like
+@code{expm} and our own routines (for instance @code{timesteps}). From
+this profile, we can immediately deduce that @code{expm} uses up the
+largest proportion of the processing time, even though it is only called
+once. The second expensive operation is the matrix-vector product in the
+routine @code{timesteps}. @footnote{We only know it is the binary
+multiplication operator, but fortunately this operator appears only at
+one place in the code and thus we know which occurence takes so much
+time. If there were multiple places, we would have to use the
+hierarchical profile to find out the exact place which uses up the time
+which is not covered in this example.}
+
+Timing, however, is not the only information available from the profile.
+The attribute column shows us that @code{timesteps} calls itself
+recursively. This may not be that remarkable in this example (since it's
+clear anyway), but could be helpful in a more complex setting. As to the
+question of why is there a @samp{binary \} in the output, we can easily
+shed some light on that too. Note that @code{data} is a structure array
+(@ref{Structure Arrays}) which contains the field @code{FunctionTable}.
+This stores the raw data for the profile shown. The number in the first
+column of the table gives the index under which the shown function can
+be found there. Looking up @code{data.FunctionTable(41)} gives:
+
+@example
+@group
+  scalar structure containing the fields:
+
+    FunctionName = binary \
+    TotalTime =  0.18765
+    NumCalls =  1
+    IsRecursive = 0
+    Parents =  7
+    Children = [](1x0)
+@end group
+@end example
+
+Here we see the information from the table again, but have additional
+fields @code{Parents} and @code{Children}. Those are both arrays, which
+contain the indices of functions which have directly called the function
+in question (which is entry 7, @code{expm}, in this case) or been called
+by it (no functions). Hence, the backslash operator has been used
+internally by @code{expm}.
+
+Now let's take a look at @code{bar}. For this, we start a fresh
+profiling session (@code{profile on} does this; the old data is removed
+before the profiler is restarted):
+
+@example
+@group
+profile on;
+bar (20);
+profile off;
+
+profshow (profile ('info'));
+@end group
+@end example
+
+This gives:
+
+@example
+   #            Function Attr     Time (s)        Calls
+-------------------------------------------------------
+   1                 bar    R        2.091        13529
+   2           binary <=             0.062        13529
+   3            binary -             0.042        13528
+   4            binary +             0.023         6764
+   5             profile             0.000            1
+   8               false             0.000            1
+   6              nargin             0.000            1
+   7           binary !=             0.000            1
+   9 __profiler_enable__             0.000            1
+@end example
+
+Unsurprisingly, @code{bar} is also recursive. It has been called 13,529
+times in the course of recursively calculating the Fibonacci number in a
+suboptimal way, and most of the time was spent in @code{bar} itself.
+
+Finally, let's say we want to profile the execution of both @code{foo}
+and @code{bar} together. Since we already have the runtime data
+collected for @code{bar}, we can restart the profiler without clearing
+the existing data and collect the missing statistics about @code{foo}.
+This is done by:
+
+@example
+@group
+profile resume;
+foo;
+profile off;
+
+profshow (profile ('info'), 10);
+@end group
+@end example
+
+As you can see in the table below, now we have both profiles mixed
+together.
+
+@example
+@group
+   #  Function Attr     Time (s)        Calls
+---------------------------------------------
+   1       bar    R        2.091        13529
+  16      expm             1.122            1
+  12  binary *             0.798          117
+  46  binary \             0.185            1
+  45  binary ^             0.124            2
+  48 timesteps    R        0.115          101
+   2 binary <=             0.062        13529
+   3  binary -             0.045        13629
+   4  binary +             0.041         6772
+  49        NA             0.036          101
+@end group
+@end example
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -27,17 +27,17 @@
 @ifset INSTALLONLY
 
 This file documents the installation of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation.
 
-@strong{Note:} This file is automatically generated from
+@strong{Note}: This file is automatically generated from
 @file{doc/interpreter/install.txi} in the Octave sources.  To update
 the documentation make changes to the .txi source file rather than this
 derived file.
 
 @node Installation
 @chapter Installing Octave
 @end ifset
 
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -573,18 +573,18 @@ width 0.6pt \tabskip=0pt\cr
 @item @tab + a @tab uplus (a) @tab Unary addition operator @tab
 @item @tab - a @tab uminus (a) @tab Unary subtraction operator @tab
 @item @tab a .* b @tab times (a, b) @tab Element-wise multiplication operator @tab
 @item @tab a * b @tab mtimes (a, b) @tab Matrix multiplication operator @tab
 @item @tab a ./ b @tab rdivide (a, b) @tab Element-wise right division operator @tab
 @item @tab a / b @tab mrdivide (a, b) @tab Matrix right division operator @tab
 @item @tab a .\ b @tab ldivide (a, b) @tab Element-wise left division operator @tab
 @item @tab a \ b @tab mldivide (a, b) @tab Matrix left division operator @tab
-@item @tab a .^ b @tab ldivide (a, b) @tab Element-wise power operator @tab
-@item @tab a ^ b @tab mldivide (a, b) @tab Matrix power operator @tab
+@item @tab a .^ b @tab power (a, b) @tab Element-wise power operator @tab
+@item @tab a ^ b @tab mpower (a, b) @tab Matrix power operator @tab
 @item @tab a < b @tab lt (a, b) @tab Less than operator @tab
 @item @tab a <= b @tab le (a, b) @tab Less than or equal to operator @tab
 @item @tab a > b @tab gt (a, b) @tab Greater than operator @tab
 @item @tab a >= b @tab ge (a, b) @tab Greater than or equal to operator @tab
 @item @tab a == b @tab eq (a, b) @tab Equal to operator @tab
 @item @tab a != b @tab ne (a, b) @tab Not equal to operator @tab
 @item @tab a \& b @tab and (a, b) @tab Logical and operator @tab
 @item @tab a | b @tab or (a, b) @tab Logical or operator @tab
diff --git a/etc/README.MacOS b/etc/README.MacOS
--- a/etc/README.MacOS
+++ b/etc/README.MacOS
@@ -329,77 +329,93 @@ Octave is not possible (i.e., cannot "ma
 
 2.4.1 Building and Installing Octave
 ------------------------------------
 
 With MacPorts building the developer's sources is convenient.  MacPorts
 includes a port file for octave-devel.  To build and run the most recent
 development snapshots, enter the commands below.
 
-    sudo port selfupdate
-    sudo port install octave-devel
+  sudo port selfupdate
+  sudo port install octave-devel
 
 To build the developers sources in one's own way, or if MacPorts' version is
 outdated, a custom port file can be added.  This requires setting up a local
 port file repository (link below).
 
-    http://guide.macports.org/#development.local-repositories
+  http://guide.macports.org/#development.local-repositories
 
 The octave-devel port file may be used as an initial starting point.  The port
 file is accessible from the web at the link below.
 
-    http://trac.macports.org/browser/trunk/dports/math/octave-devel/Portfile
+  http://trac.macports.org/browser/trunk/dports/math/octave-devel/Portfile
 
 It is also available locally at the location below.  The parameter ${prefix} is
 corresponds to where MacPorts is install, which by default is "/opt/local".
 
-    ${prefix}/var/macports/sources/rsync.macports.org/release/ports/math/octave-devel/Portfile
+  ${prefix}/var/macports/sources/rsync.macports.org/release/ports/math/octave-devel/Portfile
+
+If the Portfile is missing the dependencies, epstools, epstoedit, and transfig,
+those should be installed manually or added to the Portfile. To install
+manually, type the command below.
+
+  sudo port install epstools epstoedit transfig
 
 The local source tarball must be placed in the location below, where ${name}
 and ${distname} are each specified in the port file.
 
-    ${prefix}/var/macports/distfiles/${name}/${disname}.tar.gz
+  ${prefix}/var/macports/distfiles/${name}/${disname}.tar.gz
 
 
 2.4.2 Building for Active Development of Octave
 -----------------------------------------------
 
-To satisfy Octave's dependencies, first install the octave-devel port.
-
-    sudo port selfupdate
-    sudo port install octave-devel
+To satisfy most of Octave's dependencies, first install the octave-devel port.
 
-Next run octave to determine the configure options needed to build Octave
-using MacPorts.  At Octave's prompt type the command below and make note of
-the result, ${config_opts}.
-
-    octave:1> octave_config_info.config_opts
+  sudo port selfupdate
+  sudo port install octave-devel
 
 Now uninstall the Octave port.
 
-    sudo port deactivate octave-devel
+  sudo port deactivate octave-devel
+
+This will remove Octave and leave its dependencies in place. Some additional
+dependencies may be needed.
+
+  sudo port install epstools epstoedit transfig
+
+Octave may now be built from a local mercurial archive by typing the commands
+below (these assume gcc-4.4 is installed by macports).
 
-This will remove Octave and leave its dependencies in place.  Now Octave may
-be built from the local mercurial archive by typing the commands below, where
-the configure options mentioned above are substituted for the parameter
-${config_opts}.  If the sources being built are from the mercurial archive,
-then ./autogen.sh must be run prior to ./configure.
-
-    ./configure ${config_opts}
-    make
+  ./autogen.sh
+  export PREFIX=/opt/local
+  export CC=/opt/local/bin/gcc-mp-4.4
+  export CXX=/opt/local/bin/g++-mp-4.4
+  export CXXCPP="/opt/local/bin/g++-mp-4.4 -E"
+  export F77=/opt/local/bin/gfortran-mp-4.4
+  export FC=/opt/local/bin/gfortran-mp-4.4
+  export CXXFLAGS="-pipe -O2 -m64"
+  export FFLAGS="$CXXFLAGS -D_THREAD_SAFE -pthread"
+  export CFLAGS="$FFLAGS -lstdc++"
+  export LDFLAGS=-L$PREFIX/lib
+  export CPPFLAGS=-I$PREFIX/include
+  export BLAS_LIBS="-lcblas -lf77blas -latlas"
+  export LAPACK_LIBS=-llapack
+  ./configure --prefix="/opt/local" --without-framework-carbon --with-x
+  make
 
 Octave's integrated tests may be run.
 
-    make check
+  make check
 
-However, "make install" should not be run as it may damage or corrupt the
-MacPorts installation.  To run Octave, type the command below from the root of
-the mercurial archive.
+"make install" should not be run as it will bypass the macports package 
+management.  To run Octave, type the command below from the root of the
+mercurial archive.
 
-    ./run-octave
+  ./run-octave
 
 
 John W. Eaton
 jwe@octave.org
 
 Ben Abbott
 bpabbott@mac.com
 
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -334,17 +334,17 @@ MARRAY_SND_OP (/, mx_inline_div)
 
 // Element by element MArray by MArray ops.
 
 #define MARRAY_NDND_OP(FCN, OP, FN) \
   template <class T> \
   MArray<T> \
   FCN (const MArray<T>& a, const MArray<T>& b) \
   { \
-    return do_mm_binary_op<T, T, T> (a, b, FN, #FCN); \
+    return do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN); \
   }
 
 MARRAY_NDND_OP (operator +, +, mx_inline_add)
 MARRAY_NDND_OP (operator -, -, mx_inline_sub)
 MARRAY_NDND_OP (product,    *, mx_inline_mul)
 MARRAY_NDND_OP (quotient,   /, mx_inline_div)
 
 template <class T>
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -77,17 +77,17 @@ operator * (const T& s, const MDiagArray
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
     if (a.d1 != b.d1 || a.d2 != b.d2) \
       gripe_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
-    return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, #FCN), a.d1, a.d2); \
+    return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
 // Unary MDiagArray2 ops.
 
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -183,16 +183,17 @@ INCS = \
   ODEFunc.h \
   ODES.h \
   ODESFunc.h \
   Quad.h \
   Range.h \
   base-dae.h \
   base-de.h \
   base-min.h \
+  bsxfun.h \
   byte-swap.h \
   caseless-str.h \
   cmd-edit.h \
   cmd-hist.h \
   data-conv.h \
   dir-ops.h \
   file-ops.h \
   file-stat.h \
diff --git a/liboctave/bsxfun.h b/liboctave/bsxfun.h
new file mode 100644
--- /dev/null
+++ b/liboctave/bsxfun.h
@@ -0,0 +1,44 @@
+/*
+
+Copyright (C) 2011 Jordi Gutiérrez Hermoso <jordigh@octave.org>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+#if !defined (bsxfun_h)
+#define bsxfun_h 1
+
+#include <algorithm>
+
+#include "Array.h"
+#include "dim-vector.h"
+
+inline
+bool
+is_valid_bsxfun (const dim_vector& dx, const dim_vector& dy)
+{
+  for (int i = 0; i < std::min (dx.length (), dy.length ()); i++)
+    {
+      if ( dx(i) > 1 && dy(i) > 1 && dx(i) != dy(i))
+        return false;
+    }
+  return true;
+}
+
+#include "bsxfun-defs.cc"
+
+#endif
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -69,18 +69,18 @@ charMatrix::charMatrix (const std::strin
   octave_idx_type nr = nc > 0 ? 1 : 0;
 
   resize (nr, nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
-charMatrix::charMatrix (const string_vector& s)
-  : Array<char> (dim_vector (s.length (), s.max_length ()), 0)
+charMatrix::charMatrix (const string_vector& s, char fill_value)
+  : Array<char> (dim_vector (s.length (), s.max_length ()), fill_value)
 {
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       const std::string si = s(i);
       octave_idx_type nc = si.length ();
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -57,17 +57,17 @@ public:
   charMatrix (const charMatrix& a) : Array<char> (a) { }
 
   charMatrix (char c);
 
   charMatrix (const char *s);
 
   charMatrix (const std::string& s);
 
-  charMatrix (const string_vector& s);
+  charMatrix (const string_vector& s, char fill_value = '\0');
 
   charMatrix& operator = (const charMatrix& a)
     {
       Array<char>::operator = (a);
       return *this;
     }
 
   bool operator == (const charMatrix& a) const;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3106,25 +3106,29 @@ Sylvester (const Matrix& a, const Matrix
 
 /* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
 %!assert([1 2 3] * [ 4 ; 5 ; 6], 32, 1e-14)
 %!assert([1 2 ; 3 4 ] * [5 ; 6], [17 ; 39 ], 1e-14)
 %!assert([1 2 ; 3 4 ] * [5 6 ; 7 8], [19 22; 43 50], 1e-14)
 */
 
 /* Test some simple identities
-%!shared M, cv, rv
-%! M = randn(10,10);
+%!shared M, cv, rv, Mt, rvt
+%! M = randn(10,10)+100*eye(10,10);
+%! Mt = M';
 %! cv = randn(10,1);
 %! rv = randn(1,10);
+%! rvt = rv';
 %!assert([M*cv,M*cv],M*[cv,cv],1e-14)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],1e-14)
-%!assert([rv*M;rv*M],[rv;rv]*M,1e-14)
-%!assert([rv*M';rv*M'],[rv;rv]*M',1e-14)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],1e-14)
+%!assert([M'*cv,M'*cv],M'*[cv,cv],3e-14)
+%!assert([rv*M;rv*M],[rv;rv]*M,3e-14)
+%!assert([rv*M';rv*M'],[rv;rv]*M',3e-14)
+%!assert(2*rv*cv,[rv,rv]*[cv;cv],3e-14)
+%!assert(M'\cv,Mt\cv,1e-14)
+%!assert(M'\rv',Mt\rvt,1e-14)
 */
 
 static inline char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
 }
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -920,8 +920,10 @@ NDND_CMP_OPS (NDArray, NDArray)
 NDND_BOOL_OPS (NDArray, NDArray)
 
 BSXFUN_STDOP_DEFS_MXLOOP (NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, NDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, ComplexNDArray,
                        NDArray, mx_inline_pow)
+BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, NDArray,
+                       ComplexNDArray, mx_inline_pow)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -180,10 +180,12 @@ NDND_BOOL_OP_DECLS (NDArray, NDArray, OC
 MARRAY_FORWARD_DEFS (MArray, NDArray, double)
 
 BSXFUN_STDOP_DECLS (NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (NDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, NDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, ComplexNDArray, ComplexNDArray,
                  NDArray, OCTAVE_API)
+BSXFUN_OP2_DECL (pow, ComplexNDArray, NDArray,
+                 ComplexNDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_int16, int16NDArray
 
 NDND_CMP_OPS (int16NDArray, int16NDArray)
 NDND_BOOL_OPS (int16NDArray, int16NDArray)
 
 MINMAX_FCNS (int16NDArray, octave_int16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int16NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, int16NDArray, mx_inline_pow)
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_int32, int32NDArray
 
 NDND_CMP_OPS (int32NDArray, int32NDArray)
 NDND_BOOL_OPS (int32NDArray, int32NDArray)
 
 MINMAX_FCNS (int32NDArray, octave_int32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int32NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, int32NDArray, mx_inline_pow)
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_int64, int64NDArray
 
 NDND_CMP_OPS (int64NDArray, int64NDArray)
 NDND_BOOL_OPS (int64NDArray, int64NDArray)
 
 MINMAX_FCNS (int64NDArray, octave_int64)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int64NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int64NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, int64NDArray, mx_inline_pow)
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_int8, int8NDArray)
 
 NDND_CMP_OPS (int8NDArray, int8NDArray)
 NDND_BOOL_OPS (int8NDArray, int8NDArray)
 
 MINMAX_FCNS (int8NDArray, octave_int8)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int8NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int8NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, int8NDArray, mx_inline_pow)
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -191,54 +191,67 @@ octave_fgetl (FILE *f, bool& eof)
 
   if (retval[len-1] == '\n')
     retval.resize (len-1);
 
   return retval;
 }
 
 static inline double
-read_inf_nan_na (std::istream& is, char c, char sign = '+')
+read_inf_nan_na (std::istream& is, char c0, char sign = '+')
 {
   double d = 0.0;
 
-  switch (c)
+  switch (c0)
     {
     case 'i': case 'I':
       {
-        c = is.get ();
-        if (c == 'n' || c == 'N')
+        char c1 = is.get ();
+        if (c1 == 'n' || c1 == 'N')
           {
-            c = is.get ();
-            if (c == 'f' || c == 'F')
+            char c2 = is.get ();
+            if (c2 == 'f' || c2 == 'F')
               d = sign == '-' ? -octave_Inf : octave_Inf;
             else
-              is.putback (c);
+              {
+                is.putback (c2);
+                is.putback (c1);
+                is.putback (c0);
+                is.setstate (std::ios::failbit);
+              }
           }
         else
-          is.putback (c);
+          {
+            is.putback (c1);
+            is.putback (c0);
+            is.setstate (std::ios::failbit);
+          }
       }
       break;
 
     case 'n': case 'N':
       {
-        c = is.get ();
-        if (c == 'a' || c == 'A')
+        char c1 = is.get ();
+        if (c1 == 'a' || c1 == 'A')
           {
-            c = is.get ();
-            if (c == 'n' || c == 'N')
+            char c2 = is.get ();
+            if (c2 == 'n' || c2 == 'N')
               d = octave_NaN;
             else
               {
-                is.putback (c);
+                is.putback (c2);
                 d = octave_NA;
               }
           }
         else
-          is.putback (c);
+          {
+            is.putback (c1);
+            is.putback (c0);
+            is.setstate (std::ios::failbit);
+          }
       }
       break;
 
     default:
       abort ();
     }
 
   return d;
@@ -341,54 +354,67 @@ octave_read_value (std::istream& is)
       cx = octave_read_value<double> (is);
     }
 
   return cx;
 
 }
 
 static inline float
-read_float_inf_nan_na (std::istream& is, char c, char sign = '+')
+read_float_inf_nan_na (std::istream& is, char c0, char sign = '+')
 {
   float d = 0.0;
 
-  switch (c)
+  switch (c0)
     {
     case 'i': case 'I':
       {
-        c = is.get ();
-        if (c == 'n' || c == 'N')
+        char c1 = is.get ();
+        if (c1 == 'n' || c1 == 'N')
           {
-            c = is.get ();
-            if (c == 'f' || c == 'F')
-              d = sign == '-' ? -octave_Inf : octave_Inf;
+            char c2 = is.get ();
+            if (c2 == 'f' || c2 == 'F')
+              d = sign == '-' ? -octave_Float_Inf : octave_Float_Inf;
             else
-              is.putback (c);
+              {
+                is.putback (c2);
+                is.putback (c1);
+                is.putback (c0);
+                is.setstate (std::ios::failbit);
+              }
           }
         else
-          is.putback (c);
+          {
+            is.putback (c1);
+            is.putback (c0);
+            is.setstate (std::ios::failbit);
+          }
       }
       break;
 
     case 'n': case 'N':
       {
-        c = is.get ();
-        if (c == 'a' || c == 'A')
+        char c1 = is.get ();
+        if (c1 == 'a' || c1 == 'A')
           {
-            c = is.get ();
-            if (c == 'n' || c == 'N')
-              d = octave_NaN;
+            char c2 = is.get ();
+            if (c2 == 'n' || c2 == 'N')
+              d = octave_Float_NaN;
             else
               {
-                is.putback (c);
-                d = octave_NA;
+                is.putback (c2);
+                d = octave_Float_NA;
               }
           }
         else
-          is.putback (c);
+          {
+            is.putback (c1);
+            is.putback (c0);
+            is.setstate (std::ios::failbit);
+          }
       }
       break;
 
     default:
       abort ();
     }
 
   return d;
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -32,16 +32,18 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 #include "oct-cmplx.h"
 #include "oct-locbuf.h"
 #include "oct-inttypes.h"
 #include "Array.h"
 #include "Array-util.h"
 
+#include "bsxfun.h"
+
 // Provides some commonly repeated, basic loop templates.
 
 template <class R, class S>
 inline void mx_inline_fill (size_t n, R *r, S s) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = s; }
 
 #define DEFMXUNOP(F, OP) \
 template <class R, class X> \
@@ -281,17 +283,20 @@ inline void F (size_t n, R *r, const X *
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, const X *x, Y y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, X x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
-DEFMXMAPPER2X (mx_inline_pow, std::pow)
+// Let the compiler decide which pow to use, whichever best matches the
+// arguments provided.
+using std::pow;
+DEFMXMAPPER2X (mx_inline_pow, pow)
 
 // Arbitrary function appliers. The function is a template parameter to enable
 // inlining.
 template <class R, class X, R fun (X x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
 template <class R, class X, R fun (const X& x)>
@@ -331,30 +336,35 @@ template <class R>
 inline Array<R>&
 do_mx_inplace_op (Array<R>& r,
                   void (*op) (size_t, R *) throw ())
 {
   op (r.numel (), r.fortran_vec ());
   return r;
 }
 
-
 template <class R, class X, class Y>
 inline Array<R>
 do_mm_binary_op (const Array<X>& x, const Array<Y>& y,
                  void (*op) (size_t, R *, const X *, const Y *) throw (),
+                 void (*op1) (size_t, R *, X, const Y *) throw (),
+                 void (*op2) (size_t, R *, const X *, Y) throw (),
                  const char *opname)
 {
   dim_vector dx = x.dims (), dy = y.dims ();
   if (dx == dy)
     {
       Array<R> r (dx);
       op (r.length (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
+  else if (is_valid_bsxfun (dx, dy))
+    {
+      return do_bsxfun_op (x, y, op, op1, op2);
+    }
   else
     {
       gripe_nonconformant (opname, dx, dy);
       return Array<R> ();
     }
 }
 
 template <class R, class X, class Y>
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -67,17 +67,17 @@ along with Octave; see the file COPYING.
   SV_BIN_OP (R, operator /, mx_inline_div, S, V)
 
 // vector by vector operations.
 
 #define VV_BIN_OP(R, F, OP, V1, V2) \
   R \
   F (const V1& v1, const V2& v2) \
   { \
-    return do_mm_binary_op<R::element_type, V1::element_type, V2::element_type> (v1, v2, OP, #F); \
+    return do_mm_binary_op<R::element_type, V1::element_type, V2::element_type> (v1, v2, OP, OP, OP, #F); \
   }
 
 #define VV_BIN_OPS(R, V1, V2) \
   VV_BIN_OP (R, operator +, mx_inline_add, V1, V2) \
   VV_BIN_OP (R, operator -, mx_inline_sub, V1, V2) \
   VV_BIN_OP (R, product,    mx_inline_mul, V1, V2) \
   VV_BIN_OP (R, quotient,   mx_inline_div, V1, V2)
 
@@ -168,47 +168,47 @@ along with Octave; see the file COPYING.
   SM_BOOL_OP (mx_el_or,  mx_inline_or,  S, M)
 
 // matrix by matrix operations.
 
 #define MM_BIN_OP(R, OP, M1, M2, F) \
   R \
   OP (const M1& m1, const M2& m2) \
   { \
-    return do_mm_binary_op<R::element_type, M1::element_type, M2::element_type> (m1, m2, F, #OP); \
+    return do_mm_binary_op<R::element_type, M1::element_type, M2::element_type> (m1, m2, F, F, F, #OP); \
   }
 
 #define MM_BIN_OPS(R, M1, M2) \
   MM_BIN_OP (R, operator +, M1, M2, mx_inline_add) \
   MM_BIN_OP (R, operator -, M1, M2, mx_inline_sub) \
   MM_BIN_OP (R, product,    M1, M2, mx_inline_mul) \
   MM_BIN_OP (R, quotient,   M1, M2, mx_inline_div)
 
 #define MM_CMP_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
-    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, OP, OP, #F); \
   }
 
 #define MM_CMP_OPS(M1, M2) \
   MM_CMP_OP (mx_el_lt, mx_inline_lt, M1, M2) \
   MM_CMP_OP (mx_el_le, mx_inline_le, M1, M2) \
   MM_CMP_OP (mx_el_ge, mx_inline_ge, M1, M2) \
   MM_CMP_OP (mx_el_gt, mx_inline_gt, M1, M2) \
   MM_CMP_OP (mx_el_eq, mx_inline_eq, M1, M2) \
   MM_CMP_OP (mx_el_ne, mx_inline_ne, M1, M2)
 
 #define MM_BOOL_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     MNANCHK (m1, M1::element_type); \
     MNANCHK (m2, M2::element_type); \
-    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, OP, OP, #F); \
   }
 
 #define MM_BOOL_OPS(M1, M2) \
   MM_BOOL_OP (mx_el_and, mx_inline_and, M1, M2) \
   MM_BOOL_OP (mx_el_or,  mx_inline_or,  M1, M2)
 
 // N-d matrix by scalar operations.
 
@@ -305,47 +305,47 @@ along with Octave; see the file COPYING.
   SND_BOOL_OP (mx_el_or_not,  mx_inline_or_not,  S, ND)
 
 // N-d matrix by N-d matrix operations.
 
 #define NDND_BIN_OP(R, OP, ND1, ND2, F) \
   R \
   OP (const ND1& m1, const ND2& m2) \
   { \
-    return do_mm_binary_op<R::element_type, ND1::element_type, ND2::element_type> (m1, m2, F, #OP); \
+    return do_mm_binary_op<R::element_type, ND1::element_type, ND2::element_type> (m1, m2, F, F, F, #OP); \
   }
 
 #define NDND_BIN_OPS(R, ND1, ND2) \
   NDND_BIN_OP (R, operator +, ND1, ND2, mx_inline_add) \
   NDND_BIN_OP (R, operator -, ND1, ND2, mx_inline_sub) \
   NDND_BIN_OP (R, product,    ND1, ND2, mx_inline_mul) \
   NDND_BIN_OP (R, quotient,   ND1, ND2, mx_inline_div)
 
 #define NDND_CMP_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
-    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, OP, OP, #F); \
   }
 
 #define NDND_CMP_OPS(ND1, ND2) \
   NDND_CMP_OP (mx_el_lt, mx_inline_lt, ND1, ND2) \
   NDND_CMP_OP (mx_el_le, mx_inline_le, ND1, ND2) \
   NDND_CMP_OP (mx_el_ge, mx_inline_ge, ND1, ND2) \
   NDND_CMP_OP (mx_el_gt, mx_inline_gt, ND1, ND2) \
   NDND_CMP_OP (mx_el_eq, mx_inline_eq, ND1, ND2) \
   NDND_CMP_OP (mx_el_ne, mx_inline_ne, ND1, ND2)
 
 #define NDND_BOOL_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     MNANCHK (m1, ND1::element_type); \
     MNANCHK (m2, ND2::element_type); \
-    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, OP, OP, #F); \
   }
 
 #define NDND_BOOL_OPS(ND1, ND2) \
   NDND_BOOL_OP (mx_el_and,     mx_inline_and,     ND1, ND2) \
   NDND_BOOL_OP (mx_el_or,      mx_inline_or,      ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_and, mx_inline_not_and, ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_or,  mx_inline_not_or,  ND1, ND2) \
   NDND_BOOL_OP (mx_el_and_not, mx_inline_and_not, ND1, ND2) \
@@ -578,17 +578,17 @@ FCN (const T& m, S d) \
 { \
   return do_ms_binary_op<T::element_type, T::element_type, S> (m, d, mx_inline_x##FCN); \
 }
 
 #define NDND_MINMAX_FCN(FCN, OP, T, S) \
 T \
 FCN (const T& a, const T& b) \
 { \
-  return do_mm_binary_op<T::element_type, T::element_type, T::element_type> (a, b, mx_inline_x##FCN, #FCN); \
+  return do_mm_binary_op<T::element_type, T::element_type, T::element_type> (a, b, mx_inline_x##FCN, mx_inline_x##FCN, mx_inline_x##FCN, #FCN); \
 }
 
 #define MINMAX_FCNS(T, S) \
   SND_MINMAX_FCN (min, <, T, S) \
   NDS_MINMAX_FCN (min, <, T, S) \
   NDND_MINMAX_FCN (min, <, T, S) \
   SND_MINMAX_FCN (max, >, T, S) \
   NDS_MINMAX_FCN (max, >, T, S) \
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -22,39 +22,88 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_binmap_h)
 #define octave_binmap_h 1
 
 #include "Array.h"
 #include "Sparse.h"
 #include "Array-util.h"
 
-// This source implements a general binary maping function for arrays.
-// The syntax is binmap<type> (a, b, f, [name]). type denotes the expected
-// return type of the operation. a, b, should be one of the 6 combinations:
+#include "bsxfun.h"
+
+// This source file implements a general binary maping function for
+// arrays. The syntax is binmap<type> (a, b, f, [name]). type denotes
+// the expected return type of the operation. a, b, should be one of
+// the 6 combinations:
+//
 // Array-Array
 // Array-scalar
 // scalar-Array
 // Sparse-Sparse
 // Sparse-scalar
 // scalar-Sparse
 //
-// If both operands are nonscalar, name must be supplied. It is used as the base for error message
-// when operands are nonconforming.
+// If both operands are nonscalar, name must be supplied. It is used
+// as the base for error message when operands are nonconforming.
 //
-// The operation needs not be homogeneous, i.e. a, b and the result may be of distinct types.
-// f can have any of the four signatures:
+// The operation needs not be homogeneous, i.e. a, b and the result
+// may be of distinct types. f can have any of the four signatures:
+//
 // U f (T, R)
 // U f (const T&, R)
 // U f (T, const R&)
 // U f (const T&, const R&)
 //
 // Additionally, f can be an arbitrary functor object.
 //
-// octave_quit() is called at appropriate places, hence the operation is breakable.
+// octave_quit() is called at appropriate places, hence the operation
+// is breakable.
+
+// The following template wrappers are provided for automatic bsxfun
+// calls (see the function signature for do_bsxfun_op).
+
+template<typename R, typename X, typename Y, typename F>
+class bsxfun_wrapper
+{
+private:
+  static F f;
+
+public:
+  static void
+  set_f (const F& f_in)
+  {
+    f = f_in;
+  }
+
+  static void
+  op_mm (size_t n, R* r, const X* x , const Y* y)
+  {
+    for (size_t i = 0; i < n; i++)
+      r[i] = f (x[i], y[i]);
+  }
+
+  static void
+  op_sm (size_t n, R* r, X x, const Y* y)
+  {
+    for (size_t i = 0; i < n; i++)
+      r[i] = f (x, y[i]);
+  }
+
+  static void
+  op_ms (size_t n , R* r, const X* x, Y y)
+  {
+    for (size_t i = 0; i < n; i++)
+      r[i] = f (x[i], y);
+  }
+};
+
+// Static init
+template<typename R, typename X, typename Y, typename F>
+F bsxfun_wrapper<R, X, Y, F>::f;
+
 
 // scalar-Array
 template <class U, class T, class R, class F>
 Array<U>
 binmap (const T& x, const Array<R>& ya, F fcn)
 {
   octave_idx_type len = ya.numel ();
 
@@ -113,22 +162,34 @@ binmap (const Array<T>& xa, const R& y, 
   return result;
 }
 
 // Array-Array (treats singletons as scalars)
 template <class U, class T, class R, class F>
 Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, F fcn, const char *name)
 {
+  dim_vector xad = xa.dims (), yad = ya.dims ();
   if (xa.numel () == 1)
     return binmap<U, T, R, F> (xa(0), ya, fcn);
   else if (ya.numel () == 1)
     return binmap<U, T, R, F> (xa, ya(0), fcn);
-  else if (xa.dims () != ya.dims ())
-    gripe_nonconformant (name, xa.dims (), ya.dims ());
+  else if (xad != yad)
+    {
+      if (is_valid_bsxfun (xad, yad))
+        {
+          bsxfun_wrapper<U, T, R, F>::set_f(fcn);
+          return do_bsxfun_op (xa, ya,
+                               bsxfun_wrapper<U, T, R, F>::op_mm,
+                               bsxfun_wrapper<U, T, R, F>::op_sm,
+                               bsxfun_wrapper<U, T, R, F>::op_ms);
+        }
+      else
+        gripe_nonconformant (name, xad, yad);
+    }
 
   octave_idx_type len = xa.numel ();
 
   const T *x = xa.data ();
   const T *y = ya.data ();
 
   Array<U> result (xa.dims ());
   U *p = result.fortran_vec ();
@@ -268,139 +329,139 @@ binmap (const Sparse<T>& xs, const Spars
       retval.maybe_compress ();
       return retval;
     }
   else
     return Sparse<U> (binmap<U, T, R, F> (xs.array_value (), ys.array_value (),
                                           fcn, name));
 }
 
-// Overloads for function references.
+// Overloads for function pointers.
 
 // Signature (T, R)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (&fcn) (T, R), const char *name)
-{ return binmap<U, T, R, U (&) (T, R)> (xa, ya, fcn, name); }
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, R), const char *name)
+{ return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const T& x, const Array<R>& ya, U (&fcn) (T, R))
-{ return binmap<U, T, R, U (&) (T, R)> (x, ya, fcn); }
+binmap (const T& x, const Array<R>& ya, U (*fcn) (T, R))
+{ return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const R& y, U (&fcn) (T, R))
-{ return binmap<U, T, R, U (&) (T, R)> (xa, y, fcn); }
+binmap (const Array<T>& xa, const R& y, U (*fcn) (T, R))
+{ return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (&fcn) (T, R), const char *name)
-{ return binmap<U, T, R, U (&) (T, R)> (xa, ya, fcn, name); }
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, R), const char *name)
+{ return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const T& x, const Sparse<R>& ya, U (&fcn) (T, R))
-{ return binmap<U, T, R, U (&) (T, R)> (x, ya, fcn); }
+binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, R))
+{ return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const R& y, U (&fcn) (T, R))
-{ return binmap<U, T, R, U (&) (T, R)> (xa, y, fcn); }
+binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, R))
+{ return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
 // Signature (const T&, const R&)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (&fcn) (const T&, const R&), const char *name)
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (xa, ya, fcn, name); }
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, const R&), const char *name)
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const T& x, const Array<R>& ya, U (&fcn) (const T&, const R&))
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (x, ya, fcn); }
+binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, const R&))
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const R& y, U (&fcn) (const T&, const R&))
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (xa, y, fcn); }
+binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, const R&))
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (&fcn) (const T&, const R&), const char *name)
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (xa, ya, fcn, name); }
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, const R&), const char *name)
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const T& x, const Sparse<R>& ya, U (&fcn) (const T&, const R&))
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (x, ya, fcn); }
+binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, const R&))
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const R& y, U (&fcn) (const T&, const R&))
-{ return binmap<U, T, R, U (&) (const T&, const R&)> (xa, y, fcn); }
+binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, const R&))
+{ return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
 // Signature (const T&, R)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (&fcn) (const T&, R), const char *name)
-{ return binmap<U, T, R, U (&) (const T&, R)> (xa, ya, fcn, name); }
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, R), const char *name)
+{ return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const T& x, const Array<R>& ya, U (&fcn) (const T&, R))
-{ return binmap<U, T, R, U (&) (const T&, R)> (x, ya, fcn); }
+binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, R))
+{ return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const R& y, U (&fcn) (const T&, R))
-{ return binmap<U, T, R, U (&) (const T&, R)> (xa, y, fcn); }
+binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, R))
+{ return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (&fcn) (const T&, R), const char *name)
-{ return binmap<U, T, R, U (&) (const T&, R)> (xa, ya, fcn, name); }
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, R), const char *name)
+{ return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const T& x, const Sparse<R>& ya, U (&fcn) (const T&, R))
-{ return binmap<U, T, R, U (&) (const T&, R)> (x, ya, fcn); }
+binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, R))
+{ return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const R& y, U (&fcn) (const T&, R))
-{ return binmap<U, T, R, U (&) (const T&, R)> (xa, y, fcn); }
+binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, R))
+{ return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
 // Signature (T, const R&)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (&fcn) (T, const R&), const char *name)
-{ return binmap<U, T, R, U (&) (T, const R&)> (xa, ya, fcn, name); }
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, const R&), const char *name)
+{ return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const T& x, const Array<R>& ya, U (&fcn) (T, const R&))
-{ return binmap<U, T, R, U (&) (T, const R&)> (x, ya, fcn); }
+binmap (const T& x, const Array<R>& ya, U (*fcn) (T, const R&))
+{ return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const R& y, U (&fcn) (T, const R&))
-{ return binmap<U, T, R, U (&) (T, const R&)> (xa, y, fcn); }
+binmap (const Array<T>& xa, const R& y, U (*fcn) (T, const R&))
+{ return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (&fcn) (T, const R&), const char *name)
-{ return binmap<U, T, R, U (&) (T, const R&)> (xa, ya, fcn, name); }
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, const R&), const char *name)
+{ return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const T& x, const Sparse<R>& ya, U (&fcn) (T, const R&))
-{ return binmap<U, T, R, U (&) (T, const R&)> (x, ya, fcn); }
+binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, const R&))
+{ return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const R& y, U (&fcn) (T, const R&))
-{ return binmap<U, T, R, U (&) (T, const R&)> (xa, y, fcn); }
+binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, const R&))
+{ return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
 #endif
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -158,16 +158,36 @@ string_vector::append (const string_vect
   resize (new_len);
 
   for (octave_idx_type i = 0; i < sv_len; i++)
     elem(len + i) = sv[i];
 
   return *this;
 }
 
+std::string
+string_vector::join (const std::string& sep) const
+{
+  std::string retval;
+
+  octave_idx_type len = length ();
+
+  if (len > 0)
+    {
+      octave_idx_type i;
+
+      for (i = 0; i < len - 1; i++)
+        retval += elem(i) + sep;
+
+      retval += elem(i);
+    }
+
+  return retval;
+}
+
 char **
 string_vector::c_str_vec (void) const
 {
   octave_idx_type len = length ();
 
   char **retval = new char * [len + 1];
 
   retval [len] = 0;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -100,16 +100,18 @@ public:
   string_vector& sort (bool make_uniq = false);
 
   string_vector& uniq (void);
 
   string_vector& append (const std::string& s);
 
   string_vector& append (const string_vector& sv);
 
+  std::string join (const std::string& sep = std::string ()) const;
+
   char **c_str_vec (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
   std::ostream& list_in_columns (std::ostream&, int width = 0) const;
 };
 
 #endif
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_uint16, uint16NDArr
 
 NDND_CMP_OPS (uint16NDArray, uint16NDArray)
 NDND_BOOL_OPS (uint16NDArray, uint16NDArray)
 
 MINMAX_FCNS (uint16NDArray, octave_uint16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint16NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, uint16NDArray, mx_inline_pow)
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_uint32, uint32NDArr
 
 NDND_CMP_OPS (uint32NDArray, uint32NDArray)
 NDND_BOOL_OPS (uint32NDArray, uint32NDArray)
 
 MINMAX_FCNS (uint32NDArray, octave_uint32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint32NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, uint32NDArray, mx_inline_pow)
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_uint64, uint64NDArr
 
 NDND_CMP_OPS (uint64NDArray, uint64NDArray)
 NDND_BOOL_OPS (uint64NDArray, uint64NDArray)
 
 MINMAX_FCNS (uint64NDArray, octave_uint64)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint64NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint64NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, uint64NDArray, mx_inline_pow)
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -49,8 +49,10 @@ SND_BOOL_OPS (octave_uint8, uint8NDArray
 
 NDND_CMP_OPS (uint8NDArray, uint8NDArray)
 NDND_BOOL_OPS (uint8NDArray, uint8NDArray)
 
 MINMAX_FCNS (uint8NDArray, octave_uint8)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint8NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint8NDArray)
+
+BSXFUN_OP_DEF_MXLOOP (pow, uint8NDArray, mx_inline_pow)
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -50,145 +50,149 @@ function [y, samples_per_sec, bits_per_s
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! ischar (filename))
     error ("wavread: FILENAME must be a character string");
   endif
 
-  # Open file for binary reading.
-  [fid, msg] = fopen (filename, "rb");
-  if (fid < 0)
-    error ("wavread: %s", msg);
-  endif
+  fid = -1;
+
+  unwind_protect
 
-  ## Get file size.
-  fseek (fid, 0, "eof");
-  file_size = ftell (fid);
-  fseek (fid, 0, "bof");
+    [fid, msg] = fopen (filename, "rb");
+
+    if (fid < 0)
+      error ("wavread: %s", msg);
+    endif
 
-  ## Find RIFF chunk.
-  riff_size = find_chunk (fid, "RIFF", file_size);
-  riff_pos = ftell (fid);
-  if (riff_size == -1)
-    fclose (fid);
-    error ("wavread: file contains no RIFF chunk");
-  endif
+    ## Get file size.
+    fseek (fid, 0, "eof");
+    file_size = ftell (fid);
+    fseek (fid, 0, "bof");
 
-  riff_type = char (fread (fid, 4))';
-  if (! strcmp (riff_type, "WAVE"))
-    fclose (fid);
-    error ("wavread: file contains no WAVE signature");
-  endif
-  riff_pos = riff_pos + 4;
-  riff_size = riff_size - 4;
+    ## Find RIFF chunk.
+    riff_size = find_chunk (fid, "RIFF", file_size);
+    riff_pos = ftell (fid);
+    if (riff_size == -1)
+      error ("wavread: file contains no RIFF chunk");
+    endif
+
+    riff_type = char (fread (fid, 4))';
+    if (! strcmp (riff_type, "WAVE"))
+      error ("wavread: file contains no WAVE signature");
+    endif
+    riff_pos = riff_pos + 4;
+    riff_size = riff_size - 4;
 
-  ## Find format chunk inside the RIFF chunk.
-  fseek (fid, riff_pos, "bof");
-  fmt_size = find_chunk (fid, "fmt ", riff_size);
-  fmt_pos = ftell(fid);
-  if (fmt_size == -1)
-    fclose (fid);
-    error ("wavread: file contains no format chunk");
-  endif
+    ## Find format chunk inside the RIFF chunk.
+    fseek (fid, riff_pos, "bof");
+    fmt_size = find_chunk (fid, "fmt ", riff_size);
+    fmt_pos = ftell(fid);
+    if (fmt_size == -1)
+      error ("wavread: file contains no format chunk");
+    endif
+
+    ## Find data chunk inside the RIFF chunk.
+    ## We don't assume that it comes after the format chunk.
+    fseek (fid, riff_pos, "bof");
+    data_size = find_chunk (fid, "data", riff_size);
+    data_pos = ftell (fid);
+    if (data_size == -1)
+      error ("wavread: file contains no data chunk");
+    endif
 
-  ## Find data chunk inside the RIFF chunk.
-  ## We don't assume that it comes after the format chunk.
-  fseek (fid, riff_pos, "bof");
-  data_size = find_chunk (fid, "data", riff_size);
-  data_pos = ftell (fid);
-  if (data_size == -1)
-    fclose (fid);
-    error ("wavread: file contains no data chunk");
-  endif
+    ### Read format chunk.
+    fseek (fid, fmt_pos, "bof");
 
-  ### Read format chunk.
-  fseek (fid, fmt_pos, "bof");
+    ## Sample format code.
+    format_tag = fread (fid, 1, "uint16", 0, BYTEORDER);
+    if (format_tag != FORMAT_PCM && format_tag != FORMAT_IEEE_FLOAT)
+      error ("wavread: sample format %#x is not supported", format_tag);
+    endif
 
-  ## Sample format code.
-  format_tag = fread (fid, 1, "uint16", 0, BYTEORDER);
-  if (format_tag != FORMAT_PCM && format_tag != FORMAT_IEEE_FLOAT)
-    fclose (fid);
-    error ("wavread: sample format %#x is not supported", format_tag);
-  endif
+    ## Number of interleaved channels.
+    channels = fread (fid, 1, "uint16", 0, BYTEORDER);
 
-  ## Number of interleaved channels.
-  channels = fread (fid, 1, "uint16", 0, BYTEORDER);
+    ## Sample rate.
+    samples_per_sec = fread (fid, 1, "uint32", 0, BYTEORDER);
 
-  ## Sample rate.
-  samples_per_sec = fread (fid, 1, "uint32", 0, BYTEORDER);
+    ## Bits per sample.
+    fseek (fid, 6, "cof");
+    bits_per_sample = fread (fid, 1, "uint16", 0, BYTEORDER);
 
-  ## Bits per sample.
-  fseek (fid, 6, "cof");
-  bits_per_sample = fread (fid, 1, "uint16", 0, BYTEORDER);
+    ### Read data chunk.
+    fseek (fid, data_pos, "bof");
 
-  ### Read data chunk.
-  fseek (fid, data_pos, "bof");
+    ## Determine sample data type.
+    if (format_tag == FORMAT_PCM)
+      switch (bits_per_sample)
+        case 8
+          format = "uint8";
+        case 16
+          format = "int16";
+        case 24
+          format = "uint8";
+        case 32
+          format = "int32";
+        otherwise
+          error ("wavread: %d bits sample resolution is not supported with PCM",
+                 bits_per_sample);
+      endswitch
+    else
+      switch (bits_per_sample)
+        case 32
+          format = "float32";
+        case 64
+          format = "float64";
+        otherwise
+          error ("wavread: %d bits sample resolution is not supported with IEEE float",
+                 bits_per_sample);
+      endswitch
+    endif
 
-  ## Determine sample data type.
-  if (format_tag == FORMAT_PCM)
-    switch (bits_per_sample)
-      case 8
-        format = "uint8";
-      case 16
-        format = "int16";
-      case 24
-        format = "uint8";
-      case 32
-        format = "int32";
-      otherwise
-        fclose (fid);
-        error ("wavread: %d bits sample resolution is not supported with PCM",
-               bits_per_sample);
-    endswitch
-  else
-    switch (bits_per_sample)
-      case 32
-        format = "float32";
-      case 64
-        format = "float64";
-      otherwise
-        fclose (fid);
-        error ("wavread: %d bits sample resolution is not supported with IEEE float",
-               bits_per_sample);
-    endswitch
-  endif
+    ## Parse arguments.
+    if (nargin == 1)
+      length = idivide (8 * data_size, bits_per_sample);
+    else
+      nparams = numel (param);
+      if (nparams == 1)
+        ## Number of samples is given.
+        length = param * channels;
+      elseif (nparams == 2)
+        ## Sample range is given.
+        if (fseek (fid, (param(1)-1) * channels * (bits_per_sample/8), "cof") < 0)
+          warning ("wavread: seeking failed");
+        endif
+        length = (param(2)-param(1)+1) * channels;
+      elseif (nparams == 4 && char (param) == "size")
+        ## Size of the file is requested.
+        tmp = idivide (8 * data_size, channels * bits_per_sample);
+        y = [tmp, channels];
+        return;
+      else
+        error ("wavread: invalid PARAM argument");
+      endif
+    endif
 
-  ## Parse arguments.
-  if (nargin == 1)
-    length = 8 * data_size / bits_per_sample;
-  else
-    nparams = numel (param);
-    if (nparams == 1)
-      ## Number of samples is given.
-      length = param * channels;
-    elseif (nparams == 2)
-      ## Sample range is given.
-      if (fseek (fid, (param(1)-1) * channels * (bits_per_sample/8), "cof") < 0)
-        warning ("wavread: seeking failed");
-      endif
-      length = (param(2)-param(1)+1) * channels;
-    elseif (nparams == 4 && char (param) == "size")
-      ## Size of the file is requested.
+    ## Read samples and close file.
+    if (bits_per_sample == 24)
+      length *= 3;
+    endif
+
+    [yi, n] = fread (fid, length, format, 0, BYTEORDER);
+
+  unwind_protect_cleanup
+
+    if (fid >= 0)
       fclose (fid);
-      y = [data_size/channels/(bits_per_sample/8), channels];
-      return;
-    else
-      fclose (fid);
-      error ("wavread: invalid PARAM argument");
     endif
-  endif
 
-  ## Read samples and close file.
-  if (bits_per_sample == 24)
-    length *= 3;
-  endif
-  [yi, n] = fread (fid, length, format, 0, BYTEORDER);
-  fclose (fid);
+  end_unwind_protect
 
   ## Check data.
   if (mod (numel (yi), channels) != 0)
     error ("wavread: data in %s doesn't match the number of channels",
            filename);
   endif
 
   if (bits_per_sample == 24)
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -37,22 +37,22 @@
 ## argument that is used in their calling.
 ##
 ## The slices of the returned array that have no subscripts associated with
 ## them are set to zero.  Defining @var{fillval} to some other value allows
 ## these values to be defined.
 ##
 ## An example of the use of @code{accumdim} is:
 ##
-## @example
+## @smallexample
 ## @group
 ## accumdim ([1, 2, 1, 2, 1], [7,-10,4;-5,-12,8;-12,2,8;-10,9,-3;-5,-3,-13])
 ## @result{} ans = [-10,-11,-1;-15,-3,5]
 ## @end group
-## @end example
+## @end smallexample
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -43,57 +43,61 @@
 ##
 ## @item @var{S} = profile ('status')
 ## Return a structure filled with certain information about the current status
 ## of the profiler.  At the moment, the only field is @code{ProfilerStatus}
 ## which is either 'on' or 'off'.
 ##
 ## @item @var{T} = profile ('info')
 ## Return the collected profiling statistics in the structure @var{T}.
-## Currently, the only field is @code{FunctionTable} which is an array
-## of structures, each entry corresponding to a function which was called
-## and for which profiling statistics are present.
+## The flat profile is returned in the field @code{FunctionTable} which is an
+## array of structures, each entry corresponding to a function which was called
+## and for which profiling statistics are present.  Furthermore, the field
+## @code{Hierarchical} contains the hierarchical call-tree.  Each node
+## has an index into the @code{FunctionTable} identifying the function it
+## corresponds to as well as data fields for number of calls and time spent
+## at this level in the call-tree.
 ## @end table
 ## @end deftypefn
 
 ## Built-in profiler.
 ## Author: Daniel Kraft <d@domob.eu>
 
 function retval = profile (option)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   switch (option)
     case 'on'
-      __profiler_reset ();
-      __profiler_enable (true);
+      __profiler_reset__ ();
+      __profiler_enable__ (true);
 
     case 'off'
-      __profiler_enable (false);
+      __profiler_enable__ (false);
 
     case 'clear'
-      __profiler_reset ();
+      __profiler_reset__ ();
 
     case 'resume'
-      __profiler_enable (true);
+      __profiler_enable__ (true);
 
     case 'status'
-      enabled = __profiler_enable ();
+      enabled = __profiler_enable__ ();
       if (enabled)
         enabled = 'on';
       else
         enabled = 'off';
       endif
       retval = struct ('ProfilerStatus', enabled);
 
     case 'info'
-      data = __profiler_data ();
-      retval = struct ('FunctionTable', data);
+      [flat, tree] = __profiler_data__ ();
+      retval = struct ('FunctionTable', flat, 'Hierarchical', tree);
 
     otherwise
       warning ("profile: Unrecognized option '%s'", option);
       print_usage ();
 
   endswitch
 
 endfunction
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -58,28 +58,29 @@ function profshow (data, n = 20)
 
   ## For printing the table, find out the maximum length of a function name
   ## so that we can proportion the table accordingly.  Based on this,
   ## we can build the format used for printing table rows.
   nameLen = length ("Function");
   for i = 1 : n
     nameLen = max (nameLen, length (data.FunctionTable(p(i)).FunctionName));
   endfor
-  headerFormat = sprintf ("%%%ds %%4s %%12s %%12s\n", nameLen);
-  rowFormat = sprintf ("%%%ds %%4s %%12.3f %%12d\n", nameLen);
+  headerFormat = sprintf ("%%4s %%%ds %%4s %%12s %%12s\n", nameLen);
+  rowFormat = sprintf ("%%4d %%%ds %%4s %%12.3f %%12d\n", nameLen);
 
-  printf (headerFormat, "Function", "Attr", "Time (s)", "Calls");
-  printf ("%s\n", repmat ("-", 1, nameLen + 2 * 13 + 5));
+  printf (headerFormat, "#", "Function", "Attr", "Time (s)", "Calls");
+  printf ("%s\n", repmat ("-", 1, nameLen + 2 * 5 + 2 * 13));
   for i = 1 : n
     row = data.FunctionTable(p(i));
     attr = "";
     if (row.IsRecursive)
       attr = "R";
     endif
-    printf (rowFormat, row.FunctionName, attr, row.TotalTime, row.NumCalls);
+    printf (rowFormat, p(i), row.FunctionName, attr, ...
+            row.TotalTime, row.NumCalls);
   endfor
 
 endfunction
 
 %!demo
 %! profile ("on");
 %! A = rand (100);
 %! B = expm (A);
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -57,162 +57,161 @@
 
 ## 2003-08-05 Shai Ayal
 ##   * permission from author to release as GPL
 ## 2004-02-10 Paul Kienzle
 ##   * renamed to quadl for compatibility
 ##   * replace global variable terminate2 with local function need_warning
 ##   * add paper ref to docs
 
-function q = quadl (f, a, b, tol, trace, varargin)
-  need_warning (1);
-  if (nargin < 4)
-    tol = [];
+function q = quadl (f, a, b, tol = [], trace = false, varargin)
+
+  if (nargin < 3)
+    print_usage ();
   endif
-  if (nargin < 5)
-    trace = [];
-  endif
+
   if (isa (a, "single") || isa (b, "single"))
     myeps = eps ("single");
   else
     myeps = eps;
   endif
   if (isempty (tol))
     tol = myeps;
   endif
   if (isempty (trace))
-    trace = 0;
+    trace = false;
   endif
   if (tol < myeps)
     tol = myeps;
   endif
 
+  ## Track whether recursion has occurred
+  global __quadl_recurse_done__;
+  __quadl_recurse_done__ = false;
+  ## Track whether warning about machine precision has been issued
+  global __quadl_need_warning__;
+  __quadl_need_warning__ = true;
+
   m = (a+b)/2;
   h = (b-a)/2;
-  alpha = sqrt(2/3);
-  beta = 1/sqrt(5);
+  alpha = sqrt (2/3);
+  beta = 1/sqrt (5);
 
   x1 = .942882415695480;
   x2 = .641853342345781;
   x3 = .236383199662150;
 
   x = [a, m-x1*h, m-alpha*h, m-x2*h, m-beta*h, m-x3*h, m, m+x3*h, ...
        m+beta*h, m+x2*h, m+alpha*h, m+x1*h, b];
 
   y = feval (f, x, varargin{:});
 
   fa = y(1);
   fb = y(13);
 
   i2 = (h/6)*(y(1) + y(13) + 5*(y(5)+y(9)));
 
-  i1 = (h/1470)*(77*(y(1)+y(13))
+  i1 = (h/1470)*(   77*(y(1)+y(13))
                  + 432*(y(3)+y(11))
                  + 625*(y(5)+y(9))
                  + 672*y(7));
 
-  is = h*(.0158271919734802*(y(1)+y(13))
+  is = h*( .0158271919734802*(y(1)+y(13))
           +.0942738402188500*(y(2)+y(12))
           + .155071987336585*(y(3)+y(11))
           + .188821573960182*(y(4)+y(10))
           + .199773405226859*(y(5)+y(9))
           + .224926465333340*(y(6)+y(8))
           + .242611071901408*y(7));
 
-  s = sign(is);
-
+  s = sign (is);
   if (s == 0)
     s = 1;
   endif
-  erri1 = abs(i1-is);
-  erri2 = abs(i2-is);
-  R = 1;
+  erri1 = abs (i1-is);
+  erri2 = abs (i2-is);
   if (erri2 != 0)
     R = erri1/erri2;
+  else
+    R = 1;
   endif
   if (R > 0 && R < 1)
     tol = tol/R;
   endif
-  is = s*abs(is)*tol/myeps;
+  is = s * abs(is) * tol/myeps;
   if (is == 0)
     is = b-a;
   endif
+
   q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin{:});
+
 endfunction
 
 ## ADAPTLOBSTP  Recursive function used by QUADL.
 ##
 ##   Q = ADAPTLOBSTP('F', A, B, FA, FB, IS, TRACE) tries to
 ##   approximate the integral of F(X) from A to B to
-##   an appropriate relative error. The argument 'F' is
+##   an appropriate relative error.  The argument 'F' is
 ##   a string containing the name of f.  The remaining
 ##   arguments are generated by ADAPTLOB or by recursion.
 ##
 ##   Walter Gautschi, 08/03/98
 
 function q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin)
+  global __quadl_recurse_done__;
+  global __quadl_need_warning__;
+
   h = (b-a)/2;
   m = (a+b)/2;
-  alpha = sqrt(2/3);
-  beta = 1/sqrt(5);
+  alpha = sqrt (2/3);
+  beta = 1 / sqrt(5);
   mll = m-alpha*h;
-  ml = m-beta*h;
-  mr = m+beta*h;
+  ml  = m-beta*h;
+  mr  = m+beta*h;
   mrr = m+alpha*h;
   x = [mll, ml, m, mr, mrr];
-  y = feval(f, x, varargin{:});
+  y = feval (f, x, varargin{:});
   fmll = y(1);
-  fml = y(2);
-  fm = y(3);
-  fmr = y(4);
+  fml  = y(2);
+  fm   = y(3);
+  fmr  = y(4);
   fmrr = y(5);
   i2 = (h/6)*(fa + fb + 5*(fml+fmr));
   i1 = (h/1470)*(77*(fa+fb) + 432*(fmll+fmrr) + 625*(fml+fmr) + 672*fm);
-  if (is+(i1-i2) == is || mll <= a || b <= mrr)
-    if ((m <= a || b <= m) && need_warning ())
+  if ((is+(i1-i2) == is || mll <= a || b <= mrr) && __quadl_recurse_done__)
+    if ((m <= a || b <= m) && __quadl_need_warning__)
       warning ("quadl: interval contains no more machine number");
       warning ("quadl: required tolerance may not be met");
-      need_warning (0);
+      __quadl_need_warning__ = false;
     endif
     q = i1;
     if (trace)
       disp ([a, b-a, q]);
     endif
   else
-    q = (adaptlobstp (f, a, mll, fa, fmll, is, trace, varargin{:})
-         + adaptlobstp (f, mll, ml, fmll, fml, is, trace, varargin{:})
-         + adaptlobstp (f, ml, m, fml, fm, is, trace, varargin{:})
-         + adaptlobstp (f, m, mr, fm, fmr, is, trace, varargin{:})
-         + adaptlobstp (f, mr, mrr, fmr, fmrr, is, trace, varargin{:})
-         + adaptlobstp (f, mrr, b, fmrr, fb, is, trace, varargin{:}));
-  endif
-endfunction
-
-function r = need_warning (v)
-  persistent w = [];
-  if (nargin == 0)
-    r = w;
-  else
-    w = v;
+    __quadl_recurse_done__ = true;
+    q = (  adaptlobstp (f, a  , mll, fa  , fmll, is, trace, varargin{:})
+         + adaptlobstp (f, mll, ml , fmll, fml , is, trace, varargin{:})
+         + adaptlobstp (f, ml , m  , fml , fm  , is, trace, varargin{:})
+         + adaptlobstp (f, m  , mr , fm  , fmr , is, trace, varargin{:})
+         + adaptlobstp (f, mr , mrr, fmr , fmrr, is, trace, varargin{:})
+         + adaptlobstp (f, mrr, b  , fmrr, fb  , is, trace, varargin{:}));
   endif
 endfunction
 
 
 ## basic functionality
-%!assert( quadl (@(x) sin (x), 0, pi, [], []), 2, -3e-16)
+%!assert (quadl (@(x) sin (x), 0, pi, [], []), 2, -3e-16)
 
 ## the values here are very high so it may be unavoidable that this fails
-%!assert ( quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15),
+%!assert (quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15),
 %!         2.588424538641647e+10, -9e-15)
 
 ## extra parameters
 %!assert (quadl (@(x,a,b) sin (a + b*x), 0, 1, [], [], 2, 3),
 %!        cos(2)/3 - cos(5)/3, - 3e-16)
 
-## test different tolerances. This test currently fails for a very high
-## tolerances.
-%!assert ( quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.3, []),
+## test different tolerances. 
+%!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.3, []),
 %!        (60 + sin(4) - sin(64))/12, -0.3)
+%!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []),
+%!        (60 + sin(4) - sin(64))/12, -0.1)
 
-
-## for lower tolerances the test passes.
-%!assert ( quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []),
-%!        (60 + sin(4) - sin(64))/12, -0.1)
\ No newline at end of file
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -466,17 +466,17 @@ function varargout = strread (str, forma
             if (ii < numel (fmt_words))
               iwrdl = length (words{iwrd});
             endif
           endif
 
         endif
       endfor
       ## Done
-      words_period = iwrd - 1;
+      words_period = max (iwrd - 1, 1);
       num_lines = ceil (num_words / words_period);
 
       ## 2. Pad words array so that it can be reshaped
       tmp_lines = ceil (num_words / words_period);
       num_words_padded = tmp_lines * words_period - num_words;
       if (num_words_padded)
         words = [words'; cell(num_words_padded, 1)]; 
       endif
@@ -628,17 +628,17 @@ function varargout = strread (str, forma
                 data = int32 (data);
               end
               varargout{k} = data.';
               k++;
             case "s"
               if (pad_out)
                 data(end+1:num_lines) = {""}
               endif
-              varargout{k} = strtrunc (data, 3)';
+              varargout{k} = strtrunc (data, swidth)';
               k++;
             otherwise
           endswitch
         case {"%*", "%*s"}
           ## skip the word
         otherwise
           ## Ensure descriptive content is consistent.
           ## Test made a bit lax to accomodate for incomplete last lines
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -49,17 +49,17 @@
 ## function will be inserted into the .cc file as a comment.
 ##
 ## @item
 ## If @var{name.ext} is on your path then it will be edited, otherwise
 ## the editor will be started with @file{HOME/name.ext} as the
 ## filename.  If @file{name.ext} is not modifiable, it will be copied to
 ## @env{HOME} before editing.
 ##
-## @strong{WARNING!} You may need to clear name before the new definition
+## @strong{Warning:} You may need to clear name before the new definition
 ## is available.  If you are editing a .cc file, you will need
 ## to mkoctfile @file{name.cc} before the definition will be available.
 ## @end itemize
 ##
 ## If @code{edit} is called with @var{field} and @var{value} variables,
 ## the value of the control field @var{field} will be @var{value}.
 ## If an output argument is requested and the first argument is @code{get}
 ## then @code{edit} will return the value of the control field @var{field}.
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -75,24 +75,26 @@ function entries = __xzip__ (commandname
     cmd = sprintf (commandtemplate, sprintf (" %s", f{:}));
 
     [status, output] = system (cmd);
     if (status)
       error ("__xzip__: %s command failed with exit status = %d",
              commandname, status);
     endif
 
-    if (nargout > 0)
-      if (nargin == 5)
+    if (nargin == 5)
+      if (nargout > 0)
         entries = cellfun(
             @(x) fullfile (outdir, sprintf ("%s.%s", x, extension)),
             f, "uniformoutput", false);
-      else
-        movefile (cellfun(@(x) sprintf ("%s.%s", x, extension), f,
-                          "uniformoutput", false), cwd);
+      endif
+    else
+      movefile (cellfun(@(x) sprintf ("%s.%s", x, extension), f,
+                        "uniformoutput", false), cwd);
+      if (nargout > 0)
         ## FIXME this does not work when you try to compress directories
         entries  = cellfun(@(x) sprintf ("%s.%s", x, extension),
                            files, "uniformoutput", false);
       endif
     endif
 
   unwind_protect_cleanup
     cd (cwd);
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -37,17 +37,17 @@ function entries = tar (tarfile, files, 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (files))
     files = cellstr (files);
   endif
 
-  if (ischar (tarfile) && iscellstr (files) && ischar (root))
+  if (! (ischar (tarfile) && iscellstr (files) && ischar (root)))
     error ("tar: all arguments must be character strings");
   endif
 
   cmd = sprintf ("tar cvf %s -C %s %s", tarfile, root,
                  sprintf (" %s", files{:}));
 
   [status, output] = system (cmd);
 
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -43,17 +43,21 @@
 
 function z = xor (x, y)
 
   if (nargin == 2)
     if (isscalar (x) || isscalar (y) || size_equal (x, y))
       ## Typecast to logicals is necessary for other numeric types.
       z = logical (x) != logical (y);
     else
-      error ("xor: X and Y must be of common size or scalars");
+      try
+        z = bsxfun (@xor, x, y);
+      catch
+        error ("xor: X and Y must be of compatible size or scalars");
+      end_try_catch
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!assert((xor ([1, 1, 0, 0], [0, 1, 0, 1]) == [1, 0, 0, 1]
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -41,57 +41,59 @@
 ## If given the string input argument "negate" as last input argument
 ## then compute the reverse vector normals of an isosurface geometry.
 ##
 ## If no output argument is given then directly redraw the patch that is
 ## given by the patch handle @var{p}.
 ##
 ## For example:
 ##
-## @example
+## @c Set example in small font to prevent overfull line
+## @smallexample
 ## function [] = isofinish (p)
-##   set (gca, "PlotBoxAspectRatioMode","manual","PlotBoxAspectRatio",[1 1 1]);
-##   set (p, "VertexNormals", -get(p,"VertexNormals")); ## Revert normals
+##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
+##             "PlotBoxAspectRatio",[1 1 1]);
+##   set (p, "VertexNormals", -get(p,"VertexNormals")); # Revert normals
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "phong");
-##   ## light ("Position", [1 1 5]); ## Available with JHandles
+##   ## light ("Position", [1 1 5]); # Available with JHandles
 ## endfunction
 ##
-## N = 15;    ## Increase number of vertices in each direction
-## iso = .4;  ## Change isovalue to .1 to display a sphere
+## N = 15;    # Increase number of vertices in each direction
+## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-## figure (); ## Open another figure window
+## figure (); # Open another figure window
 ##
 ## subplot (2, 2, 1); view (-38, 20);
 ## [f, v, cdat] = isosurface (x, y, z, c, iso, y);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-##         "FaceColor", "interp", "EdgeColor", "none");
+##            "FaceColor", "interp", "EdgeColor", "none");
 ## isofinish (p); ## Call user function isofinish
 ##
 ## subplot (2, 2, 2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-##         "FaceColor", "interp", "EdgeColor", "none");
-## isonormals (x, y, z, c, p); ## Directly modify patch
+##            "FaceColor", "interp", "EdgeColor", "none");
+## isonormals (x, y, z, c, p); # Directly modify patch
 ## isofinish (p);
 ##
 ## subplot (2, 2, 3); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-##         "FaceColor", "interp", "EdgeColor", "none");
-## n = isonormals (x, y, z, c, v); ## Compute normals of isosurface
-## set (p, "VertexNormals", n);    ## Manually set vertex normals
+##            "FaceColor", "interp", "EdgeColor", "none");
+## n = isonormals (x, y, z, c, v); # Compute normals of isosurface
+## set (p, "VertexNormals", n);    # Manually set vertex normals
 ## isofinish (p);
 ##
 ## subplot (2, 2, 4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-##         "FaceColor", "interp", "EdgeColor", "none");
-## isonormals (x, y, z, c, v, "negate"); ## Use reverse directly
+##            "FaceColor", "interp", "EdgeColor", "none");
+## isonormals (x, y, z, c, v, "negate"); # Use reverse directly
 ## isofinish (p);
-## @end example
+## @end smallexample
 ##
 ## @seealso{isosurface, isocolors}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function varargout = isonormals(varargin)
   na = nargin;
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -66,52 +66,57 @@
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will directly draw a random isosurface geometry in a graphics window.
 ## Another example for an isosurface geometry with different additional
 ## coloring
 ##
-## @example
-## N = 15;    ## Increase number of vertices in each direction
-## iso = .4;  ## Change isovalue to .1 to display a sphere
+## @c Set example in small font to prevent overfull line
+## @smallexample
+## N = 15;    # Increase number of vertices in each direction
+## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-## figure (); ## Open another figure window
+## figure (); # Open another figure window
 ##
 ## subplot (2, 2, 1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", "PlotBoxAspectRatio", [1 1 1]);
+## set (gca, "PlotBoxAspectRatioMode","manual", ...
+##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "green", "FaceLighting", "phong");
-## # light ("Position", [1 1 5]); ## Available with the JHandles package
+## # light ("Position", [1 1 5]); # Available with the JHandles package
 ##
 ## subplot (2, 2, 2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", "PlotBoxAspectRatio", [1 1 1]);
+## set (gca, "PlotBoxAspectRatioMode","manual", ...
+##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "none", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
 ## subplot (2, 2, 3); view (-38, 20);
 ## [f, v, c] = isosurface (x, y, z, c, iso, y);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
 ##            "FaceColor", "interp", "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", "PlotBoxAspectRatio", [1 1 1]);
+## set (gca, "PlotBoxAspectRatioMode","manual", ...
+##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
 ## subplot (2, 2, 4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
 ##            "FaceColor", "interp", "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", "PlotBoxAspectRatio", [1 1 1]);
+## set (gca, "PlotBoxAspectRatioMode","manual", ...
+##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
-## @end example
+## @end smallexample
 ##
 ## @seealso{isonormals, isocolors}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function varargout = isosurface(varargin)
 
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -20,29 +20,25 @@
 ## @deftypefn {Function File} {} __axis_label__ (@var{caller}, @var{txt}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = __axis_label__ (caller, txt, varargin)
 
-  if (ischar (txt))
-    ca = gca ();
+  ca = gca ();
 
-    h = get (gca (), caller);
+  h = get (gca (), caller);
 
-    set (h, "fontangle", get (ca, "fontangle"),
-         "fontname", get (ca, "fontname"),
-         "fontsize", get (ca, "fontsize"),
-         "fontunits", get (ca, "fontunits"),
-         "fontweight", get (ca, "fontweight"),
-         "string", txt,
-         varargin{:});
+  set (h, "fontangle", get (ca, "fontangle"),
+       "fontname", get (ca, "fontname"),
+       "fontsize", get (ca, "fontsize"),
+       "fontunits", get (ca, "fontunits"),
+       "fontweight", get (ca, "fontweight"),
+       "string", txt,
+       varargin{:});
 
-    if (nargout > 0)
-      retval = h;
-    endif
-  else
-    error ("%s: expecting first argument to be character string", caller);
+  if (nargout > 0)
+    retval = h;
   endif
 
 endfunction
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1245,34 +1245,40 @@ function __go_draw_axes__ (h, plot_strea
           else
             units = "";
           endif
 
           if (isnumeric (color))
             colorspec = get_text_colorspec (color, mono);
           endif
 
+          if (ischar (obj.string))
+            num_lines = size (obj.string, 1);
+          else
+            num_lines = numel (obj.string);
+          endif
           switch valign
             ## Text offset in characters. This relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
             case "cap"
               dy = -0.5;
             case "middle"
-              dy = 0;
+              dy = 0.5 * (num_lines - 1);
             case "baseline"
-              dy = 0.5;
+              dy = 0.5 + (num_lines - 1);
             case "bottom"
-              dy = 0.5;
+              dy = 0.5 + (num_lines - 1);
           endswitch
           ## Gnuplot's Character units are different for x/y and vary with fontsize. The aspect ratio
           ## of 1:1.7 was determined by experiment to work for eps/ps/etc. For the MacOS aqua terminal
           ## a value of 2.5 is needed. However, the difference is barely noticable.
           dx_and_dy = [(-dy * sind (angle)), (dy * cosd(angle))] .* [1.7 1];
 
+          ## FIXME - Multiline text produced the gnuplot "warning: ft_render: skipping glyph"
           if (nd == 3)
             ## This produces the desired vertical alignment in 3D.
             fprintf (plot_stream,
                      "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
                      undo_string_escapes (label), units, lpos(1),
                      lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
                      __do_enhanced_option__ (enhanced, obj), colorspec);
           else
@@ -2124,20 +2130,41 @@ function [str, f, s] = __maybe_munge_tex
   else
     f = "Helvetica";
     s = 10;
     fnt = f;
     it = false;
     bld = false;
   endif
 
+  ## The text object maybe multiline, and may be of any class
   str = getfield (obj, fld);
+  if (ischar (str) && size (str, 1) > 1)
+    str = cellstr (str);
+  elseif (isnumeric (str))
+    str = cellstr (num2str (str(:)));
+  endif
+  if (iscellstr (str))
+    for n = 1:numel(str)
+      if (isnumeric (str{n}))
+        str{n} = num2str (str{n});
+      endif
+    endfor
+    str = sprintf ("%s\n", str{:})(1:end-1);
+  endif
+
   if (enhanced)
     if (strcmpi (obj.interpreter, "tex"))
-      str = __tex2enhanced__ (str, fnt, it, bld);
+      if (iscellstr (str))
+        for n = 1:numel(str)
+          str{n} = __tex2enhanced__ (str{n}, fnt, it, bld);
+        endfor
+      else
+        str = __tex2enhanced__ (str, fnt, it, bld);
+      endif
     elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
         warning ("latex markup not supported for text objects");
         warned_latex = true;
       endif
     endif
   endif
 endfunction
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -42,61 +42,79 @@ function h = text (varargin)
       z = varargin{3};
       offset = 4;
     else
       z = zeros (size (x));
       offset = 3;
     endif
 
     label = varargin{offset};
-    if (ischar (label) || iscellstr (label))
-      varargin(1:offset) = [];
-      if (ischar (label))
+    varargin(1:offset) = [];
+
+    nx = numel (x);
+    ny = numel (y);
+    nz = numel (z);
+    if (ischar (label) || isnumeric (label))
+      nt = size (label, 1);
+      if (nx > 1 && nt == 1)
+        ## Mutiple text objects with same string
+        label = repmat ({label}, [nx, 1]);
+        nt = nx;
+      elseif (nx > 1 && nt == nx)
+        ## Mutiple text objects with different strings
         label = cellstr (label);
+      elseif (ischar (label))
+        ## Single text object with one or more lines
+        label = {label};
       endif
-      n = numel (label);
-      nx = numel (x);
-      ny = numel (y);
-      nz = numel (z);
+    elseif (iscell (label))
+      nt = numel (label);
+      if (nx > 1 && nt == 1)
+        label = repmat ({label}, [nx, 1]);
+        nt = nx;
+      elseif (! (nx > 1 && nt == nx))
+        label = {label};
+        nt = 1;
+      endif
     else
       error ("text: expecting LABEL to be a character string or cell array of character strings");
     endif
   else
     x = y = z = 0;
     nx = ny = nz = 1;
     label = {""};
-    n = 1;
+    nt = 1;
   endif
 
   if (rem (numel (varargin), 2) == 0)
 
-    if (nx == ny && nx == nz)
+    if (nx == ny && nx == nz && (nt == nx || nt == 1 || nx == 1))
       pos = [x(:), y(:), z(:)];
       ca = gca ();
-      tmp = zeros (n, 1);
-      if (n == 1)
-        label = label{1};
-        for i = 1:nx
-          tmp(i) = __go_text__ (ca, "string", label,
+      tmp = zeros (nt, 1);
+      if (nx == 1)
+        ## TODO - Modify __go_text__() to accept cell-strings
+        tmp = __go_text__ (ca, "string", "foobar",
+                           varargin{:},
+                           "position", pos);
+        set (tmp, "string", label{1});
+      elseif (nt == nx)
+        for n = 1:nt
+          tmp(n) = __go_text__ (ca, "string", label{n},
                                 varargin{:},
-                                "position", pos(i,:));
-        endfor
-        __request_drawnow__ ();
-      elseif (n == nx)
-        for i = 1:nx
-          tmp(i) = __go_text__ (ca, "string", label{i},
-                                varargin{:},
-                                "position", pos(i,:));
+                                "position", pos(n,:));
         endfor
         __request_drawnow__ ();
       else
         error ("text: dimension mismatch for coordinates and LABEL");
       endif
+    elseif (nt == nx || nt == 1 || nx == 1)
+      error ("text: dimension mismatch for coordinates");
     else
-      error ("text: dimension mismatch for coordinates");
+      error ("text: mismatch betwween coordinates and strings");
     endif
 
     if (nargout > 0)
       h = tmp;
     endif
 
   else
     print_usage ();
@@ -137,8 +155,66 @@ endfunction
 %! for t = 0:45:359;
 %!   text (25, 25, 0, "Vertical Alignment = Bottom", ...
 %!                    "rotation", t, ...
 %!                    "horizontalalignment", "left", ...
 %!                    "verticalalignment", "bottom")
 %! endfor
 %! caxis ([-100 100])
 %! title ("Vertically Aligned at Bottom")
+
+%!demo
+%! clf
+%! axis ([0 8 0 8])
+%! title (["First title";"Second title"])
+%! xlabel (["First xlabel";"Second xlabel"])
+%! ylabel (["First ylabel";"Second ylabel"])
+%! text (4, 4, {"Hello", "World"}, ...
+%!       "horizontalalignment", "center", ...
+%!       "verticalalignment", "middle")
+%! grid on
+
+%!demo
+%! clf
+%! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
+%!                  "facecolor", "none", ...
+%!                  "facealpha", 0);
+%! title (["First title";"Second title"])
+%! xlabel (["First xlabel";"Second xlabel"])
+%! ylabel (["First ylabel";"Second ylabel"])
+%! zlabel (["First zlabel";"Second zlabel"])
+%! text (0, 0, 5, {"Hello", "World"}, ...
+%!       "horizontalalignment", "center", ...
+%!       "verticalalignment", "middle")
+%! hold on
+%! plot3 (0, 0, 5, "+k")
+%!
+
+%!demo
+%! clf
+%! h = text (0.5, 0.3, "char");
+%! assert ("char", class (get (h, "string")))
+%! h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
+%! assert ("char", class (get (h, "string")))
+%! h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
+%! assert ("cell", class (get (h, "string")))
+%! h = text (0.5, 0.8, "foobar");
+%! set (h, "string", 1:3)
+%! h = text ([0.1, 0.1], [0.3, 0.4], "one string & two objects");
+%! assert ("char", class (get (h(1), "string")))
+%! assert ("char", class (get (h(2), "string")))
+%! h = text ([0.1, 0.1], [0.5, 0.6], {"one cellstr & two objects"});
+%! assert ("cell", class (get (h(1), "string")))
+%! assert ("cell", class (get (h(2), "string")))
+%! h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr 1 object 1", "cellstr 2 object 2"});
+%! assert ("char", class (get (h(1), "string")))
+%! assert ("char", class (get (h(2), "string")))
+%! h = text ([0.1, 0.1], [0.1, 0.2], ["1st string & 1st object"; "2nd string & 2nd object"]);
+%! assert ("char", class (get (h(1), "string")))
+%! assert ("char", class (get (h(2), "string")))
+%! h = text (0.7, 0.6, "single string");
+%! assert ("char", class (get (h, "string")))
+%! h = text (0.7, 0.5, {"single cell-string"});
+%! assert ("cell", class (get (h, "string")))
+%! xlabel (1:2)
+%! ylabel (1:2)
+%! title (1:2)
+
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -61,18 +61,20 @@
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## f = uimenu("label", "&File", "accelerator", "f");
 ## e = uimenu("label", "&Edit", "accelerator", "e");
-## uimenu(f, "label", "Close", "accelerator", "q", "callback", "close (gcf)");
-## uimenu(e, "label", "Toggle &Grid", "accelerator", "g", "callback", "grid (gca)");
+## uimenu(f, "label", "Close", "accelerator", "q", ...
+##           "callback", "close (gcf)");
+## uimenu(e, "label", "Toggle &Grid", "accelerator", "g", ...
+##           "callback", "grid (gca)");
 ## @end group
 ## @end example
 ## @seealso{figure}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function hui = uimenu (varargin)
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
 ## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
-## @var{mu} is present evaluate the polynomial for
+## @var{mu} is present, evaluate the polynomial for
 ## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ## In addition to evaluating the polynomial, the second output
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
@@ -34,61 +34,66 @@
 ## @seealso{polyfit, polyvalm, poly, roots, conv, deconv, residue, filter,
 ## polyderiv, polyint}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
-function [y, dy] = polyval (p, x, s, mu)
+function [y, dy] = polyval (p, x, s = [], mu)
 
   if (nargin < 2 || nargin > 4 || (nargout == 2 && nargin < 3))
     print_usage ();
   endif
 
-  if (nargin < 3)
-    s = [];
-  endif
-
-  if (! (isvector (p) || isempty (p)))
+  if (isempty (x))
+    y = [];
+    return;
+  elseif (isempty (p))
+    y = zeros (size (x));
+    return;
+  elseif (! isvector (p))
     error ("polyval: first argument must be a vector");
   endif
 
   if (nargin > 3)
     x = (x - mu(1)) / mu(2);
   endif
 
-  if (isempty (x))
-    y = [];
-    return;
-  endif
-
-  if (length (p) == 0)
-    y = p;
-    return;
-  endif
-
   n = length (p) - 1;
   y = p(1) * ones (size (x));
   for i = 2:n+1
     y = y .* x + p(i);
   endfor
 
   if (nargout == 2)
     ## Note: the F-Distribution is generally considered to be single-sided.
     ## http://www.itl.nist.gov/div898/handbook/eda/section3/eda3673.htm
     ##   t = finv (1-alpha, s.df, s.df);
     ##   dy = t * sqrt (1 + sumsq (A/s.R, 2)) * s.normr / sqrt (s.df)
     ## If my inference is correct, then t must equal 1 for polyval.
     ## This is because finv (0.5, n, n) = 1.0 for any n.
-    k = numel (x);
-    A = (x(:) * ones (1, n+1)) .^ (ones (k, 1) * (n:-1:0));
-    dy = sqrt (1 + sumsq (A/s.R, 2)) * s.normr / sqrt (s.df);
-    dy = reshape (dy, size (x));
+    try
+      k = numel (x);
+      A = (x(:) * ones (1, n+1)) .^ (ones (k, 1) * (n:-1:0));
+      dy = sqrt (1 + sumsq (A/s.R, 2)) * s.normr / sqrt (s.df);
+      dy = reshape (dy, size (x));
+    catch
+      if (isempty (s))
+        error ("polyval: third input is required.")
+      elseif (isstruct (s)
+              && all (ismember ({"R", "normr", "df"}, fieldnames (s))))
+        error (lasterr ())
+      elseif (isstruct (s))
+        error ("polyval: third input is missing the required fields.");
+      else
+        error ("polyval: third input is not a structure.");
+      endif
+    end_try_catch
   endif
 
 endfunction
 
 %!test
 %! fail("polyval([1,0;0,1],0:10)");
 
 %!test
@@ -137,8 +142,11 @@ endfunction
 %! x = reshape(x, [2, 5]);
 %! y = ones(size(x));
 %! assert (y, polyval(p,x), eps)
 %! x = reshape(x, [5, 2]);
 %! y = ones(size(x));
 %! assert (y, polyval(p,x), eps)
 %! x = reshape(x, [1, 1, 5, 2]);
 
+%!assert (zeros (1, 10), polyval ([], 1:10))
+%!assert ([], polyval (1, []))
+%!assert ([], polyval ([], []))
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -85,23 +85,24 @@
 ## statistical packages, American Statistician, 50, 361--365.
 ##
 ## @item R: A Language and Environment for Statistical Computing;
 ## @url{http://cran.r-project.org/doc/manuals/fullrefman.pdf}.
 ## @end itemize
 ##
 ## Examples:
 ##
-## @example
+## @c Set example in small font to prevent overfull line
+## @smallexample
 ## @group
-## x = randi (1000, [10, 1]);  # Create random empirical data in range 1-1000
-## q = quantile (x, [0, 1]);   # Return minimum, maximum of empirical distribution
-## q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of empirical distribution
+## x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
+## q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
+## q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution
 ## @end group
-## @end example
+## @end smallexample
 ## @seealso{prctile}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Description: Matlab style quantile function of a discrete/continuous distribution
 
 function q = quantile (x, p = [], dim = 1, method = 5)
 
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{z}] =} wilcoxon_test (@var{x}, @var{y}, @var{alt})
 ## For two matched-pair sample vectors @var{x} and @var{y}, perform a
 ## Wilcoxon signed-rank test of the null hypothesis PROB (@var{x} >
 ## @var{y}) == 1/2.  Under the null, the test statistic @var{z}
 ## approximately follows a standard normal distribution when @var{n} > 25.
 ##
-## @strong{Warning}: This function assumes a normal distribution for @var{z}
+## @strong{Caution:} This function assumes a normal distribution for @var{z}
 ## and thus is invalid for @var{n} @leq{} 25.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## PROB (@var{x} > @var{y}) != 1/2.  If alt is @code{">"}, the one-sided
 ## alternative PROB (@var{x} > @var{y}) > 1/2 is considered.  Similarly
 ## for @code{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) <
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -15,18 +15,30 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} deblank (@var{s})
 ## Remove trailing whitespace and nulls from @var{s}.  If @var{s}
 ## is a matrix, @var{deblank} trims each row to the length of longest
-## string.  If @var{s} is a cell array, operate recursively on each
-## element of the cell array.
+## string.  If @var{s} is a cell array of strings, operate recursively on each
+## string element.
+##
+## Examples:
+## @example
+## @group
+## deblank ("    abc  ")
+##      @result{}  "    abc"
+##
+## deblank ([" abc   "; "   def   "])
+##      @result{}  [" abc  " ; "   def"]
+## @end group
+## @end example
+## @seealso{strtrim}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function s = deblank (s)
 
   if (nargin != 1)
@@ -37,17 +49,17 @@ function s = deblank (s)
 
     k = find (! isspace (s) & s != "\0");
     if (isempty (s) || isempty (k))
       s = "";
     else
       s = s(:,1:ceil (max (k) / rows (s)));
     endif
 
-  elseif (iscell (s))
+  elseif (iscellstr (s))
 
     s = regexprep (s, "[\\s\v\\0]+$", '');
 
   else
     error ("deblank: S argument must be a string or cellstring");
   endif
 
 endfunction
@@ -57,9 +69,10 @@ endfunction
 %!assert (deblank ('   '), '')
 %!assert (deblank ("   "), "")
 %!assert (deblank (""), "")
 %!assert (deblank ({}), {})
 
 %!error <Invalid call to deblank> deblank ();
 %!error <Invalid call to deblank> deblank ("foo", "bar");
 %!error <argument must be a string> deblank (1);
+%!error <argument must be a string> deblank ({[]});
 
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -12,56 +12,68 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} str2num (@var{s})
+## @deftypefn {Function File} {@var{x} =} str2num (@var{s})
+## @deftypefnx {Function File} {[@var{x}, @var{state}] =} str2num (@var{s})
 ## Convert the string (or character array) @var{s} to a number (or an
 ## array).  Examples:
 ##
 ## @example
 ## @group
 ## str2num("3.141596")
 ##      @result{} 3.141596
 ##
 ## str2num(["1, 2, 3"; "4, 5, 6"]);
 ##      @result{} ans =
 ##         1  2  3
 ##         4  5  6
 ## @end group
 ## @end example
 ##
+## The optional second output, @var{state}, is logically true when the
+## coversion is successful. If the conversion fails the numeric output,
+## @var{n}, is empty and @var{state} is false.
+##
 ## @strong{Caution:} As @code{str2num} uses the @code{eval} function
 ## to do the conversion, @code{str2num} will execute any code contained
 ## in the string @var{s}.  Use @code{str2double} instead if you want to
 ## avoid the use of @code{eval}.
 ## @seealso{str2double, eval}
 ## @end deftypefn
 
 ## Author: jwe
 
-function m = str2num (s)
+function [m, state] = str2num (s)
 
   if (nargin == 1 && ischar (s))
     [nr, nc] = size (s);
     sep = ";";
     sep = sep (ones (nr, 1), 1);
     s = sprintf ("m = [%s];", reshape ([s, sep]', 1, nr * (nc + 1)));
-    eval (s, "m = [];");
+    state = true;
+    eval (s, "m = []; state = false;");
     if (ischar (m))
       m = [];
+      state = false;
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!assert(str2num ("-1.3e2") == -130 && str2num ("[1, 2; 3, 4]") == [1, 2; 3, 4]);
 
 %!error str2num ();
 
 %!error str2num ("string", 1);
 
+%!test
+%! [x, state] = str2num ("pi");
+%! assert (state)
+%! [x, state] = str2num (tmpnam);
+%! assert (! state)
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -38,17 +38,17 @@
 ## strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
 ##      @result{} [1; 2]
 ##
 ## strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
 ##      @result{} [1]
 ## @end group
 ## @end example
 ##
-## @strong{Note:} @code{strmatch} is scheduled for deprecation.  Use
+## @strong{Caution:} @code{strmatch} is scheduled for deprecation.  Use
 ## @code{strcmpi} or @code{strncmpi} in all new code.
 ## @seealso{strfind, findstr, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Author: Paul Kienzle, Alois Schloegl
 ## Adapted-by: jwe
 
 function idx = strmatch (s, A, exact)
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -15,28 +15,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strtrim (@var{s})
 ## Remove leading and trailing whitespace from @var{s}.  If
 ## @var{s} is a matrix, @var{strtrim} trims each row to the length of
-## longest string.  If @var{s} is a cell array, operate recursively on
-## each element of the cell array.  For example:
+## longest string.  If @var{s} is a cell array of strings, operate recursively
+## on each string element.  For example:
 ##
 ## @example
 ## @group
 ## strtrim ("    abc  ")
-##      @result{} "abc"
+##      @result{}  "abc"
 ##
 ## strtrim ([" abc   "; "   def   "])
-##      @result{} ["abc  "; "  def"]
+##      @result{}  ["abc  "  ; "  def"]
 ## @end group
 ## @end example
+## @seealso{deblank}
 ## @end deftypefn
 
 ## Author: John Swensen <jpswensen@jhu.edu>
 
 ## This function was derived from deblank.
 
 function s = strtrim (s)
 
@@ -48,17 +49,17 @@ function s = strtrim (s)
 
     k = find (! isspace (s));
     if (isempty (s) || isempty (k))
       s = "";
     else
       s = s(:, ceil (min (k) / rows (s)):ceil (max (k) / rows (s)));
     endif
 
-  elseif (iscell (s))
+  elseif (iscellstr (s))
 
     s = regexprep (s, "^[\\s\v]+|[\\s\v]+$", '');
 
   else
     error ("strtrim: S argument must be a string or cellstring");
   endif
 
 endfunction
@@ -68,9 +69,10 @@ endfunction
 %!assert (strtrim ("  "), "");
 %!assert (strtrim ("abc"), "abc");
 %!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"]);
 %!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"});
 
 %!error <Invalid call to strtrim> strtrim ();
 %!error <Invalid call to strtrim> strtrim ("abc", "def");
 %!error <argument must be a string> strtrim (1);
+%!error <argument must be a string> strtrim ({[]});
 
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -45,17 +45,17 @@
 ##
 ## @item
 ## Days before the beginning of the month go to the previous month.
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
-## @strong{Warning:} this function does not attempt to handle Julian
+## @strong{Caution:} this function does not attempt to handle Julian
 ## calendars so dates before Octave 15, 1582 are wrong by as much
 ## as eleven days.  Also be aware that only Roman Catholic countries
 ## adopted the calendar in 1582.  It took until 1924 for it to be
 ## adopted everywhere.  See the Wikipedia entry on the Gregorian
 ## calendar for more details.
 ##
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -1835,20 +1835,20 @@ public:
             switch (id)
               {
                 case base_properties::ID_VISIBLE:
                   figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
                   break;
                 case figure::properties::ID_MENUBAR:
                   figure_manager::toggle_menubar_visibility (ov.string_value (), fp.menubar_is("figure"));
                   break;
-                case figure::properties::ID_NAME:
                 case figure::properties::ID_CURRENTAXES:
                   figure_manager::update_canvas (go.get_handle (), fp.get_currentaxes ());
                   break;
+                case figure::properties::ID_NAME:
                 case figure::properties::ID_NUMBERTITLE:
                   figure_manager::set_name (ov.string_value ());
                   break;
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -307,25 +307,28 @@ update_index (Array<int>& idx, const dim
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
-Apply a binary function @var{f} element-by-element to two matrix arguments\n\
-@var{A} and @var{B}.  @var{f} is a function handle, inline function, or\n\
-string containing the name of the function to evaluate.\n\
-The function @var{f} must be capable of accepting two column-vector\n\
-arguments of equal length, or one column vector argument and a scalar.\n\
+The binary singleton expansion function applier does what its name\n\
+suggests: applies a binary function @var{f} element-by-element to two\n\
+array arguments @var{A} and @var{B}, and expands as necessary\n\
+singleton dimensions in either input argument. @var{f} is a function\n\
+handle, inline function, or string containing the name of the function\n\
+to evaluate. The function @var{f} must be capable of accepting two\n\
+column-vector arguments of equal length, or one column vector argument\n\
+and a scalar.\n\
 \n\
-The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
-singleton dimensions of the matrices will be expanded to the same\n\
-dimensionality as the other matrix.\n\
+The dimensions of @var{A} and @var{B} must be equal or singleton. The\n\
+singleton dimensions of the arrays will be expanded to the same\n\
+dimensionality as the other array.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 3)
     print_usage ();
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -53,16 +53,18 @@ along with Octave; see the file COPYING.
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
 #include "ov-uint64.h"
 
+#include "ov-fcn-handle.h"
+
 static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
 {
   octave_value_list tmp = func.do_multi_index_op (nargout, inputlist);
 
@@ -217,16 +219,17 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
   if (nargin < 2)
     {
       error ("cellfun: function requires at least 2 arguments");
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
+  bool symbol_table_lookup = false;
 
   if (! args(1).is_cell ())
     {
       error ("cellfun: C must be a cell array");
 
       return retval;
     }
 
@@ -334,26 +337,52 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
               if (ptr_func && ! error_state)
                 func = octave_value (ptr_func, true);
             }
           else
             {
               func = symbol_table::find_function (name);
               if (func.is_undefined ())
                 error ("cellfun: invalid function NAME: %s", name.c_str ());
+
+              symbol_table_lookup = true;
             }
         }
     }
 
   if (error_state || ! retval.empty ())
     return retval;
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
+
+      // The following is an optimisation because the symbol table can
+      // give a more specific function class, so this can result in
+      // fewer polymorphic function calls as the function gets called
+      // for each value of the array.
+      if (! symbol_table_lookup )
+        {
+          if (func.is_function_handle ())
+            {
+              octave_fcn_handle* f = func.fcn_handle_value ();
+
+              // Overloaded function handles need to check the type of
+              // the arguments for each element of the array, so they
+              // cannot be optimised this way.
+              if (f -> is_overloaded ())
+                goto nevermind;
+            }
+          octave_value f = symbol_table::find_function (func.function_value ()
+                                                         -> name ());
+          if (f.is_defined ())
+            func = f;
+        }
+      nevermind:
+
       unwind_protect frame;
       frame.protect_var (buffer_error_messages);
 
       bool uniform_output = true;
       octave_value error_handler;
 
       while (nargin > 3 && args(nargin-2).is_string())
         {
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -107,21 +107,21 @@ private:
 
     bool perform (bool curlerror) const
       {
         bool retval = false;
         if (!error_state)
           {
             BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-            CURLcode res = curl_easy_perform (curl);
-            if (res != CURLE_OK)
+            errnum = curl_easy_perform (curl);
+            if (errnum != CURLE_OK)
               {
                 if (curlerror)
-                  error ("%s", curl_easy_strerror (res));
+                  error ("%s", curl_easy_strerror (errnum));
               }
             else
               retval = true;
 
             END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           }
         return retval;
       }
@@ -140,16 +140,17 @@ private:
       {
         return !ascii;
       }
 
     size_t count;
     std::string host;
     bool valid;
     bool ascii;
+    mutable CURLcode errnum;
 
   private:
     CURL *curl;
 
     // No copying!
 
     curl_handle_rep (const curl_handle_rep& ov);
 
@@ -245,21 +246,17 @@ public:
 
   bool is_valid (void) const
     {
       return rep->is_valid ();
     }
 
   std::string lasterror (void) const
     {
-      CURLcode errnum;
-
-      curl_easy_getinfo (rep->handle(), CURLINFO_OS_ERRNO, &errnum);
-
-      return std::string (curl_easy_strerror (errnum));
+      return std::string (curl_easy_strerror (rep->errnum));
     }
 
   void set_ostream (std::ostream& os) const
     {
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
     }
 
   void set_istream (std::istream& is) const
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -536,17 +536,17 @@ else
   ## be possible to build a statically linked copy of Octave that is
   ## fully functional.
   OCTAVE_LIBS = \
     ./liboctinterp.la \
     ../liboctave/liboctave.la \
     ../libcruft/libcruft.la \
     ../libcruft/libranlib.la \
     ../libgnu/libgnu.la \
-    $(FFTW_XLDFLAGS) $(FFTW_XLIBS)
+    $(FFTW_XLDFLAGS) $(FFTW_XLIBS) \
     $(QHULL_LDFLAGS) $(QHULL_LIBS) \
     $(QRUPDATE_LDFLAGS) $(QRUPDATE_LIBS) \
     $(SPARSE_XLDFLAGS) $(SPARSE_XLIBS) \
     $(REGEX_LDFLAGS) $(REGEX_LIBS) \
     $(CURL_LDFLAGS) $(CURL_LIBS) \
     $(GLPK_LDFLAGS) $(GLPK_LIBS) \
     $(MAGICK_LDFLAGS) $(MAGICK_LIBS) \
     $(GRAPHICS_LDFLAGS) $(GRAPHICS_LIBS) \
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -16,16 +16,17 @@ for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #include "quit.h"
+#include "bsxfun.h"
 
 #define DEFINTBINOP_OP(name, t1, t2, op, t3) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
     octave_value retval = octave_value \
       (v1.t1 ## _value () op v2.t2 ## _value ()); \
     return retval; \
@@ -698,18 +699,25 @@ octave_value elem_xpow (FloatNDArray a, 
 #define OCTAVE_MM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        gripe_nonconformant ("operator .^", a_dims, b_dims); \
-        return octave_value (); \
+        if (is_valid_bsxfun (a_dims, b_dims)) \
+          { \
+            return bsxfun_pow (a, b); \
+          } \
+        else \
+          { \
+            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+            return octave_value (); \
+          } \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -717,18 +725,25 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        gripe_nonconformant ("operator .^", a_dims, b_dims); \
-        return octave_value (); \
+        if (is_valid_bsxfun (a_dims, b_dims)) \
+          { \
+            return bsxfun_pow (a, static_cast<T1 ## NDArray> (b)); \
+          } \
+        else \
+          { \
+            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+            return octave_value (); \
+          } \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -736,18 +751,25 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        gripe_nonconformant ("operator .^", a_dims, b_dims); \
-        return octave_value (); \
+        if (is_valid_bsxfun (a_dims, b_dims)) \
+          { \
+            return bsxfun_pow (static_cast<T2 ## NDArray> (a), b); \
+          } \
+        else \
+          { \
+            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+            return octave_value (); \
+          } \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -755,18 +777,25 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        gripe_nonconformant ("operator .^", a_dims, b_dims); \
-        return octave_value (); \
+        if (is_valid_bsxfun (a_dims, b_dims)) \
+          { \
+            return bsxfun_pow (a, static_cast<T1 ## NDArray> (b)); \
+          } \
+        else \
+          { \
+            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+            return octave_value (); \
+          } \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -774,18 +803,25 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        gripe_nonconformant ("operator .^", a_dims, b_dims); \
-        return octave_value (); \
+        if (is_valid_bsxfun (a_dims, b_dims)) \
+          { \
+            return bsxfun_pow (static_cast<T1 ## NDArray> (a), b); \
+          } \
+        else \
+          { \
+            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+            return octave_value (); \
+          } \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.length (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -190,19 +190,17 @@ c_file_ptr_buf::buf_close (void)
     }
 
   return retval;
 }
 
 int
 c_file_ptr_buf::seek (long offset, int origin)
 {
-  // gnulib::fseek doesn't seem to work, so don't use it until problem
-  // can be properly diagnosed and fixed.
-  return f ? fseek (f, offset, origin) : -1;
+  return f ? gnulib::fseek (f, offset, origin) : -1;
 }
 
 long
 c_file_ptr_buf::tell (void)
 {
   return f ? gnulib::ftell (f) : -1;
 }
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -489,32 +489,32 @@ do_stream_open (const std::string& name,
 
 #if defined (HAVE_ZLIB)
               size_t pos = tmode.find ('z');
 
               if (pos != std::string::npos)
                 {
                   tmode.erase (pos, 1);
 
-                  FILE *fptr = ::fopen (fname.c_str (), tmode.c_str ());
+                  FILE *fptr = gnulib::fopen (fname.c_str (), tmode.c_str ());
 
                   int fd = fileno (fptr);
 
                   gzFile gzf = ::gzdopen (fd, tmode.c_str ());
 
                   if (fptr)
                     retval = octave_zstdiostream::create (fname, gzf, fd,
                                                           md, flt_fmt);
                   else
                     retval.error (gnulib::strerror (errno));
                 }
               else
 #endif
                 {
-                  FILE *fptr = ::fopen (fname.c_str (), tmode.c_str ());
+                  FILE *fptr = gnulib::fopen (fname.c_str (), tmode.c_str ());
 
                   retval = octave_stdiostream::create (fname, fptr, md, flt_fmt);
 
                   if (! fptr)
                     retval.error (gnulib::strerror (errno));
                 }
 
             }
@@ -1171,21 +1171,23 @@ complete description of the syntax of th
         print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
+@deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
-string is treated as an end-of-file condition.\n\
+string is treated as an end-of-file condition.  In addition to the values\n\
+returned by @code{fscanf}, the index of the next character to be read\n\
+is returned in in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
 {
   static std::string who = "sscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -1242,17 +1244,18 @@ string is treated as an end-of-file cond
 
                       if (! error_state)
                         {
                           // FIXME -- is this the right thing to do?
                           // Extract error message first, because getting
                           // position will clear it.
                           std::string errmsg = os.error ();
 
-                          retval(3) = os.tell () + 1;
+                          retval(3)
+                            = (os.eof () ? data.length () : os.tell ()) + 1;
                           retval(2) = errmsg;
                           retval(1) = count;
                           retval(0) = tmp;
                         }
                     }
                   else
                     ::error ("%s: format TEMPLATE must be a string", who.c_str ());
                 }
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -295,18 +295,19 @@ function emit_declarations ()
     if (emit_get[i])
     {
       if (type[i] == "any_property")
         emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "handle_property")
         emit_get_accessor(i, "graphics_handle", "handle_value");
       else if (type[i] == "string_property")
         emit_get_accessor(i, "std::string", "string_value");
-      else if (type[i] == "string_array_property")
-          emit_get_accessor(i, "octave_value", "get");
+      else if (type[i] == "string_array_property" \
+               || type[i] == "text_label_property")
+        emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "double_property")
         emit_get_accessor(i, "double", "double_value");
       else if (type[i] == "double_radio_property")
         emit_get_double_radio(i);
       else if (type[i] == "array_property" \
                || type[i] == "row_vector_property")
         emit_get_array(i);
       else if (type[i] == "bool_property")
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -2417,17 +2417,17 @@ void
 opengl_renderer::draw_hggroup (const hggroup::properties &props)
 {
   draw (props.get_children ());
 }
 
 void
 opengl_renderer::draw_text (const text::properties& props)
 {
-  if (props.get_string ().empty ())
+  if (props.get_string ().is_empty ())
     return;
 
   const Matrix pos = xform.scale (props.get_data_position ());
   const Matrix bbox = props.get_extent_matrix ();
 
   // FIXME: handle margin and surrounding box
   bool blend = glIsEnabled (GL_BLEND);
 
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -194,17 +194,17 @@ glps_renderer::draw_pixels (GLsizei w, G
     ::draw_pixels (w, h, format, static_cast<const GLubyte *> (data));
   else
     gl2psDrawPixels (w, h, 0, 0, format, type, data);
 }
 
 void
 glps_renderer::draw_text (const text::properties& props)
 {
-  if (props.get_string ().empty ())
+  if (props.get_string ().is_empty ())
     return;
 
   set_font (props);
   set_color (props.get_color_rgb ());
 
   const Matrix pos = get_transform ().scale (props.get_data_position ());
   int halign = 0, valign = 0;
 
@@ -218,14 +218,20 @@ glps_renderer::draw_text (const text::pr
   else if (props.verticalalignment_is ("baseline"))
     valign = 3;
   else if (props.verticalalignment_is ("middle"))
     valign = 1;
 
   // FIXME: handle margin and surrounding box
 
   glRasterPos3d (pos(0), pos(1), pos(2));
-  gl2psTextOpt (props.get_string ().c_str (), fontname.c_str (), fontsize,
+
+  octave_value string_prop = props.get_string ();
+
+  string_vector sv = string_prop.all_strings ();
+
+  std::string s = sv.join ("\n");
+
+  gl2psTextOpt (s.c_str (), fontname.c_str (), fontsize, 
                 alignment_to_mode (halign, valign), props.get_rotation ());
-
 }
 
 #endif
diff --git a/src/gl2ps.c b/src/gl2ps.c
--- a/src/gl2ps.c
+++ b/src/gl2ps.c
@@ -45,17 +45,17 @@
 #if defined(GL2PS_HAVE_ZLIB)
 #include <zlib.h>
 #endif
 
 #if defined(GL2PS_HAVE_LIBPNG)
 #include <png.h>
 #endif
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Private definitions, data structures and prototypes
  *
  *********************************************************************/
 
 /* Magic numbers (assuming that the order of magnitude of window
    coordinates is 10^3) */
 
@@ -162,17 +162,16 @@ typedef struct {
 } GL2PSstring;
 
 typedef struct {
   GLsizei width, height;
   /* Note: for an imagemap, 'type' indicates if it has already been
      written to the file or not, and 'format' indicates if it is
      visible or not */
   GLenum format, type;
-  GLfloat zoom_x, zoom_y;
   GLfloat *pixels;
 } GL2PSimage;
 
 typedef struct _GL2PSimagemap GL2PSimagemap;
 
 struct _GL2PSimagemap {
   GL2PSimage *image;
   GL2PSimagemap *next;
@@ -223,17 +222,17 @@ typedef struct {
 
   /* BSP-specific */
   GLint maxbestroot;
 
   /* Occlusion culling-specific */
   GLboolean zerosurfacearea;
   GL2PSbsptree2d *imagetree;
   GL2PSprimitive *primitivetoadd;
-
+  
   /* PDF-specific */
   int streamlength;
   GL2PSlist *pdfprimlist, *pdfgrouplist;
   int *xreflist;
   int objects_stack; /* available objects */
   int extgs_stack; /* graphics state object number */
   int font_stack; /* font object number */
   int im_stack; /* image object number */
@@ -261,34 +260,34 @@ typedef struct {
    local GL2PScontext during gl2psBeginPage) */
 
 static GL2PScontext *gl2ps = NULL;
 
 /* Need to forward-declare this one */
 
 static GLint gl2psPrintPrimitives(void);
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Utility routines
  *
  *********************************************************************/
 
 static void gl2psMsg(GLint level, const char *fmt, ...)
 {
   va_list args;
 
   if(!(gl2ps->options & GL2PS_SILENT)){
     switch(level){
     case GL2PS_INFO : fprintf(stderr, "GL2PS info: "); break;
     case GL2PS_WARNING : fprintf(stderr, "GL2PS warning: "); break;
     case GL2PS_ERROR : fprintf(stderr, "GL2PS error: "); break;
     }
     va_start(args, fmt);
-    vfprintf(stderr, fmt, args);
+    vfprintf(stderr, fmt, args); 
     va_end(args);
     fprintf(stderr, "\n");
   }
   /* if(level == GL2PS_ERROR) exit(1); */
 }
 
 static void *gl2psMalloc(size_t size)
 {
@@ -355,45 +354,45 @@ static void gl2psFreeCompress(void)
   gl2ps->compress->dest = NULL;
   gl2ps->compress->srcLen = 0;
   gl2ps->compress->destLen = 0;
 }
 
 static int gl2psAllocCompress(unsigned int srcsize)
 {
   gl2psFreeCompress();
-
+  
   if(!gl2ps->compress || !srcsize)
     return GL2PS_ERROR;
-
+  
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
   gl2ps->compress->src = (Bytef*)gl2psMalloc(gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
   gl2ps->compress->dest = (Bytef*)gl2psMalloc(gl2ps->compress->destLen);
-
+  
   return GL2PS_SUCCESS;
 }
 
 static void *gl2psReallocCompress(unsigned int srcsize)
 {
   if(!gl2ps->compress || !srcsize)
     return NULL;
-
+  
   if(srcsize < gl2ps->compress->srcLen)
     return gl2ps->compress->start;
-
+  
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
-  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src,
+  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src, 
                                               gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
-  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest,
+  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest, 
                                                gl2ps->compress->destLen);
-
+  
   return gl2ps->compress->start;
 }
 
 static size_t gl2psWriteBigEndianCompress(unsigned long data, size_t bytes)
 {
   size_t i;
   size_t size = sizeof(unsigned long);
   for(i = 1; i <= bytes; ++i){
@@ -402,18 +401,18 @@ static size_t gl2psWriteBigEndianCompres
   }
   return bytes;
 }
 
 static int gl2psDeflate(void)
 {
   /* For compatibility with older zlib versions, we use compress(...)
      instead of compress2(..., Z_BEST_COMPRESSION) */
-  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen,
-                  gl2ps->compress->start, gl2ps->compress->srcLen);
+  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen, 
+                  gl2ps->compress->start, gl2ps->compress->srcLen);  
 }
 
 #endif
 
 static int gl2psPrintf(const char* fmt, ...)
 {
   int ret;
   va_list args;
@@ -451,17 +450,17 @@ static void gl2psPrintGzipHeader()
                   2, /* extra flags: max compression */
                   '\x03'}; /* OS code: 0x03 (Unix) */
 
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
     /* add the gzip file header */
     fwrite(tmp, 10, 1, gl2ps->stream);
   }
-#endif
+#endif  
 }
 
 static void gl2psPrintGzipFooter()
 {
 #if defined(GL2PS_HAVE_ZLIB)
   int n;
   uLong crc, len;
   char tmp[8];
@@ -472,17 +471,17 @@ static void gl2psPrintGzipFooter()
     }
     else{
       /* determine the length of the header in the zlib stream */
       n = 2; /* CMF+FLG */
       if(gl2ps->compress->dest[1] & (1<<5)){
         n += 4; /* DICTID */
       }
       /* write the data, without the zlib header and footer */
-      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4),
+      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
              1, gl2ps->stream);
       /* add the gzip file footer */
       crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
       for(n = 0; n < 4; ++n){
         tmp[n] = (char)(crc & 0xff);
         crc >>= 8;
       }
       len = gl2ps->compress->srcLen;
@@ -491,17 +490,17 @@ static void gl2psPrintGzipFooter()
         len >>= 8;
       }
       fwrite(tmp, 8, 1, gl2ps->stream);
     }
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
-#endif
+#endif 
 }
 
 /* The list handling routines */
 
 static void gl2psListRealloc(GL2PSlist *list, GLint n)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot reallocate NULL list");
@@ -540,17 +539,17 @@ static GL2PSlist *gl2psListCreate(GLint 
 static void gl2psListReset(GL2PSlist *list)
 {
   if(!list) return;
   list->n = 0;
 }
 
 static void gl2psListDelete(GL2PSlist *list)
 {
-  if(!list) return;
+  if(!list) return;  
   gl2psFree(list->array);
   gl2psFree(list);
 }
 
 static void gl2psListAdd(GL2PSlist *list, void *data)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot add into unallocated list");
@@ -613,17 +612,17 @@ static void gl2psListRead(GL2PSlist *lis
 {
   if((index < 0) || (index >= list->n))
     gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListRead");
   memcpy(data, &list->array[index * list->size], list->size);
 }
 
 static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)
 {
-  static const char cb64[] =
+  static const char cb64[] = 
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
   out[0] = cb64[ in[0] >> 2 ];
   out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (len > 1) ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';
   out[3] = (len > 2) ? cb64[ in[2] & 0x3f ] : '=';
 }
 
@@ -666,17 +665,17 @@ static void gl2psListEncodeBase64(GL2PSl
 static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)
 {
   if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
      !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
      !GL2PS_ZERO(rgba1[2] - rgba2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
-
+  
 static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)
 {
   int i;
 
   for(i = 1; i < prim->numverts; i++){
     if(!gl2psSameColor(prim->verts[0].rgba, prim->verts[i].rgba)){
       return GL_FALSE;
     }
@@ -685,45 +684,45 @@ static GLboolean gl2psVertsSameColor(con
 }
 
 static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],
                                          GL2PSrgba threshold)
 {
   int i;
 
   if(n < 2) return GL_TRUE;
-
+  
   for(i = 1; i < n; i++){
     if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
        fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
        fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
       return GL_FALSE;
   }
-
+  
   return GL_TRUE;
 }
 
 static void gl2psSetLastColor(GL2PSrgba rgba)
 {
-  int i;
+  int i;        
   for(i = 0; i < 3; ++i){
     gl2ps->lastrgba[i] = rgba[i];
   }
 }
 
 static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,
                            GLfloat *red, GLfloat *green, GLfloat *blue)
 {
-
+  
   GLsizei width = im->width;
   GLsizei height = im->height;
   GLfloat *pixels = im->pixels;
   GLfloat *pimag;
 
-  /* OpenGL image is from down to up, PS image is up to down */
+  /* OpenGL image is from down to up, PS image is up to down */  
   switch(im->format){
   case GL_RGBA:
     pimag = pixels + 4 * (width * (height - 1 - y) + x);
     break;
   case GL_RGB:
   default:
     pimag = pixels + 3 * (width * (height - 1 - y) + x);
     break;
@@ -736,37 +735,35 @@ static GLfloat gl2psGetRGB(GL2PSimage *i
 }
 
 /* Helper routines for pixmaps */
 
 static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)
 {
   int size;
   GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-
+  
   image->width = im->width;
   image->height = im->height;
   image->format = im->format;
   image->type = im->type;
-  image->zoom_x = im->zoom_x;
-  image->zoom_y = im->zoom_y;
 
   switch(image->format){
   case GL_RGBA:
     size = image->height * image->width * 4 * sizeof(GLfloat);
     break;
   case GL_RGB:
   default:
     size = image->height * image->width * 3 * sizeof(GLfloat);
     break;
   }
 
   image->pixels = (GLfloat*)gl2psMalloc(size);
   memcpy(image->pixels, im->pixels, size);
-
+  
   return image;
 }
 
 static void gl2psFreePixmap(GL2PSimage *im)
 {
   if(!im)
     return;
   gl2psFree(im->pixels);
@@ -778,17 +775,17 @@ static void gl2psFreePixmap(GL2PSimage *
 #if !defined(png_jmpbuf)
 #  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
 #endif
 
 static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)
 {
   unsigned int i;
   GL2PSlist *png = (GL2PSlist*)png_get_io_ptr(png_ptr);
-  for(i = 0; i < length; i++)
+  for(i = 0; i < length; i++) 
     gl2psListAdd(png, &data[i]);
 }
 
 static void gl2psUserFlushPNG(png_structp png_ptr)
 {
 }
 
 static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)
@@ -796,31 +793,31 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_structp png_ptr;
   png_infop info_ptr;
   unsigned char *row_data;
   GLfloat dr, dg, db;
   int row, col;
 
   if(!(png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)))
     return;
-
+  
   if(!(info_ptr = png_create_info_struct(png_ptr))){
     png_destroy_write_struct(&png_ptr, NULL);
     return;
   }
-
+  
   if(setjmp(png_jmpbuf(png_ptr))) {
     png_destroy_write_struct(&png_ptr, &info_ptr);
     return;
   }
-
+  
   png_set_write_fn(png_ptr, (void *)png, gl2psUserWritePNG, gl2psUserFlushPNG);
   png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
-  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8,
-               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
+  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8, 
+               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, 
                PNG_FILTER_TYPE_BASE);
   png_write_info(png_ptr, info_ptr);
 
   row_data = (unsigned char*)gl2psMalloc(3 * pixmap->width * sizeof(unsigned char));
   for(row = 0; row < pixmap->height; row++){
     for(col = 0; col < pixmap->width; col++){
       gl2psGetRGB(pixmap, col, row, &dr, &dg, &db);
       row_data[3*col] = (unsigned char)(255. * dr);
@@ -834,17 +831,17 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_write_end(png_ptr, info_ptr);
   png_destroy_write_struct(&png_ptr, &info_ptr);
 }
 
 #endif
 
 /* Helper routines for text strings */
 
-static GLint gl2psAddText(GLint type, const char *str, const char *fontname,
+static GLint gl2psAddText(GLint type, const char *str, const char *fontname, 
                           GLshort fontsize, GLint alignment, GLfloat angle)
 {
   GLfloat pos[4];
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;
 
@@ -866,40 +863,40 @@ static GLint gl2psAddText(GLint type, co
   prim->culled = 0;
   prim->offset = 0;
   prim->pattern = 0;
   prim->factor = 0;
   prim->width = 1;
   glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
   prim->data.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   prim->data.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
-  strcpy(prim->data.text->str, str);
+  strcpy(prim->data.text->str, str); 
   prim->data.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
   strcpy(prim->data.text->fontname, fontname);
   prim->data.text->fontsize = fontsize;
   prim->data.text->alignment = alignment;
   prim->data.text->angle = angle;
 
   gl2psListAdd(gl2ps->auxprimitives, &prim);
   glPassThrough(GL2PS_TEXT_TOKEN);
-
+    
   return GL2PS_SUCCESS;
 }
 
 static GL2PSstring *gl2psCopyText(GL2PSstring *t)
 {
   GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
-  strcpy(text->str, t->str);
+  strcpy(text->str, t->str); 
   text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
   strcpy(text->fontname, t->fontname);
   text->fontsize = t->fontsize;
   text->alignment = t->alignment;
   text->angle = t->angle;
-
+  
   return text;
 }
 
 static void gl2psFreeText(GL2PSstring *text)
 {
   if(!text)
     return;
   gl2psFree(text->str);
@@ -909,17 +906,17 @@ static void gl2psFreeText(GL2PSstring *t
 
 /* Helpers for blending modes */
 
 static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)
 {
   /* returns TRUE if gl2ps supports the argument combination: only two
      blending modes have been implemented so far */
 
-  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) ||
+  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
       (sfactor == GL_ONE && dfactor == GL_ZERO) )
     return GL_TRUE;
   return GL_FALSE;
 }
 
 static void gl2psAdaptVertexForBlending(GL2PSvertex *v)
 {
   /* Transforms vertex depending on the actual blending function -
@@ -929,17 +926,17 @@ static void gl2psAdaptVertexForBlending(
 
   if(!v || !gl2ps)
     return;
 
   if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
     v->rgba[3] = 1.0F;
     return;
   }
-
+  
   switch(gl2ps->blendfunc[0]){
   case GL_ONE:
     v->rgba[3] = 1.0F;
     break;
   default:
     break;
   }
 }
@@ -950,27 +947,27 @@ static void gl2psAssignTrianglePropertie
 
   t->prop = T_VAR_COLOR;
 
   /* Uncommenting the following lines activates an even more fine
      grained distinction between triangle types - please don't delete,
      a remarkable amount of PDF handling code inside this file depends
      on it if activated */
   /*
-  t->prop = T_CONST_COLOR;
+  t->prop = T_CONST_COLOR;    
   for(i = 0; i < 3; ++i){
-    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) ||
+    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) || 
        !GL2PS_ZERO(t->vertex[1].rgba[i] - t->vertex[2].rgba[i])){
       t->prop = T_VAR_COLOR;
       break;
     }
   }
   */
 
-  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) ||
+  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) || 
      !GL2PS_ZERO(t->vertex[1].rgba[3] - t->vertex[2].rgba[3])){
     t->prop |= T_VAR_ALPHA;
   }
   else{
     if(t->vertex[0].rgba[3] < 1)
       t->prop |= T_ALPHA_LESS_1;
     else
       t->prop |= T_ALPHA_1;
@@ -1003,17 +1000,17 @@ static GL2PSprimitive *gl2psCopyPrimitiv
   GL2PSprimitive *prim;
 
   if(!p){
     gl2psMsg(GL2PS_ERROR, "Trying to copy an empty primitive");
     return NULL;
   }
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-
+  
   prim->type = p->type;
   prim->numverts = p->numverts;
   prim->boundary = p->boundary;
   prim->offset = p->offset;
   prim->pattern = p->pattern;
   prim->factor = p->factor;
   prim->culled = p->culled;
   prim->width = p->width;
@@ -1039,27 +1036,27 @@ static GLboolean gl2psSamePosition(GL2PS
 {
   if(!GL2PS_ZERO(p1[0] - p2[0]) ||
      !GL2PS_ZERO(p1[1] - p2[1]) ||
      !GL2PS_ZERO(p1[2] - p2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
- * 3D sorting routines
+ * 3D sorting routines 
  *
  *********************************************************************/
 
 static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)
 {
-  return (plane[0] * point[0] +
-          plane[1] * point[1] +
-          plane[2] * point[2] +
+  return (plane[0] * point[0] + 
+          plane[1] * point[1] + 
+          plane[2] * point[2] + 
           plane[3]);
 }
 
 static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)
 {
   return (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
 }
 
@@ -1096,53 +1093,53 @@ static void gl2psGetNormal(GLfloat *a, G
 
 static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GL2PSxyz v = {0.0F, 0.0F, 0.0F}, w = {0.0F, 0.0F, 0.0F};
 
   switch(prim->type){
   case GL2PS_TRIANGLE :
   case GL2PS_QUADRANGLE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
-    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0];
-    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1];
-    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2];
-    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) ||
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
+    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0]; 
+    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1]; 
+    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2]; 
+    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
        (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       gl2psGetNormal(v, w, plane);
-      plane[3] =
-        - plane[0] * prim->verts[0].xyz[0]
-        - plane[1] * prim->verts[0].xyz[1]
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_LINE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
     if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       if(GL2PS_ZERO(v[0]))      w[0] = 1.0F;
       else if(GL2PS_ZERO(v[1])) w[1] = 1.0F;
       else                      w[2] = 1.0F;
       gl2psGetNormal(v, w, plane);
-      plane[3] =
-        - plane[0] * prim->verts[0].xyz[0]
-        - plane[1] * prim->verts[0].xyz[1]
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_POINT :
   case GL2PS_PIXMAP :
   case GL2PS_TEXT :
   case GL2PS_SPECIAL :
   case GL2PS_IMAGEMAP:
@@ -1167,21 +1164,21 @@ static void gl2psCutEdge(GL2PSvertex *a,
   v[0] = b->xyz[0] - a->xyz[0];
   v[1] = b->xyz[1] - a->xyz[1];
   v[2] = b->xyz[2] - a->xyz[2];
 
   if(!GL2PS_ZERO(psca = gl2psPsca(plane, v)))
     sect = -gl2psComparePointPlane(a->xyz, plane) / psca;
   else
     sect = 0.0F;
-
+  
   c->xyz[0] = a->xyz[0] + v[0] * sect;
   c->xyz[1] = a->xyz[1] + v[1] * sect;
   c->xyz[2] = a->xyz[2] + v[2] * sect;
-
+  
   c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
   c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
   c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
   c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
 }
 
 static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,
                                       GL2PSprimitive *child, GLshort numverts,
@@ -1194,20 +1191,20 @@ static void gl2psCreateSplitPrimitive(GL
     child->data.image = parent->data.image;
   }
   else{
     if(numverts > 4){
       gl2psMsg(GL2PS_WARNING, "%d vertices in polygon", numverts);
       numverts = 4;
     }
     switch(numverts){
-    case 1 : child->type = GL2PS_POINT; break;
-    case 2 : child->type = GL2PS_LINE; break;
-    case 3 : child->type = GL2PS_TRIANGLE; break;
-    case 4 : child->type = GL2PS_QUADRANGLE; break;
+    case 1 : child->type = GL2PS_POINT; break; 
+    case 2 : child->type = GL2PS_LINE; break; 
+    case 3 : child->type = GL2PS_TRIANGLE; break; 
+    case 4 : child->type = GL2PS_QUADRANGLE; break;    
     default: child->type = GL2PS_NO_TYPE; break;
     }
   }
 
   child->boundary = 0; /* FIXME: not done! */
   child->culled = parent->culled;
   child->offset = parent->offset;
   child->pattern = parent->pattern;
@@ -1216,23 +1213,23 @@ static void gl2psCreateSplitPrimitive(GL
   child->numverts = numverts;
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
 
   for(i = 0; i < numverts; i++){
     if(index1[i] < 0){
       child->verts[i] = parent->verts[index0[i]];
     }
     else{
-      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]],
+      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
                    plane, &child->verts[i]);
     }
   }
 }
 
-static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb,
+static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb, 
                           GLshort i, GLshort j)
 {
   GLint k;
 
   for(k = 0; k < *nb; k++){
     if((index0[k] == i && index1[k] == j) ||
        (index1[k] == i && index0[k] == j)) return;
   }
@@ -1245,77 +1242,77 @@ static GLshort gl2psGetIndex(GLshort i, 
 {
   return (i < num - 1) ? i + 1 : 0;
 }
 
 static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GLint type = GL2PS_COINCIDENT;
   GLshort i, j;
-  GLfloat d[5];
-
-  for(i = 0; i < prim->numverts; i++){
+  GLfloat d[5]; 
+
+  for(i = 0; i < prim->numverts; i++){  
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   if(prim->numverts < 2){
     return 0;
   }
   else{
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) return 1;
+        else if(type != GL2PS_IN_BACK_OF) return 1; 
         if(d[i] < -GL2PS_EPSILON)         return 1;
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
         else if(type != GL2PS_IN_FRONT_OF) return 1;
         if(d[i] > GL2PS_EPSILON)           return 1;
       }
     }
   }
   return 0;
 }
 
-static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane,
+static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane, 
                                  GL2PSprimitive **front, GL2PSprimitive **back)
 {
   GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
   GLint type;
-  GLfloat d[5];
+  GLfloat d[5]; 
 
   type = GL2PS_COINCIDENT;
 
-  for(i = 0; i < prim->numverts; i++){
+  for(i = 0; i < prim->numverts; i++){  
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   switch(prim->type){
   case GL2PS_POINT :
     if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
     else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
     else                           type = GL2PS_COINCIDENT;
     break;
   default :
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING;
+        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
         if(d[i] < -GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(out0, out1, &out, j, -1);
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
         else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
         if(d[i] > GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(in0, in1, &in, j, -1);
       }
@@ -1332,17 +1329,17 @@ static GLint gl2psSplitPrimitive(GL2PSpr
     *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
     gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
     gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
   }
 
   return type;
 }
 
-static void gl2psDivideQuad(GL2PSprimitive *quad,
+static void gl2psDivideQuad(GL2PSprimitive *quad, 
                             GL2PSprimitive **t1, GL2PSprimitive **t2)
 {
   *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
   (*t1)->numverts = (*t2)->numverts = 3;
   (*t1)->culled = (*t2)->culled = quad->culled;
   (*t1)->offset = (*t2)->offset = quad->offset;
@@ -1361,27 +1358,27 @@ static void gl2psDivideQuad(GL2PSprimiti
   (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
 }
 
 static int gl2psCompareDepth(const void *a, const void *b)
 {
   GL2PSprimitive *q, *w;
   GLfloat dq = 0.0F, dw = 0.0F, diff;
   int i;
-
+  
   q = *(GL2PSprimitive**)a;
   w = *(GL2PSprimitive**)b;
 
   for(i = 0; i < q->numverts; i++){
-    dq += q->verts[i].xyz[2];
+    dq += q->verts[i].xyz[2]; 
   }
   dq /= (GLfloat)q->numverts;
 
   for(i = 0; i < w->numverts; i++){
-    dw += w->verts[i].xyz[2];
+    dw += w->verts[i].xyz[2]; 
   }
   dw /= (GLfloat)w->numverts;
 
   diff = dq - dw;
   if(diff > 0.){
     return -1;
   }
   else if(diff < 0.){
@@ -1422,17 +1419,17 @@ static GLint gl2psFindRoot(GL2PSlist *pr
     }
     for(i = 0; i < maxp; i++){
       prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
       gl2psGetPlane(prim1, plane);
       count = 0;
       for(j = 0; j < gl2psListNbr(primitives); j++){
         if(j != i){
           prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
-          count += gl2psTestSplitPrimitive(prim2, plane);
+          count += gl2psTestSplitPrimitive(prim2, plane); 
         }
         if(count > best) break;
       }
       if(count < best){
         best = count;
         index = i;
         *root = prim1;
         if(!count) return index;
@@ -1456,17 +1453,17 @@ static void gl2psFreeImagemap(GL2PSimage
     gl2psFree(list);
     list = next;
   }
 }
 
 static void gl2psFreePrimitive(void *data)
 {
   GL2PSprimitive *q;
-
+  
   q = *(GL2PSprimitive**)data;
   gl2psFree(q->verts);
   if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
     gl2psFreeText(q->data.text);
   }
   else if(q->type == GL2PS_PIXMAP){
     gl2psFreePixmap(q->data.image);
   }
@@ -1481,17 +1478,17 @@ static void gl2psAddPrimitiveInList(GL2P
     gl2psListAdd(list, &prim);
   }
   else{
     gl2psDivideQuad(prim, &t1, &t2);
     gl2psListAdd(list, &t1);
     gl2psListAdd(list, &t2);
     gl2psFreePrimitive(&prim);
   }
-
+  
 }
 
 static void gl2psFreeBspTree(GL2PSbsptree **tree)
 {
   if(*tree){
     if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
     if((*tree)->primitives){
       gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
@@ -1593,17 +1590,17 @@ static void gl2psTraverseBspTree(GL2PSbs
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
   }
-  else if(GL_TRUE == compare(-epsilon, result)){
+  else if(GL_TRUE == compare(-epsilon, result)){ 
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
@@ -1661,28 +1658,28 @@ static void gl2psRescaleAndOffset()
       else{
         prim->verts[0].xyz[2] -= GL2PS_ZOFFSET;
         prim->verts[1].xyz[2] -= GL2PS_ZOFFSET;
       }
     }
     else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
       factor = gl2ps->offset[0];
       units = gl2ps->offset[1];
-      area =
-        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
-        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) -
-        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
+      area = 
+        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) * 
+        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) - 
+        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) * 
         (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]);
       if(!GL2PS_ZERO(area)){
-        dZdX =
+        dZdX = 
           ((prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2]) -
            (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2])) / area;
-        dZdY =
+        dZdY = 
           ((prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2]) -
            (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2])) / area;
         maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
       }
       else{
         maxdZ = 0.0F;
@@ -1690,34 +1687,34 @@ static void gl2psRescaleAndOffset()
       dZ = factor * maxdZ + units;
       prim->verts[0].xyz[2] += dZ;
       prim->verts[1].xyz[2] += dZ;
       prim->verts[2].xyz[2] += dZ;
     }
   }
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
- * 2D sorting routines (for occlusion culling)
+ * 2D sorting routines (for occlusion culling) 
  *
  *********************************************************************/
 
 static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)
 {
-  GLfloat n;
+  GLfloat n; 
 
   plane[0] = b[1] - a[1];
   plane[1] = a[0] - b[0];
   n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
   plane[2] = 0.0F;
   if(!GL2PS_ZERO(n)){
     plane[0] /= n;
     plane[1] /= n;
-    plane[3] = -plane[0]*a[0]-plane[1]*a[1];
+    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
     return 1;
   }
   else{
     plane[0] = -1.0F;
     plane[1] = 0.0F;
     plane[3] = a[0];
     return 0;
   }
@@ -1892,47 +1889,47 @@ static GL2PSprimitive *gl2psCreateSplitP
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
   for(i = 0; i < numverts; i++){
     child->verts[i] = vertx[i];
   }
   return child;
 }
 
 static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,
-                                  GL2PSplane plane,
-                                  GL2PSprimitive **front,
+                                  GL2PSplane plane, 
+                                  GL2PSprimitive **front, 
                                   GL2PSprimitive **back)
 {
   /* cur will hold the position of the current vertex
      prev will hold the position of the previous vertex
      prev0 will hold the position of the vertex number 0
      v1 and v2 represent the current and previous vertices, respectively
      flag is set if the current vertex should be checked against the plane */
   GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
-
+  
   /* list of vertices that will go in front and back primitive */
   GL2PSvertex *front_list = NULL, *back_list = NULL;
-
+  
   /* number of vertices in front and back list */
   GLshort front_count = 0, back_count = 0;
 
   for(i = 0; i <= prim->numverts; i++){
     v1 = i;
     if(v1 == prim->numverts){
       if(prim->numverts < 3) break;
       v1 = 0;
       v2 = prim->numverts - 1;
       cur = prev0;
     }
     else if(flag){
       cur = gl2psCheckPoint(prim->verts[v1].xyz, plane);
       if(i == 0){
         prev0 = cur;
       }
-    }
+    } 
     if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
        (i < prim->numverts)){
       if(cur == GL2PS_POINT_INFRONT){
         front_count++;
         front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                                 sizeof(GL2PSvertex)*front_count);
         front_list[front_count-1] = prim->verts[v1];
       }
@@ -1977,36 +1974,36 @@ static void gl2psSplitPrimitive2D(GL2PSp
   gl2psFree(front_list);
   gl2psFree(back_list);
 }
 
 static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)
 {
   GLint ret = 0;
   GL2PSprimitive *frontprim = NULL, *backprim = NULL;
-
+  
   /* FIXME: until we consider the actual extent of text strings and
      pixmaps, never cull them. Otherwise the whole string/pixmap gets
      culled as soon as the reference point is hidden */
-  if(prim->type == GL2PS_PIXMAP ||
-     prim->type == GL2PS_TEXT ||
+  if(prim->type == GL2PS_PIXMAP || 
+     prim->type == GL2PS_TEXT || 
      prim->type == GL2PS_SPECIAL){
     return 1;
   }
 
   if(*tree == NULL){
     if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
       gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
     }
     return 1;
   }
   else{
     switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
     case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
-    case GL2PS_IN_FRONT_OF:
+    case GL2PS_IN_FRONT_OF: 
       if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
       else                       return 0;
     case GL2PS_SPANNING:
       gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
       ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
       if((*tree)->front != NULL){
         if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
           ret = 1;
@@ -2131,24 +2128,24 @@ static void gl2psBuildPolygonBoundary(GL
   gl2psBuildPolygonBoundary(tree->back);
   for(i = 0; i < gl2psListNbr(tree->primitives); i++){
     prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
     if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
   }
   gl2psBuildPolygonBoundary(tree->front);
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Feedback buffer parser
  *
  *********************************************************************/
 
-static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts,
-                                  GL2PSvertex *verts, GLint offset,
+static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts, 
+                                  GL2PSvertex *verts, GLint offset, 
                                   GLushort pattern, GLint factor,
                                   GLfloat width, char boundary)
 {
   GL2PSprimitive *prim;
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   prim->type = type;
   prim->numverts = numverts;
@@ -2205,38 +2202,38 @@ static void gl2psParseFeedbackBuffer(GLi
   GL2PSimagemap *node;
 
   current = gl2ps->feedback;
   boundary = gl2ps->boundary = GL_FALSE;
 
   while(used > 0){
 
     if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
-
+    
     switch((GLint)*current){
     case GL_POINT_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0,
+      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
                             pattern, factor, psize, 0);
       break;
     case GL_LINE_TOKEN :
     case GL_LINE_RESET_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
       i = gl2psGetVertex(&vertices[1], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0,
+      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
                             pattern, factor, lwidth, 0);
       break;
     case GL_POLYGON_TOKEN :
       count = (GLint)current[1];
       current += 2;
       used -= 2;
       v = vtot = 0;
       while(count > 0 && used > 0){
@@ -2257,94 +2254,92 @@ static void gl2psParseFeedbackBuffer(GLi
             flag = 0;
           gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
                                 pattern, factor, 1, flag);
           vertices[1] = vertices[2];
         }
         else
           v ++;
       }
-      break;
+      break;      
     case GL_BITMAP_TOKEN :
     case GL_DRAW_PIXEL_TOKEN :
     case GL_COPY_PIXEL_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      break;
+      break;      
     case GL_PASS_THROUGH_TOKEN :
       switch((GLint)current[1]){
       case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
       case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
       case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
       case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
       case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
       case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
       case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
-      case GL2PS_BEGIN_STIPPLE_TOKEN :
+      case GL2PS_BEGIN_STIPPLE_TOKEN : 
         current += 2;
-        used -= 2;
-        pattern = (GLushort)current[1];
+        used -= 2; 
+        pattern = (GLushort)current[1]; 
         current += 2;
-        used -= 2;
-        factor = (GLint)current[1];
+        used -= 2; 
+        factor = (GLint)current[1]; 
         break;
-      case GL2PS_SRC_BLEND_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_SRC_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
         gl2ps->blendfunc[0] = (GLint)current[1];
         break;
-      case GL2PS_DST_BLEND_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_DST_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
         gl2ps->blendfunc[1] = (GLint)current[1];
         break;
-      case GL2PS_POINT_SIZE_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_POINT_SIZE_TOKEN : 
+        current += 2; 
+        used -= 2; 
         psize = current[1];
         break;
-      case GL2PS_LINE_WIDTH_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_LINE_WIDTH_TOKEN : 
+        current += 2; 
+        used -= 2; 
         lwidth = current[1];
         break;
       case GL2PS_IMAGEMAP_TOKEN :
         prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
         prim->type = GL2PS_IMAGEMAP;
         prim->boundary = 0;
         prim->numverts = 4;
         prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
         prim->culled = 0;
         prim->offset = 0;
         prim->pattern = 0;
         prim->factor = 0;
         prim->width = 1;
-
+        
         node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
         node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
         node->image->type = 0;
         node->image->format = 0;
-        node->image->zoom_x = 1.0F;
-        node->image->zoom_y = 1.0F;
         node->next = NULL;
-
+        
         if(gl2ps->imagemap_head == NULL)
           gl2ps->imagemap_head = node;
         else
           gl2ps->imagemap_tail->next = node;
         gl2ps->imagemap_tail = node;
         prim->data.image = node->image;
-
+        
         current += 2; used -= 2;
         i = gl2psGetVertex(&prim->verts[0], &current[1]);
         current += i; used -= i;
-
+        
         node->image->width = (GLint)current[2];
         current += 2; used -= 2;
         node->image->height = (GLint)current[2];
         prim->verts[0].xyz[0] = prim->verts[0].xyz[0] - (int)(node->image->width / 2) + 0.5F;
         prim->verts[0].xyz[1] = prim->verts[0].xyz[1] - (int)(node->image->height / 2) + 0.5F;
         for(i = 1; i < 4; i++){
           for(v = 0; v < 3; v++){
             prim->verts[i].xyz[v] = prim->verts[0].xyz[v];
@@ -2354,56 +2349,56 @@ static void gl2psParseFeedbackBuffer(GLi
         }
         prim->verts[1].xyz[0] = prim->verts[1].xyz[0] + node->image->width;
         prim->verts[2].xyz[0] = prim->verts[1].xyz[0];
         prim->verts[2].xyz[1] = prim->verts[2].xyz[1] + node->image->height;
         prim->verts[3].xyz[1] = prim->verts[2].xyz[1];
 
         sizeoffloat = sizeof(GLfloat);
         v = 2 * sizeoffloat;
-        vtot = node->image->height + node->image->height *
+        vtot = node->image->height + node->image->height * 
           ((node->image->width - 1) / 8);
         node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
         node->image->pixels[0] = prim->verts[0].xyz[0];
         node->image->pixels[1] = prim->verts[0].xyz[1];
-
+        
         for(i = 0; i < vtot; i += sizeoffloat){
           current += 2; used -= 2;
           if((vtot - i) >= 4)
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
           else
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
         }
         current++; used--;
         gl2psListAdd(gl2ps->primitives, &prim);
         break;
       case GL2PS_DRAW_PIXELS_TOKEN :
       case GL2PS_TEXT_TOKEN :
         if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
-          gl2psListAdd(gl2ps->primitives,
+          gl2psListAdd(gl2ps->primitives, 
                        gl2psListPointer(gl2ps->auxprimitives, auxindex++));
         else
           gl2psMsg(GL2PS_ERROR, "Wrong number of auxiliary tokens in buffer");
         break;
       }
-      current += 2;
-      used -= 2;
-      break;
+      current += 2; 
+      used -= 2; 
+      break;      
     default :
       gl2psMsg(GL2PS_WARNING, "Unknown token in buffer");
       current ++;
       used --;
       break;
     }
   }
 
   gl2psListReset(gl2ps->auxprimitives);
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * PostScript routines
  *
  *********************************************************************/
 
 static void gl2psWriteByte(unsigned char byte)
 {
   unsigned char h = byte / 16;
@@ -2423,36 +2418,36 @@ static void gl2psPrintPostScriptPixmap(G
   /* FIXME: should we define an option for these? Or just keep the
      8-bit per component case? */
   int greyscale = 0; /* set to 1 to output greyscale image */
   int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */
 
   if((width <= 0) || (height <= 0)) return;
 
   gl2psPrintf("gsave\n");
-  gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%.2f %.2f scale\n", width * im->zoom_x, height * im->zoom_y);
+  gl2psPrintf("%.2f %.2f translate\n", x, y); 
+  gl2psPrintf("%d %d scale\n", width, height); 
 
   if(greyscale){ /* greyscale */
-    gl2psPrintf("/picstr %d string def\n", width);
-    gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("/picstr %d string def\n", width); 
+    gl2psPrintf("%d %d %d\n", width, height, 8); 
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
     gl2psPrintf("{ currentfile picstr readhexstring pop }\n");
     gl2psPrintf("image\n");
     for(row = 0; row < height; row++){
-      for(col = 0; col < width; col++){
+      for(col = 0; col < width; col++){ 
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         fgrey = (0.30F * dr + 0.59F * dg + 0.11F * db);
         grey = (unsigned char)(255. * fgrey);
         gl2psWriteByte(grey);
       }
       gl2psPrintf("\n");
     }
-    nbhex = width * height * 2;
-    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex);
+    nbhex = width * height * 2; 
+    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex); 
   }
   else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
     if((nbyte * 8) != nbits) nbyte++;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
@@ -2463,42 +2458,42 @@ static void gl2psPrintPostScriptPixmap(G
     for(row = 0; row < height; row++){
       icase = 1;
       col = 0;
       b = 0;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = red;
           b = (b<<2) + green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        }
+        } 
         else if(icase == 2) {
           b = green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
@@ -2507,17 +2502,17 @@ static void gl2psPrintPostScriptPixmap(G
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           b = (b<<2) + green;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        }
+        } 
         else if(icase == 3) {
           b = blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
           }
@@ -2535,45 +2530,45 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
-    if((nbyte * 8) != nbits) nbyte++;
+    if((nbyte * 8) != nbits) nbyte++; 
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
     gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       col = 0;
       icase = 1;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           green = (unsigned char)(15. * dg);
           gl2psPrintf("%x%x", red, green);
           icase++;
-        }
+        } 
         else if(icase == 2) {
           blue = (unsigned char)(15. * db);
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           gl2psPrintf("%x%x", blue, red);
           icase++;
         }
@@ -2586,49 +2581,49 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else{ /* 8 bit for r and g and b */
     nbyte = width * 3;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       for(col = 0; col < width; col++){
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         red = (unsigned char)(255. * dr);
         gl2psWriteByte(red);
         green = (unsigned char)(255. * dg);
         gl2psWriteByte(green);
         blue = (unsigned char)(255. * db);
         gl2psWriteByte(blue);
       }
       gl2psPrintf("\n");
     }
   }
-
+  
   gl2psPrintf("grestore\n");
 }
 
 static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,
                                          GLsizei width, GLsizei height,
                                          const unsigned char *imagemap){
   int i, size;
-
+  
   if((width <= 0) || (height <= 0)) return;
-
+  
   size = height + height * (width - 1) / 8;
-
+  
   gl2psPrintf("gsave\n");
   gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height);
+  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height); 
   gl2psPrintf("[ %d 0 0 -%d 0 %d ] {<", width, height);
   for(i = 0; i < size; i++){
     gl2psWriteByte(*imagemap);
     imagemap++;
   }
   gl2psPrintf(">} imagemask\ngrestore\n");
 }
 
@@ -2652,37 +2647,37 @@ static void gl2psPrintPostScriptHeader(v
 
   gl2psPrintf("%%%%Title: %s\n"
               "%%%%Creator: GL2PS %d.%d.%d%s, %s\n"
               "%%%%For: %s\n"
               "%%%%CreationDate: %s"
               "%%%%LanguageLevel: 3\n"
               "%%%%DocumentData: Clean7Bit\n"
               "%%%%Pages: 1\n",
-              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
+              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
               GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
               gl2ps->producer, ctime(&now));
 
   if(gl2ps->format == GL2PS_PS){
     gl2psPrintf("%%%%Orientation: %s\n"
                 "%%%%DocumentMedia: Default %d %d 0 () ()\n",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? "Landscape" : "Portrait",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
-                (int)gl2ps->viewport[2],
-                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
+                (int)gl2ps->viewport[2], 
+                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%BoundingBox: %d %d %d %d\n"
               "%%%%EndComments\n",
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] :
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
               (int)gl2ps->viewport[0],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
               (int)gl2ps->viewport[1],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
               (int)gl2ps->viewport[2],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
               (int)gl2ps->viewport[3]);
 
   /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
      Grayscale: r g b G
      Font choose: size fontname FC
      Text string: (string) x y size fontname S??
@@ -2720,32 +2715,32 @@ static void gl2psPrintPostScriptHeader(v
               "/SCR{ FC moveto SW neg SH -2 div rmoveto show } BD\n"
               "/STL{ FC moveto 0 SH neg rmoveto show } BD\n"
               "/STC{ FC moveto SW -2 div SH neg rmoveto show } BD\n"
               "/STR{ FC moveto SW neg SH neg rmoveto show } BD\n");
 
   /* rotated text routines: same nameanem with R appended */
 
   gl2psPrintf("/FCT { FC translate 0 0 } BD\n"
-              "/SR  { gsave FCT moveto rotate show grestore } BD\n"
+              "/SR  { gsave FCT moveto rotate show grestore } BD\n"  
               "/SBCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto show grestore } BD\n"
               "/SBRR{ gsave FCT moveto rotate SW neg 0 rmoveto show grestore } BD\n"
               "/SCLR{ gsave FCT moveto rotate 0 SH -2 div rmoveto show grestore} BD\n");
   gl2psPrintf("/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div rmoveto show grestore} BD\n"
               "/SCRR{ gsave FCT moveto rotate SW neg SH -2 div rmoveto show grestore} BD\n"
               "/STLR{ gsave FCT moveto rotate 0 SH neg rmoveto show grestore } BD\n"
               "/STCR{ gsave FCT moveto rotate SW -2 div SH neg rmoveto show grestore } BD\n"
               "/STRR{ gsave FCT moveto rotate SW neg SH neg rmoveto show grestore } BD\n");
 
   gl2psPrintf("/P  { newpath 0.0 360.0 arc closepath fill } BD\n"
               "/LS { newpath moveto } BD\n"
               "/L  { lineto } BD\n"
               "/LE { lineto stroke } BD\n"
               "/T  { newpath moveto lineto lineto closepath fill } BD\n");
-
+  
   /* Smooth-shaded triangle with PostScript level 3 shfill operator:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */
 
   gl2psPrintf("/STshfill {\n"
               "      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n"
               "      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n"
               "      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n"
               "      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n"
@@ -2789,21 +2784,21 @@ static void gl2psPrintPostScriptHeader(v
   /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */
 
   gl2psPrintf("      4 index 10 index add 0.5 mul\n" /* x12 = (x1+x2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* y12 = (y1+y2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* r12 = (r1+r2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* g12 = (g1+g2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* b12 = (b1+b2)/2 */
               "      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n");
-
+  
   /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */
 
   gl2psPrintf("      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n");
-
+  
   /* Gouraud shaded triangle using recursive subdivision until the difference
      between corner colors does not exceed the thresholds:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */
 
   gl2psPrintf("/STnoshfill {\n"
               "      2 index 8 index sub abs rThreshold gt\n" /* |r1-r2|>rth */
               "      { STsplit }\n"
               "      { 1 index 7 index sub abs gThreshold gt\n" /* |g1-g2|>gth */
@@ -2827,51 +2822,51 @@ static void gl2psPrintPostScriptHeader(v
               "                    ifelse }\n"
               "                  ifelse }\n"
               "                ifelse }\n"
               "              ifelse }\n"
               "            ifelse }\n"
               "          ifelse }\n"
               "        ifelse }\n"
               "      ifelse } BD\n");
-
+  
   gl2psPrintf("tryPS3shading\n"
               "{ /shfill where\n"
               "  { /ST { STshfill } BD }\n"
               "  { /ST { STnoshfill } BD }\n"
               "  ifelse }\n"
               "{ /ST { STnoshfill } BD }\n"
               "ifelse\n");
 
   gl2psPrintf("end\n"
               "%%%%EndProlog\n"
               "%%%%BeginSetup\n"
               "/DeviceRGB setcolorspace\n"
               "gl2psdict begin\n"
               "%%%%EndSetup\n"
               "%%%%Page: 1 1\n"
               "%%%%BeginPageSetup\n");
-
+  
   if(gl2ps->options & GL2PS_LANDSCAPE){
     gl2psPrintf("%d 0 translate 90 rotate\n",
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%EndPageSetup\n"
               "mark\n"
               "gsave\n"
               "1.0 1.0 scale\n");
-
+          
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2],
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2],
-                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
+                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
+                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 }
 
 static void gl2psPrintPostScriptColor(GL2PSrgba rgba)
 {
   if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
     gl2psSetLastColor(rgba);
@@ -2891,17 +2886,17 @@ static void gl2psEndPostScriptLine(void)
     gl2psPrintf("%g %g LE\n", gl2ps->lastvertex.xyz[0], gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
-static void gl2psParseStipplePattern(GLushort pattern, GLint factor,
+static void gl2psParseStipplePattern(GLushort pattern, GLint factor, 
                                      int *nb, int array[10])
 {
   int i, n;
   int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   char tmp[16];
 
   /* extract the 16 bits from the OpenGL stipple pattern */
@@ -2931,34 +2926,34 @@ static void gl2psParseStipplePattern(GLu
 }
 
 static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)
 {
   int len = 0, i, n, array[10];
 
   if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
     return 0;
-
+  
   gl2ps->lastpattern = pattern;
   gl2ps->lastfactor = factor;
-
+  
   if(!pattern || !factor){
     /* solid line */
     len += gl2psPrintf("[] 0 %s\n", str);
   }
   else{
     gl2psParseStipplePattern(pattern, factor, &n, array);
     len += gl2psPrintf("[");
     for(i = 0; i < n; i++){
       if(i) len += gl2psPrintf(" ");
       len += gl2psPrintf("%d", array[i]);
     }
     len += gl2psPrintf("] 0 %s\n", str);
   }
-
+  
   return len;
 }
 
 static void gl2psPrintPostScriptPrimitive(void *data)
 {
   int newline;
   GL2PSprimitive *prim;
 
@@ -2971,17 +2966,17 @@ static void gl2psPrintPostScriptPrimitiv
      line joins and to not restart the stippling for every line
      segment. So if the primitive to print is not a line we must first
      finish the current line (if any): */
   if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();
 
   switch(prim->type){
   case GL2PS_POINT :
     gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("%g %g %g P\n",
+    gl2psPrintf("%g %g %g P\n", 
                 prim->verts[0].xyz[0], prim->verts[0].xyz[1], 0.5 * prim->width);
     break;
   case GL2PS_LINE :
     if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
        !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
        gl2ps->lastlinewidth != prim->width ||
        gl2ps->lastpattern != prim->pattern ||
        gl2ps->lastfactor != prim->factor){
@@ -3134,24 +3129,24 @@ static void gl2psPrintPostScriptBeginVie
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                rgba[0], rgba[1], rgba[2],
+                rgba[0], rgba[1], rgba[2], 
                 x, y, x+w, y, x+w, y+h, x, y+h);
   }
-
+    
   gl2psPrintf("newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
               "closepath clip\n",
               x, y, x+w, y, x+w, y+h, x, y+h);
-
+  
 }
 
 static GLint gl2psPrintPostScriptEndViewport(void)
 {
   GLint res;
 
   res = gl2psPrintPrimitives();
   gl2psPrintf("grestore\n");
@@ -3183,17 +3178,17 @@ static GL2PSbackend gl2psEPS = {
   gl2psPrintPostScriptBeginViewport,
   gl2psPrintPostScriptEndViewport,
   gl2psPrintPostScriptPrimitive,
   gl2psPrintPostScriptFinalPrimitive,
   "eps",
   "Encapsulated Postscript"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * LaTeX routines
  *
  *********************************************************************/
 
 static void gl2psPrintTeXHeader(void)
 {
   char name[256];
@@ -3211,26 +3206,26 @@ static void gl2psPrintTeXHeader(void)
     if(i <= 0) strcpy(name, gl2ps->filename);
   }
   else{
     strcpy(name, "untitled");
   }
 
   time(&now);
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "\\setlength{\\unitlength}{1pt}\n"
           "\\begin{picture}(0,0)\n"
           "\\includegraphics{%s}\n"
           "\\end{picture}%%\n"
           "%s\\begin{picture}(%d,%d)(0,0)\n",
           name, (gl2ps->options & GL2PS_LANDSCAPE) ? "\\rotatebox{90}{" : "",
           (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
 }
@@ -3238,23 +3233,20 @@ static void gl2psPrintTeXHeader(void)
 static void gl2psPrintTeXPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_TEXT :
-    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont",
+    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont", 
             prim->data.text->fontsize);
-    fprintf(gl2ps->stream, "\\put(%g,%g)",
+    fprintf(gl2ps->stream, "\\put(%g,%g){\\makebox(0,0)",
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    if(prim->data.text->angle)
-      fprintf(gl2ps->stream, "{\\rotatebox{%g}", prim->data.text->angle);
-    fprintf(gl2ps->stream, "{\\makebox(0,0)");
     switch(prim->data.text->alignment){
     case GL2PS_TEXT_C:
       fprintf(gl2ps->stream, "{");
       break;
     case GL2PS_TEXT_CL:
       fprintf(gl2ps->stream, "[l]{");
       break;
     case GL2PS_TEXT_CR:
@@ -3275,16 +3267,18 @@ static void gl2psPrintTeXPrimitive(void 
     case GL2PS_TEXT_TR:
       fprintf(gl2ps->stream, "[tr]{");
       break;
     case GL2PS_TEXT_BL:
     default:
       fprintf(gl2ps->stream, "[bl]{");
       break;
     }
+    if(prim->data.text->angle)
+      fprintf(gl2ps->stream, "\\rotatebox{%g}{", prim->data.text->angle);
     fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
             prim->verts[0].rgba[0], prim->verts[0].rgba[1], prim->verts[0].rgba[2],
             prim->data.text->str);
     if(prim->data.text->angle)
       fprintf(gl2ps->stream, "}");
     fprintf(gl2ps->stream, "}}\n");
     break;
   case GL2PS_SPECIAL :
@@ -3302,17 +3296,17 @@ static void gl2psPrintTeXFooter(void)
 {
   fprintf(gl2ps->stream, "\\end{picture}%s\n",
           (gl2ps->options & GL2PS_LANDSCAPE) ? "}" : "");
 }
 
 static void gl2psPrintTeXBeginViewport(GLint viewport[4])
 {
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintTeXHeader();
     gl2ps->header = GL_FALSE;
   }
 }
 
 static GLint gl2psPrintTeXEndViewport(void)
 {
@@ -3331,17 +3325,17 @@ static GL2PSbackend gl2psTEX = {
   gl2psPrintTeXBeginViewport,
   gl2psPrintTeXEndViewport,
   gl2psPrintTeXPrimitive,
   gl2psPrintTeXFinalPrimitive,
   "tex",
   "LaTeX text"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * PDF routines
  *
  *********************************************************************/
 
 static int gl2psPrintPDFCompressorType(void)
 {
 #if defined(GL2PS_HAVE_ZLIB)
@@ -3367,17 +3361,17 @@ static int gl2psPrintPDFStrokeColor(GL2P
   }
   offs += gl2psPrintf("RG\n");
   return offs;
 }
 
 static int gl2psPrintPDFFillColor(GL2PSrgba rgba)
 {
   int i, offs = 0;
-
+  
   for(i = 0; i < 3; ++i){
     if(GL2PS_ZERO(rgba[i]))
       offs += gl2psPrintf("%.0f ", 0.);
     else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
       offs += gl2psPrintf("%f ", rgba[i]);
     else
       offs += gl2psPrintf("%g ", rgba[i]);
   }
@@ -3393,28 +3387,28 @@ static int gl2psPrintPDFLineWidth(GLfloa
     return gl2psPrintf("%f w\n", lw);
   else
     return gl2psPrintf("%g w\n", lw);
 }
 
 static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)
 {
   GLfloat rad, crad, srad;
-
+  
   if(text->angle == 0.0F){
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
        "/F%d %d Tf\n"
        "%f %f Td\n"
        "(%s) Tj\n"
-       "ET\n",
+       "ET\n", 
        cnt, text->fontsize, x, y, text->str);
   }
   else{
-    rad = (GLfloat)M_PI * text->angle / 180.0F;
+    rad = M_PI * text->angle / 180.0F;
     srad = (GLfloat)sin(rad);
     crad = (GLfloat)cos(rad);
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
        "/F%d %d Tf\n"
        "%f %f %f %f %f %f Tm\n"
        "(%s) Tj\n"
        "ET\n",
@@ -3429,33 +3423,33 @@ static void gl2psPutPDFImage(GL2PSimage 
      "%d 0 0 %d %f %f cm\n"
      "/Im%d Do\n"
      "Q\n",
      (int)image->width, (int)image->height, x, y, cnt);
 }
 
 static void gl2psPDFstacksInit(void)
 {
-  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1;
-  gl2ps->extgs_stack = 0;
-  gl2ps->font_stack = 0;
-  gl2ps->im_stack = 0;
-  gl2ps->trgroupobjects_stack = 0;
-  gl2ps->shader_stack = 0;
-  gl2ps->mshader_stack = 0;
+  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
+  gl2ps->extgs_stack = 0;   
+  gl2ps->font_stack = 0;    
+  gl2ps->im_stack = 0;      
+  gl2ps->trgroupobjects_stack = 0;    
+  gl2ps->shader_stack = 0;  
+  gl2ps->mshader_stack = 0; 
 }
 
 static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)
 {
   if(!gro)
     return;
-
+  
   gro->ptrlist = NULL;
-  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno
-    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno
+  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
+    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
     = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
 }
 
 /* Build up group objects and assign name and object numbers */
 
 static void gl2psPDFgroupListInit(void)
 {
   int i;
@@ -3470,17 +3464,17 @@ static void gl2psPDFgroupListInit(void)
   int lastTriangleWasNotSimpleWithSameColor = 0;
 
   if(!gl2ps->pdfprimlist)
     return;
 
   gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
   gl2psInitTriangle(&lastt);
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
     p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
     switch(p->type){
     case GL2PS_PIXMAP:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.imno = gl2ps->im_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
@@ -3488,17 +3482,17 @@ static void gl2psPDFgroupListInit(void)
     case GL2PS_TEXT:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.fontno = gl2ps->font_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       break;
     case GL2PS_LINE:
-      if(lasttype != p->type || lastwidth != p->width ||
+      if(lasttype != p->type || lastwidth != p->width || 
          lastpattern != p->pattern || lastfactor != p->factor ||
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
@@ -3507,102 +3501,102 @@ static void gl2psPDFgroupListInit(void)
       lastpattern = p->pattern;
       lastfactor = p->factor;
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_POINT:
-      if(lasttype != p->type || lastwidth != p->width ||
+      if(lasttype != p->type || lastwidth != p->width || 
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
         gl2psListAdd(gro.ptrlist, &p);
       }
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
-      lastTriangleWasNotSimpleWithSameColor =
+      lastTriangleWasNotSimpleWithSameColor = 
         !(tmpt.prop & T_CONST_COLOR && tmpt.prop & T_ALPHA_1) ||
         !gl2psSameColor(tmpt.vertex[0].rgba, lastt.vertex[0].rgba);
-      if(lasttype == p->type && tmpt.prop == lastt.prop &&
+      if(lasttype == p->type && tmpt.prop == lastt.prop && 
          lastTriangleWasNotSimpleWithSameColor){
         /* TODO Check here for last alpha */
         gl2psListAdd(gro.ptrlist, &p);
       }
       else{
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       lastt = tmpt;
       break;
     default:
       break;
-    }
+    } 
     lasttype = p->type;
   }
 }
 
 static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)
 {
   GL2PStriangle t;
   GL2PSprimitive *prim = NULL;
-
+  
   if(!gro)
     return;
 
   if(!gl2psListNbr(gro->ptrlist))
     return;
 
   prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
   if(prim->type != GL2PS_TRIANGLE)
     return;
 
   gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
-
-  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
-    gro->gsno = gl2ps->extgs_stack++;
+  
+  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){        
+    gro->gsno = gl2ps->extgs_stack++; 
     gro->gsobjno = gl2ps->objects_stack ++;
   }
-  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
+  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){              
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){          
     gro->shno = gl2ps->shader_stack++;
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){             
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++;
+    gro->shno = gl2ps->shader_stack++; 
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){                
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++;
+    gro->shno = gl2ps->shader_stack++; 
     gro->shobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
 }
 
 /* Main stream data */
 
@@ -3625,236 +3619,236 @@ static void gl2psPDFgroupListWriteMainSt
 
     prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
     switch(prim->type){
     case GL2PS_POINT:
       gl2ps->streamlength += gl2psPrintf("1 J\n");
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
-      for(j = 0; j <= lastel; ++j){
+      for(j = 0; j <= lastel; ++j){  
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength +=
           gl2psPrintf("%f %f m %f %f l\n",
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1],
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
       }
-      gl2ps->streamlength += gl2psPrintf("S\n");
+      gl2ps->streamlength += gl2psPrintf("S\n"); 
       gl2ps->streamlength += gl2psPrintf("0 J\n");
       break;
     case GL2PS_LINE:
       /* We try to use as few paths as possible to draw lines, in
          order to get nice stippling even when the individual segments
          are smaller than the stipple */
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
       gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, "d");
       /* start new path */
-      gl2ps->streamlength +=
-        gl2psPrintf("%f %f m\n",
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f m\n", 
                     prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-
+      
       for(j = 1; j <= lastel; ++j){
         prev = prim;
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         if(!gl2psSamePosition(prim->verts[0].xyz, prev->verts[1].xyz)){
           /* the starting point of the new segment does not match the
              end point of the previous line, so we end the current
              path and start a new one */
-          gl2ps->streamlength +=
-            gl2psPrintf("%f %f l\n",
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f l\n", 
                         prev->verts[1].xyz[0], prev->verts[1].xyz[1]);
-          gl2ps->streamlength +=
-            gl2psPrintf("%f %f m\n",
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f m\n", 
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
         else{
           /* the two segements are connected, so we just append to the
              current path */
-          gl2ps->streamlength +=
+          gl2ps->streamlength += 
             gl2psPrintf("%f %f l\n",
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
       }
       /* end last path */
-      gl2ps->streamlength +=
-        gl2psPrintf("%f %f l\n",
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f l\n", 
                     prim->verts[1].xyz[0], prim->verts[1].xyz[1]);
       gl2ps->streamlength += gl2psPrintf("S\n");
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
       gl2psSortOutTrianglePDFgroup(gro);
-
+      
       /* No alpha and const color: Simple PDF draw orders  */
-      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){
-        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){         
+        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);        
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
       }
-      /* Const alpha < 1 and const color: Simple PDF draw orders
+      /* Const alpha < 1 and const color: Simple PDF draw orders 
          and an extra extended Graphics State for the alpha const */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
+      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){               
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n",
                                            gro->gsno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
-      /* Variable alpha and const color: Simple PDF draw orders
-         and an extra extended Graphics State + Xobject + Shader
+      /* Variable alpha and const color: Simple PDF draw orders 
+         and an extra extended Graphics State + Xobject + Shader 
          object for the alpha mask */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
+      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){          
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n",
                                            gro->gsno, gro->trgroupno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
       /* Variable color and no alpha: Shader Object for the colored
          triangle(s) */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){              
         gl2ps->streamlength += gl2psPrintf("/Sh%d sh\n", gro->shno);
       }
-      /* Variable color and const alpha < 1: Shader Object for the
-         colored triangle(s) and an extra extended Graphics State
+      /* Variable color and const alpha < 1: Shader Object for the 
+         colored triangle(s) and an extra extended Graphics State 
          for the alpha const */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){         
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->shno);
       }
-      /* Variable alpha and color: Shader Object for the colored
-         triangle(s) and an extra extended Graphics State
+      /* Variable alpha and color: Shader Object for the colored 
+         triangle(s) and an extra extended Graphics State 
          + Xobject + Shader object for the alpha mask */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){            
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->trgroupno, gro->shno);
       }
       break;
     case GL2PS_PIXMAP:
       for(j = 0; j <= lastel; ++j){
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0],
+        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0], 
                          prim->verts[0].xyz[1]);
       }
       break;
     case GL2PS_TEXT:
-      for(j = 0; j <= lastel; ++j){
+      for(j = 0; j <= lastel; ++j){  
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
         gl2psPutPDFText(prim->data.text, gro->fontno, prim->verts[0].xyz[0],
                         prim->verts[0].xyz[1]);
       }
       break;
     default:
       break;
-    }
+    } 
   }
 }
 
 /* Graphics State names */
 
 static int gl2psPDFgroupListWriteGStateResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
-                  "/ExtGState\n"
+                  "/ExtGState\n" 
                   "<<\n"
                   "/GSa 7 0 R\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->gsno >= 0)
       offs += fprintf(gl2ps->stream, "/GS%d %d 0 R\n", gro->gsno, gro->gsobjno);
   }
-  offs += fprintf(gl2ps->stream, ">>\n");
+  offs += fprintf(gl2ps->stream, ">>\n"); 
   return offs;
 }
 
 /* Main Shader names */
 
 static int gl2psPDFgroupListWriteShaderResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
                   "/Shading\n"
                   "<<\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->shno >= 0)
       offs += fprintf(gl2ps->stream, "/Sh%d %d 0 R\n", gro->shno, gro->shobjno);
     if(gro->maskshno >= 0)
       offs += fprintf(gl2ps->stream, "/TrSh%d %d 0 R\n", gro->maskshno, gro->maskshobjno);
   }
-  offs += fprintf(gl2ps->stream,">>\n");
+  offs += fprintf(gl2ps->stream,">>\n");  
   return offs;
 }
 
 /* Images & Mask Shader XObject names */
 
 static int gl2psPDFgroupListWriteXObjectResources(void)
 {
   int i;
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream,
                   "/XObject\n"
                   "<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_PIXMAP:
       gro->imobjno = gl2ps->objects_stack++;
       if(GL_RGBA == p->data.image->format)  /* reserve one object for image mask */
         gl2ps->objects_stack++;
@@ -3876,212 +3870,212 @@ static int gl2psPDFgroupListWriteXObject
 static int gl2psPDFgroupListWriteFontResources(void)
 {
   int i;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream, "/Font\n<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->fontno < 0)
       continue;
     gro->fontobjno = gl2ps->objects_stack++;
     offs += fprintf(gl2ps->stream, "/F%d %d 0 R\n", gro->fontno, gro->fontobjno);
   }
   offs += fprintf(gl2ps->stream, ">>\n");
 
   return offs;
 }
 
 static void gl2psPDFgroupListDelete(void)
 {
   int i;
   GL2PSpdfgroup *gro = NULL;
-
+  
   if(!gl2ps->pdfgrouplist)
     return;
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
     gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
     gl2psListDelete(gro->ptrlist);
   }
 
   gl2psListDelete(gl2ps->pdfgrouplist);
   gl2ps->pdfgrouplist = NULL;
 }
 
 /* Print 1st PDF object - file info */
 
 static int gl2psPrintPDFInfo(void)
 {
   int offs;
   time_t now;
   struct tm *newtime;
-
+  
   time(&now);
   newtime = gmtime(&now);
-
+  
   offs = fprintf(gl2ps->stream,
                  "1 0 obj\n"
                  "<<\n"
                  "/Title (%s)\n"
                  "/Creator (GL2PS %d.%d.%d%s, %s)\n"
                  "/Producer (%s)\n",
                  gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
                  GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
                  gl2ps->producer);
-
+  
   if(!newtime){
-    offs += fprintf(gl2ps->stream,
+    offs += fprintf(gl2ps->stream, 
                     ">>\n"
                     "endobj\n");
     return offs;
   }
-
-  offs += fprintf(gl2ps->stream,
+  
+  offs += fprintf(gl2ps->stream, 
                   "/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
                   ">>\n"
                   "endobj\n",
-                  newtime->tm_year+1900,
-                  newtime->tm_mon+1,
+                  newtime->tm_year+1900, 
+                  newtime->tm_mon+1, 
                   newtime->tm_mday,
                   newtime->tm_hour,
                   newtime->tm_min,
                   newtime->tm_sec);
   return offs;
 }
 
 /* Create catalog and page structure - 2nd and 3th PDF object */
 
 static int gl2psPrintPDFCatalog(void)
 {
-  return fprintf(gl2ps->stream,
+  return fprintf(gl2ps->stream, 
                  "2 0 obj\n"
                  "<<\n"
                  "/Type /Catalog\n"
                  "/Pages 3 0 R\n"
                  ">>\n"
                  "endobj\n");
 }
 
 static int gl2psPrintPDFPages(void)
 {
-  return fprintf(gl2ps->stream,
+  return fprintf(gl2ps->stream, 
                  "3 0 obj\n"
-                 "<<\n"
+                 "<<\n" 
                  "/Type /Pages\n"
                  "/Kids [6 0 R]\n"
                  "/Count 1\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Open stream for data - graphical objects, fonts etc. PDF object 4 */
 
 static int gl2psOpenPDFDataStream(void)
 {
   int offs = 0;
-
-  offs += fprintf(gl2ps->stream,
+  
+  offs += fprintf(gl2ps->stream, 
                   "4 0 obj\n"
-                  "<<\n"
+                  "<<\n" 
                   "/Length 5 0 R\n" );
   offs += gl2psPrintPDFCompressorType();
-  offs += fprintf(gl2ps->stream,
+  offs += fprintf(gl2ps->stream, 
                   ">>\n"
                   "stream\n");
   return offs;
 }
 
 /* Stream setup - Graphics state, fill background if allowed */
 
 static int gl2psOpenPDFDataStreamWritePreface(void)
 {
   int offs;
 
   offs = gl2psPrintf("/GSa gs\n");
-
+  
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
     offs += gl2psPrintf("%d %d %d %d re\n",
                         (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                         (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-    offs += gl2psPrintf("f\n");
+    offs += gl2psPrintf("f\n");  
   }
   return offs;
 }
 
 /* Use the functions above to create the first part of the PDF*/
 
 static void gl2psPrintPDFHeader(void)
 {
   int offs = 0;
   gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2psPDFstacksInit();
 
-  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack);
+  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 
 
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
   }
-#endif
+#endif    
   gl2ps->xreflist[0] = 0;
   offs += fprintf(gl2ps->stream, "%%PDF-1.4\n");
   gl2ps->xreflist[1] = offs;
-
+  
   offs += gl2psPrintPDFInfo();
   gl2ps->xreflist[2] = offs;
-
+  
   offs += gl2psPrintPDFCatalog();
   gl2ps->xreflist[3] = offs;
-
+  
   offs += gl2psPrintPDFPages();
   gl2ps->xreflist[4] = offs;
-
+  
   offs += gl2psOpenPDFDataStream();
   gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
   gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
 }
 
 /* The central primitive drawing */
 
 static void gl2psPrintPDFPrimitive(void *data)
 {
   GL2PSprimitive *prim = *(GL2PSprimitive**)data;
 
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled)
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
     return;
 
   prim = gl2psCopyPrimitive(prim); /* deep copy */
   gl2psListAdd(gl2ps->pdfprimlist, &prim);
 }
 
 /* close stream and ... */
 
 static int gl2psClosePDFDataStream(void)
 {
   int offs = 0;
-
+ 
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     if(Z_OK != gl2psDeflate())
       gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
     else
       fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
     gl2ps->streamlength += gl2ps->compress->destLen;
-
+    
     offs += gl2ps->streamlength;
     gl2psFreeCompress();
   }
-#endif
-
-  offs += fprintf(gl2ps->stream,
+#endif 
+  
+  offs += fprintf(gl2ps->stream, 
                   "endstream\n"
                   "endobj\n");
   return offs;
 }
 
 /* ... write the now known length object */
 
 static int gl2psPrintPDFDataStreamLength(int val)
@@ -4092,58 +4086,58 @@ static int gl2psPrintPDFDataStreamLength
                  "endobj\n", val);
 }
 
 /* Put the info created before in PDF objects */
 
 static int gl2psPrintPDFOpenPage(void)
 {
   int offs;
-
+  
   /* Write fixed part */
-
-  offs = fprintf(gl2ps->stream,
+  
+  offs = fprintf(gl2ps->stream, 
                  "6 0 obj\n"
-                 "<<\n"
+                 "<<\n" 
                  "/Type /Page\n"
                  "/Parent 3 0 R\n"
                  "/MediaBox [%d %d %d %d]\n",
                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-
+  
   if(gl2ps->options & GL2PS_LANDSCAPE)
     offs += fprintf(gl2ps->stream, "/Rotate -90\n");
-
+  
   offs += fprintf(gl2ps->stream,
                   "/Contents 4 0 R\n"
-                  "/Resources\n"
-                  "<<\n"
+                  "/Resources\n" 
+                  "<<\n" 
                   "/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n");
-
+  
   return offs;
 
   /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
 }
 
 static int gl2psPDFgroupListWriteVariableResources(void)
 {
   int offs = 0;
-
+  
   /* a) Graphics States for shader alpha masks*/
-  offs += gl2psPDFgroupListWriteGStateResources();
-
-  /* b) Shader and shader masks */
-  offs += gl2psPDFgroupListWriteShaderResources();
-
+  offs += gl2psPDFgroupListWriteGStateResources();  
+  
+  /* b) Shader and shader masks */ 
+  offs += gl2psPDFgroupListWriteShaderResources();  
+ 
   /* c) XObjects (Images & Shader Masks) */
   offs += gl2psPDFgroupListWriteXObjectResources();
-
+  
   /* d) Fonts */
   offs += gl2psPDFgroupListWriteFontResources();
-
+  
   /* End resources and page */
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
@@ -4164,229 +4158,229 @@ static int gl2psPrintPDFGSObject(void)
                  "/UCR2 /Default\n"
                  "/TR2 /Default\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Put vertex' edge flag (8bit) and coordinates (32bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex,
-                                              size_t (*action)(unsigned long data,
-                                                               size_t size),
-                                              GLfloat dx, GLfloat dy,
+static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
+                                                               size_t size), 
+                                              GLfloat dx, GLfloat dy, 
                                               GLfloat xmin, GLfloat ymin)
 {
   int offs = 0;
   unsigned long imap;
   GLfloat diff;
   double dmax = ~1UL;
   char edgeflag = 0;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   offs += (*action)(edgeflag, 1);
 
   /* The Shader stream in PDF requires to be in a 'big-endian'
      order */
-
+    
   if(GL2PS_ZERO(dx * dy)){
     offs += (*action)(0, 4);
     offs += (*action)(0, 4);
   }
   else{
     diff = (vertex->xyz[0] - xmin) / dx;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
-
+      
     diff = (vertex->xyz[1] - ymin) / dy;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
   }
-
+  
   return offs;
 }
 
 /* Put vertex' rgb value (8bit for every component) in shader stream */
 
 static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,
-                                            size_t (*action)(unsigned long data,
+                                            size_t (*action)(unsigned long data, 
                                                              size_t size))
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   imap = (unsigned long)((vertex->rgba[0]) * dmax);
   offs += (*action)(imap, 1);
-
+    
   imap = (unsigned long)((vertex->rgba[1]) * dmax);
   offs += (*action)(imap, 1);
-
+    
   imap = (unsigned long)((vertex->rgba[2]) * dmax);
   offs += (*action)(imap, 1);
-
+  
   return offs;
 }
 
 /* Put vertex' alpha (8/16bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex,
-                                              size_t (*action)(unsigned long data,
+static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
                                                                size_t size),
                                               int sigbyte)
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   if(sigbyte != 8 && sigbyte != 16)
     sigbyte = 8;
-
+        
   sigbyte /= 8;
-
+  
   imap = (unsigned long)((vertex->rgba[3]) * dmax);
-
+  
   offs += (*action)(imap, sigbyte);
-
+  
   return offs;
 }
 
 /* Put a triangles raw data in shader stream */
 
-static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle,
-                                         GLfloat dx, GLfloat dy,
+static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle, 
+                                         GLfloat dx, GLfloat dy, 
                                          GLfloat xmin, GLfloat ymin,
-                                         size_t (*action)(unsigned long data,
+                                         size_t (*action)(unsigned long data, 
                                                           size_t size),
                                          int gray)
 {
   int i, offs = 0;
   GL2PSvertex v;
-
+  
   if(gray && gray != 8 && gray != 16)
     gray = 8;
-
+  
   for(i = 0; i < 3; ++i){
     offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
                                                dx, dy, xmin, ymin);
-    if(gray){
+    if(gray){ 
       v = triangle->vertex[i];
-      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray);
+      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
     }
     else{
       offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
     }
   }
-
+  
   return offs;
 }
 
-static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax,
-                             GLfloat *ymin, GLfloat *ymax,
+static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax, 
+                             GLfloat *ymin, GLfloat *ymax, 
                              GL2PStriangle *triangles, int cnt)
 {
   int i, j;
 
   *xmin = triangles[0].vertex[0].xyz[0];
   *xmax = triangles[0].vertex[0].xyz[0];
   *ymin = triangles[0].vertex[0].xyz[1];
   *ymax = triangles[0].vertex[0].xyz[1];
-
+  
   for(i = 0; i < cnt; ++i){
     for(j = 0; j < 3; ++j){
       if(*xmin > triangles[i].vertex[j].xyz[0])
         *xmin = triangles[i].vertex[j].xyz[0];
       if(*xmax < triangles[i].vertex[j].xyz[0])
         *xmax = triangles[i].vertex[j].xyz[0];
       if(*ymin > triangles[i].vertex[j].xyz[1])
         *ymin = triangles[i].vertex[j].xyz[1];
       if(*ymax < triangles[i].vertex[j].xyz[1])
         *ymax = triangles[i].vertex[j].xyz[1];
     }
   }
 }
 
-/* Writes shaded triangle
+/* Writes shaded triangle 
    gray == 0 means write RGB triangles
    gray == 8             8bit-grayscale (for alpha masks)
    gray == 16            16bit-grayscale (for alpha masks) */
 
-static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles,
+static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles, 
                                int size, int gray)
 {
   int i, offs = 0, vertexbytes, done = 0;
   GLfloat xmin, xmax, ymin, ymax;
-
+        
   switch(gray){
   case 0:
     vertexbytes = 1+4+4+1+1+1;
     break;
   case 8:
     vertexbytes = 1+4+4+1;
     break;
   case 16:
     vertexbytes = 1+4+4+2;
     break;
   default:
     gray = 8;
     vertexbytes = 1+4+4+1;
     break;
   }
-
+  
   gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<< "
                   "/ShadingType 4 "
                   "/ColorSpace %s "
                   "/BitsPerCoordinate 32 "
                   "/BitsPerComponent %d "
                   "/BitsPerFlag 8 "
                   "/Decode [%f %f %f %f 0 1 %s] ",
                   obj,
-                  (gray) ? "/DeviceGray" : "/DeviceRGB",
+                  (gray) ? "/DeviceGray" : "/DeviceRGB", 
                   (gray) ? gray : 8,
                   xmin, xmax, ymin, ymax,
                   (gray) ? "" : "0 1 0 1");
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress(vertexbytes * size * 3);
 
     for(i = 0; i < size; ++i)
       gl2psPrintPDFShaderStreamData(&triangles[i],
-                                    xmax-xmin, ymax-ymin, xmin, ymin,
+                                    xmax-xmin, ymax-ymin, xmin, ymin, 
                                     gl2psWriteBigEndianCompress, gray);
 
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
-      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest,
-                                                gl2ps->compress->destLen,
+      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
+                                                gl2ps->compress->destLen, 
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
 
   if(!done){
@@ -4397,118 +4391,118 @@ static int gl2psPrintPDFShader(int obj, 
                     ">>\n"
                     "stream\n",
                     vertexbytes * 3 * size);
     for(i = 0; i < size; ++i)
       offs += gl2psPrintPDFShaderStreamData(&triangles[i],
                                             xmax-xmin, ymax-ymin, xmin, ymin,
                                             gl2psWriteBigEndian, gray);
   }
-
+  
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 /* Writes a XObject for a shaded triangle mask */
 
 static int gl2psPrintPDFShaderMask(int obj, int childobj)
 {
   int offs = 0, len;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Form\n"
                   "/BBox [ %d %d %d %d ]\n"
                   "/Group \n<<\n/S /Transparency /CS /DeviceRGB\n"
                   ">>\n",
                   obj,
                   (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                   (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-
-  len = (childobj>0)
+  
+  len = (childobj>0) 
     ? strlen("/TrSh sh\n") + (int)log10((double)childobj)+1
-    : strlen("/TrSh0 sh\n");
-
+    : strlen("/TrSh0 sh\n"); 
+  
   offs += fprintf(gl2ps->stream,
                   "/Length %d\n"
                   ">>\n"
                   "stream\n",
                   len);
   offs += fprintf(gl2ps->stream,
                   "/TrSh%d sh\n",
                   childobj);
   offs += fprintf(gl2ps->stream,
                   "endstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 /* Writes a Extended graphics state for a shaded triangle mask if
    simplealpha ist true the childobj argument is ignored and a /ca
    statement will be written instead */
 
 static int gl2psPrintPDFShaderExtGS(int obj, int childobj)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n",
                   obj);
-
+  
   offs += fprintf(gl2ps->stream,
                   "/SMask << /S /Alpha /G %d 0 R >> ",
                   childobj);
-
+  
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
 /* a simple graphics state */
 
 static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/ca %g"
                   ">>\n"
                   "endobj\n",
                   obj, alpha);
   return offs;
 }
 
 /* Similar groups of functions for pixmaps and text */
 
 static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,
-                                         size_t (*action)(unsigned long data,
-                                                          size_t size),
+                                         size_t (*action)(unsigned long data, 
+                                                          size_t size), 
                                          int gray)
 {
   int x, y, shift;
   GLfloat r, g, b, a;
 
   if(im->format != GL_RGBA && gray)
     return 0;
 
   if(gray && gray != 8 && gray != 16)
     gray = 8;
 
   gray /= 8;
-
+  
   shift = (sizeof(unsigned long) - 1) * 8;
 
   for(y = 0; y < im->height; ++y){
     for(x = 0; x < im->width; ++x){
       a = gl2psGetRGB(im, x, y, &r, &g, &b);
       if(im->format == GL_RGBA && gray){
         (*action)((unsigned long)(a * 255) << shift, gray);
       }
@@ -4529,20 +4523,20 @@ static int gl2psPrintPDFPixmapStreamData
 }
 
 static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)
 {
   int offs = 0, done = 0, sigbytes = 3;
 
   if(gray && gray !=8 && gray != 16)
     gray = 8;
-
+  
   if(gray)
-    sigbytes = gray / 8;
-
+    sigbytes = gray / 8; 
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Image\n"
                   "/Width %d\n"
                   "/Height %d\n"
                   "/ColorSpace %s \n"
@@ -4550,60 +4544,60 @@ static int gl2psPrintPDFPixmap(int obj, 
                   obj,
                   (int)im->width, (int)im->height,
                   (gray) ? "/DeviceGray" : "/DeviceRGB" );
   if(GL_RGBA == im->format && gray == 0){
     offs += fprintf(gl2ps->stream,
                     "/SMask %d 0 R\n",
                     childobj);
   }
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress((int)(im->width * im->height * sigbytes));
-
+    
     gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
-
+    
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
       offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
-
+  
   if(!done){
     /* no compression, or too long after compression, or compress error
        -> write non-compressed entry */
     offs += fprintf(gl2ps->stream,
                     "/Length %d "
                     ">>\n"
                     "stream\n",
                     (int)(im->width * im->height * sigbytes));
     offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
   }
-
+  
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /Font\n"
                   "/Subtype /Type1\n"
                   "/Name /F%d\n"
                   "/BaseFont /%s\n"
                   "/Encoding /MacRomanEncoding\n"
@@ -4621,31 +4615,31 @@ static int gl2psPDFgroupListWriteObjects
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = entryoffs;
   GL2PStriangle *triangles;
   int size = 0;
 
   if(!gl2ps->pdfgrouplist)
     return offs;
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_POINT:
       break;
     case GL2PS_LINE:
       break;
     case GL2PS_TRIANGLE:
       size = gl2psListNbr(gro->ptrlist);
       triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
-      for(j = 0; j < size; ++j){
+      for(j = 0; j < size; ++j){  
         p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
       }
       if(triangles[0].prop & T_VAR_COLOR){
         gl2ps->xreflist[gro->shobjno] = offs;
         offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
       }
       if(triangles[0].prop & T_ALPHA_LESS_1){
@@ -4677,79 +4671,79 @@ static int gl2psPDFgroupListWriteObjects
     case GL2PS_SPECIAL :
       /* alignment contains the format for which the special output text
          is intended */
       if(p->data.text->alignment == GL2PS_PDF)
         offs += fprintf(gl2ps->stream, "%s\n", p->data.text->str);
       break;
     default:
       break;
-    }
+    } 
   }
   return offs;
 }
 
 /* All variable data has been written at this point and all required
    functioninality has been gathered, so we can write now file footer
    with cross reference table and trailer */
 
 static void gl2psPrintPDFFooter(void)
 {
-  int i, offs;
+  int i, offs;  
 
   gl2psPDFgroupListInit();
   gl2psPDFgroupListWriteMainStream();
-
-  offs = gl2ps->xreflist[5] + gl2ps->streamlength;
+ 
+  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
   offs += gl2psClosePDFDataStream();
   gl2ps->xreflist[5] = offs;
-
+  
   offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
   gl2ps->xreflist[6] = offs;
   gl2ps->streamlength = 0;
-
+  
   offs += gl2psPrintPDFOpenPage();
   offs += gl2psPDFgroupListWriteVariableResources();
   gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
                                        sizeof(int) * (gl2ps->objects_stack + 1));
   gl2ps->xreflist[7] = offs;
-
+  
   offs += gl2psPrintPDFGSObject();
   gl2ps->xreflist[8] = offs;
-
-  gl2ps->xreflist[gl2ps->objects_stack] =
+  
+  gl2ps->xreflist[gl2ps->objects_stack] = 
     gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);
 
   /* Start cross reference table. The file has to been opened in
      binary mode to preserve the 20 digit string length! */
   fprintf(gl2ps->stream,
           "xref\n"
           "0 %d\n"
           "%010d 65535 f \n", gl2ps->objects_stack, 0);
-
+  
   for(i = 1; i < gl2ps->objects_stack; ++i)
     fprintf(gl2ps->stream, "%010d 00000 n \n", gl2ps->xreflist[i]);
-
+  
   fprintf(gl2ps->stream,
           "trailer\n"
-          "<<\n"
+          "<<\n" 
           "/Size %d\n"
           "/Info 1 0 R\n"
           "/Root 2 0 R\n"
           ">>\n"
           "startxref\n%d\n"
           "%%%%EOF\n",
           gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
-
-  /* Free auxiliary lists and arrays */
+  
+  /* Free auxiliary lists and arrays */    
   gl2psFree(gl2ps->xreflist);
   gl2psListAction(gl2ps->pdfprimlist, gl2psFreePrimitive);
   gl2psListDelete(gl2ps->pdfprimlist);
   gl2psPDFgroupListDelete();
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
 #endif
 }
@@ -4757,26 +4751,26 @@ static void gl2psPrintPDFFooter(void)
 /* PDF begin viewport */
 
 static void gl2psPrintPDFBeginViewport(GLint viewport[4])
 {
   int offs = 0;
   GLint index;
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-
+  
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintPDFHeader();
     gl2ps->header = GL_FALSE;
   }
 
   offs += gl2psPrintf("q\n");
-
+  
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
     }
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
@@ -4786,28 +4780,28 @@ static void gl2psPrintPDFBeginViewport(G
     offs += gl2psPrintPDFFillColor(rgba);
     offs += gl2psPrintf("%d %d %d %d re\n"
                         "W\n"
                         "f\n",
                         x, y, w, h);
   }
   else{
     offs += gl2psPrintf("%d %d %d %d re\n"
-                        "W\n"
+                        "W\n"   
                         "n\n",
-                        x, y, w, h);
-  }
-
+                        x, y, w, h);            
+  }
+  
   gl2ps->streamlength += offs;
 }
 
 static GLint gl2psPrintPDFEndViewport(void)
 {
   GLint res;
-
+  
   res = gl2psPrintPrimitives();
   gl2ps->streamlength += gl2psPrintf("Q\n");
   return res;
 }
 
 static void gl2psPrintPDFFinalPrimitive(void)
 {
 }
@@ -4820,23 +4814,23 @@ static GL2PSbackend gl2psPDF = {
   gl2psPrintPDFBeginViewport,
   gl2psPrintPDFEndViewport,
   gl2psPrintPDFPrimitive,
   gl2psPrintPDFFinalPrimitive,
   "pdf",
   "Portable Document Format"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * SVG routines
  *
  *********************************************************************/
 
-static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts,
+static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts, 
                                        GL2PSxyz *xyz, GL2PSrgba *rgba)
 {
   int i, j;
 
   for(i = 0; i < n; i++){
     xyz[i][0] = verts[i].xyz[0];
     xyz[i][1] = gl2ps->viewport[3] - verts[i].xyz[1];
     xyz[i][2] = 0.0F;
@@ -4856,35 +4850,35 @@ static void gl2psSVGGetColorString(GL2PS
   sprintf(str, "#%2.2x%2.2x%2.2x", rc, gc, bc);
 }
 
 static void gl2psPrintSVGHeader(void)
 {
   int x, y, width, height;
   char col[32];
   time_t now;
-
+  
   time(&now);
-
+  
   if (gl2ps->options & GL2PS_LANDSCAPE){
     x = (int)gl2ps->viewport[1];
     y = (int)gl2ps->viewport[0];
     width = (int)gl2ps->viewport[3];
     height = (int)gl2ps->viewport[2];
   }
   else{
     x = (int)gl2ps->viewport[0];
     y = (int)gl2ps->viewport[1];
     width = (int)gl2ps->viewport[2];
     height = (int)gl2ps->viewport[3];
   }
-
+  
   /* Compressed SVG files (.svgz) are simply gzipped SVG files */
   gl2psPrintGzipHeader();
-
+  
   gl2psPrintf("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
   gl2psPrintf("<svg xmlns=\"http://www.w3.org/2000/svg\"\n");
   gl2psPrintf("     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n"
               "     width=\"%dpx\" height=\"%dpx\" viewBox=\"%d %d %d %d\">\n",
               width, height, x, y, width, height);
   gl2psPrintf("<title>%s</title>\n", gl2ps->title);
   gl2psPrintf("<desc>\n");
   gl2psPrintf("Creator: GL2PS %d.%d.%d%s, %s\n"
@@ -4894,19 +4888,19 @@ static void gl2psPrintSVGHeader(void)
               GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
   gl2psPrintf("</desc>\n");
   gl2psPrintf("<defs>\n");
   gl2psPrintf("</defs>\n");
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psSVGGetColorString(gl2ps->bgcolor, col);
     gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1],
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 
   /* group all the primitives and disable antialiasing */
   gl2psPrintf("<g shape-rendering=\"crispEdges\">\n");
 }
 
 static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])
@@ -4919,62 +4913,62 @@ static void gl2psPrintSVGSmoothTriangle(
   /* Apparently there is no easy way to do Gouraud shading in SVG
      without explicitly pre-defining gradients, so for now we just do
      recursive subdivision */
 
   if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
     gl2psSVGGetColorString(rgba[0], col);
     gl2psPrintf("<polygon fill=\"%s\" ", col);
     if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
-    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1],
+    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1], 
                 xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
   }
   else{
     /* subdivide into 4 subtriangles */
     for(i = 0; i < 3; i++){
-      xyz2[0][i] = xyz[0][i];
+      xyz2[0][i] = xyz[0][i]; 
       xyz2[1][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
-      rgba2[0][i] = rgba[0][i];
+      rgba2[0][i] = rgba[0][i]; 
       rgba2[1][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = xyz[1][i];
+      xyz2[1][i] = xyz[1][i]; 
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = rgba[1][i];
+      rgba2[1][i] = rgba[1][i]; 
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
-      xyz2[1][i] = xyz[2][i];
+      xyz2[1][i] = xyz[2][i]; 
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
-      rgba2[1][i] = rgba[2][i];
+      rgba2[1][i] = rgba[2][i]; 
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
+      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]); 
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
+      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]); 
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
   }
 }
 
 static void gl2psPrintSVGDash(GLushort pattern, GLint factor)
 {
@@ -4990,17 +4984,17 @@ static void gl2psPrintSVGDash(GLushort p
   }
   gl2psPrintf("\" ");
 }
 
 static void gl2psEndSVGLine(void)
 {
   int i;
   if(gl2ps->lastvertex.rgba[0] >= 0.){
-    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0],
+    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0], 
                 gl2ps->viewport[3] - gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
@@ -5012,17 +5006,17 @@ static void gl2psPrintSVGPixmap(GLfloat 
   int i;
 
   /* The only image types supported by the SVG standard are JPEG, PNG
      and SVG. Here we choose PNG, and since we want to embed the image
      directly in the SVG stream (and not link to an external image
      file), we need to encode the pixmap into PNG in memory, then
      encode it into base64. */
 
-  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000,
+  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
                         sizeof(unsigned char));
   gl2psConvertPixmapToPNG(pixmap, png);
   gl2psListEncodeBase64(png);
   gl2psPrintf("<image x=\"%g\" y=\"%g\" width=\"%d\" height=\"%d\"\n",
               x, y - pixmap->height, pixmap->width, pixmap->height);
   gl2psPrintf("xlink:href=\"data:image/png;base64,");
   for(i = 0; i < gl2psListNbr(png); i++){
     gl2psListRead(png, i, &c);
@@ -5081,17 +5075,17 @@ static void gl2psPrintSVGPrimitive(void 
     }
     gl2ps->lastvertex = prim->verts[1];
     gl2psSetLastColor(prim->verts[0].rgba);
     gl2ps->lastlinewidth = prim->width;
     gl2ps->lastpattern = prim->pattern;
     gl2ps->lastfactor = prim->factor;
     if(newline){
       gl2psSVGGetColorString(rgba[0], col);
-      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ",
+      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ", 
                   col, prim->width);
       if(rgba[0][3] < 1.0F) gl2psPrintf("stroke-opacity=\"%g\" ", rgba[0][3]);
       gl2psPrintSVGDash(prim->pattern, prim->factor);
       gl2psPrintf("points=\"%g,%g ", xyz[0][0], xyz[0][1]);
     }
     else{
       gl2psPrintf("%g,%g ", xyz[0][0], xyz[0][1]);
     }
@@ -5107,52 +5101,16 @@ static void gl2psPrintSVGPrimitive(void 
     break;
   case GL2PS_TEXT :
     gl2psSVGGetColorString(prim->verts[0].rgba, col);
     gl2psPrintf("<text fill=\"%s\" x=\"%g\" y=\"%g\" font-size=\"%d\" ",
                 col, xyz[0][0], xyz[0][1], prim->data.text->fontsize);
     if(prim->data.text->angle)
       gl2psPrintf("transform=\"rotate(%g, %g, %g)\" ",
                   -prim->data.text->angle, xyz[0][0], xyz[0][1]);
-    switch(prim->data.text->alignment){
-    case GL2PS_TEXT_C:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_CL:
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_CR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_B:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"0\" ");
-      break;
-    case GL2PS_TEXT_BR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"0\" ");
-      break;
-    case GL2PS_TEXT_T:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_TL:
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_TR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_BL:
-    default: /* same as GL2PS_TEXT_BL */
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"0\" ");
-      break;
-    }
     if(!strcmp(prim->data.text->fontname, "Times-Roman"))
       gl2psPrintf("font-family=\"Times\">");
     else if(!strcmp(prim->data.text->fontname, "Times-Bold"))
       gl2psPrintf("font-family=\"Times\" font-weight=\"bold\">");
     else if(!strcmp(prim->data.text->fontname, "Times-Italic"))
       gl2psPrintf("font-family=\"Times\" font-style=\"italic\">");
     else if(!strcmp(prim->data.text->fontname, "Times-BoldItalic"))
       gl2psPrintf("font-family=\"Times\" font-style=\"italic\" font-weight=\"bold\">");
@@ -5181,30 +5139,30 @@ static void gl2psPrintSVGPrimitive(void 
   default :
     break;
   }
 }
 
 static void gl2psPrintSVGFooter(void)
 {
   gl2psPrintf("</g>\n");
-  gl2psPrintf("</svg>\n");
-
+  gl2psPrintf("</svg>\n");  
+  
   gl2psPrintGzipFooter();
 }
 
 static void gl2psPrintSVGBeginViewport(GLint viewport[4])
 {
   GLint index;
   char col[32];
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
 
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintSVGHeader();
     gl2ps->header = GL_FALSE;
   }
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
@@ -5212,28 +5170,28 @@ static void gl2psPrintSVGBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psSVGGetColorString(rgba, col);
-    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                x, gl2ps->viewport[3] - y,
-                x + w, gl2ps->viewport[3] - y,
-                x + w, gl2ps->viewport[3] - (y + h),
+    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col, 
+                x, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - (y + h), 
                 x, gl2ps->viewport[3] - (y + h));
   }
 
   gl2psPrintf("<clipPath id=\"cp%d%d%d%d\">\n", x, y, w, h);
-  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n",
-              x, gl2ps->viewport[3] - y,
-              x + w, gl2ps->viewport[3] - y,
-              x + w, gl2ps->viewport[3] - (y + h),
+  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", 
+              x, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - (y + h), 
               x, gl2ps->viewport[3] - (y + h));
   gl2psPrintf("</clipPath>\n");
   gl2psPrintf("<g clip-path=\"url(#cp%d%d%d%d)\">\n", x, y, w, h);
 }
 
 static GLint gl2psPrintSVGEndViewport(void)
 {
   GLint res;
@@ -5277,17 +5235,17 @@ static void gl2psPrintPGFColor(GL2PSrgba
 }
 
 static void gl2psPrintPGFHeader(void)
 {
   time_t now;
 
   time(&now);
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
@@ -5331,59 +5289,59 @@ static const char *gl2psPGFTextAlignment
   case GL2PS_TEXT_C  : return "center";
   case GL2PS_TEXT_CL : return "west";
   case GL2PS_TEXT_CR : return "east";
   case GL2PS_TEXT_B  : return "south";
   case GL2PS_TEXT_BR : return "south east";
   case GL2PS_TEXT_T  : return "north";
   case GL2PS_TEXT_TL : return "north west";
   case GL2PS_TEXT_TR : return "north east";
-  case GL2PS_TEXT_BL :
+  case GL2PS_TEXT_BL : 
   default            : return "south west";
   }
 }
 
 static void gl2psPrintPGFPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_POINT :
     /* Points in openGL are rectangular */
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}"
             "{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n",
             prim->verts[0].xyz[0]-0.5*prim->width,
             prim->verts[0].xyz[1]-0.5*prim->width,
             prim->width,prim->width);
     break;
   case GL2PS_LINE :
     gl2psPrintPGFColor(prim->verts[0].rgba);
     if(gl2ps->lastlinewidth != prim->width){
       gl2ps->lastlinewidth = prim->width;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{%fpt}\n", gl2ps->lastlinewidth);
     }
     gl2psPrintPGFDash(prim->pattern, prim->factor);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfusepath{stroke}\n",
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
     break;
   case GL2PS_TRIANGLE :
     if(gl2ps->lastlinewidth != 0){
       gl2ps->lastlinewidth = 0;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{0.01pt}\n");
     }
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfpathclose\n"
             "\\pgfusepath{fill,stroke}\n",
             prim->verts[2].xyz[0], prim->verts[2].xyz[1],
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
@@ -5442,24 +5400,24 @@ static void gl2psPrintPGFBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintPGFColor(rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
             "{\\pgfpoint{%dpt}{%dpt}}\n"
             "\\pgfusepath{fill}\n",
             x, y, w, h);
   }
-
-  fprintf(gl2ps->stream,
+  
+  fprintf(gl2ps->stream, 
           "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
           "{\\pgfpoint{%dpt}{%dpt}}\n"
           "\\pgfusepath{clip}\n",
           x, y, w, h);
 }
 
 static GLint gl2psPrintPGFEndViewport(void)
 {
@@ -5481,17 +5439,17 @@ static GL2PSbackend gl2psPGF = {
   gl2psPrintPGFBeginViewport,
   gl2psPrintPGFEndViewport,
   gl2psPrintPGFPrimitive,
   gl2psPrintPGFFinalPrimitive,
   "tex",
   "PGF Latex Graphics"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * General primitive printing routine
  *
  *********************************************************************/
 
 /* Warning: the ordering of the backends must match the format
    #defines in gl2ps.h */
 
@@ -5516,17 +5474,17 @@ static void gl2psComputeTightBoundingBox
       gl2ps->viewport[0] = (GLint)prim->verts[i].xyz[0];
     if(prim->verts[i].xyz[0] > gl2ps->viewport[2])
       gl2ps->viewport[2] = (GLint)(prim->verts[i].xyz[0] + 0.5F);
     if(prim->verts[i].xyz[1] < gl2ps->viewport[1])
       gl2ps->viewport[1] = (GLint)prim->verts[i].xyz[1];
     if(prim->verts[i].xyz[1] > gl2ps->viewport[3])
       gl2ps->viewport[3] = (GLint)(prim->verts[i].xyz[1] + 0.5F);
   }
-}
+}  
 
 static GLint gl2psPrintPrimitives(void)
 {
   GL2PSbsptree *root;
   GL2PSxyz eye = {0.0F, 0.0F, 100.0F * GL2PS_ZSCALE};
   GLint used;
 
   used = glRenderMode(GL_RENDER);
@@ -5537,17 +5495,17 @@ static GLint gl2psPrintPrimitives(void)
   }
 
   if(used > 0)
     gl2psParseFeedbackBuffer(used);
 
   gl2psRescaleAndOffset();
 
   if(gl2ps->header){
-    if(gl2psListNbr(gl2ps->primitives) &&
+    if(gl2psListNbr(gl2ps->primitives) && 
        (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
       gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
       gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
       gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
     }
     (gl2psbackends[gl2ps->format]->printHeader)();
     gl2ps->header = GL_FALSE;
   }
@@ -5579,36 +5537,36 @@ static GLint gl2psPrintPrimitives(void)
     root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
     gl2psBuildBspTree(root, gl2ps->primitives);
     if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
     if(gl2ps->options & GL2PS_OCCLUSION_CULL){
       gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
                            gl2psAddInImageTree, 1);
       gl2psFreeBspImageTree(&gl2ps->imagetree);
     }
-    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater,
+    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
                          gl2psbackends[gl2ps->format]->printPrimitive, 0);
     gl2psFreeBspTree(&root);
     /* reallocate the primitive list (it's been deleted by
        gl2psBuildBspTree) in case there is another viewport */
     gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
     break;
   }
   gl2psbackends[gl2ps->format]->printFinalPrimitive();
 
   return GL2PS_SUCCESS;
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Public routines
  *
  *********************************************************************/
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
                                   GLint colorsize, GL2PSrgba *colormap,
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename)
 {
   GLint index;
   int i;
@@ -5666,17 +5624,17 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   else{
     for(i = 0; i < 4; i++){
       gl2ps->viewport[i] = viewport[i];
     }
   }
 
   if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
     gl2psMsg(GL2PS_ERROR, "Incorrect viewport (x=%d, y=%d, width=%d, height=%d)",
-             gl2ps->viewport[0], gl2ps->viewport[1],
+             gl2ps->viewport[0], gl2ps->viewport[1], 
              gl2ps->viewport[2], gl2ps->viewport[3]);
     gl2psFree(gl2ps);
     gl2ps = NULL;
     return GL2PS_ERROR;
   }
 
   gl2ps->threshold[0] = nr ? 1.0F / (GLfloat)nr : 0.064F;
   gl2ps->threshold[1] = ng ? 1.0F / (GLfloat)ng : 0.034F;
@@ -5690,21 +5648,21 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
     gl2ps->lastvertex.rgba[i] = -1.0F;
     gl2ps->lastrgba[i] = -1.0F;
   }
   gl2ps->lastlinewidth = -1.0F;
   gl2ps->lastpattern = 0;
   gl2ps->lastfactor = 0;
   gl2ps->imagetree = NULL;
   gl2ps->primitivetoadd = NULL;
-  gl2ps->zerosurfacearea = GL_FALSE;
+  gl2ps->zerosurfacearea = GL_FALSE;  
   gl2ps->pdfprimlist = NULL;
   gl2ps->pdfgrouplist = NULL;
   gl2ps->xreflist = NULL;
-
+  
   /* get default blending mode from current OpenGL state (enabled by
      default for SVG) */
   gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
   glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
   glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);
 
   if(gl2ps->colormode == GL_RGBA){
     gl2ps->colorsize = 0;
@@ -5737,55 +5695,55 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   if(!title){
     gl2ps->title = (char*)gl2psMalloc(sizeof(char));
     gl2ps->title[0] = '\0';
   }
   else{
     gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
     strcpy(gl2ps->title, title);
   }
-
+    
   if(!producer){
     gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
     gl2ps->producer[0] = '\0';
   }
   else{
     gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
     strcpy(gl2ps->producer, producer);
   }
-
+  
   if(!filename){
     gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
     gl2ps->filename[0] = '\0';
   }
   else{
     gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
     strcpy(gl2ps->filename, filename);
   }
 
   gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
   gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
   glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
-  glRenderMode(GL_FEEDBACK);
+  glRenderMode(GL_FEEDBACK);  
 
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndPage(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   res = gl2psPrintPrimitives();
 
   if(res != GL2PS_OVERFLOW)
     (gl2psbackends[gl2ps->format]->printFooter)();
-
+  
   fflush(gl2ps->stream);
 
   gl2psListDelete(gl2ps->primitives);
   gl2psListDelete(gl2ps->auxprimitives);
   gl2psFreeImagemap(gl2ps->imagemap_head);
   gl2psFree(gl2ps->colormap);
   gl2psFree(gl2ps->title);
   gl2psFree(gl2ps->producer);
@@ -5797,17 +5755,17 @@ GL2PSDLL_API GLint gl2psEndPage(void)
   return res;
 }
 
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
-
+  
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndViewport(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
@@ -5815,17 +5773,17 @@ GL2PSDLL_API GLint gl2psEndViewport(void
   res = (gl2psbackends[gl2ps->format]->endViewport)();
 
   /* reset last used colors, line widths */
   gl2ps->lastlinewidth = -1.0F;
 
   return res;
 }
 
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
                                 GLshort fontsize, GLint alignment, GLfloat angle)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle);
 }
 
 GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0.0F);
@@ -5833,21 +5791,21 @@ GL2PSDLL_API GLint gl2psText(const char 
 
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)
 {
   return gl2psAddText(GL2PS_SPECIAL, str, "", 0, format, 0.0F);
 }
 
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
-                                   GLenum format, GLenum type,
+                                   GLenum format, GLenum type, 
                                    const void *pixels)
 {
   int size, i;
-  GLfloat pos[4], *piv, zoom_x, zoom_y;
+  GLfloat pos[4], *piv;
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;
 
   if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
 
   if(gl2ps->options & GL2PS_NO_PIXMAP) return GL2PS_SUCCESS;
@@ -5857,18 +5815,16 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
              "GL_RGB/GL_RGBA, GL_FLOAT pixels");
     return GL2PS_ERROR;
   }
 
   glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
   if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
 
   glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
-  glGetFloatv(GL_ZOOM_X, &zoom_x);
-  glGetFloatv(GL_ZOOM_Y, &zoom_y);
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   prim->type = GL2PS_PIXMAP;
   prim->boundary = 0;
   prim->numverts = 1;
   prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
   prim->verts[0].xyz[0] = pos[0] + xorig;
   prim->verts[0].xyz[1] = pos[1] + yorig;
@@ -5877,34 +5833,32 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
   prim->offset = 0;
   prim->pattern = 0;
   prim->factor = 0;
   prim->width = 1;
   glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
   prim->data.image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
   prim->data.image->width = width;
   prim->data.image->height = height;
-  prim->data.image->zoom_x = zoom_x;
-  prim->data.image->zoom_y = zoom_y;
   prim->data.image->format = format;
   prim->data.image->type = type;
 
   switch(format){
   case GL_RGBA:
     if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
       /* special case: blending turned off */
       prim->data.image->format = GL_RGB;
       size = height * width * 3;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       piv = (GLfloat*)pixels;
       for(i = 0; i < size; ++i, ++piv){
         prim->data.image->pixels[i] = *piv;
-        if(!((i + 1) % 3))
+        if(!((i+1)%3))
           ++piv;
-      }
+      }   
     }
     else{
       size = height * width * 4;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
     }
     break;
   case GL_RGB:
@@ -5921,21 +5875,21 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
                                      const GLfloat position[3],
                                      const unsigned char *imagemap){
   int size, i;
   int sizeoffloat = sizeof(GLfloat);
-
+  
   if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;
 
   if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
-
+  
   size = height + height * ((width - 1) / 8);
   glPassThrough(GL2PS_IMAGEMAP_TOKEN);
   glBegin(GL_POINTS);
   glVertex3f(position[0], position[1],position[2]);
   glEnd();
   glPassThrough((GLfloat)width);
   glPassThrough((GLfloat)height);
   for(i = 0; i < size; i += sizeoffloat){
@@ -6005,17 +5959,17 @@ GL2PSDLL_API GLint gl2psDisable(GLint mo
 }
 
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_POINT_SIZE_TOKEN);
   glPassThrough(value);
-
+  
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
diff --git a/src/gl2ps.h b/src/gl2ps.h
--- a/src/gl2ps.h
+++ b/src/gl2ps.h
@@ -134,19 +134,19 @@
 /* Arguments for gl2psEnable/gl2psDisable */
 
 #define GL2PS_POLYGON_OFFSET_FILL 1
 #define GL2PS_POLYGON_BOUNDARY    2
 #define GL2PS_LINE_STIPPLE        3
 #define GL2PS_BLEND               4
 
 /* Text alignment (o=raster position; default mode is BL):
-   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o
-   | o | o   | |   o |   | |   | |   | |   | |   | |   |
-   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+
+   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o 
+   | o | o   | |   o |   | |   | |   | |   | |   | |   | 
+   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+ 
     C     CL    CR    B     BL    BR    T     TL    TR */
 
 #define GL2PS_TEXT_C  1
 #define GL2PS_TEXT_CL 2
 #define GL2PS_TEXT_CR 3
 #define GL2PS_TEXT_B  4
 #define GL2PS_TEXT_BL 5
 #define GL2PS_TEXT_BR 6
@@ -155,30 +155,30 @@
 #define GL2PS_TEXT_TR 9
 
 typedef GLfloat GL2PSrgba[4];
 
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
-                                  GLint colorsize, GL2PSrgba *colormap,
+                                  GLint colorsize, GL2PSrgba *colormap, 
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename);
 GL2PSDLL_API GLint gl2psEndPage(void);
 GL2PSDLL_API GLint gl2psSetOptions(GLint options);
 GL2PSDLL_API GLint gl2psGetOptions(GLint *options);
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4]);
 GL2PSDLL_API GLint gl2psEndViewport(void);
-GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, 
                              GLshort fontsize);
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
                                 GLshort fontsize, GLint align, GLfloat angle);
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str);
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
                                    GLenum format, GLenum type, const void *pixels);
 GL2PSDLL_API GLint gl2psEnable(GLint mode);
 GL2PSDLL_API GLint gl2psDisable(GLint mode);
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -4336,17 +4336,17 @@ void
 axes::properties::update_xlabel_position (void)
 {
   if (updating_xlabel_position)
     return;
 
   text::properties& xlabel_props = reinterpret_cast<text::properties&>
     (gh_manager::get_object (get_xlabel ()).get_properties ());
 
-  bool is_empty = xlabel_props.get_string ().empty ();
+  bool is_empty = xlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_xlabel_position);
   updating_xlabel_position = true;
 
   if (! is_empty)
     {
       if (xlabel_props.horizontalalignmentmode_is ("auto"))
@@ -4427,17 +4427,17 @@ void
 axes::properties::update_ylabel_position (void)
 {
   if (updating_ylabel_position)
     return;
 
   text::properties& ylabel_props = reinterpret_cast<text::properties&>
     (gh_manager::get_object (get_ylabel ()).get_properties ());
 
-  bool is_empty = ylabel_props.get_string ().empty ();
+  bool is_empty = ylabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
   if (! is_empty)
     {
       if (ylabel_props.horizontalalignmentmode_is ("auto"))
@@ -4519,17 +4519,17 @@ axes::properties::update_zlabel_position
 {
   if (updating_zlabel_position)
     return;
 
   text::properties& zlabel_props = reinterpret_cast<text::properties&>
     (gh_manager::get_object (get_zlabel ()).get_properties ());
 
   bool camAuto = cameraupvectormode_is ("auto");
-  bool is_empty = zlabel_props.get_string ().empty ();
+  bool is_empty = zlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_zlabel_position);
   updating_zlabel_position = true;
 
   if (! is_empty)
     {
       if (zlabel_props.horizontalalignmentmode_is ("auto"))
@@ -4891,17 +4891,17 @@ axes::properties::get_extent (bool with_
           else if (i == 3)
             text_handle = get_zlabel ();
 
           text::properties& text_props = reinterpret_cast<text::properties&>
             (gh_manager::get_object (text_handle).get_properties ());
 
           Matrix text_pos = text_props.get_position ().matrix_value ();
           text_pos = xform.transform (text_pos(0), text_pos(1), text_pos(2));
-          if (text_props.get_string ().empty ())
+          if (text_props.get_string ().is_empty ())
             {
               ext(0) = std::min (ext(0), text_pos(0));
               ext(1) = std::min (ext(1), text_pos(1));
               ext(2) = std::max (ext(2), text_pos(0));
               ext(3) = std::max (ext(3), text_pos(1));
             }
           else
             {
@@ -6001,36 +6001,43 @@ text::properties::update_font (void)
   renderer.set_color (get_color_rgb ());
 #endif
 }
 
 void
 text::properties::update_text_extent (void)
 {
 #ifdef HAVE_FREETYPE
+
   int halign = 0, valign = 0;
 
   if (horizontalalignment_is ("center"))
     halign = 1;
   else if (horizontalalignment_is ("right"))
     halign = 2;
 
   if (verticalalignment_is ("top"))
     valign = 2;
   else if (verticalalignment_is ("baseline"))
     valign = 3;
   else if (verticalalignment_is ("middle"))
     valign = 1;
 
   Matrix bbox;
+
   // FIXME: string should be parsed only when modified, for efficiency
-  renderer.text_to_pixels (get_string (), pixels, bbox,
+
+  octave_value string_prop = get_string ();
+
+  string_vector sv = string_prop.all_strings ();
+
+  renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
                            halign, valign, get_rotation ());
-
   set_extent (bbox);
+
 #endif
 
   if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
       autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
     update_autopos ("sync");
 }
 
 void
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <cctype>
 
 #include <algorithm>
 #include <list>
 #include <map>
 #include <set>
+#include <sstream>
 #include <string>
 
 #include "caseless-str.h"
 #include "lo-ieee.h"
 
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
@@ -687,16 +688,188 @@ protected:
 private:
   desired_enum desired_type;
   char separator;
   string_vector str;
 };
 
 // ---------------------------------------------------------------------
 
+class text_label_property : public base_property
+{
+public:
+  enum type { char_t, cellstr_t };
+
+  text_label_property (const std::string& s, const graphics_handle& h,
+                       const std::string& val = "")
+    : base_property (s, h), value (val), stored_type (char_t)
+  { }
+
+  text_label_property (const std::string& s, const graphics_handle& h,
+                       const NDArray& nda)
+    : base_property (s, h), stored_type (char_t)
+  {
+    octave_idx_type nel = nda.numel ();
+
+    value.resize (nel);
+
+    for (octave_idx_type i = 0; i < nel; i++)
+      {
+        std::ostringstream buf;
+        buf << nda(i);
+        value[i] = buf.str ();
+      }
+  }
+
+  text_label_property (const std::string& s, const graphics_handle& h,
+                       const Cell& c)
+    : base_property (s, h), stored_type (cellstr_t)
+  {
+    octave_idx_type nel = c.numel ();
+
+    value.resize (nel);
+
+    for (octave_idx_type i = 0; i < nel; i++)
+      {
+        octave_value tmp = c(i);
+
+        if (tmp.is_string ())
+          value[i] = c(i).string_value ();
+        else
+          {
+            double d = c(i).double_value ();
+
+            if (! error_state)
+              {
+                std::ostringstream buf;
+                buf << d;
+                value[i] = buf.str ();
+              }
+            else
+              break;
+          }
+      }
+  }
+
+  text_label_property (const text_label_property& p)
+    : base_property (p), value (p.value), stored_type (p.stored_type)
+  { }
+
+  bool empty (void) const
+  {
+    octave_value tmp = get ();
+    return tmp.is_empty ();
+  }
+
+  octave_value get (void) const
+  {
+    if (stored_type == char_t)
+      return octave_value (char_value ());
+    else
+      return octave_value (cell_value ());
+  }
+
+  std::string string_value (void) const
+  {
+    return value.empty () ? std::string () : value[0];
+  }
+
+  string_vector string_vector_value (void) const { return value; }
+
+  charMatrix char_value (void) const { return charMatrix (value, ' '); }
+
+  Cell cell_value (void) const {return Cell (value); }
+
+  text_label_property& operator = (const octave_value& val)
+  {
+    set (val);
+    return *this;
+  }
+
+  base_property* clone (void) const { return new text_label_property (*this); }
+
+protected:
+
+  bool do_set (const octave_value& val)
+  {
+    if (val.is_string ())
+      {
+        value = val.all_strings ();
+
+        stored_type = char_t;
+      }
+    else if (val.is_cell ())
+      {
+        Cell c = val.cell_value ();
+
+        octave_idx_type nel = c.numel ();
+
+        value.resize (nel);
+
+        for (octave_idx_type i = 0; i < nel; i++)
+          {
+            octave_value tmp = c(i);
+
+            if (tmp.is_string ())
+              value[i] = c(i).string_value ();
+            else
+              {
+                double d = c(i).double_value ();
+
+                if (! error_state)
+                  {
+                    std::ostringstream buf;
+                    buf << d;
+                    value[i] = buf.str ();
+                  }
+                else
+                  return false;
+              }
+          }
+
+        stored_type = cellstr_t;
+      }
+    else
+      {
+        NDArray nda = val.array_value ();
+
+        if (! error_state)
+          {
+            octave_idx_type nel = nda.numel ();
+
+            value.resize (nel);
+
+            for (octave_idx_type i = 0; i < nel; i++)
+              {
+                std::ostringstream buf;
+                buf << nda(i);
+                value[i] = buf.str ();
+              }
+
+            stored_type = char_t;
+          }
+        else
+          {
+            error ("set: invalid string property value for \"%s\"",
+                   get_name ().c_str ());
+
+            return false;
+          }
+      }
+
+    return true;
+  }
+
+private:
+  string_vector value;
+  type stored_type;
+};
+
+// ---------------------------------------------------------------------
+
 class radio_values
 {
 public:
   OCTINTERP_API radio_values (const std::string& opt_string = std::string ());
 
   radio_values (const radio_values& a)
     : default_val (a.default_val), possible_vals (a.possible_vals) { }
 
@@ -3681,17 +3854,17 @@ class OCTINTERP_API text : public base_g
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (text)
-      string_property string u , ""
+      text_label_property string u , ""
       radio_property units u , "{data}|pixels|normalized|inches|centimeters|points"
       array_property position mu , Matrix (1, 3, 0.0)
       double_property rotation mu , 0
       radio_property horizontalalignment mu , "{left}|center|right"
       color_property color u , color_values (0, 0, 0)
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontangle u , "{normal}|italic|oblique"
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -423,17 +423,17 @@ octave_read (char *buf, unsigned max_siz
 // warning if the file doesn't exist.
 
 FILE *
 get_input_from_file (const std::string& name, int warn)
 {
   FILE *instream = 0;
 
   if (name.length () > 0)
-    instream = fopen (name.c_str (), "rb");
+    instream = gnulib::fopen (name.c_str (), "rb");
 
   if (! instream && warn)
     warning ("%s: no such file or directory", name.c_str ());
 
   if (reading_fcn_file || reading_script_file || reading_classdef_file)
     ff_instream = instream;
   else
     command_editor::set_input_stream (instream);
@@ -946,36 +946,32 @@ do_keyboard (const octave_value_list& ar
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
   unwind_protect frame;
 
-  // FIXME -- we shouldn't need both the
-  // command_history object and the
-  // Vsaving_history variable...
+  frame.add_fcn (command_history::ignore_entries,
+                 command_history::ignoring_entries ());
+
   command_history::ignore_entries (false);
 
-  frame.add_fcn (command_history::ignore_entries, ! Vsaving_history);
-
-  frame.protect_var (Vsaving_history);
   frame.protect_var (Vdebugging);
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
   // FIXME -- probably we just want to print one line, not the
   // entire statement, which might span many lines...
   //
   // tree_print_code tpc (octave_stdout);
   // stmt.accept (tpc);
 
-  Vsaving_history = true;
   Vdebugging = true;
 
   std::string prompt = "debug> ";
   if (nargin > 0)
     prompt = args(0).string_value ();
 
   if (! error_state)
     get_debug_input (prompt);
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -83,19 +83,16 @@ default_history_file (void)
 
   if (file.empty ())
     file = file_ops::concat (octave_env::get_home_directory (),
                              ".octave_hist");
 
   return file;
 }
 
-// Where history is saved.
-static std::string Vhistory_file = default_history_file ();
-
 static int
 default_history_size (void)
 {
   int size = 1024;
 
   std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
@@ -104,67 +101,47 @@ default_history_size (void)
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
         size = val > 0 ? val : 0;
     }
 
   return size;
 }
 
-// The number of lines to keep in the history file.
-static int Vhistory_size = default_history_size ();
-
-static std::string
-default_history_control (void)
-{
-  std::string retval;
-
-  std::string env_histcontrol = octave_env::getenv ("OCTAVE_HISTCONTROL");
-
-  if (! env_histcontrol.empty ())
-    {
-      return env_histcontrol;
-    }
-
-  return retval;
-}
-
-// The number of lines to keep in the history file.
-static std::string Vhistory_control = default_history_control ();
-
 static std::string
 default_history_timestamp_format (void)
 {
   return
     std::string ("# Octave " OCTAVE_VERSION ", %a %b %d %H:%M:%S %Y %Z <")
     + octave_env::get_user_name ()
     + std::string ("@")
     + octave_env::get_host_name ()
     + std::string (">");
 }
 
 // The format of the timestamp marker written to the history file when
 // Octave exits.
 static std::string Vhistory_timestamp_format_string
   = default_history_timestamp_format ();
 
-// TRUE if we are saving history.
-bool Vsaving_history = true;
-
 // Display, save, or load history.  Stolen and modified from bash.
 //
 // Arg of -w FILENAME means write file, arg of -r FILENAME
 // means read file, arg of -q means don't number lines.  Arg of N
 // means only display that many items.
 
 static void
 do_history (int argc, const string_vector& argv)
 {
   int numbered_output = 1;
 
+  unwind_protect frame;
+
+  frame.add_fcn (command_history::set_file, command_history::file ());
+
   int i;
   for (i = 1; i < argc; i++)
     {
       std::string option = argv[i];
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
@@ -532,18 +509,20 @@ do_run_history (int argc, const string_v
   input_from_tmp_history_file = true;
 
   source_file (name);
 }
 
 void
 initialize_history (bool read_history_file)
 {
-  command_history::initialize (read_history_file, Vhistory_file, Vhistory_size,
-                               Vhistory_control);
+  command_history::initialize (read_history_file,
+                               default_history_file (),
+                               default_history_size (),
+                               octave_env::getenv ("OCTAVE_HISTCONTROL"));
 }
 
 void
 octave_history_write_timestamp (void)
 {
   octave_localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
@@ -686,64 +665,72 @@ A value of @code{ignoreboth} is shorthan
 @code{ignoredups}.  A value of @code{erasedups} causes all previous lines\n\
 matching the current line to be removed from the history list before that\n\
 line is saved.  Any value not in the above list is ignored.  If\n\
 @code{history_control} is the empty string, all commands are saved on\n\
 the history list, subject to the value of @code{saving_history}.\n\
 @seealso{history_file, history_size, history_timestamp_format_string, saving_history}\n\
 @end deftypefn")
 {
-  std::string saved_history_control = Vhistory_control;
+  std::string old_history_control = command_history::histcontrol ();
+
+  std::string tmp = old_history_control;
 
-  octave_value retval = SET_INTERNAL_VARIABLE (history_control);
+  octave_value retval = set_internal_variable (tmp, args, nargout,
+                                               "history_control");
 
-  if (Vhistory_control != saved_history_control)
-    command_history::process_histcontrol (Vhistory_control);
+  if (tmp != old_history_control)
+    command_history::process_histcontrol (tmp);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
 to store in the history file.  The default value is @code{1024},\n\
 but may be overridden by the environment variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, saving_history}\n\
 @end deftypefn")
 {
-  int saved_history_size = Vhistory_size;
+  int old_history_size = command_history::size ();
+
+  int tmp = old_history_size;
 
-  octave_value retval
-    = SET_INTERNAL_VARIABLE_WITH_LIMITS (history_size, -1, INT_MAX);
+  octave_value retval = set_internal_variable (tmp, args, nargout,
+                                               "history_size", -1, INT_MAX);
 
-  if (Vhistory_size != saved_history_size)
-    command_history::set_size (Vhistory_size);
+  if (tmp != old_history_size)
+    command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 file used to store command history.  The default value is\n\
 @file{~/.octave_hist}, but may be overridden by the environment\n\
 variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, saving_history, history_timestamp_format_string}\n\
 @end deftypefn")
 {
-  std::string saved_history_file = Vhistory_file;
+  std::string old_history_file = command_history::file ();
+
+  std::string tmp = old_history_file;
 
-  octave_value retval = SET_INTERNAL_VARIABLE (history_file);
+  octave_value retval = set_internal_variable (tmp, args, nargout,
+                                               "history_file");
 
-  if (Vhistory_file != saved_history_file)
-    command_history::set_file (Vhistory_file);
+  if (tmp != old_history_file)
+    command_history::set_file (tmp);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
@@ -765,14 +752,20 @@ DEFUN (saving_history, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} saving_history ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} saving_history (@var{new_val})\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
 @seealso{history_control, history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
 {
-  octave_value retval = SET_INTERNAL_VARIABLE (saving_history);
+  bool old_saving_history = ! command_history::ignoring_entries ();
+
+  bool tmp = old_saving_history;
 
-  command_history::ignore_entries (! Vsaving_history);
+  octave_value retval = set_internal_variable (tmp, args, nargout,
+                                               "saving_history");
+
+  if (tmp != old_saving_history)
+    command_history::ignore_entries (! tmp);
 
   return retval;
 }
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -30,12 +30,9 @@ along with Octave; see the file COPYING.
 extern void initialize_history (bool read_history_file = false);
 
 // Write timestamp to history file.
 extern void octave_history_write_timestamp (void);
 
 // TRUE means input is coming from temporary history file.
 extern bool input_from_tmp_history_file;
 
-// TRUE if we are saving history.
-extern bool Vsaving_history;
-
 #endif
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -3466,28 +3466,21 @@ parse_fcn_file (const std::string& ff, c
   reading_fcn_file = true;
   line_editing = false;
   current_class_name = dispatch_type;
   current_function_depth = 0;
   max_function_depth = 0;
   parsing_subfunctions = false;
   endfunction_found = false;
 
-  // The next four lines must be in this order.
-  frame.add_fcn (command_history::ignore_entries, ! Vsaving_history);
-
-  // FIXME -- we shouldn't need both the
-  // command_history object and the
-  // Vsaving_history variable...
+  frame.add_fcn (command_history::ignore_entries,
+                 command_history::ignoring_entries ());
+
   command_history::ignore_entries ();
 
-  frame.protect_var (Vsaving_history);
-
-  Vsaving_history = false;
-
   FILE *ffile = get_input_from_file (ff, 0);
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
@@ -4210,22 +4203,36 @@ are passed on to the named function.  Fo
 feval (\"acos\", -1)\n\
      @result{} 3.1416\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 calls the function @code{acos} with the argument @samp{-1}.\n\
 \n\
-The function @code{feval} is necessary in order to be able to write\n\
-functions that call user-supplied functions, because Octave does not\n\
-have a way to declare a pointer to a function (like C) or to declare a\n\
-special kind of variable that can be used to hold the name of a function\n\
-(like @code{EXTERNAL} in Fortran).  Instead, you must refer to functions\n\
-by name, and use @code{feval} to call them.\n\
+The function @code{feval} can also be used with function handles of\n\
+any sort (@pxref{Function Handles}).  Historically, @code{feval} was\n\
+the only way to call user-supplied functions in strings, but\n\
+function handles are now preferred due to the cleaner syntax they\n\
+offer.  For example,\n\
+\n\
+@example\n\
+@group\n\
+@var{f} = @@exp;\n\
+feval (@var{f}, 1)\n\
+     @result{} 2.7183\n\
+@var{f} (1)\n\
+     @result{} 2.7183\n\
+@end group\n\
+@end example\n\
+\n\
+@noindent\n\
+are equivalent ways to call the function referred to by @var{f}.  If it\n\
+cannot be predicted beforehand that @var{f} is a function handle or the\n\
+function name in a string, @code{feval} can be used instead.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     retval = feval (args, nargout);
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1374,17 +1374,19 @@ do_scanf_conv (std::istream&, const scan
  \
   int c = EOF; \
   int n = 0; \
  \
   while (is && n < width && (c = is.get ()) != EOF) \
     tmp[n++] = static_cast<char> (c); \
  \
   if (n > 0 && c == EOF) \
-    is.clear ()
+    is.clear (); \
+ \
+  tmp.resize (n)
 
 // For a `%s' format, skip initial whitespace and then read until the
 // next whitespace character or until WIDTH characters have been read.
 #define BEGIN_S_CONVERSION() \
   int width = elt->width; \
  \
   std::string tmp; \
  \
@@ -2855,48 +2857,70 @@ int
 octave_stream::seek (long offset, int origin)
 {
   int status = -1;
 
   if (stream_ok ())
     {
       clearerr ();
 
+      // Find current position so we can return to it if needed.
+
       long orig_pos = rep->tell ();
 
-      status = rep->seek (offset, origin);
+      // Move to end of file.  If successful, find the offset of the end.
+
+      status = rep->seek (0, SEEK_END);
 
       if (status == 0)
         {
-          long save_pos = rep->tell ();
-
-          rep->seek (0, SEEK_END);
-
-          long pos_eof = rep->tell ();
-
-          // I don't think save_pos can be less than zero, but we'll
-          // check anyway...
-
-          if (save_pos > pos_eof || save_pos < 0)
+          long eof_pos = rep->tell ();
+
+          if (origin == SEEK_CUR)
+            {
+              // Move back to original position, otherwise we will be
+              // seeking from the end of file which is probably not the
+              // original location.
+
+              rep->seek (orig_pos, SEEK_SET);
+            }
+
+          // Attempt to move to desired position; may be outside bounds
+          // of existing file.
+
+          status = rep->seek (offset, origin);
+
+          if (status == 0)
             {
-              // Seek outside bounds of file.  Failure should leave
-              // position unchanged.
+              // Where are we after moving to desired position?
+
+              long desired_pos = rep->tell ();
+
+              // I don't think save_pos can be less than zero, but we'll
+              // check anyway...
+
+              if (desired_pos > eof_pos || desired_pos < 0)
+                {
+                  // Seek outside bounds of file.  Failure should leave
+                  // position unchanged.
+
+                  rep->seek (orig_pos, SEEK_SET);
+
+                  status = -1;
+                }
+            }
+          else
+            {
+              // Seeking to the desired position failed.  Move back to
+              // original position and return failure status.
 
               rep->seek (orig_pos, SEEK_SET);
 
               status = -1;
             }
-          else
-            {
-              // Is it possible for this to fail?  We are just
-              // returning to a position after the first successful
-              // seek.
-
-              rep->seek (save_pos, SEEK_SET);
-            }
         }
     }
 
   return status;
 }
 
 int
 octave_stream::seek (const octave_value& tc_offset,
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -121,30 +121,32 @@ octave_builtin::do_multi_index_op (int n
       if (lvalue_list || curr_lvalue_list)
         {
           frame.protect_var (curr_lvalue_list);
           curr_lvalue_list = lvalue_list;
         }
 
       try
         {
-          profile_data_accumulator::enter pe (profiler, profiler_name ());
+          BEGIN_PROFILER_BLOCK (profiler_name ())
 
           retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
           // Fix the case of a single undefined value.
           // This happens when a compiled function uses
           //   octave_value retval;
           // instead of
           //   octave_value_list retval;
           // the idiom is very common, so we solve that here.
           if (retval.length () == 1 && retval.xelem (0).is_undefined ())
             retval.clear ();
+
+          END_PROFILER_BLOCK
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
         }
     }
 
   return retval;
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -143,18 +143,19 @@ octave_mex_function::do_multi_index_op (
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
       try
         {
-          profile_data_accumulator::enter pe (profiler, profiler_name ());
+          BEGIN_PROFILER_BLOCK (profiler_name ())
           retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+          END_PROFILER_BLOCK
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
         }
     }
 
   return retval;
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -129,21 +129,19 @@ octave_user_script::do_multi_index_op (i
                 {
                   octave_call_stack::push (this);
 
                   frame.add_fcn (octave_call_stack::pop);
 
                   frame.protect_var (tree_evaluator::statement_context);
                   tree_evaluator::statement_context = tree_evaluator::script;
 
-                  {
-                    profile_data_accumulator::enter pe (profiler,
-                                                        profiler_name ());
-                    cmd_list->accept (*current_evaluator);
-                  }
+                  BEGIN_PROFILER_BLOCK (profiler_name ())
+                  cmd_list->accept (*current_evaluator);
+                  END_PROFILER_BLOCK
 
                   if (tree_return_command::returning)
                     tree_return_command::returning = 0;
 
                   if (tree_break_command::breaking)
                     tree_break_command::breaking--;
 
                   if (error_state)
@@ -450,36 +448,36 @@ octave_user_function::do_multi_index_op 
   // Evaluate the commands that make up the function.
 
   frame.protect_var (tree_evaluator::statement_context);
   tree_evaluator::statement_context = tree_evaluator::function;
 
   bool special_expr = (is_inline_function ()
                        || cmd_list->is_anon_function_body ());
 
-  {
-    profile_data_accumulator::enter pe (profiler, profiler_name ());
+  BEGIN_PROFILER_BLOCK (profiler_name ())
 
-    if (special_expr)
-      {
-        assert (cmd_list->length () == 1);
+  if (special_expr)
+    {
+      assert (cmd_list->length () == 1);
 
-        tree_statement *stmt = 0;
+      tree_statement *stmt = 0;
 
-        if ((stmt = cmd_list->front ())
-            && stmt->is_expression ())
-          {
-            tree_expression *expr = stmt->expression ();
+      if ((stmt = cmd_list->front ())
+          && stmt->is_expression ())
+        {
+          tree_expression *expr = stmt->expression ();
 
-            retval = expr->rvalue (nargout);
-          }
-      }
-    else
-      cmd_list->accept (*current_evaluator);
-  }
+          retval = expr->rvalue (nargout);
+        }
+    }
+  else
+    cmd_list->accept (*current_evaluator);
+
+  END_PROFILER_BLOCK
 
   if (echo_commands)
     print_code_function_trailer ();
 
   if (tree_return_command::returning)
     tree_return_command::returning = 0;
 
   if (tree_break_command::breaking)
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -19,16 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <cstddef>
 #include <iostream>
 
 #include "defun.h"
 #include "oct-time.h"
 #include "ov-struct.h"
 #include "pager.h"
 #include "profiler.h"
 
@@ -51,200 +52,312 @@ profile_data_accumulator::enter::~enter 
     acc.exit_function (fcn);
 }
 
 profile_data_accumulator::stats::stats ()
   : time (0.0), calls (0), recursive (false),
     parents (), children ()
 {}
 
-// With the help of a mapping name -> index, convert a function_set list
-// to an Octave array of indices.
 octave_value
-profile_data_accumulator::stats::function_set_value (const function_set& list,
-                                                     const fcn_index_map& idx)
+profile_data_accumulator::stats::function_set_value (const function_set& list)
 {
   const octave_idx_type n = list.size ();
 
   RowVector retval (n);
   octave_idx_type i = 0;
   for (function_set::const_iterator p = list.begin (); p != list.end (); ++p)
     {
-      fcn_index_map::const_iterator q = idx.find (*p);
-      assert (q != idx.end ());
-      retval (i) = q->second;
+      retval(i) = *p;
       ++i;
     }
   assert (i == n);
 
   return retval;
 }
 
+profile_data_accumulator::tree_node::tree_node (tree_node* p, octave_idx_type f)
+  : parent (p), fcn_id (f), children (), time (0.0), calls (0)
+{}
+
+profile_data_accumulator::tree_node::~tree_node ()
+{
+  for (child_map::iterator i = children.begin (); i != children.end (); ++i)
+    delete i->second;
+}
+
+profile_data_accumulator::tree_node*
+profile_data_accumulator::tree_node::enter (octave_idx_type fcn)
+{
+  tree_node* retval;
+
+  child_map::iterator pos = children.find (fcn);
+  if (pos == children.end ())
+    {
+      retval = new tree_node (this, fcn);
+      children[fcn] = retval;
+    }
+  else
+    retval = pos->second;
+
+  ++retval->calls;
+  return retval;
+}
+
+profile_data_accumulator::tree_node*
+profile_data_accumulator::tree_node::exit (octave_idx_type fcn)
+{
+  assert (parent);
+  assert (fcn_id == fcn);
+
+  return parent;
+}
+
+void
+profile_data_accumulator::tree_node::build_flat (flat_profile& data) const
+{
+  // If this is not the top-level node, update profile entry for this function.
+  if (fcn_id != 0)
+    {
+      stats& entry = data[fcn_id - 1];
+      
+      entry.time += time;
+      entry.calls += calls;
+
+      assert (parent);
+      if (parent->fcn_id != 0)
+        {
+          entry.parents.insert (parent->fcn_id);
+          data[parent->fcn_id - 1].children.insert (fcn_id);
+        }
+
+      if (!entry.recursive)
+        for (const tree_node* i = parent; i; i = i->parent)
+          if (i->fcn_id == fcn_id)
+            {
+              entry.recursive = true;
+              break;
+            }
+    }
+
+  // Recurse on children.
+  for (child_map::const_iterator i = children.begin ();
+       i != children.end (); ++i)
+    i->second->build_flat (data);
+}
+
+octave_value
+profile_data_accumulator::tree_node::get_hierarchical (void) const
+{
+  /* Note that we don't generate the entry just for this node, but rather
+     a struct-array with entries for all children.  This way, the top-node
+     (for which we don't want a real entry) generates already the final
+     hierarchical profile data.  */
+
+  const octave_idx_type n = children.size ();
+
+  Cell rv_indices (n, 1);
+  Cell rv_times (n, 1);
+  Cell rv_calls (n, 1);
+  Cell rv_children (n, 1);
+
+  octave_idx_type i = 0;
+  for (child_map::const_iterator p = children.begin ();
+       p != children.end (); ++p)
+    {
+      const tree_node& entry = *p->second;
+
+      rv_indices(i) = octave_value (p->first);
+      rv_times(i) = octave_value (entry.time);
+      rv_calls(i) = octave_value (entry.calls);
+      rv_children(i) = entry.get_hierarchical ();
+
+      ++i;
+    }
+  assert (i == n);
+
+  Octave_map retval;
+
+  retval.assign ("Index", rv_indices);
+  retval.assign ("SelfTime", rv_times);
+  retval.assign ("NumCalls", rv_calls);
+  retval.assign ("Children", rv_children);
+
+  return retval;
+}
+
 profile_data_accumulator::profile_data_accumulator ()
-  : enabled (false), call_stack (), data (), last_time (-1.0)
+  : known_functions (), fcn_index (),
+    enabled (false), call_tree (NULL), last_time (-1.0)
 {}
 
+profile_data_accumulator::~profile_data_accumulator ()
+{
+  if (call_tree)
+    delete call_tree;
+}
+
 void
 profile_data_accumulator::set_active (bool value)
 {
-  // If we enable, clear the call-stack.  This ensures we freshly start
-  // with collecting times now.
   if (value)
     {
-      while (!call_stack.empty ())
-        call_stack.pop_back ();
+      // Create a call-tree top-node if there isn't yet one.
+      if (!call_tree)
+        call_tree = new tree_node (NULL, 0);
+
+      // Let the top-node be the active one.  This ensures we have a clean
+      // fresh start collecting times.
+      active_fcn = call_tree;
+    }
+  else
+    {
+      // Make sure we start with fresh timing if we're re-enabled later.
+      last_time = -1.0;
     }
 
   enabled = value;
 }
 
 void
 profile_data_accumulator::enter_function (const std::string& fcn)
 {
   // The enter class will check and only call us if the profiler is active.
   assert (is_active ());
+  assert (call_tree);
 
   // If there is already an active function, add to its time before
   // pushing the new one.
-  if (!call_stack.empty ())
+  if (active_fcn != call_tree)
     add_current_time ();
 
-  // Update non-timing related data for the function entered.
-  stats& entry = data[fcn];
-  ++entry.calls;
-  if (!call_stack.empty ())
+  // Map the function's name to its index.
+  octave_idx_type fcn_idx;
+  fcn_index_map::iterator pos = fcn_index.find (fcn);
+  if (pos == fcn_index.end ())
     {
-      const std::string parent_name = call_stack.back ();
-      entry.parents.insert (parent_name);
-      data[parent_name].children.insert (fcn);
+      known_functions.push_back (fcn);
+      fcn_idx = known_functions.size ();
+      fcn_index[fcn] = fcn_idx;
     }
-  if (!entry.recursive)
-    for (call_stack_type::iterator i = call_stack.begin ();
-         i != call_stack.end (); ++i)
-      if (*i == fcn)
-        {
-          entry.recursive = true;
-          break;
-        }
+  else
+    fcn_idx = pos->second;
 
-  call_stack.push_back (fcn);
+  active_fcn = active_fcn->enter (fcn_idx);
   last_time = query_time ();
 }
 
 void
 profile_data_accumulator::exit_function (const std::string& fcn)
 {
-  assert (!call_stack.empty ());
-  assert (fcn == call_stack.back ());
+  assert (call_tree);
+  assert (active_fcn != call_tree);
 
   // Usually, if we are disabled this function is not even called.  But the
   // call disabling the profiler is an exception.  So also check here
   // and only record the time if enabled.
   if (is_active ())
     add_current_time ();
 
-  call_stack.pop_back ();
+  fcn_index_map::iterator pos = fcn_index.find (fcn);
+  assert (pos != fcn_index.end ());
+  active_fcn = active_fcn->exit (pos->second);
 
   // If this was an "inner call", we resume executing the parent function
   // up the stack.  So note the start-time for this!
   last_time = query_time ();
 }
 
 void
 profile_data_accumulator::reset (void)
 {
   if (is_active ())
     {
       error ("Can't reset active profiler.");
       return;
     }
 
-  data.clear ();
+  known_functions.clear ();
+  fcn_index.clear ();
+
+  if (call_tree)
+    {
+      delete call_tree;
+      call_tree = NULL;
+    }
+
   last_time = -1.0;
 }
 
 octave_value
-profile_data_accumulator::get_data (void) const
+profile_data_accumulator::get_flat (void) const
 {
-  const octave_idx_type n = data.size ();
+  const octave_idx_type n = known_functions.size ();
 
-  // For the parent/child data, we need to map function key-names
-  // to the indices they correspond to in the output array.  Find them out
-  // in a preparation step.
-  fcn_index_map fcn_indices;
-  octave_idx_type i = 0;
-  for (stats_map::const_iterator p = data.begin (); p != data.end (); ++p)
-    {
-      fcn_indices[p->first] = i + 1;
-      ++i;
-    }
-  assert (i == n);
+  flat_profile flat (n);
+  assert (call_tree);
+  call_tree->build_flat (flat);
 
   Cell rv_names (n, 1);
   Cell rv_times (n, 1);
   Cell rv_calls (n, 1);
   Cell rv_recursive (n, 1);
   Cell rv_parents (n, 1);
   Cell rv_children (n, 1);
 
-  i = 0;
-  for (stats_map::const_iterator p = data.begin (); p != data.end (); ++p)
+  for (octave_idx_type i = 0; i != n; ++i)
     {
-      const stats& entry = p->second;
-
-      rv_names (i) = octave_value (p->first);
-      rv_times (i) = octave_value (entry.time);
-      rv_calls (i) = octave_value (entry.calls);
-      rv_recursive (i) = octave_value (entry.recursive);
-      rv_parents (i) = stats::function_set_value (entry.parents, fcn_indices);
-      rv_children (i) = stats::function_set_value (entry.children, fcn_indices);
-
-      ++i;
+      rv_names(i) = octave_value (known_functions[i]);
+      rv_times(i) = octave_value (flat[i].time);
+      rv_calls(i) = octave_value (flat[i].calls);
+      rv_recursive(i) = octave_value (flat[i].recursive);
+      rv_parents(i) = stats::function_set_value (flat[i].parents);
+      rv_children(i) = stats::function_set_value (flat[i].children);
     }
-  assert (i == n);
 
   Octave_map retval;
 
   retval.assign ("FunctionName", rv_names);
   retval.assign ("TotalTime", rv_times);
   retval.assign ("NumCalls", rv_calls);
   retval.assign ("IsRecursive", rv_recursive);
   retval.assign ("Parents", rv_parents);
   retval.assign ("Children", rv_children);
 
   return retval;
 }
 
+octave_value
+profile_data_accumulator::get_hierarchical (void) const
+{
+  assert (call_tree);
+  return call_tree->get_hierarchical ();
+}
+
 double
 profile_data_accumulator::query_time (void) const
 {
   octave_time now;
   return now.double_value ();
 }
 
 void
 profile_data_accumulator::add_current_time (void)
 {
   const double t = query_time ();
   assert (last_time >= 0.0 && last_time <= t);
 
-  assert (!call_stack.empty ());
-  const std::string name = call_stack.back ();
-
-  // The entry for this function should already be created; namely
-  // when entering the function via the non-timing data collection!
-  stats_map::iterator pos = data.find (name);
-  assert (pos != data.end ());
-  pos->second.time += t - last_time;
+  assert (call_tree && active_fcn != call_tree);
+  active_fcn->add_time (t - last_time);
 }
 
 profile_data_accumulator profiler;
 
 // Enable or disable the profiler data collection.
-DEFUN (__profiler_enable, args, ,
+DEFUN (__profiler_enable__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_enable ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   const int nargin = args.length ();
@@ -260,17 +373,17 @@ Undocumented internal function.\n\
     }
 
   retval(0) = profiler.is_active ();
 
   return retval;
 }
 
 // Clear all collected profiling data.
-DEFUN (__profiler_reset, args, ,
+DEFUN (__profiler_reset__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_reset ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   const int nargin = args.length ();
 
@@ -278,24 +391,26 @@ Undocumented internal function.\n\
     warning ("profiler_reset: ignoring extra arguments");
 
   profiler.reset ();
 
   return retval;
 }
 
 // Query the timings collected by the profiler.
-DEFUN (__profiler_data, args, ,
+DEFUN (__profiler_data__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_data ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   const int nargin = args.length ();
 
   if (nargin > 0)
     warning ("profiler_data: ignoring extra arguments");
 
-  retval(0) = profiler.get_data ();
+  retval(0) = profiler.get_flat ();
+  if (nargout > 1)
+    retval(1) = profiler.get_hierarchical ();
 
   return retval;
 }
diff --git a/src/profiler.h b/src/profiler.h
--- a/src/profiler.h
+++ b/src/profiler.h
@@ -35,105 +35,151 @@ OCTAVE_API
 profile_data_accumulator
 {
 public:
 
   // This is a utility class that can be used to call the enter/exit
   // functions in a manner protected from stack unwinding.
   class enter
   {
-    private:
-
-      profile_data_accumulator& acc;
+  private:
 
-      std::string fcn;
+    profile_data_accumulator& acc;
+    std::string fcn;
 
-    public:
-
-      enter (profile_data_accumulator&, const std::string&);
+  public:
 
-      virtual ~enter (void);
-
-    private:
+    enter (profile_data_accumulator&, const std::string&);
+    virtual ~enter (void);
 
-      // No copying!
+  private:
 
-      enter (const enter&);
-
-      enter& operator = (const enter&);
+    // No copying!
+    enter (const enter&);
+    enter& operator = (const enter&);
   };
 
   profile_data_accumulator (void);
+  virtual ~profile_data_accumulator ();
 
   bool is_active (void) const { return enabled; }
-
   void set_active (bool);
 
   void reset (void);
 
-  octave_value get_data (void) const;
+  octave_value get_flat (void) const;
+  octave_value get_hierarchical (void) const;
 
 private:
 
-  typedef std::set<std::string> function_set;
+  // One entry in the flat profile (i.e., a collection of data for a single
+  // function).  This is filled in when building the flat profile from the
+  // hierarchical call tree.
+  struct stats
+  {
+    stats ();
+
+    double time;
+    unsigned calls;
+
+    bool recursive;
+
+    typedef std::set<octave_idx_type> function_set;
+    function_set parents;
+    function_set children;
+
+    // Convert a function_set list to an Octave array of indices.
+    static octave_value function_set_value (const function_set&);
+  };
+
+  typedef std::vector<stats> flat_profile;
+  
+  // Store data for one node in the call-tree of the hierarchical profiler
+  // data we collect.
+  class tree_node
+  {
+  public:
+
+    tree_node (tree_node*, octave_idx_type);
+    virtual ~tree_node ();
+
+    void add_time (double dt) { time += dt; }
+
+    // Enter a child function.  It is created in the list of children if it
+    // wasn't already there.  The now-active child node is returned.
+    tree_node* enter (octave_idx_type);
+
+    // Exit function.  As a sanity-check, it is verified that the currently
+    // active function actually is the one handed in here.  Returned is the
+    // then-active node, which is our parent.
+    tree_node* exit (octave_idx_type);
+
+    void build_flat (flat_profile&) const;
+    octave_value get_hierarchical (void) const;
+
+  private:
+
+    tree_node* parent;
+    octave_idx_type fcn_id;
+
+    typedef std::map<octave_idx_type, tree_node*> child_map;
+    child_map children;
+
+    // This is only time spent *directly* on this level, excluding children!
+    double time;
+
+    unsigned calls;
+
+    // No copying!
+    tree_node (const tree_node&);
+    tree_node& operator = (const tree_node&);
+  };
+
+  // Each function we see in the profiler is given a unique index (which
+  // simply counts starting from 1).  We thus have to map profiler-names to
+  // those indices.  For all other stuff, we identify functions by their index.
+
+  typedef std::vector<std::string> function_set;
   typedef std::map<std::string, octave_idx_type> fcn_index_map;
 
-  // Store some statistics data collected for a function.
-  class stats
-  {
-    private:
-
-      double time;
-      unsigned calls;
-
-      bool recursive;
-
-      function_set parents;
-      function_set children;
-
-    public:
-
-      stats ();
-
-      static octave_value
-      function_set_value (const function_set&, const fcn_index_map&);
-
-      friend class profile_data_accumulator;
-  };
+  function_set known_functions;
+  fcn_index_map fcn_index;
 
   bool enabled;
 
-  typedef std::vector<std::string> call_stack_type;
-  call_stack_type call_stack;
-
-  typedef std::map<std::string, stats> stats_map;
-  stats_map data;
+  tree_node* call_tree;
+  tree_node* active_fcn;
 
   // Store last timestamp we had, when the currently active function was called.
   double last_time;
 
   // These are private as only the unwind-protecting inner class enter
   // should be allowed to call them.
   void enter_function (const std::string&);
   void exit_function (const std::string&);
 
   // Query a timestamp, used for timing calls (obviously).
   // This is not static because in the future, maybe we want a flag
-  // in the profiler or something to choose between cputime, wall-time
+  // in the profiler or something to choose between cputime, wall-time,
   // user-time, system-time, ...
   double query_time () const;
 
-  // Add the time elapsed since last_time to the function on the top
-  // of our call-stack.  This is called from two different positions,
-  // thus it is useful to have it as a seperate function.
+  // Add the time elapsed since last_time to the function we're currently in.
+  // This is called from two different positions, thus it is useful to have
+  // it as a seperate function.
   void add_current_time (void);
 
   // No copying!
-
   profile_data_accumulator (const profile_data_accumulator&);
-
   profile_data_accumulator& operator = (const profile_data_accumulator&);
 };
 
 // The instance used.
 extern profile_data_accumulator profiler;
 
+// Helper macro to profile a block of code.
+#define BEGIN_PROFILER_BLOCK(name) \
+  { \
+    profile_data_accumulator::enter pe (profiler, (name));
+#define END_PROFILER_BLOCK \
+  }
+
 #endif
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -116,29 +116,30 @@ tree_binary_expression::rvalue1 (int)
       octave_value a = op_lhs->rvalue1 ();
 
       if (! error_state && a.is_defined () && op_rhs)
         {
           octave_value b = op_rhs->rvalue1 ();
 
           if (! error_state && b.is_defined ())
             {
-              profile_data_accumulator::enter pe (profiler,
-                                                  "binary " + oper ());
+              BEGIN_PROFILER_BLOCK ("binary " + oper ())
 
               // Note: The profiler does not catch the braindead
               // short-circuit evaluation code above, but that should be
               // ok. The evaluation of operands and the operator itself
               // is entangled and it's not clear where to start/stop
               // timing the operator to make it reasonable.
 
               retval = ::do_binary_op (etype, a, b);
 
               if (error_state)
                 retval = octave_value ();
+
+              END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
 std::string
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -68,43 +68,45 @@ tree_prefix_expression::rvalue1 (int)
   if (op)
     {
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
         {
           octave_lvalue ref = op->lvalue ();
 
           if (! error_state)
             {
-              profile_data_accumulator::enter pe (profiler,
-                                                  "prefix " + oper ());
+              BEGIN_PROFILER_BLOCK ("prefix " + oper ())
               
               ref.do_unary_op (etype);
 
               if (! error_state)
                 retval = ref.value ();
+
+              END_PROFILER_BLOCK
             }
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
           if (! error_state && val.is_defined ())
             {
-              profile_data_accumulator::enter pe (profiler,
-                                                  "prefix " + oper ());
+              BEGIN_PROFILER_BLOCK ("prefix " + oper ())
 
               // Attempt to do the operation in-place if it is unshared
               // (a temporary expression).
               if (val.get_count () == 1)
                 retval = val.do_non_const_unary_op (etype);
               else
                 retval = ::do_unary_op (etype, val);
 
               if (error_state)
                 retval = octave_value ();
+
+              END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
 tree_expression *
@@ -155,35 +157,35 @@ tree_postfix_expression::rvalue1 (int)
       if (etype == octave_value::op_incr || etype == octave_value::op_decr)
         {
           octave_lvalue ref = op->lvalue ();
 
           if (! error_state)
             {
               retval = ref.value ();
 
-              profile_data_accumulator::enter pe (profiler,
-                                                  "postfix " + oper ());
-
+              BEGIN_PROFILER_BLOCK ("postfix " + oper ())
               ref.do_unary_op (etype);
+              END_PROFILER_BLOCK
             }
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
           if (! error_state && val.is_defined ())
             {
-              profile_data_accumulator::enter pe (profiler,
-                                                  "postfix " + oper ());
+              BEGIN_PROFILER_BLOCK ("postfix " + oper ())
 
               retval = ::do_unary_op (etype, val);
 
               if (error_state)
                 retval = octave_value ();
+
+              END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
 tree_expression *
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <sstream>
 #include <string>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "cmd-edit.h"
+#include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "oct-env.h"
 #include "quit.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
@@ -1048,17 +1049,17 @@ do_octave_atexit (void)
 
         SAFE_CALL (command_editor::restore_terminal_state, ())
 
       // FIXME -- is this needed?  Can it cause any trouble?
       SAFE_CALL (raw_mode, (0))
 
       SAFE_CALL (octave_history_write_timestamp, ())
 
-      if (Vsaving_history)
+      if (! command_history::ignoring_entries ())
         SAFE_CALL (command_history::clean_up_and_save, ())
 
       SAFE_CALL (close_files, ())
 
       SAFE_CALL (cleanup_tmp_files, ())
 
       SAFE_CALL (flush_octave_stdout, ())
 
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -197,17 +197,18 @@ private:
 };
 
 ft_manager* ft_manager::instance = 0;
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
     : text_processor (), face (0), bbox (1, 4, 0.0),
-      xoffset (0), yoffset (0), mode (MODE_BBOX),
+      xoffset (0), yoffset (0), multiline_halign (0), 
+      multiline_align_xoffsets(), mode (MODE_BBOX),
       red (0), green (0), blue (0)
 {
 }
 
 ft_render::~ft_render (void)
 {
   if (face)
     FT_Done_Face (face);
@@ -265,33 +266,55 @@ ft_render::set_mode (int m)
     }
 }
 
 void
 ft_render::visit (text_element_string& e)
 {
   if (face)
     {
+      int line_index = 0;
+      FT_UInt box_line_width = 0;
       std::string str = e.string_value ();
       FT_UInt glyph_index, previous = 0;
 
+      if (mode == MODE_BBOX)
+        multiline_align_xoffsets.clear();
+      else if (mode == MODE_RENDER)
+        xoffset += multiline_align_xoffsets[line_index];
+
       for (size_t i = 0; i < str.length (); i++)
         {
           glyph_index = FT_Get_Char_Index (face, str[i]);
 
-          if (! glyph_index
-              || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+          if (str[i] != '\n' 
+              && (! glyph_index
+              || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT)))
             ::warning ("ft_render: skipping missing glyph for character `%c'",
                        str[i]);
           else
             {
               switch (mode)
                 {
                 case MODE_RENDER:
-                  if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
+                  if (str[i] == '\n')
+                    {
+                    glyph_index = FT_Get_Char_Index(face, ' ');
+                    if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+                      {
+                        ::warning ("ft_render: skipping missing glyph for character ` '");
+                      } 
+                    else 
+                      {
+                        line_index++;
+                        xoffset = multiline_align_xoffsets[line_index];
+                        yoffset -= (face->size->metrics.height >> 6);
+                      }
+                  } 
+                  else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
                     ::warning ("ft_render: unable to render glyph for character `%c'",
                                str[i]);
                   else
                     {
                       FT_Bitmap& bitmap = face->glyph->bitmap;
                       int x0, y0;
 
                       if (previous)
@@ -299,16 +322,24 @@ ft_render::visit (text_element_string& e
                           FT_Vector delta;
 
                           FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
                           xoffset += (delta.x >> 6);
                         }
 
                       x0 = xoffset+face->glyph->bitmap_left;
                       y0 = yoffset+face->glyph->bitmap_top;
+
+                      // 'w' seems to have a negative -1
+                      // face->glyph->bitmap_left, this is so we don't
+                      // index out of bound, and assumes we we allocated
+                      // the right amount of horizontal space in the bbox.
+                      if (x0 < 0)
+                        x0 = 0;
+
                       for (int r = 0; r < bitmap.rows; r++)
                         for (int c = 0; c < bitmap.width; c++)
                           {
                             unsigned char pix = bitmap.buffer[r*bitmap.width+c];
                             if (x0+c < 0 || x0+c >= pixels.dim2()
                                 || y0-r < 0 || y0-r >= pixels.dim3())
                               {
                                 //::error ("out-of-bound indexing!!");
@@ -322,53 +353,99 @@ ft_render::visit (text_element_string& e
                               }
                           }
 
                       xoffset += (face->glyph->advance.x >> 6);
                     }
                   break;
 
                 case MODE_BBOX:
-                  // width
-                  if (previous)
+                  if (str[i] == '\n')
                     {
-                      FT_Vector delta;
-
-                      FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
-                      bbox(2) += (delta.x >> 6);
-                    }
-                  bbox(2) += (face->glyph->advance.x >> 6);
-
-                  int asc, desc;
-
-                  if (false /*tight*/)
+                      glyph_index = FT_Get_Char_Index(face, ' ');
+                      if (! glyph_index
+                          || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+                      {
+                        ::warning ("ft_render: skipping missing glyph for character ` '");
+                      }
+                    else
+                      {
+                        multiline_align_xoffsets.push_back(box_line_width);
+                        // Reset the pixel width for this newline, so we don't
+                        // allocate a bounding box larger than the horizontal
+                        // width of the multi-line
+                        box_line_width = 0; 
+                        bbox(1) -= (face->size->metrics.height >> 6);
+                      }
+                    } 
+                  else 
                     {
-                      desc = face->glyph->metrics.horiBearingY - face->glyph->metrics.height;
-                      asc = face->glyph->metrics.horiBearingY;
-                    }
-                  else
-                    {
-                      asc = face->size->metrics.ascender;
-                      desc = face->size->metrics.descender;
-                    }
+                    // width
+                    if (previous)
+                      {
+                        FT_Vector delta;
+
+                        FT_Get_Kerning (face, previous, glyph_index,
+                                        FT_KERNING_DEFAULT, &delta);
+
+                        box_line_width += (delta.x >> 6);
+                      }
+
+                    box_line_width += (face->glyph->advance.x >> 6);
+
+                    int asc, desc;
 
-                  asc = yoffset + (asc >> 6);
-                  desc = yoffset + (desc >> 6);
+                    if (false /*tight*/)
+                      {
+                        desc = face->glyph->metrics.horiBearingY - face->glyph->metrics.height;
+                        asc = face->glyph->metrics.horiBearingY;
+                      }
+                    else
+                      {
+                        asc = face->size->metrics.ascender;
+                        desc = face->size->metrics.descender;
+                      }
 
-                  if (desc < bbox(1))
-                    {
-                      bbox(3) += (bbox(1) - desc);
-                      bbox(1) = desc;
-                    }
-                  if (asc > (bbox(3)+bbox(1)))
-                    bbox(3) = asc-bbox(1);
+                    asc = yoffset + (asc >> 6);
+                    desc = yoffset + (desc >> 6);
+
+                    if (desc < bbox(1))
+                      {
+                        bbox(3) += (bbox(1) - desc);
+                        bbox(1) = desc;
+                      }
+                    if (asc > (bbox(3)+bbox(1)))
+                      bbox(3) = asc-bbox(1);
+                    if (bbox(2) < box_line_width)
+                      bbox(2) = box_line_width;
+                  }
                   break;
                 }
+                if (str[i] == '\n')
+                  previous = 0;
+                else
+                  previous = glyph_index;
+            }
+        }
+      if (mode == MODE_BBOX)
+        {
+          /* Push last the width associated with the last line */ 
+          multiline_align_xoffsets.push_back(box_line_width);
 
-              previous = glyph_index;
+          for (unsigned int i = 0; i < multiline_align_xoffsets.size(); i++)
+            {
+            /* Center align */
+            if (multiline_halign == 1) 
+              multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
+            /* Right align */
+            else if (multiline_halign == 2)
+              multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i]);
+            /* Left align */
+            else 
+              multiline_align_xoffsets[i] = 0;
             }
         }
     }
 }
 
 void
 ft_render::reset (void)
 {
@@ -501,16 +578,18 @@ ft_render::rotation_to_mode (double rota
 
 void
 ft_render::text_to_pixels (const std::string& txt,
                            uint8NDArray& pixels_, Matrix& box,
                            int halign, int valign, double rotation)
 {
   // FIXME: clip "rotation" between 0 and 360
   int rot_mode = rotation_to_mode (rotation);
+  
+  multiline_halign = halign;
 
   text_element *elt = text_parser_none ().parse (txt);
   pixels_ = render (elt, box, rot_mode);
   delete elt;
 
   if (pixels_.numel () == 0)
     {
       // nothing to render
diff --git a/src/txt-eng-ft.h b/src/txt-eng-ft.h
--- a/src/txt-eng-ft.h
+++ b/src/txt-eng-ft.h
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (txt_eng_ft_h)
 #define txt_eng_ft_h 1
 
 #if HAVE_FREETYPE
 
+#include <vector>
+
 #include <ft2build.h>
 #include FT_FREETYPE_H
 
 #include <dMatrix.h>
 #include <uint8NDArray.h>
 #include "txt-eng.h"
 
 class
@@ -89,15 +91,17 @@ private:
   ft_render& operator = (const ft_render&);
 
 private:
   FT_Face face;
   Matrix bbox;
   uint8NDArray pixels;
   int xoffset;
   int yoffset;
+  int multiline_halign;
+  std::vector<int> multiline_align_xoffsets;
   int mode;
   uint8_t red, green, blue;
 };
 
 #endif // HAVE_FREETYPE
 
 #endif
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -59,35 +59,35 @@ static void
 solve_singularity_warning (double rcond)
 {
   warning_with_id ("Octave:singular-matrix-div",
                    "matrix singular to machine precision, rcond = %g", rcond);
 }
 
 template <class T1, class T2>
 bool
-mx_leftdiv_conform (const T1& a, const T2& b)
+mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
-  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
-      octave_idx_type a_nc = a.cols ();
+      octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols () : a.rows ();
       octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
-  template bool mx_leftdiv_conform (const T1&, const T2&)
+  template bool mx_leftdiv_conform (const T1&, const T2&, blas_trans_type)
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, ComplexMatrix);
 
 template <class T1, class T2>
 bool
@@ -347,54 +347,54 @@ x_el_div (const Complex a, const Complex
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
 xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
@@ -645,54 +645,54 @@ x_el_div (const FloatComplex a, const Fl
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 FloatMatrix
 xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
 xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
 xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
 xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
-  if (! mx_leftdiv_conform (a, b))
+  if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // Diagonal matrix division.
@@ -777,17 +777,17 @@ xdiv (const FloatComplexMatrix& a, const
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatComplexDiagMatrix& b)
 { return mdm_div_impl (a, b); }
 
 template <class MT, class DMT>
 MT
 dmm_leftdiv_impl (const DMT& d, const MT& a)
 {
-  if (! mx_leftdiv_conform (d, a))
+  if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
   octave_idx_type m = d.cols (), n = a.cols (), k = a.rows (), l = d.length ();
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
   const S *dd = d.data ();
@@ -926,17 +926,17 @@ xdiv (const FloatComplexDiagMatrix& a, c
 FloatComplexDiagMatrix
 xdiv (const FloatComplexDiagMatrix& a, const FloatComplexDiagMatrix& b)
 { return dmdm_div_impl (a, b); }
 
 template <class MT, class DMT>
 MT
 dmdm_leftdiv_impl (const DMT& d, const MT& a)
 {
-  if (! mx_leftdiv_conform (d, a))
+  if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
   octave_idx_type m = d.cols (), n = a.cols (), k = d.rows ();
   octave_idx_type l = std::min (m, n), lk = std::min (l, k);
   MT x (m, n);
   typedef typename DMT::element_type S;
   typedef typename MT::element_type T;
   const T *aa = a.data ();
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -44,16 +44,18 @@ along with Octave; see the file COPYING.
 #include "Range.h"
 #include "quit.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "xpow.h"
 
+#include "bsxfun.h"
+
 #ifdef _OPENMP
 #include <omp.h>
 #endif
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
@@ -1238,18 +1240,31 @@ elem_xpow (const NDArray& a, const NDArr
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          //Potentially complex results
+          NDArray xa = octave_value_extract<NDArray> (a);
+          NDArray xb = octave_value_extract<NDArray> (b);
+          if (! xb.all_integers () && xa.any_element_is_negative ())
+            return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
+          else
+            return octave_value (bsxfun_pow (xa, xb));
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   int len = a.length ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -1313,18 +1328,25 @@ elem_xpow (const NDArray& a, const Compl
 octave_value
 elem_xpow (const NDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -1405,18 +1427,25 @@ elem_xpow (const ComplexNDArray& a, doub
 octave_value
 elem_xpow (const ComplexNDArray& a, const NDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       double btmp = b(i);
@@ -1448,18 +1477,25 @@ elem_xpow (const ComplexNDArray& a, cons
 octave_value
 elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      gripe_nonconformant ("operator .^", a_dims, b_dims);
-      return octave_value ();
+      if (is_valid_bsxfun (a_dims, b_dims))
+        {
+          return bsxfun_pow (a, b);
+        }
+      else
+        {
+          gripe_nonconformant ("operator .^", a_dims, b_dims);
+          return octave_value ();
+        }
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -237,16 +237,40 @@
 %!assert(puts (1),-1);
 
 %% test/octave.test/io/puts-3.m
 %!error <Invalid call to puts.*> puts ();
 
 %% test/octave.test/io/puts-4.m
 %!error <Invalid call to puts.*> puts (1, 2);
 
+%!assert (sscanf ('123456', '%10c'), '123456')
+%!assert (sscanf ('123456', '%10s'), '123456')
+
+%!test
+%! [val, count, msg, pos] = sscanf ("3I2", "%f");
+%! assert (val, 3);
+%! assert (count, 1);
+%! assert (msg, "");
+%! assert (pos, 2);
+
+%!test
+%! [val, count, msg, pos] = sscanf ("3In2", "%f");
+%! assert (val, 3);
+%! assert (count, 1);
+%! assert (msg, "");
+%! assert (pos, 2);
+
+%!test
+%! [val, count, msg, pos] = sscanf ("3Inf2", "%f");
+%! assert (val, [3; Inf; 2]);
+%! assert (count, 3);
+%! assert (msg, "");
+%! assert (pos, 6);
+
 %% test/octave.test/io/sscanf-1.m
 %!test
 %! [a, b, c] = sscanf ("1.2 3 foo", "%f%d%s", "C");
 %! [v1, c1, m1] = sscanf ("1 2 3 4 5 6", "%d");
 %! [v2, c2, m2] = sscanf ("1 2 bar 3 4 5 6", "%d");
 %! 
 %! assert((a == 1.2 && b == 3 && c == "foo"
 %! && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
