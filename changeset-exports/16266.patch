# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1363026639 14400
#      Mon Mar 11 14:30:39 2013 -0400
# Branch classdef
# Node ID 36e01847694fe8f95da4a82e8147fd76d2f1a426
# Parent  6077d13ddb3bc284017be59110ad644ee52198d3
# Parent  71ee3afedb694ab9dd886960bf2f7cc4b9c5a379
maint: periodic merge of default to classdef

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -68,17 +68,18 @@ public:
   class bbp_nesting_level
   {
   private:
 
     enum bracket_type
       {
         BRACKET = 1,
         BRACE = 2,
-        PAREN = 3
+        PAREN = 3,
+        ANON_FCN_BODY = 4
       };
 
   public:
 
     bbp_nesting_level (void) : context () { }
 
     bbp_nesting_level (const bbp_nesting_level& nl) : context (nl.context) { }
 
@@ -114,16 +115,23 @@ public:
 
     void paren (void) { context.push (PAREN); }
 
     bool is_paren (void)
     {
       return ! context.empty () && context.top () == PAREN;
     }
 
+    void anon_fcn_body (void) { context.push (ANON_FCN_BODY); }
+
+    bool is_anon_fcn_body (void)
+    {
+      return ! context.empty () && context.top () == ANON_FCN_BODY;
+    }
+
     bool is_bracket_or_brace (void)
     {
       return (! context.empty ()
               && (context.top () == BRACKET || context.top () == BRACE));
     }
 
     bool none (void) { return context.empty (); }
 
@@ -388,18 +396,18 @@ public:
   // if the top of the stack is true, then we've already seen the name
   // of the current function.  should only matter if
   // current_function_level > 0
   std::stack<bool> parsed_function_name;
 
   // set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
-  // is the closest nesting level a square bracket, squiggly brace or
-  // a paren?
+  // is the closest nesting level a square bracket, squiggly brace,
+  // a paren, or an anonymous function body?
   bbp_nesting_level nesting_level;
 
   // Tokens generated by the lexer.
   token_cache tokens;
 
 private:
 
   // No copying!
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -816,17 +816,24 @@ ANY_INCLUDING_NL (.|{NL})
 "/"     { return curr_lexer->handle_op ("/", '/'); }
 "\\"    { return curr_lexer->handle_op ("\\", LEFTDIV); }
 "^"     { return curr_lexer->handle_op ("^", POW); }
 "**"    { return curr_lexer->handle_incompatible_op ("**", POW); }
 "&&"    { return curr_lexer->handle_op ("&&", EXPR_AND_AND); }
 "||"    { return curr_lexer->handle_op ("||", EXPR_OR_OR); }
 "<<"    { return curr_lexer->handle_incompatible_op ("<<", LSHIFT); }
 ">>"    { return curr_lexer->handle_incompatible_op (">>", RSHIFT); }
-";"     { return curr_lexer->handle_op (";", ';', true, true); }
+
+";" {
+    bool at_beginning_of_statement
+      = (! (curr_lexer->whitespace_is_significant ()
+            || curr_lexer->looking_at_object_index.front ()));
+
+    return curr_lexer->handle_op (";", ';', true, at_beginning_of_statement);
+  }
 
 "+" {
    int tok = curr_lexer->handle_unary_op ("+", '+');
 
     if (tok < 0)
       {
         yyless (0);
         curr_lexer->xunput (',');
@@ -882,18 +889,22 @@ ANY_INCLUDING_NL (.|{NL})
         yyless (0);
         curr_lexer->xunput (',');
       }
     else
       return tok;
   }
 
 "," {
+    bool at_beginning_of_statement
+      = (! (curr_lexer->whitespace_is_significant ()
+            || curr_lexer->looking_at_object_index.front ()));
+
     return curr_lexer->handle_op
-      (",", ',', true, ! curr_lexer->looking_at_object_index.front ());
+      (",", ',', true, at_beginning_of_statement);
   }
 
 ".'" {
     return curr_lexer->handle_op (".'", TRANSPOSE, true, false);
   }
 
 "++" {
     int tok = curr_lexer->handle_incompatible_unary_op
@@ -969,17 +980,20 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->current_input_column++;
 
     curr_lexer->looking_at_object_index.pop_front ();
 
     curr_lexer->looking_for_object_index = true;
     curr_lexer->at_beginning_of_statement = false;
 
     if (curr_lexer->looking_at_anon_fcn_args)
-      curr_lexer->looking_at_anon_fcn_args = false;
+      {
+        curr_lexer->looking_at_anon_fcn_args = false;
+        curr_lexer->nesting_level.anon_fcn_body ();
+      }
 
     return curr_lexer->count_token (')');
   }
 
 "." {
     curr_lexer->lexer_debug (".");
 
     curr_lexer->looking_for_object_index = false;
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -537,17 +537,20 @@ cell_or_matrix_row
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = curr_parser.make_fcn_handle ($2);
                     curr_lexer->looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
-                  { $$ = curr_parser.make_anon_fcn_handle ($2, $3); }
+                  {
+                    $$ = curr_parser.make_anon_fcn_handle ($2, $3);
+                    curr_lexer->nesting_level.remove ();
+                  }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
                   { $$ = $1; }
