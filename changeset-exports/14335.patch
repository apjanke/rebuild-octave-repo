# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1328484744 28800
#      Sun Feb 05 15:32:24 2012 -0800
# Node ID ce2b59a6d0e5e2a12cad1bcb26d8ba6d92f654a5
# Parent  6dd710b73150b8eaed4b24173e55f2e46ed763d0
# Parent  4d917a6a858bf6f657a3633c535d369e8ef777d6
maint: periodic merge of stable to default.

diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -63,36 +63,36 @@
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
 ## the same index (@pxref{doc-unique}).
 ##
 ## @example
 ## @group
 ## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
 ## [@var{u}, ~, @var{j}] = unique (@var{x});
 ## [accumarray(@var{j}', 1), @var{u}']
-## @result{} 2    89
-##    3    90
-##    2    91
-##    2    92
-##    3   100
+##   @result{}  2    89
+##       3    90
+##       2    91
+##       2    92
+##       3   100
 ## @end group
 ## @end example
 ##
 ## Another example, where the result is a multi-dimensional 3-D array and
 ## the default value (zero) appears in the output:
 ##
 ## @example
 ## @group
 ## accumarray ([1, 1, 1;
 ##              2, 1, 2;
 ##              2, 3, 2;
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
-##    ans(:,:,2) = [0, 0, 0; 206, 0, 208]
+## @result{} ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
 ## The sparse option can be used as an alternative to the @code{sparse}
 ## constructor (@pxref{doc-sparse}). Thus
 ##
 ## @example
 ## sparse (@var{i}, @var{j}, @var{sv})
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -45,17 +45,17 @@
 ##
 ## @example
 ## @group
 ## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
 ##                             -5, -12,   8;
 ##                            -12,   2,   8;
 ##                            -10,   9,  -3;
 ##                             -5,  -3, -13])
-## @result{} ans = [-10,-11,-1;-15,-3,5]
+## @result{} [-10,-11,-1;-15,-3,5]
 ## @end group
 ## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -18,22 +18,22 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bitcmp (@var{A}, @var{k})
 ## Return the @var{k}-bit complement of integers in @var{A}.  If
 ## @var{k} is omitted @code{k = log2 (bitmax) + 1} is assumed.
 ##
 ## @example
 ## @group
-## bitcmp(7,4)
-## @result{} 8
-## dec2bin(11)
-## @result{} 1011
-## dec2bin(bitcmp(11, 6))
-## @result{} 110100
+## bitcmp (7,4)
+##   @result{} 8
+## dec2bin (11)
+##   @result{} 1011
+## dec2bin (bitcmp (11, 6))
+##   @result{} 110100
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based on the version by Kai Habel from octave-forge
 
 function C = bitcmp (A, k)
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{C} =} bitset (@var{A}, @var{n}, @var{val})
 ## Set or reset bit(s) @var{n} of unsigned integers in @var{A}.
 ## @var{val} = 0 resets and @var{val} = 1 sets the bits.
 ## The lowest significant bit is: @var{n} = 1
 ##
 ## @example
 ## @group
 ## dec2bin (bitset (10, 1))
-## @result{} 1011
+##   @result{} 1011
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based on the version by Kai Habel from octave-forge
 
 function C = bitset (A, n, val)
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -20,26 +20,26 @@
 ## @deftypefn {Function File} {} celldisp (@var{c}, @var{name})
 ## Recursively display the contents of a cell array.  By default the values
 ## are displayed with the name of the variable @var{c}.  However, this name
 ## can be replaced with the variable @var{name}.  For example:
 ##
 ## @example
 ## @group
 ## c = @{1, 2, @{31, 32@}@};
-## celldisp(c, "b")
-##      @result{}
-##         b@{1@} =
-##          1
-##         b@{2@} =
-##          2
-##         b@{3@}@{1@} =
-##          31
-##         b@{3@}@{2@} =
-##          32
+## celldisp (c, "b")
+##    @result{}
+##       b@{1@} =
+##        1
+##       b@{2@} =
+##        2
+##       b@{3@}@{1@} =
+##        31
+##       b@{3@}@{2@} =
+##        32
 ## @end group
 ## @end example
 ##
 ## @seealso{disp}
 ## @end deftypefn
 
 ## This is ugly, but seems to be what matlab does..
 
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -20,19 +20,19 @@
 ## @deftypefn {Function File} {} chop (@var{x}, @var{ndigits}, @var{base})
 ## Truncate elements of @var{x} to a length of @var{ndigits} such that the
 ## resulting numbers are exactly divisible by @var{base}.  If @var{base} is not
 ## specified it defaults to 10.
 ##
 ## @example
 ## @group
 ## chop (-pi, 5, 10)
-##      @result{} -3.14200000000000
+##    @result{} -3.14200000000000
 ## chop (-pi, 5, 5)
-##      @result{} -3.14150000000000
+##    @result{} -3.14150000000000
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function retval = chop (x, ndigits, base = 10)
 
   if (nargin == 2 || nargin == 3)
     tmp = abs (x);
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -19,18 +19,18 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{r} =} colon (@var{a}, @var{b})
 ## @deftypefnx {Function File} {@var{r} =} colon (@var{a}, @var{b}, @var{c})
 ## Method of a class to construct a range with the @code{:} operator.  For
 ## example:
 ##
 ## @example
 ## @group
-## a = myclass (@dots{})
-## b = myclass (@dots{})
+## a = myclass (@dots{});
+## b = myclass (@dots{});
 ## c = a : b
 ## @end group
 ## @end example
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function r = colon (varargin)
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {} flipdim (@var{x}, @var{dim})
 ## Return a copy of @var{x} flipped about the dimension @var{dim}.
 ## @var{dim} defaults to the first non-singleton dimension.
 ## For example:
 ##
 ## @example
 ## @group
 ## flipdim ([1, 2; 3, 4], 2)
-##      @result{}  2  1
-##          4  3
+##       @result{}  2  1
+##           4  3
 ## @end group
 ## @end example
 ## @seealso{fliplr, flipud, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: David Bateman, Jaroslav Hajek
 
 function y = flipdim (x, dim)
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -25,61 +25,60 @@
 ##
 ## If @var{str} is a cellstr, then a unique variable is created for each
 ## cell in @var{str}.
 ##
 ## @example
 ## @group
 ## x = 3.141;
 ## genvarname ("x", who ())
-## @result{} x1
+##   @result{} x1
 ## @end group
 ## @end example
 ##
 ## If @var{wanted} is a cell array, genvarname will make sure the returned
 ## strings are distinct:
 ##
 ## @example
 ## @group
 ## genvarname (@{"foo", "foo"@})
-## @result{}
-## @{
-##   [1,1] = foo
-##   [1,2] = foo1
-## @}
+##   @result{}
+##      @{
+##        [1,1] = foo
+##        [1,2] = foo1
+##      @}
 ## @end group
 ## @end example
 ##
 ## Note that the result is a char array/cell array of strings, not the
 ## variables themselves.  To define a variable, @code{eval()} can be
 ## used.  The following trivial example sets @code{x} to @code{42}.
 ##
 ## @example
 ## @group
 ## name = genvarname ("x");
-## eval([name " = 42"]);
-## @result{} x =  42
+## eval ([name " = 42"]);
+##   @result{} x =  42
 ## @end group
 ## @end example
 ##
 ## Also, this can be useful for creating unique struct field names.
 ##
 ## @example
 ## @group
 ## x = struct ();
 ## for i = 1:3
 ##   x.(genvarname ("a", fieldnames (x))) = i;
 ## endfor
-## @result{}
-## x =
-## @{
-##   a =  1
-##   a1 =  2
-##   a2 =  3
-## @}
+##   @result{} x =
+##      @{
+##        a =  1
+##        a1 =  2
+##        a2 =  3
+##      @}
 ## @end group
 ## @end example
 ##
 ## Since variable names may only contain letters, digits and underscores,
 ## genvarname replaces any sequence of disallowed characters with
 ## an underscore.  Also, variables may not begin with a digit; in this
 ## case an underscore is added before the variable name.
 ##
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -47,23 +47,23 @@
 ##
 ## @noindent
 ## If @var{op} is not given it defaults to @code{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
 ## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
-## @result{} int8 ([0, 0])
+##   @result{} int8 ([0, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "round")
-## @result{} int8 ([-1, 1])
+##   @result{} int8 ([-1, 1])
 ## idivide (int8 ([-3, 3]), int8 (4), "floor")
-## @result{} int8 ([-1, 0])
+##   @result{} int8 ([-1, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "ceil")
-## @result{} int8 ([0, 1])
+##   @result{} int8 ([0, 1])
 ## @end group
 ## @end example
 ##
 ## @seealso{ldivide, rdivide}
 ## @end deftypefn
 
 function z = idivide (x, y, op)
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -18,17 +18,16 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} int2str (@var{n})
 ## Convert an integer (or array of integers) to a string (or a character
 ## array).
 ##
 ## @example
 ## @group
-##
 ## int2str (123)
 ##      @result{} "123"
 ##
 ## s = int2str ([1, 2, 3; 4, 5, 6])
 ##      @result{} s =
 ##         1  2  3
 ##         4  5  6
 ##
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -82,17 +82,17 @@
 ## xp = [0:10];
 ## yp = sin (2*pi*xp/5);
 ## lin = interp1 (xp, yp, xf);
 ## spl = interp1 (xp, yp, xf, "spline");
 ## cub = interp1 (xp, yp, xf, "cubic");
 ## near = interp1 (xp, yp, xf, "nearest");
 ## plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
 ##       xf, cub, "c", xf, near, "m", xp, yp, "r*");
-## legend ("original", "linear", "spline", "cubic", "nearest")
+## legend ("original", "linear", "spline", "cubic", "nearest");
 ## @end group
 ## @end example
 ##
 ## @seealso{interpft}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Date: 2000-03-25
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -37,17 +37,17 @@
 ## given values of @var{x}.
 ##
 ## @var{a} and @var{b} are the lower and upper limits of integration.  Either
 ## or both limits may be infinite or contain weak end singularities.
 ## Variable transformation will be used to treat any infinite intervals and
 ## weaken the singularities.  For example:
 ##
 ## @example
-## quadgk(@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
+## quadgk (@@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)
 ## @end example
 ##
 ## @noindent
 ## Note that the formulation of the integrand uses the
 ## element-by-element operator @code{./} and all user functions to
 ## @code{quadgk} should do the same.
 ##
 ## The optional argument @var{tol} defines the absolute tolerance used to stop
@@ -84,17 +84,17 @@
 ## @item WayPoints
 ## Discontinuities in the first derivative of the function to integrate can be
 ## flagged with the  @code{"WayPoints"} property.  This forces the ends of
 ## a subinterval to fall on the breakpoints of the function and can result in
 ## significantly improved estimation of the error in the integral, faster
 ## computation, or both.  For example,
 ##
 ## @example
-## quadgk (@@(x) abs (1 - x.^2), 0, 2, 'Waypoints', 1)
+## quadgk (@@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)
 ## @end example
 ##
 ## @noindent
 ## signals the breakpoint in the integrand at @code{@var{x} = 1}.
 ##
 ## @item Trace
 ## If logically true @code{quadgk} prints information on the
 ## convergence of the quadrature at each iteration.
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -35,17 +35,17 @@
 ## on the interval @w{[@var{imin}, @var{imax}]}.
 ##
 ## The optional argument "@var{class}" will return a matrix of the requested
 ## type.  The default is "double".
 ##
 ## The following example returns 150 integers in the range 1-10.
 ##
 ## @example
-## ri = randi (10, 150, 1);
+## ri = randi (10, 150, 1)
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
 ## uses class "double" to represent numbers.  This limits the maximum
 ## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
 ## this value is @w{@math{2^{53} - 1}}.
 ##
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -20,19 +20,19 @@
 ## @deftypefn  {Function File} {@var{s} =} rat (@var{x}, @var{tol})
 ## @deftypefnx {Function File} {[@var{n}, @var{d}] =} rat (@var{x}, @var{tol})
 ##
 ## Find a rational approximation to @var{x} within the tolerance defined
 ## by @var{tol} using a continued fraction expansion.  For example:
 ##
 ## @example
 ## @group
-## rat(pi) = 3 + 1/(7 + 1/16) = 355/113
-## rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
-##        = 1457/536
+## rat (pi) = 3 + 1/(7 + 1/16) = 355/113
+## rat (e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
+##         = 1457/536
 ## @end group
 ## @end example
 ##
 ## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @seealso{rats}
 ## @end deftypefn
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -23,18 +23,18 @@
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
 ## Negative values of @var{k} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
-##      @result{}  3  1
-##          4  2
+##     @result{}  3  1
+##         4  2
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## rotates the given matrix clockwise by 90 degrees.  The following are all
 ## equivalent statements:
 ##
 ## @example
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -25,17 +25,17 @@
 ## or it might be used to ensure that certain fields of the object are
 ## initialized before the object is saved.  For example:
 ##
 ## @example
 ## @group
 ## function b = saveobj (a)
 ##   b = a;
 ##   if (isempty (b.field))
-##      b.field = initfield(b);
+##      b.field = initfield (b);
 ##   endif
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @seealso{loadobj, class}
 ## @end deftypefn
 
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -31,22 +31,22 @@
 ## in the second output argument @var{ns}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## x = ones (1, 2, 3);
 ## size (shiftdim (x, -1))
-##      @result{} [1, 1, 2, 3]
+##    @result{} [1, 1, 2, 3]
 ## size (shiftdim (x, 1))
-##      @result{} [2, 3]
-## [b, ns] = shiftdim (x);
-##      @result{} b =  [1, 1, 1; 1, 1, 1]
-##      @result{} ns = 1
+##    @result{} [2, 3]
+## [b, ns] = shiftdim (x)
+##    @result{} b = [1, 1, 1; 1, 1, 1]
+##    @result{} ns = 1
 ## @end group
 ## @end example
 ## @seealso {reshape, permute, ipermute, circshift, squeeze}
 ## @end deftypefn
 
 function [y, ns]  = shiftdim (x, n)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -42,17 +42,17 @@
 ## with the same fieldnames as the input structure.
 ##
 ## @example
 ## @group
 ## s.name1 = "John Smith";
 ## s.name2 = "Jill Jones";
 ## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s,
 ##            "UniformOutput", false)
-##     @result{}
+## @result{}
 ##    @{
 ##      name1 = Smith
 ##      name2 = Jones
 ##    @}
 ## @end group
 ## @end example
 ##
 ## Given the parameter "ErrorHandler", @var{errfunc} defines a function to
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -23,28 +23,28 @@
 ## overloading method that allows the conversion of this class object to
 ## a valid indexing vector.  It is important to note that
 ## @code{subsindex} must return a zero-based real integer vector of the
 ## class "double".  For example, if the class constructor
 ##
 ## @example
 ## @group
 ## function b = myclass (a)
-##  b = class (struct ("a", a), "myclass");
+##   b = class (struct ("a", a), "myclass");
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## then the @code{subsindex} function
 ##
 ## @example
 ## @group
 ## function idx = subsindex (a)
-##  idx = double (a.a) - 1.0;
+##   idx = double (a.a) - 1.0;
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## can then be used as follows
 ##
 ## @example
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -37,22 +37,22 @@
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
 ## plotted and a graphics handle @var{h} to the plot is returned.
 ## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the Voronoi vertices
 ## instead of plotting the diagram.
 ##
 ## @example
 ## @group
-##   x = rand (10, 1);
-##   y = rand (size (x));
-##   h = convhull (x, y);
-##   [vx, vy] = voronoi (x, y);
-##   plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g")
-##   legend ("", "points", "hull");
+## x = rand (10, 1);
+## y = rand (size (x));
+## h = convhull (x, y);
+## [vx, vy] = voronoi (x, y);
+## plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g");
+## legend ("", "points", "hull");
 ## @end group
 ## @end example
 ##
 ## @seealso{voronoin, delaunay, convhull}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## First Release: 20/08/2000
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -36,17 +36,17 @@
 ## If the optional argument @var{see_also} is present, it is used to expand the
 ## Octave specific @t{@@seealso} macro. This argument must be a function handle,
 ## that accepts a cell array of strings as input argument (each elements of the
 ## array corresponds to the arguments to the @t{@@seealso} macro), and return
 ## the expanded string. If this argument is not given, the @t{@@seealso} macro
 ## will be expanded to the text
 ##
 ## @example
-## See also: arg1, arg2@, ...
+## See also: arg1, arg2, ...
 ## @end example
 ##
 ## @noindent
 ## for @t{"plain text"} output, and
 ##
 ## @example
 ## See also: @@ref@{arg1@}, @@ref@{arg2@}, ...
 ## @end example
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -35,28 +35,29 @@
 ## The value of @var{c} specifies the number of delimiters to prepend to
 ## each line of data.
 ##
 ## If the argument @code{"-append"} is given, append to the end of
 ## @var{file}.
 ##
 ## In addition, the following keyword value pairs may appear at the end
 ## of the argument list:
+##
 ## @table @asis
 ## @item "append"
 ## Either @samp{"on"} or @samp{"off"}.  See @samp{"-append"} above.
 ##
 ## @item "delimiter"
 ## See @var{delim} above.
 ##
 ## @item "newline"
 ## The character(s) to use to separate each row.  Three special cases
-## exist for this option.  @samp{"unix"} is changed into '\n',
-## @samp{"pc"} is changed into '\r\n', and @samp{"mac"} is changed
-## into '\r'.  Other values for this option are kept as is.
+## exist for this option.  @samp{"unix"} is changed into "\n",
+## @samp{"pc"} is changed into "\r\n", and @samp{"mac"} is changed
+## into "\r".  Other values for this option are kept as is.
 ##
 ## @item "roffset"
 ## See @var{r} above.
 ##
 ## @item "coffset"
 ## See @var{c} above.
 ##
 ## @item "precision"
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -29,16 +29,17 @@
 ## specifiers in @var{format}.  The first word is matched to the first
 ## specifier, the second to the second specifier and so forth.  If there are
 ## more words than specifiers, the process is repeated until all words have
 ## been processed.
 ##
 ## The string @var{format} describes how the words in @var{str} should be
 ## parsed.
 ## It may contain any combination of the following specifiers:
+##
 ## @table @code
 ## @item %s
 ## The word is parsed as a string.
 ##
 ## @itemx %f
 ## @itemx %n
 ## The word is parsed as a number and converted to double.
 ##
@@ -79,24 +80,24 @@
 ## can be read using
 ##
 ## @example
 ## [@var{a}, @var{b}, @var{c}] = strread (@var{str}, "%s %s %f");
 ## @end example
 ##
 ## Optional numeric argument @var{format_repeat} can be used for
 ## limiting the number of items read:
+##
 ## @table @asis
 ## @item -1
 ## (default) read all of the string until the end.
 ##
 ## @item N
 ## Read N times @var{nargout} items.  0 (zero) is an acceptable
 ## value for @var{format_repeat}.
-##
 ## @end table
 ##
 ## The behavior of @code{strread} can be changed via property-value
 ## pairs.  The following properties are recognized:
 ##
 ## @table @asis
 ## @item "commentstyle"
 ## Parts of @var{str} are considered comments and will be skipped.
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -23,17 +23,17 @@
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## expm(A) = I + A + A^2/2! + A^3/3! + @dots{}
+## expm (A) = I + A + A^2/2! + A^3/3! + @dots{}
 ## @end example
 ##
 ## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
 ## uses Ward's diagonal Pad@'e approximation method with three step
 ## preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -21,17 +21,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{s} =} logm (@var{A})
 ## @deftypefnx {Function File} {@var{s} =} logm (@var{A}, @var{opt_iters})
 ## @deftypefnx {Function File} {[@var{s}, @var{iters}] =} logm (@dots{})
 ## Compute the matrix logarithm of the square matrix @var{A}.  The
 ## implementation utilizes a Pad@'e approximant and the identity
 ##
 ## @example
-## logm(@var{A}) = 2^k * logm(@var{A}^(1 / 2^k))
+## logm (@var{A}) = 2^k * logm (@var{A}^(1 / 2^k))
 ## @end example
 ##
 ## The optional argument @var{opt_iters} is the maximum number of square roots
 ## to compute and defaults to 100.  The optional output @var{iters} is the
 ## number of square roots actually computed.
 ## @seealso{expm, sqrtm}
 ## @end deftypefn
 
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -32,18 +32,18 @@
 ##      @result{}  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
 ##      @result{}  z = [ 1, 0; 0, 1 ]
 ## @end group
 ## @end example
 ##
 ## The Hessenberg-triangular decomposition is the first step in
 ## Moler and Stewart's QZ@tie{}decomposition algorithm.
 ##
-## Algorithm taken from Golub and Van Loan, @cite{Matrix Computations, 2nd
-## edition}.
+## Algorithm taken from Golub and Van Loan,
+## @cite{Matrix Computations, 2nd edition}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (A, B)
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -37,17 +37,17 @@
 ## @end example
 ##
 ## @end ifnottex
 ## For example:
 ##
 ## @example
 ## @group
 ## bincoeff (5, 2)
-##      @result{} 10
+##    @result{} 10
 ## @end group
 ## @end example
 ##
 ## In most cases, the @code{nchoosek} function is faster for small
 ## scalar integer arguments.  It also warns about loss of precision for
 ## big arguments.
 ##
 ## @seealso{nchoosek}
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -22,20 +22,20 @@
 ## Print or return a string of the form @var{cpu}-@var{vendor}-@var{os}
 ## that identifies the kind of computer Octave is running on.  If invoked
 ## with an output argument, the value is returned instead of printed.  For
 ## example:
 ##
 ## @example
 ## @group
 ## computer ()
-##      @print{} i586-pc-linux-gnu
+##    @print{} i586-pc-linux-gnu
 ##
 ## x = computer ()
-##      @result{} x = "i586-pc-linux-gnu"
+##    @result{} x = "i586-pc-linux-gnu"
 ## @end group
 ## @end example
 ##
 ## If two output arguments are requested, also return the maximum number
 ## of elements for an array.
 ##
 ## If three output arguments are requested, also return the byte order
 ## of the current system as a character (@code{"B"} for big-endian or
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -28,25 +28,25 @@
 ## bytes
 ## date
 ## isdir
 ## statinfo
 ## @end group
 ## @end example
 ##
 ## @noindent
-## in which @code{statinfo} is the structure returned from @code{stat}.
+## where @code{statinfo} is the structure returned from @code{stat}.
 ##
 ## If @var{directory} is not a directory, return information about the
 ## named @var{filename}.  @var{directory} may be a list of directories
 ## specified either by name or with wildcard characters (like * and ?)
 ## which will be expanded with glob.
 ##
 ## Note that for symbolic links, @code{dir} returns information about
-## the file that a symbolic link points to instead of the link itself.
+## the file that the symbolic link points to instead of the link itself.
 ## However, if the link points to a nonexistent file, @code{dir} returns
 ## information about the link.
 ## @seealso{ls, stat, lstat, readdir, glob, filesep}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## FIXME -- this is quite slow for large directories, so perhaps
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -20,28 +20,28 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{})
 ## Extract a field from a structure (or a nested structure).  For example:
 ##
 ## @example
 ## @group
 ## ss(1,2).fd(3).b = 5;
 ## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
-##      @result{} ans = 5
+##    @result{} 5
 ## @end group
 ## @end example
 ##
 ## Note that the function call in the previous example is equivalent to
 ## the expression
 ##
 ## @example
 ## @group
 ## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
 ## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
-##      @result{} ans = 5
+##    @result{} 5
 ##
 ## @end group
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -119,26 +119,26 @@
 ## @itemx --verbose
 ## Echo commands as they are executed.
 ##
 ## @item file
 ## The file to compile or link.  Recognized file types are
 ##
 ## @example
 ## @group
-##                   .c    C source
-##                   .cc   C++ source
-##                   .C    C++ source
-##                   .cpp  C++ source
-##                   .f    Fortran source (fixed form)
-##                   .F    Fortran source (fixed form)
-##                   .f90  Fortran source (free form)
-##                   .F90  Fortran source (free form)
-##                   .o    object file
-##                   .a    library file
+##    .c    C source
+##    .cc   C++ source
+##    .C    C++ source
+##    .cpp  C++ source
+##    .f    Fortran source (fixed form)
+##    .F    Fortran source (fixed form)
+##    .f90  Fortran source (free form)
+##    .F90  Fortran source (free form)
+##    .o    object file
+##    .a    library file
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -33,59 +33,60 @@
 ## vector
 ## which converts the original name order into the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## s = struct("d", 4, "b", 2, "a", 1, "c", 3);
-## t1 = orderfields(s)
+## t1 = orderfields (s)
 ##      @result{} t1 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
 ## t = struct("d", @{@}, "c", @{@}, "b", "a", @{@});
-## t2 = orderfields(s, t)
+## t2 = orderfields (s, t)
 ##      @result{} t2 =
 ##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
 ## @end group
 ## @group
-## t3 = orderfields(s, [3, 2, 4, 1]);
+## t3 = orderfields (s, [3, 2, 4, 1]);
 ##      @result{} t3 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
-## [t4, p] = orderfields(s, @{"d", "c", "b", "a"@})
-##      @result{} t4 = @{
+## [t4, p] = orderfields (s, @{"d", "c", "b", "a"@})
+##      @result{} t4 =
+##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
-##      p =
-##         1
-##         4
-##         2
-##         3
+##         p =
+##            1
+##            4
+##            2
+##            3
 ## @end group
 ## @end example
 ##
 ## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-By: jwe
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -19,31 +19,30 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} substruct (@var{type}, @var{subs}, @dots{})
 ## Create a subscript structure for use with @code{subsref} or
 ## @code{subsasgn}.  For example:
 ##
 ## @example
 ## @group
-## idx = substruct("()", @{3, ":"@})
+## idx = substruct ("()", @{3, ":"@})
 ##      @result{}
 ##        idx =
 ##        @{
 ##          type = ()
 ##          subs =
 ##          @{
 ##            [1,1] =  3
 ##            [1,2] = :
 ##          @}
 ##        @}
 ## x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
-## subsref(x, idx)
-##      @result{} ans =
-##         7  8  9
+## subsref (x, idx)
+##    @result{} 7  8  9
 ## @end group
 ## @end example
 ## @seealso{subsref, subsasgn}
 ## @end deftypefn
 
 ## Author:  jwe
 
 function retval = substruct (varargin)
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -60,17 +60,17 @@
 ## instead.
 ##
 ## There are times when it is useful to write code that contains
 ## assignments within the condition of a @code{while} or @code{if}
 ## statement.  For example, statements like
 ##
 ## @example
 ## @group
-## while (c = getc())
+## while (c = getc ())
 ##   @dots{}
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## are common in C programming.
 ##
 ## It is possible to avoid all warnings about such statements by
@@ -88,17 +88,17 @@
 ## slip by.
 ##
 ## In such cases, it is possible suppress errors for specific statements by
 ## writing them with an extra set of parentheses.  For example, writing the
 ## previous example as
 ##
 ## @example
 ## @group
-## while ((c = getc()))
+## while ((c = getc ()))
 ##   @dots{}
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will prevent the warning from being printed for this statement, while
 ## allowing Octave to warn about other assignments used in conditional
 ## contexts.
@@ -208,17 +208,17 @@
 ## If the @code{Octave:num-to-str} warning is enable, a warning is
 ## printed for implicit conversions of numbers to their ASCII character
 ## equivalents when strings are constructed using a mixture of strings and
 ## numbers in matrix notation.  For example,
 ##
 ## @example
 ## @group
 ## [ "f", 111, 111 ]
-##      @result{} "foo"
+## @result{} "foo"
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:num-to-str} warning is
 ## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
 ##
 ## @item Octave:possible-matlab-short-circuit-operator
@@ -226,17 +226,17 @@
 ## is enabled, Octave will warn about using the not short circuiting
 ## operators @code{&} and @code{|} inside @code{if} or @code{while}
 ## conditions.  They normally never short circuit, but @sc{matlab} always
 ## short circuits if any logical operators are used in a condition.  You
 ## can turn on the option
 ##
 ## @example
 ## @group
-## do_braindead_shortcircuit_evaluation(1)
+## do_braindead_shortcircuit_evaluation (1)
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## if you would like to enable this short-circuit evaluation in
 ## Octave.  Note that the @code{&&} and @code{||} operators always short
 ## circuit in both Octave and @sc{matlab}, so it's only necessary to
 ## enable @sc{matlab}-style short-circuiting it's too arduous to modify
@@ -290,17 +290,17 @@
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
 ##
 ## @example
 ## @group
 ## "abc" + 0
-##      @result{} 97 98 99
+## @result{} 97 98 99
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
 ## By default, the @code{Octave:str-to-num} warning is disabled.
 ##
 ## @item Octave:undefined-return-values
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -28,35 +28,35 @@
 ## $$
 ##  \min_x {1 \over 2} x^T H x + x^T q
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      min 0.5 x'*H*x + x'*q
-##       x
+## min 0.5 x'*H*x + x'*q
+##  x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @tex
 ## $$
 ##  Ax = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} \leq A_{ub}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      A*x = b
-##      lb <= x <= ub
-##      A_lb <= A_in*x <= A_ub
+## A*x = b
+## lb <= x <= ub
+## A_lb <= A_in*x <= A_ub
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a null-space active-set method.
 ##
 ## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb},
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -28,35 +28,35 @@
 ## $$
 ## \min_x \phi (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      min phi (x)
-##       x
+## min phi (x)
+##  x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
 ## @tex
 ## $$
 ##  g(x) = 0 \qquad h(x) \geq 0 \qquad lb \leq x \leq ub
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##      g(x)  = 0
-##      h(x) >= 0
-##      lb <= x <= ub
+## g(x)  = 0
+## h(x) >= 0
+## lb <= x <= ub
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a sequential quadratic programming method.
 ##
 ## The first argument is the initial guess for the vector @var{x0}.
@@ -97,19 +97,19 @@
 ##         {\partial f(x) \over \partial x_2}, \ldots,
 ##         {\partial f(x) \over \partial x_N} \Bigg)^T
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##                 [ d f(x)   d f(x)        d f(x) ]
-##     transpose ( [ ------   -----   ...   ------ ] )
-##                 [  dx_1     dx_2          dx_N  ]
+##             [ d f(x)   d f(x)        d f(x) ]
+## transpose ( [ ------   -----   ...   ------ ] )
+##             [  dx_1     dx_2          dx_N  ]
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## The fifth and sixth arguments, @var{lb} and @var{ub}, contain lower
 ## and upper bounds on @var{x}.  These must be consistent with the
 ## equality and inequality constraints @var{g} and @var{h}.  If the
 ## arguments are vectors then @var{x}(i) is bound by @var{lb}(i) and
@@ -150,17 +150,17 @@
 ## @example
 ## function r = g (x)
 ##   r = [ sumsq(x)-10;
 ##         x(2)*x(3)-5*x(4)*x(5);
 ##         x(1)^3+x(2)^3+1 ];
 ## endfunction
 ##
 ## function obj = phi (x)
-##   obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
+##   obj = exp (prod (x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
 ## endfunction
 ##
 ## x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];
 ##
 ## [x, obj, info, iter, nf, lambda] = sqp (x0, @@phi, @@g, [])
 ##
 ## x =
 ##
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -61,28 +61,28 @@
 ## bar (randn (1, 100), "facecolor", "r", "edgecolor", "b")
 ## @end example
 ##
 ## @noindent
 ## The color of the bars is taken from the figure's colormap, such that
 ##
 ## @example
 ## @group
-## bar (rand(10,3))
-## colormap (summer ())
+## bar (rand (10, 3));
+## colormap (summer (64));
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will change the colors used for the bars.  The color of bars can also be set
 ## manually using the "facecolor" property as shown below.
 ##
 ## @example
 ## @group
-## h = bar (rand(10,3))
+## h = bar (rand (10, 3));
 ## set (h(1), "facecolor", "r")
 ## set (h(2), "facecolor", "g")
 ## set (h(3), "facecolor", "b")
 ## @end group
 ## @end example
 ##
 ## @seealso{barh, plot}
 ## @end deftypefn
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -43,18 +43,18 @@
 ## the text objects representing each label.  
 ## The "userdata" property of the text objects contains the numerical value of
 ## the contour label.
 ##
 ## An example of the use of @code{clabel} is
 ##
 ## @example
 ## @group
-## [c, h] = contour (peaks(), -4 : 6);
-## clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
+## [c, h] = contour (peaks (), -4 : 6);
+## clabel (c, h, -4:2:6, "fontsize", 12);
 ## @end group
 ## @end example
 ##
 ## @seealso{contour, contourf, contour3, meshc, surfc, text}
 ## @end deftypefn
 
 function retval = clabel (c, varargin)
   label_spacing = 2 * 72;
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -32,17 +32,17 @@
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
-## compass (eig (a))
+## compass (eig (a));
 ## @end group
 ## @end example
 ##
 ## @seealso{polar, quiver, feather, plot}
 ## @end deftypefn
 
 function retval = compass (varargin)
 
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -29,18 +29,18 @@
 ## arguments; see the latter for their interpretation.  The contours are
 ## plotted at the Z level corresponding to their contour.  The set of
 ## contour levels, @var{c}, is only returned if requested.  For example:
 ##
 ## @example
 ## @group
 ## contour3 (peaks (19));
 ## hold on
-## surface (peaks (19), "facecolor", "none", "EdgeColor", "black")
-## colormap hot
+## surface (peaks (19), "facecolor", "none", "EdgeColor", "black");
+## colormap hot;
 ## @end group
 ## @end example
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## Any markers defined by @var{style} are ignored.
 ##
 ## The optional input and output argument @var{h} allows an axis handle to
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -45,19 +45,18 @@
 ## For example:
 ##
 ## @example
 ## @group
 ## x = 0:2;
 ## y = x;
 ## z = x' * y;
 ## contourc (x, y, z, 2:3)
-##      @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
-##      2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
-##
+##    @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
+##         2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
 ## @end group
 ## @end example
 ## @seealso{contour}
 ## @end deftypefn
 
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [cout, lev] = contourc (varargin)
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -33,19 +33,19 @@
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle @var{ax}
 ## is passed as the first argument, the surface is plotted to this set
 ## of axes.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## [x, y, z] = cylinder (10:-1:0,50);
+## [x, y, z] = cylinder (10:-1:0, 50);
 ## surf (x, y, z);
-## title ("a cone")
+## title ("a cone");
 ## @end group
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
   [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder",
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -34,17 +34,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezcontourf, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezcontour (varargin)
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -34,17 +34,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezcontour, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezcontourf (varargin)
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -44,17 +44,17 @@
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created 
 ## surface object.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## An example of a parametrically defined function is
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -45,17 +45,17 @@
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## handle for the created mesh plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezsurfc, ezsurf, ezmesh}
 ## @end deftypefn
 
 function retval = ezmeshc (varargin)
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -30,17 +30,17 @@
 ## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 500 points.
 ##
 ## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
 ## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
 ## < 2*pi} with 60 by 60 in the mesh.  For example:
 ##
 ## @example
-## ezplot (@@(@var{x}, @var{y}) @var{x} .^ 2 - @var{y} .^ 2 - 1)
+## ezplot (@@(@var{x}, @var{y}) @var{x}.^2 - @var{y}.^2 - 1)
 ## @end example
 ##
 ## If two functions are passed as strings, inline functions or function
 ## handles, then the parametric function
 ##
 ## @example
 ## @group
 ## @var{x} = @var{fx} (@var{t})
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -44,28 +44,28 @@
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## An example of a parametrically defined function is
 ##
 ## @example
 ## @group
-## fx = @@(s,t) cos (s) .* cos(t);
-## fy = @@(s,t) sin (s) .* cos(t);
-## fz = @@(s,t) sin(t);
+## fx = @@(s,t) cos (s) .* cos (t);
+## fy = @@(s,t) sin (s) .* cos (t);
+## fz = @@(s,t) sin (t);
 ## ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezmesh, ezsurfc, ezmeshc}
 ## @end deftypefn
 
 function retval = ezsurf (varargin)
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -45,17 +45,17 @@
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## for the created surface plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
-## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezmeshc, ezsurf, ezmesh}
 ## @end deftypefn
 
 function retval = ezsurfc (varargin)
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -31,18 +31,18 @@
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
-## phi = [0 : 15 : 360] * pi / 180;
-## feather (sin (phi), cos (phi))
+## phi = [0 : 15 : 360] * pi/180;
+## feather (sin (phi), cos (phi));
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, quiver, compass}
 ## @end deftypefn
 
 function retval = feather (varargin)
 
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -14,54 +14,54 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findobj ()
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{prop_name})
-## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{prop_name}, @var{pattern})
-## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj ("-property", @var{prop_name})
+## @deftypefnx {Function File} {@var{h} =} findobj ("-regexp", @var{prop_name}, @var{pattern})
+## @deftypefnx {Function File} {@var{h} =} findobj ("flat", @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, "-depth", @var{d}, @dots{})
 ## Find graphics object with specified property values.  The simplest form is
 ##
 ## @example
-## findobj (@var{prop_name}, @var{prop_Value})
+## findobj (@var{prop_name}, @var{prop_value})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name
-## @var{prop_name} and the name @var{prop_Value}.  The search can be limited
+## @var{prop_name} and the name @var{prop_value}.  The search can be limited
 ## to a particular object or set of objects and their descendants by
 ## passing a handle or set of handles @var{h} as the first argument to
 ## @code{findobj}.
 ##
 ## The depth of hierarchy of objects to which to search to can be limited
-## with the '-depth' argument.  To limit the number depth of the hierarchy
+## with the "-depth" argument.  To limit the number depth of the hierarchy
 ## to search to @var{d} generations of children, and example is
 ##
 ## @example
-## findobj (@var{h}, '-depth', @var{d}, @var{prop_Name}, @var{prop_Value})
+## findobj (@var{h}, "-depth", @var{d}, @var{prop_name}, @var{prop_value})
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0, limits the search to the set of object
-## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the '-flat'
+## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the "-flat"
 ## argument.
 ##
-## A specified logical operator may be applied to the pairs of @var{prop_Name}
-## and @var{prop_Value}.  The supported logical operators are '-and', '-or',
-## '-xor', '-not'.
+## A specified logical operator may be applied to the pairs of @var{prop_name}
+## and @var{prop_value}.  The supported logical operators are "-and", "-or",
+## "-xor", "-not".
 ##
 ## The objects may also be matched by comparing a regular expression to the
 ## property values, where property values that match @code{regexp
-## (@var{prop_Value}, @var{pattern})} are returned.  Finally, objects may be
-## matched by property name only, using the '-property' option.
+## (@var{prop_value}, @var{pattern})} are returned.  Finally, objects may be
+## matched by property name only, using the "-property" option.
 ## @seealso{get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function h = findobj (varargin)
 
   depth = NaN;
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -28,18 +28,18 @@
 ## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
 ## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
 ## plot, and if @var{tol} is an integer it is assumed that it defines the
 ## number points to use in the plot.  The @var{fmt} argument is passed
 ## to the plot command.
 ##
 ## @example
 ## @group
-##    fplot ("cos", [0, 2*pi])
-##    fplot ("[cos(x), sin(x)]", [0, 2*pi])
+## fplot ("cos", [0, 2*pi])
+## fplot ("[cos(x), sin(x)]", [0, 2*pi])
 ## @end group
 ## @end example
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function fplot (fn, limits, n, fmt)
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -46,27 +46,27 @@
 ## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
 ##
 ## The histogram's appearance may be modified by specifying property/value
 ## pairs, @var{prop} and @var{val} pairs.  For example the face and edge
 ## color may be modified.
 ##
 ## @example
 ## @group
-## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b")
+## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## The histograms colors also depend upon the colormap.
 ##
 ## @example
 ## @group
-## hist (rand (10, 3))
-## colormap (summer ())
+## hist (rand (10, 3));
+## colormap (summer ());
 ## @end group
 ## @end example
 ##
 ## @seealso{bar}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -45,53 +45,53 @@
 ## data @var{v}.  Finally, if no output argument is given then directly
 ## change the colors of a patch that is given by the patch handle
 ## @var{p}.
 ##
 ## For example:
 ##
 ## @example
 ## function [] = isofinish (p)
-##   set (gca, "PlotBoxAspectRatioMode", "manual", \
-##        "PlotBoxAspectRatio", [1 1 1]);
+##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
+##             "PlotBoxAspectRatio", [1 1 1]);
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "flat");
 ##   ## light ("Position", [1 1 5]); ## Available with JHandles
 ## endfunction
 ##
-## N = 15;    ## Increase number of vertices in each direction
-## iso = .4;  ## Change isovalue to .1 to display a sphere
+## N = 15;    # Increase number of vertices in each direction
+## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-## figure (); ## Open another figure window
+## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## cdat = rand (size (c));       ## Compute random patch color data
-## isocolors (x, y, z, cdat, p); ## Directly set colors of patch
-## isofinish (p);                ## Call user function isofinish
+## cdat = rand (size (c));       # Compute random patch color data
+## isocolors (x, y, z, cdat, p); # Directly set colors of patch
+## isofinish (p);                # Call user function isofinish
 ##
-## subplot (2, 2, 2); view (-38, 20);
+## subplot (2,2,2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
-## cdat = isocolors (x, y, z, c, v); ## Compute color data vertices
-## set (p, "FaceVertexCData", cdat); ## Set color data manually
+## cdat = isocolors (x, y, z, c, v); # Compute color data vertices
+## set (p, "FaceVertexCData", cdat); # Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 3); view (-38, 20);
+## subplot (2,2,3); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## cdat = isocolors (r, g, b, c, p); ## Compute color data patch
-## set (p, "FaceVertexCData", cdat); ## Set color data manually
+## cdat = isocolors (r, g, b, c, p); # Compute color data patch
+## set (p, "FaceVertexCData", cdat); # Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 4); view (-38, 20);
+## subplot (2,2,4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## r = g = b = repmat ([1:N] / N, [N, 1, N]); ## Black to white
+## r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
 ## cdat = isocolors (x, y, z, r, g, b, v);
 ## set (p, "FaceVertexCData", cdat);
 ## isofinish (p);
 ## @end example
 ##
 ## @seealso{isosurface, isonormals}
 ##
 ## @end deftypefn
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -45,51 +45,51 @@
 ## given by the patch handle @var{p}.
 ##
 ## For example:
 ## @c Set example in small font to prevent overfull line
 ##
 ## @smallexample
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode", "manual", ...
-##             "PlotBoxAspectRatio",[1 1 1]);
-##   set (p, "VertexNormals", -get(p,"VertexNormals")); # Revert normals
+##             "PlotBoxAspectRatio", [1 1 1]);
+##   set (p, "VertexNormals", -get (p,"VertexNormals")); # Revert normals
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "phong");
 ##   ## light ("Position", [1 1 5]); # Available with JHandles
 ## endfunction
 ##
 ## N = 15;    # Increase number of vertices in each direction
 ## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v, cdat] = isosurface (x, y, z, c, iso, y);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isofinish (p); ## Call user function isofinish
 ##
-## subplot (2, 2, 2); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,2); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, p); # Directly modify patch
 ## isofinish (p);
 ##
-## subplot (2, 2, 3); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,3); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## n = isonormals (x, y, z, c, v); # Compute normals of isosurface
 ## set (p, "VertexNormals", n);    # Manually set vertex normals
 ## isofinish (p);
 ##
-## subplot (2, 2, 4); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
+## subplot (2,2,4); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, v, "negate"); # Use reverse directly
 ## isofinish (p);
 ## @end smallexample
 ##
 ## @seealso{isosurface, isocolors}
 ## @end deftypefn
 
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -75,44 +75,44 @@
 ## @smallexample
 ## N = 15;    # Increase number of vertices in each direction
 ## iso = .4;  # Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); # Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20);
+## subplot (2,2,1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "green", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]); # Available with the JHandles package
 ##
-## subplot (2, 2, 2); view (-38, 20);
+## subplot (2,2,2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "none", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
-## subplot (2, 2, 3); view (-38, 20);
+## subplot (2,2,3); view (-38, 20);
 ## [f, v, c] = isosurface (x, y, z, c, iso, y);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
 ##            "FaceColor", "interp", "EdgeColor", "none");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ##
-## subplot (2, 2, 4); view (-38, 20);
-## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
+## subplot (2,2,4); view (-38, 20);
+## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
 ##            "FaceColor", "interp", "EdgeColor", "blue");
-## set (gca, "PlotBoxAspectRatioMode","manual", ...
+## set (gca, "PlotBoxAspectRatioMode", "manual", ...
 ##           "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]);
 ## @end smallexample
 ##
 ## @seealso{isonormals, isocolors}
 ## @end deftypefn
 
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -23,19 +23,19 @@
 ## string of cell string array by @var{prop} and the objects containing
 ## these properties by the handle array @var{h}.
 ##
 ## An example of the use of linkprop is
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
-## subplot (1, 2, 1);
+## subplot (1,2,1);
 ## h1 = plot (x, sin (x));
-## subplot (1, 2, 2);
+## subplot (1,2,2);
 ## h2 = plot (x, cos (x));
 ## hlink = linkprop ([h1, h2], @{"color","linestyle"@});
 ## set (h1, "color", "green");
 ## set (h2, "linestyle", "--");
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -69,19 +69,19 @@
 ## @example
 ## plot3 (@var{x1}, @var{c1}, "", @var{c2}, "", @dots{})
 ## @end example
 ##
 ## An example of the use of @code{plot3} is
 ##
 ## @example
 ## @group
-##    z = [0:0.05:5];
-##    plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
-##    plot3 (z, exp(2i*pi*z), ";complex sinusoid;");
+## z = [0:0.05:5];
+## plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
+## plot3 (z, exp (2i*pi*z), ";complex sinusoid;");
 ## @end group
 ## @end example
 ## @seealso{plot, xlabel, ylabel, zlabel, title, print}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ##         (modified from __plt__.m)
 
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -49,19 +49,17 @@
 ## graphics objects in the scatter plots, whereas @var{ax} returns the
 ## handles to the scatter plot axis objects.  @var{bigax} is a hidden
 ## axis object that surrounds the other axes, such that the commands
 ## @code{xlabel}, @code{title}, etc., will be associated with this hidden
 ## axis.  Finally @var{p} returns the graphics objects associated with
 ## the histogram and @var{pax} the corresponding axes objects.
 ##
 ## @example
-## @group
-## plotmatrix (randn (100, 3), 'g+')
-## @end group
+## plotmatrix (randn (100, 3), "g+")
 ## @end example
 ##
 ## @end deftypefn
 
 function [h, ax, bigax, p, pax] = plotmatrix (varargin)
 
   [bigax2, varargin, nargin] = __plt_get_axis_arg__ ("plotmatrix", varargin{:});
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -229,30 +229,30 @@
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ##
 ## Example: Print to a file, using the svg device.
 ##
 ## @example
 ## @group
-## figure (1)
-## clf ()
-## surf (peaks)
+## figure (1);
+## clf ();
+## surf (peaks);
 ## print -dsvg figure1.svg
 ## @end group
 ## @end example
 ##
 ## Example: Print to an HP Deskjet 550C.
 ##
 ## @example
 ## @group
-## figure (1)
-## clf ()
-## surf (peaks)
+## figure (1);
+## clf ();
+## surf (peaks);
 ## print -dcdj550
 ## @end group
 ## @end example
 ##
 ## @seealso{figure, orient, saveas}
 ## @end deftypefn
 
 function print (varargin)
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -44,17 +44,17 @@
 ## beyond other surface and geometry stuff at Paul Bourke's website
 ## @uref{http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## N = 20;
-## lin = linspace(0, 2, N);
+## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ##
 ## c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 ## [t, p] = __marching_cube__ (x, y, z, c, .5);
 ##
 ## figure ();
 ## trimesh (t, p(:,1), p(:,2), p(:,3));
 ## @end group
@@ -65,21 +65,21 @@
 ##
 ## @example
 ## @group
 ## figure (); view (-38, 20);
 ## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, \
 ##             "FaceColor", "interp", "EdgeColor", "none");
 ##
 ## ## Revert normals
-## set (pa, "VertexNormals", -get(pa, "VertexNormals"));
+## set (pa, "VertexNormals", -get (pa, "VertexNormals"));
 ##
 ## ## Set lightning (available with the JHandles package)
 ## # set (pa, "FaceLighting", "gouraud");
-## # light( "Position", [1 1 5]);
+## # light ( "Position", [1 1 5]);
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [T, p, col] = __marching_cube__ (xx, yy, zz, c, iso, colors)
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -37,18 +37,18 @@
 ## An example of the use of @code{refreshdata} is:
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
 ## y = sin (x);
 ## plot (x, y, "ydatasource", "y");
 ## for i = 1 : 100
-##   pause (0.1)
-##   y = sin (x + 0.1 * i);
+##   pause (0.1);
+##   y = sin (x + 0.1*i);
 ##   refreshdata ();
 ## endfor
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function refreshdata (h, workspace)
 
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -34,17 +34,17 @@
 ## line objects representing each histogram.
 ##
 ## If two output arguments are requested then, rather than plotting the
 ## histogram, the polar vectors necessary to plot the histogram are
 ## returned.
 ##
 ## @example
 ## @group
-## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
+## [r, t] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
 ## polar (r, t);
 ## @end group
 ## @end example
 ##
 ## @seealso{polar, compass, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -45,20 +45,19 @@
 ## @end table
 ##
 ## All device formats specified in @code{print} may also be used.  If
 ## @var{fmt} is omitted it is extracted from the extension of @var{filename}.
 ## The default format is @code{"pdf"}.
 ##
 ## @example
 ## @group
-## figure (1);
 ## clf ();
 ## surf (peaks);
-## saveas(1, "figure1.png");
+## saveas (1, "figure1.png");
 ## @end group
 ## @end example
 ##
 ## @seealso{print}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -34,42 +34,42 @@
 ## The default color is @code{"b"} (blue).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.  The line style can
 ## be altered by the @code{linespec} argument in the same manner as the
 ## @code{plot} command.  For example,
 ##
 ## @example
 ## @group
 ## x = 1:10;
-## y = ones (1, length (x))*2.*x;
+## y = 2*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ##
 ## The optional return value @var{h} is a vector of "stem series" graphics
 ## handles with one handle per column of the variable @var{y}.  The
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example,
 ##
 ## @example
 ## @group
-## x = [0 : 10]';
+## x = [0:10]';
 ## y = [sin(x), cos(x)]
 ## h = stem (x, y);
 ## set (h(2), "color", "g");
 ## set (h(1), "basevalue", -1)
 ## @end group
 ## @end example
 ##
 ## @noindent
-## changes the color of the second "stem series"  and moves the base line
+## changes the color of the second "stem series" and moves the base line
 ## of the first.
 ## @seealso{bar, barh, plot}
 ## @end deftypefn
 
 ## Author: Michel D. Schmid <michaelschmid@users.sourceforge.net>
 ## Adapted-by: jwe
 
 function h = stem (varargin)
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -51,17 +51,17 @@
 ## +-----+-----+-----+
 ## @end group
 ## @end example
 ##
 ## @var{index} may be a vector.  In which case, the new axis will enclose
 ## the grid locations specified.  The first demo illustrates an example:
 ##
 ## @example
-## @code{demo ("subplot", 1)}
+## demo ("subplot", 1)
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{axes, plot}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -52,17 +52,17 @@
 ## impression of a lighted surface.  Please note: the alternative "light"
 ## mode, which creates a light object to illuminate the surface is not
 ## implemented (yet).
 ##
 ## Example:
 ##
 ## @example
 ## @group
-## colormap (bone);
+## colormap (bone (64));
 ## surfl (peaks);
 ## shading interp;
 ## @end group
 ## @end example
 ## @seealso{surf, diffuse, specular, surface}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
 ## Find the vectors normal to a meshgridded surface.  The meshed gridded
 ## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
 ## @group
-## [@var{x}, @var{y}] = meshgrid (1:size(@var{z}, 1),
-##                      1:size(@var{z}, 2));
+## [@var{x}, @var{y}] = meshgrid (1:size (@var{z}, 1),
+##                    1:size (@var{z}, 2));
 ## @end group
 ## @end example
 ##
 ## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -59,22 +59,22 @@
 ## current position.  It is ignored for top level entries.
 ##
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## f = uimenu("label", "&File", "accelerator", "f");
-## e = uimenu("label", "&Edit", "accelerator", "e");
-## uimenu(f, "label", "Close", "accelerator", "q", ...
-##           "callback", "close (gcf)");
-## uimenu(e, "label", "Toggle &Grid", "accelerator", "g", ...
-##           "callback", "grid (gca)");
+## f = uimenu ("label", "&File", "accelerator", "f");
+## e = uimenu ("label", "&Edit", "accelerator", "e");
+## uimenu (f, "label", "Close", "accelerator", "q", ...
+##            "callback", "close (gcf)");
+## uimenu (e, "label", "Toggle &Grid", "accelerator", "g", ...
+##            "callback", "grid (gca)");
 ## @end group
 ## @end example
 ## @seealso{figure}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function hui = uimenu (varargin)
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -33,20 +33,20 @@
 ## poles.  @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
 ## @code{@var{p}(@var{idxp}(n))}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## p = [2 3 1 1 2];
-## [m, n] = mpoles(p);
-##   @result{} m = [1; 1; 2; 1; 2]
-##   @result{} n = [2; 5; 1; 4; 3]
-##   @result{} p(n) = [3, 2, 2, 1, 1]
+## [m, n] = mpoles (p)
+##    @result{} m = [1; 1; 2; 1; 2]
+##    @result{} n = [2; 5; 1; 4; 3]
+##    @result{} p(n) = [3, 2, 2, 1, 1]
 ## @end group
 ## @end example
 ##
 ## @seealso{residue, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: Sept 30, 2007
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -22,20 +22,20 @@
 ## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
 ## the characteristic polynomial of @var{A}.  For example,
 ## the following code finds the eigenvalues of @var{A} which are the roots of
 ## @code{poly (@var{A})}.
 ##
 ## @example
 ## @group
-## roots(poly(eye(3)))
-## @result{} 1.00001 + 0.00001i
-## @result{} 1.00001 - 0.00001i
-## @result{} 0.99999 + 0.00000i
+## roots (poly (eye (3)))
+##     @result{} 1.00001 + 0.00001i
+##        1.00001 - 0.00001i
+##        0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyaffine (@var{f}, @var{mu})
 ## Return the coefficients of the polynomial vector @var{f} after an affine
 ## transformation.  If @var{f} is the vector representing the polynomial f(x),
 ## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
 ## representing:
 ##
 ## @example
-## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
+## g(x) = f( (x - @var{mu}(1)) / @var{mu}(2) )
 ## @end example
 ##
 ## @seealso{polyval, polyfit}
 ## @end deftypefn
 
 
 function g = polyaffine (f, mu)
 
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -20,26 +20,26 @@
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
 ## Find the greatest common divisor of two polynomials.  This is equivalent
 ## to the polynomial found by multiplying together all the common roots.
 ## Together with deconv, you can reduce a ratio of two polynomials.
 ## The tolerance @var{tol} defaults to @code{sqrt(eps)}.
 ##
-## @strong{Caution:} This is a numerically unstable algorithm and should not be used on large polynomials.
+## @strong{Caution:} This is a numerically unstable algorithm and should not
+## be used on large polynomials.
 ##
 ## Example code:
 ##
 ## @example
 ## @group
-## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
+## polygcd (poly (1:8), poly (3:12)) - poly (3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
-## deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
-##   - poly(1:2)
+## deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly(1:2)
 ## @result{} [ 0, 0, 0 ]
 ## @end group
 ## @end example
 ## @seealso{poly, roots, conv, deconv, residue}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {@var{str} =} polyout (@dots{})
 ## Write formatted polynomial
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
+## c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
 ## and return it as a string or write it to the screen (if @var{nargout} is
 ## zero).  @var{x} defaults to the string @code{"s"}.
 ## @seealso{polyreduce}
 ## @end deftypefn
 
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -28,40 +28,40 @@
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##  B(s)    M       r(m)         N
-##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
-##  A(s)   m=1 (s-p(m))^e(m)    i=1
+## B(s)    M       r(m)         N
+## ---- = SUM -------------  + SUM k(i)*s^(N-i)
+## A(s)   m=1 (s-p(m))^e(m)    i=1
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## where @math{M} is the number of poles (the length of the @var{r},
 ## @var{p}, and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
 ## representing the direct contribution, and the @var{e} vector specifies
 ## the multiplicity of the m-th residue's pole.
 ##
 ## For example,
 ##
 ## @example
 ## @group
 ## b = [1, 1, 1];
 ## a = [1, -5, 8, -4];
-## [r, p, k, e] = residue (b, a);
-##      @result{} r = [-2; 7; 3]
-##      @result{} p = [2; 2; 1]
-##      @result{} k = [](0x0)
-##      @result{} e = [1; 2; 1]
+## [r, p, k, e] = residue (b, a)
+##    @result{} r = [-2; 7; 3]
+##    @result{} p = [2; 2; 1]
+##    @result{} k = [](0x0)
+##    @result{} e = [1; 2; 1]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
 ## @tex
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
@@ -90,53 +90,52 @@
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## r = [-2; 7; 3];
 ## p = [2; 2; 1];
 ## k = [1, 0];
-## [b, a] = residue (r, p, k);
-##      @result{} b = [1, -5, 9, -3, 1]
-##      @result{} a = [1, -5, 8, -4]
+## [b, a] = residue (r, p, k)
+##    @result{} b = [1, -5, 9, -3, 1]
+##    @result{} a = [1, -5, 8, -4]
 ##
 ## where mpoles is used to determine e = [1; 2; 1]
-##
 ## @end group
 ## @end example
 ##
 ## Alternatively the multiplicity may be defined explicitly, for example,
 ##
 ## @example
 ## @group
 ## r = [7; 3; -2];
 ## p = [2; 1; 2];
 ## k = [1, 0];
 ## e = [2; 1; 1];
-## [b, a] = residue (r, p, k, e);
-##      @result{} b = [1, -5, 9, -3, 1]
-##      @result{} a = [1, -5, 8, -4]
+## [b, a] = residue (r, p, k, e)
+##    @result{} b = [1, -5, 9, -3, 1]
+##    @result{} a = [1, -5, 8, -4]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
 ## @tex
 ## $$
 ## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
-##    ----- + ------- + ----- + s = --------------------------
-##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
+##  -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
+## ----- + ------- + ----- + s = --------------------------
+## (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{mpoles, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -25,43 +25,43 @@
 ## true (1) if @code{A(i,j)} is in @var{s} and false (0) if it is not.  If a
 ## second output argument is requested, the index into @var{s} of each of the
 ## matching elements is also returned.
 ##
 ## @example
 ## @group
 ## a = [3, 10, 1];
 ## s = [0:9];
-## [tf, s_idx] = ismember (a, s);
+## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0, 1]
 ##      @result{} s_idx = [4, 0, 2]
 ## @end group
 ## @end example
 ##
 ## The inputs, @var{A} and @var{s}, may also be cell arrays.
 ##
 ## @example
 ## @group
 ## a = @{'abc'@};
 ## s = @{'abc', 'def'@};
-## [tf, s_idx] = ismember (a, s);
+## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
 ## With the optional third argument @code{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
 ## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
-## [tf, s_idx] = ismember(a, s, 'rows');
+## [tf, s_idx] = ismember(a, s, "rows")
 ##      @result{} tf = logical ([1; 0; 1])
 ##      @result{} s_idx = [2; 0; 5];
 ## @end group
 ## @end example
 ##
 ## @seealso{unique, union, intersect, setxor, setdiff}
 ## @end deftypefn
 
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -22,38 +22,37 @@
 ## @deftypefnx {Function File} {} union (@var{a}, @var{b}, "rows")
 ## Return the set of elements that are in either of the sets @var{a} and
 ## @var{b}.  @var{a}, @var{b} may be cell arrays of string(s).
 ## For example:
 ##
 ## @example
 ## @group
 ## union ([1, 2, 4], [2, 3, 5])
-##      @result{} [1, 2, 3, 4, 5]
+##     @result{} [1, 2, 3, 4, 5]
 ## @end group
 ## @end example
 ##
 ## If the optional third input argument is the string "rows" each row of
 ## the matrices @var{a} and @var{b} will be considered an element of sets.
 ## For example:
 ##
 ## @example
 ## @group
-## union([1, 2; 2, 3], [1, 2; 3, 4], "rows")
-##      @result{}  1   2
-##     2   3
-##     3   4
+## union ([1, 2; 2, 3], [1, 2; 3, 4], "rows")
+##    @result{}  1   2
+##        2   3
+##        3   4
 ## @end group
 ## @end example
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} union (@var{a}, @var{b})
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)} and
-## @code{b(ib)} are
-## disjoint sets whose union is @var{c}.
+## @code{b(ib)} are disjoint sets whose union is @var{c}.
 ##
 ## @seealso{intersect, setdiff, unique}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [y, ia, ib] = union (a, b, varargin)
 
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -119,87 +119,87 @@
 ## verifying this assumption.
 ## @end itemize
 ##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A)
 ##
 ## @example
 ## @group
-##      n = 10;
-##      A = diag (sparse (1:n));
-##      b = rand (n, 1);
-##      [l, u, p, q] = luinc (A, 1.e-3);
+## n = 10;
+## A = diag (sparse (1:n));
+## b = rand (n, 1);
+## [l, u, p, q] = luinc (A, 1.e-3);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ##
 ## @example
-##   x = pcg(A,b)
+## x = pcg (A,b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcg} with a function which computes
 ## @code{@var{A} * @var{x}}
 ##
 ## @example
 ## @group
-##   function y = apply_a (x)
-##     y = [1:N]'.*x;
-##   endfunction
+## function y = apply_a (x)
+##   y = [1:N]' .* x;
+## endfunction
 ##
-##   x = pcg ("apply_a", b)
+## x = pcg ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}
 ##
 ## @example
-## x = pcg (A, b, 1.e-6, 500, l*u);
+## x = pcg (A, b, 1.e-6, 500, l*u)
 ## @end example
 ##
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
 ## Faster than @sc{Example 3} since lower and upper triangular matrices
 ## are easier to invert
 ##
 ## @example
-## x = pcg (A, b, 1.e-6, 500, l, u);
+## x = pcg (A, b, 1.e-6, 500, l, u)
 ## @end example
 ##
 ## @sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
 ##
 ## @example
 ## @group
-##   function y = apply_m (x)
-##     k = floor (length (x) - 2);
-##     y = x;
-##     y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x)
+##   k = floor (length (x) - 2);
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec, eigest] = ...
-##                      pcg (A, b, [], [], "apply_m");
-##   semilogy (1:iter+1, resvec);
+## [x, flag, relres, iter, resvec, eigest] = ...
+##                    pcg (A, b, [], [], "apply_m");
+## semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 6:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ##
 ## @example
 ## @group
-##   function y = apply_M (x, varargin)
+## function y = apply_M (x, varargin)
 ##   K = varargin@{1@};
 ##   y = x;
-##   y(1:K) = x(1:K)./[1:K]';
-##   endfunction
+##   y(1:K) = x(1:K) ./ [1:K]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec, eigest] = ...
-##        pcg (A, b, [], [], "apply_m", [], [], 3)
+## [x, flag, relres, iter, resvec, eigest] = ...
+##      pcg (A, b, [], [], "apply_m", [], [], 3)
 ## @end group
 ## @end example
 ##
 ## References:
 ##
 ## @enumerate
 ## @item
 ## C.T. Kelley, @cite{Iterative Methods for Linear and Nonlinear Equations},
@@ -211,18 +211,17 @@
 ## available online at @url{http://www-users.cs.umn.edu/~saad/books.html}
 ## @end enumerate
 ##
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 ## Modified by: Vittoria Rezzonico <vittoria.rezzonico@epfl.ch>
-##    - Add the ability to provide the pre-conditioner as two separate
-## matrices
+##  - Add the ability to provide the pre-conditioner as two separate matrices
 
 function [x, flag, relres, iter, resvec, eigest] = pcg (A, b, tol, maxit, m1, m2, x0, varargin)
 
   ## M = M1*M2
 
   if (nargin < 7 || isempty (x0))
     x = zeros (size (b));
   else
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -96,71 +96,72 @@
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
 ##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A)
 ##
 ## @example
 ## @group
-##      n = 10;
-##      A = sparse (diag (1:n));
-##      b = rand (N, 1);
+## n = 10;
+## A = sparse (diag (1:n));
+## b = rand (N, 1);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ##
 ## @example
-##   x = pcr (A, b)
+## x = pcr (A, b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
-##   function y = apply_a (x)
-##     y = [1:10]'.*x;
-##   endfunction
+## function y = apply_a (x)
+##   y = [1:10]' .* x;
+## endfunction
 ##
-##   x = pcr ("apply_a", b)
+## x = pcr ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
 ##
 ## @example
 ## @group
-##   function y = apply_m (x)
-##     k = floor (length(x)-2);
-##     y = x;
-##     y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x)
+##   k = floor (length (x) - 2);
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (A, b, [], [], "apply_m")
-##   semilogy([1:iter+1], resvec);
+## [x, flag, relres, iter, resvec] = ...
+##                    pcr (A, b, [], [], "apply_m")
+## semilogy ([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ##
 ## @example
 ## @group
-##   function y = apply_m (x, varargin)
-##     k = varargin@{1@};
-##     y = x; y(1:k) = x(1:k)./[1:k]';
-##   endfunction
+## function y = apply_m (x, varargin)
+##   k = varargin@{1@};
+##   y = x;
+##   y(1:k) = x(1:k) ./ [1:k]';
+## endfunction
 ##
-##   [x, flag, relres, iter, resvec] = ...
-##                      pcr (A, b, [], [], "apply_m"', [], 3)
+## [x, flag, relres, iter, resvec] = ...
+##                    pcr (A, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
 ##
 ## References:
 ##
 ##      [1] W. Hackbusch, @cite{Iterative Solution of Large Sparse Systems of
 ##      Equations}, section 9.5.4; Springer, 1994
 ##
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -17,29 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} spaugment (@var{A}, @var{c})
 ## Create the augmented matrix of @var{A}.  This is given by
 ##
 ## @example
 ## @group
-## [@var{c} * eye(@var{m}, @var{m}),@var{A}; @var{A}', zeros(@var{n},
-## @var{n})]
+## [@var{c} * eye(@var{m}, @var{m}), @var{A};
+##             @var{A}', zeros(@var{n}, @var{n})]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## This is related to the least squares solution of
-## @code{@var{A} \\ @var{b}}, by
+## @code{@var{A} \ @var{b}}, by
 ##
 ## @example
 ## @group
-## @var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
-## columns(@var{b})]
+## @var{s} * [ @var{r} / @var{c}; x] = [ @var{b}, zeros(@var{n}, columns(@var{b})) ]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## where @var{r} is the residual error
 ##
 ## @example
 ## @var{r} = @var{b} - @var{A} * @var{x}
@@ -48,17 +47,17 @@
 ## As the matrix @var{s} is symmetric indefinite it can be factorized
 ## with @code{lu}, and the minimum norm solution can therefore be found
 ## without the need for a @code{qr} factorization.  As the residual
 ## error will be @code{zeros (@var{m}, @var{m})} for under determined
 ## problems, and example can be
 ##
 ## @example
 ## @group
-## m = 11; n = 10; mn = max(m ,n);
+## m = 11; n = 10; mn = max (m, n);
 ## A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
 ##              [-1, 0, 1], m, n);
 ## x0 = A \ ones (m,1);
 ## s = spaugment (A);
 ## [L, U, P, Q] = lu (s);
 ## x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 ## x1 = x1(end - n + 1 : end);
 ## @end group
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -37,17 +37,17 @@
 ## diagonal, and positive values of @var{c} diagonals above the main
 ## diagonal.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
-## @result{}    5 10  0  0
+##    @result{} 5 10  0  0
 ##       1  6 11  0
 ##       0  2  7 12
 ##       0  0  3  8
 ##       0  0  0  4
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -24,19 +24,19 @@
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}] =} svds (@dots{})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
 ## Find a few singular values of the matrix @var{A}.  The singular values
 ## are calculated using
 ##
 ## @example
 ## @group
-## [@var{m}, @var{n}] = size(@var{A})
-## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{A};
-##                     @var{A}', sparse(@var{n}, @var{n})])
+## [@var{m}, @var{n}] = size (@var{A});
+## @var{s} = eigs ([sparse(@var{m}, @var{m}), @var{A};
+##                      @var{A}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular values
 ## of @var{A}.  The number of singular values to calculate is given by @var{k}
 ## and defaults to 6.
 ##
 ## The argument @var{sigma} specifies which singular values to find.  When
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -38,17 +38,17 @@
 ## P^m_n(x) = (-1)^m (1-x^2)^{m/2}{d^m\over {dx^m}}P_n (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  m        m       2  m/2   d^m
-## P(x) = (-1) * (1-x  )    * ----  P (x)
+## P(x) = (-1) * (1-x  )    * ----  P(x)
 ##  n                         dx^m   n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## with Legendre polynomial of degree @var{n}:
@@ -57,30 +57,30 @@
 ## $$
 ## P(x) = {1\over{2^n n!}}\biggl({d^n\over{dx^n}}(x^2 - 1)^n\biggr)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##           1     d^n   2    n
-## P (x) = ------ [----(x - 1)  ]
-##  n      2^n n!  dx^n
+##           1    d^n   2    n
+## P(x) = ------ [----(x - 1) ]
+##  n     2^n n!  dx^n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## @code{legendre (3, [-1.0, -0.9, -0.8])} returns the matrix:
 ##
 ## @example
 ## @group
-##  x  |   -1.0   |   -0.9   |  -0.8
+##  x  |   -1.0   |   -0.9   |   -0.8
 ## ------------------------------------
 ## m=0 | -1.00000 | -0.47250 | -0.08000
 ## m=1 |  0.00000 | -1.99420 | -1.98000
 ## m=2 |  0.00000 | -2.56500 | -4.32000
 ## m=3 |  0.00000 | -1.24229 | -3.24000
 ## @end group
 ## @end example
 ##
@@ -95,38 +95,38 @@
 ## $$
 ## SP^0_n (x) = P^0_n (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   0       0
-## SP (x) = P (x)
-##   n       n
+##   0      0
+## SP(x) = P(x)
+##   n      n
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## For Legendre functions of degree n and order m:
 ##
 ## @tex
 ## $$
 ## SP^m_n (x) = P^m_n (x)(-1)^m\biggl({2(n-m)!\over{(n+m)!}}\biggl)^{0.5}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   m       m          m    2(n-m)! 0.5
-## SP (x) = P (x) * (-1)  * [-------]
-##   n       n               (n+m)!
+##   m      m         m    2(n-m)! 0.5
+## SP(x) = P(x) * (-1)  * [-------]
+##   n      n              (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## If the optional argument @var{normalization} is @code{"norm"},
 ## compute the fully normalized associated Legendre function.
 ## The fully normalized associated Legendre function is related
@@ -138,19 +138,19 @@
 ## $$
 ## NP^m_n (x) = P^m_n (x)(-1)^m\biggl({(n+0.5)(n-m)!\over{(n+m)!}}\biggl)^{0.5}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##   m       m          m    (n+0.5)(n-m)! 0.5
-## NP (x) = P (x) * (-1)  * [-------------]
-##   n       n                   (n+m)!
+##   m      m         m    (n+0.5)(n-m)! 0.5
+## NP(x) = P(x) * (-1)  * [-------------]
+##   n      n                  (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: Marco Caliari <marco.caliari@univr.it>
 
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -24,17 +24,17 @@
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, it is assumed to
 ## be a vector of zeros with the same size as @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
 ## @tex
 ## $$
-## H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
+## H(i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -17,38 +17,38 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
 ## Return the Hilbert matrix of order @var{n}.  The @math{i,j} element
 ## of a Hilbert matrix is defined as
 ## @tex
 ## $$
-## H (i, j) = {1 \over (i + j - 1)}
+## H(i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## H (i, j) = 1 / (i + j - 1)
+## H(i, j) = 1 / (i + j - 1)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## Hilbert matrices are close to being singular which make them difficult to
 ## invert with numerical routines.
 ## Comparing the condition number of a random matrix 5x5 matrix with that of
 ## a Hilbert matrix of order 5 reveals just how difficult the problem is.
 ##
 ## @example
 ## @group
 ## cond (rand (5))
-##     @result{} 14.392
+##    @result{} 14.392
 ## cond (hilb (5))
-##     @result{} 4.7661e+05
+##    @result{} 4.7661e+05
 ## @end group
 ## @end example
 ##
 ## @seealso{invhilb}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -22,17 +22,17 @@
 ## @tex
 ## $$
 ## {\rm cloglog}(x) = - \log (- \log (x))
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## cloglog(x) = - log (- log (@var{x}))
+## cloglog (x) = - log (- log (@var{x}))
 ## @end example
 ##
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Complementary log-log function
 
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -28,17 +28,17 @@
 ## @tex
 ## $$
 ## {\rm corr}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) {\rm std}(y)}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## corr(x,y) = cov(x,y)/(std(x)*std(y))
+## corr (x,y) = cov (x,y) / (std (x) * std (y))
 ## @end example
 ##
 ## @end ifnottex
 ## If called with one argument, compute @code{corr (@var{x}, @var{x})},
 ## the correlation between the columns of @var{x}.
 ## @seealso{cov}
 ## @end deftypefn
 
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -24,17 +24,17 @@
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
+## kurtosis (x) = 1/N std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return the kurtosis over the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
 ##
 ## Note: The definition of kurtosis above yields a kurtosis of zero for the
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -22,17 +22,17 @@
 ## @tex
 ## $$
 ## {\rm logit}(p) = \log\Big({p \over 1-p}\Big)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## logit(@var{p}) = log (@var{p} / (1-@var{p}))
+## logit (@var{p}) = log (@var{p} / (1-@var{p}))
 ## @end example
 ##
 ## @end ifnottex
 ## @seealso{logistic_cdf}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Logit transformation
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -29,19 +29,19 @@
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##             x(ceil(N/2)),             N odd
-## median(x) =
-##             (x(N/2) + x((N/2)+1))/2,  N even
+##               x(ceil(N/2))             N odd
+## median (x) =
+##              (x(N/2) + x((N/2)+1))/2   N even
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the median value for each
 ## column and return them in a row vector.  If the optional @var{dim}
 ## argument is given, operate along this dimension.
 ## @seealso{mean, mode}
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -38,16 +38,17 @@
 ##
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, return the row vector containing the
 ## @var{p}-th moment of each column.
 ##
 ## The optional string @var{type} specifies the type of moment to be computed.
 ## Valid options are:
+##
 ## @table @asis
 ## @item "c"
 ##   Central Moment.  The moment about the mean defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N (x_i - \bar{x})^p \over N}
 ## $$
 ## @end tex
@@ -67,34 +68,34 @@
 ## $$
 ## {\sum_{i=1}^N {\left| x_i \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## 1/N SUM_i ( abs(x(i)) )^p
+## 1/N SUM_i ( abs (x(i)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @item "ac"
 ##   Absolute Central Moment.  Defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N {\left| x_i - \bar{x} \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## 1/N SUM_i ( abs(x(i) - mean(x)) )^p
+## 1/N SUM_i ( abs (x(i) - mean(x)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end table
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -24,17 +24,17 @@
 ## $$
 ## {\rm skewness} (x) = {1\over N \sigma^3} \sum_{i=1}^N (x_i-\bar{x})^3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
+## skewness (x) = 1/N std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @noindent
 ## If @var{x} is a matrix, return the skewness along the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -25,17 +25,17 @@
 ## Weibull distribution with scale parameter @var{scale} and shape
 ## parameter @var{shape} which is given by
 ## @tex
 ## $$  {shape \over scale^{shape}} \cdot x^{shape-1} \cdot e^{-({x \over scale})^{shape}} $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-##    shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)
+## shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## for @var{x} @geq{} 0.
 ##
 ## Default values are @var{scale} = 1, @var{shape} = 1.
 ## @end deftypefn
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} base2dec (@var{s}, @var{base})
 ## Convert @var{s} from a string of digits in base @var{base} to a decimal
 ## integer (base 10).
 ##
 ## @example
 ## @group
 ## base2dec ("11120", 3)
-##      @result{} 123
+##    @result{} 123
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, return a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
 ## corresponding value will be NaN@.  
 ##
 ## If @var{s} is a cell array of strings, return a column vector with one
@@ -37,17 +37,17 @@
 ##
 ## If @var{base} is a string, the characters of @var{base} are used as the
 ## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
 ## @group
 ## base2dec ("yyyzx", "xyz")
-##      @result{} 123
+##    @result{} 123
 ## @end group
 ## @end example
 ## @seealso{dec2base, bin2dec, hex2dec}
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -19,26 +19,25 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cstrcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
 ## horizontally.  Trailing white space is preserved.  For example:
 ##
 ## @example
 ## @group
 ## cstrcat ("ab   ", "cd")
-##      @result{} "ab   cd"
+##       @result{} "ab   cd"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## cstrcat (s, s, s)
-##      @result{} ans =
-##         "ab ab ab "
+##      @result{} "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ## @seealso{strcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -20,32 +20,32 @@
 ## @deftypefn  {Function File} {} dec2base (@var{d}, @var{base})
 ## @deftypefnx {Function File} {} dec2base (@var{d}, @var{base}, @var{len})
 ## Return a string of symbols in base @var{base} corresponding to
 ## the non-negative integer @var{d}.
 ##
 ## @example
 ## @group
 ## dec2base (123, 3)
-##      @result{} "11120"
+##    @result{} "11120"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a matrix or cell array, return a string matrix with one
 ## row per element in @var{d}, padded with leading zeros to the width of 
 ## the largest value.
 ##
 ## If @var{base} is a string then the characters of @var{base} are used as
 ## the symbols for the digits of @var{d}.  Space (' ') may not be used
 ## as a symbol.
 ##
 ## @example
 ## @group
 ## dec2base (123, "aei")
-##      @result{} "eeeia"
+##    @result{} "eeeia"
 ## @end group
 ## @end example
 ##
 ## The optional third argument, @var{len}, specifies the minimum
 ## number of digits in the result.
 ## @seealso{base2dec, dec2bin, dec2hex}
 ## @end deftypefn
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -23,17 +23,17 @@
 ## string @var{s}, or 0 if no occurrence is found.  @var{s} may also be a
 ## string array or cell array of strings.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## index ("Teststring", "t")
-##      @result{} 4
+##    @result{} 4
 ## @end group
 ## @end example
 ##
 ## If @var{direction} is @samp{"first"}, return the first element found.
 ## If @var{direction} is @samp{"last"}, return the last element found.
 ##
 ## @seealso{find, rindex}
 ## @end deftypefn
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -22,19 +22,18 @@
 ## Convert the string (or character array) @var{s} to a number (or an
 ## array).  Examples:
 ##
 ## @example
 ## @group
 ## str2num ("3.141596")
 ##       @result{} 3.141596
 ##
-## str2num (["1, 2, 3"; "4, 5, 6"]);
-##       @result{} ans =
-##          1  2  3
+## str2num (["1, 2, 3"; "4, 5, 6"])
+##       @result{} 1  2  3
 ##          4  5  6
 ## @end group
 ## @end example
 ##
 ## The optional second output, @var{state}, is logically true when the
 ## conversion is successful.  If the conversion fails the numeric output,
 ## @var{x}, is empty and @var{state} is false.
 ##
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -25,27 +25,27 @@
 ## For numerical input, each element is converted to the
 ## corresponding ASCII character.  Trailing white space is eliminated.
 ## For example:
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
-##      @result{} ans =
+##     @result{}
 ##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## s = @{ "ab"; "cde" @};
 ## strcat (s, s, s)
-##      @result{} ans =
+##     @result{}
 ##         @{
 ##           [1,1] = ababab
 ##           [2,1] = cdecdecde
 ##         @}
 ## @end group
 ## @end example
 ##
 ## @seealso{cstrcat, char, strvcat}
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -27,21 +27,21 @@
 ## Null characters are replaced by spaces.  All other character
 ## data are treated as non-white space.
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## strjust (["a"; "ab"; "abc"; "abcd"])
-##      @result{} ans =
-##            a
-##           ab
-##          abc
-##         abcd
+##      @result{}
+##         "   a"
+##         "  ab"
+##         " abc"
+##         "abcd"
 ## @end group
 ## @end example
 ## @seealso{deblank, strrep, strtrim, untabify}
 ## @end deftypefn
 
 function y = strjust (s, pos = "right")
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -27,25 +27,25 @@
 ## 2-D character arrays are split at separators and at the original column
 ## boundaries.
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## strsplit ("a,b,c", ",")
-##        @result{}
+##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
 ## strsplit (["a,b" ; "cde"], ",")
-##        @result{}
+##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = cde
 ##           @}
 ## @end group
 ## @end example
 ## @seealso{strtok}
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -29,36 +29,36 @@
 ## name but no extension located on Octave's load path.  To keep examples
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
 ## example must also be introduced by the keyword 'demo' flush left to the
 ## prefix with no intervening spaces.  The remainder of the example can
 ## contain arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
-##   %!demo
-##   %! t = 0:0.01:2*pi;
-##   %! x = sin (t);
-##   %! plot (t,x);
-##   %! %-------------------------------------------------
-##   %! % the figure window shows one cycle of a sine wave
+## %!demo
+## %! t = 0:0.01:2*pi;
+## %! x = sin (t);
+## %! plot (t, x);
+## %! %-------------------------------------------------
+## %! % the figure window shows one cycle of a sine wave
 ## @end group
 ## @end example
 ##
 ## Note that the code is displayed before it is executed, so a simple
 ## comment at the end suffices for labeling what is being shown.  It is
 ## generally not necessary to use @code{disp} or @code{printf} within the demo.
 ##
 ## Demos are run in a function environment with no access to external
 ## variables.  This means that every demo must have separate initialization
 ## code.  Alternatively, all demos can be combined into a single large demo
 ## with the code
 ##
 ## @example
-##    %! input("Press <enter> to continue: ","s");
+## %! input("Press <enter> to continue: ","s");
 ## @end example
 ##
 ## @noindent
 ## between the sections, but this is discouraged.  Other techniques
 ## to avoid multiple initialization blocks include using multiple plots
 ## with a new @code{figure} command between each plot, or using @code{subplot}
 ## to put multiple plots in the same window.
 ##
@@ -67,22 +67,22 @@
 ## rather than just anonymous functions or inline functions, you will have to
 ## use @code{eval(example('function',n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
 ## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
 ## with the 'if' on the same line as 'demo'.  For example:
 ##
 ## @example
 ## @group
-##   %!demo if 1
-##   %!  function y=f(x)
-##   %!    y=x;
-##   %!  endfunction
-##   %!  f(3)
-##   %! endif
+## %!demo if 1
+## %!  function y=f(x)
+## %!    y=x;
+## %!  endfunction
+## %!  f(3)
+## %! endif
 ## @end group
 ## @end example
 ##
 ## @seealso{test, example}
 ## @end deftypefn
 
 ## FIXME: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## use the current figure window but pause if not plotting in the
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -21,17 +21,17 @@
 ## Convert a value returned from @code{time} (or any other non-negative
 ## integer), to the local time and return a string of the same form as
 ## @code{asctime}.  The function @code{ctime (time)} is equivalent to
 ## @code{asctime (localtime (time))}.  For example:
 ##
 ## @example
 ## @group
 ## ctime (time ())
-##      @result{} "Mon Feb 17 01:15:06 1997"
+##    @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
 ## @seealso{asctime, time, localtime}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = ctime (t)
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {} date ()
 ## Return the current date as a character string in the form DD-MMM-YYYY@.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## date ()
-##      @result{} "20-Aug-1993"
+##   @result{} "20-Aug-1993"
 ## @end group
 ## @end example
 ## @seealso{now, clock, datestr, localtime}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = date ()
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} is_leap_year (@var{year})
 ## Return true if @var{year} is a leap year and false otherwise.  If no
 ## year is specified, @code{is_leap_year} uses the current year.
 ## For example:
 ##
 ## @example
 ## @group
 ## is_leap_year (2000)
-##      @result{} 1
+##    @result{} 1
 ## @end group
 ## @end example
 ## @seealso{weekday, eomday, calendar}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = is_leap_year (year)
