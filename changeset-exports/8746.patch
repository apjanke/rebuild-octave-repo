# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1234759755 18000
#      Sun Feb 15 23:49:15 2009 -0500
# Node ID 5dd06f19e9be34c68d099716e064d235f6c73d5b
# Parent  6dc61981d18b50d6b41a9833f1fd192e8a64c8b1
handle commands in the lexer

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,33 @@
+2009-02-15  John W. Eaton  <jwe@octave.org>
+
+	* help/doc.m, help/help.m, help/lookfor.m, help/type.m,
+	help/which.m, image/colormap.m, miscellaneous/delete.m,
+	miscellaneous/dir.m, miscellaneous/edit.m,
+	miscellaneous/intwarning.m, miscellaneous/ls.m,
+	miscellaneous/mex.m, miscellaneous/mkoctfile.m,
+	miscellaneous/run.m, miscellaneous/what.m, path/savepath.m,
+	pkg/pkg.m, plot/axis.m, plot/box.m, plot/caxis.m, plot/cla.m,
+	plot/close.m, plot/colorbar.m, plot/grid.m, plot/hidden.m,
+	plot/hold.m, plot/legend.m, plot/orient.m, plot/print.m,
+	plot/shading.m, plot/title.m, plot/xlabel.m, plot/ylabel.m,
+	plot/zlabel.m, testfun/demo.m, testfun/example.m, testfun/fail.m,
+	testfun/rundemos.m, testfun/test.m:
+	Delete "PKG_ADD: mark_as_command" directive.
+
+	* scripts/edit.m: Avoid command-style function call syntax when
+	assigning results in tests.
+
+	* deprecated/mark_as_rawcommand.m, deprecated/unmark_rawcommand.m,
+	deprecated/israwcommand.m, deprecated/mark_as_command.m,
+	deprecated/unmark_command.m, deprecated/iscommand.m:
+	New functions.
+	* deprecated/Makefile.in (SOURCES): Add them to the list.
+
 2009-02-15  Ben Abbott <bpabbott@mac.com>
 
 	* plot/subplot.m: Compatible placement of subplots.
 
 2009-02-13 Ben Abbott <bpabott@mac.com>
 
 	* plot/__go_draw_axes__.m: Respect axes ticklength property.
 
diff --git a/scripts/deprecated/Makefile.in b/scripts/deprecated/Makefile.in
--- a/scripts/deprecated/Makefile.in
+++ b/scripts/deprecated/Makefile.in
@@ -37,28 +37,31 @@ SOURCES = beta_cdf.m beta_inv.m beta_pdf
   chisquare_cdf.m chisquare_inv.m chisquare_pdf.m chisquare_rnd.m \
   clearplot.m clg.m com2str.m exponential_cdf.m exponential_inv.m \
   exponential_pdf.m exponential_rnd.m f_cdf.m f_inv.m f_pdf.m \
   f_rnd.m gamma_cdf.m gamma_inv.m gamma_pdf.m gamma_rnd.m \
   geometric_cdf.m geometric_inv.m geometric_pdf.m geometric_rnd.m \
   hypergeometric_cdf.m hypergeometric_inv.m hypergeometric_pdf.m \
   hypergeometric_rnd.m intersection.m is_bool.m is_complex.m \
   is_list.m is_matrix.m is_scalar.m is_square.m is_stream.m \
-  is_struct.m is_symmetric.m is_vector.m isstr.m lchol.m loadimage.m \
-  lognormal_cdf.m lognormal_inv.m lognormal_pdf.m lognormal_rnd.m \
-  meshdom.m normal_cdf.m normal_inv.m normal_pdf.m normal_rnd.m \
-  pascal_cdf.m pascal_inv.m pascal_pdf.m pascal_rnd.m poisson_cdf.m \
-  poisson_inv.m poisson_pdf.m poisson_rnd.m polyinteg.m setstr.m \
-  spatan2.m spchol2inv.m spcholinv.m spcumprod.m spcumsum.m \
-  spchol.m spdet.m spdiag.m spfind.m spinv.m spkron.m splchol.m \
-  splu.m spmax.m spmin.m spprod.m spqr.m spsum.m spsumsq.m \
-  struct_contains.m struct_elements.m t_cdf.m t_inv.m t_pdf.m \
-  t_rnd.m uniform_cdf.m uniform_inv.m uniform_pdf.m uniform_rnd.m \
-  weibcdf.m weibinv.m weibpdf.m weibrnd.m weibull_cdf.m \
-  weibull_inv.m weibull_pdf.m weibull_rnd.m wiener_rnd.m str2mat.m
+  is_struct.m is_symmetric.m is_vector.m iscommand.m israwcommand.m \
+  isstr.m lchol.m loadimage.m lognormal_cdf.m lognormal_inv.m \
+  lognormal_pdf.m lognormal_rnd.m mark_as_command.m \
+  mark_as_rawcommand.m meshdom.m normal_cdf.m normal_inv.m \
+  normal_pdf.m normal_rnd.m pascal_cdf.m pascal_inv.m pascal_pdf.m \
+  pascal_rnd.m poisson_cdf.m poisson_inv.m poisson_pdf.m \
+  poisson_rnd.m polyinteg.m setstr.m spatan2.m spchol2inv.m \
+  spcholinv.m spcumprod.m spcumsum.m spchol.m spdet.m spdiag.m \
+  spfind.m spinv.m spkron.m splchol.m splu.m spmax.m spmin.m \
+  spprod.m spqr.m spsum.m spsumsq.m struct_contains.m \
+  struct_elements.m t_cdf.m t_inv.m t_pdf.m t_rnd.m uniform_cdf.m \
+  uniform_inv.m uniform_pdf.m uniform_rnd.m unmark_command.m \
+  unmark_rawcommand.m weibcdf.m weibinv.m weibpdf.m weibrnd.m \
+  weibull_cdf.m weibull_inv.m weibull_pdf.m weibull_rnd.m \
+  wiener_rnd.m str2mat.m
 
 DISTFILES = $(addprefix $(srcdir)/, Makefile.in $(SOURCES))
 
 FCN_FILES = $(addprefix $(srcdir)/, $(SOURCES))
 FCN_FILES_NO_DIR = $(notdir $(FCN_FILES))
 
 all: PKG_ADD
 .PHONY: all
diff --git a/scripts/deprecated/iscommand.m b/scripts/deprecated/iscommand.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/iscommand.m
@@ -0,0 +1,44 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} iscommand (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function retval = iscommand ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "iscommand is obsolete and will be removed from a future version of Octave");
+  endif
+
+  if (nargin == 0)
+    retval = {};
+  else
+    retval = true;
+  endif
+
+endfunction
diff --git a/scripts/deprecated/israwcommand.m b/scripts/deprecated/israwcommand.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/israwcommand.m
@@ -0,0 +1,44 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} israwcommand (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function retval = israwcommand ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "israwcommand is obsolete and will be removed from a future version of Octave");
+  endif
+
+  if (nargin == 0)
+    retval = {};
+  else
+    retval = true;
+  endif
+
+endfunction
diff --git a/scripts/deprecated/mark_as_command.m b/scripts/deprecated/mark_as_command.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/mark_as_command.m
@@ -0,0 +1,38 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} mark_as_command (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function mark_as_command ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "mark_as_command is obsolete and will be removed from a future version of Octave");
+  endif
+
+endfunction
diff --git a/scripts/deprecated/mark_as_rawcommand.m b/scripts/deprecated/mark_as_rawcommand.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/mark_as_rawcommand.m
@@ -0,0 +1,38 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} mark_as_rawcommand (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function mark_as_rawcommand ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "mark_as_rawcommand is obsolete and will be removed from a future version of Octave");
+  endif
+
+endfunction
diff --git a/scripts/deprecated/unmark_command.m b/scripts/deprecated/unmark_command.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/unmark_command.m
@@ -0,0 +1,38 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} unmark_command (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function unmark_command ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "unmark_command is obsolete and will be removed from a future version of Octave");
+  endif
+
+endfunction
diff --git a/scripts/deprecated/unmark_rawcommand.m b/scripts/deprecated/unmark_rawcommand.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/unmark_rawcommand.m
@@ -0,0 +1,38 @@
+## Copyright (C) 2009 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Built-in Function} {} unmark_rawcommand (@var{name})
+## This function is obsolete and will be removed from a future
+## version of Octave.
+## @end deftypefn
+
+## Author: jwe
+
+## Deprecated in version 3.2
+
+function unmark_rawcommand ()
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "unmark_rawcommand is obsolete and will be removed from a future version of Octave");
+  endif
+
+endfunction
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -29,18 +29,16 @@
 ## Once the GNU Info browser is running, help for using it is available
 ## using the command @kbd{C-h}.
 ## @seealso{help}
 ## @end deftypefn
 
 ## Author: Soren Hauberg <soren@hauberg.org>
 ## Adapted-by: jwe
 
-## PKG_ADD: mark_as_command doc
-
 function retval = doc (fname)
 
   if (nargin == 0 || nargin == 1)
 
     ftype = 0;
 
     if (nargin == 1)
       ## Get the directory where the function lives.
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -24,18 +24,16 @@
 ## describing the @code{help} command.
 ## 
 ## The help command can give you information about operators, but not the
 ## comma and semicolons that are used as command separators.  To get help
 ## for those, you must type @kbd{help comma} or @kbd{help semicolon}.
 ## @seealso{doc, which, lookfor}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command help
-
 function help (name)
   if (nargin == 0)
     disp ("Help is available for the topics listed below.");
     disp ("");
     
     disp ("*** operators:");
     operators = __operators__ ();
     disp (list_in_columns (operators (:, 1)));
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -34,18 +34,16 @@
 ## sentence of the help of the functions is dependent on the format of the
 ## functions help. All of the functions in Octave itself will correctly
 ## find the first sentence, but the same can not be guaranteed for other
 ## functions. Therefore the use of the '-all' argument might be necessary
 ## to find related functions that are not part of Octave.
 ## @seealso{help, which}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command lookfor
-
 function [out_fun, out_help_text] = lookfor (str, extra)
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
     ## we search. The cache is organised such that its first column contains
     ## the function name, its second column contains the full help text, and its
     ## third column contains the first sentence of the help text.
     str = extra;
     search_type = 2; # when using caches, search its second column
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -21,18 +21,16 @@
 ## Normally also displays whether each @var{name} is user-defined or built-in;
 ## the @code{-q} option suppresses this behaviour.
 ##
 ## If an output argument is requested nothing is displayed. Instead a cell array
 ## of strings is returned, where each element corresponds to the definition of
 ## each requested function.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command type
-
 function retval = type (varargin)
   ## Parse input
   if (nargin == 0)
     error ("type: not enough input arguments");
   endif
 
   if (!iscellstr (varargin))
     error ("type: input arguments must be strings");
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -16,18 +16,16 @@
 
 ## -*- texinfo -*-
 ## @deffn {Command} which name @dots{}
 ## Display the type of each @var{name}.  If @var{name} is defined from a
 ## function file, the full name of the file is also displayed.
 ## @seealso{help, lookfor}
 ## @end deffn
 
-## PKG_ADD: mark_as_command which
-
 function varargout = which (varargin)
 
   if (nargin > 0 && iscellstr (varargin))
     m = __which__ (varargin{:});
 
     if (nargout == 0)
       for i = 1:nargin
 	if (isempty (m(i).file))
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -33,18 +33,16 @@
 ## With no arguments, @code{colormap} returns the current color map.
 ## @seealso{jet}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-## PKG_ADD: mark_as_command colormap
-
 function cmap = colormap (map)
 
   if (nargin > 1)
     print_usage ();
   endif
 
   if (nargin == 1)
 
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -17,18 +17,16 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} delete (@var{file})
 ## @deftypefnx {Function File} {} delete (@var{h})
 ## Delete the named file or graphics handle.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command delete
-
 ## Author: jwe
 
 function delete (arg)
 
   if (nargin == 1)
     if (ischar (arg))
       files = glob (arg).';
       if (isempty (files))
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -44,18 +44,16 @@
 ## the file that a symbolic link points to instead of the link itself.
 ## However, if the link points to a nonexistent file, @code{dir} returns
 ## information about the link.
 ## @seealso{ls, stat, lstat, readdir, glob, filesep}
 ## @end deftypefn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command dir
-
 ## FIXME -- this is quite slow for large directories, so perhaps
 ## it should be converted to C++.
 
 function retval = dir (file)
 
   if (nargin == 0)
     file = ".";
   elseif (nargin > 1)
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -129,18 +129,16 @@
 ## @end table
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
-## PKG_ADD: mark_as_command edit
-
 function ret = edit (file, state)
 
   ## Pick up globals or default them.
 
   persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
   				"HOME", fullfile (default_home, "octave"),
   				"AUTHOR", default_user(1),
   				"EMAIL",  [],
@@ -493,23 +491,23 @@ function ret = default_user (long_form)
     endif
   else
     ret = ent.name;
   endif
 
 endfunction
 
 %!test
-%! s.editor = edit get editor;
-%! s.home = edit get home;
-%! s.author = edit get author;
-%! s.email = edit get email;
-%! s.license = edit get license;
-%! s.editinplace = edit get editinplace;
-%! s.mode = edit get mode;
+%! s.editor = edit ("get", "editor");
+%! s.home = edit ("get", "home");
+%! s.author = edit ("get", "author");
+%! s.email = edit ("get", "email");
+%! s.license = edit ("get", "license");
+%! s.editinplace = edit ("get", "editinplace");
+%! s.mode = edit ("get", "mode");
 %! edit editor none
 %! edit home none
 %! edit author none
 %! edit email none
 %! edit license none
 %! edit ("editinplace", !s.editinplace)
 %! if (s.mode(1) == "a")
 %!   edit mode sync
diff --git a/scripts/miscellaneous/intwarning.m b/scripts/miscellaneous/intwarning.m
--- a/scripts/miscellaneous/intwarning.m
+++ b/scripts/miscellaneous/intwarning.m
@@ -60,18 +60,16 @@
 ## @example
 ## s = intwarning ("off");
 ## @dots{}
 ## intwarning (s);
 ## @end example
 ## @seealso{warning}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command intwarning
-
 function y = intwarning (x)
 
   if (nargin != 1)
     print_usage ();
   else
     if (nargout > 0)
       y = warning("query", "Octave:int-convert-nan");
       y = [y; warning("query", "Octave:int-convert-non-int-val")];
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -30,18 +30,16 @@
 ## The @code{dir} and @code{ls} commands are implemented by calling your
 ## system's directory listing command, so the available options may vary
 ## from system to system.
 ## @seealso{dir, stat, readdir, glob, filesep, ls_command}
 ## @end deffn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command ls
-
 function retval = ls (varargin)
 
   global __ls_command__;
 
   if (isempty (__ls_command__) || ! ischar (__ls_command__))
     ## Initialize value for __ls_command__.
     ls_command ();
   endif
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -18,14 +18,12 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mex [options] file @dots{}
 ## Compile source code written in C, C++, or Fortran, to a MEX file.
 ## This is equivalent to @code{mkoctfile --mex [options] file}.
 ## @seealso{mkoctfile}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command mex
-
 function mex (varargin)
   args = {"--mex", varargin{:}};
   mkoctfile (args{:});
 endfunction
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -112,18 +112,16 @@
 ##                   .f    Fortran source
 ##                   .F    Fortran source
 ##                   .o    object file
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command mkoctfile
-
 function mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
   cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -21,18 +21,16 @@
 ## @deftypefnx {Command} {} run @var{f}
 ## Run scripts in the current workspace that are not necessarily on the
 ## path. If @var{f} is the script to run, including its path, then @code{run}
 ## change the directory to the directory where @var{f} is found. @code{run}
 ## then executes the script, and returns to the original directory.
 ## @seealso{system}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command run
-
 function run (s)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   [d, f, ext] = fileparts (s);
   if (! isempty (d))
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -22,18 +22,16 @@
 ## @deftypefnx {Function File} {w =} what (@var{dir})
 ## List the Octave specific files in a directory. If the variable @var{dir}
 ## is given then check that directory rather than the current directory. If
 ## a return argument is requested, the files found are returned in the 
 ## structure @var{w}.
 ## @seealso{which}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command what
-
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
     ## Find the appropriate directory on the path.
     p = split (path (), pathsep());
     p = cellfun (@(x) deblank (x), mat2cell (p, ones (1, size (p, 1)), ...
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -22,18 +22,16 @@
 ## not set during Octave's initialization process, to @var{file}.
 ## If @var{file} is omitted, @file{~/.octaverc} is used.  If successful,
 ## @code{savepath} returns 0.
 ## @seealso{path, addpath, rmpath, genpath, pathdef, pathsep}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@givebillmoney.com>
 
-##PKGADD: mark_as_command savepath
-
 function varargout = savepath (savefile)
 
   retval = 1;
 
   beginstring = "## Begin savepath auto-created section, do not edit";
   endstring   = "## End savepath auto-created section";
 
   if (nargin == 0)
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -190,18 +190,16 @@
 ## @noindent
 ## where @code{buiddir} is the name of a directory where the temporary
 ## installation will be produced and the binary packages will be found.
 ## The options @code{-verbose} and @code{-nodeps} are respected, while 
 ## the other options are ignored.
 ## @end table
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command pkg
-
 function [local_packages, global_packages] = pkg (varargin)
   ## Installation prefix (FIXME: what should these be on windows?)
   persistent user_prefix = false;
   persistent prefix = -1;
   persistent archprefix = -1;
   persistent local_list = tilde_expand (fullfile ("~", ".octave_packages"));
   persistent global_list = fullfile (OCTAVE_HOME (), "share", "octave",
 				     "octave_packages");
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -109,18 +109,16 @@
 ## @end table
 ## 
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command axis
-
 function varargout = axis (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("axis", varargin{:});
 
   oldh = gca ();
   unwind_protect
     axes (h);
     varargout = cell (max (nargin == 0, nargout), 1);
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -22,18 +22,16 @@
 ## Control the display of a border around the plot.
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, the current box state is toggled.
 ## @seealso{grid}
 ## @end deftypefn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command box
-
 function box (varargin)
 
   h = gca ();
 
   box_state = get (h, "box");
 
   nargs = numel (varargin);
 
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -30,18 +30,16 @@
 ## whereas if @var{limits} is 'manual' the colormap scaling is set to manual.
 ##
 ## Called without any arguments to current color axis limits are returned.
 ##
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command caxis
-
 function varargout = caxis (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("caxis", varargin{:});
 
   oldh = gca ();
   unwind_protect
     axes (h);
     varargout = cell (max (nargin == 0, nargout), 1);
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -24,18 +24,16 @@
 ## instead of the current axes.  If the optional argument @code{"reset"}
 ## is specified, also delete the children with hidden handles.
 ## @seealso{clf}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2008-10-03
 
-## PKG_ADD: mark_as_command cla
-
 function cla (varargin)
 
   if (nargin > 2)
     print_usage ();
   elseif (nargin > 1)
     if (ishandle (varargin{1})
 	&& strcmp (get (varargin{1}, "type"), "axes")
 	&& ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -24,18 +24,16 @@
 ## Close figure window(s) by calling the function specified by the
 ## @code{"closerequestfcn"} property for each figure.  By default, the
 ## function @code{closereq} is used.
 ## @seealso{closereq}
 ## @end deftypefn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command close
-
 function retval = close (arg1, arg2)
 
   figs = [];
 
   if (nargin == 0)
     ## Close current figure.  Don't use gcf because that will open a new
     ## plot window if one doesn't exist.
     figs = get (0, "currentfigure");
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -41,19 +41,16 @@
 ## @item "Off", "None"
 ## Remove any existing colorbar from the plot.
 ## @end table
 ##
 ## If the argument "peer" is given, then the following argument is treated
 ## as the axes handle on which to add the colorbar.
 ## @end deftypefn
 
-
-## PKG_ADD: mark_as_command colorbar
-
 function h = colorbar (varargin)
   ax = [];
   loc = "eastoutside";
   args = {};
   deleting = false;
 
   i = 1;
   while (i <= nargin)
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -32,18 +32,16 @@
 ##
 ## If the first argument is an axis handle, @var{hax}, operate on the
 ## specified axis object.
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: jwe
 
-## PKG_ADD: mark_as_command grid
-
 function grid (varargin)
 
   persistent grid_on = false;
   persistent minor_on = false;
 
   [ax, varargin, nargs] = __plt_get_axis_arg__ ("grid", varargin{:});
 
   if (nargs > 2)
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -20,18 +20,16 @@
 ## @deftypefn {Function File} {} hidden (@var{mode})
 ## @deftypefnx {Function File} {} hidden ()
 ## Manipulation the mesh hidden line removal. Called with no argument
 ## the hidden line removal is toggled. The argument @var{mode} can be either
 ## 'on' or 'off' and the set of the hidden line removal is set accordingly.
 ## @seealso{mesh, meshc, surf}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command hidden
-
 function retval = hidden (mode)
 
   if (nargin == 0)
     mode = "swap";
   elseif (nargin == 1);
     if (ischar (mode))
       mode = tolower (mode);
       if (! strcmp (mode, "on") && ! strcmp (mode, "off"))
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -35,18 +35,16 @@
 ##
 ## @deftypefnx {Function File} {} hold (@var{h}, @dots{})
 ## 
 ## Applies to a specific axis or axes, associated with the handle(s), 
 ## @var{h}.
 ## 
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command hold
-
 function hold (varargin)
 
   if (nargin > 0 && numel (varargin{1}) == 1 && ishandle (varargin{1}(1))
       && strcmp (get (varargin{1}, "type"), "axes"))
     [h, varargin, nargs] = __plt_get_axis_arg__ ("hold", varargin{:});
   elseif (nargin > 0 && numel (varargin{1}) > 1 && ishandle (varargin{1}(1)))
     print_usage ();
   else
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -71,18 +71,16 @@
 ##   Withdraw the box around legends
 ## @item "left"
 ##   Text is to the left of the keys
 ## @item "right"
 ##   Text is to the right of the keys
 ## @end table
 ## @end deftypefn
 
-## PKG_ADD mark_as_command legend
-
 function legend (varargin)
 
   [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
   nargs = nargin;
 
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && round (pos) == pos)
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -21,18 +21,16 @@
 ## Set the default print orientation.  Valid values for
 ## @var{orientation} include @code{"landscape"} and @code{"portrait"}.
 ## If called with no arguments, return the default print orientation.
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Adapted-By: jwe
 
-## PKG_ADD: mark_as_command orient
-
 function retval = orient (varargin)
 
   nargs = nargin;
 
   if (nargs > 0 && numel (varargin{1}) == 1 && isfigure (varargin{1}))
     cf = varargin{1};
     varargin(1) = [];
     nargs--;
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -121,18 +121,16 @@
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ## @end deftypefn
 
 ## Author: Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 ## Adapted-By: jwe
 
-## PKG_ADD: mark_as_command print
-
 function print (varargin)
 
   orientation = orient ();
   use_color = 0; # 0=default, -1=mono, +1=color
   force_solid = 0; # 0=default, -1=dashed, +1=solid
   fontsize = "";
   font = "";
   size = "";
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -35,18 +35,16 @@
 ## @end table
 ##
 ## If @var{ax} is given the shading is applied to axis @var{ax} instead
 ## of the current axis.
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
-## PKG_ADD: mark_as_command shading
-
 function shading (varargin)
 
   [ax, varargin] = __plt_get_axis_arg__ ("shading", varargin{:});
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -18,18 +18,16 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} title (@var{title})
 ## @deftypefnx {Function File} {} title (@var{title}, @var{p1}, @var{v1}, @dots{})
 ## Create a title object and return a handle to it.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command title
-
 ## Author: jwe
 
 function h = title (s, varargin)
 
   if (rem (nargin, 2) == 1)
     if (nargout > 0)
       h = __axis_label__ ("title", s, varargin{:});
     else
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -23,18 +23,16 @@
 ## @deftypefnx {Function File} {} zlabel (@var{string})
 ## @deftypefnx {Function File} {} xlabel (@var{h}, @var{string})
 ## Specify x, y, and z axis labels for the current figure. If @var{h} is
 ## specified then label the axis defined by @var{h}.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs, title}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command xlabel
-
 ## Author: jwe
 
 function retval = xlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -18,18 +18,16 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{h}, @var{string})
 ## @seealso{xlabel}.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command ylabel
-
 ## Author: jwe
 
 function retval = ylabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -18,18 +18,16 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} zlabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{h}, @var{string})
 ## @seealso{xlabel}.
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command zlabel
-
 ## Author: jwe
 
 function retval = zlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
 
   if (rem (nargin, 2) != 1)
     print_usage ();
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -69,18 +69,16 @@
 ## @end example
 ## @seealso{test, example}
 ## @end deftypefn
 
 ## FIXME: modify subplot so that gnuplot_has_multiplot == 0 causes it to
 ## use the current figure window but pause if not plotting in the
 ## first subplot.
 
-## PKG_ADD: mark_as_command demo
-
 function demo (name, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2)
     n = 0;
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -27,18 +27,16 @@
 ## Called with output arguments, the examples are returned in the form of
 ## a string @var{x}, with @var{idx} indicating the ending position of the 
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command example
-
 function [code_r, idx_r] = example (name, n)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
   if (nargin < 2)
     n = 0;
   endif
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -43,18 +43,16 @@
 ## Called with three arguments, the behavior is similar to 
 ## @code{fail(@var{code}, @var{pattern})}, but produces an error if no 
 ## warning is given during code execution or if the code fails.
 ##
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
-## PKG_ADD mark_as_command fail
-
 function ret = fail (code, pattern, warning_pattern)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   ## sort out arguments
   test_warning = (nargin > 1 && strcmp (pattern, "warning"));
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -15,18 +15,16 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rundemos (@var{directory})
 ## @end deftypefn
 
-## PKG_ADD: mark_as_command rundemos
-
 ## Author: jwe
 
 function rundemos (directory)
 
   if (nargin == 0)
     dirs = cellstr (split (path (), pathsep ()));
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -68,18 +68,16 @@
 ## @seealso{error, assert, fail, demo, example}
 ## @end deftypefn
 
 ## FIXME: * Consider using keyword fail rather then error?  This allows us
 ## to make a functional form of error blocks, which means we
 ## can include them in test sections which means that we can use
 ## octave flow control for both kinds of tests.
 
-## PKG_ADD: mark_as_command test
-
 function [__ret1, __ret2, __ret3, __ret4] = test (__name, __flag, __fid)
   ## Information from test will be introduced by "key".
   persistent __signal_fail =  "!!!!! ";
   persistent __signal_empty = "????? ";
   persistent __signal_block = "  ***** ";
   persistent __signal_file =  ">>>>> ";
   persistent __signal_skip = "----- ";
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,49 @@
 2009-02-15  John W. Eaton  <jwe@octave.org>
 
+	* defun.cc, defun-int.h, defun-dld.h (DEFUN_INTERNAL,
+	DEFCONSTFUN_INTERNAL, DEFUNX_INTERNAL, DEFUN_DLD_INTERNAL,
+	DEFUNX_DLD_INTERNAL, install_builtin_function,
+	install_dld_function, install_mex_function):
+	Delete IS_TEXT_FCN arg.  Fix all uses.
+	(DEFMD, DEFUN_TEXT): Delete.
+	* mkbuiltins, mkgendoc: Adapt to DEFUN macro changes.
+
+	* lex.h, lex.l (lexer_flags::at_beginning_of_statement):
+	New data member.  Set it as needed in rules.
+	(is_keyword_token):
+	Handle lexer_flags::at_beginning_of_statement.
+	(next_token_can_follow_bin_op, looks_like_command_arg): New functions.
+	(handle_identifier): Use them to determine 
+	Don't check is_command_name or is_rawcommand_name.
+	* parse.y (statement): Recognize word_list_cmd here.
+	(expression): Not here.
+
+	* lex.l (handle_string): Delete arg TEXT_STYLE.
+	(BIN_OP_RETURN, XBIN_OP_RETURN): New arg, BOS. Change all uses.
+
+	* lex.h, lex.l (lexer_flags::doing_raw_command): Delete data
+	member and all uses.
+
+	* debug.cc, dirfns.cc, error.cc, input.cc, lex.l, load-path.cc,
+	load-save.cc, oct-hist.cc, ov-class.cc, pager.cc, parse.y,
+	pr-output.cc, sysdep.cc, utils.cc, variables.cc:
+	Replace all uses of DEFCMD with DEFUN.
+
+	* variables.cc (command_set, rawcommand_set): Delete static variables.
+	(mark_as_command, unmark_command, is_command_name,
+	mark_as_rawcommand, unmark_raw_command, is_rawcommand_name): Delete.
+	(Fmark_as_command, Funmark_command, Fiscommand,
+	Fmark_as_rawcommand, Funmark_rawcommand, Fisrawcommand):
+	Convert to .m files and move to scripts/deprecated.
+	* variables.h (mark_as_command, is_command_name,
+	is_marked_as_rawcommand, mark_as_rawcommand, unmark_rawcommand,
+	is_rawcommand_name): Delete decls.
+
 	* lex.h, lex.l (lexer_flags.looking_at_object_index): Now a
 	std::list<bool> object instead of an int.
 	Push TRUE to list at start of object index.  Push FALSE at
 	beginning of matrix list.  Pop value at end of object index or
 	matrix list.
 	(lexer_flags.looking_for_object_index): New data member.
 	Set it as needed in rules.
 	(inside_any_object_index): New function.
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -485,17 +485,17 @@ intmap_to_ov (const bp_table::intmap& li
 	}
     }
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
-DEFCMD (dbstop, args, ,
+DEFUN (dbstop, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{rline} =} dbstop (@var{func}, @var{line}, @dots{})\n\
 Set a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
@@ -517,17 +517,17 @@ The rline returned is the real line that
     lines[0] = 1;
 
   if (! error_state)
     retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
-DEFCMD (dbclear, args, ,
+DEFUN (dbclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbclear (@var{func}, @var{line}, @dots{})\n\
 Delete a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
@@ -546,17 +546,17 @@ a breakpoint. If you get the wrong line 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
       
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
-DEFCMD (dbstatus, args, nargout,
+DEFUN (dbstatus, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {lst =} dbstatus (@var{func})\n\
 Return a vector containing the lines on which a function has \n\
 breakpoints set.\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out.\n\
@@ -641,17 +641,17 @@ mode this should be left out.\n\
       retval.assign ("name", names);
       retval.assign ("file", file);
       retval.assign ("line", line);
 
       return octave_value (retval);
     }
 }
 
-DEFCMD (dbwhere, , ,
+DEFUN (dbwhere, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbwhere ()\n\
 Show where we are in the code\n\
 @seealso{dbclear, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -740,17 +740,17 @@ do_dbtype (std::ostream& os, const std::
 	os << "dbtype: unable to open `" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
-DEFCMD (dbtype, args, ,
+DEFUN (dbtype, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbtype ()\n\
 List script file with line numbers.\n\
 @seealso{dbclear, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
@@ -846,17 +846,17 @@ List script file with line numbers.\n\
 	default:
 	  error ("dbtype: expecting zero, one, or two arguments\n");
 	}
     }
 
   return retval;
 }
 
-DEFCMD (dbstack, args, nargout,
+DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
 Print or return current stack information.  With optional argument\n\
 @var{n}, omit the @var{n} innermost stack frames.\n\
 @seealso{dbclear, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -954,47 +954,47 @@ do_dbupdown (const octave_value_list& ar
       if (who == "dbup")
 	n = -n;
 
       if (! octave_call_stack::goto_frame_relative (n, true))
 	error ("%s: invalid stack frame", who.c_str ());
     }
 }
 
-DEFCMD (dbup, args, ,
+DEFUN (dbup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move up one frame.\n\
 @seealso{dbstack}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
-DEFCMD (dbdown, args, ,
+DEFUN (dbdown, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbdown (@var{n})\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move down one frame.\n\
 @seealso{dbstack}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
 
   return retval;
 }
 
-DEFCMD (dbstep, args, ,
+DEFUN (dbstep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbstep @var{n}\n\
 @deftypefnx {Command} {} dbstep in\n\
 @deftypefnx {Command} {} dbstep out\n\
 In debugging mode, execute the next @var{n} lines of code. If @var{n} is\n\
 omitted execute the next line of code. If the next line of code is itself\n\
 defined in terms of an m-file remain in the existing function.\n\
 \n\
@@ -1058,17 +1058,17 @@ execution to continue until the current 
   else
     error ("dbstep: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
-DEFCMD (dbcont, args, ,
+DEFUN (dbcont, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont ()\n\
 In debugging mode, quit debugging mode and continue execution.\n\
 @seealso{dbstep, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
@@ -1082,17 +1082,17 @@ In debugging mode, quit debugging mode a
 	print_usage ();
     }
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
-DEFCMD (dbquit, args, ,
+DEFUN (dbquit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbquit ()\n\
 In debugging mode, quit debugging mode and return to the top level.\n\
 @seealso{dbstep, dbcont}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
@@ -1106,17 +1106,17 @@ In debugging mode, quit debugging mode a
 	print_usage ();
     }
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
-DEFCMD (isdebugmode, args, ,
+DEFUN (isdebugmode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} isdebugmode ()\n\
 Return true if debug mode is on, otherwise false.\n\
 @seealso{dbstack, dbclear, dbstop, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -38,27 +38,27 @@ along with Octave; see the file COPYING.
 // an extra externally visible function.
 //
 // The first DECLARE_FUN is for the benefit of the installer function
 // and the second is for the definition of the function.
 
 #if defined (MAKE_BUILTINS)
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
-  DEFUN_DLD_INTERNAL (name, args_name, nargout_name, false, doc)
+  DEFUN_DLD_INTERNAL (name, args_name, nargout_name, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes
 // "Ffoo") as well as the name of the generated installer function
 // (the convention is to use a prefix of "G", so "foo" becomes "Gfoo").
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc) \
-  DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, false, doc)
+  DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, doc)
 
 #else
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name); \
   DEFINE_FUN_INSTALLER_FUN (name, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -35,29 +35,27 @@ class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&);
 
 extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-			  const std::string& doc, bool is_text_fcn = false,
+			  const std::string& doc,
 			  bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-		      const octave_shlib& shl,
-		      const std::string& doc, bool is_text_fcn = false,
+		      const octave_shlib& shl, const std::string& doc, 
 		      bool relative = false);
 
 extern OCTINTERP_API void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool is_text_fcn = false,
-		      bool relative = false);
+		      const octave_shlib& shl, bool relative = false);
 
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 #define DECLARE_FUNX(name, args_name, nargout_name) \
   OCTAVE_EXPORT octave_value_list \
   name (const octave_value_list& args_name, int nargout_name)
 
@@ -103,67 +101,64 @@ typedef octave_function * (*octave_dld_f
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
 // or DEFCMD.
 
-#define DEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define DEFUN_INTERNAL(name, args_name, nargout_name, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFUN_INTERNAL (name, args_name, nargout_name, is_text_fcn, doc) \
+    XDEFUN_INTERNAL (name, args_name, nargout_name, doc) \
   END_INSTALL_BUILTIN
 
-#define DEFCONSTFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define DEFCONSTFUN_INTERNAL(name, args_name, nargout_name, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFCONSTFUN_INTERNAL (name, args_name, nargout_name, is_text_fcn, doc) \
+    XDEFCONSTFUN_INTERNAL (name, args_name, nargout_name, doc) \
   END_INSTALL_BUILTIN
 
-#define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
-			is_text_fcn, doc) \
+#define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFUNX_INTERNAL (name, fname, args_name, nargout_name, is_text_fcn, doc) \
+    XDEFUNX_INTERNAL (name, fname, args_name, nargout_name, doc) \
   END_INSTALL_BUILTIN
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses
 // DEFUN_DLD.
 
-#define DEFUN_DLD_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define DEFUN_DLD_INTERNAL(name, args_name, nargout_name, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFUN_DLD_INTERNAL (name, args_name, nargout_name, is_text_fcn, doc) \
+    XDEFUN_DLD_INTERNAL (name, args_name, nargout_name, doc) \
   END_INSTALL_BUILTIN
 
-#define DEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, \
-			    is_text_fcn, doc) \
+#define DEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, doc) \
   BEGIN_INSTALL_BUILTIN \
-    XDEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, is_text_fcn, doc) \
+    XDEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, doc) \
   END_INSTALL_BUILTIN
 
 // Generate code for making another name for an existing function.
 
 #define DEFALIAS_INTERNAL(alias, name) \
   BEGIN_INSTALL_BUILTIN \
     XDEFALIAS_INTERNAL(alias, name) \
   END_INSTALL_BUILTIN
 
 #else /* ! MAKE_BUILTINS */
 
 // Generate the first line of the function definition.  This ensures
 // that the internal functions all have the same signature.
 
-#define DEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define DEFUN_INTERNAL(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
-#define DEFCONSTFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define DEFCONSTFUN_INTERNAL(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
-#define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
-			is_text_fcn, doc) \
+#define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc) \
   DECLARE_FUNX (fname, args_name, nargout_name)
 
 // No definition is required for an alias.
 
 #define DEFALIAS_INTERNAL(alias, name)
 
 #endif /* ! MAKE_BUILTINS */
 
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -75,62 +75,51 @@ check_version (const std::string& versio
 	     version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-			  const std::string& doc, bool is_text_fcn,
+			  const std::string& doc,
 			  bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, doc));
 
   symbol_table::install_built_in_function (name, fcn);
-
-  if (is_text_fcn)
-    mark_as_command (name);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-		      const octave_shlib& shl,
-		      const std::string& doc, bool is_text_fcn,
+		      const octave_shlib& shl, const std::string& doc,
 		      bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
   symbol_table::install_built_in_function (name, fval);
-
-  if (is_text_fcn)
-    mark_as_command (name);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-		      const octave_shlib& shl, bool is_text_fcn,
-		      bool relative)
+		      const octave_shlib& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
   symbol_table::install_built_in_function (name, fval);
-
-  if (is_text_fcn)
-    mark_as_command (name);
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
   symbol_table::alias_built_in_function (alias, name);
 }
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -38,42 +38,29 @@ along with Octave; see the file COPYING.
 //     the argument list to this function.
 //
 //   nargout_name is the name of the int variable used to pass the
 //     number of output arguments this function is expected to produce.
 //
 //   doc is the simple help text for the function.
 
 #define DEFUN(name, args_name, nargout_name, doc) \
-  DEFUN_INTERNAL (name, args_name, nargout_name, false, doc)
+  DEFUN_INTERNAL (name, args_name, nargout_name, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convention is to use a prefix of "F", so "foo" becomes "Ffoo").
 
 #define DEFUNX(name, fname, args_name, nargout_name, doc) \
-  DEFUNX_INTERNAL (name, fname, args_name, nargout_name, false, doc)
-
-// Define a builtin command-style function.
-//
-// This is like DEFUN, except that it defines a function that can be
-// called from the Octave language without using parenthesis to
-// surround the arguments). 
-
-#define DEFCMD(name, args_name, nargout_name, doc) \
-  DEFUN_INTERNAL (name, args_name, nargout_name, true, doc)
-
-// For backward compatibility.
-
-#define DEFUN_TEXT DEFCMD
+  DEFUNX_INTERNAL (name, fname, args_name, nargout_name, doc)
 
 // This is a function with a name that can't be hidden by a variable.
 #define DEFCONSTFUN(name, args_name, nargout_name, doc) \
-  DEFCONSTFUN_INTERNAL (name, args_name, nargout_name, true, doc)
+  DEFCONSTFUN_INTERNAL (name, args_name, nargout_name, doc)
 
 // Make alias another name for the existing function name.  This macro
 // must be used in the same file where name is defined, after the
 // definition for name.
 
 #define DEFALIAS(alias, name) \
   DEFALIAS_INTERNAL (alias, name)
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -91,17 +91,17 @@ octave_change_to_directory (const std::s
       using namespace std;
 
       error ("%s: %s", newdir.c_str (), strerror (errno));
     }
 
   return cd_ok;
 }
 
-DEFCMD (cd, args, ,
+DEFUN (cd, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} cd dir\n\
 @deffnx {Command} chdir dir\n\
 Change the current working directory to @var{dir}.  If @var{dir} is\n\
 omitted, the current directory is changed to the user's home\n\
 directory.  For example,\n\
 \n\
 @example\n\
@@ -201,17 +201,17 @@ system-dependent error message.\n\
     print_usage ();
 
   return retval;
 }
 
 // FIXME -- should maybe also allow second arg to specify
 // mode?  OTOH, that might cause trouble with compatibility later...
 
-DEFCMD (mkdir, args, ,
+DEFUN (mkdir, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{parent}, @var{dir})\n\
 Create a directory named @var{dir} in the directory @var{parent}.\n\
 \n\
 If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
 character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique\n\
@@ -284,17 +284,17 @@ message identifier.\n\
 	}
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (rmdir, args, ,
+DEFUN (rmdir, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir}, @code{\"s\"})\n\
 Remove the directory named @var{dir}.\n\
 \n\
 If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
 character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1028,17 +1028,17 @@ error: nargin != 1\n\
 	return retval;
     }
 
   handle_message (error_with_id, id.c_str (), "unspecified error", nargs);
 
   return retval;
 }
 
-DEFCMD (warning, args, nargout,
+DEFUN (warning, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -929,17 +929,17 @@ If @code{keyboard} is invoked without an
       unwind_protect::run ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (echo, args, ,
+DEFUN (echo, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} echo options\n\
 Control whether commands are displayed as they are executed.  Valid\n\
 options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Enable echoing of commands as they are executed in script files.\n\
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -77,16 +77,20 @@ public:
 
   // TRUE means we're in the middle of defining a loop.
   int looping;
 
   // TRUE means that we should convert spaces to a comma inside a
   // matrix definition.
   bool convert_spaces_to_comma;
 
+  // TRUE means we are at the beginning of a statement, where a
+  // command name is possible.
+  bool at_beginning_of_statement;
+
   // TRUE means we're in the middle of defining a function.
   bool defining_func;
 
   // Nonzero means we are parsing a function handle.
   int looking_at_function_handle;
 
   // TRUE means we're parsing the return list for a function.
   bool looking_at_return_list;
@@ -111,19 +115,16 @@ public:
   std::list<bool> looking_at_object_index;
 
   // Object index not possible until we've seen something.
   bool looking_for_object_index;
 
   // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
   bool do_comma_insert;
 
-  // TRUE means we're doing a raw input command.
-  bool doing_rawcommand;
-    
   // TRUE means we're looking at an indirect reference to a
   // structure element.
   bool looking_at_indirect_ref;
 
   // TRUE means that we've already seen the name of this function.
   // Should only matter if defining_func is also TRUE.
   bool parsed_function_name;
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-              2002, 2003, 2004, 2005, 2006, 2007 John W. Eaton
+              2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -151,34 +151,35 @@ along with Octave; see the file COPYING.
     { \
       yylval.tok_val = new token (name, input_line_number, \
 				  current_input_column); \
       token_stack.push (yylval.tok_val); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
-#define BIN_OP_RETURN(tok, convert) \
+#define BIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
       yylval.tok_val = new token (input_line_number, current_input_column); \
       token_stack.push (yylval.tok_val); \
       current_input_column += yyleng; \
       lexer_flags.quote_is_transpose = false; \
       lexer_flags.convert_spaces_to_comma = convert; \
       lexer_flags.looking_for_object_index = false; \
+      lexer_flags.at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
-#define XBIN_OP_RETURN(tok, convert) \
+#define XBIN_OP_RETURN(tok, convert, bos) \
   do \
     { \
       gripe_matlab_incompatible_operator (yytext); \
-      BIN_OP_RETURN (tok, convert); \
+      BIN_OP_RETURN (tok, convert, bos); \
     } \
   while (0)
 
 #define LEXER_DEBUG(pattern) \
   do \
     { \
       if (lexer_debug_flag) \
         lexer_debug (pattern, yytext); \
@@ -283,17 +284,17 @@ static void prep_for_function (void);
 static void prep_for_nested_function (void);
 static int process_comment (bool start_in_block, bool& eof);
 static bool match_any (char c, const char *s);
 static bool next_token_is_sep_op (void);
 static bool next_token_is_bin_op (bool spc_prev);
 static bool next_token_is_postfix_unary_op (bool spc_prev);
 static std::string strip_trailing_whitespace (char *s);
 static void handle_number (void);
-static int handle_string (char delim, int text_style = 0);
+static int handle_string (char delim);
 static int handle_close_bracket (bool spc_gobbled, int bracket_type);
 static int handle_identifier (void);
 static bool have_continuation (bool trailing_comments_ok = true);
 static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
 static void scan_for_comments (const char *);
 static yum_yum eat_whitespace (void);
 static yum_yum eat_continuation (void);
 static void maybe_warn_separator_insert (char sep);
@@ -334,80 +335,84 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     COUNT_TOK_AND_RETURN (SCRIPT);
   }
 
 <NESTED_FUNCTION_END>. {
     LEXER_DEBUG ("<NESTED_FUNCTION_END>.");
 
     BEGIN (NESTED_FUNCTION_BEGIN);
     xunput (yytext[0], yytext);
+
+    lexer_flags.at_beginning_of_statement = true;
+
     COUNT_TOK_AND_RETURN (';');
   }
 
 <NESTED_FUNCTION_BEGIN>. {
     LEXER_DEBUG ("<NESTED_FUNCTION_BEGIN>.");
 
     BEGIN (INITIAL);
     xunput (yytext[0], yytext);
+
     prep_for_nested_function ();
+
     COUNT_TOK_AND_RETURN (FCN);
   }
 
 %{
-// Help and other command-style functions are a pain in the ass.  This
-// stuff needs to be simplified.  May require some changes in the
-// parser too.
+// Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
 
     BEGIN (INITIAL);
     input_line_number++;
     current_input_column = 1;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.doing_rawcommand = false;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = true;
 
     COUNT_TOK_AND_RETURN ('\n');
   }
 
 <COMMAND_START>[\;\,] {
     LEXER_DEBUG ("<COMMAND_START>[\\;\\,]");
 
     lexer_flags.looking_for_object_index = false;
-
-    if (lexer_flags.doing_rawcommand)
-      TOK_PUSH_AND_RETURN (yytext, SQ_STRING);
+    lexer_flags.at_beginning_of_statement = true;
 
     BEGIN (INITIAL);
 
     if (strcmp (yytext, ",") == 0)
       TOK_RETURN (',');
     else
       TOK_RETURN (';');
   }
 
 <COMMAND_START>[\"\'] {
     LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
 
+    lexer_flags.at_beginning_of_statement = false;
+
     current_input_column++;
-    int tok = handle_string (yytext[0], true);
+    int tok = handle_string (yytext[0]);
 
     COUNT_TOK_AND_RETURN (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
 
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is `=' or `=='.
 //
@@ -425,16 +430,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\]{S}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.looking_for_object_index = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     int cont_is_spc = eat_continuation ();
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
       xunput (' ', yytext);
@@ -450,16 +456,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\}{S}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.looking_for_object_index = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     int cont_is_spc = eat_continuation ();
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
       xunput (' ', yytext);
@@ -478,16 +485,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
     current_input_column += yyleng;
 
     int tmp = eat_continuation ();
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     if (! lexer_flags.looking_at_object_index.front ())
       {
 	if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
 	  {
 	    maybe_warn_separator_insert (';');
 
 	    xunput (';', yytext);
@@ -504,16 +512,18 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // here we can end up inserting too many commas.
 %}
 
 <MATRIX_START>{S}+ {
     LEXER_DEBUG ("<MATRIX_START>{S}+");
 
     current_input_column += yyleng;
 
+    lexer_flags.at_beginning_of_statement = false;
+
     int tmp = eat_continuation ();
 
     if (! lexer_flags.looking_at_object_index.front ())
       {
 	bool bin_op = next_token_is_bin_op (true);
 	bool postfix_un_op = next_token_is_postfix_unary_op (true);
 	bool sep_op = next_token_is_sep_op ();
 
@@ -551,16 +561,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN (';');
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
@@ -573,16 +584,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     if (nesting_level.none ())
       return LEXICAL_ERROR;
 
     if (! lexer_flags.looking_at_object_index.front ()
 	&& nesting_level.is_bracket_or_brace ())
       {
 	maybe_warn_separator_insert (';');
@@ -597,16 +609,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     nesting_level.bracket ();
 
     lexer_flags.looking_at_object_index.push_front (false);
 
     current_input_column += yyleng;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     if (lexer_flags.defining_func && ! lexer_flags.parsed_function_name)
       lexer_flags.looking_at_return_list = true;
     else
       lexer_flags.looking_at_matrix_or_assign_lhs = true;
 
     promptflag--;
     eat_whitespace ();
@@ -619,16 +632,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 \] {
     LEXER_DEBUG ("\\]");
 
     nesting_level.remove ();
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.looking_for_object_index = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     TOK_RETURN (']');
   }
 
 %{
 // Imaginary numbers.
 %}
 
@@ -722,37 +736,46 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG ("@");
 
     current_input_column++;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = false;
     lexer_flags.looking_at_function_handle++;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     LEXER_DEBUG ("{NL}");
 
     input_line_number++;
     current_input_column = 1;
+
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
+
     if (nesting_level.none ())
-      COUNT_TOK_AND_RETURN ('\n');
+      {
+	lexer_flags.at_beginning_of_statement = true;
+	COUNT_TOK_AND_RETURN ('\n');
+      }
     else if (nesting_level.is_paren ())
-      gripe_matlab_incompatible ("bare newline inside parentheses");
+      {
+	lexer_flags.at_beginning_of_statement = false;
+	gripe_matlab_incompatible ("bare newline inside parentheses");
+      }
     else if (nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator. 
 %}
@@ -816,82 +839,85 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     LEXER_DEBUG ("^{S}*{CCHAR}\\{{S}*{NL}");
 
     lexer_flags.looking_for_object_index = false;
 
     input_line_number++;
     current_input_column = 1;
     block_comment_nesting_level++;
     promptflag--;
+
     bool eof = false;
     process_comment (true, eof);
   }
 
 %{
 // Other operators.
 %}
 
-":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false); }
-
-".+"	{ LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false); }
-".-"	{ LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false); }
-".*"	{ LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false); }
-"./"	{ LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false); }
-".\\"	{ LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false); }
-".^"	{ LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false); }
-".**"	{ LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false); }
-".'"	{ LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true); }
-"++"	{ LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN (PLUS_PLUS, true); }
-"--"	{ LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN (MINUS_MINUS, true); }
-"<="	{ LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false); }
-"=="	{ LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false); }
-"~="	{ LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false); }
-"!="	{ LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false); }
-">="	{ LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false); }
-"&"	{ LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false); }
-"|"	{ LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false); }
-"<"	{ LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false); }
-">"	{ LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false); }
-"+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false); }
-"-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false); }
-"*"	{ LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false); }
-"/"	{ LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false); }
-"\\"	{ LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false); }
-";"	{ LEXER_DEBUG (";"); BIN_OP_RETURN (';', true); }
-","	{ LEXER_DEBUG (","); BIN_OP_RETURN (',', true); }
-"^"	{ LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false); }
-"**"	{ LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false); }
-"="	{ LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true); }
-"&&"	{ LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false); }
-"||"	{ LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false); }
-"<<"	{ LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false); }
-">>"	{ LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false); }
+":"     { LEXER_DEBUG (":"); BIN_OP_RETURN (':', false, false); }
+
+".+"	{ LEXER_DEBUG (".+"); XBIN_OP_RETURN (EPLUS, false, false); }
+".-"	{ LEXER_DEBUG (".-"); XBIN_OP_RETURN (EMINUS, false, false); }
+".*"	{ LEXER_DEBUG (".*"); BIN_OP_RETURN (EMUL, false, false); }
+"./"	{ LEXER_DEBUG ("./"); BIN_OP_RETURN (EDIV, false, false); }
+".\\"	{ LEXER_DEBUG (".\\"); BIN_OP_RETURN (ELEFTDIV, false, false); }
+".^"	{ LEXER_DEBUG (".^"); BIN_OP_RETURN (EPOW, false, false); }
+".**"	{ LEXER_DEBUG (".**"); XBIN_OP_RETURN (EPOW, false, false); }
+".'"	{ LEXER_DEBUG (".'"); do_comma_insert_check (); BIN_OP_RETURN (TRANSPOSE, true, false); }
+"++"	{ LEXER_DEBUG ("++"); do_comma_insert_check (); XBIN_OP_RETURN (PLUS_PLUS, true, false); }
+"--"	{ LEXER_DEBUG ("--"); do_comma_insert_check (); XBIN_OP_RETURN (MINUS_MINUS, true, false); }
+"<="	{ LEXER_DEBUG ("<="); BIN_OP_RETURN (EXPR_LE, false, false); }
+"=="	{ LEXER_DEBUG ("=="); BIN_OP_RETURN (EXPR_EQ, false, false); }
+"~="	{ LEXER_DEBUG ("~="); BIN_OP_RETURN (EXPR_NE, false, false); }
+"!="	{ LEXER_DEBUG ("!="); XBIN_OP_RETURN (EXPR_NE, false, false); }
+">="	{ LEXER_DEBUG (">="); BIN_OP_RETURN (EXPR_GE, false, false); }
+"&"	{ LEXER_DEBUG ("&"); BIN_OP_RETURN (EXPR_AND, false, false); }
+"|"	{ LEXER_DEBUG ("|"); BIN_OP_RETURN (EXPR_OR, false, false); }
+"<"	{ LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
+">"	{ LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
+"+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false, false); }
+"-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false, false); }
+"*"	{ LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
+"/"	{ LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
+"\\"	{ LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
+";"     { LEXER_DEBUG (";"); BIN_OP_RETURN (';', true, true); }
+","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! lexer_flags.looking_at_object_index.front ()); }
+"^"	{ LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
+"**"	{ LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
+"="	{ LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
+"&&"	{ LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
+"||"	{ LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
+"<<"	{ LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
+">>"	{ LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
+
 
 {NOT} {
     LEXER_DEBUG ("{NOT}");
 
     if (yytext[0] == '~')
-      BIN_OP_RETURN (EXPR_NOT, false);
+      BIN_OP_RETURN (EXPR_NOT, false, false);
     else
-      XBIN_OP_RETURN (EXPR_NOT, false);
+      XBIN_OP_RETURN (EXPR_NOT, false, false);
   }
 
 "(" {
     LEXER_DEBUG ("(");
 
     // If we are looking for an object index, then push TRUE for
     // looking_at_object_index.  Otherwise, just push whatever state
     // is current (so that we can pop it off the stack when we find
     // the matching close paren).
 
     lexer_flags.looking_at_object_index.push_front
       (lexer_flags.looking_for_object_index);
 
     lexer_flags.looking_at_indirect_ref = false;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     nesting_level.paren ();
     promptflag--;
 
     TOK_RETURN ('(');
   }
 
 ")" {
@@ -900,74 +926,78 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     nesting_level.remove ();
     current_input_column++;
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.quote_is_transpose = true;
     lexer_flags.convert_spaces_to_comma = nesting_level.is_bracket_or_brace ();
     lexer_flags.looking_for_object_index = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     do_comma_insert_check ();
 
     COUNT_TOK_AND_RETURN (')');
   }
 
 "." {
     LEXER_DEBUG (".");
 
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     TOK_RETURN ('.');
   }
 
-"+="	{ LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false); }
-"-="	{ LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false); }
-"*="	{ LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false); }
-"/="	{ LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false); }
-"\\="	{ LEXER_DEBUG ("\\="); XBIN_OP_RETURN (LEFTDIV_EQ, false); }
-".+="	{ LEXER_DEBUG (".+="); XBIN_OP_RETURN (ADD_EQ, false); }
-".-="	{ LEXER_DEBUG (".-="); XBIN_OP_RETURN (SUB_EQ, false); }
-".*="	{ LEXER_DEBUG (".*="); XBIN_OP_RETURN (EMUL_EQ, false); }
-"./="	{ LEXER_DEBUG ("./="); XBIN_OP_RETURN (EDIV_EQ, false); }
-".\\="	{ LEXER_DEBUG (".\\="); XBIN_OP_RETURN (ELEFTDIV_EQ, false); }
-{POW}=  { LEXER_DEBUG ("{POW}="); XBIN_OP_RETURN (POW_EQ, false); }
-{EPOW}= { LEXER_DEBUG ("{EPOW}="); XBIN_OP_RETURN (EPOW_EQ, false); }
-"&="	{ LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false); }
-"|="	{ LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false); }
-"<<="	{ LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false); }
-">>="	{ LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false); }
+"+="	{ LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
+"-="	{ LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
+"*="	{ LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
+"/="	{ LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
+"\\="	{ LEXER_DEBUG ("\\="); XBIN_OP_RETURN (LEFTDIV_EQ, false, false); }
+".+="	{ LEXER_DEBUG (".+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
+".-="	{ LEXER_DEBUG (".-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
+".*="	{ LEXER_DEBUG (".*="); XBIN_OP_RETURN (EMUL_EQ, false, false); }
+"./="	{ LEXER_DEBUG ("./="); XBIN_OP_RETURN (EDIV_EQ, false, false); }
+".\\="	{ LEXER_DEBUG (".\\="); XBIN_OP_RETURN (ELEFTDIV_EQ, false, false); }
+{POW}=  { LEXER_DEBUG ("{POW}="); XBIN_OP_RETURN (POW_EQ, false, false); }
+{EPOW}= { LEXER_DEBUG ("{EPOW}="); XBIN_OP_RETURN (EPOW_EQ, false, false); }
+"&="	{ LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
+"|="	{ LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
+"<<="	{ LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
+">>="	{ LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
 
 \{{S}* {
     LEXER_DEBUG ("\\{{S}*");
 
     nesting_level.brace ();
 
     lexer_flags.looking_at_object_index.push_front
       (lexer_flags.looking_for_object_index);
 
     current_input_column += yyleng;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = true;
     lexer_flags.looking_for_object_index = false;
+    lexer_flags.at_beginning_of_statement = false;
 
     promptflag--;
     eat_whitespace ();
 
     lexer_flags.braceflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('{');
   }
 
 "}" {
     LEXER_DEBUG ("}");
 
     lexer_flags.looking_at_object_index.pop_front ();
 
     lexer_flags.looking_for_object_index = true;
+    lexer_flags.at_beginning_of_statement = false;
 
     nesting_level.remove ();
 
     TOK_RETURN ('}');
   }
 
 %{
 // Unrecognized input is a lexical error.
@@ -1411,103 +1441,122 @@ is_keyword_token (const std::string& s)
 
   if (kw)
     {
       yylval.tok_val = 0;
 
       switch (kw->kw_id)
 	{
 	case break_kw:
-	case case_kw:
 	case catch_kw:
 	case continue_kw:
 	case else_kw:
-	case elseif_kw:
-	case global_kw:
 	case otherwise_kw:
 	case return_kw:
+	case unwind_protect_cleanup_kw:
+	  lexer_flags.at_beginning_of_statement = true;
+	  break;
+
+	case case_kw:
+	case elseif_kw:
+	case global_kw:
 	case static_kw:
 	case until_kw:
-	case unwind_protect_cleanup_kw:
- 	  break;
+	  break;
 
 	case end_kw:
 	  if (inside_any_object_index ()
 	      || (lexer_flags.defining_func
 		  && ! (lexer_flags.looking_at_return_list
 			|| lexer_flags.parsed_function_name)))
 	    return 0;
 	  else
 	    {
 	      if (reading_fcn_file && end_tokens_expected == 1)
 		return -1;
 	      else
 		{
 		  yylval.tok_val = new token (token::simple_end, l, c);
+		  lexer_flags.at_beginning_of_statement = true;
 		  end_tokens_expected--;
 		}
 	    }
 	  break;
 
 	case end_try_catch_kw:
+	  yylval.tok_val = new token (token::try_catch_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::try_catch_end, l, c);
 	  break;
 
 	case end_unwind_protect_kw:
+	  yylval.tok_val = new token (token::unwind_protect_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::unwind_protect_end, l, c);
 	  break;
 
 	case endfor_kw:
+	  yylval.tok_val = new token (token::for_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::for_end, l, c);
 	  break;
 
 	case endfunction_kw:
 	  {
 	    if (reading_fcn_file && end_tokens_expected == 1)
 	      return -1;
 	    else
 	      {
 		yylval.tok_val = new token (token::function_end, l, c);
+		lexer_flags.at_beginning_of_statement = true;
 		end_tokens_expected--;
 	      }
 	  }
 	  break;
 
 	case endif_kw:
+	  yylval.tok_val = new token (token::if_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::if_end, l, c);
 	  break;
 
 	case endswitch_kw:
+	  yylval.tok_val = new token (token::switch_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::switch_end, l, c);
 	  break;
 
 	case endwhile_kw:
+	  yylval.tok_val = new token (token::while_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  end_tokens_expected--;
-	  yylval.tok_val = new token (token::while_end, l, c);
 	  break;
 
 	case for_kw:
 	case while_kw:
 	  end_tokens_expected++;
-	  // Fall through...
+	  promptflag--;
+	  lexer_flags.looping++;
+	  break;
 
 	case do_kw:
+	  lexer_flags.at_beginning_of_statement = true;
 	  promptflag--;
 	  lexer_flags.looping++;
 	  break;
 
+	case try_kw:
+	case unwind_protect_kw:
+	  lexer_flags.at_beginning_of_statement = true;
+	  end_tokens_expected++;
+	  promptflag--;
+	  break;
+
 	case if_kw:
-	case try_kw:
 	case switch_kw:
-	case unwind_protect_kw:
 	  end_tokens_expected++;
 	  promptflag--;
 	  break;
 
 	case function_kw:
 	  {
 	    if (lexer_flags.defining_func)
 	      {
@@ -1515,16 +1564,18 @@ is_keyword_token (const std::string& s)
 		  {
 		    if (lexer_flags.parsing_nested_function)
 		      {
 			BEGIN (NESTED_FUNCTION_END);
 
 			yylval.tok_val = new token (token::function_end, l, c);
 			token_stack.push (yylval.tok_val);
 
+			lexer_flags.at_beginning_of_statement = true;
+
 			return END;
 		      }
 		    else
 		      {
 			prep_for_nested_function ();
 
 			return FCN;
 		      }
@@ -1883,25 +1934,23 @@ process_comment (bool start_in_block, bo
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
   current_input_column = 1;
   lexer_flags.quote_is_transpose = false;
   lexer_flags.convert_spaces_to_comma = true;
+  lexer_flags.at_beginning_of_statement = true;
 
   if (YY_START == COMMAND_START)
     BEGIN (INITIAL);
 
   if (nesting_level.none ())
-    {
-      lexer_flags.doing_rawcommand = false;
-      return '\n';
-    }
+    return '\n';
   else if (nesting_level.is_bracket_or_brace ())
     return ';';
   else
     return 0;
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
@@ -2327,16 +2376,17 @@ handle_number (void)
 
   // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
   lexer_flags.quote_is_transpose = true;
   lexer_flags.convert_spaces_to_comma = true;
   lexer_flags.looking_for_object_index = true;
+  lexer_flags.at_beginning_of_statement = false;
 
   yylval.tok_val = new token (value, yytext, input_line_number,
 			      current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   current_input_column += yyleng;
 
@@ -2480,17 +2530,17 @@ eat_continuation (void)
     retval = eat_whitespace ();
   else
     xunput (c, yytext);
 
   return retval;
 }
 
 static int
-handle_string (char delim, int text_style)
+handle_string (char delim)
 {
   std::ostringstream buf;
 
   int bos_line = input_line_number;
   int bos_col = current_input_column;
 
   int c;
   int escape_pending = 0;
@@ -2533,46 +2583,40 @@ handle_string (char delim, int text_styl
 	  if (escape_pending)
 	    buf << static_cast<char> (c);
 	  else
 	    {
 	      c = text_yyinput ();
 	      if (c == delim)
 		{
 		  buf << static_cast<char> (c);		    
-		  if (lexer_flags.doing_rawcommand)
-		    buf << static_cast<char> (c);
 		}
 	      else
 		{
 		  std::string s;  
 		  xunput (c, yytext);
 
-		  if (lexer_flags.doing_rawcommand || delim == '\'')
+		  if (delim == '\'')
 		    s = buf.str ();
 		  else
 		    s = do_string_escapes (buf.str ());
 
-		  if (text_style && lexer_flags.doing_rawcommand)
-		    s = std::string (1, delim) + s + std::string (1, delim);
-		  else
-		    {
-		      lexer_flags.quote_is_transpose = true;
-		      lexer_flags.convert_spaces_to_comma = true;
-		    }
+		  lexer_flags.quote_is_transpose = true;
+		  lexer_flags.convert_spaces_to_comma = true;
 
 		  yylval.tok_val = new token (s, bos_line, bos_col);
 		  token_stack.push (yylval.tok_val);
 
 		  if (delim == '"')
 		    gripe_matlab_incompatible ("\" used as string delimiter");
 		  else if (delim == '\'')
 		    gripe_single_quote_string ();
 
                   lexer_flags.looking_for_object_index = true;
+		  lexer_flags.at_beginning_of_statement = false;
 
 		  return delim == '"' ? DQ_STRING : SQ_STRING;
 		}
 	    }
 	}
       else
 	{
 	  buf << static_cast<char> (c);
@@ -2776,23 +2820,276 @@ maybe_unput_comma (int spc_gobbled)
 	return;
 
       maybe_warn_separator_insert (',');
 
       xunput (',', yytext);
     }
 }
 
+static bool
+next_token_can_follow_bin_op (void)
+{
+  std::stack<char> buf;
+
+  int c = EOF;
+
+  // Skip whitespace in current statement on current line
+  while (true)
+    {
+      c = text_yyinput ();
+
+      if (! match_any (c, ",;\n") && (c == ' ' || c == '\t'))
+	buf.push (c);
+      else
+	break;
+    }
+
+  // Restore input.
+  while (! buf.empty ())
+    {
+      xunput (buf.top (), yytext);
+
+      buf.pop ();
+    }
+
+  return (isalnum (c) || match_any (c, "!\"'(-[_{~"));
+}
+
+static bool
+looks_like_command_arg (void)
+{
+  bool retval = true;
+
+  int c0 = text_yyinput ();
+
+  switch (c0)
+    {
+    // = ==
+    case '=':
+      {
+	int c1 = text_yyinput ();
+
+	if (c1 == '=')
+	  {
+	    int c2 = text_yyinput ();
+
+	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		&& next_token_can_follow_bin_op ())
+	      retval = false;
+
+	    xunput (c2, yytext);
+	  }
+	else
+	  retval = false;
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    case '(':
+    case '{':
+      // Indexing.
+      retval = false;
+      break;
+
+    case '\n':
+      // EOL.
+      break;
+
+    case '\'':
+    case '"':
+      // Beginning of a character string.
+      break;
+
+    // + - ++ -- += -=
+    case '+':
+    case '-':
+      {
+	int c1 = text_yyinput ();
+
+	switch (c1)
+	  {
+	  case '\n':
+	    // EOL.
+	  case '+':
+	  case '-':
+	    // Unary ops, spacing doesn't matter.
+	    break;
+
+	  case '\t':
+	  case ' ':
+	    {
+	      if (next_token_can_follow_bin_op ())
+		retval = false;
+	    }
+	    break;
+
+	  case '=':
+	    {
+	      int c2 = text_yyinput ();
+
+	      if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		  && next_token_can_follow_bin_op ())
+		retval = false;
+
+	      xunput (c2, yytext);
+	    }
+	    break;
+	  }
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    case ':':
+    case '/':
+    case '\\':
+    case '^':
+      {
+	int c1 = text_yyinput ();
+
+	if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+	    && next_token_can_follow_bin_op ())
+	  retval = false;
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    // .+ .- ./ .\ .^ .* .**
+    case '.':
+      {
+	int c1 = text_yyinput ();
+
+	if (match_any (c1, "+-/\\^*"))
+	  {
+	    int c2 = text_yyinput ();
+
+	    if (c2 == '=')
+	      {
+		int c3 = text_yyinput ();
+
+		if (! match_any (c3, ",;\n") && (c3 == ' ' || c3 == '\t')
+		    && next_token_can_follow_bin_op ())
+		  retval = false;
+
+		xunput (c3, yytext);
+	      }
+	    else if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		     && next_token_can_follow_bin_op ())
+	      retval = false;
+
+	    xunput (c2, yytext);
+	  }
+	else if (! match_any (c1, ",;\n")
+		 && (! isdigit (c1) && c1 != ' ' && c1 != '\t'
+		     && c1 != '.'))
+	  {
+	    // Structure reference.  FIXME -- is this a complete check?
+
+	    retval = false;
+	  }
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    // & && | || * **
+    case '&':
+    case '|':
+    case '*':
+      {
+	int c1 = text_yyinput ();
+
+	if (c1 == c0)
+	  {
+	    int c2 = text_yyinput ();
+
+	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		&& next_token_can_follow_bin_op ())
+	      retval = false;
+
+	    xunput (c2, yytext);
+	  }
+	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+		 && next_token_can_follow_bin_op ())
+	  retval = false;
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    // < <= > >=
+    case '<':
+    case '>':
+      {
+	int c1 = text_yyinput ();
+
+	if (c1 == '=')
+	  {
+	    int c2 = text_yyinput ();
+
+	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		&& next_token_can_follow_bin_op ())
+	      retval = false;
+
+	    xunput (c2, yytext);
+	  }
+	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+		 && next_token_can_follow_bin_op ())
+	  retval = false;
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    // ~= !=
+    case '~':
+    case '!':
+      {
+	int c1 = text_yyinput ();
+
+	// ~ and ! can be unary ops, so require following =.
+	if (c1 == '=')
+	  {
+	    int c2 = text_yyinput ();
+
+	    if (! match_any (c2, ",;\n") && (c2 == ' ' || c2 == '\t')
+		&& next_token_can_follow_bin_op ())
+	      retval = false;
+
+	    xunput (c2, yytext);
+	  }
+	else if (! match_any (c1, ",;\n") && (c1 == ' ' || c1 == '\t')
+		 && next_token_can_follow_bin_op ())
+	  retval = false;
+
+	xunput (c1, yytext);
+      }
+      break;
+
+    default:
+      break;
+    }
+
+  xunput (c0, yytext);
+
+  return retval;
+}
+
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 static int
 handle_identifier (void)
 {
+  bool at_bos = lexer_flags.at_beginning_of_statement;
+
   std::string tok = strip_trailing_whitespace (yytext);
 
   int c = yytext[yyleng-1];
 
   int cont_is_spc = eat_continuation ();
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
@@ -2815,18 +3112,29 @@ handle_identifier (void)
       lexer_flags.quote_is_transpose = true;
       lexer_flags.convert_spaces_to_comma = true;
 
       current_input_column += yyleng;
 
       return STRUCT_ELT;
     }
 
+  lexer_flags.at_beginning_of_statement = false;
+
+  // The is_keyword_token may reset
+  // lexer_flags.at_beginning_of_statement.  For example, if it sees
+  // an else token, then the next token is at the beginning of a
+  // statement.
+
   int kw_token = is_keyword_token (tok);
 
+  // If we found a keyword token, then the beginning_of_statement flag
+  // is already set.  Otherwise, we won't be at the beginning of a
+  // statement.
+
   if (lexer_flags.looking_at_function_handle)
     {
       if (kw_token)
 	{
 	  error ("function handles may not refer to keywords");
 
 	  return LEXICAL_ERROR;
 	}
@@ -2859,18 +3167,16 @@ handle_identifier (void)
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
 
-  bool next_tok_is_paren = (c1 == '(');
-
   bool next_tok_is_eq = false;
   if (c1 == '=')
     {
       int c2 = text_yyinput ();
       xunput (c2, yytext);
 
       if (c2 != '=')
 	next_tok_is_eq = true;
@@ -2883,42 +3189,34 @@ handle_identifier (void)
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
   // If the following token is `=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
   // as a variable in the current symbol table.
 
-  if (is_command_name (tok) && ! is_variable (tok))
+  if (! is_variable (tok))
     {
-      if (next_tok_is_eq
-	  || lexer_flags.looking_at_decl_list
-	  || lexer_flags.looking_at_return_list
-	  || (lexer_flags.looking_at_parameter_list
-	      && ! lexer_flags.looking_at_initializer_expression))
+      if (at_bos && spc_gobbled && looks_like_command_arg ())
+	{
+	  BEGIN (COMMAND_START);
+	}
+      else if (next_tok_is_eq
+	       || lexer_flags.looking_at_decl_list
+	       || lexer_flags.looking_at_return_list
+	       || (lexer_flags.looking_at_parameter_list
+		   && ! lexer_flags.looking_at_initializer_expression))
 	{
 	  force_local_variable (tok);
 	}
       else if (lexer_flags.looking_at_matrix_or_assign_lhs)
 	{
 	  lexer_flags.pending_local_variables.insert (tok);
 	}
-      else if (! (next_tok_is_paren
-		  || lexer_flags.looking_at_object_index.front ()))
-	{
-	  BEGIN (COMMAND_START);
-	}
-
-      if (is_rawcommand_name (tok)
-	  && ! lexer_flags.looking_at_object_index.front ())
-	{
-	  lexer_flags.doing_rawcommand = true;
-	  BEGIN (COMMAND_START);
-	}
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";    
 
@@ -2927,17 +3225,17 @@ handle_identifier (void)
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
   lexer_flags.convert_spaces_to_comma = true;
 
-  if (! next_tok_is_eq)
+  if (! (next_tok_is_eq || YY_START == COMMAND_START))
     {
       lexer_flags.quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
@@ -2983,41 +3281,41 @@ lexical_feedback::init (void)
   while (! looking_at_object_index.empty ())
     looking_at_object_index.pop_front ();
 
   looking_at_object_index.push_front (false);
 
   // Object index not possible until we've seen something.
   looking_for_object_index = false;
 
+  // Yes, we are at the beginning of a statement.
+  at_beginning_of_statement = true;
+
   // No need to do comma insert or convert spaces to comma at
   // beginning of input. 
   convert_spaces_to_comma = true;
   do_comma_insert = false;
 
-  // Not initially doing any plotting or setting of plot attributes.
-  doing_rawcommand = false;
-
   // Not initially looking at indirect references.
   looking_at_indirect_ref = false;
 
   // Quote marks strings intially.
   quote_is_transpose = false;
 
   // Set of identifiers that might be local variable names is empty.
   pending_local_variables.clear ();
 }
 
 bool
 is_keyword (const std::string& s)
 {
   return octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0;
 }
 
-DEFCMD (iskeyword, args, ,
+DEFUN (iskeyword, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iskeyword (@var{name})\n\
 Return true if @var{name} is an Octave keyword.  If @var{name}\n\
 is omitted, return a list of keywords.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -1892,17 +1892,17 @@ No checks are made for duplicate element
 
 	  octave_stdout << "\n";
 	}
     }
 
   return retval;
 }
 
-DEFCMD (addpath, args, nargout,
+DEFUN (addpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add @var{dir1}, @dots{} to the current function search path.  If\n\
 @var{option} is @samp{\"-begin\"} or 0 (the default), prepend the\n\
 directory name to the current path.  If @var{option} is @samp{\"-end\"}\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
@@ -1988,17 +1988,17 @@ Directories added to the path must exist
 	}
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (rmpath, args, nargout,
+DEFUN (rmpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
 \n\
 @seealso{path, addpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   // Originally by Etienne Grossmann. Heavily modified and translated
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -537,17 +537,17 @@ find_file_to_load (const std::string& na
 #ifdef HAVE_HDF5
 #define HAVE_HDF5_HELP_STRING ""
 #else /* ! HAVE_HDF5 */
 #define HAVE_HDF5_HELP_STRING "\n\
 HDF5 load and save are not available, as this Octave executable was\n\
 not linked with the HDF5 library."
 #endif /* ! HAVE HDF5 */
 
-DEFCMD (load, args, nargout,
+DEFUN (load, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} load options file v1 v2 @dots{}\n\
 Load the named variables @var{v1}, @var{v2}, @dots{}, from the file\n\
 @var{file}.  As with @code{save}, you may specify a list of variables\n\
 and @code{load} will only extract those variables with names that\n\
 match.  For example, to restore the variables saved in the file\n\
 @file{data}, use the command\n\
 \n\
@@ -1441,17 +1441,17 @@ dump_octave_core (void)
 #ifdef HAVE_ZLIB
 #define HAVE_ZLIB_HELP_STRING ""
 #else /* ! HAVE_ZLIB */
 #define HAVE_ZLIB_HELP_STRING "\n\
 This option is not available, as this Octave executable was not linked with\n\
 the zlib library."
 #endif /* ! HAVE ZLIB */
 
-DEFCMD (save, args, ,
+DEFUN (save, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} save options file @var{v1} @var{v2} @dots{}\n\
 @deffnx {Command} save options file -struct @var{STR} @var{f1} @var{f2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
 @var{file}.  The special filename @samp{-} may be used to write the\n\
 output to your terminal.  If no variable names are listed, Octave saves\n\
 all the variables in the current scope.\n\
 If the @code{-struct} modifier is used, fields @var{f1} @var{f2} @dots{}\n\
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -46,45 +46,41 @@ cat << \EOF
 #include "builtins.h"
 
 #if defined (quad)
 #undef quad
 #endif
 
 #if defined (ENABLE_DYNAMIC_LINKING)
 
-#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc)
+#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, doc)
 
-#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, \
-                             is_text_fcn, doc)
+#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, doc)
 
 #else
 
-#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
-  XDEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc)
+#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, doc) \
+  XDEFUN_INTERNAL(name, args_name, nargout_name, doc)
 
-#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, \
-                             is_text_fcn, doc) \
-  XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, is_text_fcn, doc)
+#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, doc) \
+  XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc)
 
 #endif
 
-#define XDEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define XDEFUN_INTERNAL(name, args_name, nargout_name, doc) \
   extern DECLARE_FUN (name, args_name, nargout_name); \
-  install_builtin_function (F ## name, #name, doc, is_text_fcn); \
+  install_builtin_function (F ## name, #name, doc); \
 
-#define XDEFCONSTFUN_INTERNAL(name, args_name, nargout_name, \
-			      is_text_fcn, doc) \
+#define XDEFCONSTFUN_INTERNAL(name, args_name, nargout_name, doc) \
   extern DECLARE_FUN (name, args_name, nargout_name); \
-  install_builtin_function (F ## name, #name, doc, is_text_fcn, false); \
+  install_builtin_function (F ## name, #name, doc, false); \
 
-#define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
-			 is_text_fcn, doc) \
+#define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc) \
   extern DECLARE_FUNX (fname, args_name, nargout_name); \
-  install_builtin_function (fname, name, doc, is_text_fcn); \
+  install_builtin_function (fname, name, doc); \
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
 #define XDEFCONST_INTERNAL(name, defn, doc)
 
 EOF
 
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -37,32 +37,29 @@ cat << \EOF
 
 #if defined (__DECCXX)
 #define __USE_STD_IOSTREAM
 #endif
 
 #include <iostream>
 #include <string>
 
-#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, doc) \
   print_doc_string (#name, doc);
 
-#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, \
-                             is_text_fcn, doc) \
+#define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, doc) \
   print_doc_string (name, doc);
 
-#define XDEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
+#define XDEFUN_INTERNAL(name, args_name, nargout_name, doc) \
   print_doc_string (#name, doc);
 
-#define XDEFCONSTFUN_INTERNAL(name, args_name, nargout_name, \
-			      is_text_fcn, doc) \
+#define XDEFCONSTFUN_INTERNAL(name, args_name, nargout_name, doc) \
   print_doc_string (#name, doc);
 
-#define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
-			 is_text_fcn, doc) \
+#define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc) \
   print_doc_string (name, doc);
 
 #define XDEFALIAS_INTERNAL(alias, name)
 
 #define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   print_doc_string (#name, doc);
 
 #define XDEFCONST_INTERNAL(name, defn, doc) \
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -544,17 +544,17 @@ octave_history_write_timestamp (void)
   octave_localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
     command_history::add (timestamp);
 }
 
-DEFCMD (edit_history, args, ,
+DEFUN (edit_history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} edit_history options\n\
 If invoked with no arguments, @code{edit_history} allows you to edit the\n\
 history list using the editor named by the variable @code{EDITOR}.  The\n\
 commands to be edited are first copied to a temporary file.  When you\n\
 exit the editor, Octave executes the commands that remain in the file.\n\
 It is often more convenient to use @code{edit_history} to define functions \n\
 rather than attempting to enter them directly on the command line.\n\
@@ -594,17 +594,17 @@ omitted, the previous command in the his
   if (error_state)
     return retval;
 
   do_edit_history (argc, argv);
 
   return retval;
 }
 
-DEFCMD (history, args, ,
+DEFUN (history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} history options\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.  Valid options are:\n\
 \n\
 @table @code\n\
 @item -w @var{file}\n\
 Write the current history to the file @var{file}.  If the name is\n\
@@ -637,17 +637,17 @@ typed without displaying line numbers, u
   if (error_state)
     return retval;
 
   do_history (argc, argv);
 
   return retval;
 }
 
-DEFCMD (run_history, args, ,
+DEFUN (run_history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} run_history [first] [last]\n\
 Similar to @code{edit_history}, except that the editor is not invoked,\n\
 and the commands are simply executed as they appear in the history list.\n\
 @end deffn")
 {
   octave_value_list retval;
 
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1261,17 +1261,17 @@ is a method of this class.\n\
 	}
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (methods, args, nargout,
+DEFUN (methods, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} methods (@var{x})\n\
 @deftypefnx {Built-in Function} {} methods (\"classname\")\n\
 Return a cell array containing the names of the methods for the\n\
 object @var{x} or the named class.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -413,17 +413,17 @@ open_diary_file (void)
   octave_stdout.set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
-DEFCMD (diary, args, ,
+DEFUN (diary, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} diary options\n\
 Create a list of all commands @emph{and} the output they produce, mixed\n\
 together just as you see them on your terminal.  Valid options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Start recording your session in a file called @file{diary} in your\n\
@@ -484,17 +484,17 @@ Without any arguments, @code{diary} togg
     default:
       print_usage ();
       break;
     }
 
   return retval;
 }
 
-DEFCMD (more, args, ,
+DEFUN (more, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} more\n\
 @deffnx {Command} more on\n\
 @deffnx {Command} more off\n\
 Turn output pagination on or off.  Without an argument, @code{more}\n\
 toggles the current state.\n\
 The current state can be determined via @code{page_screen_output}.\n\
 @end deffn")
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-              2002, 2003, 2004, 2005, 2006, 2007, 2008 John W. Eaton
+              2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -539,16 +539,39 @@ list1		: statement
 		| list1 sep statement
 		  { $$ = append_statement_list ($1, $2, $3, true); }
 		;
 
 statement	: expression
 		  { $$ = make_statement ($1); }
 		| command
 		  { $$ = make_statement ($1); }
+		| word_list_cmd
+		  { $$ = make_statement ($1); }
+		;
+
+// =================
+// Word-list command
+// =================
+
+// These are not really like expressions since they can't appear on
+// the RHS of an assignment.  But they are also not like commands (IF,
+// WHILE, etc.
+
+word_list_cmd	: identifier word_list
+		  { $$ = make_index_expression ($1, $2, '('); }
+		;
+
+word_list	: string
+		  { $$ = new tree_argument_list ($1); }
+		| word_list string
+		  {
+		    $1->append ($2);
+		    $$ = $1;
+		  }
 		;
 
 // ===========
 // Expressions
 // ===========
 
 identifier	: NAME
 		  {
@@ -850,33 +873,18 @@ assign_expr	: assign_lhs '=' expression
 		| assign_lhs EPOW_EQ expression
 		  { $$ = make_assign_op (EPOW_EQ, $1, $2, $3); }
 		| assign_lhs AND_EQ expression
 		  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
 		| assign_lhs OR_EQ expression
 		  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
 		;
 
-word_list_cmd	: identifier word_list
-		  { $$ = make_index_expression ($1, $2, '('); }
-		;
-
-word_list	: string
-		  { $$ = new tree_argument_list ($1); }
-		| word_list string
-		  {
-		    $1->append ($2);
-		    $$ = $1;
-		  }
-		;
-
 expression	: simple_expr
 		  { $$ = $1; }
-		| word_list_cmd
-		  { $$ = $1; }
 		| assign_expr
 		  { $$ = $1; }
 		| anon_fcn_handle
 		  { $$ = $1; }
 		;
 
 // ================================================
 // Commands, declarations, and function definitions
@@ -3371,17 +3379,17 @@ load_fcn_from_file (const std::string& f
   if (retval)
     retval->stash_dir_name (dir_name);
 
   unwind_protect::run_frame ("load_fcn_from_file");
 
   return retval;
 }
 
-DEFCMD (autoload, args, ,
+DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
 The second argument, @var{file}, should be an absolute file name or\n\
 a file name in the same directory as the function or script from which\n\
 the autoload command was run. @var{file} should not depend on the\n\
 Octave load path.\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3393,17 +3393,17 @@ set_format_style (int argc, const string
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
-DEFCMD (format, args, ,
+DEFUN (format, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} format options\n\
 Control the format of the output produced by @code{disp} and Octave's\n\
 normal echoing mechanism.  Valid options are listed in the following\n\
 table.\n\
 \n\
 @table @code\n\
 @item short\n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -900,17 +900,17 @@ tilde_expand (\"~/bin\")\n\
   else
     print_usage ();
 
   return retval;
 }
 
 #if defined (__EMX__) && defined (OS2)
 
-DEFCMD (extproc, , ,
+DEFUN (extproc, , ,
   "extproc: ignored by Octave")
 {
   return octave_value_list ();
 }
 
 DEFALIAS (EXTPROC, extproc);
 
 #endif
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -85,17 +85,17 @@ valid_identifier (const char *s)
 }
 
 bool
 valid_identifier (const std::string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
-DEFCMD (isvarname, args, ,
+DEFUN (isvarname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int argc = args.length () + 1;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -86,288 +86,16 @@ clear_variable (const std::string& nm)
 void
 clear_symbol (const std::string& nm)
 {
   symbol_table::clear_symbol (nm);
 }
 
 // Attributes of variables and functions.
 
-// Is this a command-style function?
-
-static std::set <std::string> command_set;
-
-void
-mark_as_command (const std::string& s)
-{
-  command_set.insert (s);
-}
-
-static inline void
-unmark_command (const std::string& s)
-{
-  command_set.erase (s);
-}
-
-DEFCMD (mark_as_command, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mark_as_command (@var{name})\n\
-Enter @var{name} into the list of commands.\n\
-@seealso{unmark_command, iscommand}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (symbol_table::at_top_level ())
-    {
-      int nargin = args.length ();
-
-      if (nargin > 0)
-	{
-	  int argc = nargin + 1;
-
-	  string_vector argv = args.make_argv ("mark_as_command");
-
-	  if (! error_state)
-	    {
-	      for (int i = 1; i < argc; i++)
-		mark_as_command (argv[i]);
-	    }
-	}
-      else
-	print_usage ();
-    }
-  else
-    warning ("mark_as_command: invalid use inside function body");
-
-  return retval;
-}
-
-DEFCMD (unmark_command, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} unmark_command (@var{name})\n\
-Remove @var{name} from the list of commands.\n\
-@seealso{mark_as_command, iscommand}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (symbol_table::at_top_level ())
-    {
-      int nargin = args.length ();
-
-      if (nargin > 0)
-	{
-	  int argc = nargin + 1;
-
-	  string_vector argv = args.make_argv ("unmark_command");
-
-	  if (! error_state)
-	    {
-	      for (int i = 1; i < argc; i++)
-		unmark_command (argv[i]);
-	    }
-	}
-      else
-	print_usage ();
-    }
-  else
-    warning ("mark_as_command: invalid use inside function body");
-
-  return retval;
-}
-
-bool
-is_command_name (const std::string& s)
-{
-  return command_set.find (s) != command_set.end ();
-}
-
-
-DEFCMD (iscommand, args, ,
-"-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} iscommand (@var{name})\n\
-Return true if @var{name} is a command style function.  If @var{name}\n\
-is omitted, return a list of identifiers which are marked as commands with\n\
-@code{mark_as_command}.\n\
-@seealso{mark_as_command, unmark_command}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    {
-      string_vector lst (command_set.size ());
-
-      int i = 0;
-      for (std::set<std::string>::const_iterator p = command_set.begin ();
-	   p != command_set.end (); p++)
-	lst[i++] = *p;
-
-      retval = Cell (lst.sort ());
-    }
-  else if (nargin == 1)
-    {
-      string_vector argv = args.make_argv ("iscommand");
-	  
-      if (! error_state)
-	{
-	  std::string s = argv[1];
-	  retval = is_command_name(s);
-	}
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
-// Is this a raw input command?
-
-static std::set <std::string> rawcommand_set;
-
-void
-mark_as_rawcommand (const std::string& s)
-{
-  command_set.insert (s);    
-  rawcommand_set.insert (s);
-}
-
-void
-unmark_rawcommand (const std::string& s)
-{
-  rawcommand_set.erase (s);
-}
-
-DEFCMD (mark_as_rawcommand, args, ,
-"-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mark_as_rawcommand (@var{name})\n\
-Enter @var{name} into the list of raw input commands and to the list of\n\
-command style functions.\n\
-Raw input commands are like normal command style functions, but they\n\
-receive their input unprocessed (ie. strings still contain the quotes\n\
-and escapes they had when input). However, comments and continuations\n\
-are handled as usual, you cannot pass a token starting with a comment\n\
-character ('#' or '%') to your function, and the last token cannot be\n\
-a continuation token ('\\' or '...').\n\
-@seealso{unmark_rawcommand, israwcommand, iscommand, mark_as_command}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (symbol_table::at_top_level ())
-    {
-      int nargin = args.length ();
-
-      if (nargin > 0)
-	{
-	  int argc = nargin + 1;
-
-	  string_vector argv = args.make_argv ("mark_as_rawcommand");
-
-	  if (! error_state)
-	    {
-	      for (int i = 1; i < argc; i++)
-		mark_as_rawcommand (argv[i]);
-	    }
-	}
-      else
-	print_usage ();
-    }
-  else
-    warning ("mark_as_rawcommand: invalid use inside function body");
-
-  return retval;
-}
-
-DEFCMD (unmark_rawcommand, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} unmark_rawcommand (@var{name})\n\
-Remove @var{name} from the list of raw input commands.\n\
-Note that this does not remove @var{name} from the list of command style\n\
-functions.\n\
-@seealso{mark_as_rawcommand, israwcommand, iscommand, unmark_command}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (symbol_table::at_top_level ())
-    {
-      int nargin = args.length ();
-
-      if (nargin > 0)
-	{
-	  int argc = nargin + 1;
-
-	  string_vector argv = args.make_argv ("unmark_rawcommand");
-
-	  if (! error_state)
-	    {
-	      for (int i = 1; i < argc; i++)
-		unmark_rawcommand (argv[i]);
-	    }
-	}
-      else
-	print_usage ();
-    }
-  else
-    warning ("unmark_rawcommand: invalid use inside function body");
-
-  return retval;
-}
-
-bool
-is_rawcommand_name (const std::string& s)
-{
-  return rawcommand_set.find (s) != rawcommand_set.end ();
-}
-
-DEFCMD (israwcommand, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} israwcommand (@var{name})\n\
-Return true if @var{name} is a raw input command function.\n\
-If @var{name} is omitted, return a list of identifiers which are marked as\n\
-raw input commands with mark_as_rawcommand.\n\
-@seealso{mark_as_rawcommand, unmark_rawcommand}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    {
-      string_vector lst (rawcommand_set.size());
-      
-      int i = 0;
-      for (std::set<std::string>::const_iterator p = rawcommand_set.begin ();
-	   p != rawcommand_set.end ();
-	   p++)
-	lst[i++] = *p;
-
-      retval = Cell (lst.sort ());
-    }
-  else if (nargin == 1)
-    {
-      string_vector argv = args.make_argv ("israwcommand");
-	  
-      if (! error_state)
-	{
-	  std::string s = argv[1];
-	  retval = is_rawcommand_name(s);
-	}
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
 		   const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
@@ -1818,17 +1546,17 @@ do_who (int argc, const string_vector& a
 	}
 
       octave_stdout << "\n";
     }
 
   return retval;
 }
 
-DEFCMD (who, args, nargout,
+DEFUN (who, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} who options pattern @dots{}\n\
 @deffnx {Command} whos options pattern @dots{}\n\
 List currently defined symbols matching the given patterns.  The\n\
 following are valid options.  They may be shortened to one character but\n\
 may not be combined.\n\
 \n\
 @table @code\n\
@@ -1864,17 +1592,17 @@ The command @kbd{whos} is equivalent to 
 	retval = do_who (argc, argv, nargout == 1);
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (whos, args, nargout,
+DEFUN (whos, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} whos options pattern @dots{}\n\
 See who.\n\
 @end deffn")
 {
   octave_value retval;
 
   if (nargout < 2)
@@ -1966,17 +1694,17 @@ mislocked (const std::string& nm)
 
       if (fcn)
 	retval = fcn->islocked ();
     }
 
   return retval;
 }
 
-DEFCMD (mlock, args, ,
+DEFUN (mlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mlock ()\n\
 Lock the current function into memory so that it can't be cleared.\n\
 @seealso{munlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -1990,17 +1718,17 @@ Lock the current function into memory so
 	error ("mlock: invalid use outside a function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFCMD (munlock, args, ,
+DEFUN (munlock, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function.  If no function is named\n\
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -2025,17 +1753,17 @@ then unlock the current function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 
-DEFCMD (mislocked, args, ,
+DEFUN (mislocked, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mislocked (@var{fcn})\n\
 Return true if the named function is locked.  If no function is named\n\
 then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2277,17 +2005,17 @@ do_matlab_compatible_clear (const string
       if (cond) \
         { \
           print_usage (); \
           return retval; \
         } \
     } \
   while (0)
 
-DEFCMD (clear, args, ,
+DEFUN (clear, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} clear [options] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.  The\n\
 pattern may contain the following special characters:\n\
 \n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -39,26 +39,16 @@ class string_vector;
 #include <string>
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern OCTINTERP_API void clear_mex_functions (void);
 
-extern OCTINTERP_API void mark_as_command (const std::string&);
-extern OCTINTERP_API bool is_command_name (const std::string&);
-
-// The next three are here temporarily...
-extern OCTINTERP_API bool is_marked_as_rawcommand (const std::string& s);
-extern OCTINTERP_API void mark_as_rawcommand (const std::string& s);
-extern OCTINTERP_API void unmark_rawcommand (const std::string& s);
-
-extern OCTINTERP_API bool is_rawcommand_name (const std::string&);
-
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
 		   bool warn = false); 
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = std::string (),
 		   bool warn = false); 
 
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,8 +1,13 @@
+2009-02-15  John W. Eaton  <jwe@octave.org>
+
+	* test_io.m, test_prefer.m: Avoid command-style function call
+	syntax when assigning results.
+
 2009-02-09  John W. Eaton  <jwe@octave.org>
 
 	* fntests.m (hastests): Error if fopen fails.
 
 2009-01-29  John W. Eaton  <jwe@octave.org>
 
 	* test_system.m: Use isfield instead of struct_contains.
 
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -191,27 +191,27 @@
 %! 
 %! STR.scalar_fld = 1;
 %! STR.matrix_fld = [1.1,2;3,4];
 %! STR.string_fld = "Octave";
 %! STR.struct_fld.x = 0;
 %! STR.struct_fld.y = 1;
 %! 
 %! save struct.dat -struct STR;
-%! STR = load struct.dat ;
+%! STR = load ("struct.dat");
 %!
 %! assert(STR.scalar_fld == 1 && ...
 %! 	STR.matrix_fld == [1.1,2;3,4] && ...
 %! 	STR.string_fld == "Octave" && ...
 %! 	STR.struct_fld.x == 0 && ...
 %! 	STR.struct_fld.y == 1 );
 %!
 %!
 %! save -binary struct.dat -struct STR matrix_fld str*_fld;
-%! STR = load struct.dat ;
+%! STR = load ("struct.dat");
 %!
 %! assert(!isfield(STR,"scalar_fld") && ...
 %! 	STR.matrix_fld == [1.1,2;3,4] && ...
 %! 	STR.string_fld == "Octave" && ...
 %! 	STR.struct_fld.x == 0 && ...
 %! 	STR.struct_fld.y == 1);
 %!
 %! delete struct.dat;
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -129,27 +129,27 @@
 %! a = 1
 %! print_answer_id_name (pid);
 
 %% test/octave.test/prefer/prefer-21.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (0);
 %! a = cell (1, 1);
-%! b = type -q a;
+%! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[]")));
 %! assert (isempty (findstr (b{1} ,"[](0x0)")));
 %! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-22.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (1);
 %! a = cell (1, 1);
-%! b = type -q a;
+%! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[](0x0)")));
 %! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-23.m
 %!assert(all (size (inv ([])) == [0, 0]));
 
 %% test/octave.test/prefer/prefer-24.m
 %!assert(all (svd ([]) == zeros (0, 1)));
