# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1368847045 14400
#      Fri May 17 23:17:25 2013 -0400
# Branch classdef
# Node ID 7368654f302fb5662e90924a162615210baefaae
# Parent  450c03932d6c5d9c65bfe268f80a3df7443e41d8
Initial support for (classdef) packages.

* libinterp/interpfcn/load-path.h (class load_path::loader): New class.
(load_path::default_loader, load_path::loader_map): New members.
(load_path::load_path): Initialize them.
(load_path::fcn_map, load_path::private_fcn_map,
load_path::method_map): Move to class load_path::loader.
(load_path::add_to_fcn_map, load_path::add_to_private_fcn_map,
load_path::add_to_method_map, load_path::move_fcn_map,
load_path::move_method_map, load_path::remove_fcn_map,
load_path::remove_private_fcn_map, load_path::remove_method_map):
Move to class load_path::loader.
(load_path::move): Change signature.
(load_path::do_move, load_path::remove, load_path::add,
load_path::get_loader): New methods.
(load_path::find_package, load_path::do_find_package): Likewise.
(load_path::dir_info::package_dir_map): New member.
(load_path::dir_info::dir_info, load_path::dir_info::operator=):
Initialize/assign it.
(load_path::dir_info::get_package_dir): New method.
(load_path::do_find_fcn, load_path::do_find_private_fcn): Remove
methods.
(load_path::find_fcn, load_path::find_private_fcn,
load_path::find_fcn_file, load_path::find_oct_file,
load_path::find_mex_file): Rewrite using class load_path::loader.
New argument for package name.

*libinterp/interpfcn/load-path.cc (load_path::dir_info::initialize):
Clear package_map_dir.
(load_path::dir_info::get_package_dir): New method.
(load_path::dir_info::get_files_list): Use it.
(load_path::add_to_fcn_map, load_path::add_to_private_fcn_map,
load_path::add_to_method_map, load_path::move_fcn_map,
load_path::move_method_map, load_path::remove_fcn_map,
load_path::remove_private_fcn_map, load_path::remove_method_map):
Move to class load_path::loader.
(load_path::move): Move implementation to do_move, rewrite using
class load_path::loader. Signature change.
(load_path::do_move, load_path::add, load_path::remove): New methods.
(load_path::do_clear): Rewrite using class load_path::loader.
(load_path::do_add): Use "do_move" and "add" methods.
(load_path::do_remove): Rewrite using "remove" method.
(load_path::do_update): Rewitre using class load_path::loader and
"add" method.
(load_path::do_find_method, load_path::do_methods,
load_path::do_overloads, load_path::do_fcn_names, load_path::do_display):
Move Implementation to class load_path::loader, without "do_" prefix.
Rewrite original to redirect to appropriate loaders.
(F__dump_load_path__): New debug function.

* libinterp/interpfcn/symtab.h (symbol_table::package_name): New member.
(symbol_table::symbol_table): Initialize it.
(symbol_table::find): New scope argument.
(symbol_table::alloc_package_scope): New method.
(symbol_table::fcn_info::find, symbol_table::fcn_info::find_function,
symbol_table::fcn_info::find_user_function,
symbol_table::fcn_info::fcn_info_rep::xfind,
symbol_table::fcn_info::fcn_info_rep::load_class_constructor,
symbol_table::fcn_info::fcn_info_rep::find,
symbol_table::fcn_info::fcn_info_rep::find_user_function): New
argument for package name.
(symbol_table::fcn_info::fcn_info_rep::package): New member.
(symbol_table::fcn_info::fcn_info_rep::find_package,
symbol_table::fcn_info::fcn_info_rep::clear_package): New methods.
(symbol_table::fcn_info::fcn_info_rep::clear): Clear package.

* libinterp/interpfcn/symtab.cc
(symbol_table::fcn_info::fcn_info_rep::load_class_constructor,
symbol_table::fcn_info::fcn_info_rep::find,
symbol_table::fcn_info::fcn_info_rep::xfind,
symbol_table::fcn_info::fcn_info_rep::find_user_function):
New argument for package name.
(symbol_table::fcn_info::fcn_info_rep::find_package): New method.
(symbol_table::find): New scope argument.
(symbol_table::do_find): Use package_name member.

* libinterp/octave-value/ov-classdef.h
(cdef_package::cdef_package_rep::scope): New member.
(cdef_package::cdef_package_rep::~cdef_package_rep): New destructor.
(cdef_package::cdef_package_rep::meta_subsref,
cdef_package::cdef_package_rep::meta_release,
cdef_package::cdef_package_rep::meta_is_postfix_index_handled,
cdef_package::cdef_package_rep::find,
cdef_package::cdef_package_rep::wrap): New methods.
(cdef_package::find): New method.
(cdef_manager::find_package, cdef_manager::do_find_package): New
argument "load_if_not_found".
(cdef_manager::find_package_symbol,
cdef_manager::do_find_package_symbol): New methods.

* libinterp/octave-value/ov-classdef.cc
(cdef_manager::do_find_package_symbol): New method.
(cdef_manager::do_find_package): New argument. Create package object if
it is not loaded yet and the package exists in load_path.
(cdef_manager::do_find_class): Handle class names with package.
(cdef_package::cdef_package_rep::meta_subsref,
cdef_package::cdef_package_rep::meta_release,
cdef_package::cdef_package_rep::find): New methods.
(cdef_class::make_meta_class): Handle package-scoped classes.
(make_package): Assign correct name to the package object.

* libinterp/parse-tree/pt-classdef.h (tree_classdef::pack_name): New
member.
(tree_classdef::tree_classdef): New argument. Initialize it.
(tree_classdef::package_name): New accessor.

* libinterp/parse-tree/parse.h (octave_base_parser::curr_package_name):
New member.
(octave_base_parser::octave_base_parser): Initialize it.
(load_fcn_from_file): New argument for package name.

* libinterp/parse-tree/oct-parse.in.yy (load_fcn_from_file): New
argument for package name. Change callers.
(parse_fcn_from_file): New argument for package name. Change callers.
(octave_base_parser::make_classdef): Use curr_package_name to create
the tree_classdef object.

* libinterp/octave-value/ov-fcn-handle.cc (octave_fcn_handle::set_fcn):
Adapt to new load_fcn_from_file signature.

* libinterp/interp-core/ls-mat5.cc (read_mat5_binary_element): Adapt
to new load_fcn_from_file signature.

diff --git a/libinterp/interp-core/ls-mat5.cc b/libinterp/interp-core/ls-mat5.cc
--- a/libinterp/interp-core/ls-mat5.cc
+++ b/libinterp/interp-core/ls-mat5.cc
@@ -901,17 +901,17 @@ read_mat5_binary_element (std::istream& 
                     if (fs.exists ())
                       {
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
-                          = load_fcn_from_file (str, dir_name, "", fname);
+                          = load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                       }
@@ -929,17 +929,17 @@ read_mat5_binary_element (std::istream& 
                         str = octave_env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
-                          = load_fcn_from_file (str, dir_name, "", fname);
+                          = load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                         else
@@ -953,17 +953,17 @@ read_mat5_binary_element (std::istream& 
                 else
                   {
                     size_t xpos
                       = fpath.find_last_of (file_ops::dir_sep_chars ());
 
                     std::string dir_name = fpath.substr (0, xpos);
 
                     octave_function *fcn
-                      = load_fcn_from_file (fpath, dir_name, "", fname);
+                      = load_fcn_from_file (fpath, dir_name, "", "", fname);
 
                     if (fcn)
                       {
                         octave_value tmp (fcn);
 
                         tc = octave_value (new octave_fcn_handle (tmp, fname));
                       }
                     else
diff --git a/libinterp/interpfcn/load-path.cc b/libinterp/interpfcn/load-path.cc
--- a/libinterp/interpfcn/load-path.cc
+++ b/libinterp/interpfcn/load-path.cc
@@ -114,16 +114,17 @@ load_path::dir_info::initialize (void)
 
   dir_time_last_checked = octave_time (static_cast<time_t> (0));
 
   file_stat fs (dir_name);
 
   if (fs)
     {
       method_file_map.clear ();
+      package_dir_map.clear ();
 
       dir_mtime = fs.mtime ();
       dir_time_last_checked = octave_time ();
 
       get_file_list (dir_name);
 
       try
         {
@@ -175,16 +176,18 @@ load_path::dir_info::get_file_list (cons
           if (fs)
             {
               if (fs.is_dir ())
                 {
                   if (fname == "private")
                     get_private_file_map (full_name);
                   else if (fname[0] == '@')
                     get_method_file_map (full_name, fname.substr (1));
+                  else if (fname[0] == '+')
+                    get_package_dir (full_name, fname.substr (1));
                 }
               else
                 {
                   all_files[all_files_count++] = fname;
 
                   size_t pos = fname.rfind ('.');
 
                   if (pos != std::string::npos)
@@ -280,16 +283,23 @@ load_path::dir_info::get_method_file_map
   std::string pd = file_ops::concat (d, "private");
 
   file_stat fs (pd);
 
   if (fs && fs.is_dir ())
     method_file_map[class_name].private_file_map = get_fcn_files (pd);
 }
 
+void
+load_path::dir_info::get_package_dir (const std::string& d,
+                                      const std::string& package_name)
+{
+  package_dir_map[package_name] = dir_info (d);
+}
+
 bool
 load_path::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
       instance = new load_path ();
@@ -368,18 +378,18 @@ load_path::do_contains_canonical (const 
           break;
         }
     }
 
   return retval;
 }
 
 void
-load_path::move_fcn_map (const std::string& dir_name,
-                         const string_vector& fcn_files, bool at_end)
+load_path::loader::move_fcn_map (const std::string& dir_name,
+                                 const string_vector& fcn_files, bool at_end)
 {
   octave_idx_type len = fcn_files.length ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
@@ -417,17 +427,17 @@ load_path::move_fcn_map (const std::stri
                   break;
                 }
             }
         }
     }
 }
 
 void
-load_path::move_method_map (const std::string& dir_name, bool at_end)
+load_path::loader::move_method_map (const std::string& dir_name, bool at_end)
 {
   for (method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
@@ -462,39 +472,79 @@ load_path::move_method_map (const std::s
                     }
                 }
             }
         }
     }
 }
 
 void
-load_path::move (dir_info_list_iterator i, bool at_end)
+load_path::do_move (dir_info_list_iterator i, bool at_end)
 {
   if (dir_info_list.size () > 1)
     {
       dir_info di = *i;
 
       dir_info_list.erase (i);
 
       if (at_end)
         dir_info_list.push_back (di);
       else
         dir_info_list.push_front (di);
 
-      std::string dir_name = di.dir_name;
-
-      move_fcn_map (dir_name, di.fcn_files, at_end);
-
-      // No need to move elements of private function map.
-
-      move_method_map (dir_name, at_end);
+      move (di, at_end);
+    }
+}
+
+void
+load_path::move (const dir_info& di, bool at_end, const std::string& pname)
+{
+  loader& l = get_loader (pname);
+
+  l.move (di, at_end);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
+       p != package_dir_map.end (); ++p)
+    {
+      std::string full_name = p->first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      move (p->second, at_end, full_name);
     }
 }
 
+void
+load_path::loader::move (const dir_info& di, bool at_end)
+{
+  std::string dir_name = di.dir_name;
+
+  std::list<std::string>::iterator s = 
+    std::find (dir_list.begin (), dir_list.end (), dir_name);
+
+  if (s != dir_list.end ())
+    {
+      dir_list.erase (s);
+
+      if (at_end)
+        dir_list.push_back (dir_name);
+      else
+        dir_list.push_front (dir_name);
+    }
+
+  move_fcn_map (dir_name, di.fcn_files, at_end);
+
+  // No need to move elements of private function map.
+
+  move_method_map (dir_name, at_end);
+}
+
 static void
 maybe_add_path_elts (std::string& path, const std::string& dir)
 {
   std::string tpath = genpath (dir);
 
   if (! tpath.empty ())
     {
       if (path.empty ())
@@ -540,19 +590,20 @@ load_path::do_initialize (bool set_initi
 
   do_set (xpath, false, true);
 }
 
 void
 load_path::do_clear (void)
 {
   dir_info_list.clear ();
-  fcn_map.clear ();
-  private_fcn_map.clear ();
-  method_map.clear ();
+
+  default_loader.clear ();
+
+  loader_map.clear ();
 }
 
 static std::list<std::string>
 split_path (const std::string& p)
 {
   std::list<std::string> retval;
 
   size_t beg = 0;
@@ -679,17 +730,17 @@ load_path::do_add (const std::string& di
 
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   dir = strip_trailing_separators (dir);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
-    move (i, at_end);
+    do_move (i, at_end);
   else
     {
       file_stat fs (dir);
 
       if (fs)
         {
           if (fs.is_dir ())
             {
@@ -697,21 +748,17 @@ load_path::do_add (const std::string& di
 
               if (! error_state)
                 {
                   if (at_end)
                     dir_info_list.push_back (di);
                   else
                     dir_info_list.push_front (di);
 
-                  add_to_fcn_map (di, at_end);
-
-                  add_to_private_fcn_map (di);
-
-                  add_to_method_map (di, at_end);
+                  add (di, at_end);
 
                   if (add_hook)
                     add_hook (dir);
                 }
             }
           else if (warn)
             warning ("addpath: %s: not a directory", dir_arg.c_str ());
         }
@@ -722,22 +769,22 @@ load_path::do_add (const std::string& di
         }
     }
 
   // FIXME -- is there a better way to do this?
 
   i = find_dir_info (".");
 
   if (i != dir_info_list.end ())
-    move (i, false);
+    do_move (i, false);
 }
 
 void
-load_path::remove_fcn_map (const std::string& dir,
-                           const string_vector& fcn_files)
+load_path::loader::remove_fcn_map (const std::string& dir,
+                                   const string_vector& fcn_files)
 {
   octave_idx_type len = fcn_files.length ();
 
   for (octave_idx_type k = 0; k < len; k++)
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
@@ -766,26 +813,26 @@ load_path::remove_fcn_map (const std::st
 
               break;
             }
         }
     }
 }
 
 void
-load_path::remove_private_fcn_map (const std::string& dir)
+load_path::loader::remove_private_fcn_map (const std::string& dir)
 {
   private_fcn_map_iterator p = private_fcn_map.find (dir);
 
   if (p != private_fcn_map.end ())
     private_fcn_map.erase (p);
 }
 
 void
-load_path::remove_method_map (const std::string& dir)
+load_path::loader::remove_method_map (const std::string& dir)
 {
   for (method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
@@ -844,58 +891,85 @@ load_path::do_remove (const std::string&
 
           if (i != dir_info_list.end ())
             {
               retval = true;
 
               if (remove_hook)
                 remove_hook (dir);
 
-              string_vector fcn_files = i->fcn_files;
+              dir_info& di = *i;
 
               dir_info_list.erase (i);
 
-              remove_fcn_map (dir, fcn_files);
-
-              remove_private_fcn_map (dir);
-
-              remove_method_map (dir);
+              remove (di);
             }
         }
     }
 
   return retval;
 }
 
 void
+load_path::remove (const dir_info& di, const std::string& pname)
+{
+  loader& l = get_loader (pname);
+
+  l.remove (di);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
+       p != package_dir_map.end (); ++p)
+    {
+      std::string full_name = p->first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      remove (p->second, full_name);
+    }
+}
+
+void
+load_path::loader::remove (const dir_info& di)
+{
+  std::string dir = di.dir_name;
+
+  string_vector fcn_files = di.fcn_files;
+
+  dir_list.remove (dir);
+
+  remove_fcn_map (dir, fcn_files);
+
+  remove_private_fcn_map (dir);
+
+  remove_method_map (dir);
+}
+
+void
 load_path::do_update (void) const
 {
   // I don't see a better way to do this because we need to
   // preserve the correct directory ordering for new files that
   // have appeared.
 
-  fcn_map.clear ();
-
-  private_fcn_map.clear ();
-
-  method_map.clear ();
+  default_loader.clear ();
+
+  loader_map.clear ();
 
   for (dir_info_list_iterator p = dir_info_list.begin ();
        p != dir_info_list.end ();
        p++)
     {
       dir_info& di = *p;
 
       di.update ();
 
-      add_to_fcn_map (di, true);
-
-      add_to_private_fcn_map (di);
-
-      add_to_method_map (di, true);
+      add (di, true);
     }
 }
 
 bool
 load_path::check_file_type (std::string& fname, int type, int possible_types,
                             const std::string& fcn, const char *who)
 {
   bool retval = false;
@@ -984,33 +1058,33 @@ load_path::check_file_type (std::string&
     }
   else
     error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
 
   return retval;
 }
 
 std::string
-load_path::do_find_fcn (const std::string& fcn, std::string& dir_name,
-                        int type) const
+load_path::loader::find_fcn (const std::string& fcn, std::string& dir_name,
+                             int type) const
 {
   std::string retval;
 
   //  update ();
 
   if (fcn.length () > 0 && fcn[0] == '@')
     {
       size_t pos = fcn.find ('/');
 
       if (pos != std::string::npos)
         {
           std::string class_name = fcn.substr (1, pos-1);
           std::string meth = fcn.substr (pos+1);
 
-          retval = do_find_method (class_name, meth, dir_name);
+          retval = find_method (class_name, meth, dir_name);
         }
       else
         retval = std::string ();
     }
   else
     {
       dir_name = std::string ();
 
@@ -1039,18 +1113,18 @@ load_path::do_find_fcn (const std::strin
             }
         }
     }
 
   return retval;
 }
 
 std::string
-load_path::do_find_private_fcn (const std::string& dir,
-                                const std::string& fcn, int type) const
+load_path::loader::find_private_fcn (const std::string& dir,
+                                     const std::string& fcn, int type) const
 {
   std::string retval;
 
   //  update ();
 
   const_private_fcn_map_iterator q = private_fcn_map.find (dir);
 
   if (q != private_fcn_map.end ())
@@ -1071,17 +1145,36 @@ load_path::do_find_private_fcn (const st
     }
 
   return retval;
 }
 
 std::string
 load_path::do_find_method (const std::string& class_name,
                            const std::string& meth,
-                           std::string& dir_name, int type) const
+                           std::string& dir_name) const
+{
+  size_t pos = class_name.rfind ('.');
+
+  if (pos == std::string::npos)
+    return default_loader.find_method (class_name, meth, dir_name);
+  else
+    {
+      std::string pname = class_name.substr (0, pos);
+
+      std::string cname = class_name.substr (pos+1);
+
+      return get_loader(pname).find_method (cname, meth, dir_name);
+    }
+}
+
+std::string
+load_path::loader::find_method (const std::string& class_name,
+                                const std::string& meth,
+                                std::string& dir_name, int type) const
 {
   std::string retval;
 
   //  update ();
 
   dir_name = std::string ();
 
   const_method_map_iterator q = method_map.find (class_name);
@@ -1119,16 +1212,33 @@ load_path::do_find_method (const std::st
     }
 
   return retval;
 }
 
 std::list<std::string>
 load_path::do_methods (const std::string& class_name) const
 {
+  size_t pos = class_name.rfind ('.');
+
+  if (pos == std::string::npos)
+    return default_loader.methods (class_name);
+  else
+    {
+      std::string pname = class_name.substr (0, pos);
+
+      std::string cname = class_name.substr (pos+1);
+
+      return get_loader (pname).methods (cname);
+    }
+}
+
+std::list<std::string>
+load_path::loader::methods (const std::string& class_name) const
+{
   std::list<std::string> retval;
 
   //  update ();
 
   const_method_map_iterator q = method_map.find (class_name);
 
   if (q != method_map.end ())
     {
@@ -1146,26 +1256,44 @@ load_path::do_methods (const std::string
 
 std::list<std::string>
 load_path::do_overloads (const std::string& meth) const
 {
   std::list<std::string> retval;
 
   //  update ();
 
+  default_loader.overloads (meth, retval);
+
+  for (const_loader_map_iterator l = loader_map.begin ();
+       l != loader_map.end (); ++l)
+    l->second.overloads (meth, retval);
+
+  return retval;
+}
+
+void
+load_path::loader::overloads (const std::string& meth,
+                              std::list<std::string>& l) const
+{
   for (const_method_map_iterator q = method_map.begin ();
        q != method_map.end (); q++)
     {
       const fcn_map_type& m = q->second;
 
       if (m.find (meth) != m.end ())
-        retval.push_back (q->first);
+        {
+          std::string class_name = q->first;
+
+          if (! prefix.empty ())
+            class_name = prefix + "." + class_name;
+
+          l.push_back (class_name);
+        }
     }
-
-  return retval;
 }
 
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
   if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
@@ -1513,16 +1641,22 @@ load_path::do_files (const std::string& 
     }
 
   return retval;
 }
 
 string_vector
 load_path::do_fcn_names (void) const
 {
+  return default_loader.fcn_names ();
+}
+
+string_vector
+load_path::loader::fcn_names (void) const
+{
   size_t len = fcn_map.size ();
 
   string_vector retval (len);
 
   octave_idx_type count = 0;
 
   for (const_fcn_map_iterator p = fcn_map.begin ();
        p != fcn_map.end ();
@@ -1656,79 +1790,21 @@ load_path::do_display (std::ostream& os)
 
               string_vector method_files = get_file_list (ci.method_file_map);
 
               method_files.list_in_columns (os);
             }
         }
     }
 
-  for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
-       i != private_fcn_map.end (); i++)
-    {
-      os << "\n*** private functions in "
-         << file_ops::concat (i->first, "private") << ":\n\n";
-
-      print_fcn_list (os, i->second);
-    }
-
-#if defined (DEBUG_LOAD_PATH)
-
-  for (const_fcn_map_iterator i = fcn_map.begin ();
-       i != fcn_map.end ();
-       i++)
-    {
-      os << i->first << ":\n";
-
-      const file_info_list_type& file_info_list = i->second;
-
-      for (const_file_info_list_iterator p = file_info_list.begin ();
-           p != file_info_list.end ();
-           p++)
-        {
-          os << "  " << p->dir_name << " (";
-
-          print_types (os, p->types);
-
-          os << ")\n";
-        }
-    }
-
-  for (const_method_map_iterator i = method_map.begin ();
-       i != method_map.end ();
-       i++)
-    {
-      os << "CLASS " << i->first << ":\n";
-
-      const fcn_map_type& fm = i->second;
-
-      for (const_fcn_map_iterator q = fm.begin ();
-           q != fm.end ();
-           q++)
-        {
-          os << "  " << q->first << ":\n";
-
-          const file_info_list_type& file_info_list = q->second;
-
-          for (const_file_info_list_iterator p = file_info_list.begin ();
-               p != file_info_list.end ();
-               p++)
-            {
-              os << "  " << p->dir_name << " (";
-
-              print_types (os, p->types);
-
-              os << ")\n";
-            }
-        }
-    }
-
-  os << "\n";
-
-#endif
+  default_loader.display (os);
+
+  for (const_loader_map_iterator l = loader_map.begin ();
+       l != loader_map.end (); ++l)
+    l->second.display (os);
 }
 
 // True if a path is contained in a path list separated by path_sep_char
 static bool
 in_path_list (const std::string& path_list, const std::string& path)
 {
   size_t ps = path.size (), pls = path_list.size (), pos = path_list.find (path);
   char psc = dir_path::path_sep_char ();
@@ -1740,17 +1816,39 @@ in_path_list (const std::string& path_li
       else
         pos = path_list.find (path, pos + 1);
     }
 
   return false;
 }
 
 void
-load_path::add_to_fcn_map (const dir_info& di, bool at_end) const
+load_path::add (const dir_info& di, bool at_end,
+                const std::string& pname) const
+{
+  loader& l = get_loader (pname);
+
+  l.add (di, at_end);
+
+  dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
+
+  for (dir_info::const_package_dir_map_iterator p = package_dir_map.begin ();
+       p != package_dir_map.end (); ++p)
+    {
+      std::string full_name = p->first;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      add (p->second, at_end, full_name);
+    }
+}
+
+void
+load_path::loader::add_to_fcn_map (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
   string_vector fcn_files = di.fcn_files;
 
   octave_idx_type len = fcn_files.length ();
 
   for (octave_idx_type i = 0; i < len; i++)
@@ -1836,26 +1934,26 @@ load_path::add_to_fcn_map (const dir_inf
           file_info& fi = *p;
 
           fi.types |= t;
         }
     }
 }
 
 void
-load_path::add_to_private_fcn_map (const dir_info& di) const
+load_path::loader::add_to_private_fcn_map (const dir_info& di)
 {
   dir_info::fcn_file_map_type private_file_map = di.private_file_map;
 
   if (! private_file_map.empty ())
     private_fcn_map[di.dir_name] = private_file_map;
 }
 
 void
-load_path::add_to_method_map (const dir_info& di, bool at_end) const
+load_path::loader::add_to_method_map (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
   // <CLASS_NAME, CLASS_INFO>
   dir_info::method_file_map_type method_file_map = di.method_file_map;
 
   for (dir_info::const_method_file_map_iterator q = method_file_map.begin ();
        q != method_file_map.end ();
@@ -1915,16 +2013,91 @@ load_path::add_to_method_map (const dir_
       // <FCN_NAME, TYPES>
       dir_info::fcn_file_map_type private_file_map = ci.private_file_map;
 
       if (! private_file_map.empty ())
         private_fcn_map[full_dir_name] = private_file_map;
     }
 }
 
+void
+load_path::loader::display (std::ostream& os) const
+{
+  os << "*** loader: " << (prefix.empty () ? "<top-level>" : prefix) << "\n\n";
+
+  for (std::list<std::string>::const_iterator s = dir_list.begin ();
+       s != dir_list.end (); ++s)
+    os << *s << "\n";
+  os << "\n";
+
+  for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
+       i != private_fcn_map.end (); i++)
+    {
+      os << "\n*** private functions in "
+         << file_ops::concat (i->first, "private") << ":\n\n";
+
+      print_fcn_list (os, i->second);
+    }
+
+#if defined (DEBUG_LOAD_PATH)
+
+  for (const_fcn_map_iterator i = fcn_map.begin ();
+       i != fcn_map.end ();
+       i++)
+    {
+      os << i->first << ":\n";
+
+      const file_info_list_type& file_info_list = i->second;
+
+      for (const_file_info_list_iterator p = file_info_list.begin ();
+           p != file_info_list.end ();
+           p++)
+        {
+          os << "  " << p->dir_name << " (";
+
+          print_types (os, p->types);
+
+          os << ")\n";
+        }
+    }
+
+  for (const_method_map_iterator i = method_map.begin ();
+       i != method_map.end ();
+       i++)
+    {
+      os << "CLASS " << i->first << ":\n";
+
+      const fcn_map_type& fm = i->second;
+
+      for (const_fcn_map_iterator q = fm.begin ();
+           q != fm.end ();
+           q++)
+        {
+          os << "  " << q->first << ":\n";
+
+          const file_info_list_type& file_info_list = q->second;
+
+          for (const_file_info_list_iterator p = file_info_list.begin ();
+               p != file_info_list.end ();
+               p++)
+            {
+              os << "  " << p->dir_name << " (";
+
+              print_types (os, p->types);
+
+              os << ")\n";
+            }
+        }
+    }
+
+  os << "\n";
+
+#endif
+}
+
 std::string
 genpath (const std::string& dirname, const string_vector& skip)
 {
   std::string retval;
 
   dir_entry dir (dirname);
 
   if (dir)
@@ -2335,8 +2508,15 @@ rmpath (\"dir1:/dir2:~/dir3\")\n\
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
   return retval;
 }
+
+DEFUN (__dump_load_path__, , , "")
+{
+  load_path::display (octave_stdout);
+
+  return octave_value_list ();
+}
diff --git a/libinterp/interpfcn/load-path.h b/libinterp/interpfcn/load-path.h
--- a/libinterp/interpfcn/load-path.h
+++ b/libinterp/interpfcn/load-path.h
@@ -34,18 +34,17 @@ along with Octave; see the file COPYING.
 
 class
 OCTINTERP_API
 load_path
 {
 protected:
 
   load_path (void)
-    : dir_info_list (), fcn_map (), private_fcn_map (), method_map (),
-      init_dirs () { }
+    : loader_map (), default_loader (), dir_info_list (), init_dirs () { }
 
 public:
 
   typedef void (*hook_fcn_ptr) (const std::string& dir);
 
   ~load_path (void) { }
 
   static void initialize (bool set_initial_path = false)
@@ -94,17 +93,18 @@ public:
     return instance_ok () ? instance->do_contains_canonical (dir_name) : false;
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth,
                                   std::string& dir_name)
   {
     return instance_ok ()
-      ? instance->do_find_method (class_name, meth, dir_name) : std::string ();
+      ? instance->do_find_method (class_name, meth, dir_name)
+      : std::string ();
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth)
   {
     std::string dir_name;
     return find_method (class_name, meth, dir_name);
   }
@@ -116,57 +116,74 @@ public:
   }
 
   static std::list<std::string> overloads (const std::string& meth)
   {
     return instance_ok ()
       ? instance->do_overloads (meth) : std::list<std::string> ();
   }
 
-  static std::string find_fcn (const std::string& fcn, std::string& dir_name)
+  static bool find_package (const std::string& package_name)
+  {
+    return instance_ok ()
+      ? instance->do_find_package (package_name) : false;
+  }
+
+  static std::string find_fcn (const std::string& fcn, std::string& dir_name,
+                               const std::string& pack_name = std::string ())
   {
     return instance_ok ()
-      ? instance->do_find_fcn (fcn, dir_name) : std::string ();
+      ? instance->get_loader (pack_name).find_fcn (fcn, dir_name)
+      : std::string ();
   }
 
-  static std::string find_fcn (const std::string& fcn)
+  static std::string find_fcn (const std::string& fcn,
+                               const std::string& pack_name = std::string ())
   {
     std::string dir_name;
-    return find_fcn (fcn, dir_name);
+    return find_fcn (fcn, dir_name, pack_name);
   }
 
   static std::string find_private_fcn (const std::string& dir,
-                                       const std::string& fcn)
+                                       const std::string& fcn,
+                                       const std::string& pack_name = std::string ())
   {
     return instance_ok ()
-      ? instance->do_find_private_fcn (dir, fcn) : std::string ();
+      ? instance->get_loader (pack_name).find_private_fcn (dir, fcn)
+      : std::string ();
   }
 
-  static std::string find_fcn_file (const std::string& fcn)
+  static std::string find_fcn_file (const std::string& fcn,
+                                    const std::string& pack_name = std::string ())
   {
     std::string dir_name;
 
-    return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, M_FILE) : std::string ();
+    return instance_ok ()
+      ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
+      : std::string ();
   }
 
-  static std::string find_oct_file (const std::string& fcn)
+  static std::string find_oct_file (const std::string& fcn,
+                                    const std::string& pack_name = std::string ())
   {
     std::string dir_name;
 
-    return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, OCT_FILE) : std::string ();
+    return instance_ok ()
+      ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
+      : std::string ();
   }
 
-  static std::string find_mex_file (const std::string& fcn)
+  static std::string find_mex_file (const std::string& fcn,
+                                    const std::string& pack_name = std::string ())
   {
     std::string dir_name;
 
-    return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, MEX_FILE) : std::string ();
+    return instance_ok ()
+      ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
+      : std::string ();
   }
 
   static std::string find_file (const std::string& file)
   {
     return instance_ok ()
       ? instance->do_find_file (file) : std::string ();
   }
 
@@ -290,85 +307,99 @@ private:
     };
 
     // <CLASS_NAME, CLASS_INFO>
     typedef std::map<std::string, class_info> method_file_map_type;
 
     typedef method_file_map_type::const_iterator const_method_file_map_iterator;
     typedef method_file_map_type::iterator method_file_map_iterator;
 
+    // <PACKAGE_NAME, DIR_INFO>
+    typedef std::map<std::string, dir_info> package_dir_map_type;
+
+    typedef package_dir_map_type::const_iterator const_package_dir_map_iterator;
+    typedef package_dir_map_type::iterator package_dir_map_iterator;
+
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
         dir_mtime (), dir_time_last_checked (),
-        all_files (), fcn_files (), private_file_map (), method_file_map ()
+        all_files (), fcn_files (), private_file_map (), method_file_map (),
+        package_dir_map ()
       { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
         dir_mtime (), dir_time_last_checked (),
-        all_files (), fcn_files (), private_file_map (), method_file_map ()
+        all_files (), fcn_files (), private_file_map (), method_file_map (),
+        package_dir_map ()
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
         dir_mtime (di.dir_mtime),
         dir_time_last_checked (di.dir_time_last_checked),
         all_files (di.all_files), fcn_files (di.fcn_files),
         private_file_map (di.private_file_map),
-        method_file_map (di.method_file_map) { }
+        method_file_map (di.method_file_map),
+        package_dir_map (di.package_dir_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
       if (&di != this)
         {
           dir_name = di.dir_name;
           abs_dir_name = di.abs_dir_name;
           is_relative = di.is_relative;
           dir_mtime = di.dir_mtime;
           dir_time_last_checked = di.dir_time_last_checked;
           all_files = di.all_files;
           fcn_files = di.fcn_files;
           private_file_map = di.private_file_map;
           method_file_map = di.method_file_map;
+          package_dir_map = di.package_dir_map;
         }
 
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
     bool is_relative;
     octave_time dir_mtime;
     octave_time dir_time_last_checked;
     string_vector all_files;
     string_vector fcn_files;
     fcn_file_map_type private_file_map;
     method_file_map_type method_file_map;
+    package_dir_map_type package_dir_map;
 
   private:
 
     void initialize (void);
 
     void get_file_list (const std::string& d);
 
     void get_private_file_map (const std::string& d);
 
     void get_method_file_map (const std::string& d,
                               const std::string& class_name);
 
+    void get_package_dir (const std::string& d,
+                          const std::string& package_name);
+
     friend fcn_file_map_type get_fcn_files (const std::string& d);
   };
 
   class file_info
   {
   public:
 
     file_info (const std::string& d, int t) : dir_name (d), types (t) { }
@@ -434,23 +465,135 @@ private:
   typedef private_fcn_map_type::iterator private_fcn_map_iterator;
 
   // <CLASS_NAME, <FCN_NAME, FILE_INFO_LIST>>
   typedef std::map<std::string, fcn_map_type> method_map_type;
 
   typedef method_map_type::const_iterator const_method_map_iterator;
   typedef method_map_type::iterator method_map_iterator;
 
-  mutable dir_info_list_type dir_info_list;
+  class loader
+  {
+  public:
+    loader (const std::string& pfx = std::string ())
+      : prefix (pfx), dir_list (), fcn_map (), private_fcn_map (),
+        method_map () { }
+
+    loader (const loader& l)
+      : prefix (l.prefix), dir_list (l.dir_list),
+        private_fcn_map (l.private_fcn_map), method_map (l.method_map) { }
+
+    ~loader (void) { }
+
+    loader& operator = (const loader& l)
+    {
+      if (&l != this)
+        {
+          prefix = l.prefix;
+          dir_list = l.dir_list;
+          fcn_map = l.fcn_map;
+          private_fcn_map = l.private_fcn_map;
+          method_map = l.method_map;
+        }
+
+      return *this;
+    }
 
-  mutable fcn_map_type fcn_map;
+    void add (const dir_info& di, bool at_end)
+    {
+      if (at_end)
+        dir_list.push_back (di.dir_name);
+      else
+        dir_list.push_front (di.dir_name);
+
+      add_to_fcn_map (di, at_end);
+
+      add_to_private_fcn_map (di);
+
+      add_to_method_map (di, at_end);
+    }
+
+    void move (const dir_info& di, bool at_end);
+
+    void remove (const dir_info& di);
+
+    void clear (void)
+      {
+        dir_list.clear ();
+
+        fcn_map.clear ();
+
+        private_fcn_map.clear ();
+
+        method_map.clear ();
+      }
+
+    void display (std::ostream& out) const;
 
-  mutable private_fcn_map_type private_fcn_map;
+    std::string find_fcn (const std::string& fcn,
+                          std::string& dir_name,
+                          int type = M_FILE | OCT_FILE | MEX_FILE) const;
+
+    std::string find_private_fcn (const std::string& dir,
+                                  const std::string& fcn,
+                                  int type = M_FILE | OCT_FILE | MEX_FILE) const;
+
+    std::string find_method (const std::string& class_name,
+                             const std::string& meth,
+                             std::string& dir_name,
+                             int type = M_FILE | OCT_FILE | MEX_FILE) const;
+
+    std::list<std::string> methods (const std::string& class_name) const;
+
+    void overloads (const std::string& meth, std::list<std::string>& l) const;
+
+    string_vector fcn_names (void) const;
+
+  private:
+    void add_to_fcn_map (const dir_info& di, bool at_end);
+
+    void add_to_private_fcn_map (const dir_info& di);
+
+    void add_to_method_map (const dir_info& di, bool at_end);
+
+    void move_fcn_map (const std::string& dir,
+                       const string_vector& fcn_files, bool at_end);
+
+    void move_method_map (const std::string& dir, bool at_end);
 
-  mutable method_map_type method_map;
+    void remove_fcn_map (const std::string& dir,
+                         const string_vector& fcn_files);
+
+    void remove_private_fcn_map (const std::string& dir);
+
+    void remove_method_map (const std::string& dir);
+
+  private:
+    std::string prefix;
+
+    std::list<std::string> dir_list;
+
+    fcn_map_type fcn_map;
+
+    private_fcn_map_type private_fcn_map;
+
+    method_map_type method_map;
+  };
+
+  // <PACKAGE_NAME, LOADER>
+  typedef std::map<std::string, loader> loader_map_type;
+
+  typedef loader_map_type::const_iterator const_loader_map_iterator;
+  typedef loader_map_type::iterator loader_map_iterator;
+
+  mutable loader_map_type loader_map;
+
+  mutable loader default_loader;
+
+  mutable dir_info_list_type dir_info_list;
 
   mutable std::set<std::string> init_dirs;
 
   static load_path *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static hook_fcn_ptr add_hook;
@@ -467,66 +610,73 @@ private:
 
   const_dir_info_list_iterator find_dir_info (const std::string& dir) const;
   dir_info_list_iterator find_dir_info (const std::string& dir);
 
   bool contains (const std::string& dir) const;
 
   bool do_contains_canonical (const std::string& dir) const;
 
-  void move_fcn_map (const std::string& dir,
-                     const string_vector& fcn_files, bool at_end);
+  void do_move (dir_info_list_iterator i, bool at_end);
 
-  void move_method_map (const std::string& dir, bool at_end);
+  void move (const dir_info& di, bool at_end,
+             const std::string& pname = std::string ());
 
-  void move (std::list<dir_info>::iterator i, bool at_end);
+  void remove (const dir_info& di,
+               const std::string& pname = std::string ());
 
   void do_initialize (bool set_initial_path);
 
   void do_clear (void);
 
   void do_set (const std::string& p, bool warn, bool is_init = false);
 
   void do_append (const std::string& dir, bool warn);
 
   void do_prepend (const std::string& dir, bool warn);
 
   void do_add (const std::string& dir, bool at_end, bool warn);
 
-  void remove_fcn_map (const std::string& dir, const string_vector& fcn_files);
-
-  void remove_private_fcn_map (const std::string& dir);
-
-  void remove_method_map (const std::string& dir);
-
   bool do_remove (const std::string& dir);
 
   void do_update (void) const;
 
   static bool
   check_file_type (std::string& fname, int type, int possible_types,
                    const std::string& fcn, const char *who);
 
-  std::string do_find_fcn (const std::string& fcn,
-                           std::string& dir_name,
-                           int type = M_FILE | OCT_FILE | MEX_FILE) const;
+  loader& get_loader (const std::string& name) const
+  {
+    if (! name.empty ())
+      {
+        loader_map_iterator l = loader_map.find (name);
 
-  std::string do_find_private_fcn (const std::string& dir,
-                                   const std::string& fcn,
-                                   int type = M_FILE | OCT_FILE | MEX_FILE) const;
+        if (l == loader_map.end ())
+          l = loader_map.insert (loader_map.end (),
+                                 loader_map_type::value_type (name, loader (name)));
+
+        return l->second;
+      }
+
+    return default_loader;
+  }
 
   std::string do_find_method (const std::string& class_name,
                               const std::string& meth,
-                              std::string& dir_name,
-                              int type = M_FILE | OCT_FILE | MEX_FILE) const;
+                              std::string& dir_name) const;
 
   std::list<std::string> do_methods (const std::string& class_name) const;
 
   std::list<std::string> do_overloads (const std::string& meth) const;
 
+  bool do_find_package (const std::string& package_name) const
+  {
+    return (loader_map.find (package_name) != loader_map.end ());
+  }
+
   std::string do_find_file (const std::string& file) const;
 
   std::string do_find_dir (const std::string& dir) const;
 
   string_vector do_find_matching_dirs (const std::string& dir) const;
 
   std::string do_find_first_of (const string_vector& files) const;
 
@@ -550,21 +700,18 @@ private:
   print_fcn_list (std::ostream& os, const dir_info::fcn_file_map_type& lst);
 
   void do_display (std::ostream& os) const;
 
   std::string do_system_path (void) const { return sys_path; }
 
   std::string do_get_command_line_path (void) const { return command_line_path; }
 
-  void add_to_fcn_map (const dir_info& di, bool at_end) const;
-
-  void add_to_private_fcn_map (const dir_info& di) const;
-
-  void add_to_method_map (const dir_info& di, bool at_end) const;
+  void add (const dir_info& di, bool at_end,
+            const std::string& pname = std::string ()) const;
 
   friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
 };
 
 extern std::string
 genpath (const std::string& dir, const string_vector& skip = "private");
 
 extern void execute_pkg_add (const std::string& dir);
diff --git a/libinterp/interpfcn/symtab.cc b/libinterp/interpfcn/symtab.cc
--- a/libinterp/interpfcn/symtab.cc
+++ b/libinterp/interpfcn/symtab.cc
@@ -369,27 +369,34 @@ symbol_table::fcn_info::fcn_info_rep::lo
           private_functions[dir_name] = retval;
         }
     }
 
   return retval;
 }
 
 octave_value
-symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
+symbol_table::fcn_info::fcn_info_rep::load_class_constructor
+  (const std::string& pname)
 {
   octave_value retval;
 
   std::string dir_name;
 
-  std::string file_name = load_path::find_method (name, name, dir_name);
+  std::string full_name = name;
+
+  if (! pname.empty ())
+    full_name = pname + "." + full_name;
+
+  std::string file_name = load_path::find_method (full_name, name, dir_name);
 
   if (! file_name.empty ())
     {
-      octave_function *fcn = load_fcn_from_file (file_name, dir_name, name);
+      octave_function *fcn = load_fcn_from_file (file_name, dir_name, name,
+                                                 pname);
 
       if (fcn)
         {
           retval = octave_value (fcn);
 
           class_constructors[name] = retval;
         }
     }
@@ -397,17 +404,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
     {
       // Classdef constructors can be defined anywhere in the path, not
       // necessarily in @-folders. Look for a normal function and load it.
       // If the loaded function is a classdef constructor, store it as such
       // and restore function_on_path to its previous value.
 
       octave_value old_function_on_path = function_on_path;
 
-      octave_value maybe_cdef_ctor = find_user_function ();
+      octave_value maybe_cdef_ctor = find_user_function (pname);
 
       if (maybe_cdef_ctor.is_defined ())
         {
           octave_function *fcn = maybe_cdef_ctor.function_value (true);
 
           if (fcn && fcn->is_classdef_constructor ())
             {
               retval = maybe_cdef_ctor;
@@ -424,17 +431,27 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::load_class_method
   (const std::string& dispatch_type)
 {
   octave_value retval;
 
   if (name == dispatch_type)
-    retval = load_class_constructor ();
+    retval = load_class_constructor (std::string ());
+  else if (dispatch_type.length () > name.length ()
+           && dispatch_type.substr (dispatch_type.length () - name.length ()
+                                    - 1) == ("." + name))
+    {
+      std::string pname =
+        dispatch_type.substr (0,
+                              dispatch_type.length () - name.length () - 1);
+
+      retval = load_class_constructor (pname);
+    }
   else
     {
       octave_function *cm = cdef_manager::find_method_symbol (name,
                                                               dispatch_type);
 
       if (cm)
         retval = octave_value (cm);
 
@@ -642,37 +659,39 @@ get_dispatch_type (const octave_value_li
 //   function on the path
 //   built-in function
 //
 // Matlab documentation states that constructors have higher precedence
 // than methods, but that does not seem to be the case.
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find (const octave_value_list& args,
-                                            bool local_funcs)
+                                            bool local_funcs,
+                                            const std::string& pname)
 {
-  octave_value retval = xfind (args, local_funcs);
+  octave_value retval = xfind (args, local_funcs, pname);
 
   if (! (error_state || retval.is_defined ()))
     {
       // It is possible that the user created a file on the fly since
       // the last prompt or chdir, so try updating the load path and
       // searching again.
 
       load_path::update ();
 
-      retval = xfind (args, local_funcs);
+      retval = xfind (args, local_funcs, pname);
     }
 
   return retval;
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
-                                             bool local_funcs)
+                                             bool local_funcs,
+                                             const std::string& pname)
 {
   if (local_funcs)
     {
       // Subfunction.  I think it only makes sense to check for
       // subfunctions if we are currently executing a function defined
       // from a .m file.
 
       octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
@@ -745,33 +764,33 @@ symbol_table::fcn_info::fcn_info_rep::xf
     }
 
   // Class constructors.  The class name and function name are the same.
 
   str_val_iterator q = class_constructors.find (name);
 
   if (q == class_constructors.end ())
     {
-      octave_value val = load_class_constructor ();
+      octave_value val = load_class_constructor (pname);
 
       if (val.is_defined ())
         return val;
     }
   else
     {
       octave_value& fval = q->second;
 
       if (fval.is_defined ())
         out_of_date_check (fval, name);
 
       if (fval.is_defined ())
         return fval;
       else
         {
-          octave_value val = load_class_constructor ();
+          octave_value val = load_class_constructor (pname);
 
           if (val.is_defined ())
             return val;
         }
     }
 
   // Legacy dispatch.
 
@@ -807,17 +826,24 @@ symbol_table::fcn_info::fcn_info_rep::xf
 
   octave_value fcn = find_autoload ();
 
   if (fcn.is_defined ())
     return fcn;
 
   // Function on the path.
 
-  fcn = find_user_function ();
+  fcn = find_user_function (pname);
+
+  if (fcn.is_defined ())
+    return fcn;
+
+  // Package
+
+  fcn = find_package (pname);
 
   if (fcn.is_defined ())
     return fcn;
 
   // Built-in function (might be undefined).
 
   return built_in_function;
 }
@@ -864,17 +890,17 @@ octave_value
 symbol_table::fcn_info::fcn_info_rep::x_builtin_find (void)
 {
   // Built-in function.
   if (built_in_function.is_defined ())
     return built_in_function;
 
   // Function on the path.
 
-  octave_value fcn = find_user_function ();
+  octave_value fcn = find_user_function (std::string ());
 
   if (fcn.is_defined ())
     return fcn;
 
   // Autoload?
 
   fcn = find_autoload ();
 
@@ -999,53 +1025,77 @@ symbol_table::fcn_info::fcn_info_rep::fi
       std::string file_name = lookup_autoload (name);
 
       if (! file_name.empty ())
         {
           size_t pos = file_name.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = file_name.substr (0, pos);
 
-          octave_function *fcn = load_fcn_from_file (file_name, dir_name,
+          octave_function *fcn = load_fcn_from_file (file_name, dir_name, "",
                                                      "", name, true);
 
           if (fcn)
             autoload_function = octave_value (fcn);
         }
     }
 
   return autoload_function;
 }
 
 octave_value
-symbol_table::fcn_info::fcn_info_rep::find_user_function (void)
+symbol_table::fcn_info::fcn_info_rep::find_user_function (const std::string& pname)
 {
   // Function on the path.
 
   if (function_on_path.is_defined ())
     out_of_date_check (function_on_path);
 
   if (! (error_state || function_on_path.is_defined ()))
     {
       std::string dir_name;
 
-      std::string file_name = load_path::find_fcn (name, dir_name);
+      std::string file_name = load_path::find_fcn (name, dir_name, pname);
 
       if (! file_name.empty ())
         {
-          octave_function *fcn = load_fcn_from_file (file_name, dir_name);
+          octave_function *fcn = load_fcn_from_file (file_name, dir_name, "",
+                                                     pname);
 
           if (fcn)
             function_on_path = octave_value (fcn);
         }
     }
 
   return function_on_path;
 }
 
+octave_value
+symbol_table::fcn_info::fcn_info_rep::find_package (const std::string& pname)
+{
+  // FIXME: implement correct way to check out of date package
+  //if (package.is_defined ())
+  //  out_of_date_check (package);
+
+  if (! (error_state || package.is_defined ()))
+    {
+      std::string full_name = name;
+
+      if (! pname.empty ())
+        full_name = pname + "." + full_name;
+
+      octave_function * fcn = cdef_manager::find_package_symbol (full_name);
+
+      if (fcn)
+        package = octave_value (fcn);
+    }
+
+  return package;
+}
+
 // Insert INF_CLASS in the set of class names that are considered
 // inferior to SUP_CLASS.  Return FALSE if INF_CLASS is currently
 // marked as superior to  SUP_CLASS.
 
 bool
 symbol_table::set_class_relationship (const std::string& sup_class,
                                       const std::string& inf_class)
 {
@@ -1171,19 +1221,20 @@ symbol_table::install_nestfunction (cons
 
   parent_table->add_nest_child (*fcn_table_loc);
 }
 
 octave_value
 symbol_table::find (const std::string& name,
                     const octave_value_list& args,
                     bool skip_variables,
-                    bool local_funcs)
+                    bool local_funcs,
+                    scope_id scope)
 {
-  symbol_table *inst = get_instance (xcurrent_scope);
+  symbol_table *inst = get_instance (scope);
 
   return inst
     ? inst->do_find (name, args, skip_variables, local_funcs)
     : octave_value ();
 }
 
 octave_value
 symbol_table::builtin_find (const std::string& name)
@@ -1371,22 +1422,22 @@ symbol_table::do_find (const std::string
                 return val;
             }
         }
     }
 
   fcn_table_iterator p = fcn_table.find (name);
 
   if (p != fcn_table.end ())
-    return p->second.find (args, local_funcs);
+    return p->second.find (args, local_funcs, package_name);
   else
     {
       fcn_info finfo (name);
 
-      octave_value fcn = finfo.find (args, local_funcs);
+      octave_value fcn = finfo.find (args, local_funcs, package_name);
 
       if (fcn.is_defined ())
         fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
diff --git a/libinterp/interpfcn/symtab.h b/libinterp/interpfcn/symtab.h
--- a/libinterp/interpfcn/symtab.h
+++ b/libinterp/interpfcn/symtab.h
@@ -756,38 +756,42 @@ public:
       fcn_info_rep (const std::string& nm)
         : name (nm), subfunctions (), private_functions (),
           class_constructors (), class_methods (), dispatch_map (),
           cmdline_function (), autoload_function (), function_on_path (),
           built_in_function (), count (1) { }
 
       octave_value load_private_function (const std::string& dir_name);
 
-      octave_value load_class_constructor (void);
+      octave_value load_class_constructor (const std::string& pname);
 
       octave_value load_class_method (const std::string& dispatch_type);
 
-      octave_value find (const octave_value_list& args, bool local_funcs);
+      octave_value find (const octave_value_list& args, bool local_funcs,
+                         const std::string& package_name);
 
       octave_value builtin_find (void);
 
       octave_value find_method (const std::string& dispatch_type);
 
       octave_value find_autoload (void);
 
-      octave_value find_user_function (void);
+      octave_value find_package (const std::string& package_name);
+
+      octave_value find_user_function (const std::string& package_name);
 
       bool is_user_function_defined (void) const
       {
         return function_on_path.is_defined ();
       }
 
-      octave_value find_function (const octave_value_list& args, bool local_funcs)
+      octave_value find_function (const octave_value_list& args, bool local_funcs,
+                                  const std::string& package_name)
       {
-        return find (args, local_funcs);
+        return find (args, local_funcs, package_name);
       }
 
       void lock_subfunction (scope_id scope)
       {
         scope_val_iterator p = subfunctions.find (scope);
 
         if (p != subfunctions.end ())
           p->second.lock ();
@@ -875,25 +879,31 @@ public:
       }
 
       void clear_mex_function (void)
       {
         if (function_on_path.is_mex_function ())
           clear_user_function ();
       }
 
+      void clear_package (void)
+      {
+        package = octave_value ();
+      }
+
       void clear (bool force = false)
       {
         clear_map (subfunctions, force);
         clear_map (private_functions, force);
         clear_map (class_constructors, force);
         clear_map (class_methods, force);
 
         clear_autoload_function (force);
         clear_user_function (force);
+        clear_package ();
       }
 
       void add_dispatch (const std::string& type, const std::string& fname)
       {
         dispatch_map[type] = fname;
       }
 
       void clear_dispatch (const std::string& type)
@@ -930,23 +940,26 @@ public:
       dispatch_map_type dispatch_map;
 
       octave_value cmdline_function;
 
       octave_value autoload_function;
 
       octave_value function_on_path;
 
+      octave_value package;
+
       octave_value built_in_function;
 
       octave_refcount<size_t> count;
 
     private:
 
-      octave_value xfind (const octave_value_list& args, bool local_funcs);
+      octave_value xfind (const octave_value_list& args, bool local_funcs,
+                          const std::string& package_name);
 
       octave_value x_builtin_find (void);
 
       // No copying!
 
       fcn_info_rep (const fcn_info_rep&);
 
       fcn_info_rep& operator = (const fcn_info_rep&);
@@ -978,19 +991,20 @@ public:
 
     ~fcn_info (void)
     {
       if (--rep->count == 0)
         delete rep;
     }
 
     octave_value find (const octave_value_list& args = octave_value_list (),
-                       bool local_funcs = true)
+                       bool local_funcs = true,
+                       const std::string& package_name = std::string ())
     {
-      return rep->find (args, local_funcs);
+      return rep->find (args, local_funcs, package_name);
     }
 
     octave_value builtin_find (void)
     {
       return rep->builtin_find ();
     }
 
     octave_value find_method (const std::string& dispatch_type) const
@@ -1008,30 +1022,31 @@ public:
       return rep->cmdline_function;
     }
 
     octave_value find_autoload (void)
     {
       return rep->find_autoload ();
     }
 
-    octave_value find_user_function (void)
+    octave_value find_user_function (const std::string& pname = std::string ())
     {
-      return rep->find_user_function ();
+      return rep->find_user_function (pname);
     }
 
     bool is_user_function_defined (void) const
     {
       return rep->is_user_function_defined ();
     }
 
     octave_value find_function (const octave_value_list& args = octave_value_list (),
-                                bool local_funcs = true)
+                                bool local_funcs = true,
+                                const std::string& package_name = std::string ())
     {
-      return rep->find_function (args, local_funcs);
+      return rep->find_function (args, local_funcs, package_name);
     }
 
     void lock_subfunction (scope_id scope)
     {
       rep->lock_subfunction (scope);
     }
 
     void unlock_subfunction (scope_id scope)
@@ -1127,16 +1142,31 @@ public:
   static scope_id top_scope (void) { return xtop_scope; }
 
   static scope_id current_scope (void) { return xcurrent_scope; }
 
   static context_id current_context (void) { return xcurrent_context; }
 
   static scope_id alloc_scope (void) { return scope_id_cache::alloc (); }
 
+  static scope_id alloc_package_scope (const std::string& name)
+  {
+    scope_id retval = alloc_scope ();
+
+    if (retval != -1)
+      {
+        symbol_table* inst = get_instance (retval, true);
+
+        inst->do_cache_name (name);
+        inst->package_name = name;
+      }
+
+    return retval;
+  }
+
   static void set_scope (scope_id scope)
   {
     if (scope == xglobal_scope)
       error ("can't set scope to global");
     else if (scope != xcurrent_scope)
       {
         all_instances_iterator p = all_instances.find (scope);
 
@@ -1270,17 +1300,18 @@ public:
 
   static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
 
   // Find a value corresponding to the given name in the table.
   static octave_value
   find (const std::string& name,
         const octave_value_list& args = octave_value_list (),
         bool skip_variables = false,
-        bool local_funcs = true);
+        bool local_funcs = true,
+        scope_id scope = xcurrent_scope);
 
   static octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
   static symbol_record& insert (const std::string& name,
                                 scope_id scope = xcurrent_scope)
   {
     static symbol_record foobar;
@@ -2307,16 +2338,20 @@ private:
   symbol_table *nest_parent;
 
   // The associated user code (may be null).
   octave_user_function *curr_fcn;
 
   // If true then no variables can be added.
   bool static_workspace;
 
+  // The name of the package context associated with this table. This is
+  // only used by classdef packages.
+  std::string package_name;
+
   // Map from names of global variables to values.
   static std::map<std::string, octave_value> global_table;
 
   // Map from names of persistent variables to values.
   std::map<std::string, octave_value> persistent_table;
 
   // Pointer to symbol table for current scope (variables only).
   static symbol_table *instance;
@@ -2347,17 +2382,17 @@ private:
   static scope_id xcurrent_scope;
 
   static context_id xcurrent_context;
 
   static const context_id xdefault_context = static_cast<context_id> (-1);
 
   symbol_table (scope_id scope)
     : my_scope (scope), table_name (), table (), nest_children (), nest_parent (0),
-    curr_fcn (0), static_workspace (false), persistent_table () { }
+    curr_fcn (0), static_workspace (false), package_name (), persistent_table () { }
 
   ~symbol_table (void) { }
 
   static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
 #include "defun.h"
+#include "load-path.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
 #include "pt-assign.h"
 #include "pt-classdef.h"
 #include "pt-funcall.h"
 #include "pt-misc.h"
@@ -718,20 +719,19 @@ make_method (const cdef_class& cls, cons
 
   return make_method (cls, name, fcn, m_access, is_static);
 }
 
 static cdef_package
 make_package (const std::string& nm,
               const std::string& parent = std::string ())
 {
-  cdef_package pack ("meta.package");
+  cdef_package pack (nm);
 
   pack.set_class (cdef_class::meta_package ());
-  pack.put ("Name", nm);
   if (parent.empty ())
     pack.put ("ContainingPackage", Matrix ());
   else
     pack.put ("ContainingPackage", to_ov (cdef_manager::find_package (parent)));
 
   if (! nm.empty ())
     cdef_manager::register_package (pack);
 
@@ -774,16 +774,18 @@ octave_classdef::subsref (const std::str
   return retval;
 }
 
 octave_value
 octave_classdef::subsasgn (const std::string& type,
                            const std::list<octave_value_list>& idx,
                            const octave_value& rhs)
 {
+  // FIXME: should check "subsasgn" method first
+
   return object.subsasgn (type, idx, rhs);
 }
 
 octave_value
 octave_classdef::undef_subsasgn (const std::string& type,
                                  const std::list<octave_value_list>& idx,
                                  const octave_value& rhs)
 {
@@ -945,17 +947,17 @@ public:
               else
                 {
                   if (mname == meth_name)
                     {
                       if (is_strict_superclass (cls, ctx))
                         {
                           // I see 2 possible implementations here:
                           // 1) use cdef_object::subsref with a different class
-                          //    context; this avoids duplicating codem but
+                          //    context; this avoids duplicating code, but
                           //    assumes the object is always the first argument
                           // 2) lookup the method manually and call
                           //    cdef_method::execute; this duplicates part of
                           //    logic in cdef_object::subsref, but avoid the
                           //    assumption of 1)
                           // Not being sure about the assumption of 1), I
                           // go with option 2) for the time being.
 
@@ -2185,22 +2187,24 @@ attribute_value_to_string (T* t, octave_
   else
     return std::string ("true");
 }
 
 cdef_class
 cdef_class::make_meta_class (tree_classdef* t)
 {
   cdef_class retval;
-  std::string class_name;
+  std::string class_name, full_class_name;
 
   // Class creation
 
-  class_name = t->ident ()->name ();
-  gnulib::printf ("class: %s\n", class_name.c_str ());
+  class_name = full_class_name = t->ident ()->name ();
+  if (! t->package_name ().empty ())
+    full_class_name = t->package_name () + "." + full_class_name;
+  gnulib::printf ("class: %s\n", full_class_name.c_str ());
 
   std::list<cdef_class> slist;
 
   if (t->superclass_list ())
     {
       for (tree_classdef_superclass_list::iterator it = t->superclass_list ()->begin ();
            ! error_state && it != t->superclass_list ()->end (); ++it)
         {
@@ -2214,31 +2218,41 @@ cdef_class::make_meta_class (tree_classd
 
           if (! error_state)
             {
               if (! sclass.get ("Sealed").bool_value ())
                 slist.push_back (sclass);
               else
                 {
                   ::error ("`%s' cannot inherit from `%s', because it is sealed",
-                           class_name.c_str (), sclass_name.c_str ());
+                           full_class_name.c_str (), sclass_name.c_str ());
                   return retval;
                 }
             }
           else
             return retval;
 
         }
     }
 
-  retval = ::make_class (class_name, slist);
+  retval = ::make_class (full_class_name, slist);
 
   if (error_state)
     return cdef_class ();
 
+  // Package owning this class
+
+  if (! t->package_name ().empty ())
+    {
+      cdef_package pack = cdef_manager::find_package (t->package_name ());
+
+      if (! error_state && pack.ok ())
+        retval.put ("ContainingPackage", to_ov (pack));
+    }
+
   // Class attributes
 
   if (t->attribute_list ())
     {
       for (tree_classdef_attribute_list::iterator it = t->attribute_list ()->begin ();
            it != t->attribute_list ()->end (); ++it)
         {
           std::string aname = (*it)->ident ()->name ();
@@ -2765,16 +2779,99 @@ cdef_package::cdef_package_rep::get_clas
 Cell
 cdef_package::cdef_package_rep::get_functions (void) const
 { return map2Cell (function_map); }
 
 Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
+octave_value
+cdef_package::cdef_package_rep::find (const std::string& nm)
+{
+  if (scope == -1)
+    scope = symbol_table::alloc_package_scope (get_name ());
+
+  return symbol_table::find (nm, octave_value_list (), true, false, scope);
+}
+
+octave_value_list
+cdef_package::cdef_package_rep::meta_subsref
+  (const std::string& type, const std::list<octave_value_list>& idx,
+   int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '.':
+      if (idx.front ().length () == 1)
+        {
+          std::string nm = idx.front ()(0).string_value ();
+
+          if (! error_state)
+            {
+              gnulib::printf ("meta.package query: %s\n", nm.c_str ());
+
+              octave_value o = find (nm);
+
+              if (o.is_defined ())
+                {
+                  if (o.is_function ())
+                    {
+                      octave_function* fcn = o.function_value ();
+
+                      if (! error_state)
+                        {
+                          if (type.size () == 1 ||
+                              ! fcn->is_postfix_index_handled (type[1]))
+                            {
+                              octave_value_list tmp_args;
+
+                              retval = o.do_multi_index_op (nargout,
+                                                            tmp_args);
+                            }
+                          else
+                            retval(0) = o;
+
+                          if (type.size () > 1 && idx.size () > 1)
+                            retval = retval(0).next_subsref (nargout, type,
+                                                             idx, 1);
+                        }
+                    }
+                  else if (type.size () > 1 && idx.size () > 1)
+                    retval = o.next_subsref (nargout, type, idx, 1);
+                  else
+                    retval(0) = o;
+                }
+              else
+                error ("member `%s' in package `%s' does not exist",
+                       nm.c_str (), get_name ().c_str ());
+            }
+          else
+            error ("invalid meta.package indexing, expected a symbol name");
+        }
+      else
+        error ("invalid meta.package indexing");
+      break;
+
+    default:
+      error ("invalid meta.package indexing");
+      break;
+    }
+
+  return retval;
+}
+
+void
+cdef_package::cdef_package_rep::meta_release (void)
+{
+  cdef_manager::unregister_package (wrap ());
+}
+
 cdef_class cdef_class::_meta_class = cdef_class ();
 cdef_class cdef_class::_meta_property = cdef_class ();
 cdef_class cdef_class::_meta_method = cdef_class ();
 cdef_class cdef_class::_meta_package = cdef_class ();
 
 cdef_package cdef_package::_meta = cdef_package ();
 
 void
@@ -2943,21 +3040,33 @@ cdef_manager::create_instance (void)
 cdef_class
 cdef_manager::do_find_class (const std::string& name,
                              bool error_if_not_found, bool load_if_not_found)
 {
   std::map<std::string, cdef_class>::iterator it = all_classes.find (name);
 
   if (it == all_classes.end ())
     {
-      // FIXME: implement this properly, take package prefix into account
-
       if (load_if_not_found)
         {
-          octave_value ov_cls = symbol_table::find (name);
+          octave_value ov_cls;
+
+          size_t pos = name.rfind ('.');
+
+          if (pos == std::string::npos)
+            ov_cls = symbol_table::find (name);
+          else
+            {
+              std::string pack_name = name.substr (0, pos);
+
+              cdef_package pack = do_find_package (pack_name, false, true);
+
+              if (pack.ok ())
+                ov_cls = pack.find (name.substr (pos+1));
+            }
 
           if (ov_cls.is_defined ())
             it = all_classes.find (name);
         }
     }
 
   if (it == all_classes.end ())
     {
@@ -2996,32 +3105,62 @@ cdef_manager::do_find_method_symbol (con
         retval = new octave_classdef_meta (meth);
     }
 
   return retval;
 }
 
 cdef_package
 cdef_manager::do_find_package (const std::string& name,
-                               bool error_if_not_found)
+                               bool error_if_not_found,
+                               bool load_if_not_found)
 {
   cdef_package retval;
 
   std::map<std::string, cdef_package>::const_iterator it
     = all_packages.find (name);
 
   if (it != all_packages.end ())
     {
       retval = it->second;
 
       if (! retval.ok ())
         error ("invalid package `%s'", name.c_str ());
     }
-  else if (error_if_not_found)
-    error ("unknown package `%s'", name.c_str ());
+  else
+    {
+      if (load_if_not_found && load_path::find_package (name))
+        {
+          size_t pos = name.find ('.');
+
+          if (pos == std::string::npos)
+            retval = make_package (name, std::string ());
+          else
+            {
+              std::string parent_name = name.substr (0, pos);
+
+              retval = make_package (name, parent_name);
+            }
+        }
+      else if (error_if_not_found)
+        error ("unknown package `%s'", name.c_str ());
+    }
+
+  return retval;
+}
+
+octave_function*
+cdef_manager::do_find_package_symbol (const std::string& pack_name)
+{
+  octave_function* retval = 0;
+
+  cdef_package pack = find_package (pack_name, false);
+
+  if (pack.ok ())
+    retval = new octave_classdef_meta (pack);
 
   return retval;
 }
 
 //----------------------------------------------------------------------------
 
 DEFUN (__meta_get_package__, args, , "")
 {
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 
 #include <map>
 #include <set>
 #include <string>
 
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "ov-base.h"
+#include "symtab.h"
 
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
 class tree_classdef;
@@ -1205,17 +1206,24 @@ cdef_package : public cdef_meta_object
   friend class cdef_class;
 
 private:
 
   class
   cdef_package_rep : public cdef_meta_object_rep
   {
   public:
-    cdef_package_rep (void) : cdef_meta_object_rep (), member_count (0) { }
+    cdef_package_rep (void)
+      : cdef_meta_object_rep (), member_count (0), scope (-1) { }
+
+    ~cdef_package_rep (void)
+      {
+        if (scope != -1)
+          symbol_table::erase_scope (scope);
+      }
 
     cdef_object_rep* copy (void) const { return new cdef_package_rep (*this); }
 
     bool is_package (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
@@ -1244,37 +1252,59 @@ private:
             member_count = 0;
             class_map.clear ();
             package_map.clear ();
           }
         else
           delete this;
       }
 
+    octave_value_list
+    meta_subsref (const std::string& type,
+                  const std::list<octave_value_list>& idx, int nargout);
+
+    void meta_release (void);
+
+    bool meta_is_postfix_index_handled (char type) const
+      { return (type == '.'); }
+
+    octave_value find (const std::string& nm);
+
   private:
+    std::string full_name;
     std::map<std::string, cdef_class> class_map;
     std::map<std::string, octave_value> function_map;
     std::map<std::string, cdef_package> package_map;
 
     // The number of registered members in this package (classes, packages).
     // This only accounts for the members that back-reference to this package.
     octave_idx_type member_count;
 
     typedef std::map<std::string, cdef_class>::iterator class_iterator;
     typedef std::map<std::string, cdef_class>::const_iterator class_const_iterator;
     typedef std::map<std::string, octave_value>::iterator function_iterator;
     typedef std::map<std::string, octave_value>::const_iterator function_const_iterator;
     typedef std::map<std::string, cdef_package>::iterator package_iterator;
     typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
 
+    // The symbol_table scope corresponding to this package.
+    symbol_table::scope_id scope;
+
   private:
     cdef_package_rep (const cdef_package_rep& p)
-      : cdef_meta_object_rep (p), class_map (p.class_map),
-        function_map (p.function_map), package_map (p.package_map),
-        member_count (p.member_count) { }
+      : cdef_meta_object_rep (p), full_name (p.full_name),
+        class_map (p.class_map), function_map (p.function_map),
+        package_map (p.package_map), member_count (p.member_count)
+      { }
+
+    cdef_package wrap (void)
+      {
+        refcount++;
+        return cdef_package (this);
+      }
   };
 
 public:
   cdef_package (void) : cdef_meta_object () { }
 
   cdef_package (const std::string& nm)
       : cdef_meta_object (new cdef_package_rep ())
     { get_rep ()->set_name (nm); }
@@ -1313,16 +1343,18 @@ public:
   Cell get_functions (void) const
     { return get_rep ()->get_functions (); }
 
   Cell get_packages (void) const
     { return get_rep ()->get_packages (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
+  octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
+
   static const cdef_package& meta (void) { return _meta; }
 
 private:
   cdef_package_rep* get_rep (void)
     { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
   
   const cdef_package_rep* get_rep (void) const
     { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
@@ -1489,24 +1521,34 @@ public:
     {
       if (instance_ok ())
         return instance->do_find_method_symbol (method_name, class_name);
 
       return 0;
     }
 
   static cdef_package find_package (const std::string& name,
-                                    bool error_if_not_found = true)
+                                    bool error_if_not_found = true,
+                                    bool load_if_not_found = true)
     {
       if (instance_ok ())
-        return instance->do_find_package (name, error_if_not_found);
+        return instance->do_find_package (name, error_if_not_found,
+                                          load_if_not_found);
 
       return cdef_package ();
     }
 
+  static octave_function* find_package_symbol (const std::string& pack_name)
+    {
+      if (instance_ok ())
+        return instance->do_find_package_symbol (pack_name);
+
+      return 0;
+    }
+
   static void register_class (const cdef_class& cls)
     {
       if (instance_ok ())
         instance->do_register_class (cls);
     }
 
   static void unregister_class (const cdef_class& cls)
     {
@@ -1564,17 +1606,20 @@ private:
 
   cdef_class do_find_class (const std::string& name, bool error_if_not_found,
                             bool load_if_not_found);
 
   octave_function* do_find_method_symbol (const std::string& method_name,
                                           const std::string& class_name);
 
   cdef_package do_find_package (const std::string& name,
-                                bool error_if_not_found);
+                                bool error_if_not_found,
+                                bool load_if_not_found);
+
+  octave_function* do_find_package_symbol (const std::string& pack_name);
 
   void do_register_class (const cdef_class& cls)
     { all_classes[cls.get_name ()] = cls; }
 
   void do_unregister_class (const cdef_class& cls)
     { all_classes.erase(cls.get_name ()); }
 
   void do_register_package (const cdef_package& pkg)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -261,17 +261,17 @@ octave_fcn_handle::set_fcn (const std::s
 
       if (fs.exists ())
         {
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn
-            = load_fcn_from_file (str, dir_name, "", nm);
+            = load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (xfcn)
             {
               octave_value tmp (xfcn);
 
               fcn = octave_value (new octave_fcn_handle (tmp, nm));
             }
           else
@@ -291,17 +291,17 @@ octave_fcn_handle::set_fcn (const std::s
           dir_path p (load_path::system_path ());
 
           str = octave_env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
-          octave_function *xfcn = load_fcn_from_file (str, dir_name, "", nm);
+          octave_function *xfcn = load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (xfcn)
             {
               octave_value tmp (xfcn);
 
               fcn = octave_value (new octave_fcn_handle (tmp, nm));
             }
           else
@@ -314,17 +314,17 @@ octave_fcn_handle::set_fcn (const std::s
   else
     {
       if (fpath.length () > 0)
         {
           size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = fpath.substr (0, xpos);
 
-          octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", nm);
+          octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", "", nm);
 
           if (xfcn)
             {
               octave_value tmp (xfcn);
 
               fcn = octave_value (new octave_fcn_handle (tmp, nm));
             }
           else
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -1583,16 +1583,17 @@ octave_base_parser::reset (void)
   endfunction_found = false;
   autoloading = false;
   fcn_file_from_relative_lookup = false;
   parsing_subfunctions = false;
   max_fcn_depth = 0;
   curr_fcn_depth = 0;
   primary_fcn_scope = -1;
   curr_class_name = "";
+  curr_package_name = "";
   function_scopes.clear ();
   primary_fcn_ptr  = 0;
   subfunction_names.clear ();
 
   delete stmt_list;
   stmt_list = 0;
 
   lexer.reset ();
@@ -2967,17 +2968,18 @@ octave_base_parser::make_classdef (token
 
   if (end_token_ok (end_tok, token::classdef_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = tok_val->line ();
       int c = tok_val->column ();
 
-      retval = new tree_classdef (a, id, sc, body, lc, tc, l, c);
+      retval = new tree_classdef (a, id, sc, body, lc, tc, curr_package_name,
+                                  l, c);
     }
 
   return retval;
 }
 
 tree_classdef_properties_block *
 octave_base_parser::make_classdef_properties_block (token *tok_val,
                                                     tree_classdef_attribute_list *a,
@@ -3524,16 +3526,17 @@ safe_fclose (FILE *f)
 
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
 static octave_function *
 parse_fcn_file (const std::string& full_file, const std::string& file,
                 const std::string& dispatch_type,
+                const std::string& package_name,
                 bool require_file, bool force_script, bool autoload,    
                 bool relative_lookup, const std::string& warn_for)
 {
   unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
@@ -3557,16 +3560,17 @@ parse_fcn_file (const std::string& full_
   if (ffile)
     {
       // octave_base_parser constructor sets this for us.
       frame.protect_var (LEXER);
 
       octave_parser parser (ffile);
 
       parser.curr_class_name = dispatch_type;
+      parser.curr_package_name = package_name;
       parser.autoloading = autoload;
       parser.fcn_file_from_relative_lookup = relative_lookup;
 
       parser.lexer.force_script = force_script;
       parser.lexer.prep_for_file ();
       parser.lexer.parsing_class_method = ! dispatch_type.empty ();
 
       parser.lexer.fcn_file_name = file;
@@ -3639,17 +3643,18 @@ get_help_from_file (const std::string& n
         file = file.substr (pos+1);
     }
 
   if (! file.empty ())
     {
       symbol_found = true;
 
       octave_function *fcn
-        = parse_fcn_file (full_file, file, "", true, false, false, false, "");
+        = parse_fcn_file (full_file, file, "", "", true, false, false, false,
+                          "");
 
       if (fcn)
         {
           retval = fcn->doc_string ();
 
           delete fcn;
         }
     }
@@ -3703,16 +3708,17 @@ reverse_lookup_autoload (const std::stri
       names.append (p->first);
 
   return names;
 }
 
 octave_function *
 load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
                     const std::string& dispatch_type,
+                    const std::string& package_name,
                     const std::string& fcn_name, bool autoload)
 {
   octave_function *retval = 0;
 
   unwind_protect frame;
 
   std::string nm = file_name;
 
@@ -3750,30 +3756,31 @@ load_fcn_from_file (const std::string& f
       retval = octave_dynamic_loader::load_oct (nm, file, relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     {
       // Temporarily load m-file version of mex-file, if it exists,
       // to get the help-string to use.
 
       octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
-                                                nm, dispatch_type, false,
+                                                nm, dispatch_type,
+                                                package_name, false,
                                                 autoload, autoload,
                                                 relative_lookup, "");
 
       retval = octave_dynamic_loader::load_mex (nm, file, relative_lookup);
 
       if (tmpfcn)
         retval->document (tmpfcn->doc_string ());
       delete tmpfcn;
     }
   else if (len > 2)
     {
-      retval = parse_fcn_file (file, nm, dispatch_type, true, autoload,
-                               autoload, relative_lookup, "");
+      retval = parse_fcn_file (file, nm, dispatch_type, package_name, true,
+                               autoload, autoload, relative_lookup, "");
     }
 
   if (retval)
     {
       retval->stash_dir_name (dir_name);
 
       if (retval->is_user_function ())
         {
@@ -3961,17 +3968,17 @@ source_file (const std::string& file_nam
 
       if (! error_state)
         frame.add_fcn (octave_call_stack::pop);
     }
 
   if (! error_state)
     {
       octave_function *fcn = parse_fcn_file (file_full_name, file_name,
-                                             "", require_file, true,
+                                             "", "", require_file, true,
                                              false, false, warn_for);
 
       if (! error_state)
         {
           if (fcn && fcn->is_user_script ())
             {
               octave_value_list args;
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -99,16 +99,17 @@ extern OCTINTERP_API std::string lookup_
 extern OCTINTERP_API string_vector autoloaded_functions (void);
 
 extern OCTINTERP_API string_vector reverse_lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API octave_function *
 load_fcn_from_file (const std::string& file_name,
                     const std::string& dir_name = std::string (),
                     const std::string& dispatch_type = std::string (),
+                    const std::string& package_name = std::string (),
                     const std::string& fcn_name = std::string (),
                     bool autoload = false);
 
 extern OCTINTERP_API void
 source_file (const std::string& file_name,
              const std::string& context = std::string (),
              bool verbose = false, bool require_file = true,
              const std::string& warn_for = std::string ());
@@ -143,19 +144,19 @@ octave_base_parser
 {
 public:
 
   octave_base_parser (octave_base_lexer& lxr)
     : endfunction_found (false),
       autoloading (false), fcn_file_from_relative_lookup (false),
       parsing_subfunctions (false), max_fcn_depth (0),
       curr_fcn_depth (0), primary_fcn_scope (-1),
-      curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      subfunction_names (), classdef_object (0), stmt_list (0),
-      lexer (lxr)
+      curr_class_name (), curr_package_name (), function_scopes (),
+      primary_fcn_ptr (0), subfunction_names (), classdef_object (0),
+      stmt_list (0), lexer (lxr)
   {
     init ();
   }
 
   ~octave_base_parser (void);
 
   void init (void);
 
@@ -419,16 +420,20 @@ public:
   // Scope where we install all subfunctions and nested functions. Only
   // used while reading function files.
   symbol_table::scope_id primary_fcn_scope;
 
   // Name of the current class when we are parsing class methods or
   // constructors.
   std::string curr_class_name;
 
+  // Name of the current package when we are parsing an element contained
+  // in a package directory (+-directory).
+  std::string curr_package_name;
+
   // A stack holding the nested function scopes being parsed.
   // We don't use std::stack, because we want the clear method. Also, we
   // must access one from the top
   std::vector<symbol_table::scope_id> function_scopes;
 
   // Pointer to the primary user function or user script function.
   octave_function *primary_fcn_ptr;
 
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -593,19 +593,22 @@ private:
 
 class tree_classdef : public tree_command
 {
 public:
 
   tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
                  tree_classdef_superclass_list *sc,
                  tree_classdef_body *b, octave_comment_list *lc,
-                 octave_comment_list *tc, int l = -1, int c = -1)
+                 octave_comment_list *tc,
+                 const std::string& pn = std::string (), int l = -1,
+                 int c = -1)
     : tree_command (l, c), attr_list (a), id (i),
-      supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc) { }
+      supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
+      pack_name (pn) { }
 
   ~tree_classdef (void)
   {
     delete attr_list;
     delete id;
     delete supclass_list;
     delete element_list;
     delete lead_comm;
@@ -618,16 +621,18 @@ public:
 
   tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
 
   tree_classdef_body *body (void) { return element_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
+  const std::string& package_name (void) const { return pack_name; }
+
   octave_function* make_meta_class (void);
 
   tree_classdef *dup (symbol_table::scope_id scope,
                       symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
@@ -638,16 +643,18 @@ private:
 
   tree_classdef_superclass_list *supclass_list;
 
   tree_classdef_body *element_list;
 
   octave_comment_list *lead_comm;
   octave_comment_list *trail_comm;
 
+  std::string pack_name;
+
   // No copying!
 
   tree_classdef (const tree_classdef&);
 
   tree_classdef& operator = (const tree_classdef&);
 };
 
 #endif
