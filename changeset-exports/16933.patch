# HG changeset patch
# User Rik <rik@octave.org>
# Date 1373403845 25200
#      Tue Jul 09 14:04:05 2013 -0700
# Node ID e39f00a32dc7935dbc053037acea14608b21fe7d
# Parent  c55df4e5e216d24d06428b26e5339cbbeb74abb0
maint: Use parentheses around condition for switch(),while(),if() statements.

* libinterp/corefcn/dirfns.cc, libinterp/octave-value/ov-fcn-handle.cc,
liboctave/array/Sparse.cc, scripts/image/rgb2ind.m, scripts/io/importdata.m,
scripts/io/strread.m, scripts/optimization/fminbnd.m,
scripts/optimization/sqp.m, scripts/plot/graphics_toolkit.m,
scripts/plot/hdl2struct.m, scripts/plot/legend.m, scripts/plot/print.m,
scripts/plot/printd.m, scripts/plot/private/__contour__.m,
scripts/plot/private/__go_draw_axes__.m, scripts/plot/struct2hdl.m,
scripts/polynomial/polyeig.m, scripts/sparse/bicg.m, scripts/specfun/ellipke.m,
scripts/special-matrix/gallery.m, scripts/ui/errordlg.m, scripts/ui/helpdlg.m,
scripts/ui/inputdlg.m, scripts/ui/listdlg.m, scripts/ui/questdlg.m,
scripts/ui/warndlg.m: Use parentheses around condition for
switch(),while(),if() statements.

diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -623,17 +623,17 @@ glob (\"file[12]\")\n\
 
 /*
 %!test
 %! tmpdir = tmpnam;
 %! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
 %! if (mkdir (tmpdir))
 %!   cwd = pwd;
 %!   cd (tmpdir);
-%!   if strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir))
+%!   if (strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir)))
 %!     a = 0;
 %!     for n = 1:5
 %!       save (filename{n}, "a");
 %!     endfor
 %!   else
 %!     rmdir (tmpdir);
 %!     error ("Couldn't change to temporary dir");
 %!   endif
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1324,24 +1324,24 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 %!   unwind_protect_cleanup
 %!     unlink (nm);
 %!   end_unwind_protect
 %! endfor
 */
 
 /*
 %!function fcn_handle_save_recurse (n, mode, nm, f2, g2, hm2, hdld2, hbi2)
-%!  if n == 0
+%!  if (n == 0)
 %!    save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!  else
 %!    fcn_handle_save_recurse (n - 1, mode, nm, f2, g2, hm2, hdld2, hbi2);
 %!  endif
 %!endfunction
 %!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
-%!  if n == 0
+%!  if (n == 0)
 %!    load (nm)
 %!  else
 %!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
 %!  endif
 %!endfunction
 
 Test for bug #35876
 %!test
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2618,30 +2618,30 @@ Sparse<T>::array_value () const
   return retval;
 }
 
 /*
  * Tests
  *
 
 %!function x = set_slice (x, dim, slice, arg)
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    otherwise
 %!      error ("invalid dim, '%d'", dim);
 %!  endswitch
 %!endfunction
 
 %!function x = set_slice2 (x, dim, slice)
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2 * ones (size (slice));
 %!    case 21
 %!      x(slice, :) = 2 * ones (length (slice), columns (x));
 %!    case 22
 %!      x(:, slice) = 2 * ones (rows (x), length (slice));
 %!    otherwise
 %!      error ("invalid dim, '%d'", dim);
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -61,17 +61,17 @@
 function [x, map] = rgb2ind (varargin)
 
   ## Gather the inputs
   if (nargin < 1 || nargin > 6)
     print_usage ();
   else
 
     ## Test for dither_option, by checking if the final input is a string
-    if ischar (varargin{end})
+    if (ischar (varargin{end}))
       dither_option = varargin{end};
       dither_check  = true;
     else
       dither_option = "dither";
       dither_check  = false;
     endif
 
     ## Read the rgb input
@@ -138,24 +138,24 @@ function [x, map] = rgb2ind (varargin)
       map = reshape (map, size (map, 1), 1, 3);
       imwrite (map, fnmap, "tiff");
       optionstr = sprintf ("-map %s", fnmap);
       
     endif
   
     ## If image is an ND array, convert it to a tiled 2D image
     ## before processing it with Graphicsmagick
-    if numel (sz)>3
+    if (numel (sz) > 3)
      rgb = reshape (rgb, [prod(sz(1:end-2)), sz(end-1), 3]);
     end
 
     ## Prepare the Graphicsmagick dithering option
-    if strcmp (dither_option, "nodither")
+    if (strcmp (dither_option, "nodither"))
       ditherstr = "+dither";
-    elseif strcmp (dither_option, "dither")
+    elseif (strcmp (dither_option, "dither"))
       ditherstr = "-dither";
     endif
       
     ## Perform the image processing using Graphicsmagick
     fna = tmpnam;
     fnb = tmpnam;
     imwrite (rgb, fna, "tiff");
     gmstr = sprintf ("gm convert %s %s %s %s", fna, ditherstr, optionstr, fnb);
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -115,17 +115,17 @@ function [output, delimiter, header_rows
   ##########
 
   ## Check file format
   ## Get the extension from the file name.
   [d n fileExt v] = fileparts (fname);
   ## Make sure file extension is in lower case.
   fileExt = lower (fileExt);
 
-  switch fileExt
+  switch (fileExt)
     case {".au", ".snd"}
       error ("importdata: not implemented for file format %s", fileExt);
     case ".avi"
       error ("importdata: not implemented for file format %s", fileExt);
     case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", \
           ".pbm", ".pcx", ".pgm", ".png", ".pnm", ".ppm", ".ras", \
           ".tif", ".tiff", ".xwd"}
       delimiter  = NaN;
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -474,17 +474,17 @@ function varargout = strread (str, forma
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and matching fmt_words to words until the fmt_words array is exhausted.
       ## iwrd: ptr to current analyzed word; iwrdp: ptr to pos before analyzed char
       iwrd = 1; iwrdp = 0; iwrdl = length (words{1});
       fwptr = zeros (1, numel (fmt_words));
       ii = 1;
-      while ii <= numel (fmt_words)
+      while (ii <= numel (fmt_words))
 
         nxt_wrd = 0;
         ## Keep track of which words nr. every fmt_words{} is (starts) in.
         fwptr(ii) = iwrd;
 
         if (idf(ii))
           ## Literal expected
           if (isempty (strfind (fmt_words{ii}, words(iwrd))))
@@ -674,17 +674,17 @@ function varargout = strread (str, forma
         lastline = ...
           min (num_words_per_line * format_repeat_count + m - 1, numel (words));
         data = words(m:num_words_per_line:lastline);
       endif
 
       ## Map to format
       ## FIXME - add support for formats like "<%s>", "%[a-zA-Z]"
       ##         Someone with regexp experience is needed.
-      switch fmt_words{m}(1:min (2, length (fmt_words{m})))
+      switch (fmt_words{m}(1:min (2, length (fmt_words{m}))))
         case "%s"
           if (pad_out)
             data(end+1:num_lines) = {""};
           endif
           varargout{k} = data';
           k++;
         case {"%d", "%u", "%f", "%n"}
           n = cellfun ("isempty", data);
@@ -701,17 +701,17 @@ function varargout = strread (str, forma
           endif
           varargout{k} = data.';
           k++;
         case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
           sw = regexp (fmt_words{m}, '\d', "once");
           ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
           nfmt = ostrsplit (fmt_words{m}(2:ew), ".");
           swidth = str2double (nfmt{1});
-          switch fmt_words{m}(ew+1)
+          switch (fmt_words{m}(ew+1))
             case {"d", "u", "f", "n"}
               n = cellfun ("isempty", data);
               ### FIXME - erroneously formatted data lead to NaN, not an error
               ###         => ReturnOnError can't be implemented for numeric data
               data = str2double (strtrunc (data, swidth));
               data(n) = numeric_fill_value;
               if (pad_out)
                 data(end+1:num_lines) = numeric_fill_value;
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -205,17 +205,17 @@ function [x, fval, info, output] = fminb
       endif
     endif
   endwhile
 
   ## Fix the first step procedure.
   iter(1).procedure = "initial";
 
   ## Handle the "Display" option
-  switch displ
+  switch (displ)
     case "iter"
       print_formatted_table (iter);
       print_exit_msg (info, struct("TolX", tolx, "fx", fval));
     case "notify"
       if (info == 0)
         print_exit_msg (info, struct("fx",fval));
       endif
     case "final"
@@ -254,17 +254,17 @@ function print_formatted_table (table)
            num2str (row.fx,"%.6f"), row.procedure);
   endfor
   printf ("\n");
 endfunction
 
 ## Print either a success termination message or bad news
 function print_exit_msg (info, opt=struct())
   printf ("");
-  switch info
+  switch (info)
     case 1
       printf ("Optimization terminated:\n");
       printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
     case 0
       printf ("Exiting: Maximum number of iterations has been exceeded\n");
       printf ("         - increase MaxIter option.\n");
       printf ("         Current function value: %.6f\n", opt.fx);
     case -1
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -256,17 +256,17 @@ function [x, obj, info, iter, nf, lambda
     elseif (! isempty (cif))
       globals.cifcn = cif;
     endif
 
     if (nargin < 5 || (nargin > 5 && isempty (lb) && isempty (ub)))
       ## constraint inequality function only without any bounds
       ci_grd = @ (x) fd_ci_jac (x, globals.cifcn);
       if (iscell (cif))
-        switch length (cif)
+        switch (length (cif))
          case {1}
            ci_fun = cif{1};
          case {2}
            ci_fun = cif{1};
            ci_grd = cif{2};
         otherwise
           error ("sqp: invalid inequality constraint function specification");
         endswitch
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -96,17 +96,17 @@ endfunction
 %!   graphics_toolkit (hf, "fltk"); 
 %!   assert (graphics_toolkit (hf), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
 %! old_toolkit = graphics_toolkit ();
-%! switch old_toolkit
+%! switch (old_toolkit)
 %!   case {"gnuplot"}
 %!     new_toolkit = "fltk";
 %!   otherwise
 %!     new_toolkit = "gnuplot";
 %! endswitch
 %! assert (graphics_toolkit (new_toolkit), old_toolkit);
 %! assert (graphics_toolkit (old_toolkit), new_toolkit);
 
diff --git a/scripts/plot/hdl2struct.m b/scripts/plot/hdl2struct.m
--- a/scripts/plot/hdl2struct.m
+++ b/scripts/plot/hdl2struct.m
@@ -141,17 +141,17 @@ function prpstr = getprops (h)
             "interruptible", "parent", "selected" ,...
             "selectionhighlight", "type", "__modified__", ...
             "uicontextmenu", "__graphics_toolkit__", "currentaxes", ...
             "currentcharacter", "currentobject","tightinset", ...
             "currentpoint", "extent"};
 
   nflds = length (fields);
   ii = 0;
-  while nflds
+  while (nflds)
     prop = fields{nflds};
     val = obj.(fields{nflds});
     ii++;
     if (! any (strcmp (prop, forbid)))
       prpstr.(prop) = val;
     endif
     nflds--;
   endwhile
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1002,17 +1002,17 @@ function updatelegend (h, d)
     recursive = true;
     unwind_protect
       hax = getfield (get (h, "userdata"), "handle");
       [hplots, text_strings] = __getlegenddata__ (h);
       position = get (h, "unmodified_axes_position");
       outerposition = get (h, "unmodified_axes_outerposition");
       units = get (hax, "units");
       set (hax, "units", "points");
-      switch get (hax, "activepositionproperty")
+      switch (get (hax, "activepositionproperty"))
       case "position"
         set (hax, "outerposition", outerposition);
         set (hax, "position", position);
       case "outerposition"
         set (hax, "position", position);
         set (hax, "outerposition", outerposition);
       endswitch
       set (hax, "units", units);
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -490,17 +490,17 @@ function cmd = epstool (opts, filein, fi
     warning ("print:previewandtight",
              "print.m: eps preview may not be combined with -tight");
   endif
   if (! isempty (opts.preview) || opts.tight_flag)
     if (! isempty (opts.epstool_binary))
       if (opts.tight_flag)
         cmd = "--copy --bbox";
       elseif (! isempty (opts.preview))
-        switch opts.preview
+        switch (opts.preview)
         case "tiff"
           cmd = sprintf ("--add-%s-preview --device tiffg3", opts.preview);
         case {"tiff6u", "tiff6p", "metafile"}
           cmd = sprintf ("--add-%s-preview --device bmpgray", opts.preview);
         case {"tiff4", "interchange"}
           cmd = sprintf ("--add-%s-preview", opts.preview);
         case "pict"
           cmd = sprintf ("--add-%s-preview --mac-single", opts.preview);
@@ -612,17 +612,17 @@ function cmd = fig2dev (opts, devopt)
 endfunction
 
 function latex_standalone (opts)
   n = find (opts.name == ".", 1, "last");
   if (! isempty (n))
     opts.name = opts.name(1:n-1);
   endif
   latexfile = strcat (opts.name, ".tex");
-  switch opts.devopt
+  switch (opts.devopt)
   case {"pdflatexstandalone"}
     packages = "\\usepackage{graphicx,color}";
     graphicsfile = strcat (opts.name, "-inc.pdf");
   case {"pslatexstandalone"}
     packages = "\\usepackage{epsfig,color}";
     graphicsfile = strcat (opts.name, "-inc.ps");
   otherwise
     packages = "\\usepackage{epsfig,color}";
diff --git a/scripts/plot/printd.m b/scripts/plot/printd.m
--- a/scripts/plot/printd.m
+++ b/scripts/plot/printd.m
@@ -46,17 +46,17 @@ function pr_out = printd (obj, filename)
   opt = substr (filename, sufix+1);
   [pf, tempf, mag] = mkstemp ("oct-XXXXXX", 1);  # Safe version of tmpnam()
   fprintf (pf, "%s", disp (obj));
   frewind (pf);
 
   ## It seems best to only use convert for image output.  Its ps and pdf
   ## are badly rendered.
   opt = lower (opt);
-  switch opt
+  switch (opt)
     case {"pdf"}
       enscr = sprintf (
                        "enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit",...
                        tempf, tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
     case {"ps"}
       enscr = sprintf ("enscript --no-header -o %s %s ; exit", filename, tempf);
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -439,17 +439,17 @@ endfunction
 function update_data (h, d, prop = "")
   persistent recursive = false;
 
   if (!recursive)
     recursive = true;
 
     delete (get (h, "children"));
 
-    switch prop
+    switch (prop)
     case "levellist"
       set (h, "levellistmode", "manual")
     case "levelstep"
       set (h, "levelstepmode", "manual")
     endswitch
 
     if (strcmpi (get (h, "levellistmode"), "manual")
         && ! strcmp (prop, "levelstep"))
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1324,17 +1324,17 @@ function __go_draw_axes__ (h, plot_strea
             colorspec = get_text_colorspec (color, mono);
           endif
 
           if (ischar (obj.string))
             num_lines = rows (obj.string);
           else
             num_lines = numel (obj.string);
           endif
-          switch valign
+          switch (valign)
             ## Text offset in characters. This relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
             case "cap"
               dy = -0.5;
             case "middle"
               dy = 0.5 * (num_lines - 1);
             case "baseline"
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/struct2hdl.m
--- a/scripts/plot/struct2hdl.m
+++ b/scripts/plot/struct2hdl.m
@@ -412,17 +412,17 @@ function [h, sout, pout] = createhg_hile
     form = s.properties.format;
     xdata = s.properties.xdata;
     ydata = s.properties.ydata;
     xldata = s.properties.xldata;
     ldata = s.properties.ldata;
     xudata = s.properties.xudata;
     udata = s.properties.udata;
 
-    switch form
+    switch (form)
       case "xerr"
         h = errorbar (xdata, ydata, xldata, xudata, ">");
       case "yerr"
         h = errorbar (xdata, ydata, ldata, udata, "~");
       case "xyerr"
         h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "~>");
       case "box"
         h = errorbar (xdata, ydata, xldata, xudata, "#");
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -41,23 +41,23 @@ function [ z, varargout ] = polyeig (var
     print_usage ();
   endif
 
   nin = numel (varargin);
 
   n = zeros (1, nin);
 
   for cnt = 1 : nin
-    if ! ( issquare (varargin{cnt}) )
+    if (! issquare (varargin{cnt}))
        error ("polyeig: coefficients must be square matrices");
     endif
     n(cnt) = size (varargin{cnt}, 1);
   endfor
 
-  if numel (unique (n)) > 1
+  if (numel (unique (n)) > 1)
        error ("polyeig: coefficients must have the same dimensions");
   endif
   n = unique (n);
 
   ## matrix polynomial degree
   l = nin - 1;
 
   ## form needed matrices
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -228,17 +228,17 @@ endfunction;
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!function y = afun (x, t, a)
-%!  switch t
+%!  switch (t)
 %!   case "notransp"
 %!     y = a * x;
 %!   case "transp"
 %!     y = a' * x;
 %!  endswitch
 %!endfunction
 %!
 %!test
diff --git a/scripts/specfun/ellipke.m b/scripts/specfun/ellipke.m
--- a/scripts/specfun/ellipke.m
+++ b/scripts/specfun/ellipke.m
@@ -42,20 +42,20 @@
 function [k, e] = ellipke (m)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   k = e = zeros (size (m));
   m = m(:);
-  if any (!isreal (m))
+  if (any (!isreal (m)))
     error ("ellipke must have real m");
   endif
-  if any (m > 1)
+  if (any (m > 1))
     error ("ellipke must have m <= 1");
   endif
 
   Nmax = 16;
   idx = find (m == 1);
   if (!isempty (idx))
     k(idx) = Inf;
     e(idx) = 1;
@@ -114,17 +114,17 @@ endfunction
 %!          0.0 ];
 %! e_exp = [1.5707963267948966192;
 %!          1.5668619420216682912;
 %!          1.5307576368977632025;
 %!          1.3506438810476755025;
 %!          1.1047747327040733261;
 %!          1.0159935450252239356;
 %!          1.0 ];
-%! if k(7)==Inf, k(7)=0; endif;
+%! if (k(7)==Inf), k(7)=0; endif;
 %! assert (k, k_exp, 8*eps);
 %! assert (e, e_exp, 8*eps);
 
 %% Test against A&S Table 17.1
 %!test
 %! m = [0:5:50]'/100;
 %! k_exp = [1.570796326794897;
 %!          1.591003453790792;
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -1310,17 +1310,17 @@ function A = invhess (x, y)
     y = -x(1:end-1);
   elseif (! isvector (y) || numel (y) != numel (x) -1)
     error ("gallery: Y must be a vector of length -1 than X for invhess matrix.");
   endif
 
   x = x(:);
   y = y(:);
 
-  ##  On next line, z = x'; A = z(ones(n,1),:) would be more efficient.
+  ##  FIXME: On next line, z = x'; A = z(ones(n,1),:) would be more efficient.
   A = ones (n, 1) * x';
   for j = 2:n
     A(1:j-1,j) = y(1:j-1);
   endfor
 endfunction
 
 function A = invol (n)
   ## INVOL   An involutory matrix.
@@ -1498,26 +1498,26 @@ function A = kms (n, rho = 0.5)
   ##        Reference:
   ##        W.F. Trench, Numerical solution of the eigenvalue problem
   ##        for Hermitian Toeplitz matrices, SIAM J. Matrix Analysis and Appl.,
   ##        10 (1989), pp. 135-146 (and see the references therein).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for lauchli matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
-    error("gallery: N must be an integer for lauchli matrix.")
+    error ("gallery: N must be an integer for lauchli matrix.")
   elseif (! isscalar (mu))
-    error("gallery: MU must be a scalar for lauchli matrix.")
+    error ("gallery: MU must be a scalar for lauchli matrix.")
   endif
 
-  A = (1:n)'*ones(1,n);
-  A = abs(A - A');
+  A = (1:n)'*ones (1,n);
+  A = abs (A - A');
   A = rho .^ A;
-  if imag(rho)
-    A = conj(tril(A,-1)) + triu(A);
+  if (imag (rho))
+    A = conj (tril (A,-1)) + triu (A);
   endif
 endfunction
 
 function B = krylov (A, x, j)
   ## KRYLOV    Krylov matrix.
   ##           KRYLOV(A, x, j) is the Krylov matrix
   ##                [x, Ax, A^2x, ..., A^(j-1)x],
   ##           where A is an n-by-n matrix and x is an n-vector.
@@ -1923,17 +1923,17 @@ function A = prolate (n, w = 0.25)
   elseif (! isnumeric (w) || ! isscalar (w))
     error ("gallery: W must be a scalar for prolate matrix.");
   endif
 
   a      = zeros (n, 1);
   a(1)   = 2*w;
   a(2:n) = sin (2*pi*w*(1:n-1)) ./ (pi*(1:n-1));
 
-  A = toeplitz(a);
+  A = toeplitz (a);
 endfunction
 
 function H = randhess (x)
   ## NOTE: this function was named ohess in the original Test Matrix Toolbox
   ## RANDHESS  Random, orthogonal upper Hessenberg matrix.
   ##        H = RANDHESS(N) is an N-by-N real, random, orthogonal
   ##        upper Hessenberg matrix.
   ##        Alternatively, H = RANDHESS(X), where X is an arbitrary real
@@ -2247,18 +2247,18 @@ function A = smoke (n, k = 0)
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n))
     error ("gallery: K must be a numeric scalar for smoke matrix.");
   endif
 
-  w = exp(2*pi*i/n);
-  A = diag( [w.^(1:n-1) 1] ) + diag(ones(n-1,1),1);
+  w = exp (2*pi*i/n);
+  A = diag ( [w.^(1:n-1) 1] ) + diag (ones (n-1,1), 1);
 
   switch (k)
     case (0), A(n,1) = 1;
     case (1), # do nothing
     otherwise,
       error ("gallery: K must have a value of 0 or 1 for smoke matrix.");
   endswitch
 endfunction
diff --git a/scripts/ui/errordlg.m b/scripts/ui/errordlg.m
--- a/scripts/ui/errordlg.m
+++ b/scripts/ui/errordlg.m
@@ -35,15 +35,16 @@ function retval = errordlg (msg, title =
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("errdlg", msg, title, "error");
 
 endfunction
 
-%!demo
-%!  disp('- test errordlg with prompt only.');
-%!  errordlg('Oops, an expected error occured');
 
 %!demo
-%!  disp('- test errordlg with prompt and caption.');
-%!  errordlg('Oops another error','This is a very long and informative caption');
+%! disp ('- test errordlg with prompt only.');
+%! errordlg ('Oops, an expected error occured');
+
+%!demo
+%! disp ('- test errordlg with prompt and caption.');
+%! errordlg ('Oops another error','This is a very long and informative caption');
diff --git a/scripts/ui/helpdlg.m b/scripts/ui/helpdlg.m
--- a/scripts/ui/helpdlg.m
+++ b/scripts/ui/helpdlg.m
@@ -35,15 +35,17 @@ function retval = helpdlg (msg, title = 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("helpdlg", msg, title, "help");
 
 endfunction
 
-%!demo
-%!  disp('- test helpdlg with a help message only.');
-%!  helpdlg("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
 
 %!demo
-%!  disp('- test helpdlg with help message and caption.');
-%!  helpdlg('You should see a single line.','A help dialog');
+%! disp ('- test helpdlg with a help message only.');
+%! helpdlg ("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
+
+%!demo
+%! disp ('- test helpdlg with help message and caption.');
+%! helpdlg ('You should see a single line.','A help dialog');
+
diff --git a/scripts/ui/inputdlg.m b/scripts/ui/inputdlg.m
--- a/scripts/ui/inputdlg.m
+++ b/scripts/ui/inputdlg.m
@@ -137,69 +137,71 @@ function cstr = inputdlg (prompt, title 
       cstr = cellstr (user_inputs);
     endif
   else
     error ("inputdlg is not available in this version of Octave");
   endif
 
 endfunction
 
-%!demo
-%!  disp('- test inputdlg with prompt and caption only.');
-%!  prompt = {'Width','Height','Depth'};
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions' );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
 
 %!demo
-%!  disp('- test inputdlg with prescribed scalar (2 lines per text field) and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.1','2.2','3.3'};
-%!  rc = 2;
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prompt and caption only.');
+%! prompt = {'Width','Height','Depth'};
+%! dims = inputdlg (prompt, 'Enter Box Dimensions');
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
+
+%!demo
+%! disp ('- test inputdlg with prescribed scalar (2 lines per text field) and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.1','2.2','3.3'};
+%! rc = 2;
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!    helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
 
 %!demo
-%!  disp('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.10', '2.10', '3.10'};
-%!  rc = [1,2,3];  % NOTE: must be an array
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.10', '2.10', '3.10'};
+%! rc = [1,2,3];  % NOTE: must be an array
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
 
 %!demo
-%!  disp('- test inputdlg with prescribed row by column sizes and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.10', '2.20', '3.30'};
-%!  rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prescribed row by column sizes and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.10', '2.20', '3.30'};
+%! rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
+
diff --git a/scripts/ui/listdlg.m b/scripts/ui/listdlg.m
--- a/scripts/ui/listdlg.m
+++ b/scripts/ui/listdlg.m
@@ -89,31 +89,31 @@ function [sel, ok] = listdlg (varargin)
   initialvalue = 1;
   name = "";
   prompt = {};
   okstring = "OK";
   cancelstring = "Cancel";
 
   ## handle key, value pairs
   for i = 1:2:nargin-1
-    if strcmp (varargin{i}, "ListString")
+    if (strcmp (varargin{i}, "ListString"))
       listcell = varargin{i+1};
-    elseif strcmp (varargin{i}, "SelectionMode")
+    elseif (strcmp (varargin{i}, "SelectionMode"))
       selmode = varargin{i+1};
-    elseif strcmp (varargin{i}, "ListSize")
+    elseif (strcmp (varargin{i}, "ListSize"))
       listsize = varargin{i+1};
-    elseif strcmp (varargin{i}, "InitialValue")
+    elseif (strcmp (varargin{i}, "InitialValue"))
       initialvalue = varargin{i+1};
-    elseif strcmp (varargin{i}, "Name")
+    elseif (strcmp (varargin{i}, "Name"))
       name = varargin{i+1};
-    elseif strcmp (varargin{i}, "PromptString")
+    elseif (strcmp (varargin{i}, "PromptString"))
       prompt = varargin{i+1};
-    elseif strcmp (varargin{i}, "OKString")
+    elseif (strcmp (varargin{i}, "OKString"))
       okstring = varargin{i+1};
-    elseif strcmp (varargin{i}, "CancelString")
+    elseif (strcmp (varargin{i}, "CancelString"))
       cancelstring = varargin{i+1};
     endif
   endfor
 
   ## make sure prompt strings are a cell array
   if (! iscell (prompt))
     prompt = {prompt};
   endif
@@ -132,17 +132,17 @@ function [sel, ok] = listdlg (varargin)
     [sel, ok] = __octave_link_list_dialog__ (listcell, selmode, listsize,
                                             initialvalue, name, prompt,
                                             okstring, cancelstring);
   elseif (__have_feature__ ("JAVA"))
     ## transform matrices to cell arrays of strings
     ## swap width and height to correct calling format for JDialogBox
     listsize = {num2str(listsize(2)), num2str(listsize(1))};
     initialvalue = arrayfun (@num2str, initialvalue, "UniformOutput", false);
-    if isempty(prompt)
+    if (isempty (prompt))
       prompt = {""};
     endif
 
     ret = javaMethod ("listdlg", "org.octave.JDialogBox", listcell,
                       selmode, listsize, initialvalue, name, prompt,
                       okstring, cancelstring);
 
     if (numel (ret) > 0)
@@ -153,40 +153,42 @@ function [sel, ok] = listdlg (varargin)
       ok = 0;
     endif
   else
     error ("listdlg is not available in this version of Octave");
   endif
 
 endfunction
 
+
 %!demo
-%!  disp('- test listdlg with selectionmode single. No caption, no prompt.');
-%!  itemlist = {'An item \\alpha', 'another', 'yet another'};
-%!  s = listdlg ( 'ListString',itemlist, 'SelectionMode','Single' );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with selectionmode single. No caption, no prompt.');
+%! itemlist = {'An item \\alpha', 'another', 'yet another'};
+%! s = listdlg ('ListString',itemlist, 'SelectionMode','Single');
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
 
 %!demo
-%!  disp('- test listdlg with selectionmode and preselection. Has caption and two lines prompt.');
-%!  itemlist = {'An item \\alpha', 'another', 'yet another'};
-%!  s = listdlg ( 'ListString',itemlist, ...
-%!                'SelectionMode','Multiple', ...
-%!                'Name','Selection Dialog', ...
-%!                'InitialValue',[1,2,3,4],
-%!                'PromptString',{'Select <b>an</b> item...', '...or <b>multiple</b> items'} );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with selectionmode and preselection. Has caption and two lines prompt.');
+%! itemlist = {'An item \\alpha', 'another', 'yet another'};
+%! s = listdlg ('ListString',itemlist, ...
+%!              'SelectionMode','Multiple', ...
+%!              'Name','Selection Dialog', ...
+%!              'InitialValue',[1,2,3,4],
+%!              'PromptString',{'Select <b>an</b> item...', '...or <b>multiple</b> items'} );
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
 
 %!demo
-%!  disp('- test listdlg with listsize.');
-%!  itemlist = {"Neutron","Electron","Quark","Proton","Neutrino"};
-%!  s = listdlg ( "ListString",itemlist,
-%!                "Name","Bits and Pieces",
-%!                "ListSize",[200 75] );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with listsize.');
+%! itemlist = {"Neutron","Electron","Quark","Proton","Neutrino"};
+%! s = listdlg ("ListString",itemlist,
+%!              "Name","Bits and Pieces",
+%!              "ListSize",[200 75] );
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
+
diff --git a/scripts/ui/questdlg.m b/scripts/ui/questdlg.m
--- a/scripts/ui/questdlg.m
+++ b/scripts/ui/questdlg.m
@@ -115,60 +115,61 @@ function btn = questdlg (msg, title = "Q
     btn = javaMethod ("questdlg", "org.octave.JDialogBox", msg,
                       title, options);
   else
     error ("questdlg is not available in this version of Octave");
   endif
 
 endfunction
 
+
 %!demo
-%!  disp('- test questdlg with two buttons');
-%!  a = questdlg('Would you like some free money?',...
+%! disp ('- test questdlg with two buttons');
+%! a = questdlg ('Would you like some free money?',...
 %!               '$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $',...
 %!               'No', 'Cancel', 'Cancel');
-%!  if strcmp (a, 'No')
-%!    msgbox('Suit yourself.', 'Message Box');
-%!  endif
+%! if (strcmp (a, 'No'))
+%!   msgbox ('Suit yourself.', 'Message Box');
+%! endif
 
 %!demo
-%!  disp('- test questdlg with message and title only.');
-%!  a = 'No';
-%!  c = 0;
-%!  while (strcmp(a, 'No') || !c)
-%!    a = questdlg('Close this Question Dialog?', 'Reductio Ad Absurdum');
-%!    if strcmp(a, 'Yes')
-%!      q = 'Are you sure?';
-%!      while (strcmp(a, 'Yes') && !c)
-%!        a = questdlg(q, 'Reductio Ad Absurdum');
-%!        word = ' really';
-%!        i = strfind(q, word);
-%!        if isempty( i )
-%!          i = strfind(q, ' sure');
-%!          q = [q '!'];
-%!        else
-%!          word = [word ','];
-%!        endif
-%!        q = [q(1:i-1) word q(i:end)];
-%!      endwhile
-%!    endif
-%!    if strcmp(a, 'Cancel')
-%!      warndlg('Answer "Yes" or "No".', 'Warning Dialog');
-%!      a = 'No';
-%!      c = 1;
-%!    endif
-%!  endwhile
-%!  msgbox('Whew!');
+%! disp ('- test questdlg with message and title only.');
+%! a = 'No';
+%! c = 0;
+%! while (strcmp (a, 'No') || !c)
+%!   a = questdlg ('Close this Question Dialog?', 'Reductio Ad Absurdum');
+%!   if (strcmp (a, 'Yes'))
+%!     q = 'Are you sure?';
+%!     while (strcmp (a, 'Yes') && !c)
+%!       a = questdlg (q, 'Reductio Ad Absurdum');
+%!       word = ' really';
+%!       i = strfind (q, word);
+%!       if (isempty (i))
+%!         i = strfind (q, ' sure');
+%!         q = [q '!'];
+%!       else
+%!         word = [word ','];
+%!       endif
+%!       q = [q(1:i-1) word q(i:end)];
+%!     endwhile
+%!   endif
+%!   if (strcmp (a, 'Cancel'))
+%!     warndlg ('Answer "Yes" or "No".', 'Warning Dialog');
+%!     a = 'No';
+%!     c = 1;
+%!   endif
+%! endwhile
+%! msgbox ('Whew!');
 
 %!demo
-%!  disp('- test questdlg with five inputs');
-%!  ans = questdlg('Are you ready Steve?', 'Brian', 'No', 'Uh huh', 'Uh huh');
-%!  if !strcmp (ans, 'No')
-%!    ans = questdlg ('Andy?', 'Brian', 'No', 'Yeah', 'Yeah');
-%!    if !strcmp (ans, 'No')
-%!      ans = questdlg ('Mick?', 'Brian', 'No', 'Okay', 'Okay');
-%!      if !strcmp (ans, 'No')
-%!        ans = msgbox ("Well all right, fellas.    \n\n     Let''s GO!!!!!",...
-%!                      'Ballroom Blitz', 'none');
-%!      endif
-%!    endif
-%!  endif
+%! disp ('- test questdlg with five inputs');
+%! ans = questdlg ('Are you ready Steve?', 'Brian', 'No', 'Uh huh', 'Uh huh');
+%! if (! strcmp (ans, 'No'))
+%!   ans = questdlg ('Andy?', 'Brian', 'No', 'Yeah', 'Yeah');
+%!   if (! strcmp (ans, 'No'))
+%!     ans = questdlg ('Mick?', 'Brian', 'No', 'Okay', 'Okay');
+%!     if (! strcmp (ans, 'No'))
+%!       ans = msgbox ("Well all right, fellas.    \n\n     Let''s GO!!!!!",...
+%!                     'Ballroom Blitz', 'none');
+%!     endif
+%!   endif
+%! endif
 
diff --git a/scripts/ui/warndlg.m b/scripts/ui/warndlg.m
--- a/scripts/ui/warndlg.m
+++ b/scripts/ui/warndlg.m
@@ -34,15 +34,17 @@ function retval = warndlg (msg, title = 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("warndlg", msg, title, "warn");
 
 endfunction
 
-%!demo
-%!  disp('- test warndlg with prompt only.');
-%!  warndlg('Oh, a warning occured');
 
 %!demo
-%!  disp('- test warndlg with prompt and caption.');
-%!  warndlg('Oh, No...','This is the last Warning');
+%! disp ('- test warndlg with prompt only.');
+%! warndlg ('Oh, a warning occured');
+
+%!demo
+%! disp ('- test warndlg with prompt and caption.');
+%! warndlg ('Oh, No...','This is the last Warning');
+
