# HG changeset patch
# User jwe
# Date 865633127 0
#      Fri Jun 06 21:38:47 1997 +0000
# Node ID e70400e133d0ebce98001edbf3d6ec16b585f75f
# Parent  4b12b66ec09f0b6b05742cdc8e5d5f9aa4dd3fb0
[project @ 1997-06-06 21:33:29 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,13 @@
 Fri Jun  6 04:27:40 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* FSQP.h, NPSOL.h, QPSOL.h, FSQP.cc, NPSOL.cc, QPSOL.cc: Delete
+	* Makefile.in (INCLUDES, SOURCES): Remove them from the lists.
+
 	* file-ops.cc (file_ops::tilde_expand): Steal more code from bash
 	to do better job expanding tildes.
 
 	* str-vec.cc (string_vector::string_vector (const char * const *):
 	Use temporary variable to compute length.
 
 Thu Jun  5 01:44:43 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/liboctave/FSQP.cc b/liboctave/FSQP.cc
deleted file mode 100644
--- a/liboctave/FSQP.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if defined (__GNUG__)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#ifndef FSQP_MISSING
-
-#include "FSQP.h"
-#include "f77-fcn.h"
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/FSQP.h b/liboctave/FSQP.h
deleted file mode 100644
--- a/liboctave/FSQP.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if !defined (octave_FSQP_h)
-#define octave_FSQP_h 1
-
-#if defined (__GNUG__)
-#pragma interface
-#endif
-
-#ifndef FSQP_MISSING
-
-#include "NLP.h"
-
-class
-FSQP : public NLP
-{
-};
-
-#endif
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -35,19 +35,19 @@ MATRIX_INC := Array.h Array2.h Array3.h 
 	dbleQRP.h dbleSCHUR.h dbleSVD.h
 
 MX_OP_INC := mx-cdm-cm.h mx-cdm-cs.h mx-cdm-dm.h mx-cdm-m.h \
 	mx-cdm-s.h mx-cm-cdm.h mx-cm-dm.h mx-cm-m.h mx-cm-s.h \
 	mx-cs-cdm.h mx-cs-dm.h mx-cs-m.h mx-dm-cdm.h mx-dm-cm.h \
 	mx-dm-cs.h mx-dm-m.h mx-dm-s.h mx-m-cdm.h mx-m-cm.h \
 	mx-m-cs.h mx-m-dm.h mx-s-cdm.h mx-s-cm.h mx-s-dm.h
 
-INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DASSL.h FEGrid.h FSQP.h \
+INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DASSL.h FEGrid.h \
 	LinConst.h LP.h LPsolve.h LSODE.h NLConst.h NLEqn.h NLFunc.h \
-	NLP.h NPSOL.h ODE.h ODEFunc.h Objective.h QP.h QPSOL.h Quad.h \
+	NLP.h ODE.h ODEFunc.h Objective.h QP.h Quad.h \
 	Range.h base-de.h base-min.h byte-swap.h cmd-edit.h cmd-hist.h \
 	data-conv.h dir-ops.h file-ops.h file-stat.h getopt.h \
 	glob-match.h idx-vector.h lo-ieee.h lo-mappers.h lo-sysdep.h \
 	lo-utils.h mach-info.h oct-alloc.h oct-cmplx.h oct-env.h \
 	oct-math.h oct-group.h oct-passwd.h oct-syscalls.h pathsearch.h \
 	prog-args.h statdefs.h str-vec.h sun-utils.h sysdir.h syswait.h \
 	$(MATRIX_INC) \
 	$(MX_OP_INC)
@@ -69,18 +69,18 @@ MATRIX_SRC := Array-flags.cc CColVector.
 	dbleSVD.cc
 
 MX_OP_SRC := mx-cdm-cm.cc mx-cdm-cs.cc mx-cdm-dm.cc mx-cdm-m.cc \
 	mx-cdm-s.cc mx-cm-cdm.cc mx-cm-dm.cc mx-cm-m.cc mx-cm-s.cc \
 	mx-cs-cdm.cc mx-cs-dm.cc mx-cs-m.cc mx-dm-cdm.cc mx-dm-cm.cc \
 	mx-dm-cs.cc mx-dm-m.cc mx-dm-s.cc mx-m-cdm.cc mx-m-cm.cc \
 	mx-m-cs.cc mx-m-dm.cc mx-s-cdm.cc mx-s-cm.cc mx-s-dm.cc
 
-SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc FSQP.cc \
-	LinConst.cc LPsolve.cc LSODE.cc NLEqn.cc NPSOL.cc QPSOL.cc \
+SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc \
+	LinConst.cc LPsolve.cc LSODE.cc NLEqn.cc \
 	Quad.cc Range.cc acosh.c asinh.c atanh.c cmd-edit.cc \
 	cmd-hist.cc data-conv.cc dir-ops.cc erf.c erfc.c f2c-main.c \
 	file-ops.cc file-stat.cc filemode.c gamma.c getopt.c getopt1.c \
 	glob-match.cc idx-vector.cc lgamma.c lo-ieee.cc lo-mappers.cc \
 	lo-sysdep.cc lo-utils.cc mach-info.cc mkdir.c oct-alloc.cc \
 	oct-env.cc oct-group.cc oct-passwd.cc oct-syscalls.cc \
 	pathsearch.cc prog-args.cc rename.c rmdir.c str-vec.cc \
 	tempname.c tempnam.c \
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
deleted file mode 100644
--- a/liboctave/NPSOL.cc
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if defined (__GNUG__)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <cfloat>
-#include <cmath>
-#include <cstring>
-
-#include <strstream.h>
-
-#ifndef NPSOL_MISSING
-
-#include "NPSOL.h"
-#include "dMatrix.h"
-#include "f77-fcn.h"
-#include "sun-utils.h"
-
-extern "C"
-{
-  int F77_FCN (npoptn, NPOPTN) (const char*, long);
-
-  int F77_FCN (npsol, NPSOL) (int&, int&, int&, int&, int&, int&,
-			      double*, double*, double*,
-			      int (*)(int&, const int&, const int&,
-				      const int&, int*, double*,
-				      double*, double*, int*),
-			      int (*)(int&, const int&, double*,
-				      double*, double*, int*),
-			      int&, int&, int*, double*, double*,
-			      double*, double&, double*, double*,
-			      double*, int*, int&, double*, int&);
-}
-
-// XXX FIXME XXX -- would be nice to not have to have this global
-// variable.
-// Nonzero means an error occurred in the calculation of the objective
-// function, and the user wants us to quit.
-int npsol_objective_error = 0;
-
-static Objective::objective_fcn user_phi;
-static Objective::gradient_fcn user_grad;
-static NLFunc::nonlinear_fcn user_g;
-static NLFunc::jacobian_fcn user_jac;
-
-int
-npsol_objfun (int& mode, const int& n, double *xx, double *objf,
-	      double *objgrd, int *)
-{
-  ColumnVector tmp_x (n);
-
-  npsol_objective_error = 0;
-
-  for (int i = 0; i < n; i++)
-    tmp_x.elem (i) = xx[i];
-
-  if (mode == 0 || mode == 2)
-    {
-      double value = (*user_phi) (tmp_x);
-
-      if (npsol_objective_error)
-	{
-	  mode = -1;
-	  return 0;
-	}
-
-#if defined (sun) && defined (__GNUC__)
-      assign_double (objf, value);
-#else
-      *objf = value;
-#endif
-    }
-
-  if ((mode == 1 || mode == 2) && user_grad)
-    {
-      ColumnVector tmp_grad (n);
-
-      tmp_grad = (*user_grad) (tmp_x);
-
-      if (tmp_grad.length () == 0)
-	mode = -1;
-      else
-	{
-	  for (int i = 0; i < n; i++)
-	    objgrd[i] = tmp_grad.elem (i);
-	}
-    }
-
-  return 0;
-}
-
-int
-npsol_confun (int& mode, const int& ncnln, const int& n,
-	      const int& nrowj, int *, double *xx, double *cons,
-	      double *cjac, int *)
-{
-  ColumnVector tmp_x (n);
-  ColumnVector tmp_c (ncnln);
-
-  for (int i = 0; i < n; i++)
-    tmp_x.elem (i) = xx[i];
-
-  tmp_c = (*user_g) (tmp_x);
-
-  if (tmp_c.length () == 0)
-    {
-      mode = -1;
-      return 0;
-    }
-  else
-    {
-      for (int i = 0; i < ncnln; i++)
-	cons[i] = tmp_c.elem (i);
-    }
-
-  if (user_jac)
-    {
-      Matrix tmp_jac (ncnln, n);
-
-      tmp_jac = (*user_jac) (tmp_x);
-
-      if (tmp_jac.rows () == 0 || tmp_jac.columns () == 0)
-	mode = -1;
-      else
-	{
-	  int ld = nrowj;
-	  for (int j = 0; j < n; j++)
-	    for (int i = 0; i < ncnln; i++)
-	      cjac[i+j*ld] = tmp_jac (i, j);
-	}
-    }
-
-  return 0;
-}
-
-ColumnVector
-NPSOL::do_minimize (double& objf, int& inform, ColumnVector& lambda)
-{
-  // Dimensions of various things.
-
-  int n     = x.capacity ();
-  int nclin = lc.size ();
-  int ncnln = nlc.size ();
-  int nrowa = 1 > nclin ? 1 : nclin;
-  int nrowj = 1 > ncnln ? 1 : ncnln;
-  int nrowr = n;
-
-  // Informative stuff.
-
-  int iter;
-
-  Array<int> aistate (n+nclin+ncnln);
-  int *istate = aistate.fortran_vec ();
-
-  // User defined function stuff is defined above in the functions
-  // npsol_confun() and npsol_objfun();
-
-  // Constraint stuff.
-
-  double bigbnd = infinite_bound ();
-
-  Matrix clin = lc.constraint_matrix ();
-  double *pclin = clin.fortran_vec ();
-
-  ColumnVector aclow (n+nclin+ncnln);
-  ColumnVector acup (n+nclin+ncnln);
-
-  if (bnds.size () > 0)
-    {
-      aclow.insert (bnds.lower_bounds (), 0);
-      acup.insert (bnds.upper_bounds (), 0);
-    }
-  else
-    {
-      aclow.fill (-bigbnd, 0, n-1);
-      acup.fill (bigbnd, 0, n-1);
-    }
-
-  if (nclin > 0)
-    {
-      aclow.insert (lc.lower_bounds (), n);
-      acup.insert (lc.upper_bounds (), n);
-    }
-
-  if (ncnln > 0)
-    {
-      aclow.insert (nlc.lower_bounds (), n+nclin);
-      acup.insert (nlc.upper_bounds (), n+nclin);
-    }
-
-  double *clow = aclow.fortran_vec ();
-  double *cup = acup.fortran_vec ();
-
-  Array<double> ac (ncnln);
-  double *c = ac.fortran_vec ();
-
-  Array<double> acjac (nrowj*n);
-  double *cjac = acjac.fortran_vec ();
-
-  // Objective stuff.
-
-  Array<double> aobjgrd (n);
-  double *objgrd = aobjgrd.fortran_vec ();
-
-  // Other stuff.
-
-  Array<double> ar (n*n);
-  double *r = ar.fortran_vec ();
-
-  lambda.resize (n+nclin+ncnln);
-  double *pclambda = lambda.fortran_vec ();
-
-  // Decision variable stuff.
-
-  double *px = x.fortran_vec ();
-
-  // Workspace parameters.
-
-  int lenw;
-  int leniw = 3 * n + nclin + 2 * ncnln;
-  if (nclin == 0 && ncnln == 0)
-    lenw = 20*n;
-  else if (ncnln == 0)
-    lenw = 2*n*(10 + n) + 11*nclin;
-  else
-    lenw = 2*n*(n + 10) + nclin*(n + 11) + ncnln*(2*n + 21);
-
-  Array<int> aiw (leniw);
-  int *iw = aiw.fortran_vec ();
-
-  Array<double> aw (lenw);
-  double *w = aw.fortran_vec ();
-
-  user_phi  = phi.objective_function ();
-  user_grad = phi.gradient_function ();
-  user_g    = nlc.function ();
-  user_jac  = nlc.jacobian_function ();
-
-  pass_options_to_npsol ();
-
-  if (! user_jac && ! user_grad)
-    F77_FCN (npoptn, NPOPTN) ("Derivative Level 0", 18L);
-  else if (! user_jac && user_grad)
-    F77_FCN (npoptn, NPOPTN) ("Derivative Level 1", 18L);
-  else if (user_jac && ! user_grad)
-    F77_FCN (npoptn, NPOPTN) ("Derivative Level 2", 18L);
-  else if (user_jac && user_grad)
-    F77_FCN (npoptn, NPOPTN) ("Derivative Level 3", 18L);
-
-  attempt = 0;
-  while (attempt++ < 5)
-    {
-
-      F77_XFCN (npsol, NPSOL,
-		(n, nclin, ncnln, nrowa, nrowj, nrowr, pclin, clow,
-		 cup, npsol_confun, npsol_objfun, inform, iter,
-		 istate, c, cjac, pclambda, objf, objgrd, r, px, iw,
-		 leniw, w, lenw));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in npsol");
-      else if (inform == 6 || inform == 1)
-	continue;
-      else
-	break;
-    }
-
-  return x;
-}
-
-void
-NPSOL_options::init (void)
-{
-  x_central_difference_interval = -1.0;
-  x_crash_tolerance = 0.1;
-  x_difference_interval = -1.0;
-  x_function_precision = pow (DBL_EPSILON, 0.9);
-  x_infinite_bound = 1.0e+30;
-  x_infinite_step = 1.0e+30;
-  x_linear_feasibility_tolerance = sqrt (DBL_EPSILON);
-  x_linesearch_tolerance = 0.9;
-  x_nonlinear_feasibility_tolerance = sqrt (DBL_EPSILON);
-  x_optimality_tolerance = pow (DBL_EPSILON, 0.8);
-  x_derivative_level = 0;
-  x_major_iteration_limit = -1;
-  x_minor_iteration_limit = -1;
-  x_major_print_level = 0;
-  x_minor_print_level = 0;
-  x_start_objective_check = 1;
-  x_start_constraint_check = 1;
-  x_stop_objective_check = -1;
-  x_stop_constraint_check = -1;
-  x_verify_level = 0;
-}
-
-void
-NPSOL_options::set_options (const NPSOL_options& opt)
-{
-  x_central_difference_interval = opt.x_central_difference_interval;
-  x_crash_tolerance = opt.x_crash_tolerance;
-  x_difference_interval = opt.x_difference_interval;
-  x_function_precision = opt.x_function_precision;
-  x_infinite_bound = opt.x_infinite_bound;
-  x_infinite_step = opt.x_infinite_step;
-  x_linear_feasibility_tolerance = opt.x_linear_feasibility_tolerance;
-  x_linesearch_tolerance = opt.x_linesearch_tolerance;
-  x_nonlinear_feasibility_tolerance = opt.x_nonlinear_feasibility_tolerance;
-  x_optimality_tolerance = opt.x_optimality_tolerance;
-  x_derivative_level = opt.x_derivative_level;
-  x_major_iteration_limit = opt.x_major_iteration_limit;
-  x_minor_iteration_limit = opt.x_minor_iteration_limit;
-  x_major_print_level = opt.x_major_print_level;
-  x_minor_print_level = opt.x_minor_print_level;
-  x_start_objective_check = opt.x_start_objective_check;
-  x_start_constraint_check = opt.x_start_constraint_check;
-  x_stop_objective_check = opt.x_stop_objective_check;
-  x_stop_constraint_check = opt.x_stop_constraint_check;
-  x_verify_level = opt.x_verify_level;
-}
-
-void
-NPSOL_options::pass_options_to_npsol (void)
-{
-  F77_FCN (npoptn, NPOPTN) ("Nolist", 6L);
-  F77_FCN (npoptn, NPOPTN) ("Defaults", 8L);
-
-  if (x_central_difference_interval > 0.0)
-    set_option ("Central Difference", x_central_difference_interval);
-
-  set_option ("Crash Tolerance", x_crash_tolerance);
-
-  if (x_difference_interval > 0.0)
-    set_option ("Difference Interval", x_difference_interval);
-
-  set_option ("Function Precision", x_function_precision);
-
-  set_option ("Infinite Bound", x_infinite_bound);
-
-  set_option ("Infinite Step", x_infinite_step);
-
-  set_option ("Linear Feasibility", x_linear_feasibility_tolerance);
-
-  set_option ("Linesearch Tolerance", x_linesearch_tolerance);
-
-  set_option ("Nonlinear Feasibility", x_nonlinear_feasibility_tolerance);
-
-  set_option ("Optimality Tolerance", x_optimality_tolerance);
-
-  set_option ("Derivative Level", x_derivative_level);
-
-  if (x_major_iteration_limit > 0)
-    set_option ("Major Iteration", x_major_iteration_limit);
-
-  if (x_minor_iteration_limit > 0)
-    set_option ("Minor Iteration", x_minor_iteration_limit);
-
-  set_option ("Major Print", x_major_print_level);
-
-  set_option ("Minor Print", x_minor_print_level);
-
-  set_option ("Start Objective", x_start_objective_check);
-
-  set_option ("Start Constraint", x_start_constraint_check);
-
-  if (x_stop_objective_check > 0)
-    set_option ("Stop Objective", x_stop_objective_check);
-
-  if (x_stop_constraint_check > 0)
-    set_option ("Stop Constraint", x_stop_constraint_check);
-
-  set_option ("Verify Level", x_verify_level);
-}
-
-void
-NPSOL_options::set_option (const string& key, int opt)
-{
-  ostrstream buf;
-  buf << key << " " << opt << ends;
-  char *command = buf.str ();
-  size_t len = strlen (command);
-  F77_FCN (npoptn, NPOPTN) (command, (long) len);
-  delete [] command;
-}
-
-void
-NPSOL_options::set_option (const string& key, double opt)
-{
-  ostrstream buf;
-  buf << key << " " << opt << ends;
-  char *command = buf.str ();
-  size_t len = strlen (command);
-  F77_FCN (npoptn, NPOPTN) (command, (long) len);
-  delete [] command;
-}
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/NPSOL.h b/liboctave/NPSOL.h
deleted file mode 100644
--- a/liboctave/NPSOL.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if !defined (octave_NPSOL_h)
-#define octave_NPSOL_h 1
-
-#if defined (__GNUG__)
-#pragma interface
-#endif
-
-#ifndef NPSOL_MISSING
-
-#include <cfloat>
-#include <cmath>
-
-#include <string>
-
-#include "dColVector.h"
-#include "NLP.h"
-
-class
-NPSOL_options
-{
-public:
-
-  NPSOL_options (void) { init (); }
-
-  NPSOL_options (const NPSOL_options& opt) { set_options (opt); }
-
-  NPSOL_options& operator = (const NPSOL_options& opt)
-    {
-      if (this != &opt)
-	set_options (opt);
-
-      return *this;
-    }
-
-  ~NPSOL_options (void) { }
-
-  void init (void);
-
-  void set_default_options (void) { init (); }
-
-  void set_options (const NPSOL_options& opt);
-
-// XXX FIXME XXX -- is this a good idea?
-
-// Passing invalid values to the set_* functions will result in
-// setting the default option.
-
-  void set_central_difference_interval (double val)
-    { x_central_difference_interval = (val > 0.0) ? val : -1.0; }
-
-  void set_crash_tolerance (double val)
-    { x_crash_tolerance = (val >= 0.0) ? val : 0.1; }
-
-  void set_difference_interval (double val)
-    { x_difference_interval = (val > 0.0) ? val : -1.0; }
-
-  void set_function_precision (double val)
-    { x_function_precision = (val > 0.0) ? val : ::pow (DBL_EPSILON, 0.9); }
-
-  void set_infinite_bound (double val)
-    { x_infinite_bound = (val > 0.0) ? val : 1.0e+30; }
-
-  void set_infinite_step (double val)
-    { x_infinite_step = (val > 0.0) ? val : 1.0e+30; }
-
-  void set_linear_feasibility_tolerance (double val)
-    {
-      x_linear_feasibility_tolerance
-	= (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
-    }
-
-  void set_linesearch_tolerance (double val)
-    { x_linesearch_tolerance = (val >= 0.0 && val < 1.0) ? val : 0.9; }
-
-  void set_nonlinear_feasibility_tolerance (double val)
-    {
-      x_nonlinear_feasibility_tolerance
-	= (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
-    }
-
-  void set_optimality_tolerance (double val)
-    { x_optimality_tolerance = (val > 0.0) ? val : ::pow (DBL_EPSILON, 0.8); }
-
-  void set_derivative_level (int val)
-    { x_derivative_level = (val >= 0 && val < 4) ? val : 0; }
-
-  void set_major_iteration_limit (int val)
-    { x_major_iteration_limit = (val > 0) ? val : -1; }
-
-  void set_minor_iteration_limit (int val)
-    { x_minor_iteration_limit = (val > 0) ? val : -1; }
-
-  void set_major_print_level (int val)
-    { x_major_print_level = (val >= 0) ? val : -1; }
-
-  void set_minor_print_level (int val)
-    { x_minor_print_level = (val >= 0) ? val : -1; }
-
-  void set_start_objective_check (int val)
-    { x_start_objective_check = (val >= 0) ? val : -1; }
-
-  void set_start_constraint_check (int val)
-    { x_start_constraint_check = (val >= 0) ? val : -1; }
-
-  void set_stop_objective_check (int val)
-    { x_stop_objective_check = (val >= 0) ? val : -1; }
-
-  void set_stop_constraint_check (int val)
-    { x_stop_constraint_check = (val >= 0) ? val : -1; }
-
-  void set_verify_level (int val)
-    {
-      x_verify_level
-	= ((val > -1 && val < 4) || (val > 9 && val < 14)) ? val : 0;
-    }
-
-  double central_difference_interval (void) const
-    { return x_central_difference_interval; }
-
-  double crash_tolerance (void) const
-    { return x_crash_tolerance; }
-
-  double difference_interval (void) const
-    { return x_difference_interval; }
-
-  double function_precision (void) const
-    { return x_function_precision; }
-
-  double infinite_bound (void) const
-    { return x_infinite_bound; }
-
-  double infinite_step (void) const
-    { return x_infinite_step; }
-
-  double linear_feasibility_tolerance (void) const
-    { return x_linear_feasibility_tolerance; }
-
-  double linesearch_tolerance (void) const
-    { return x_linesearch_tolerance; }
-
-  double nonlinear_feasibility_tolerance (void) const
-    { return x_nonlinear_feasibility_tolerance; }
-
-  double optimality_tolerance (void) const
-    { return x_optimality_tolerance; }
-
-  int derivative_level (void) const
-    { return x_derivative_level; }
-
-  int major_iteration_limit (void) const
-    { return x_major_iteration_limit; }
-
-  int minor_iteration_limit (void) const
-    { return x_minor_iteration_limit; }
-
-  int major_print_level (void) const
-    { return x_major_print_level; }
-
-  int minor_print_level (void) const
-    { return x_minor_print_level; }
-
-  int start_objective_check (void) const
-    { return x_start_objective_check; }
-
-  int start_constraint_check (void) const
-    { return x_start_constraint_check; }
-
-  int stop_objective_check (void) const
-    { return x_stop_objective_check; }
-
-  int stop_constraint_check (void) const
-    { return x_stop_constraint_check; }
-
-  int verify_level (void) const
-    { return x_verify_level; }
-
-protected:
-
-  void pass_options_to_npsol (void);
-
-  void set_option (const string& key, int opt);
-  void set_option (const string& key, double opt);
-
-  void set_option (const char *key, int opt)
-    { set_option (string (key), opt); }
-
-  void set_option (const char *key, double opt)
-    { set_option (string (key), opt); }
-
-private:
-
-  double x_central_difference_interval;
-  double x_crash_tolerance;
-  double x_difference_interval;
-  double x_function_precision;
-  double x_infinite_bound;
-  double x_infinite_step;
-  double x_linear_feasibility_tolerance;
-  double x_linesearch_tolerance;
-  double x_nonlinear_feasibility_tolerance;
-  double x_optimality_tolerance;
-
-  int x_derivative_level;
-  int x_major_iteration_limit;
-  int x_minor_iteration_limit;
-  int x_major_print_level;
-  int x_minor_print_level;
-  int x_start_objective_check;
-  int x_start_constraint_check;
-  int x_stop_objective_check;
-  int x_stop_constraint_check;
-  int x_verify_level;
-};
-
-class
-NPSOL : public NLP, public NPSOL_options
-{
-public:
-
-  NPSOL (void)
-    : NLP (), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi)
-    : NLP (x, phi), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const Bounds& b)
-    : NLP (x, phi, b), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const Bounds& b,
-	 const LinConst& lc)
-    : NLP (x, phi, b, lc), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const Bounds& b,
-	 const LinConst& lc, const NLConst& nlc)
-    : NLP (x, phi, b, lc, nlc), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const LinConst& lc)
-    : NLP (x, phi, lc), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const LinConst& lc,
-	 const NLConst& nlc)
-    : NLP (x, phi, lc, nlc), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi,
-	 const NLConst& nlc)
-    : NLP (x, phi, nlc), NPSOL_options () { }
-
-  NPSOL (const ColumnVector& x, const Objective& phi, const Bounds& b,
-	 const NLConst& nlc)
-    : NLP (x, phi, b, nlc), NPSOL_options () { }
-
-  NPSOL (const NPSOL& a)
-    : NLP (a), NPSOL_options () { }
-
-  NPSOL& operator = (const NPSOL& a)
-    {
-      if (this != &a)
-	{
-	  NLP::operator = (a);
-	  NPSOL_options::operator = (a);
-	}
-      return *this;
-    }
-
-  ~NPSOL (void) { }
-
-  ColumnVector do_minimize (double& objf, int& inform, ColumnVector& lambda);
-
-private:
-
-  int attempt;
-};
-
-// XXX FIXME XXX -- would be nice to not have to have this global
-// variable.
-// Nonzero means an error occurred in the calculation of the objective
-// function, and the user wants us to quit.
-extern int npsol_objective_error;
-
-#endif
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/QPSOL.cc b/liboctave/QPSOL.cc
deleted file mode 100644
--- a/liboctave/QPSOL.cc
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if defined (__GNUG__)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <cfloat>
-#include <cmath>
-
-#ifndef QPSOL_MISSING
-
-#include "QPSOL.h"
-#include "f77-fcn.h"
-
-extern "C"
-{
-  int F77_FCN (qpsol, QPSOL) (int&, int&, int&, int&, int&, int&,
-			      int&, int&, double&, double*, double*,
-			      double*, double*, double*, double*,
-			      int (*)(const int&, const int&,
-				      const int&, const int&, double*,
-				      double*, double*),
-			      int&, int&, int&, int*, double*, int&,
-			      int&, double&, double*, int*, int&,
-			      double*, int&);
-
-  int F77_FCN (dgemv, DGEMV) (const char*, const int&, const int&,
-			      const double&, const double*,
-			      const int&, const double*, const int&,
-			      const double&, double*, const int&,
-			      long);
-}
-
-int
-qphess (const int& n, const int& nrowh, const int&,
-	const int& jthcol, double *hess, double *x, double *hx)
-{
-  if (jthcol > 0)
-    {
-      int hp = (jthcol - 1) * nrowh;
-      for (int i = 0; i < n; i++)
-	hx[i] = hess[hp+i];
-    }
-  else
-    {
-      F77_FCN (dgemv, DGEMV) ("N", n, n, 1.0, hess, n, x, 1, 0.0, hx,
-			      1, 1L);
-    }
-
-  return 0;
-}
-
-ColumnVector
-QPSOL::do_minimize (double& objf, int& inform, ColumnVector& lambda)
-{
-  int n = x.capacity ();
- 
-  int itmax = (iteration_limit () < 0) ? 50 * n : iteration_limit ();
-  int msglvl = print_level ();
-  int nclin = lc.size ();
-  int nctotl = nclin + n;
-
-  double bigbnd = infinite_bound ();
-
-  Matrix clin = lc.constraint_matrix ();
-  double *pa = clin.fortran_vec ();
-
-  ColumnVector bl (n+nclin);
-  ColumnVector bu (n+nclin);
-
-  if (bnds.size () > 0)
-    {
-      bl.insert (bnds.lower_bounds (), 0);
-      bu.insert (bnds.upper_bounds (), 0);
-    }
-  else
-    {
-      bl.fill (-bigbnd, 0, n-1);
-      bu.fill (bigbnd, 0, n-1);
-    }
-
-  if (nclin > 0)
-    {
-      bl.insert (lc.lower_bounds (), n);
-      bu.insert (lc.upper_bounds (), n);
-    }
-
-  double *pbl = bl.fortran_vec ();
-  double *pbu = bu.fortran_vec ();
-
-  double *pc = c.fortran_vec ();
-
-  double tmp = feasibility_tolerance ();
-
-  Array<double> afeatol (nctotl, tmp);
-  double *featol = afeatol.fortran_vec ();
-
-  double *ph = H.fortran_vec ();
-
-  int cold = 1;
-  int lp = 0;
-  int orthog = 1;
-
-  Array<int> aistate (nctotl);
-  int *istate = aistate.fortran_vec ();
-
-  double *px = x.fortran_vec ();
-
-  int iter = 0;
-  lambda.resize (nctotl);
-  double *pclambda = lambda.fortran_vec ();
-
-  int leniw = 2 * n;
-
-  int lenw;
-  int ncon = nclin > 1 ? nclin : 1;
-  if (lp == 0 || nclin >= n)
-    lenw = 2*n*(n + 2) + nclin + 2*ncon;
-  else
-    lenw = 2*ncon*(1 + ncon) + 4*n + nclin;
-
-  Array<int> aiw (leniw);
-  int *iw = aiw.fortran_vec ();
-
-  Array<double> aw (lenw);
-  double *w = aw.fortran_vec ();
-
-  F77_XFCN (qpsol, QPSOL, (itmax, msglvl, n, nclin, nctotl, ncon, n,
-			   n, bigbnd, pa, pbl, pbu, pc, featol, ph,
-			   qphess, cold, lp, orthog, istate, px,
-			   inform, iter, objf, pclambda, iw, leniw, w,
-			   lenw));
-
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in qpsol");
-
-  return x;
-}
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/QPSOL.h b/liboctave/QPSOL.h
deleted file mode 100644
--- a/liboctave/QPSOL.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if !defined (octave_QPSOL_h)
-#define octave_QPSOL_h 1
-
-#if defined (__GNUG__)
-#pragma interface
-#endif
-
-#ifndef QPSOL_MISSING
-
-#include <cfloat>
-#include <cmath>
-
-#include "dMatrix.h"
-#include "dColVector.h"
-#include "QP.h"
-
-class
-QPSOL_options
-{
-public:
-
-  QPSOL_options (void) { init (); }
-
-  QPSOL_options (const QPSOL_options& opt) { set_options (opt); }
-
-  QPSOL_options& operator = (const QPSOL_options& opt)
-    {
-      if (this != &opt)
-	set_options (opt);
-
-      return *this;
-    }
-
-  ~QPSOL_options (void) { }
-
-  void init (void)
-    {
-      x_feasibility_tolerance = ::sqrt (DBL_EPSILON);
-      x_infinite_bound = 1.0e+30;
-      x_iteration_limit = -1;
-      x_print_level = 0;
-    }
-
-  void set_default_options (void) { init (); }
-
-  void set_options (const QPSOL_options& opt)
-    {
-      x_feasibility_tolerance = opt.x_feasibility_tolerance;
-      x_infinite_bound = opt.x_infinite_bound;
-      x_iteration_limit = opt.x_iteration_limit;
-      x_print_level = opt.x_print_level;
-    }
-
-  void set_feasibility_tolerance (double val)
-    { x_feasibility_tolerance = (val > 0.0) ? val : ::sqrt (DBL_EPSILON); }
-
-  void set_infinite_bound (double val)
-    { x_infinite_bound = (val > 0.0) ? val : 1.0e+30; }
-
-  void set_iteration_limit (int val)
-    { x_iteration_limit = (val > 0) ? val : -1; }
-
-  void set_print_level (int val)
-    { x_print_level = (val >= 0) ? val : 0; }
-
-  double feasibility_tolerance (void) { return x_feasibility_tolerance; }
-
-  double infinite_bound (void) { return x_infinite_bound; }
-
-  int iteration_limit (void) { return x_iteration_limit; }
-
-  int print_level (void) { return x_print_level; }
-
-private:
-
-  double x_feasibility_tolerance;
-  double x_infinite_bound;
-  int x_iteration_limit;
-  int x_print_level;
-};
-
-class
-QPSOL : public QP, public QPSOL_options
-{
-public:
-
-  QPSOL (void)
-    : QP (), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H)
-    : QP (x, H), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const ColumnVector& c)
-    : QP (x, H, c), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const Bounds& b)
-    : QP (x, H, b), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const LinConst& lc)
-    : QP (x, H, lc), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const ColumnVector& c,
-	 const Bounds& b)
-    : QP (x, H, c, b), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const ColumnVector& c,
-	 const LinConst& lc)
-    : QP (x, H, c, lc), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const Bounds& b,
-	 const LinConst& lc)
-    : QP (x, H, b, lc), QPSOL_options () { }
-
-  QPSOL (const ColumnVector& x, const Matrix& H, const ColumnVector& c,
-	 const Bounds& b, const LinConst& lc)
-    : QP (x, H, c, b, lc), QPSOL_options () { }
-
-  QPSOL (const QPSOL& a)
-    : QP (a), QPSOL_options (a) { }
-
-  QPSOL& operator = (const QPSOL& a)
-    {
-      QP::operator = (a);
-      QPSOL_options::operator = (a);
-      return *this;
-    }
-
-  ColumnVector do_minimize (double& objf, int& inform, ColumnVector& lambda);
-};
-
-#endif
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,14 @@
 Fri Jun  6 04:30:57 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* DLD-FUNCTIONS/npsol.cc, DLD-FUNCTIONS/qpsol.cc,
+	DLD-FUNCTIONS/fsqp.cc: Delete.
+	* Makefile.in (DLD_XSRC): Remove them from the list.
+
 	* utils.cc (search_path_for_file): New arg, do_tilde_expansion.
 	If TRUE, perform tilde expansion on path before searching.
 	(file_in_path): Call search_path_for_file with do_tilde_expansion
 	set to false, since we've already performed tilde expansion on the
 	load path.
 
 	* defaults.cc (loadpath): Perform tilde expansion here.
 
diff --git a/src/DLD-FUNCTIONS/fsqp.cc b/src/DLD-FUNCTIONS/fsqp.cc
deleted file mode 100644
--- a/src/DLD-FUNCTIONS/fsqp.cc
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "FSQP.h"
-
-#include "defun-dld.h"
-#include "error.h"
-#include "oct-obj.h"
-
-#ifndef FSQP_MISSING
-
-// Global pointers for user defined functions required by fsqp.
-// static tree *fsqp_objective;
-// static tree *fsqp_constraints;
-
-double
-fsqp_objective_function (const ColumnVector&)
-{
-  return 0.0;
-}
-
-ColumnVector
-fsqp_constraint_function (const ColumnVector&)
-{
-  ColumnVector retval;
-  return retval;
-}
-
-#endif
-
-#if defined (FSQP_MISSING)
-DEFUN_DLD (fsqp, , ,
-  "This function requires FSQP, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/fsqp/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (fsqp, , ,
-  "[X, PHI] = fsqp (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
-\n\
-Groups of arguments surrounded in `[]' are optional, but\n\
-must appear in the same relative order shown above.")
-#endif
-{
-/*
-
-Handle all of the following:
-
-  1. fsqp (x, phi)
-  2. fsqp (x, phi, lb, ub)
-  3. fsqp (x, phi, lb, ub, llb, c, lub)
-  4. fsqp (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
-  5. fsqp (x, phi, lb, ub,              nllb, g, nlub)
-  6. fsqp (x, phi,         llb, c, lub, nllb, g, nlub)
-  7. fsqp (x, phi,         llb, c, lub)
-  8. fsqp (x, phi,                      nllb, g, nlub)
-
-*/
-
-  octave_value_list retval;
-
-  error ("fsqp: not implemented yet");
-
-  return retval;
-}
-
-#if defined (FSQP_MISSING)
-DEFUN_DLD (fsqp_options, , ,
-  "This function requires FSQP, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/fsqp/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (fsqp_options, , ,
-  "fsqp_options (KEYWORD, VALUE)\n\
-\n\
-Set or show options for fsqp.  Keywords may be abbreviated\n\
-to the shortest match.")
-#endif
-{
-  octave_value_list retval;
-
-  error ("fsqp_options: not implemented yet");
-
-  return retval;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/DLD-FUNCTIONS/npsol.cc b/src/DLD-FUNCTIONS/npsol.cc
deleted file mode 100644
--- a/src/DLD-FUNCTIONS/npsol.cc
+++ /dev/null
@@ -1,852 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string>
-
-#include <iostream.h>
-
-#include "NPSOL.h"
-#include "lo-mappers.h"
-
-#include "defun-dld.h"
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "ov-fcn.h"
-#include "pager.h"
-#include "utils.h"
-#include "variables.h"
-
-#ifndef NPSOL_MISSING
-
-// Global pointers for user defined functions required by npsol.
-static octave_function *npsol_objective;
-static octave_function *npsol_constraints;
-
-static NPSOL_options npsol_opts;
-
-double
-npsol_objective_function (const ColumnVector& x)
-{
-  int n = x.capacity ();
-
-  octave_value decision_vars;
-  if (n > 1)
-    {
-      Matrix m (n, 1);
-      for (int i = 0; i < n; i++)
-	m (i, 0) = x (i);
-      decision_vars = m;
-    }
-  else
-    {
-      double d = x (0);
-      decision_vars = d;
-    }
-
-  octave_value_list args;
-  args(0) = decision_vars;
-
-  static double retval;
-  retval = 0.0;
-
-  octave_value objective_value;
-  if (npsol_objective)
-    {
-      octave_value_list tmp = npsol_objective->do_index_op (1, args);
-
-      if (error_state)
-	{
-	  error ("npsol: error evaluating objective function");
-	  npsol_objective_error = 1; // XXX FIXME XXX
-	  return retval;
-	}
-
-      if (tmp.length () > 0 && tmp(0).is_defined ())
-	objective_value = tmp(0);
-      else
-	{
-	  error ("npsol: error evaluating objective function");
-	  npsol_objective_error = 1; // XXX FIXME XXX
-	  return retval;
-	}
-    }
-
-  if (objective_value.is_real_matrix ())
-    {
-      Matrix m = objective_value.matrix_value ();
-      if (m.rows () == 1 && m.columns () == 1)
-	retval = m (0, 0);
-      else
-	{
-	  gripe_user_returned_invalid ("npsol_objective");
-	  npsol_objective_error = 1; // XXX FIXME XXX
-	}
-    }
-  else if (objective_value.is_real_scalar ())
-    {
-      retval = objective_value.double_value ();
-    }
-  else
-    {
-      gripe_user_returned_invalid ("npsol_objective");
-      npsol_objective_error = 1; // XXX FIXME XXX
-    }
-
-  return retval;
-}
-
-ColumnVector
-npsol_constraint_function (const ColumnVector& x)
-{
-  ColumnVector retval;
-
-  int n = x.capacity ();
-
-  octave_value decision_vars;
-  if (n > 1)
-    {
-      Matrix m (n, 1);
-      for (int i = 0; i < n; i++)
-	m (i, 0) = x (i);
-      decision_vars = m;
-    }
-  else
-    {
-      double d = x (0);
-      decision_vars = d;
-    }
-
-  octave_value_list args;
-  args(0) = decision_vars;
-
-  if (npsol_constraints)
-    {
-      octave_value_list tmp = npsol_constraints->do_index_op (1, args);
-
-      if (error_state)
-	{
-	  error ("npsol: error evaluating constraints");
-	  return retval;
-	}
-
-      if (tmp.length () > 0 && tmp(0).is_defined ())
-	{
-	  retval = tmp(0).vector_value ();
-
-	  if (error_state || retval.length () <= 0)
-	    error ("npsol: error evaluating constraints");
-	}
-      else
-	error ("npsol: error evaluating constraints");
-    }
-
-  return retval;
-}
-
-static int
-linear_constraints_ok (const ColumnVector& x, const ColumnVector& llb,
-		       const Matrix& c, const ColumnVector& lub,
-		       char *warn_for, int warn)
-{
-  int x_len = x.capacity ();
-  int llb_len = llb.capacity ();
-  int lub_len = lub.capacity ();
-  int c_rows = c.rows ();
-  int c_cols = c.columns ();
-
-  int ok = 1;
-  if (warn)
-    {
-      if (c_rows == 0 || c_cols == 0 || llb_len == 0 || lub_len == 0)
-	{
-	  ok = 0;
-	  error ("%s: linear constraints must have nonzero dimensions",
-		 warn_for);
-	}
-      else if (x_len != c_cols || llb_len != lub_len || llb_len != c_rows)
-	{
-	  ok = 0;
-	  error ("%s: linear constraints have inconsistent dimensions",
-		 warn_for);
-	}
-    }
-
-  return ok;
-}
-
-static int
-nonlinear_constraints_ok (const ColumnVector& x, const ColumnVector& nllb,
-			  NLFunc::nonlinear_fcn g, const ColumnVector& nlub,
-			  char *warn_for, int warn)
-{
-  int nllb_len = nllb.capacity ();
-  int nlub_len = nlub.capacity ();
-  ColumnVector c = (*g) (x);
-  int c_len = c.capacity ();
-
-  int ok = 1;
-  if (warn)
-    {
-      if (nllb_len == 0 || nlub_len == 0 || c_len == 0)
-	{
-	  ok = 0;
-	  error ("%s: nonlinear constraints have nonzero dimensions",
-		 warn_for);
-	}
-      else if (nllb_len != nlub_len || nllb_len != c_len)
-	{
-	  ok = 0;
-	  error ("%s: nonlinear constraints have inconsistent dimensions",
-		 warn_for);
-	}
-    }
-  return ok;
-}
-
-#endif
-
-#if defined (NPSOL_MISSING)
-DEFUN_DLD (npsol, , ,
-  "This function requires NPSOL, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/npsol/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (npsol, args, nargout,
-  "[X, OBJ, INFO, LAMBDA] = npsol (X, PHI [, LB, UB] [, A_LB, A, A_UB]\n\
-                                [, G_LB, G, G_UB])\n\
-\n\
-Groups of arguments surrounded in `[]' are optional, but\n\
-must appear in the same relative order shown above.\n\
-\n\
-The second argument is a string containing the name of the objective\n\
-function to call.  The objective function must be of the form\n\
-\n\
-  y = phi (x)\n\
-\n\
-where x is a vector and y is a scalar.\n\
-\n\
-The argument G is a string containing the name of the function that\n\
-defines the nonlinear constraints.  It must be of the form\n\
-\n\
-  y = g (x)\n\
-\n\
-where x is a vector and y is a vector.")
-#endif
-{
-/*
-
-Handle all of the following:
-
-  1. npsol (x, phi)
-  2. npsol (x, phi, lb, ub)
-  3. npsol (x, phi, lb, ub, llb, c, lub)
-  4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
-  5. npsol (x, phi, lb, ub,              nllb, g, nlub)
-  6. npsol (x, phi,         llb, c, lub, nllb, g, nlub)
-  7. npsol (x, phi,         llb, c, lub)
-  8. npsol (x, phi,                      nllb, g, nlub)
-
-*/
-
-  octave_value_list retval;
-
-#if defined (NPSOL_MISSING)
-
-  // Force a bad value of inform, and empty matrices for x, phi, and
-  // lambda.
-
-  retval.resize (4, Matrix ());
-
-  retval(2) = -1.0;
-
-  print_usage ("npsol");
-
-#else
-
-  int nargin = args.length ();
-
-  if (nargin < 2 || nargin == 3 || nargin == 6 || nargin == 9
-      || nargin > 10 || nargout > 4)
-    {
-      print_usage ("npsol");
-      return retval;
-    }
-
-  ColumnVector x = args(0).vector_value ();
-
-  if (error_state || x.capacity () == 0)
-    {
-      error ("npsol: expecting vector as first argument");
-      return retval;
-    }
-
-  npsol_objective = extract_function
-    (args(1), "npsol", "__npsol_obj__",
-     "function phi = __npsol_obj__ (x) phi = ",
-     "; endfunction");
-
-  if (! npsol_objective)
-    return retval;
-
-  Objective func (npsol_objective_function);
-
-  ColumnVector soln;
-
-  Bounds bounds;
-  if (nargin == 4 || nargin == 7 || nargin == 10)
-    {
-      ColumnVector lb = args(2).vector_value ();
-      ColumnVector ub = args(3).vector_value ();
-
-      int lb_len = lb.capacity ();
-      int ub_len = ub.capacity ();
-
-      if (error_state || lb_len != ub_len || lb_len != x.capacity ())
-	{
-	  error ("npsol: lower and upper bounds and decision variable vector");
-	  error ("must all have the same number of elements");
-	  return retval;
-	}
-
-      bounds.resize (lb_len);
-      bounds.set_lower_bounds (lb);
-      bounds.set_upper_bounds (ub);
-    }
-
-  double objf;
-  ColumnVector lambda;
-  int inform;
-
-  if (nargin == 2)
-    {
-      // 1. npsol (x, phi)
-
-      NPSOL nlp (x, func);
-      nlp.set_options (npsol_opts);
-      soln = nlp.minimize (objf, inform, lambda);
-
-      goto solved;
-    }
-
-  if (nargin == 4)
-    {
-      // 2. npsol (x, phi, lb, ub)
-
-      NPSOL nlp (x, func, bounds);
-      nlp.set_options (npsol_opts);
-      soln = nlp.minimize (objf, inform, lambda);
-
-      goto solved;
-    }
-
-  npsol_constraints = 0;
-  if (nargin == 5 || nargin == 7 || nargin == 8 || nargin == 10)
-    npsol_constraints = extract_function
-      (args(nargin-2), "npsol", "__npsol_constr__",
-       "function y = __npsol_constr__ (x) y = ",
-       "; endfunction");
-
-  if (nargin == 7 || nargin == 5)
-    {
-      if (! npsol_constraints)
-	{
-	  ColumnVector lub = args(nargin-1).vector_value ();
-	  ColumnVector llb = args(nargin-3).vector_value ();
-
-	  if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
-	    {
-	      error ("npsol: bounds for linear constraints must be vectors");
-	      return retval;
-	    }
-
-	  Matrix c = args(nargin-2).matrix_value ();
-
-	  if (error_state)
-	    {
-	      error ("npsol: invalid linear constraint matrix");
-	      return retval;
-	    }
-
-	  if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
-	    return retval;
-
-	  LinConst linear_constraints (llb, c, lub);
-
-	  if (nargin == 5)
-	    {
-	      // 7. npsol (x, phi, llb, c, lub)
-
-	      NPSOL nlp (x, func, linear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  else
-	    {
-	      // 3. npsol (x, phi, lb, ub, llb, c, lub)
-
-	      NPSOL nlp (x, func, bounds, linear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  goto solved;
-	}
-      else
-	{
-	  ColumnVector nlub = args(nargin-1).vector_value ();
-	  ColumnVector nllb = args(nargin-3).vector_value ();
-
-	  if (error_state
-	      || (! nonlinear_constraints_ok
-		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
-	    return retval;
-
-	  NLFunc const_func (npsol_constraint_function);
-	  NLConst nonlinear_constraints (nllb, const_func, nlub);
-
-	  if (nargin == 5)
-	    {
-	      // 8. npsol (x, phi, nllb, g, nlub)
-
-	      NPSOL nlp (x, func, nonlinear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  else
-	    {
-	      // 5. npsol (x, phi, lb, ub, nllb, g, nlub)
-
-	      NPSOL nlp (x, func, bounds, nonlinear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  goto solved;
-	}
-    }
-
-  if (nargin == 8 || nargin == 10)
-    {
-      if (! npsol_constraints)
-	{
-	  // Produce error message.
-
-	  is_valid_function (args(nargin-2), "npsol", 1);
-	}
-      else
-	{
-	  ColumnVector nlub = args(nargin-1).vector_value ();
-	  ColumnVector nllb = args(nargin-3).vector_value ();
-
-	  if (error_state
-	      || (! nonlinear_constraints_ok
-		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
-	    return retval;
-
-	  NLFunc const_func (npsol_constraint_function);
-	  NLConst nonlinear_constraints (nllb, const_func, nlub);
-
-	  ColumnVector lub = args(nargin-4).vector_value ();
-	  ColumnVector llb = args(nargin-6).vector_value ();
-
-	  if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
-	    {
-	      error ("npsol: bounds for linear constraints must be vectors");
-	      return retval;
-	    }
-	      
-	  Matrix c = args(nargin-5).matrix_value ();
-
-	  if (error_state)
-	    {
-	      error ("npsol: invalid linear constraint matrix");
-	      return retval;
-	    }
-
-	  if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
-	    return retval;
-
-	  LinConst linear_constraints (llb, c, lub);
-
-	  if (nargin == 8)
-	    {
-	      // 6. npsol (x, phi, llb, c, lub, nllb, g, nlub)
-
-	      NPSOL nlp (x, func, linear_constraints,
-			 nonlinear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  else
-	    {
-	      // 4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
-
-	      NPSOL nlp (x, func, bounds, linear_constraints,
-			 nonlinear_constraints);
-	      nlp.set_options (npsol_opts);
-	      soln = nlp.minimize (objf, inform, lambda);
-	    }
-	  goto solved;
-	}
-    }
-
-  return retval;
-
- solved:
-
-  retval.resize (nargout ? nargout : 1);
-  retval(0) = soln, 1;
-  if (nargout > 1)
-    retval(1) = objf;
-  if (nargout > 2)
-    retval(2) = static_cast<double> (inform);
-  if (nargout > 3)
-    retval(3) = lambda;
-
-#endif
-
-  return retval;
-}
-
-#ifndef NPSOL_MISSING
-
-typedef void (NPSOL_options::*d_set_opt_mf) (double);
-typedef void (NPSOL_options::*i_set_opt_mf) (int);
-typedef double (NPSOL_options::*d_get_opt_mf) (void);
-typedef int (NPSOL_options::*i_get_opt_mf) (void);
-
-#define MAX_TOKENS 5
-
-struct NPSOL_OPTIONS
-{
-  const char *keyword;
-  const char *kw_tok[MAX_TOKENS + 1];
-  int min_len[MAX_TOKENS + 1];
-  int min_toks_to_match;
-  d_set_opt_mf d_set_fcn;
-  i_set_opt_mf i_set_fcn;
-  d_get_opt_mf d_get_fcn;
-  i_get_opt_mf i_get_fcn;
-};
-
-static NPSOL_OPTIONS npsol_option_table [] =
-{
-  { "central difference interval",
-    { "central", "difference", "interval", 0, 0, 0, },
-    { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_central_difference_interval, 0,
-    NPSOL_options::central_difference_interval, 0, },
-
-  { "crash tolerance",
-    { "crash", "tolerance", 0, 0, 0, 0, },
-    { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_crash_tolerance, 0,
-    NPSOL_options::crash_tolerance, 0, },
-
-  { "derivative level",
-    { "derivative", "level", 0, 0, 0, 0, },
-    { 1, 0, 0, 0, 0, 0, }, 1,
-    0, NPSOL_options::set_derivative_level,
-    0, NPSOL_options::derivative_level, },
-
-  { "difference interval",
-    { "difference", "interval", 0, 0, 0, 0, },
-    { 3, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_difference_interval, 0,
-    NPSOL_options::difference_interval, 0, },
-
-  { "function precision",
-    { "function", "precision", 0, 0, 0, 0, },
-    { 2, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_function_precision, 0,
-    NPSOL_options::function_precision, 0, },
-
-  { "infinite bound size",
-    { "infinite", "bound", "size", 0, 0, 0, },
-    { 1, 1, 0, 0, 0, 0, }, 2,
-    NPSOL_options::set_infinite_bound, 0,
-    NPSOL_options::infinite_bound, 0, },
-
-  { "infinite step size",
-    { "infinite", "step", "size", 0, 0, 0, },
-    { 1, 1, 0, 0, 0, 0, }, 2,
-    NPSOL_options::set_infinite_step, 0,
-    NPSOL_options::infinite_step, 0, },
-
-  { "linear feasibility tolerance",
-    { "linear", "feasibility", "tolerance", 0, 0, 0, },
-    { 5, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_linear_feasibility_tolerance, 0,
-    NPSOL_options::linear_feasibility_tolerance, 0, },
-
-  { "linesearch tolerance",
-    { "linesearch", "tolerance", 0, 0, 0, 0, },
-    { 5, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_linesearch_tolerance, 0,
-    NPSOL_options::linesearch_tolerance, 0, },
-
-  { "major iteration limit",
-    { "major", "iteration", "limit", 0, 0, 0, },
-    { 2, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_major_iteration_limit,
-    0, NPSOL_options::major_iteration_limit, },
-
-  { "minor iteration limit",
-    { "minor", "iteration", "limit", 0, 0, 0, },
-    { 2, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_minor_iteration_limit,
-    0, NPSOL_options::minor_iteration_limit, },
-
-  { "major print level",
-    { "major", "print", "level", 0, 0, 0, },
-    { 2, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_major_print_level,
-    0, NPSOL_options::major_print_level, },
-
-  { "minor print level",
-    { "minor", "print", "level", 0, 0, 0, },
-    { 2, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_minor_print_level,
-    0, NPSOL_options::minor_print_level, },
-
-  { "nonlinear feasibility tolerance",
-    { "nonlinear", "feasibility", "tolerance", 0, 0, },
-    { 1, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_nonlinear_feasibility_tolerance, 0,
-    NPSOL_options::nonlinear_feasibility_tolerance, 0, },
-
-  { "optimality tolerance",
-    { "optimality", "tolerance", 0, 0, 0, 0, },
-    { 1, 0, 0, 0, 0, 0, }, 1,
-    NPSOL_options::set_optimality_tolerance, 0,
-    NPSOL_options::optimality_tolerance, 0, },
-
-  { "start objective check at variable",
-    { "start", "objective", "check", "at", "variable", 0, },
-    { 3, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_start_objective_check,
-    0, NPSOL_options::start_objective_check, },
-
-  { "start constraint check at variable",
-    { "start", "constraint", "check", "at", "variable", 0, },
-    { 3, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_start_constraint_check,
-    0, NPSOL_options::start_constraint_check, },
-
-  { "stop objective check at variable",
-    { "stop", "objective", "check", "at", "variable", 0, },
-    { 3, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_stop_objective_check,
-    0, NPSOL_options::stop_objective_check, },
-
-  { "stop constraint check at variable",
-    { "stop", "constraint", "check", "at", "variable", 0, },
-    { 3, 1, 0, 0, 0, 0, }, 2,
-    0, NPSOL_options::set_stop_constraint_check,
-    0, NPSOL_options::stop_constraint_check, },
-
-  { "verify level",
-    { "verify", "level", 0, 0, 0, 0, },
-    { 1, 0, 0, 0, 0, 0, }, 1,
-    0, NPSOL_options::set_verify_level,
-    0, NPSOL_options::verify_level, },
-
-  { 0,
-    { 0, 0, 0, 0, 0, 0, },
-    { 0, 0, 0, 0, 0, 0, }, 0,
-    0, 0, 0, 0, },
-};
-
-static void
-print_npsol_option_list (ostream& os)
-{
-  print_usage ("npsol_options", 1);
-
-  os << "\n"
-     << "Options for npsol include:\n\n"
-     << "  keyword                                  value\n"
-     << "  -------                                  -----\n\n";
-
-  NPSOL_OPTIONS *list = npsol_option_table;
-
-  const char *keyword;
-  while ((keyword = list->keyword) != 0)
-    {
-      os.form ("  %-40s ", keyword);
-      if (list->d_get_fcn)
-	{
-	  double val = (npsol_opts.*list->d_get_fcn) ();
-	  if (val < 0.0)
-	    os << "computed automatically";
-	  else
-	    os << val;
-	}
-      else
-	{
-	  int val = (npsol_opts.*list->i_get_fcn) ();
-	  if (val < 0)
-	    os << "depends on problem size";
-	  else
-	    os << val;
-	}
-      os << "\n";
-      list++;
-    }
-
-  os << "\n";
-}
-
-static void
-set_npsol_option (const string& keyword, double val)
-{
-  NPSOL_OPTIONS *list = npsol_option_table;
-
-  while (list->keyword != 0)
-    {
-      if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
-				list->min_toks_to_match, MAX_TOKENS))
-	{
-	  if (list->d_set_fcn)
-	    (npsol_opts.*list->d_set_fcn) (val);
-	  else
-	    {
-	      if (xisnan (val))
-		{
-		  error ("npsol_options: %s: expecting integer, found NaN",
-			 keyword.c_str ());
-		}
-	      else
-		(npsol_opts.*list->i_set_fcn) (NINT (val));
-	    }
-	  return;
-	}
-      list++;
-    }
-
-  warning ("npsol_options: no match for `%s'", keyword.c_str ());
-}
-
-static octave_value_list
-show_npsol_option (const string& keyword)
-{
-  octave_value retval;
-
-  NPSOL_OPTIONS *list = npsol_option_table;
-
-  while (list->keyword != 0)
-    {
-      if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
-				list->min_toks_to_match, MAX_TOKENS))
-	{
-	  if (list->d_get_fcn)
-	    {
-	      double val = (npsol_opts.*list->d_get_fcn) ();
-	      if (val < 0.0)
-		retval = "computed automatically";
-	      else
-		retval = val;
-	    }
-	  else
-	    {
-	      int val = (npsol_opts.*list->i_get_fcn) ();
-	      if (val < 0)
-		retval = "depends on problem size";
-	      else
-		retval = static_cast<double> (val);
-	    }
-
-	  return retval;
-	}
-      list++;
-    }
-
-  warning ("npsol_options: no match for `%s'", keyword.c_str ());
-
-  return retval;
-}
-
-#endif
-
-#if defined (NPSOL_MISSING)
-DEFUN_DLD (npsol_options, , ,
-  "This function requires NPSOL, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/npsol/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (npsol_options, args, ,
-  "npsol_options (KEYWORD, VALUE)\n\
-\n\
-Set or show options for npsol.  Keywords may be abbreviated\n\
-to the shortest match.")
-#endif
-{
-  octave_value_list retval;
-
-#if defined (NPSOL_MISSING)
-
-  print_usage ("npsol_options");
-
-#else
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    {
-      print_npsol_option_list (octave_stdout);
-      return retval;
-    }
-  else if (nargin == 1 || nargin == 2)
-    {
-      string keyword = args(0).string_value ();
-
-      if (! error_state)
-	{
-	  if (nargin == 1)
-	    return show_npsol_option (keyword);
-	  else
-	    {
-	      double val = args(1).double_value ();
-
-	      if (! error_state)
-		{
-		  set_npsol_option (keyword, val);
-		  return retval;
-		}
-	    }
-	}
-    }
-
-  print_usage ("npsol_options");
-
-#endif
-
-  return retval;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/DLD-FUNCTIONS/qpsol.cc b/src/DLD-FUNCTIONS/qpsol.cc
deleted file mode 100644
--- a/src/DLD-FUNCTIONS/qpsol.cc
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string>
-
-#include <iostream.h>
-
-#include "QPSOL.h"
-#include "lo-mappers.h"
-
-#include "defun-dld.h"
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "pager.h"
-#include "utils.h"
-#include "variables.h"
-
-#ifndef QPSOL_MISSING
-
-// XXX FIXME XXX -- this is duplicated in npsol.cc
-
-static int
-linear_constraints_ok (const ColumnVector& x, const ColumnVector& llb,
-		       const Matrix& c, const ColumnVector& lub,
-		       char *warn_for, int warn)
-{
-  int x_len = x.capacity ();
-  int llb_len = llb.capacity ();
-  int lub_len = lub.capacity ();
-  int c_rows = c.rows ();
-  int c_cols = c.columns ();
-
-  int ok = 1;
-  if (warn)
-    {
-      if (c_rows == 0 || c_cols == 0 || llb_len == 0 || lub_len == 0)
-	{
-	  ok = 0;
-	  error ("%s: linear constraints must have nonzero dimensions",
-		 warn_for);
-	}
-      else if (x_len != c_cols || llb_len != lub_len || llb_len != c_rows)
-	{
-	  ok = 0;
-	  error ("%s: linear constraints have inconsistent dimensions",
-		 warn_for);
-	}
-    }
-
-  return ok;
-}
-
-static QPSOL_options qpsol_opts;
-
-#endif
-
-#if defined (QPSOL_MISSING)
-DEFUN_DLD (qpsol, , ,
-  "This function requires QPSOL, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/qpsol/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (qpsol, args, nargout,
-  "[X, OBJ, INFO, LAMBDA] = qpsol (X, H, C [, LB, UB] [, A_LB, A, A_UB])\n\
-\n\
-Groups of arguments surrounded in `[]' are optional, but\n\
-must appear in the same relative order shown above.")
-#endif
-{
-/*
-
-Handle all of the following:
-
-  1. qpsol (x, H, c)
-  2. qpsol (x, H, c, lb, ub)
-  3. qpsol (x, H, c, lb, ub, llb, A, lub)
-  4. qpsol (x, H, c,         llb, A, lub)
-
-*/
-
-  octave_value_list retval;
-
-#if defined (QPSOL_MISSING)
-
-  // Force a bad value of inform, and empty matrices for x, phi, and
-  // lambda.
-
-  retval.resize (4, Matrix ());
-
-  retval(2) = -1.0;
-
-  print_usage ("qpsol");
-
-#else
-
-  int nargin = args.length ();
-
-  if (nargin < 3 || nargin == 4 || nargin == 7 || nargin > 8
-      || nargout > 4)
-    {
-      print_usage ("qpsol");
-      return retval;
-    }
-
-  ColumnVector x = args(0).vector_value ();
-
-  if (error_state || x.capacity () == 0)
-    {
-      error ("qpsol: expecting vector as first argument");
-      return retval;
-    }
-
-  Matrix H = args(1).matrix_value ();
-
-  if (error_state || H.rows () != H.columns () || H.rows () != x.capacity ())
-    {
-      error ("qpsol: H must be a square matrix consistent with the size of x");
-      return retval;
-    }
-
-  ColumnVector c = args(2).vector_value ();
-
-  if (error_state || c.capacity () != x.capacity ())
-    {
-      error ("qpsol: c must be a vector the same size as x");
-      return retval;
-    }
-
-  Bounds bounds;
-  if (nargin == 5 || nargin == 8)
-    {
-      ColumnVector lb = args(3).vector_value ();
-      ColumnVector ub = args(4).vector_value ();
-
-      int lb_len = lb.capacity ();
-      int ub_len = ub.capacity ();
-
-      if (error_state || lb_len != ub_len || lb_len != x.capacity ())
-	{
-	  error ("qpsol: lower and upper bounds and decision variable vector");
-	  error ("must all have the same number of elements");
-	  return retval;
-	}
-
-      bounds.resize (lb_len);
-      bounds.set_lower_bounds (lb);
-      bounds.set_upper_bounds (ub);
-    }
-
-  ColumnVector soln;
-  double objf;
-  ColumnVector lambda;
-  int inform;
-
-  if (nargin == 3)
-    {
-      // 1. qpsol (x, H, c)
-
-      QPSOL qp (x, H, c);
-      qp.set_options (qpsol_opts);
-      soln = qp.minimize (objf, inform, lambda);
-
-      goto solved;
-    }
-
-  if (nargin == 5)
-    {
-      //  2. qpsol (x, H, c, lb, ub)
-
-      QPSOL qp (x, H, c, bounds);
-      qp.set_options (qpsol_opts);
-      soln = qp.minimize (objf, inform, lambda);
-
-      goto solved;
-    }
-
-  if (nargin == 6 || nargin == 8)
-    {
-      ColumnVector lub = args(nargin-1).vector_value ();
-      ColumnVector llb = args(nargin-3).vector_value ();
-
-      if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
-	{
-	  error ("qpsol: bounds for linear constraints must be vectors");
-	  return retval;
-	}
-
-      Matrix A = args(nargin-2).matrix_value ();
-
-      if (error_state)
-	{
-	  error ("qpsol: invalid linear constraint matrix");
-	  return retval;
-	}
-
-      if (! linear_constraints_ok (x, llb, A, lub, "qpsol", 1))
-	return retval;
-
-      LinConst linear_constraints (llb, A, lub);
-
-      if (nargin == 8)
-	{
-	  // 3. qpsol (x, H, c, lb, ub, llb, A, lub)
-
-	  QPSOL qp (x, H, c, bounds, linear_constraints);
-	  qp.set_options (qpsol_opts);
-	  soln = qp.minimize (objf, inform, lambda);
-	}
-      else
-	{
-	  // 4. qpsol (x, H, c,         llb, A, lub)
-
-	 QPSOL qp (x, H, c, linear_constraints);
-	 qp.set_options (qpsol_opts);
-	 soln = qp.minimize (objf, inform, lambda);
-       }
-      goto solved;
-    }
-
-  return retval;
-
- solved:
-
-  retval.resize (nargout ? nargout : 1);
-  retval(0) = soln, 1;
-  if (nargout > 1)
-    retval(1) = objf;
-  if (nargout > 2)
-    retval(2) = static_cast<double> (inform);
-  if (nargout > 3)
-    retval(3) = lambda;
-
-#endif
-
-  return retval;
-}
-
-#ifndef QPSOL_MISSING
-
-typedef void (QPSOL_options::*d_set_opt_mf) (double);
-typedef void (QPSOL_options::*i_set_opt_mf) (int);
-typedef double (QPSOL_options::*d_get_opt_mf) (void);
-typedef int (QPSOL_options::*i_get_opt_mf) (void);
-
-#define MAX_TOKENS 2
-
-struct QPSOL_OPTIONS
-{
-  const char *keyword;
-  const char *kw_tok[MAX_TOKENS + 1];
-  int min_len[MAX_TOKENS + 1];
-  int min_toks_to_match;
-  d_set_opt_mf d_set_fcn;
-  i_set_opt_mf i_set_fcn;
-  d_get_opt_mf d_get_fcn;
-  i_get_opt_mf i_get_fcn;
-};
-
-static QPSOL_OPTIONS qpsol_option_table [] =
-{
-  { "feasibility tolerance",
-    { "feasibility", "tolerance", 0, },
-    { 1, 0, 0, }, 1,
-    QPSOL_options::set_feasibility_tolerance, 0,
-    QPSOL_options::feasibility_tolerance, 0, },
-
-  { "infinite bound",
-    { "infinite", "bound", 0, },
-    { 2, 0, 0, }, 1,
-    QPSOL_options::set_infinite_bound, 0,
-    QPSOL_options::infinite_bound, 0, },
-
-  { "iteration limit",
-    { "iteration", "limit", 0, },
-    { 2, 0, 0, }, 1,
-    0, QPSOL_options::set_iteration_limit,
-    0, QPSOL_options::iteration_limit, },
-
-  { "print level",
-    { "print", "level", 0, },
-    { 1, 0, 0, }, 1,
-    0, QPSOL_options::set_print_level,
-    0, QPSOL_options::print_level, },
-
-  { 0,
-    { 0, 0, 0, },
-    { 0, 0, 0, }, 0,
-    0, 0, 0, 0, },
-};
-
-static void
-print_qpsol_option_list (ostream& os)
-{
-  print_usage ("qpsol_options", 1);
-
-  os << "\n"
-     << "Options for qpsol include:\n\n"
-     << "  keyword                                  value\n"
-     << "  -------                                  -----\n\n";
-
-  QPSOL_OPTIONS *list = qpsol_option_table;
-
-  const char *keyword;
-  while ((keyword = list->keyword) != 0)
-    {
-      os.form ("  %-40s ", keyword);
-      if (list->d_get_fcn)
-	{
-	  double val = (qpsol_opts.*list->d_get_fcn) ();
-	  if (val < 0.0)
-	    os << "computed automatically";
-	  else
-	    os << val;
-	}
-      else
-	{
-	  int val = (qpsol_opts.*list->i_get_fcn) ();
-	  if (val < 0)
-	    os << "depends on problem size";
-	  else
-	    os << val;
-	}
-      os << "\n";
-      list++;
-    }
-
-  os << "\n";
-}
-
-static void
-set_qpsol_option (const string& keyword, double val)
-{
-  QPSOL_OPTIONS *list = qpsol_option_table;
-
-  while (list->keyword != 0)
-    {
-      if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
-				list->min_toks_to_match, MAX_TOKENS))
-	{
-	  if (list->d_set_fcn)
-	    (qpsol_opts.*list->d_set_fcn) (val);
-	  else
-	    {
-	      if (xisnan (val))
-		{
-		  error ("qpsol_options: %s: expecting integer, found NaN",
-			 keyword.c_str ());
-		}
-	      else
-		(qpsol_opts.*list->i_set_fcn) (NINT (val));
-	    }
-	  return;
-	}
-      list++;
-    }
-
-  warning ("qpsol_options: no match for `%s'", keyword.c_str ());
-}
-
-static octave_value_list
-show_qpsol_option (const string& keyword)
-{
-  octave_value retval;
-
-  QPSOL_OPTIONS *list = qpsol_option_table;
-
-  while (list->keyword != 0)
-    {
-      if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
-				list->min_toks_to_match, MAX_TOKENS))
-	{
-	  if (list->d_get_fcn)
-	    {
-	      double val = (qpsol_opts.*list->d_get_fcn) ();
-	      if (val < 0.0)
-		retval = "computed automatically";
-	      else
-		retval = val;
-	    }
-	  else
-	    {
-	      int val = (qpsol_opts.*list->i_get_fcn) ();
-	      if (val < 0)
-		retval = "depends on problem size";
-	      else
-		retval = static_cast<double> (val);
-	    }
-
-	  return retval;
-	}
-      list++;
-    }
-
-  warning ("qpsol_options: no match for `%s'", keyword.c_str ());
-
-  return retval;
-}
-
-#endif
-
-#if defined (QPSOL_MISSING)
-DEFUN_DLD (qpsol_options, , ,
-  "This function requires QPSOL, which is not freely\n\
-redistributable.  For more information, read the file\n\
-libcruft/qpsol/README.MISSING in the source distribution.")
-#else
-DEFUN_DLD (qpsol_options, args, ,
-  "qpsol_options (KEYWORD, VALUE)\n\
-\n\
-Set or show options for qpsol.  Keywords may be abbreviated\n\
-to the shortest match.")
-#endif
-{
-  octave_value_list retval;
-
-#if defined (QPSOL_MISSING)
-
-  print_usage ("qpsol");
-
-#else
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    {
-      print_qpsol_option_list (octave_stdout);
-      return retval;
-    }
-  else if (nargin == 1 || nargin == 2)
-    {
-      string keyword = args(0).string_value ();
-
-      if (! error_state)
-	{
-	  if (nargin == 1)
-	    return show_qpsol_option (keyword);
-	  else
-	    {
-	      double val = args(1).double_value ();
-
-	      if (! error_state)
-		{
-		  set_qpsol_option (keyword, val);
-		  return retval;
-		}
-	    }
-	}
-    }
-
-  print_usage ("qpsol_options");
-
-#endif
-
-  return retval;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -35,21 +35,21 @@ ifeq ($(OCTAVE_LITE), true)
 	  $(SH_LD) $(SH_LDFLAGS) -o $@ $<
   else
     %.oct : %.o
 	  $(SH_LD) $(SH_LDFLAGS) -o $@ $<
   endif
 endif
 
 DLD_XSRC := balance.cc chol.cc colloc.cc dassl.cc det.cc eig.cc \
-	   expm.cc fft.cc fft2.cc filter.cc find.cc fsolve.cc \
-	   fsqp.cc getgrent.cc getpwent.cc getrusage.cc givens.cc \
-	   hess.cc ifft.cc ifft2.cc inv.cc log.cc lpsolve.cc lsode.cc \
-	   lu.cc minmax.cc npsol.cc pinv.cc qpsol.cc qr.cc quad.cc \
-	   qzval.cc rand.cc schur.cc sort.cc svd.cc syl.cc time.cc 
+	expm.cc fft.cc fft2.cc filter.cc find.cc fsolve.cc \
+	getgrent.cc getpwent.cc getrusage.cc givens.cc hess.cc \
+	ifft.cc ifft2.cc inv.cc log.cc lpsolve.cc lsode.cc \
+	lu.cc minmax.cc pinv.cc qr.cc quad.cc qzval.cc rand.cc \
+	schur.cc sort.cc svd.cc syl.cc time.cc
 
 DLD_SRC := $(addprefix DLD-FUNCTIONS/, $(DLD_XSRC))
 
 DLD_OBJ := $(patsubst %.cc, %.o, $(DLD_XSRC))
 
 ifeq ($(OCTAVE_LITE), true)
   OCT_FILES := $(patsubst %.o, %.oct, $(DLD_OBJ))
   ifdef CXXPICFLAG
