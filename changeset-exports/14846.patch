# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1341772130 25200
#      Sun Jul 08 11:28:50 2012 -0700
# Node ID 460a3c6d8bf100be01f2879253e2bd9ced7b6067
# Parent  5bc9b9cb4362edf07722057481cbe0bd22928aa1
maint: Use Octave coding convention for cuddled parenthis in function calls with empty argument lists.
Example: func() => func ()

* dynamic.txi, func.txi, oop.txi, var.txi, embedded.cc, fortdemo.cc,
funcdemo.cc, paramdemo.cc, stringdemo.cc, unwinddemo.cc, Array.cc, Array.h,
CColVector.cc, CDiagMatrix.h, CMatrix.cc, CNDArray.cc, CRowVector.cc,
CSparse.cc, CmplxGEPBAL.cc, EIG.cc, MSparse.cc, MatrixType.cc,
Sparse-op-defs.h, Sparse-perm-op-defs.h, Sparse.cc, Sparse.h,
SparseCmplxCHOL.cc, SparseCmplxCHOL.h, SparseCmplxLU.cc, SparseCmplxQR.cc,
SparseCmplxQR.h, SparseQR.cc, SparseQR.h, SparsedbleCHOL.cc, SparsedbleCHOL.h,
SparsedbleLU.cc, SparsedbleLU.h, base-lu.cc, cmd-hist.cc, dColVector.cc,
dDiagMatrix.h, dMatrix.cc, dNDArray.cc, dRowVector.cc, dSparse.cc, dbleCHOL.cc,
dbleGEPBAL.cc, dim-vector.cc, eigs-base.cc, f2c-main.c, fCColVector.cc,
fCDiagMatrix.h, fCMatrix.cc, fCNDArray.cc, fCRowVector.cc, fCmplxGEPBAL.cc,
fColVector.cc, fDiagMatrix.h, fEIG.cc, fMatrix.cc, fNDArray.cc, fRowVector.cc,
file-ops.cc, file-stat.cc, floatCHOL.cc, floatGEPBAL.cc, idx-vector.h,
lo-specfun.cc, lo-sysdep.cc, mx-inlines.cc, oct-binmap.h, oct-convn.cc,
oct-md5.cc, oct-mem.h, oct-rand.cc, oct-syscalls.cc, randgamma.c, randmtzig.c,
sparse-base-chol.cc, sparse-base-chol.h, sparse-base-lu.cc, sparse-dmsolve.cc,
tempname.c, curl.m, divergence.m, randi.m, dlmwrite.m, edit.m, getappdata.m,
what.m, getarchdir.m, install.m, installed_packages.m, repackage.m,
unload_packages.m, colorbar.m, figure.m, isosurface.m, legend.m, loglog.m,
plot.m, plot3.m, plotyy.m, polar.m, __errplot__.m, __ghostscript__.m,
__marching_cube__.m, __plt__.m, __scatter__.m, semilogx.m, semilogy.m,
trimesh.m, trisurf.m, demo.m, test.m, datetick.m, __delaunayn__.cc,
__dsearchn__.cc, __fltk_uigetfile__.cc, __glpk__.cc, __init_fltk__.cc,
__lin_interpn__.cc, __magick_read__.cc, __pchip_deriv__.cc, balance.cc,
bsxfun.cc, ccolamd.cc, cellfun.cc, chol.cc, daspk.cc, dasrt.cc, dassl.cc,
dmperm.cc, eig.cc, eigs.cc, fftw.cc, filter.cc, find.cc, kron.cc, lookup.cc,
lsode.cc, matrix_type.cc, md5sum.cc, mgorth.cc, qr.cc, quad.cc, rand.cc,
regexp.cc, symbfact.cc, tril.cc, urlwrite.cc, op-bm-bm.cc, op-cdm-cdm.cc,
op-cell.cc, op-chm.cc, op-cm-cm.cc, op-cm-scm.cc, op-cm-sm.cc, op-cs-scm.cc,
op-cs-sm.cc, op-dm-dm.cc, op-dm-scm.cc, op-dm-sm.cc, op-fcdm-fcdm.cc,
op-fcm-fcm.cc, op-fdm-fdm.cc, op-fm-fm.cc, op-int.h, op-m-m.cc, op-m-scm.cc,
op-m-sm.cc, op-pm-pm.cc, op-pm-scm.cc, op-pm-sm.cc, op-range.cc, op-s-scm.cc,
op-s-sm.cc, op-sbm-sbm.cc, op-scm-cm.cc, op-scm-cs.cc, op-scm-m.cc,
op-scm-s.cc, op-scm-scm.cc, op-scm-sm.cc, op-sm-cm.cc, op-sm-cs.cc, op-sm-m.cc,
op-sm-s.cc, op-sm-scm.cc, op-sm-sm.cc, op-str-str.cc, op-struct.cc, bitfcns.cc,
data.cc, debug.cc, dynamic-ld.cc, error.cc, gl-render.cc, graphics.cc,
graphics.in.h, load-path.cc, ls-hdf5.cc, ls-mat5.cc, ls-mat5.h,
ls-oct-ascii.cc, ls-oct-ascii.h, mex.cc, mk-errno-list, oct-map.cc, oct-obj.h,
oct-parse.yy, octave-config.in.cc, ov-base-int.cc, ov-base-mat.cc, ov-base.cc,
ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc, ov-cell.cc, ov-class.cc,
ov-class.h, ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc, ov-flt-cx-mat.cc,
ov-flt-re-mat.cc, ov-intx.h, ov-range.h, ov-re-mat.cc, ov-re-sparse.cc,
ov-str-mat.cc, ov-struct.cc, ov-usr-fcn.h, ov.h, pr-output.cc, pt-id.cc,
pt-id.h, pt-mat.cc, pt-select.cc, sparse.cc, symtab.cc, symtab.h, syscalls.cc,
toplev.cc, txt-eng-ft.cc, variables.cc, zfstream.cc, zfstream.h, Dork.m,
getStash.m, myStash.m, Gork.m, Pork.m, myStash.m, getStash.m, myStash.m,
getStash.m, myStash.m, fntests.m: Use Octave coding convention for
cuddled parenthis in function calls with empty argument lists.

diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -1274,17 +1274,17 @@ mkoctfile --mex firstmexdemo.c
 @end example
 
 @noindent
 which creates a file @file{firstmexdemo.mex}.  The function can then be run
 from Octave as
 
 @example
 @group
-firstmexdemo()
+firstmexdemo ()
 @result{} 1.2346
 @end group
 @end example
 
 It should be noted that the mex-file contains no help string for the
 functions it contains.  To document mex-files, there should exist an
 m-file in the same directory as the mex-file itself.  Taking the above as
 an example, we would therefore have a file @file{firstmexdemo.m} that might
@@ -1319,20 +1319,20 @@ mkoctfile --mex myfunc.c
 ln -s myfunc.mex myfunc2.mex
 @end group
 @end example
 
 Then as can be seen by
 
 @example
 @group
-myfunc()
+myfunc ()
 @result{} You called function: myfunc
     This is the principal function
-myfunc2()
+myfunc2 ()
 @result{} You called function: myfunc2
 @end group
 @end example
 
 @noindent
 the behavior of the mex-file can be altered depending on the functions
 name.
 
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -912,17 +912,17 @@ mislocked ("my_function")
 @end group
 @end example
 
 A common use of @code{mlock} is to prevent persistent variables from
 being removed from memory, as the following example shows:
 
 @example
 @group
-function count_calls()
+function count_calls ()
   persistent calls = 0;
   printf ("'count_calls' has been called %d times\n",
           ++calls);
 endfunction
 mlock ("count_calls");
 
 count_calls ();
 @print{} 'count_calls' has been called 1 times
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -791,17 +791,17 @@ publicly writable.
 @EXAMPLEFILE(@FIRfilter/subsasgn.m)
 @end group
 @end example
 
 So that
 
 @example
 @group
-octave:6> f=FIRfilter();
+octave:6> f=FIRfilter ();
 octave:7> f.polynomial = polynomial([1 2 3]);
 f.polynomial = 1 + 2 * X + 3 * X ^ 2
 @end group
 @end example
 
 
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -267,31 +267,31 @@ is saved on disk, we get the following b
 for i = 1:2
   count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 
 clear
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 3 times
 @print{} 'count_calls' has been called 4 times
 
 clear all
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 
 clear count_calls
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 @end example
 
 @noindent
 That is, the persistent variable is only removed from memory when the
 function containing the variable is removed.  Note that if the function
diff --git a/examples/embedded.cc b/examples/embedded.cc
--- a/examples/embedded.cc
+++ b/examples/embedded.cc
@@ -5,17 +5,17 @@
 
 int
 main (void)
 {
   string_vector argv (2);
   argv(0) = "embedded";
   argv(1) = "-q";
 
-  octave_main (2, argv.c_str_vec(), 1);
+  octave_main (2, argv.c_str_vec (), 1);
 
   octave_idx_type n = 2;
   octave_value_list in;
 
   for (octave_idx_type i = 0; i < n; i++)  
     in(i) = octave_value (5 * (i + 1));
   
   octave_value_list out = feval ("gcd", in, 1);
diff --git a/examples/fortdemo.cc b/examples/fortdemo.cc
--- a/examples/fortdemo.cc
+++ b/examples/fortdemo.cc
@@ -7,17 +7,17 @@ extern "C"
   F77_FUNC (fortsub, FORTSUB)
         (const int&, double*, F77_CHAR_ARG_DECL
          F77_CHAR_ARG_LEN_DECL);
 }
 
 DEFUN_DLD (fortdemo , args , , "Fortran Demo.")
 {
   octave_value_list retval;
-  int nargin = args.length();
+  int nargin = args.length ();
   if (nargin != 1)
     print_usage ();
   else
     {
       NDArray a = args(0).array_value ();
       if (! error_state)
         {
           double *av = a.fortran_vec ();
diff --git a/examples/funcdemo.cc b/examples/funcdemo.cc
--- a/examples/funcdemo.cc
+++ b/examples/funcdemo.cc
@@ -1,14 +1,14 @@
 #include <octave/oct.h>
 #include <octave/parse.h>
 
 DEFUN_DLD (funcdemo, args, nargout, "Function Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       octave_value_list newargs;
       for (octave_idx_type i = nargin - 1; i > 0; i--)
diff --git a/examples/paramdemo.cc b/examples/paramdemo.cc
--- a/examples/paramdemo.cc
+++ b/examples/paramdemo.cc
@@ -2,33 +2,33 @@
 
 DEFUN_DLD (paramdemo, args, nargout,
            "Parameter Check Demo.")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
-    print_usage();
+    print_usage ();
   else if (nargout != 0)
     error ("paramdemo: function has no output arguments");
   else
     {
-      NDArray m = args(0).array_value();
+      NDArray m = args(0).array_value ();
       double min_val = -10.0;
       double max_val = 10.0;
       octave_stdout << "Properties of input array:\n";
       if (m.any_element_is_negative ())
         octave_stdout << "  includes negative values\n";
-      if (m.any_element_is_inf_or_nan())
+      if (m.any_element_is_inf_or_nan ())
         octave_stdout << "  includes Inf or NaN values\n";
-      if (m.any_element_not_one_or_zero())
+      if (m.any_element_not_one_or_zero ())
         octave_stdout <<
           "  includes other values than 1 and 0\n";
-      if (m.all_elements_are_int_or_inf_or_nan())
+      if (m.all_elements_are_int_or_inf_or_nan ())
         octave_stdout <<
           "  includes only int, Inf or NaN values\n";
       if (m.all_integers (min_val, max_val))
         octave_stdout <<
           "  includes only integers in [-10,10]\n";
     }
   return retval;
 }
diff --git a/examples/stringdemo.cc b/examples/stringdemo.cc
--- a/examples/stringdemo.cc
+++ b/examples/stringdemo.cc
@@ -1,33 +1,33 @@
 #include <octave/oct.h>
 
 DEFUN_DLD (stringdemo, args, , "String Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     print_usage ();
   else
     {
       charMatrix ch = args(0).char_matrix_value ();
 
       if (! error_state)
         {
           if (args(0).is_sq_string ())
             retval(1) = octave_value (ch, true);
           else
             retval(1) = octave_value (ch, true, '\'');
 
-          octave_idx_type nr = ch.rows();
+          octave_idx_type nr = ch.rows ();
           for (octave_idx_type i = 0; i < nr / 2; i++)
             {
               std::string tmp = ch.row_as_string (i);
-              ch.insert (ch.row_as_string(nr-i-1).c_str(),
+              ch.insert (ch.row_as_string(nr-i-1).c_str (),
                          i, 0);
-              ch.insert (tmp.c_str(), nr-i-1, 0);
+              ch.insert (tmp.c_str (), nr-i-1, 0);
             }
           retval(0) = octave_value (ch, true);
         }
     }
   return retval;
 }
diff --git a/examples/unwinddemo.cc b/examples/unwinddemo.cc
--- a/examples/unwinddemo.cc
+++ b/examples/unwinddemo.cc
@@ -4,17 +4,17 @@
 void
 err_hand (const char *fmt, ...)
 {
   // Do nothing!!
 }
 
 DEFUN_DLD (unwinddemo, args, nargout, "Unwind Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value retval;
   if (nargin < 2)
     print_usage ();
   else
     {
       NDArray a = args(0).array_value ();
       NDArray b = args(1).array_value ();
 
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2683,17 +2683,17 @@ bool Array<T>::optimize_dimensions (cons
   return retval;
 }
 
 template <class T>
 void Array<T>::instantiation_guard ()
 {
   // This guards against accidental implicit instantiations.
   // Array<T> instances should always be explicit and use INSTANTIATE_ARRAY.
-  T::__xXxXx__();
+  T::__xXxXx__ ();
 }
 
 #define INSTANTIATE_ARRAY(T, API) \
   template <> void Array<T>::instantiation_guard () { } \
   template class API Array<T>
 
 // FIXME: is this used?
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -322,23 +322,23 @@ public:
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
     { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n) { return slice_data [n]; }
   crefT xelem (octave_idx_type n) const { return slice_data [n]; }
 
-  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1()*j+i); }
-  crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1()*j+i); }
+  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1 ()*j+i); }
+  crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1 ()*j+i); }
 
   T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
-    { return xelem (i, dim2()*k+j); }
+    { return xelem (i, dim2 ()*k+j); }
   crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
-    { return xelem (i, dim2()*k+j); }
+    { return xelem (i, dim2 ()*k+j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index_unchecked (ra_idx)); }
 
   crefT xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index_unchecked (ra_idx)); }
 
   // FIXME -- would be nice to fix this so that we don't
@@ -351,19 +351,19 @@ public:
   T& checkelem (const Array<octave_idx_type>& ra_idx);
 
   T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
-  T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1()*j+i); }
+  T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1 ()*j+i); }
 
-  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2()*k+j); }
+  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2 ()*k+j); }
 
   T& elem (const Array<octave_idx_type>& ra_idx)
     { return Array<T>::elem (compute_index_unchecked (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   T& operator () (octave_idx_type n) { return checkelem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return checkelem (i, j, k); }
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -510,17 +510,17 @@ operator << (std::ostream& os, const Com
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -85,17 +85,17 @@ public:
   ComplexDiagMatrix& fill (const RowVector& a);
   ComplexDiagMatrix& fill (const ComplexRowVector& a);
   ComplexDiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const RowVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexRowVector& a, octave_idx_type beg);
 
   ComplexDiagMatrix hermitian (void) const { return MDiagArray2<Complex>::hermitian (std::conj); }
-  ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose(); }
+  ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1084,17 +1084,17 @@ ComplexMatrix::finverse (MatrixType &mat
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1122,17 +1122,17 @@ ComplexMatrix::finverse (MatrixType &mat
           F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
           if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         double& rcon, int force, int calc_cond) const
@@ -1148,17 +1148,17 @@ ComplexMatrix::inverse (MatrixType &matt
   else
     {
       if (mattype.is_hermitian ())
         {
           ComplexCHOL chol (*this, info, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
-                rcon = chol.rcond();
+                rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
@@ -1788,18 +1788,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           double anorm = -1.0;
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1828,18 +1828,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2095,17 +2095,17 @@ ComplexMatrix::fsolve (MatrixType &matty
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2151,17 +2151,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2179,17 +2179,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2237,17 +2237,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
     }
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -114,45 +114,45 @@ ComplexNDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -346,17 +346,17 @@ ComplexNDArray::fourier2d (void) const
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -406,17 +406,17 @@ operator << (std::ostream& os, const Com
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -738,22 +738,22 @@ SparseComplexMatrix::dinverse (MatrixTyp
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose();
+            retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
-          Complex *v = retval.data();
+          Complex *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = std::abs(v[i]);
                   if (tmp > dmax)
@@ -924,17 +924,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseComplexMatrix (nr, nc, nz2);
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-              octave_idx_type *perm = mattyp.triangular_perm();
+              octave_idx_type *perm = mattyp.triangular_perm ();
               if (typ == MatrixType::Permuted_Upper)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     rperm[perm[i]] = i;
                 }
               else
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
@@ -1044,77 +1044,77 @@ SparseComplexMatrix::tinverse (MatrixTyp
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
-  return SparseComplexMatrix();
+  return SparseComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                               double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
+    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose ();
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     {
-      MatrixType newtype = mattype.transpose();
-      ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
+      MatrixType newtype = mattype.transpose ();
+      ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
-      if (mattype.is_hermitian())
+      if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexCHOL fact (*this, info, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
-              SparseMatrix Q = fact.Q();
-              SparseComplexMatrix InvL = fact.L().transpose().
+              SparseMatrix Q = fact.Q ();
+              SparseComplexMatrix InvL = fact.L ().transpose ().
                 tinverse(tmp_typ, info, rcond2, true, false);
-              ret = Q * InvL.hermitian() * InvL * Q.transpose();
+              ret = Q * InvL.hermitian () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
         }
 
-      if (!mattype.is_hermitian())
+      if (!mattype.is_hermitian ())
         {
-          octave_idx_type n = rows();
+          octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           double rcond2;
-          SparseComplexMatrix InvL = fact.L().transpose().
+          SparseComplexMatrix InvL = fact.L ().transpose ().
             tinverse(tmp_typ, info, rcond2, true, false);
-          SparseComplexMatrix InvU = fact.U().
-            tinverse(tmp_typ, info, rcond2, true, false).transpose();
-          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+          SparseComplexMatrix InvU = fact.U ().
+            tinverse(tmp_typ, info, rcond2, true, false).transpose ();
+          ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 ComplexDET
 SparseComplexMatrix::determinant (void) const
@@ -1274,23 +1274,23 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex(0.,0.));
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1342,29 +1342,29 @@ SparseComplexMatrix::dsolve (MatrixType 
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -1426,23 +1426,23 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex(0.,0.));
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
@@ -1494,29 +1494,29 @@ SparseComplexMatrix::dsolve (MatrixType 
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -3791,22 +3791,22 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx(i) == j)
                       D[j] = std::real(data(i));
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3848,22 +3848,22 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4090,17 +4090,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                     if (ridx(i) == j)
                       D[j] = std::real (data(i));
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
@@ -4147,18 +4147,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
@@ -4388,17 +4388,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4452,17 +4452,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows(), err
+                             ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
@@ -4574,17 +4574,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows(), err
+                             ldm, pipvt, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4637,17 +4637,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4955,17 +4955,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5201,17 +5201,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5650,49 +5650,49 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_REAL;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<double *>(b.fortran_vec());
+            B->x = const_cast<double *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -5726,21 +5726,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -5893,59 +5893,59 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6184,49 +6184,49 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_COMPLEX;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<Complex *>(b.fortran_vec());
+            B->x = const_cast<Complex *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6260,21 +6260,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -6406,59 +6406,59 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -7343,18 +7343,18 @@ SparseComplexMatrix
 SparseComplexMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseComplexMatrix, Complex, cumsum);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
-  if ((rows() == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose();
+  if ((rows () == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
@@ -7381,17 +7381,17 @@ SparseComplexMatrix::sumsq (int dim) con
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
   octave_idx_type nz = nnz ();
   octave_idx_type nc = cols ();
 
-  SparseMatrix retval (rows(), nc, nz);
+  SparseMatrix retval (rows (), nc, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = std::abs (data (i));
       retval.ridx (i) = ridx (i);
@@ -7660,17 +7660,17 @@ min (const SparseComplexMatrix& m, const
   return min (c, m);
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
@@ -7780,17 +7780,17 @@ max (const SparseComplexMatrix& m, const
   return max (c, m);
 }
 
 SparseComplexMatrix
 max (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -65,17 +65,17 @@ ComplexGEPBALANCE::init (const ComplexMa
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -686,17 +686,17 @@ EIG::init (const ComplexMatrix& a, const
       (*current_liboctave_error_handler)
         ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
-  if (n != a.cols () || nb != b.cols())
+  if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   if (n != nb)
     {
       (*current_liboctave_error_handler) ("EIG requires same size matrices");
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -412,34 +412,34 @@ product (const MSparse<T>& a, const MSpa
 
   if (a_nr == 1 && a_nc == 1)
     {
       if (a.elem(0,0) == 0.)
         r = MSparse<T> (b_nr, b_nc);
       else
         {
           r = MSparse<T> (b);
-          octave_idx_type b_nnz = b.nnz();
+          octave_idx_type b_nnz = b.nnz ();
 
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             {
               octave_quit ();
               r.data (i) = a.data(0) * r.data(i);
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       if (b.elem(0,0) == 0.)
         r = MSparse<T> (a_nr, a_nc);
       else
         {
           r = MSparse<T> (a);
-          octave_idx_type a_nnz = a.nnz();
+          octave_idx_type a_nnz = a.nnz ();
 
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             {
               octave_quit ();
               r.data (i) = r.data(i) * b.data(0);
             }
           r.maybe_compress ();
         }
@@ -507,20 +507,20 @@ quotient (const MSparse<T>& a, const MSp
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
       T val = a.elem (0,0);
-      T fill = val / T();
-      if (fill == T())
+      T fill = val / T ();
+      if (fill == T ())
         {
-          octave_idx_type b_nnz = b.nnz();
+          octave_idx_type b_nnz = b.nnz ();
           r = MSparse<T> (b);
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             r.data (i) = val / r.data(i);
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (b_nr, b_nc, fill);
@@ -535,20 +535,20 @@ quotient (const MSparse<T>& a, const MSp
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       T val = b.elem (0,0);
-      T fill = T() / val;
-      if (fill == T())
+      T fill = T () / val;
+      if (fill == T ())
         {
-          octave_idx_type a_nnz = a.nnz();
+          octave_idx_type a_nnz = a.nnz ();
           r = MSparse<T> (a);
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             r.data (i) = r.data(i) / val;
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (a_nr, a_nc, fill);
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "oct-locbuf.h"
 
 // FIXME There is a large code duplication here
 
 MatrixType::MatrixType (void)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0),
     lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
 
 MatrixType::MatrixType (const MatrixType &a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
@@ -135,18 +135,18 @@ matrix_complex_probe (const MArray<std::
       OCTAVE_LOCAL_BUFFER(T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           std::complex<T> d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
-          hermitian = hermitian && (d.real() > zero && d.imag() == zero);
-          diag[j] = d.real();
+          hermitian = hermitian && (d.real () > zero && d.imag () == zero);
+          diag[j] = d.real ();
         }
 
       for (octave_idx_type j = 0;
            j < ncols && (upper || lower || hermitian); j++)
         {
           for (octave_idx_type i = 0; i < j; i++)
             {
               std::complex<T> aij = a.elem (i,j), aji = a.elem (j,i);
@@ -215,17 +215,17 @@ MatrixType::MatrixType (const SparseMatr
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
-  sp_bandden = octave_sparse_params::get_bandden();
+  sp_bandden = octave_sparse_params::get_bandden ();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
@@ -536,17 +536,17 @@ MatrixType::MatrixType (const SparseComp
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
-  sp_bandden = octave_sparse_params::get_bandden();
+  sp_bandden = octave_sparse_params::get_bandden ();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
@@ -799,18 +799,18 @@ MatrixType::MatrixType (const SparseComp
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
                 {
                   if (a.ridx(i) == j)
                     {
                       Complex d = a.data(i);
-                      is_herm = d.real() > 0. && d.imag() == 0.;
-                      diag(j) = d.real();
+                      is_herm = d.real () > 0. && d.imag () == 0.;
+                      diag(j) = d.real ();
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
@@ -845,34 +845,34 @@ MatrixType::MatrixType (const SparseComp
               else
                 typ = MatrixType::Tridiagonal_Hermitian;
             }
         }
     }
 }
 MatrixType::MatrixType (const matrix_type t, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if (t == MatrixType::Unknown || t == MatrixType::Full
       || t == MatrixType::Diagonal || t == MatrixType::Permuted_Diagonal
       || t == MatrixType::Upper || t == MatrixType::Lower
       || t == MatrixType::Tridiagonal || t == MatrixType::Tridiagonal_Hermitian
       || t == MatrixType::Rectangular)
     typ = t;
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
                         const octave_idx_type *p, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
@@ -882,17 +882,17 @@ MatrixType::MatrixType (const matrix_typ
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
                         const octave_idx_type kl, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
     {
       typ = t;
       upper_band = ku;
       lower_band = kl;
@@ -939,17 +939,17 @@ MatrixType::operator = (const MatrixType
 
   return *this;
 }
 
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (!quiet &&
           octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
@@ -963,17 +963,17 @@ MatrixType::type (bool quiet)
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
@@ -996,17 +996,17 @@ MatrixType::type (const SparseMatrix &a)
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -514,34 +514,34 @@ along with Octave; see the file COPYING.
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m1.elem(0,0) == 0.) \
           r = R (m2_nr, m2_nc); \
         else \
           { \
             r = R (m2); \
-            octave_idx_type m2_nnz = m2.nnz(); \
+            octave_idx_type m2_nnz = m2.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = m1.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
             r = R (m1); \
-            octave_idx_type m1_nnz = m1.nnz(); \
+            octave_idx_type m1_nnz = m1.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = r.data(i) OP m2.data(0); \
               } \
             r.maybe_compress (); \
           } \
@@ -607,19 +607,19 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if ((m1.elem (0,0) OP Complex()) == Complex()) \
+        if ((m1.elem (0,0) OP Complex ()) == Complex ()) \
           { \
-            octave_idx_type m2_nnz = m2.nnz(); \
+            octave_idx_type m2_nnz = m2.nnz (); \
             r = R (m2); \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               r.data (i) = m1.elem(0,0) OP r.data(i); \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
@@ -633,27 +633,27 @@ along with Octave; see the file COPYING.
                     r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if ((Complex() OP m1.elem (0,0)) == Complex()) \
+        if ((Complex () OP m1.elem (0,0)) == Complex ()) \
           { \
-            octave_idx_type m1_nnz = m1.nnz(); \
+            octave_idx_type m1_nnz = m1.nnz (); \
             r = R (m1); \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               r.data (i) = r.data(i) OP m2.elem(0,0); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m1_nr, m1_nc, Complex() OP m2.elem(0,0)); \
+            r = R (m1_nr, m1_nc, Complex () OP m2.elem(0,0)); \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
@@ -1825,18 +1825,18 @@ along with Octave; see the file COPYING.
 
 #define SPARSE_ANY_ALL_OP(DIM, INIT_VAL, MT_RESULT, TEST_OP, TEST_TRUE_VAL) \
   SPARSE_BASE_REDUCTION_OP (SparseBoolMatrix, char, \
                         SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
                         SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
                         INIT_VAL, MT_RESULT)
 
 #define SPARSE_ALL_OP(DIM) \
-  if ((rows() == 1 && dim == -1) || dim == 1) \
-    return transpose (). all (0). transpose(); \
+  if ((rows () == 1 && dim == -1) || dim == 1) \
+    return transpose (). all (0). transpose (); \
   else \
     { \
       SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nr ? false : true), \
                          true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
@@ -1845,17 +1845,17 @@ along with Octave; see the file COPYING.
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
    { \
      RET_EL_TYPE s = m.elem(0,0); \
-     octave_idx_type nz = a.nnz(); \
+     octave_idx_type nz = a.nnz (); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
          r.data(i) = s * a.data(i); \
          r.ridx(i) = a.ridx(i); \
        } \
@@ -1866,17 +1866,17 @@ along with Octave; see the file COPYING.
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (a_nr == 1 && a_nc == 1) \
    { \
      RET_EL_TYPE s = a.elem(0,0); \
-     octave_idx_type nz = m.nnz(); \
+     octave_idx_type nz = m.nnz (); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
          r.data(i) = m.data(i) * s; \
          r.ridx(i) = m.ridx(i); \
        } \
@@ -1941,17 +1941,17 @@ along with Octave; see the file COPYING.
           /* it was found that the breakpoints were */ \
           /*   nr: 500  1000  2000  5000 10000 */ \
           /*   nz:   6    25    97   585  2202 */ \
           /* The below is a simplication of the 'polyfit'-ed parameters */ \
           /* to these breakpoints */ \
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
                                         (a_nc * a_nc) / 43000); \
           octave_idx_type ii = 0; \
-          octave_idx_type *ri = retval.xridx(); \
+          octave_idx_type *ri = retval.xridx (); \
           octave_sort<octave_idx_type> sort; \
           \
           for (octave_idx_type i = 0; i < a_nc ; i++) \
             { \
               if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
                 { \
                   for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
                     { \
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -44,17 +44,17 @@ SM octinternal_do_mul_colpm_sm (const oc
       octave_quit ();
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         {
           sidx[ii++]=i;
           r.xridx (i) = pcol[a.ridx (i)];
         }
-      sort.sort (r.xridx() + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
+      sort.sort (r.xridx () + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         r.xdata(i) = a.data (sidx[ii++]);
     }
 
   return r;
 }
 
 template <typename SM>
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
 #include "PermMatrix.h"
 
 template <class T>
 Sparse<T>::Sparse (const PermMatrix& a)
   : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
-         dimensions (dim_vector (a.rows (), a.cols()))
+         dimensions (dim_vector (a.rows (), a.cols ()))
 {
   octave_idx_type n = a.rows ();
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
   const Array<octave_idx_type> pv = a.pvec ();
 
   if (a.is_row_perm ())
@@ -144,17 +144,17 @@ Sparse<T>::SparseRep::maybe_compress (bo
 {
   if (remove_zeros)
     {
       octave_idx_type i = 0, k = 0;
       for (octave_idx_type j = 1; j <= ncols; j++)
         {
           octave_idx_type u = c[j];
           for (i = i; i < u; i++)
-            if (d[i] != T())
+            if (d[i] != T ())
               {
                 d[k] = d[i];
                 r[k++] = r[i];
               }
           c[j] = k;
         }
     }
 
@@ -226,17 +226,17 @@ Sparse<T>::Sparse (octave_idx_type nr, o
         xcidx(j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
-  if (dv.length() != 2)
+  if (dv.length () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
   else
     rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
 template <class T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
@@ -249,17 +249,17 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
   unsigned long long dv_nel = static_cast<unsigned long long>(dv (0)) *
     static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
-      dim_vector old_dims = a.dims();
+      dim_vector old_dims = a.dims ();
       octave_idx_type new_nzmx = a.nnz ();
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
@@ -329,17 +329,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
           for (octave_idx_type j = 0; j < nc; j++)
             xcidx(j+1) = j >= c(0);
         }
     }
   else if (a_scalar)
     {
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
-      if (a0 == T())
+      if (a0 == T ())
         {
           // Do nothing, it's an empty matrix.
         }
       else if (cl == 1)
         {
           // Sparse column vector. Sort row indices.
           idx_vector rs = r.sorted ();
 
@@ -810,17 +810,17 @@ Sparse<T>::reshape (const dim_vector& ne
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
 
   if (dims2.length () > 2)
     {
       (*current_liboctave_warning_handler)
         ("reshape: sparse reshape to N-d array smashes dims");
 
-      for (octave_idx_type i = 2; i < dims2.length(); i++)
+      for (octave_idx_type i = 2; i < dims2.length (); i++)
         dims2(1) *= dims2(i);
 
       dims2.resize (2);
     }
 
   if (dimensions != dims2)
     {
       if (dimensions.numel () == dims2.numel ())
@@ -1613,17 +1613,17 @@ Sparse<T>::index (const idx_vector& idx_
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
       retval = index (idx_i);
 
       // If nr == 1 then the vector indexing will return a column vector!!
       if (nr == 1)
-        retval.transpose();
+        retval.transpose ();
     }
   else if (idx_i.is_scalar ())
     {
       octave_idx_type ii = idx_i(0);
       retval = Sparse<T> (1, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ij, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
@@ -1861,17 +1861,17 @@ Sparse<T>::assign (const idx_vector& idx
             {
               // Elements are being zeroed.
               octave_idx_type *ri = ridx ();
               for (octave_idx_type i = 0; i < rhl; i++)
                 {
                   octave_idx_type iidx = idx(i);
                   octave_idx_type li = lblookup (ri, nz, iidx);
                   if (li != nz && ri[li] == iidx)
-                    xdata(li) = T();
+                    xdata(li) = T ();
                 }
 
               maybe_compress (true);
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
@@ -2584,17 +2584,17 @@ Sparse<T>::cat (int dim, octave_idx_type
 
   return retval;
 }
 
 template <class T>
 Array<T>
 Sparse<T>::array_value () const
 {
-  NoAlias< Array<T> > retval (dims (), T());
+  NoAlias< Array<T> > retval (dims (), T ());
   if (rows () == 1)
     {
       octave_idx_type i = 0;
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         {
           if (cidx(j+1) > i)
             retval(j) = data (i++);
         }
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -294,23 +294,23 @@ public:
 
   T range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const;
   T& range_error (const char *fcn, const Array<octave_idx_type>& ra_idx);
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n)
   {
-    octave_idx_type i = n % rows (), j = n / rows();
+    octave_idx_type i = n % rows (), j = n / rows ();
     return xelem (i, j);
   }
 
   T xelem (octave_idx_type n) const
   {
-    octave_idx_type i = n % rows (), j = n / rows();
+    octave_idx_type i = n % rows (), j = n / rows ();
     return xelem (i, j);
   }
 
   T& xelem (octave_idx_type i, octave_idx_type j) { return rep->elem (i, j); }
   T xelem (octave_idx_type i, octave_idx_type j) const
   {
     return rep->celem (i, j);
   }
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -47,22 +47,22 @@ chol2inv (const SparseComplexMatrix& r)
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
           rinv = r.inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -56,17 +56,17 @@ public:
     {
       if (this != &a)
         sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
           operator = (a);
 
       return *this;
     }
 
-  SparseComplexMatrix chol_matrix (void) const { return R(); }
+  SparseComplexMatrix chol_matrix (void) const { return R (); }
 
   SparseComplexMatrix L (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: L (); }
 
   SparseComplexMatrix R (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: R (); }
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -52,17 +52,17 @@ SparseComplexLU::SparseComplexLU (const 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
-  if (piv_thres.nelem() == 2)
+  if (piv_thres.nelem () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -218,22 +218,22 @@ SparseComplexLU::SparseComplexLU (const 
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
                   UMFPACK_ZNAME (report_matrix) (nr, n_inner,
                                             Lfact.cidx (), Lfact.ridx (),
-                                            reinterpret_cast<double *> (Lfact.data()),
+                                            reinterpret_cast<double *> (Lfact.data ()),
                                             0, 1, control);
 
                   UMFPACK_ZNAME (report_matrix) (n_inner, nc,
                                             Ufact.cidx (), Ufact.ridx (),
-                                            reinterpret_cast<double *> (Ufact.data()),
+                                            reinterpret_cast<double *> (Ufact.data ()),
                                             0, 1, control);
                   UMFPACK_ZNAME (report_perm) (nr, p, control);
                   UMFPACK_ZNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
             }
         }
@@ -261,17 +261,17 @@ SparseComplexLU::SparseComplexLU (const 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
-      if (piv_thres.nelem() == 2)
+      if (piv_thres.nelem () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
@@ -447,23 +447,23 @@ SparseComplexLU::SparseComplexLU (const 
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
                       UMFPACK_ZNAME (report_matrix) (nr, n_inner,
                                                 Lfact.cidx (),
                                                 Lfact.ridx (),
-                                                reinterpret_cast<double *> (Lfact.data()),
+                                                reinterpret_cast<double *> (Lfact.data ()),
                                                 0, 1, control);
 
                       UMFPACK_ZNAME (report_matrix) (n_inner, nc,
                                                 Ufact.cidx (),
                                                 Ufact.ridx (),
-                                                reinterpret_cast<double *> (Ufact.data()),
+                                                reinterpret_cast<double *> (Ufact.data ()),
                                                 0, 1, control);
                       UMFPACK_ZNAME (report_perm) (nr, p, control);
                       UMFPACK_ZNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_ZNAME (report_info) (control, info);
                 }
             }
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -187,24 +187,24 @@ SparseComplexQR::SparseComplexQR_rep::R 
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::C (const ComplexMatrix &b) const
 {
 #ifdef HAVE_CXSPARSE
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec =
-    reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
+    reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix ret(b_nr, b_nc);
-  Complex *vec = ret.fortran_vec();
+  Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
@@ -240,17 +240,17 @@ SparseComplexQR::SparseComplexQR_rep::C 
 
 ComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::Q (void) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   ComplexMatrix ret(nr, nr);
-  Complex *vec = ret.fortran_vec();
+  Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
       OCTAVE_C99_COMPLEX (bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
@@ -289,127 +289,127 @@ SparseComplexQR::SparseComplexQR_rep::Q 
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+        (x.fortran_vec ());
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+        (x.fortran_vec ());
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -417,70 +417,70 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -497,73 +497,73 @@ qrsolve(const SparseComplexMatrix&a, con
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -591,120 +591,120 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
-    reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
+    reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+        (x.fortran_vec ());
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+        (x.fortran_vec ());
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -712,70 +712,70 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -792,72 +792,72 @@ qrsolve(const SparseComplexMatrix&a, con
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -82,17 +82,17 @@ protected:
     SparseComplexQR_rep operator = (const SparseComplexQR_rep&);
 
   };
 private:
   SparseComplexQR_rep *rep;
 
 public:
   SparseComplexQR (void) :
-    rep (new SparseComplexQR_rep (SparseComplexMatrix(), 0)) { }
+    rep (new SparseComplexQR_rep (SparseComplexMatrix (), 0)) { }
 
   SparseComplexQR (const SparseComplexMatrix& a, int order = 0) :
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
     {
@@ -108,30 +108,30 @@ public:
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
-  bool ok (void) const { return rep->ok(); }
+  bool ok (void) const { return rep->ok (); }
 
-  SparseComplexMatrix V (void) const { return rep->V(); }
+  SparseComplexMatrix V (void) const { return rep->V (); }
 
-  ColumnVector Pinv (void) const { return rep->P(); }
+  ColumnVector Pinv (void) const { return rep->P (); }
 
-  ColumnVector P (void) const { return rep->P(); }
+  ColumnVector P (void) const { return rep->P (); }
 
   SparseComplexMatrix R (const bool econ = false) const
     { return rep->R(econ); }
 
   ComplexMatrix C (const ComplexMatrix &b) const { return rep->C(b); }
 
-  ComplexMatrix Q (void) const { return rep->Q(); }
+  ComplexMatrix Q (void) const { return rep->Q (); }
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                                 octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                       const SparseMatrix &b,
                                       octave_idx_type &info);
 
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -169,23 +169,23 @@ SparseQR::SparseQR_rep::R (const bool ec
   return SparseMatrix ();
 #endif
 }
 
 Matrix
 SparseQR::SparseQR_rep::C (const Matrix &b) const
 {
 #ifdef HAVE_CXSPARSE
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
-  const double *bvec = b.fortran_vec();
+  const double *bvec = b.fortran_vec ();
   Matrix ret (b_nr, b_nc);
-  double *vec = ret.fortran_vec();
+  double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
@@ -221,17 +221,17 @@ SparseQR::SparseQR_rep::C (const Matrix 
 
 Matrix
 SparseQR::SparseQR_rep::Q (void) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   Matrix ret (nr, nr);
-  double *vec = ret.fortran_vec();
+  double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = Matrix (nc, nr, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
       for (octave_idx_type i = 0; i < nr; i++)
@@ -270,103 +270,103 @@ SparseQR::SparseQR_rep::Q (void) const
 #endif
 }
 
 Matrix
 qrsolve(const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
-  const double *bvec = b.fortran_vec();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  const double *bvec = b.fortran_vec ();
   Matrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return Matrix();
+        return Matrix ();
       x.resize(nc, b_nc);
-      double *vec = x.fortran_vec();
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      double *vec = x.fortran_vec ();
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return Matrix();
+        return Matrix ();
       x.resize(nc, b_nc);
-      double *vec = x.fortran_vec();
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      double *vec = x.fortran_vec ();
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -374,66 +374,66 @@ qrsolve(const SparseMatrix&a, const Matr
 #endif
 }
 
 SparseMatrix
 qrsolve(const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   SparseMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return SparseMatrix();
-      x = SparseMatrix (nc, b_nc, b.nnz());
+        return SparseMatrix ();
+      x = SparseMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -450,54 +450,54 @@ qrsolve(const SparseMatrix&a, const Spar
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return SparseMatrix();
-      x = SparseMatrix (nc, b_nc, b.nnz());
+        return SparseMatrix ();
+      x = SparseMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -525,164 +525,164 @@ qrsolve(const SparseMatrix&a, const Spar
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
-      Complex *vec = x.fortran_vec();
+      Complex *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
-      Complex *vec = x.fortran_vec();
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      Complex *vec = x.fortran_vec ();
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
 
@@ -692,95 +692,95 @@ qrsolve(const SparseMatrix&a, const Comp
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
@@ -797,83 +797,83 @@ qrsolve(const SparseMatrix&a, const Spar
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -84,17 +84,17 @@ protected:
   };
 
 private:
 
   SparseQR_rep *rep;
 
 public:
 
-  SparseQR (void) : rep (new SparseQR_rep (SparseMatrix(), 0)) { }
+  SparseQR (void) : rep (new SparseQR_rep (SparseMatrix (), 0)) { }
 
   SparseQR (const SparseMatrix& a, int order = 0) :
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
     {
@@ -110,29 +110,29 @@ public:
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
-  bool ok (void) const { return rep->ok(); }
+  bool ok (void) const { return rep->ok (); }
 
-  SparseMatrix V (void) const { return rep->V(); }
+  SparseMatrix V (void) const { return rep->V (); }
 
-  ColumnVector Pinv (void) const { return rep->P(); }
+  ColumnVector Pinv (void) const { return rep->P (); }
 
-  ColumnVector P (void) const { return rep->P(); }
+  ColumnVector P (void) const { return rep->P (); }
 
   SparseMatrix R (const bool econ = false) const { return rep->R(econ); }
 
   Matrix C (const Matrix &b) const { return rep->C(b); }
 
-  Matrix Q (void) const { return rep->Q(); }
+  Matrix Q (void) const { return rep->Q (); }
 
   friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b,
                          octave_idx_type &info);
 
   friend SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
                          octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -47,22 +47,22 @@ chol2inv (const SparseMatrix& r)
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
           rinv = r.inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -50,17 +50,17 @@ public:
   SparseCHOL& operator = (const SparseCHOL& a)
     {
       if (this != &a)
         sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
 
       return *this;
     }
 
-  SparseMatrix chol_matrix (void) const { return R(); }
+  SparseMatrix chol_matrix (void) const { return R (); }
 
   SparseMatrix L (void) const
   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
 
   SparseMatrix R (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
 
   octave_idx_type P (void) const
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -52,17 +52,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
-  if (piv_thres.nelem() == 2)
+  if (piv_thres.nelem () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -248,17 +248,17 @@ SparseLU::SparseLU (const SparseMatrix& 
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
-      if (piv_thres.nelem() == 2)
+      if (piv_thres.nelem () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -31,21 +31,21 @@ class
 OCTAVE_API
 SparseLU : public sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
 {
 public:
 
   SparseLU (void)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> () { }
 
-  SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix(),
+  SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix (),
             bool scale = false);
 
   SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
-            const Matrix& piv_thres = Matrix(), bool scale = false,
+            const Matrix& piv_thres = Matrix (), bool scale = false,
             bool FixedQ = false, double droptol = -1.,
             bool milu = false, bool udiag = false);
 
   SparseLU (const SparseLU& a)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> (a) { }
 
   SparseLU& operator = (const SparseLU& a)
     {
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -106,34 +106,34 @@ base_lu <lu_type> :: U (void) const
     return a_fact;
 }
 
 template <class lu_type>
 lu_type
 base_lu <lu_type> :: Y (void) const
 {
   if (! packed ())
-    (*current_liboctave_error_handler) ("lu: Y() not implemented for unpacked form");
+    (*current_liboctave_error_handler) ("lu: Y () not implemented for unpacked form");
   return a_fact;
 }
 
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
 
       Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
 
       for (octave_idx_type i = 0; i < a_nr; i++)
         pvt.xelem (i) = i;
 
-      for (octave_idx_type i = 0; i < ipvt.length(); i++)
+      for (octave_idx_type i = 0; i < ipvt.length (); i++)
         {
           octave_idx_type k = ipvt.xelem (i);
 
           if (k != i)
             {
               octave_idx_type tmp = pvt.xelem (k);
               pvt.xelem (k) = pvt.xelem (i);
               pvt.xelem (i) = tmp;
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -160,25 +160,25 @@ gnu_history::do_histcontrol (void) const
 
   std::string retval;
 
   if (history_control & HC_IGNSPACE)
     retval.append ("ignorespace");
 
   if (history_control & HC_IGNDUPS)
     {
-      if (retval.length() > 0)
+      if (retval.length () > 0)
         retval.append (":");
 
       retval.append ("ignoredups");
     }
 
   if (history_control & HC_ERASEDUPS)
     {
-      if (retval.length() > 0)
+      if (retval.length () > 0)
         retval.append (":");
 
       retval.append ("erasedups");
     }
 
   return retval;
 }
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -138,17 +138,17 @@ ColumnVector::stack (const ColumnVector&
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 RowVector
 ColumnVector::transpose (void) const
 {
-  return MArray<double>::transpose();
+  return MArray<double>::transpose ();
 }
 
 ColumnVector
 ColumnVector::abs (void) const
 {
   return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
@@ -303,17 +303,17 @@ operator << (std::ostream& os, const Col
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -69,17 +69,17 @@ public:
 
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
   DiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   DiagMatrix& fill (const RowVector& a, octave_idx_type beg);
 
-  DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose(); }
+  DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API DiagMatrix real (const ComplexDiagMatrix& a);
   friend OCTAVE_API DiagMatrix imag (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -758,17 +758,17 @@ Matrix::finverse (MatrixType &mattype, o
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
-        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -797,17 +797,17 @@ Matrix::finverse (MatrixType &mattype, o
           F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
           if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                  int force, int calc_cond) const
@@ -1456,18 +1456,18 @@ Matrix::rcond (MatrixType &mattype) cons
           double anorm = -1.0;
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1494,18 +1494,18 @@ Matrix::rcond (MatrixType &mattype) cons
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1757,17 +1757,17 @@ Matrix::fsolve (MatrixType &mattype, con
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1813,17 +1813,17 @@ Matrix::fsolve (MatrixType &mattype, con
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -1834,17 +1834,17 @@ Matrix::fsolve (MatrixType &mattype, con
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1897,17 +1897,17 @@ Matrix::fsolve (MatrixType &mattype, con
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -155,44 +155,44 @@ NDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const double *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   ComplexNDArray retval (*this);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -339,17 +339,17 @@ NDArray::ifourier (int dim) const
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -387,17 +387,17 @@ NDArray::fourier2d (void) const
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -141,17 +141,17 @@ RowVector::append (const RowVector& a) c
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ColumnVector
 RowVector::transpose (void) const
 {
-  return MArray<double>::transpose();
+  return MArray<double>::transpose ();
 }
 
 RowVector
 real (const ComplexRowVector& a)
 {
   return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
@@ -266,17 +266,17 @@ operator << (std::ostream& os, const Row
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, RowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -714,17 +714,17 @@ atan2 (const SparseMatrix& x, const doub
     return retval;
 }
 
 SparseMatrix
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
 {
   SparseMatrix r;
 
-  if ((x.rows() == y.rows()) && (x.cols() == y.cols()))
+  if ((x.rows () == y.rows ()) && (x.cols () == y.cols ()))
     {
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
@@ -832,22 +832,22 @@ SparseMatrix::dinverse (MatrixType &matt
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose();
+            retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
-          double *v = retval.data();
+          double *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = fabs(v[i]);
                   if (tmp > dmax)
@@ -1017,17 +1017,17 @@ SparseMatrix::tinverse (MatrixType &matt
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseMatrix (nr, nc, nz2);
 
               OCTAVE_LOCAL_BUFFER (double, work, nr);
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-              octave_idx_type *perm = mattyp.triangular_perm();
+              octave_idx_type *perm = mattyp.triangular_perm ();
               if (typ == MatrixType::Permuted_Upper)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     rperm[perm[i]] = i;
                 }
               else
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
@@ -1137,77 +1137,77 @@ SparseMatrix::tinverse (MatrixType &matt
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
-  return SparseMatrix();
+  return SparseMatrix ();
 }
 
 SparseMatrix
 SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                        double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
+    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose ();
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     {
-      MatrixType newtype = mattype.transpose();
-      ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
+      MatrixType newtype = mattype.transpose ();
+      ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
-      if (mattype.is_hermitian())
+      if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseCHOL fact (*this, info, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
-              SparseMatrix Q = fact.Q();
-              SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
+              SparseMatrix Q = fact.Q ();
+              SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
                                            info, rcond2, true, false);
-              ret = Q * InvL.transpose() * InvL * Q.transpose();
+              ret = Q * InvL.transpose () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
         }
 
-      if (!mattype.is_hermitian())
+      if (!mattype.is_hermitian ())
         {
-          octave_idx_type n = rows();
+          octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          SparseLU fact (*this, Qinit, Matrix(), false, false);
-          rcond = fact.rcond();
+          SparseLU fact (*this, Qinit, Matrix (), false, false);
+          rcond = fact.rcond ();
           double rcond2;
-          SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
+          SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
                                            info, rcond2, true, false);
-          SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
-                                           true, false).transpose();
-          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+          SparseMatrix InvU = fact.U ().tinverse(tmp_typ, info, rcond2,
+                                           true, false).transpose ();
+          ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 DET
 SparseMatrix::determinant (void) const
@@ -1361,23 +1361,23 @@ SparseMatrix::dsolve (MatrixType &mattyp
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), 0.);
+          retval.resize (nc, b.cols (), 0.);
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1511,23 +1511,23 @@ SparseMatrix::dsolve (MatrixType &mattyp
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), 0);
+          retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1578,29 +1578,29 @@ SparseMatrix::dsolve (MatrixType &mattyp
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -3884,22 +3884,22 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx(i) == j)
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3941,22 +3941,22 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4183,17 +4183,17 @@ SparseMatrix::trisolve (MatrixType &matt
                     if (ridx(i) == j)
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
@@ -4240,18 +4240,18 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
@@ -4501,17 +4501,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4565,17 +4565,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows(), err
+                             ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
@@ -4688,17 +4688,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (dgbtrs, DGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows(), err
+                             ldm, pipvt, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4751,17 +4751,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5069,17 +5069,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5159,17 +5159,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
-                                 ldm, Bz, b.rows(), err
+                                 ldm, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
@@ -5368,17 +5368,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5848,49 +5848,49 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_REAL;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<double *>(b.fortran_vec());
+            B->x = const_cast<double *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -5925,21 +5925,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -5960,17 +5960,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
           void *Numeric =
             factorize (err, rcond, Control, Info, sing_handler, calc_cond);
 
           if (err == 0)
             {
               const double *Bx = b.fortran_vec ();
-              retval.resize (b.rows (), b.cols());
+              retval.resize (b.rows (), b.cols ());
               double *result = retval.fortran_vec ();
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
@@ -6064,59 +6064,59 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6326,49 +6326,49 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_COMPLEX;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<Complex *>(b.fortran_vec());
+            B->x = const_cast<Complex *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6402,21 +6402,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -6560,59 +6560,59 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -7490,18 +7490,18 @@ SparseMatrix
 SparseMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseMatrix, double, cumsum);
 }
 
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
-  if ((rows() == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose();
+  if ((rows () == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
@@ -7760,17 +7760,17 @@ min (const SparseMatrix& m, double d)
   return min (d, m);
 }
 
 SparseMatrix
 min (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
@@ -7910,17 +7910,17 @@ max (const SparseMatrix& m, double d)
   return max (d, m);
 }
 
 SparseMatrix
 max (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -152,17 +152,17 @@ chol2inv_internal (const Matrix& r)
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       Matrix tmp = r;
-      double *v = tmp.fortran_vec();
+      double *v = tmp.fortran_vec ();
 
       if (info == 0)
         {
           F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                      v, n, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // If someone thinks of a more graceful way of doing this (or
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -65,17 +65,17 @@ GEPBALANCE::init (const Matrix& a, const
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -40,17 +40,17 @@ dim_vector::dim_max (void)
 }
 
 void
 dim_vector::chop_all_singletons (void)
 {
   make_unique ();
 
   int j = 0;
-  int l = ndims();
+  int l = ndims ();
 
   for (int i = 0; i < l; i++)
     {
       if (rep[i] != 1)
         rep[j++] = rep[i];
     }
 
   if (j == 1)
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -221,24 +221,24 @@ lusolve (const SM& L, const SM& U, M& m)
 
   return err;
 }
 
 template <class SM, class M>
 static M
 ltsolve (const SM& L, const ColumnVector& Q, const M& m)
 {
-  octave_idx_type n = L.cols();
-  octave_idx_type b_nc = m.cols();
+  octave_idx_type n = L.cols ();
+  octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
   M tmp = L.solve (ltyp, m, err, rcond, 0);
   M retval;
-  const double* qv = Q.fortran_vec();
+  const double* qv = Q.fortran_vec ();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
             retval.elem(static_cast<octave_idx_type>(qv[i]), j)  =
@@ -248,24 +248,24 @@ ltsolve (const SM& L, const ColumnVector
 
   return retval;
 }
 
 template <class SM, class M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
 {
-  octave_idx_type n = U.cols();
-  octave_idx_type b_nc = m.cols();
+  octave_idx_type n = U.cols ();
+  octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   M retval (n, b_nc);
-  const double* qv = Q.fortran_vec();
+  const double* qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
     }
   return U.solve (utyp, retval, err, rcond, 0);
 }
 
@@ -342,120 +342,120 @@ vector_product (const ComplexMatrix& m, 
     return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   CHOL fact (b, info);
-  octave_idx_type n = b.cols();
+  octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.transpose();
+      b =  bt.transpose ();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   SparseCHOL fact (b, info, false);
 
-  if (fact.P() != 0)
+  if (fact.P () != 0)
     return false;
   else
     {
-      b = fact.L();
-      bt = b.transpose();
-      permB = fact.perm() - 1.0;
+      b = fact.L ();
+      bt = b.transpose ();
+      permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
 make_cholb (ComplexMatrix& b, ComplexMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   ComplexCHOL fact (b, info);
-  octave_idx_type n = b.cols();
+  octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.hermitian();
+      b =  bt.hermitian ();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
             ColumnVector& permB)
 {
   octave_idx_type info;
   SparseComplexCHOL fact (b, info, false);
 
-  if (fact.P() != 0)
+  if (fact.P () != 0)
     return false;
   else
     {
-      b = fact.L();
-      bt = b.hermitian();
-      permB = fact.perm() - 1.0;
+      b = fact.L ();
+      bt = b.hermitian ();
+      permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
 LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 SparseMatrix &L, SparseMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.rows();
+  octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length())
+          if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
                   tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
-                b.transpose() * b * tmp.transpose();
+                b.transpose () * b * tmp.transpose ();
             }
           else
             AminusSigmaB = AminusSigmaB - sigma *
-              b.transpose() * b;
+              b.transpose () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
@@ -517,55 +517,55 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
 static bool
 LuAminusSigmaB (const Matrix &m, const Matrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 Matrix &L, Matrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.cols();
+  octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          Matrix tmp = sigma * b.transpose() * b;
-          const double *pB = permB.fortran_vec();
-          double *p = AminusSigmaB.fortran_vec();
-
-          if (permB.length())
+          Matrix tmp = sigma * b.transpose () * b;
+          const double *pB = permB.fortran_vec ();
+          double *p = AminusSigmaB.fortran_vec ();
+
+          if (permB.length ())
             {
               for (octave_idx_type j = 0;
-                   j < b.cols(); j++)
+                   j < b.cols (); j++)
                 for (octave_idx_type i = 0;
-                     i < b.rows(); i++)
+                     i < b.rows (); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
-      double *p = AminusSigmaB.fortran_vec();
+      double *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
   LU fact (AminusSigmaB);
 
-  L = fact.P().transpose() * fact.L ();
+  L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
@@ -594,42 +594,42 @@ LuAminusSigmaB (const Matrix &m, const M
 
 static bool
 LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 SparseComplexMatrix &L, SparseComplexMatrix &U,
                 octave_idx_type *P, octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.rows();
+  octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length())
+          if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
                   tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
-              AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b *
-                tmp.transpose() * sigma;
+              AminusSigmaB = AminusSigmaB - tmp * b.hermitian () * b *
+                tmp.transpose () * sigma;
             }
           else
-            AminusSigmaB = AminusSigmaB - sigma * b.hermitian() * b;
+            AminusSigmaB = AminusSigmaB - sigma * b.hermitian () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseComplexMatrix sigmat (n, n, n);
 
@@ -691,55 +691,55 @@ LuAminusSigmaB (const SparseComplexMatri
 
 static bool
 LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.cols();
+  octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          ComplexMatrix tmp = sigma * b.hermitian() * b;
-          const double *pB = permB.fortran_vec();
-          Complex *p = AminusSigmaB.fortran_vec();
-
-          if (permB.length())
+          ComplexMatrix tmp = sigma * b.hermitian () * b;
+          const double *pB = permB.fortran_vec ();
+          Complex *p = AminusSigmaB.fortran_vec ();
+
+          if (permB.length ())
             {
               for (octave_idx_type j = 0;
-                   j < b.cols(); j++)
+                   j < b.cols (); j++)
                 for (octave_idx_type i = 0;
-                     i < b.rows(); i++)
+                     i < b.rows (); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
-      Complex *p = AminusSigmaB.fortran_vec();
+      Complex *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
   ComplexLU fact (AminusSigmaB);
 
-  L = fact.P().transpose() * fact.L ();
+  L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
@@ -774,37 +774,37 @@ EigsRealSymmetricMatrix (const M& m, con
                          ColumnVector &eig_val, const M& _b,
                          ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -833,20 +833,20 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -883,18 +883,18 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.transpose();
-          if (permB.length() == 0)
+          b = b.transpose ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -934,17 +934,17 @@ EigsRealSymmetricMatrix (const M& m, con
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1095,40 +1095,40 @@ EigsRealSymmetricMatrixShift (const M& m
                               ColumnVector &eig_val, const M& _b,
                               ColumnVector &permB, ColumnVector &resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1157,20 +1157,20 @@ EigsRealSymmetricMatrixShift (const M& m
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -1210,34 +1210,34 @@ EigsRealSymmetricMatrixShift (const M& m
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1425,19 +1425,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
                        bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1528,17 +1528,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1687,38 +1687,38 @@ EigsRealNonSymmetricMatrix (const M& m, 
                             ComplexColumnVector &eig_val, const M& _b,
                             ColumnVector &permB, ColumnVector &resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1747,20 +1747,20 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -1797,18 +1797,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.transpose();
-          if (permB.length() == 0)
+          b = b.transpose ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -1848,17 +1848,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
@@ -2057,41 +2057,41 @@ EigsRealNonSymmetricMatrixShift (const M
                                  ComplexColumnVector &eig_val, const M& _b,
                                  ColumnVector &permB, ColumnVector &resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -2120,20 +2120,20 @@ EigsRealNonSymmetricMatrixShift (const M
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -2173,34 +2173,34 @@ EigsRealNonSymmetricMatrixShift (const M
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigmar, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -2442,19 +2442,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 {
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -2546,17 +2546,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
@@ -2752,37 +2752,37 @@ EigsComplexNonSymmetricMatrix (const M& 
                                ColumnVector &permB,
                                ComplexColumnVector &cresid,
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -2815,20 +2815,20 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -2865,18 +2865,18 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.hermitian();
-          if (permB.length() == 0)
+          b = b.hermitian ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -2917,17 +2917,17 @@ EigsComplexNonSymmetricMatrix (const M& 
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
@@ -3074,40 +3074,40 @@ EigsComplexNonSymmetricMatrixShift (cons
                                     ColumnVector &permB,
                                     ComplexColumnVector &cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -3140,20 +3140,20 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -3193,35 +3193,35 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
@@ -3412,19 +3412,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (std::abs(sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -3520,17 +3520,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -26,10 +26,10 @@ along with Octave; see the file COPYING.
 /* Dummy Fortran main declaration, needed in order to link to some
    Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #ifdef F77_DUMMY_MAIN
 #  ifdef __cplusplus
 extern "C"
 #  endif
-int F77_DUMMY_MAIN() { assert(0); return 1; }
+int F77_DUMMY_MAIN () { assert(0); return 1; }
 #endif
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -509,17 +509,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -85,17 +85,17 @@ public:
   FloatComplexDiagMatrix& fill (const FloatRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a, octave_idx_type beg);
 
   FloatComplexDiagMatrix hermitian (void) const { return MDiagArray2<FloatComplex>::hermitian (std::conj); }
-  FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose(); }
+  FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose (); }
   FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatComplexDiagMatrix conj (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1086,17 +1086,17 @@ FloatComplexMatrix::finverse (MatrixType
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1124,17 +1124,17 @@ FloatComplexMatrix::finverse (MatrixType
           F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
           if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         float& rcon, int force, int calc_cond) const
@@ -1150,17 +1150,17 @@ FloatComplexMatrix::inverse (MatrixType 
   else
     {
       if (mattype.is_hermitian ())
         {
           FloatComplexCHOL chol (*this, info, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
-                rcon = chol.rcond();
+                rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
@@ -1784,18 +1784,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           float anorm = -1.0;
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1824,18 +1824,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2091,17 +2091,17 @@ FloatComplexMatrix::fsolve (MatrixType &
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2147,17 +2147,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2175,17 +2175,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2233,17 +2233,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
     }
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -114,45 +114,45 @@ FloatComplexNDArray::ifourier (int dim) 
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -343,17 +343,17 @@ FloatComplexNDArray::fourier2d (void) co
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -406,17 +406,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -64,17 +64,17 @@ FloatComplexGEPBALANCE::init (const Floa
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -137,17 +137,17 @@ FloatColumnVector::stack (const FloatCol
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 FloatRowVector
 FloatColumnVector::transpose (void) const
 {
-  return MArray<float>::transpose();
+  return MArray<float>::transpose ();
 }
 
 FloatColumnVector
 FloatColumnVector::abs (void) const
 {
   return do_mx_unary_map<float, float, std::abs> (*this);
 }
 
@@ -302,17 +302,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -69,17 +69,17 @@ public:
 
   FloatDiagMatrix& fill (float val);
   FloatDiagMatrix& fill (float val, octave_idx_type beg, octave_idx_type end);
   FloatDiagMatrix& fill (const FloatColumnVector& a);
   FloatDiagMatrix& fill (const FloatRowVector& a);
   FloatDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
 
-  FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose(); }
+  FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose (); }
   FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatDiagMatrix real (const FloatComplexDiagMatrix& a);
   friend OCTAVE_API FloatDiagMatrix imag (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -681,17 +681,17 @@ FloatEIG::init (const FloatComplexMatrix
       (*current_liboctave_error_handler)
         ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
-  if (n != a.cols () || nb != b.cols())
+  if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   if (n != nb)
     {
       (*current_liboctave_error_handler) ("EIG requires same size matrices");
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -758,17 +758,17 @@ FloatMatrix::finverse (MatrixType &matty
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
-        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -797,17 +797,17 @@ FloatMatrix::finverse (MatrixType &matty
           F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
           if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                  int force, int calc_cond) const
@@ -1456,18 +1456,18 @@ FloatMatrix::rcond (MatrixType &mattype)
           float anorm = -1.0;
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1494,18 +1494,18 @@ FloatMatrix::rcond (MatrixType &mattype)
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1757,17 +1757,17 @@ FloatMatrix::fsolve (MatrixType &mattype
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1813,17 +1813,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (spotrs, SPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -1834,17 +1834,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1897,17 +1897,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (sgetrs, SGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -113,44 +113,44 @@ FloatNDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const float *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   FloatComplexNDArray retval (*this);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -299,17 +299,17 @@ FloatNDArray::ifourier (int dim) const
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -347,17 +347,17 @@ FloatNDArray::fourier2d (void) const
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -141,17 +141,17 @@ FloatRowVector::append (const FloatRowVe
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 FloatColumnVector
 FloatRowVector::transpose (void) const
 {
-  return MArray<float>::transpose();
+  return MArray<float>::transpose ();
 }
 
 FloatRowVector
 real (const FloatComplexRowVector& a)
 {
   return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
@@ -266,17 +266,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -351,17 +351,17 @@ file_ops::tilde_expand (const string_vec
   return retval;
 }
 
 std::string
 file_ops::concat (const std::string& dir, const std::string& file)
 {
   return dir.empty ()
     ? file
-    : (is_dir_sep (dir[dir.length()-1])
+    : (is_dir_sep (dir[dir.length ()-1])
        ? dir + file
        : dir + dir_sep_char () + file);
 }
 
 
 int
 octave_mkdir (const std::string& nm, mode_t md)
 {
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -184,17 +184,17 @@ file_stat::update_internal (bool force)
       fail = false;
 
       std::string full_file_name = file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
       // Remove trailing slash.
       if (file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
           && full_file_name.length () != 1
-          && ! (full_file_name.length() == 3 && full_file_name[1] == ':'))
+          && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
 
       int status = follow_links
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -152,17 +152,17 @@ chol2inv_internal (const FloatMatrix& r)
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       FloatMatrix tmp = r;
-      float *v = tmp.fortran_vec();
+      float *v = tmp.fortran_vec ();
 
       if (info == 0)
         {
           F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                      v, n, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // If someone thinks of a more graceful way of doing this (or
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -65,17 +65,17 @@ FloatGEPBALANCE::init (const FloatMatrix
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -599,17 +599,17 @@ public:
 
   octave_idx_type orig_rows (void) const
     { return orig_dimensions () (0); }
 
   octave_idx_type orig_columns (void) const
     { return orig_dimensions () (1); }
 
   int orig_empty (void) const
-    { return (! is_colon () && orig_dimensions().any_zero ()); }
+    { return (! is_colon () && orig_dimensions ().any_zero ()); }
 
   // i/o
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
     { return a.print (os); }
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -455,17 +455,17 @@ expm1 (double x)
 
 Complex
 expm1(const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
-      double im = x.imag();
+      double im = x.imag ();
       double u = expm1 (x.real ());
       double v = sin (im/2);
       v = -2*v*v;
       retval = Complex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - Complex (1);
 
@@ -510,17 +510,17 @@ expm1f (float x)
 
 FloatComplex
 expm1(const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
-      float im = x.imag();
+      float im = x.imag ();
       float u = expm1 (x.real ());
       float v = sin (im/2);
       v = -2*v*v;
       retval = FloatComplex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - FloatComplex (1);
 
@@ -551,17 +551,17 @@ log1p (double x)
 }
 #endif
 
 Complex
 log1p (const Complex& x)
 {
   Complex retval;
 
-  double r = x.real (), i = x.imag();
+  double r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
       retval = Complex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
@@ -868,17 +868,17 @@ zbesi (const Complex& z, double alpha, i
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
             * zbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real()));
+              tmp2 *= exp(-z - std::abs(z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = Complex (octave_NaN, octave_NaN);
@@ -1478,17 +1478,17 @@ cbesi (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
             * cbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real()));
+              tmp2 *= exp(-z - std::abs(z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -68,34 +68,34 @@ octave_getcwd (void)
 }
 
 int
 octave_chdir (const std::string& path_arg)
 {
   std::string path = file_ops::tilde_expand (path_arg);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
-  if (path.length() == 2 && path[1] == ':')
+  if (path.length () == 2 && path[1] == ':')
     path += "\\";
 #endif
 
   return gnulib::chdir (path.c_str ());
 }
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 pid_t
 octave_popen2 (const std::string& cmd, const string_vector& args, bool sync_mode,
     int *fildes, std::string& msg)
 {
   pid_t pid;
   PROCESS_INFORMATION pi;
   STARTUPINFO si;
   std::string command = "\"" + cmd + "\"";
-  HANDLE hProcess = GetCurrentProcess(), childRead, childWrite, parentRead, parentWrite;
+  HANDLE hProcess = GetCurrentProcess (), childRead, childWrite, parentRead, parentWrite;
   DWORD pipeMode;
 
   ZeroMemory (&pi, sizeof (pi));
   ZeroMemory (&si, sizeof (si));
   si.cb = sizeof (si);
 
   if (! CreatePipe (&childRead, &parentWrite, 0, 0) ||
       ! DuplicateHandle (hProcess, childRead, hProcess, &childRead, 0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
@@ -116,17 +116,17 @@ octave_popen2 (const std::string& cmd, c
     }
   fildes[1] = _open_osfhandle (reinterpret_cast<long> (parentRead), _O_RDONLY | _O_BINARY);
   fildes[0] = _open_osfhandle (reinterpret_cast<long> (parentWrite), _O_WRONLY | _O_BINARY);
   si.dwFlags |= STARTF_USESTDHANDLES;
   si.hStdInput = childRead;
   si.hStdOutput = childWrite;
 
   // Ignore first arg as it is the command
-  for (int k=1; k<args.length(); k++)
+  for (int k=1; k<args.length (); k++)
     command += " \"" + args[k] + "\"";
   OCTAVE_LOCAL_BUFFER (char, c_command, command.length () + 1);
   strcpy (c_command, command.c_str ());
   if (! CreateProcess (0, c_command, 0, 0, TRUE, 0, 0, 0, &si, &pi))
     {
       msg = "popen2: process creation failed";
       return -1;
     }
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -57,17 +57,17 @@ template <class R> \
 inline void F (size_t n, R *r) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = OP r[i]; }
 
 DEFMXUNOPEQ (mx_inline_uminus2, -)
 
 #define DEFMXUNBOOLOP(F, OP) \
 template <class X> \
 inline void F (size_t n, bool *r, const X *x) throw () \
-{ const X zero = X(); for (size_t i = 0; i < n; i++) r[i] = x[i] OP zero; }
+{ const X zero = X (); for (size_t i = 0; i < n; i++) r[i] = x[i] OP zero; }
 
 DEFMXUNBOOLOP (mx_inline_iszero, ==)
 DEFMXUNBOOLOP (mx_inline_notzero, !=)
 
 #define DEFMXBINOP(F, OP) \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y[i]; } \
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -260,17 +260,17 @@ binmap (const Sparse<T>& xs, const Spars
     return binmap<U, T, R, F> (xs, ys(0,0), fcn);
   else if (xs.dims () != ys.dims ())
     gripe_nonconformant (name, xs.dims (), ys.dims ());
 
   T xzero = T ();
   R yzero = R ();
 
   U fz = fcn (xzero, yzero);
-  if (fz == U())
+  if (fz == U ())
     {
       // Sparsity-preserving function. Do it efficiently.
       octave_idx_type nr = xs.rows (), nc = xs.cols ();
       Sparse<T> retval (nr, nc);
 
       octave_idx_type nz = 0;
       // Count nonzeros.
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -120,17 +120,17 @@ convolve (const MArray<T>& a, const MArr
       if (ct == convn_valid)
         cdims(i) = std::max (adims(i) - bdims(i) + 1,
                              static_cast<octave_idx_type> (0));
       else
         cdims(i) = std::max (adims(i) + bdims(i) - 1,
                              static_cast<octave_idx_type> (0));
     }
 
-  MArray<T> c (cdims, T());
+  MArray<T> c (cdims, T ());
 
   convolve_nd<T, R> (a.fortran_vec (), adims, adims.cumulative (),
                      b.fortran_vec (), bdims, bdims.cumulative (),
                      c.fortran_vec (), cdims.cumulative (), nd, ct == convn_valid);
 
   if (ct == convn_same)
     {
       // Pick the relevant part.
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -74,12 +74,12 @@ oct_md5_file (const std::string file)
 
       if (! errflag)
         retval = oct_md5_result_to_str (buf);
       else
         (*current_liboctave_error_handler) ("internal error in md5_stream");
     }
   else
     (*current_liboctave_error_handler) ("unable to open file `%s' for reading",
-                                        file.c_str());
+                                        file.c_str ());
 
   return retval;
 }
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -87,17 +87,17 @@ template <class T>
 inline bool helper_is_zero_mem (const std::complex<T>& value)
 {
   return (helper_is_zero_mem (value.real ())
           && helper_is_zero_mem (value.imag ()));
 }
 
 template <class T>
 inline bool helper_is_zero_mem (const octave_int<T>& value)
-{ return value.value () == T(); }
+{ return value.value () == T (); }
 
 #define DEFINE_POD_FILL(T) \
 inline void fill_or_memset (size_t n, const T& value, T *dest) \
 { \
   if (helper_is_zero_mem (value)) \
     std::memset (dest, 0, n * sizeof (T)); \
   else \
     std::fill_n (dest, n, value); \
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -508,66 +508,66 @@ Array<double>
 octave_rand::do_vector (octave_idx_type n, double a)
 {
   Array<double> retval;
 
   if (n > 0)
     {
       retval.clear (n, 1);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
   else if (n < 0)
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
 
 Array<float>
 octave_rand::do_float_vector (octave_idx_type n, float a)
 {
   Array<float> retval;
 
   if (n > 0)
     {
       retval.clear (n, 1);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
   else if (n < 0)
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
 
 NDArray
 octave_rand::do_nd_array (const dim_vector& dims, double a)
 {
   NDArray retval;
 
   if (! dims.all_zero ())
     {
       retval.clear (dims);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
 
   return retval;
 }
 
 FloatNDArray
 octave_rand::do_float_nd_array (const dim_vector& dims, float a)
 {
   FloatNDArray retval;
 
   if (! dims.all_zero ())
     {
       retval.clear (dims);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
 
   return retval;
 }
 
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.  The
 // technique used below will cycle monthly, but it it does seem to
@@ -575,21 +575,21 @@ octave_rand::do_float_nd_array (const di
 
 void
 octave_rand::initialize_ranlib_generators (void)
 {
   octave_localtime tm;
   int stored_distribution = current_distribution;
   F77_FUNC (setcgn, SETCGN) (uniform_dist);
 
-  int hour = tm.hour() + 1;
-  int minute = tm.min() + 1;
-  int second = tm.sec() + 1;
+  int hour = tm.hour () + 1;
+  int minute = tm.min () + 1;
+  int second = tm.sec () + 1;
 
-  int32_t s0 = tm.mday() * hour * minute * second;
+  int32_t s0 = tm.mday () * hour * minute * second;
   int32_t s1 = hour * minute * second;
 
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
   F77_FUNC (setall, SETALL) (s0, s1);
   F77_FUNC (setcgn, SETCGN) (stored_distribution);
 }
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -351,17 +351,17 @@ octave_syscalls::popen2 (const std::stri
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
 
-              (*current_liboctave_error_handler)(child_msg.c_str());
+              (*current_liboctave_error_handler)(child_msg.c_str ());
 
               exit(0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -53,17 +53,17 @@ gamma(a,b) for a>0, b>0 (from R)
 beta(a,b) for a>0, b>0
   r1 = randg(a,1)
   r = r1 / (r1 + randg(b,1))
 Erlang(a,n)
   r = a*randg(n)
 chisq(df) for df>0
   r = 2*randg(df/2)
 t(df) for 0<df<inf (use randn if df is infinite)
-  r = randn() / sqrt(2*randg(df/2)/df)
+  r = randn () / sqrt(2*randg(df/2)/df)
 F(n1,n2) for 0<n1, 0<n2
   r1 = 2*randg(n1/2)/n1 or 1 if n1 is infinite
   r2 = 2*randg(n2/2)/n2 or 1 if n2 is infinite
   r = r1 / r2
 negative binonial (n, p) for n>0, 0<p<=1
   r = randp((1-p)/p * randg(n))
   (from R, citing Devroye(1986), Non-Uniform Random Variate Generation)
 non-central chisq(df,L), for df>=0 and L>0 (use chisq if L=0)
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -272,17 +272,17 @@ oct_init_by_entropy (void)
           }
         fclose(urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N)
       entropy[n++] = time(NULL); /* Current time in seconds */
     if (n < MT_N)
-      entropy[n++] = clock();    /* CPU time used (usec) */
+      entropy[n++] = clock ();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
     if (n < MT_N)
       {
         struct timeval tv;
         if (gettimeofday(&tv, NULL) != -1)
           entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
@@ -315,17 +315,17 @@ next_state (void)
   uint32_t *p = state;
   int j;
 
   /* if init_by_int() has not been called, */
   /* a default initial seed is used         */
   /* if (initf==0) init_by_int(5489UL); */
   /* Or better yet, a random seed! */
   if (initf == 0)
-    oct_init_by_entropy();
+    oct_init_by_entropy ();
 
   left = MT_N;
   next = state;
 
   for (j = MT_N - MT_M + 1; --j; p++)
     *p = p[MT_M] ^ TWIST(p[0], p[1]);
 
   for (j = MT_M; --j; p++)
@@ -336,17 +336,17 @@ next_state (void)
 
 /* generates a random number on [0,0xffffffff]-interval */
 static uint32_t
 randmt (void)
 {
   register uint32_t y;
 
   if (--left == 0)
-    next_state();
+    next_state ();
   y = *next++;
 
   /* Tempering */
   y ^= (y >> 11);
   y ^= (y << 7) & 0x9d2c5680UL;
   y ^= (y << 15) & 0xefc60000UL;
   return (y ^ (y >> 18));
 }
@@ -354,59 +354,59 @@ randmt (void)
 /* ===== Uniform generators ===== */
 
 /* Select which 32 bit generator to use */
 #define randi32 randmt
 
 static uint64_t
 randi53 (void)
 {
-  const uint32_t lo = randi32();
-  const uint32_t hi = randi32()&0x1FFFFF;
+  const uint32_t lo = randi32 ();
+  const uint32_t hi = randi32 ()&0x1FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
 static uint64_t
 randi54 (void)
 {
-  const uint32_t lo = randi32();
-  const uint32_t hi = randi32()&0x3FFFFF;
+  const uint32_t lo = randi32 ();
+  const uint32_t hi = randi32 ()&0x3FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
 /* generates a random number on (0,1)-real-interval */
 static float
 randu32 (void)
 {
-  return ((float)randi32() + 0.5) * (1.0/4294967296.0);
+  return ((float)randi32 () + 0.5) * (1.0/4294967296.0);
   /* divided by 2^32 */
 }
 
 /* generates a random number on (0,1) with 53-bit resolution */
 static double
 randu53 (void)
 {
-  const uint32_t a=randi32()>>5;
-  const uint32_t b=randi32()>>6;
+  const uint32_t a=randi32 ()>>5;
+  const uint32_t b=randi32 ()>>6;
   return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
 }
 
 /* Determine mantissa for uniform doubles */
 double
 oct_randu (void)
 {
   return randu53 ();
@@ -559,17 +559,17 @@ create_ziggurat_tables (void)
  * Where f is the functional form of the distribution, which for a normal
  * distribution is exp(-0.5*x*x)
  */
 
 double
 oct_randn (void)
 {
   if (initt)
-    create_ziggurat_tables();
+    create_ziggurat_tables ();
 
   while (1)
     {
       /* The following code is specialized for 32-bit mantissa.
        * Compared to the arbitrary mantissa code, there is a performance
        * gain for 32-bits:  PPC: 2%, MIPS: 8%, x86: 40%
        * There is a bigger performance gain compared to using a full
        * 53-bit mantissa:  PPC: 60%, MIPS: 65%, x86: 240%
@@ -578,19 +578,19 @@ oct_randn (void)
        */
 # if HAVE_X86_32
       /* 53-bit mantissa, 1-bit sign, x86 32-bit architecture */
       double x;
       int si,idx;
       register uint32_t lo, hi;
       int64_t rabs;
       uint32_t *p = (uint32_t *)&rabs;
-      lo = randi32();
+      lo = randi32 ();
       idx = lo&0xFF;
-      hi = randi32();
+      hi = randi32 ();
       si = hi&UMASK;
       p[0] = lo;
       p[1] = hi&0x1FFFFF;
       x = ( si ? -rabs : rabs ) * wi[idx];
 # else /* !HAVE_X86_32 */
       /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
       const uint64_t r = NRANDI;
       const int64_t rabs=r>>1;
@@ -624,17 +624,17 @@ oct_randn (void)
         return x;
     }
 }
 
 double
 oct_rande (void)
 {
   if (initt)
-    create_ziggurat_tables();
+    create_ziggurat_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const double x = ri * we[idx];
       if (ri < ke[idx])
         return x;               // 98.9% of the time we return here 1st try
@@ -750,22 +750,22 @@ create_ziggurat_float_tables (void)
  * Where f is the functional form of the distribution, which for a normal
  * distribution is exp(-0.5*x*x)
  */
 
 float
 oct_float_randn (void)
 {
   if (inittf)
-    create_ziggurat_float_tables();
+    create_ziggurat_float_tables ();
 
   while (1)
     {
       /* 32-bit mantissa */
-      const uint32_t r = randi32();
+      const uint32_t r = randi32 ();
       const uint32_t rabs = r&LMASK;
       const int idx = (int)(r&0xFF);
       const float x = ((int32_t)r) * fwi[idx];
       if (rabs < fki[idx])
         return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
@@ -791,17 +791,17 @@ oct_float_randn (void)
         return x;
     }
 }
 
 float
 oct_float_rande (void)
 {
   if (inittf)
-    create_ziggurat_float_tables();
+    create_ziggurat_float_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const float x = ri * fwe[idx];
       if (ri < fke[idx])
         return x;               // 98.9% of the time we return here 1st try
@@ -820,50 +820,50 @@ oct_float_rande (void)
 }
 
 /* Array generators */
 void
 oct_fill_randu (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_randu();
+    p[i] = oct_randu ();
 }
 
 void
 oct_fill_randn (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_randn();
+    p[i] = oct_randn ();
 }
 
 void
 oct_fill_rande (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_rande();
+    p[i] = oct_rande ();
 }
 
 void
 oct_fill_float_randu (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_randu();
+    p[i] = oct_float_randu ();
 }
 
 void
 oct_fill_float_randn (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_randn();
+    p[i] = oct_float_randn ();
 }
 
 void
 oct_fill_float_rande (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_rande();
+    p[i] = oct_float_rande ();
 }
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -124,19 +124,19 @@ sparse_base_chol<chol_type, chol_elt, p_
   cm->final_resymbol = false;
 
   cholmod_sparse A;
   cholmod_sparse *ac = &A;
   double dummy;
   ac->nrow = a_nr;
   ac->ncol = a_nc;
 
-  ac->p = a.cidx();
-  ac->i = a.ridx();
-  ac->nzmax = a.nnz();
+  ac->p = a.cidx ();
+  ac->i = a.ridx ();
+  ac->nzmax = a.nnz ();
   ac->packed = true;
   ac->sorted = true;
   ac->nz = 0;
 #ifdef IDX_TYPE_LONG
   ac->itype = CHOLMOD_LONG;
 #else
   ac->itype = CHOLMOD_INT;
 #endif
@@ -146,17 +146,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   ac->xtype = OCTAVE_CHOLMOD_TYPE;
 #else
   ac->xtype = CHOLMOD_REAL;
 #endif
 
   if (a_nr < 1)
     ac->x = &dummy;
   else
-    ac->x = a.data();
+    ac->x = a.data ();
 
   // use natural ordering if no q output parameter
   if (natural)
     {
       cm->nmethods = 1 ;
       cm->method [0].ordering = CHOLMOD_NATURAL ;
       cm->postorder = false ;
     }
@@ -219,30 +219,30 @@ sparse_base_chol<chol_type, chol_elt, p_
   return info;
 }
 
 template <class chol_type, class chol_elt, class p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
-  cholmod_sparse *m = rep->L();
+  cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx(j) = static_cast<octave_idx_type *>(m->p)[j];
   for (octave_idx_type i = 0; i < nnz; i++)
     {
       ret.xridx(i) = static_cast<octave_idx_type *>(m->i)[i];
       ret.xdata(i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
-  return chol_type();
+  return chol_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
 p_type
 sparse_base_chol<chol_type, chol_elt, p_type>::
 sparse_base_chol_rep::Q (void) const
 {
@@ -255,37 +255,37 @@ sparse_base_chol_rep::Q (void) const
       p.xcidx(i) = i;
       p.xridx(i) = static_cast<octave_idx_type>(perms(i));
       p.xdata(i) = 1;
     }
   p.xcidx(n) = n;
 
   return p;
 #else
-  return p_type();
+  return p_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::inverse (void) const
 {
   chol_type retval;
 #ifdef HAVE_CHOLMOD
-  cholmod_sparse *m = rep->L();
+  cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
-  ColumnVector perms = rep->perm();
+  ColumnVector perms = rep->perm ();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
-  chol_type linv = L().hermitian().inverse(mattype, info, rcond2, 1, 0);
+  chol_type linv = L ().hermitian ().inverse(mattype, info, rcond2, 1, 0);
 
-  if (perms.length() == n)
+  if (perms.length () == n)
     {
-      p_type Qc = Q();
-      retval = Qc * linv * linv.hermitian() * Qc.transpose();
+      p_type Qc = Q ();
+      retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
 #endif
   return retval;
 }
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -193,25 +193,25 @@ public:
           rep->count++;
         }
 
       return *this;
     }
 
   chol_type L (void) const;
 
-  chol_type R (void) const { return L().hermitian (); }
+  chol_type R (void) const { return L ().hermitian (); }
 
-  octave_idx_type P (void) const { return rep->P(); }
+  octave_idx_type P (void) const { return rep->P (); }
 
-  ColumnVector perm (void) const { return rep->perm(); }
+  ColumnVector perm (void) const { return rep->perm (); }
 
-  p_type Q (void) const { return rep->Q(); }
+  p_type Q (void) const { return rep->Q (); }
 
   bool is_positive_definite (void) const
-    { return rep->is_positive_definite(); }
+    { return rep->is_positive_definite (); }
 
-  double rcond (void) const { return rep->rcond(); }
+  double rcond (void) const { return rep->rcond (); }
 
   chol_type inverse (void) const;
 };
 
 #endif
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
   octave_idx_type nc = Ufact.rows ();
   octave_idx_type rcmin = (nr > nc ? nr : nc);
 
-  lu_type Yout (nr, nc, Lfact.nnz() + Ufact.nnz());
+  lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz ());
   octave_idx_type ii = 0;
   Yout.xcidx(0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
         {
           Yout.xridx (ii) = Ufact.ridx(i);
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -68,17 +68,17 @@ dmsolve_extract (const MSparse<T> &A, co
             }
         }
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
       octave_sort<octave_idx_type> sort;
-      octave_idx_type *ri = B.xridx();
+      octave_idx_type *ri = B.xridx ();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q [j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
@@ -153,21 +153,21 @@ dmsolve_extract (const MArray<Complex> &
                  octave_idx_type c2)
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                octave_idx_type r, octave_idx_type c)
 {
-  T *ax = a.fortran_vec();
-  const T *bx = b.fortran_vec();
-  octave_idx_type anr = a.rows();
-  octave_idx_type nr = b.rows();
-  octave_idx_type nc = b.cols();
+  T *ax = a.fortran_vec ();
+  const T *bx = b.fortran_vec ();
+  octave_idx_type anr = a.rows ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
           ax [Q [r + i] + aoff] = bx [i + boff];
@@ -209,17 +209,17 @@ dmsolve_insert (MSparse<T> &a, const MSp
     for (octave_idx_type j = a.xcidx(i); j < a.xcidx(i+1); j++)
       if (Qinv [a.xridx(j)] < r || Qinv [a.xridx(j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
-  octave_idx_type *ri = a.xridx();
+  octave_idx_type *ri = a.xridx ();
 
   for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
     {
       a.xdata(i) = tmp.xdata(i);
       a.xridx(i) = tmp.xridx(i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
     a.xcidx(i) = tmp.xcidx(i);
@@ -273,19 +273,19 @@ dmsolve_insert (MSparse<Complex> &a, con
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
-  const T *Bx = b.fortran_vec();
+  const T *Bx = b.fortran_vec ();
   a.resize (dim_vector (b_nr, b_nc));
-  RT *Btx = a.fortran_vec();
+  RT *Btx = a.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
           Btx [p [i] + off] = Bx [ i + off];
         }
@@ -311,17 +311,17 @@ static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
   octave_idx_type nz = 0;
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
-  octave_idx_type *ri = a.xridx();
+  octave_idx_type *ri = a.xridx ();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
   a.xcidx(0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
         {
           octave_quit ();
           octave_idx_type r = p [b.ridx (i)];
@@ -406,39 +406,39 @@ dmsolve (const ST &a, const T &b, octave
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr [2] < nr && dm->cc [3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc,
                                   nnz_remaining, true);
-          nnz_remaining -= m.nnz();
+          nnz_remaining -= m.nnz ();
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
           if (dm->rr [2] > 0 && !info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr [2],
                                    dm->cc [3], nc, nnz_remaining, true);
-              nnz_remaining -= m.nnz();
+              nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2],
                                   dm->cc [2], dm->cc [3], nnz_remaining, false);
-          nnz_remaining -= m.nnz();
+          nnz_remaining -= m.nnz ();
           RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
@@ -446,17 +446,17 @@ dmsolve (const ST &a, const T &b, octave
               mtmp = qrsolve (m, btmp2, info);
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
           if (dm->rr [1] > 0 && !info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
                                    dm->cc [3], nnz_remaining, true);
-              nnz_remaining -= m.nnz();
+              nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
       if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -102,17 +102,17 @@ char *
                       FILE **streamptr)
 {
   int saverrno = errno;
   static const char tmpdir[] = P_tmpdir;
   static size_t indices[2];
   size_t *idx;
   static char buf[FILENAME_MAX];
   static pid_t oldpid = (pid_t) 0;
-  pid_t pid = getpid();
+  pid_t pid = getpid ();
   register size_t len, plen, dlen;
 
   if (dir_search)
     {
       register const char *d = getenv("TMPDIR");
       if (d != NULL && !diraccess(d))
         d = NULL;
       if (d == NULL && dir != NULL && diraccess(dir))
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -66,17 +66,17 @@ function varargout = curl (varargin)
     dx = varargin{1}(1,:);
     dy = varargin{2}(:,1);
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
-    print_usage();
+    print_usage ();
   endif
 
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}))
       error ("curl: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("curl: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx}))
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -64,17 +64,17 @@ function retval = divergence (varargin)
     dx = varargin{1}(1,:);
     dy = varargin{2}(:,1);
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
-    print_usage();
+    print_usage ();
   endif
 
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("divergence: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -52,17 +52,17 @@
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 
 function ri = randi (bounds, varargin)
 
   if (nargin < 1)
-    print_usage();
+    print_usage ();
   endif
 
   if (! (isnumeric (bounds) && isreal (bounds)))
     error ("randi: IMIN and IMAX must be real numeric bounds");
   endif
 
   if (isscalar (bounds))
     imin = 1;
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -141,17 +141,17 @@ function dlmwrite (file, M, varargin)
     else
       if (i == 1)
         delim = varargin{i};
       elseif (i == 2)
         r = varargin{i};
       elseif (i == 3)
         c = varargin{i};
       else
-        print_usage();
+        print_usage ();
       endif
     endif
   endwhile
 
   if (ischar (file))
     [fid, msg] = fopen (file, opentype);
   elseif (isscalar (file) && isnumeric (file))
     [fid, msg] = deal (file, "invalid file number");
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -424,17 +424,17 @@ SUCH DAMAGE.\
         code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
       else
         code = " ";
       endif
       body = cstrcat ("#include <octave/oct.h>\n\n",
                      "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
                      name, "\\n\\\n\")\n{\n",
                      "  octave_value_list retval;\n",
-                     "  int nargin = args.length();\n\n",
+                     "  int nargin = args.length ();\n\n",
                      code, "\n  return retval;\n}\n");
 
       text = cstrcat (comment, body);
     case "m"
       ## If we are editing a function defined on the fly, paste the
       ## code.
       if (any (exists == [2, 103]))
         body = type (name){1};
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -27,17 +27,17 @@
 ## Created: 2010-07-15
 
 function val = getappdata (h, name)
 
   if (all (ishandle (h)) && nargin == 2 && ischar (name))
     ## FIXME - Is there a better way to handle non-existent appdata
     ## and missing fields?
     val = cell (numel (h), 1);
-    appdata = struct();
+    appdata = struct ();
     for nh = 1:numel(h)
       try
         appdata = get (h(nh), "__appdata__");
       end_try_catch
       if (! isfield (appdata, name))
         appdata.(name) = [];
       endif
       val(nh) = {appdata.(name)};
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
     ## Find the appropriate directory on the path.
-    p = strtrim (strsplit (path (), pathsep()));
+    p = strtrim (strsplit (path (), pathsep ()));
     d = p{find (cellfun (@(x) ! isempty (strfind (x, d)), p))(end)};
   else
     [status, msg, msgid] = fileattrib (d);
     if (status != 1)
       error ("what: could not find the file or path %s", d);
     else
       d = msg.Name;
     endif
@@ -86,17 +86,17 @@ function ret = what (d)
   endif
 endfunction
 
 function __display_filenames__ (msg, p, f)
   if (length (f) > 0)
     printf ("%s %s:\n\n", msg, p);
 
     maxlen = max (cellfun ("length", f));
-    ncols = max (1, floor (terminal_size()(2) / (maxlen + 3)));
+    ncols = max (1, floor (terminal_size ()(2) / (maxlen + 3)));
     fmt = "";
     for i = 1: ncols
       fmt = sprintf ("%s   %%-%ds", fmt, maxlen);
     endfor
     fmt = [fmt, "\n"];
 
     nrows = ceil (length (f) / ncols);
     for i = 1 : nrows
diff --git a/scripts/pkg/private/getarchdir.m b/scripts/pkg/private/getarchdir.m
--- a/scripts/pkg/private/getarchdir.m
+++ b/scripts/pkg/private/getarchdir.m
@@ -18,11 +18,11 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{archdir} =} getarchdir (@var{desc})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function archdir = getarchdir (desc)
-  archdir = fullfile (desc.archprefix, getarch());
+  archdir = fullfile (desc.archprefix, getarch ());
 endfunction
 
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -96,17 +96,17 @@ function install (files, handle_deps, au
         dirlist = {".", "..", tgz};
       endif
 
       if (exist (tgz, "file") || exist (tgz, "dir"))
         ## The two first entries of dirlist are "." and "..".
         if (exist (tgz, "file"))
           packdir = fullfile (tmpdir, dirlist{3});
         else
-          packdir = fullfile (pwd(), dirlist{3});
+          packdir = fullfile (pwd (), dirlist{3});
         endif
         packdirs{end+1} = packdir;
 
         ## Make sure the package contains necessary files.
         verify_directory (packdir);
 
         ## Read the DESCRIPTION file.
         filename = fullfile (packdir, "DESCRIPTION");
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -52,17 +52,17 @@ function [out1, out2] = installed_packag
       endif
     endfor
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
   endif
 
   ## Now check if the package is loaded.
-  tmppath = strrep (path(), "\\", "/");
+  tmppath = strrep (path (), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
     if (strfind (tmppath, strrep (installed_pkgs_lst{i}.dir, '\', '/')))
       installed_pkgs_lst{i}.loaded = true;
     else
       installed_pkgs_lst{i}.loaded = false;
     endif
   endfor
   for i = 1:length (local_packages)
@@ -106,17 +106,17 @@ function [out1, out2] = installed_packag
   names = cell (num_packages, 1);
   for i = 1:num_packages
     max_name_length = max (max_name_length,
                            length (installed_pkgs_lst{i}.name));
     max_version_length = max (max_version_length,
                               length (installed_pkgs_lst{i}.version));
     names{i} = installed_pkgs_lst{i}.name;
   endfor
-  max_dir_length = terminal_size()(2) - max_name_length - ...
+  max_dir_length = terminal_size ()(2) - max_name_length - ...
                                              max_version_length - 7;
   if (max_dir_length < 20)
      max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
   h2 = postpad (h2, max_version_length, " ");;
 
@@ -133,17 +133,17 @@ function [out1, out2] = installed_packag
                     max_version_length);
   [dummy, idx] = sort (names);
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
-      first_filesep = strfind (cur_dir(first_char:end), filesep());
+      first_filesep = strfind (cur_dir(first_char:end), filesep ());
       if (! isempty (first_filesep))
         cur_dir = cstrcat ("...",
                           cur_dir((first_char + first_filesep(1) - 1):end));
       else
         cur_dir = cstrcat ("...", cur_dir(first_char:end));
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
diff --git a/scripts/pkg/private/repackage.m b/scripts/pkg/private/repackage.m
--- a/scripts/pkg/private/repackage.m
+++ b/scripts/pkg/private/repackage.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} repackage (@var{builddir}, @var{buildlist})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function repackage (builddir, buildlist)
   packages = installed_packages (buildlist, buildlist);
 
-  wd = pwd();
+  wd = pwd ();
   for i = 1 : length(packages)
     pack = packages{i};
     unwind_protect
       cd (builddir);
       mkdir (pack.name);
       mkdir (fullfile (pack.name, "inst"));
       copyfile (fullfile (pack.dir, "*"), fullfile (pack.name, "inst"));
       movefile (fullfile (pack.name, "inst","packinfo", "*"), pack.name);
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -30,17 +30,17 @@ function unload_packages (files, handle_
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
     pdeps{i} = installed_pkgs_lst{i}.depends;
   endfor
 
   ## Get the current octave path.
-  p = strtrim (strsplit (path(), pathsep ()));
+  p = strtrim (strsplit (path (), pathsep ()));
 
   if (length (files) == 1 && strcmp (files{1}, "all"))
     ## Unload all.
     dirs = pdirs;
     desc = installed_pkgs_lst;
   else
     ## Unload package_name1 ...
     dirs = {};
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -177,17 +177,17 @@ function h = colorbar (varargin)
     h = cax;
   endif
 endfunction
 
 function deletecolorbar (h, d, hc, orig_props)
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
   if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
     if (!isempty (ancestor (h, "axes"))
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", orig_props.position, ...
                             "outerposition", orig_props.outerposition, ...
                     "activepositionproperty", orig_props.activepositionproperty);
@@ -204,17 +204,17 @@ function resetaxis (cax, d, ax, orig_pro
              "outerposition", orig_props.outerposition, ...
              "activepositionproperty", orig_props.activepositionproperty);
     set (ax, "units", units)
   endif
 endfunction
 
 function update_colorbar_clim (h, d, hi, vert)
   if (ishandle (h) && strcmp (get (h, "type"), "image")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     clen = rows (get (get (h, "parent"), "colormap"));
     cext = get (h, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     if (vert)
       set (hi, "ydata", [cmin, cmax]);
@@ -224,17 +224,17 @@ function update_colorbar_clim (h, d, hi,
       set (get (hi, "parent"), "xlim", cext);
     endif
   endif
 endfunction
 
 function update_colorbar_axis (h, d, cax, orig_props)
 
   if (ishandle (cax) && strcmp (get (cax, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     obj.__my_handle__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -54,17 +54,17 @@ function h = figure (varargin)
     else
       error ("figure: expecting figure handle or figure number");
     endif
   endif
 
   ## Check to see if we already have a figure on the screen.  If we do,
   ## then update it if it is different from the figure we are creating
   ## or switching to.
-  cf = get (0, "currentfigure");   # Can't use gcf() because it calls figure()
+  cf = get (0, "currentfigure");   # Can't use gcf () because it calls figure ()
   if (! isempty (cf) && cf != 0)
     if (isnan (f) || cf != f)
       drawnow ();
     endif
   endif
 
   if (rem (nargs, 2) == 0)
     if (isnan (f) || init_new_figure)
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -169,17 +169,17 @@ function varargout = isosurface(varargin
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceVertexCData", fvc.facevertexcdata,
                     "FaceColor", "flat", "EdgeColor", "none");
       else
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
-        set (gca(), "view", [-37.5, 30],
+        set (gca (), "view", [-37.5, 30],
              "xgrid", "on", "ygrid", "on", "zgrid", "on");
       endif
     case 1
       varargout = {fvc};
     case 2
       varargout = {fvc.faces, fvc.vertices};
     case 3
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -851,17 +851,17 @@ function hideshowlegend (h, d, ca, pos1,
         isvisible = true;
         break;
       endif
     endfor
   endif
 
   for i = 1 : numel (ca)
     if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
-        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       units = get (ca(i), "units");
       unwind_protect
         set (ca(i), "units", "points");
         if (isvisible)
           set (ca(i), "position", pos2);
         else
           set (ca(i), "position", pos1);
@@ -870,26 +870,26 @@ function hideshowlegend (h, d, ca, pos1,
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
 endfunction
 
 function deletelegend1 (h, d, ca)
   if (ishandle (ca) && strcmp (get (ca, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
       && strcmp (get (ca, "beingdeleted"), "off"))
     delete (ca);
   endif
 endfunction
 
 function deletelegend2 (h, d, ca, pos, outpos, t1, hplots)
   for i = 1 : numel (ca)
     if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
-        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       if (!isempty (pos) && !isempty(outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log", "yscale", "log");
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -181,17 +181,17 @@
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("plot", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     tmp = __plt__ ("plot", h, varargin{:});
   unwind_protect_cleanup
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -322,17 +322,17 @@ function retval = plot3 (varargin)
       if (! isempty (key))
         hlgnd = [hlgnd, tmp(idx)];
         tlgnd = {tlgnd{:}, key};
       endif
     endfor
   endif
 
   if (!isempty (hlgnd))
-    legend (gca(), hlgnd, tlgnd);
+    legend (gca (), hlgnd, tlgnd);
   endif
 
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -279,17 +279,17 @@ endfunction
 %! set ([h3, h4], "linestyle", "--")
 %! xlabel (hax(1), 'xlabel')
 %! title (hax(2), 'title')
 %! ylabel (hax(1), 'Left axis is Blue')
 %! ylabel (hax(2), 'Right axis is Green')
 
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
 endfunction
 
 function update_nextplot (h, d, ax2)
   persistent recursion = false;
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     if (nargs == 3)
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -191,17 +191,17 @@ function h = __errplot__ (fstr, p, varar
 
     update_data (hg, [], hl);
 
   endfor
 
   ## Process legend key
   if (! isempty (fmt.key))    
     hlegend = [];
-    fkids = get (gcf(), "children");
+    fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
       if (ishandle (fkids(i)) && strcmp (get (fkids(i), "type"), "axes")
           && (strcmp (get (fkids(i), "tag"), "legend")))
         udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
@@ -213,17 +213,17 @@ function h = __errplot__ (fstr, p, varar
       tlgnd = {};
     else
       [hlgnd, tlgnd] = __getlegenddata__ (hlegend);
     endif
  
     hlgnd(end+1) = hg;
     tlgnd(end+1) = fmt.key;
 
-    legend (gca(), hlgnd, tlgnd);
+    legend (gca (), hlgnd, tlgnd);
   endif
 
 endfunction
 
 function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -113,23 +113,23 @@ function [gs_cmd, cleanup_cmd] = __ghost
       cleanup_cmd = "";
     else
       offsetfile = strcat (tmpnam (), ".ps");
       cleanup_cmd = sprintf ("rm %s", offsetfile);
     endif
     unwind_protect
       fid = fopen (offsetfile, "w");
       if (fid == -1)
-        error ("print:fopenfailed", "__ghostscript__.m: fopen() failed");
+        error ("print:fopenfailed", "__ghostscript__.m: fopen () failed");
       endif
       fprintf (fid, "%s\n", offset_ps{:});
     unwind_protect_cleanup
       status = fclose (fid);
       if (status == -1)
-        error ("print:fclosefailed", "__ghostscript__.m: fclose() failed");
+        error ("print:fclosefailed", "__ghostscript__.m: fclose () failed");
       endif
     end_unwind_protect
     if (opts.debug)
       fprintf ("---- begin %s ----\n", offsetfile);
       fprintf ("%s\n", offset_ps{:});
       fprintf ("----- end %s -----\n", offsetfile);
     endif
   endif
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -230,17 +230,17 @@ function p = vertex_interp(isolevel,p1x,
       p1y(nid) + mu(nid) .* (p2y(nid) - p1y(nid)), ...
       p1z(nid) + mu(nid) .* (p2z(nid) - p1z(nid))];
     if (nargin == 11)
       p(nid, 4) = col1(nid) + mu(nid) .* (col2(nid) - col1(nid));
     endif
   endif
 endfunction
 
-function [edge_table, tri_table] = init_mc()
+function [edge_table, tri_table] = init_mc ()
   edge_table = [
   0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, ...
   0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, ...
   0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, ...
   0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, ...
   0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c, ...
   0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, ...
   0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac, ...
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -32,17 +32,17 @@ function retval = __plt__ (caller, h, va
     k = 1;
 
     x_set = false;
     y_set = false;
     property_set = false;
     properties = {};
 
     hlegend = [];
-    fkids = get (gcf(), "children");
+    fkids = get (gcf (), "children");
     for i = 1 : numel(fkids)
       if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
           && (strcmp (get (fkids (i), "tag"), "legend")))
         udata = get (fkids (i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
@@ -127,17 +127,17 @@ function retval = __plt__ (caller, h, va
       else
         x = next_arg;
         x_set = true;
       endif
 
     endwhile
 
     if (setlgnd)
-      legend (gca(), hlgnd, tlgnd);
+      legend (gca (), hlgnd, tlgnd);
     endif
   else
     error ("__plt__: invalid number of arguments");
   endif
 
 endfunction
 
 function [hlgnd, tlgnd, setlgnd] = __plt_key__ (h, options, hlgnd, tlgnd, setlgnd)
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -106,17 +106,17 @@ function hg = __scatter__ (varargin)
       newargs{end+1} = arg;
       if (iarg <= nargin)
         newargs{end+1} = varargin{iarg++};
       endif
     endif
   endwhile
 
   if (isempty (c))
-    c = __next_line_color__();
+    c = __next_line_color__ ();
   endif
 
   hg = hggroup ();
   newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"},
                              newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log");
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "yscale", "log");
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -36,20 +36,20 @@ function h = trimesh (tri, x, y, z, vara
 
   if (nargin == 3)
     triplot (tri, x, y);
   elseif (ischar (z))
     triplot (tri, x, y, z, varargin{:});
   else
     newplot ();
     handle = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
-                    "FaceColor", "none", "EdgeColor", __next_line_color__(),
+                    "FaceColor", "none", "EdgeColor", __next_line_color__ (),
                     varargin{:});
     if (! ishold ())
-      set (gca(), "view", [-37.5, 30],
+      set (gca (), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
     if (nargout > 0)
       h = handle;
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -59,17 +59,17 @@ function h = trisurf (tri, x, y, z, vara
     handle = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
                     "FaceVertexCData", reshape (c, numel (c), 1),
                     varargin{:});
     if (nargout > 0)
       h = handle;
     endif
 
     if (! ishold ())
-      set (gca(), "view", [-37.5, 30],
+      set (gca (), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
 
 %!demo
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -123,17 +123,17 @@ function demo (name, n)
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## FIXME: need to check for embedded test functions, which cause
       ## segfaults, until issues with subfunctions in functions are resolved.
       embed_func = regexp (block, '^\s*function ', 'once', 'lineanchors');
       if (isempty (embed_func))
         ## Use an environment without variables
-        eval (cstrcat ("function __demo__()\n", block, "\nendfunction"));
+        eval (cstrcat ("function __demo__ ()\n", block, "\nendfunction"));
         ## Display the code that will be executed before executing it
         printf ("%s example %d:%s\n\n", name, doidx(i), block);
         __demo__;
       else
         error (["Functions embedded in %!demo blocks are not allowed.\n", ...
                 "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
       endif
     catch
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -276,17 +276,17 @@ function [__ret1, __ret2, __ret3, __ret4
         else
           __demo_code = cstrcat(__demo_code, __code);
           __demo_idx = [__demo_idx, length(__demo_code)+1];
         endif
 
       elseif (__rundemo && __isdemo)
         try
           ## process the code in an environment without variables
-          eval (sprintf ("function __test__()\n%s\nendfunction", __code));
+          eval (sprintf ("function __test__ ()\n%s\nendfunction", __code));
           __test__;
           input ("Press <enter> to continue: ", "s");
         catch
           __success = 0;
           __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, lasterr ());
         end_try_catch
         clear __test__;
 
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -130,17 +130,17 @@ function __datetick__ (varargin)
     endif
   endif
 
   if (keepticks)
     ticks = get (gca (), strcat (ax, "tick"));
   else
     ## Need to do our own axis tick position calculation as
     ## year, etc, don't fallback on nice datenum values.
-    objs = findall (gca());
+    objs = findall (gca ());
     xmax = NaN;
     xmin = NaN;
     for i = 1 : length (objs)
       fld = get (objs (i));
       if (isfield (fld, strcat (ax, "data")))
         xdata = getfield (fld, strcat (ax, "data"))(:);
         xmin = min (xmin, min (xdata));
         xmax = max (xmax, max (xdata));
@@ -239,26 +239,26 @@ function __datetick__ (varargin)
       sticks = datestr (ticks, form);
     endif
   endif
 
   sticks = mat2cell (sticks, ones (rows (sticks), 1), columns (sticks));
 
   if (keepticks)
     if (keeplimits)
-      set (gca(), strcat (ax, "ticklabel"), sticks);
+      set (gca (), strcat (ax, "ticklabel"), sticks);
     else
-      set (gca(), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
+      set (gca (), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
       [min(ticks), max(ticks)]);
     endif
   else
     if (keeplimits)
-      set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
+      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
     else
-      set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
+      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
       strcat (ax, "lim"), [min(ticks), max(ticks)]);
     endif
   endif
 endfunction
 
 function [a, b] = __magform__ (x)
   if (x == 0)
     a = 0;
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -119,17 +119,17 @@ Undocumented internal function.\n\
 
   if (n > dim + 1)
     {
       p = p.transpose ();
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
       // Qhull flags argument is not const char*
-      OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length());
+      OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length ());
 
       sprintf (flags, "qhull d %s", options.c_str ());
 
       unwind_protect frame;
 
       // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
       FILE *outfile = gnulib::fopen ("NUL", "w");
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -35,37 +35,37 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 DEFUN_DLD (__dsearchn__, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 2)
     {
       print_usage ();
       return retval;
     }
 
-  Matrix x = args(0).matrix_value().transpose ();
-  Matrix xi = args(1).matrix_value().transpose ();
+  Matrix x = args(0).matrix_value ().transpose ();
+  Matrix xi = args(1).matrix_value ().transpose ();
 
   if (! error_state)
     {
-      if (x.rows() != xi.rows() || x.columns() < 1)
+      if (x.rows () != xi.rows () || x.columns () < 1)
         error ("__dsearch__: number of rows of X and XI must match");
       else
         {
-          octave_idx_type n = x.rows();
-          octave_idx_type nx = x.columns();
-          octave_idx_type nxi = xi.columns();
+          octave_idx_type n = x.rows ();
+          octave_idx_type nx = x.columns ();
+          octave_idx_type nxi = xi.columns ();
 
           ColumnVector idx (nxi);
           double *pidx = idx.fortran_vec ();
           ColumnVector dist (nxi);
           double *pdist = dist.fortran_vec ();
 
 #define DIST(dd, y, yi, m) \
   dd = 0.; \
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -53,25 +53,25 @@ Undocumented internal function.\n\
   //   args(0) ... FileFilter in fltk format
   //   args(1) ... Title
   //   args(2) ... Default Filename
   //   args(3) ... PostionValue [x,y]
   //   args(4) ... SelectValue "on"/"off"/"dir"/"create"
 
   octave_value_list retval (3, octave_value (0));
 
-  std::string file_filter = args(0).string_value();
-  std::string title = args(1).string_value();
-  std::string default_name = args(2).string_value();
-  Matrix pos = args(3).matrix_value();
+  std::string file_filter = args(0).string_value ();
+  std::string title = args(1).string_value ();
+  std::string default_name = args(2).string_value ();
+  Matrix pos = args(3).matrix_value ();
 
   int multi_type = Fl_File_Chooser::SINGLE;
   std::string flabel = "Filename:";
 
-  std::string multi = args(4).string_value();
+  std::string multi = args(4).string_value ();
   if (multi == "on")
     multi_type = Fl_File_Chooser::MULTI;
   else if (multi == "dir")
     {
       multi_type = Fl_File_Chooser::DIRECTORY;
       flabel = "Directory:";
     }
   else if (multi == "create")
@@ -87,17 +87,17 @@ Undocumented internal function.\n\
   if (multi_type == Fl_File_Chooser::CREATE)
     fc.ok_label ("Save");
 
   fc.show ();
 
   while (fc.shown ())
     Fl::wait ();
 
-  if (fc.value())
+  if (fc.value ())
     {
       int file_count = fc.count ();
       std::string fname;
 
       //fltk uses forward slash even for windows
       std::string sep = "/";
       std::size_t idx;
 
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -163,17 +163,17 @@ glpk (int sense, int n, int m, double *c
       int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
       int save_pb, double *xmin, double *fmin, double *status,
       double *lambda, double *redcosts, double *time, double *mem)
 {
   int errnum;
   int typx = 0;
   int method;
 
-  clock_t t_start = clock();
+  clock_t t_start = clock ();
 
 #if 0
 #ifdef GLPK_PRE_4_14
   lib_set_fault_hook (0, glpk_fault_hook);
 #else
   _glp_lib_fault_hook (glpk_fault_hook, 0);
 #endif
 
@@ -483,17 +483,17 @@ Undocumented internal function.\n\
   if (nrhs != 9)
     {
       print_usage ();
       return retval;
     }
 
   //-- 1nd Input. A column array containing the objective function
   //--            coefficients.
-  volatile int mrowsc = args(0).rows();
+  volatile int mrowsc = args(0).rows ();
 
   Matrix C (args(0).matrix_value ());
 
   if (error_state)
     {
       error ("__glpk__: invalid value of C");
       return retval;
     }
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -733,17 +733,17 @@ public:
           // FIXME: This code should be removed when Octave drops support
           // for FLTK 1.1.  Search for default_xclass in this file to find
           // code that should be uncommented to take its place.
           //
           // Set WM_CLASS which allows window managers to properly group
           // related windows.  Otherwise, the class is just "FLTK"
           xclass ("Octave");
           show ();
-          if (fp.get_currentaxes ().ok())
+          if (fp.get_currentaxes ().ok ())
             show_canvas ();
           else
             hide_canvas ();
         }
     }
     end ();
 
     status->show ();
@@ -875,17 +875,17 @@ public:
             break;
           }
 
         if (uimenu->items_to_show ())
           show_menubar ();
         else
           hide_menubar ();
 
-        mark_modified();
+        mark_modified ();
       }
   }
 
   void show_canvas (void)
   {
     if (fp.is_visible ())
       {
         canvas->show ();
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -190,17 +190,17 @@ lin_interpn (int n, M *X, const M V, M *
   M Vi = M (Y[0].dims ());
 
   OCTAVE_LOCAL_BUFFER (const T *, y, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, size, n);
 
   for (int i = 0; i < n; i++)
     {
       y[i] = Y[i].data ();
-      size[i] =  V.dims()(i);
+      size[i] =  V.dims ()(i);
     }
 
   OCTAVE_LOCAL_BUFFER (const T *, x, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, scale, n);
 
   const T *v = V.data ();
   T *vi = Vi.fortran_vec ();
   octave_idx_type Ni = Vi.numel ();
@@ -281,17 +281,17 @@ Undocumented internal function.\n\
     {
       print_usage ();
       return retval;
     }
 
   // dimension of the problem
   int n = (nargin-1)/2;
 
-  if (args(n).is_single_type())
+  if (args(n).is_single_type ())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
 
       const FloatNDArray V = args(n).float_array_value ();
 
       if (error_state)
         {
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -423,24 +423,24 @@ function.  Instead use @code{imread}.\n\
       print_usage ();
       return output;
     }
 
   Array<int> frameidx;
   bool all_frames = false;
 
   if (args.length () == 2 && args(1).is_real_type ())
-    frameidx = args(1).int_vector_value();
+    frameidx = args(1).int_vector_value ();
   else if (args.length () == 3 && args(1).is_string ()
-           && args(1).string_value() == "frames")
+           && args(1).string_value () == "frames")
     {
-      if (args(2).is_string () && args(2).string_value() == "all")
+      if (args(2).is_string () && args(2).string_value () == "all")
         all_frames = true;
       else if (args(2).is_real_type ())
-        frameidx = args(2).int_vector_value();
+        frameidx = args(2).int_vector_value ();
     }
   else
     {
       frameidx = Array<int> (dim_vector (1, 1));
       frameidx(0) = 1;
     }
 
   std::vector<Magick::Image> imvec;
@@ -896,17 +896,17 @@ function.  Instead use @code{imwrite}.\n
           if (! error_state)
             {
               if (nargin > 4)
                 write_image (filename, fmt, args(2), args(3), args(4));
               else if (nargin > 3)
                 if (args(3).is_real_type ())
                   write_image (filename, fmt, args(2), args(3));
                 else
-                  write_image (filename, fmt, args(2), octave_value(), args(3));
+                  write_image (filename, fmt, args(2), octave_value (), args(3));
               else
                 write_image (filename, fmt, args(2));
             }
           else
             error ("__magick_write__: FMT must be string");
         }
       else
         error ("__magick_write__: FNAME must be a string");
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -54,17 +54,17 @@ DEFUN_DLD (__pchip_deriv__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
-  bool rows = (nargin == 3 && args (2).uint_value() == 2);
+  bool rows = (nargin == 3 && args (2).uint_value () == 2);
 
   if (nargin >= 2)
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatColumnVector xvec (args(0).float_vector_value ());
           FloatMatrix ymat (args(1).float_matrix_value ());
 
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -99,24 +99,24 @@ Generalized eigenvalue problem balancing
     }
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
-  if (nn != args(0).columns())
+  if (nn != args(0).columns ())
     {
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
   bool isfloat = args(0).is_single_type () ||
-    (! AEPcase && args(1).is_single_type());
+    (! AEPcase && args(1).is_single_type ());
 
   bool complex_case = (args(0).is_complex_type () ||
                        (! AEPcase && args(1).is_complex_type ()));
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -437,17 +437,17 @@ dimensionality as the other array.\n\
                   BSXDEF(uint64NDArray);
 
                   octave_value Ac ;
                   octave_value_list idxA;
                   octave_value Bc;
                   octave_value_list idxB;
                   octave_value C;
                   octave_value_list inputs;
-                  Array<int> ra_idx (dim_vector (dvc.length(), 1), 0);
+                  Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
 
 
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
@@ -544,60 +544,60 @@ dimensionality as the other array.\n\
                               else if (tmp(0).is_double_type ())
                                 {
                                   if (tmp(0).is_complex_type () &&
                                       have_FloatNDArray)
                                     {
                                       result_ComplexNDArray =
                                         ComplexNDArray (result_FloatNDArray);
                                       result_ComplexNDArray.insert
-                                        (tmp(0).complex_array_value(), ra_idx);
+                                        (tmp(0).complex_array_value (), ra_idx);
                                       have_FloatComplexNDArray = false;
                                       have_ComplexNDArray = true;
                                     }
                                   else
                                     {
                                       result_NDArray =
                                         NDArray (result_FloatNDArray);
                                       result_NDArray.insert
-                                        (tmp(0).array_value(), ra_idx);
+                                        (tmp(0).array_value (), ra_idx);
                                       have_FloatNDArray = false;
                                       have_NDArray = true;
                                     }
                                 }
                               else if (tmp(0).is_real_type ())
                                 result_FloatNDArray.insert
-                                  (tmp(0).float_array_value(), ra_idx);
+                                  (tmp(0).float_array_value (), ra_idx);
                               else
                                 {
                                   result_FloatComplexNDArray =
                                     FloatComplexNDArray (result_FloatNDArray);
                                   result_FloatComplexNDArray.insert
-                                    (tmp(0).float_complex_array_value(), ra_idx);
+                                    (tmp(0).float_complex_array_value (), ra_idx);
                                   have_FloatNDArray = false;
                                   have_FloatComplexNDArray = true;
                                 }
                             }
                           else if (have_NDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
                                   have_NDArray = false;
                                   C = result_NDArray;
                                   C = do_cat_op (C, tmp(0), ra_idx);
                                 }
                               else if (tmp(0).is_real_type ())
-                                result_NDArray.insert (tmp(0).array_value(),
+                                result_NDArray.insert (tmp(0).array_value (),
                                                        ra_idx);
                               else
                                 {
                                   result_ComplexNDArray =
                                     ComplexNDArray (result_NDArray);
                                   result_ComplexNDArray.insert
-                                    (tmp(0).complex_array_value(), ra_idx);
+                                    (tmp(0).complex_array_value (), ra_idx);
                                   have_NDArray = false;
                                   have_ComplexNDArray = true;
                                 }
                             }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
                         (have_ ## T) \
                           { \
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -265,18 +265,18 @@ colamd, symamd, and other related orderi
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
         A[i] = ridx [i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
-          NDArray in_cmember = args(2).array_value();
-          octave_idx_type cslen = in_cmember.length();
+          NDArray in_cmember = args(2).array_value ();
+          octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
@@ -497,18 +497,18 @@ colamd, symamd, and other related orderi
         }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
-          NDArray in_cmember = args(2).array_value();
-          octave_idx_type cslen = in_cmember.length();
+          NDArray in_cmember = args(2).array_value ();
+          octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -179,20 +179,20 @@ try_cellfun_internal_ops (const octave_v
         }
       else
         error ("cellfun: not enough arguments for \"size\"");
     }
   else if (name == "isclass")
     {
       if (nargin == 3)
         {
-          std::string class_name = args(2).string_value();
+          std::string class_name = args(2).string_value ();
           boolNDArray result (f_args.dims ());
           for (octave_idx_type count = 0; count < k; count++)
-            result(count) = (f_args.elem(count).class_name() == class_name);
+            result(count) = (f_args.elem(count).class_name () == class_name);
 
           retval(0) = result;
         }
       else
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
@@ -204,17 +204,17 @@ get_mapper_fun_options (const octave_val
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
       caseless_str arg = args(nargin-2).string_value ();
 
       size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
 
       if (arg.compare ("uniformoutput", compare_len))
-        uniform_output = args(nargin-1).bool_value();
+        uniform_output = args(nargin-1).bool_value ();
       else if (arg.compare ("errorhandler", compare_len))
         {
           if (args(nargin-1).is_function_handle ()
               || args(nargin-1).is_inline_function ())
             {
               error_handler = args(nargin-1);
             }
           else if (args(nargin-1).is_string ())
@@ -234,17 +234,17 @@ get_mapper_fun_options (const octave_val
             {
               error ("cellfun: invalid value for 'ErrorHandler' function");
               break;
             }
         }
       else
         {
           error ("cellfun: unrecognized parameter %s",
-                 arg.c_str());
+                 arg.c_str ());
           break;
         }
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
@@ -1834,17 +1834,17 @@ num2cell ([1,2;3,4],1)\n\
            4\n\
       @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
-  int nargin =  args.length();
+  int nargin =  args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       octave_value array = args(0);
       Array<int> dimv;
@@ -2172,17 +2172,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
      15\n\
 \n\
    [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       // Prepare indices.
       OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -199,26 +199,26 @@ sparse matrices.\n\
                 {
                   octave_idx_type info;
                   SparseCHOL fact (m, info, natural);
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
-                        retval(2) = fact.Q();
+                        retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P();
+                      retval(1) = fact.P ();
                       if (LLt)
-                        retval(0) = fact.L();
+                        retval(0) = fact.L ();
                       else
-                        retval(0) = fact.R();
+                        retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
@@ -228,26 +228,26 @@ sparse matrices.\n\
                   octave_idx_type info;
                   SparseComplexCHOL fact (m, info, natural);
 
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
-                        retval(2) = fact.Q();
+                        retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P();
+                      retval(1) = fact.P ();
                       if (LLt)
-                        retval(0) = fact.L();
+                        retval(0) = fact.L ();
                       else
-                        retval(0) = fact.R();
+                        retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
             }
           else
             gripe_wrong_type_arg ("chol", arg);
         }
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -292,19 +292,19 @@ parameters for @code{daspk}.\n\
       daspk_fcn = 0;
       daspk_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 daspk_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -323,28 +323,28 @@ parameters for @code{daspk}.\n\
                       jname = "function jac = ";
                       jname.append(jac_name);
                       jname.append (" (x, xdot, t, cj) jac = ");
                       daspk_jac = extract_function
                         (c(1), "daspk", jac_name, jname, "; endfunction");
 
                       if (!daspk_jac)
                         {
-                          if (fcn_name.length())
+                          if (fcn_name.length ())
                             clear_function (fcn_name);
                           daspk_fcn = 0;
                         }
                     }
                 }
             }
           else
             DASPK_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!daspk_fcn && ! f_arg.is_cell())
+      if (!daspk_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             daspk_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -380,17 +380,17 @@ parameters for @code{daspk}.\n\
                             jname.append(jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             daspk_jac = extract_function
                               (tmp(1), "daspk", jac_name, jname,
                                "; endfunction");
 
                             if (!daspk_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 daspk_fcn = 0;
                               }
                           }
                       }
                   }
                 }
             }
@@ -441,19 +441,19 @@ parameters for @code{daspk}.\n\
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
         output = dae.integrate (out_times, deriv_output, crit_times);
       else
         output = dae.integrate (out_times, deriv_output);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = dae.error_message ();
 
           retval(3) = msg;
           retval(2) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -380,19 +380,19 @@ parameters for @code{dasrt}.\n\
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
       Cell c = f_arg.cell_value ();
-      if (c.length() == 1)
+      if (c.length () == 1)
         f_arg = c(0);
-      else if (c.length() == 2)
+      else if (c.length () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dasrt_f = c(0).function_value ();
           else
             {
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
@@ -411,28 +411,28 @@ parameters for @code{dasrt}.\n\
                   jname = "function jac = ";
                   jname.append(jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function
                     (c(1), "dasrt", jac_name, jname, "; endfunction");
 
                   if (!dasrt_j)
                     {
-                      if (fcn_name.length())
+                      if (fcn_name.length ())
                         clear_function (fcn_name);
                       dasrt_f = 0;
                     }
                 }
             }
         }
       else
         DASRT_ABORT1 ("incorrect number of elements in cell array");
     }
 
-  if (!dasrt_f && ! f_arg.is_cell())
+  if (!dasrt_f && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dasrt_f = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
@@ -482,19 +482,19 @@ parameters for @code{dasrt}.\n\
 
   if (error_state || (! dasrt_f))
     DASRT_ABORT;
 
   DAERTFunc func (dasrt_user_f);
 
   argp++;
 
-  if (args(1).is_function_handle() || args(1).is_inline_function())
+  if (args(1).is_function_handle () || args(1).is_inline_function ())
     {
-      dasrt_cf = args(1).function_value();
+      dasrt_cf = args(1).function_value ();
 
       if (! dasrt_cf)
         DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
@@ -552,19 +552,19 @@ parameters for @code{dasrt}.\n\
 
   dae.set_options (dasrt_opts);
 
   if (crit_times_set)
     output = dae.integrate (out_times, crit_times);
   else
     output = dae.integrate (out_times);
 
-  if (fcn_name.length())
+  if (fcn_name.length ())
     clear_function (fcn_name);
-  if (jac_name.length())
+  if (jac_name.length ())
     clear_function (jac_name);
 
   if (! error_state)
     {
       std::string msg = dae.error_message ();
 
       retval(4) = msg;
       retval(3) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -293,19 +293,19 @@ parameters for @code{dassl}.\n\
       dassl_fcn = 0;
       dassl_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 dassl_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -324,28 +324,28 @@ parameters for @code{dassl}.\n\
                         jname = "function jac = ";
                         jname.append(jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dassl_jac = extract_function
                           (c(1), "dassl", jac_name, jname, "; endfunction");
 
                         if (!dassl_jac)
                           {
-                            if (fcn_name.length())
+                            if (fcn_name.length ())
                               clear_function (fcn_name);
                             dassl_fcn = 0;
                           }
                     }
                 }
             }
           else
             DASSL_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!dassl_fcn && ! f_arg.is_cell())
+      if (!dassl_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             dassl_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -381,17 +381,17 @@ parameters for @code{dassl}.\n\
                             jname.append(jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             dassl_jac = extract_function
                               (tmp(1), "dassl", jac_name, jname,
                                "; endfunction");
 
                             if (!dassl_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 dassl_fcn = 0;
                               }
                           }
                       }
                   }
                 }
             }
@@ -443,19 +443,19 @@ parameters for @code{dassl}.\n\
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
         output = dae.integrate (out_times, deriv_output, crit_times);
       else
         output = dae.integrate (out_times, deriv_output);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = dae.error_message ();
 
           retval(3) = msg;
           retval(2) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -65,24 +65,24 @@ dmperm_internal (bool rank, const octave
   csm.m = nr;
   csm.n = nc;
   csm.x = 0;
   csm.nz = -1;
 
   if (arg.is_real_type ())
     {
       m = arg.sparse_matrix_value ();
-      csm.nzmax = m.nnz();
+      csm.nzmax = m.nnz ();
       csm.p = m.xcidx ();
       csm.i = m.xridx ();
     }
   else
     {
       cm = arg.sparse_complex_matrix_value ();
-      csm.nzmax = cm.nnz();
+      csm.nzmax = cm.nnz ();
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
   if (!error_state)
     {
       if (nargout <= 1 || rank)
         {
@@ -148,17 +148,17 @@ triangular form.  The values of @var{r} 
 of the blocks.  If @var{S} is square then @code{@var{r} == @var{S}}.\n\
 \n\
 The method used is described in: A. Pothen & C.-J. Fan. @cite{Computing the\n\
 Block Triangular Form of a Sparse Matrix}. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
@@ -196,17 +196,17 @@ Calculate the structural rank of the spa
 only the structure of the matrix is used in this calculation based on\n\
 a Dulmage-Mendelsohn permutation to block triangular form.  As such the\n\
 numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -88,17 +88,17 @@ The eigenvalues returned by @code{eig} a
       nc_b = arg_b.columns ();
 
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return octave_value_list (2, Matrix ());
 
-      if (!(arg_b.is_single_type() || arg_b.is_double_type ()))
+      if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
         {
           gripe_wrong_type_arg ("eig", arg_b);
           return retval;
         }
     }
 
   if (nr_a != nc_a)
     {
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -341,17 +341,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
   else if (args(0).is_function_handle () || args(0).is_inline_function ()
            || args(0).is_string ())
@@ -388,35 +388,35 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         }
     }
   else
     {
       if (args(0).is_complex_type ())
         {
           if (args(0).is_sparse_type ())
             {
-              ascm = (args(0).sparse_complex_matrix_value());
+              ascm = (args(0).sparse_complex_matrix_value ());
               a_is_sparse = true;
             }
           else
-            acm = (args(0).complex_matrix_value());
+            acm = (args(0).complex_matrix_value ());
           a_is_complex = true;
           symmetric = false; // ARPACK doesn't special case complex symmetric
           sym_tested = true;
         }
       else
         {
           if (args(0).is_sparse_type ())
             {
-              asmm = (args(0).sparse_matrix_value());
+              asmm = (args(0).sparse_matrix_value ());
               a_is_sparse = true;
             }
           else
             {
-              amm = (args(0).matrix_value());
+              amm = (args(0).matrix_value ());
             }
         }
 
     }
 
   // Note hold off reading B till later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
   if (!error_state && nargin > 1 + arg_offset &&
@@ -542,19 +542,19 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
       error ("eigs: incorrect number of arguments");
       return retval;
     }
 
   // Test undeclared (no issym) matrix inputs for symmetry
   if (!sym_tested && !have_a_fun)
     {
       if (a_is_sparse)
-        symmetric = asmm.is_symmetric();
+        symmetric = asmm.is_symmetric ();
       else
-        symmetric = amm.is_symmetric();
+        symmetric = amm.is_symmetric ();
     }
 
   if (have_b)
     {
       if (a_is_complex || b_is_complex)
         {
           if (a_is_sparse)
             bscm = args(b_arg).sparse_complex_matrix_value ();
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -110,17 +110,17 @@ Note that calculated wisdom will be lost
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
 #if defined (HAVE_FFTW)
@@ -191,33 +191,33 @@ they will not be efficient and the point
                           else
                             retval = octave_value ("estimate");
                         }
                     }
                   else if (arg0 == "dwisdom")
                     {
                       char *str = fftw_export_wisdom_to_string ();
 
-                      if (arg1.length() < 1)
+                      if (arg1.length () < 1)
                         fftw_forget_wisdom ();
-                      else if (! fftw_import_wisdom_from_string (arg1.c_str()))
+                      else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
                         error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else if (arg0 == "swisdom")
                     {
                       char *str = fftwf_export_wisdom_to_string ();
 
-                      if (arg1.length() < 1)
+                      if (arg1.length () < 1)
                         fftwf_forget_wisdom ();
-                      else if (! fftwf_import_wisdom_from_string (arg1.c_str()))
+                      else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
                         error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -247,17 +247,17 @@ extern MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
         MArray<FloatComplex>&, int dim);
 #endif
 
 template <class T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, int dim = -1)
 {
-  dim_vector x_dims = x.dims();
+  dim_vector x_dims = x.dims ();
 
   if (dim < 0)
     {
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
       // All dimensions singleton, pick first dimension
@@ -398,17 +398,17 @@ H(z) = ---------------------\n\
 
   const char *errmsg = "filter: arguments a and b must be vectors";
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
-      dim = args(4).nint_value() - 1;
+      dim = args(4).nint_value () - 1;
       if (dim < 0 || dim >= x_dims.length ())
         {
           error ("filter: DIM must be a valid dimension");
           return retval;
         }
     }
   else
     {
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -84,19 +84,19 @@ find_nonzero_elem_idx (const Array<T>& n
 template <typename T>
 octave_value_list
 find_nonzero_elem_idx (const Sparse<T>& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
 
-  octave_idx_type nc = v.cols();
-  octave_idx_type nr = v.rows();
-  octave_idx_type nz = v.nnz();
+  octave_idx_type nc = v.cols ();
+  octave_idx_type nr = v.rows ();
+  octave_idx_type nz = v.nnz ();
 
   // Search in the default range.
   octave_idx_type start_nc = -1;
   octave_idx_type end_nc = -1;
   octave_idx_type count;
 
   // Search for the range to search
   if (n_to_find < 0)
@@ -226,17 +226,17 @@ find_nonzero_elem_idx (const Sparse<T>& 
 
 octave_value_list
 find_nonzero_elem_idx (const PermMatrix& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   // There are far fewer special cases to handle for a PermMatrix.
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
-  octave_idx_type nc = v.cols();
+  octave_idx_type nc = v.cols ();
   octave_idx_type start_nc, count;
 
   // Determine the range to search.
   if (n_to_find < 0 || n_to_find >= nc)
     {
       start_nc = 0;
       n_to_find = nc;
       count = nc;
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -77,17 +77,17 @@ template <class R, class T>
 static MArray<T>
 kron (const MDiagArray2<R>& a, const MArray<T>& b)
 {
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows (), nrb = b.rows (), dla = a.diag_length ();
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
-  MArray<T> c (dim_vector (nra*nrb, nca*ncb), T());
+  MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
         mx_inline_mul (nrb, &c.xelem(ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
       }
 
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -65,26 +65,26 @@ struct icmp_char_gt : public std::binary
 // FIXME -- are they even needed now?
 // case-insensitive ascending comparator
 #if 0
 static bool
 stri_comp_lt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
-                                       icmp_char_lt());
+                                       icmp_char_lt ());
 }
 
 // case-insensitive descending comparator
 static bool
 stri_comp_gt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
-                                       icmp_char_gt());
+                                       icmp_char_gt ());
 }
 #endif
 
 template <class T>
 inline sortmode
 get_sort_mode (const Array<T>& array,
                typename octave_sort<T>::compare_fcn_type desc_comp
                = octave_sort<T>::descending_compare)
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -293,19 +293,19 @@ parameters for @code{lsode}.\n\
       lsode_fcn = 0;
       lsode_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 lsode_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -324,28 +324,28 @@ parameters for @code{lsode}.\n\
                         jname = "function jac = ";
                         jname.append(jac_name);
                         jname.append (" (x, t) jac = ");
                         lsode_jac = extract_function
                           (c(1), "lsode", jac_name, jname, "; endfunction");
 
                       if (!lsode_jac)
                         {
-                          if (fcn_name.length())
+                          if (fcn_name.length ())
                             clear_function (fcn_name);
                           lsode_fcn = 0;
                         }
                     }
                 }
             }
           else
             LSODE_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!lsode_fcn && ! f_arg.is_cell())
+      if (!lsode_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             lsode_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -381,17 +381,17 @@ parameters for @code{lsode}.\n\
                             jname.append(jac_name);
                             jname.append (" (x, t) jac = ");
                             lsode_jac = extract_function
                               (tmp(1), "lsode", jac_name, jname,
                               "; endfunction");
 
                             if (!lsode_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 lsode_fcn = 0;
                               }
                           }
                       }
                   }
                   break;
 
@@ -439,19 +439,19 @@ parameters for @code{lsode}.\n\
       ode.set_options (lsode_opts);
 
       Matrix output;
       if (crit_times_set)
         output = ode.integrate (out_times, crit_times);
       else
         output = ode.integrate (out_times);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = ode.error_message ();
 
           retval(2) = msg;
           retval(1) = static_cast<double> (ode.integration_state ());
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -124,17 +124,17 @@ LU@tie{}factorization.  Once the matrix 
     {
       bool autocomp = true;
       if (nargin == 2 && args(1).is_string () && args(1).string_value () == "nocompute")
         {
           nargin = 1;
           autocomp = false;
         }
 
-      if (args(0).is_scalar_type())
+      if (args(0).is_scalar_type ())
         {
           if (nargin == 1)
             retval = octave_value ("Diagonal");
           else
             retval = args(0);
         }
       else if (args(0).is_sparse_type ())
         {
@@ -193,17 +193,17 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Tridiagonal)
                 retval = octave_value ("Tridiagonal");
               else if (typ == MatrixType::Tridiagonal_Hermitian)
                 retval = octave_value ("Tridiagonal Positive Definite");
               else if (typ == MatrixType::Hermitian)
                 retval = octave_value ("Positive Definite");
               else if (typ == MatrixType::Rectangular)
                 {
-                  if (args(0).rows() == args(0).columns())
+                  if (args(0).rows () == args(0).columns ())
                     retval = octave_value ("Singular");
                   else
                     retval = octave_value ("Rectangular");
                 }
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
@@ -265,17 +265,17 @@ LU@tie{}factorization.  Once the matrix 
                     }
                   else if (str_typ == "singular")
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
 
@@ -389,17 +389,17 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Lower)
                 retval = octave_value ("Lower");
               else if (typ == MatrixType::Permuted_Lower)
                 retval = octave_value ("Permuted Lower");
               else if (typ == MatrixType::Hermitian)
                 retval = octave_value ("Positive Definite");
               else if (typ == MatrixType::Rectangular)
                 {
-                  if (args(0).rows() == args(0).columns())
+                  if (args(0).rows () == args(0).columns ())
                     retval = octave_value ("Singular");
                   else
                     retval = octave_value ("Rectangular");
                 }
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
@@ -431,17 +431,17 @@ LU@tie{}factorization.  Once the matrix 
                     }
                   else if (str_typ == "singular")
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper"
                                           || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
@@ -472,28 +472,28 @@ LU@tie{}factorization.  Once the matrix 
                       else if (nargin != 2)
                         error ("matrix_type: Invalid number of arguments");
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_single_type ())
                             {
-                              if (args(0).is_complex_type())
+                              if (args(0).is_complex_type ())
                                 retval = octave_value
                                   (args(0).float_complex_matrix_value (),
                                    mattyp);
                               else
                                 retval = octave_value
                                   (args(0).float_matrix_value (),
                                    mattyp);
                             }
                           else
                             {
-                              if (args(0).is_complex_type())
+                              if (args(0).is_complex_type ())
                                 retval = octave_value
                                   (args(0).complex_matrix_value (),
                                    mattyp);
                               else
                                 retval = octave_value
                                   (args(0).matrix_value (),
                                    mattyp);
                             }
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -44,24 +44,24 @@ Calculate the MD5 sum of the file @var{f
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
-    print_usage();
+    print_usage ();
   else
     {
       bool have_str = false;
-      std::string str = args(0).string_value();
+      std::string str = args(0).string_value ();
 
       if (nargin == 2)
-        have_str = args(1).bool_value();
+        have_str = args(1).bool_value ();
 
       if (!error_state)
         {
           if (have_str)
             retval = oct_md5 (str);
           else
             {
               file_stat fs (str);
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -62,17 +62,17 @@ On exit, @var{y} is a unit vector such t
   @var{x} = @var{h}*[@var{v}, @var{y}]\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
   {
     print_usage ();
     return retval;
   }
 
   octave_value arg_x = args(0);
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -195,17 +195,17 @@ x = @var{R} \\ @var{C}\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin < 1 || nargin > (args(0).is_sparse_type() ? 3 : 2))
+  if (nargin < 1 || nargin > (args(0).is_sparse_type () ? 3 : 2))
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
@@ -245,17 +245,17 @@ x = @var{R} \\ @var{C}\n\
             {
               SparseComplexQR q (arg.sparse_complex_matrix_value ());
               if (!error_state)
                 {
                   if (have_b > 0)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.C (args(have_b).complex_matrix_value ());
-                      if (arg.rows() < arg.columns())
+                      if (arg.rows () < arg.columns ())
                         warning ("qr: non minimum norm solution for under-determined problem");
                     }
                   else if (nargout > 1)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.Q ();
                     }
                   else
@@ -266,17 +266,17 @@ x = @var{R} \\ @var{C}\n\
             {
               SparseQR q (arg.sparse_matrix_value ());
               if (!error_state)
                 {
                   if (have_b > 0)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.C (args(have_b).matrix_value ());
-                      if (args(0).rows() < args(0).columns())
+                      if (args(0).rows () < args(0).columns ())
                         warning ("qr: non minimum norm solution for under-determined problem");
                     }
                   else if (nargout > 1)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.Q ();
                     }
                   else
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -145,17 +145,17 @@ quad_float_user_function (float x)
     }
 
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
-      if (fcn_name.length()) \
+      if (fcn_name.length ()) \
         clear_function (fcn_name); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
@@ -458,17 +458,17 @@ variable by routines @code{dblquad} and 
             }
 
           retval(3) = abserr;
           retval(2) = nfun;
           retval(1) = ier;
           retval(0) = val;
         }
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -65,17 +65,17 @@ do_rand (const octave_value_list& args, 
 
   unwind_protect frame;
   // Restore current distribution on any exit.
   frame.add_fcn (octave_rand::distribution,
                  octave_rand::distribution ());
 
   octave_rand::distribution (distribution);
 
-  if (nargin > 0 && args(nargin-1).is_string())
+  if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string s_arg = args(nargin-1).string_value ();
 
       if (s_arg == "single")
         {
           is_single = true;
           nargin--;
         }
@@ -85,17 +85,17 @@ do_rand (const octave_value_list& args, 
 
   if (additional_arg)
     {
       if (nargin == 0)
         {
           error ("%s: expecting at least one argument", fcn);
           goto done;
         }
-      else if (args(0).is_string())
+      else if (args(0).is_string ())
         additional_arg = false;
       else
         {
           a = args(0).array_value ();
           if (error_state)
             {
               error ("%s: expecting scalar or matrix arguments", fcn);
               goto done;
@@ -256,25 +256,25 @@ do_rand (const octave_value_list& args, 
                 if (args(idx+1).is_real_scalar ())
                   {
                     double d = args(idx+1).double_value ();
 
                     if (! error_state)
                       octave_rand::seed (d);
                   }
                 else if (args(idx+1).is_string ()
-                         && args(idx+1).string_value() == "reset")
+                         && args(idx+1).string_value () == "reset")
                   octave_rand::reset ();
                 else
                   error ("%s: seed must be a real scalar", fcn);
               }
             else if (ts == "state" || ts == "twister")
               {
                 if (args(idx+1).is_string ()
-                    && args(idx+1).string_value() == "reset")
+                    && args(idx+1).string_value () == "reset")
                   octave_rand::reset (fcn);
                 else
                   {
                     ColumnVector s =
                       ColumnVector (args(idx+1).vector_value(false, true));
 
                     if (! error_state)
                       octave_rand::state (s, fcn);
@@ -312,21 +312,21 @@ do_rand (const octave_value_list& args, 
  gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (is_single)
     {
       if (additional_arg)
         {
-          if (a.length() == 1)
+          if (a.length () == 1)
             return octave_rand::float_nd_array (dims, a(0));
           else
             {
-              if (a.dims() != dims)
+              if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
               octave_idx_type len = a.length ();
               FloatNDArray m (dims);
               float *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
@@ -336,21 +336,21 @@ do_rand (const octave_value_list& args, 
         }
       else
         return octave_rand::float_nd_array (dims);
     }
   else
     {
       if (additional_arg)
         {
-          if (a.length() == 1)
+          if (a.length () == 1)
             return octave_rand::nd_array (dims, a(0));
           else
             {
-              if (a.dims() != dims)
+              if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
               octave_idx_type len = a.length ();
               NDArray m (dims);
               double *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -226,17 +226,17 @@ octregexp (const octave_value_list &args
 
       octave_idx_type i = 0;
       octave_scalar_map nmap;
 
       retval.resize (7);
 
       if (sz == 1)
         {
-          string_vector named_tokens = rx_lst.begin()->named_tokens ();
+          string_vector named_tokens = rx_lst.begin ()->named_tokens ();
 
           for (int j = 0; j < named_pats.length (); j++)
             nmap.assign (named_pats(j), named_tokens(j));
 
           retval(5) = nmap;
         }
       else
         {
@@ -1306,19 +1306,19 @@ This option is present for compatibility
       if (!error_state)
         {
           Cell ret (dv0);
           octave_value_list new_args = args;
 
           for (octave_idx_type i = 0; i < dv0.numel (); i++)
             {
               new_args(0) = str(i);
-              if (pat.numel() == 1)
+              if (pat.numel () == 1)
                 new_args(1) = pat(0);
-              if (rep.numel() == 1)
+              if (rep.numel () == 1)
                 new_args(2) = rep(0);
 
               for (octave_idx_type j = 0; j < dv1.numel (); j++)
                 {
                   if (pat.numel () != 1)
                     new_args(1) = pat(j);
                   if (rep.numel () != 1)
                     new_args(2) = rep(j);
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -138,51 +138,51 @@ factorization as determined by @var{typ}
   A->itype = CHOLMOD_INT;
 #endif
   A->dtype = CHOLMOD_DOUBLE;
   A->stype = 1;
   A->x = &dummy;
 
   if (args(0).is_real_type ())
     {
-      const SparseMatrix a = args(0).sparse_matrix_value();
-      A->nrow = a.rows();
-      A->ncol = a.cols();
-      A->p = a.cidx();
-      A->i = a.ridx();
-      A->nzmax = a.nnz();
+      const SparseMatrix a = args(0).sparse_matrix_value ();
+      A->nrow = a.rows ();
+      A->ncol = a.cols ();
+      A->p = a.cidx ();
+      A->i = a.ridx ();
+      A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_REAL;
 
-      if (a.rows() > 0 && a.cols() > 0)
-        A->x = a.data();
+      if (a.rows () > 0 && a.cols () > 0)
+        A->x = a.data ();
     }
   else if (args(0).is_complex_type ())
     {
-      const SparseComplexMatrix a = args(0).sparse_complex_matrix_value();
-      A->nrow = a.rows();
-      A->ncol = a.cols();
-      A->p = a.cidx();
-      A->i = a.ridx();
-      A->nzmax = a.nnz();
+      const SparseComplexMatrix a = args(0).sparse_complex_matrix_value ();
+      A->nrow = a.rows ();
+      A->ncol = a.cols ();
+      A->p = a.cidx ();
+      A->i = a.ridx ();
+      A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_COMPLEX;
 
-      if (a.rows() > 0 && a.cols() > 0)
-        A->x = a.data();
+      if (a.rows () > 0 && a.cols () > 0)
+        A->x = a.data ();
     }
   else
     gripe_wrong_type_arg ("symbfact", args(0));
 
   octave_idx_type coletree = false;
   octave_idx_type n = A->nrow;
 
   if (nargin > 1)
     {
       char ch;
-      std::string str = args(1).string_value();
-      ch = tolower (str.c_str()[0]);
+      std::string str = args(1).string_value ();
+      ch = tolower (str.c_str ()[0]);
       if (ch == 'r')
         A->stype = 0;
       else if (ch == 'c')
         {
           n = A->ncol;
           coletree = true;
           A->stype = 0;
         }
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -64,17 +64,17 @@ do_tril (const Array<T>& a, octave_idx_t
     }
   else
     {
       Array<T> r (a.dims ());
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j - k), nr);
-          std::fill (rvec, rvec + ii, T());
+          std::fill (rvec, rvec + ii, T ());
           std::copy (avec + ii, avec + nr, rvec + ii);
           avec += nr;
           rvec += nr;
         }
 
       return r;
     }
 }
@@ -106,17 +106,17 @@ do_triu (const Array<T>& a, octave_idx_t
   else
     {
       NoAlias<Array<T> > r (a.dims ());
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           std::copy (avec, avec + ii, rvec);
-          std::fill (rvec + ii, rvec + nr, T());
+          std::fill (rvec + ii, rvec + nr, T ());
           avec += nr;
           rvec += nr;
         }
 
       return r;
     }
 }
 
@@ -129,17 +129,17 @@ do_tril (const Sparse<T>& a, octave_idx_
 {
   if (pack) // FIXME
     {
       error ("tril: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
-  octave_idx_type nc = m.cols();
+  octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
       if (m.ridx(i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
@@ -151,17 +151,17 @@ do_triu (const Sparse<T>& a, octave_idx_
 {
   if (pack) // FIXME
     {
       error ("triu: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
-  octave_idx_type nc = m.cols();
+  octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
       if (m.ridx(i) > j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -183,17 +183,17 @@ public:
   curl_handle (const std::string& _host, const std::string& user,
                const std::string& passwd) :
     rep (new curl_handle_rep ())
     {
       rep->host = _host;
       init (user, passwd, std::cin, octave_stdout);
 
       std::string url = "ftp://" + _host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // Setup the link, with no transfer
       if (!error_state)
         perform ();
     }
 
   curl_handle (const std::string& url, const std::string& method,
                const Cell& param, std::ostream& os, bool& retval) :
@@ -215,17 +215,17 @@ public:
           setopt (CURLOPT_URL, query_string.c_str ());
         }
       else if (method == "post")
         {
           setopt (CURLOPT_URL, url.c_str ());
           setopt (CURLOPT_POSTFIELDS, query_string.c_str ());
         }
       else
-        setopt (CURLOPT_URL, url.c_str());
+        setopt (CURLOPT_URL, url.c_str ());
 
       if (!error_state)
         retval = perform (false);
     }
 
   curl_handle (const curl_handle& h) : rep (h.rep)
     {
       rep->count++;
@@ -291,133 +291,133 @@ public:
     {
       return rep->is_binary ();
     }
 
   void cwd (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "cwd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void del (const std::string& file) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "dele " + file;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void rmdir (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rmd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   bool mkdir (const std::string& path, bool curlerror = true) const
     {
       bool retval = false;
       struct curl_slist *slist = 0;
       std::string cmd = "mkd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         retval = perform (curlerror);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
       return retval;
     }
 
   void rename (const std::string& oldname, const std::string& newname) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rnfr " + oldname;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       cmd = "rnto " + newname;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void put (const std::string& file, std::istream& is) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_UPLOAD, 1);
       setopt (CURLOPT_NOBODY, 0);
       set_istream (is);
       if (! error_state)
         perform ();
       set_istream (std::cin);
       setopt (CURLOPT_NOBODY, 1);
       setopt (CURLOPT_UPLOAD, 0);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   void get (const std::string& file, std::ostream& os) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       set_ostream (os);
       if (! error_state)
         perform ();
       set_ostream (octave_stdout);
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   void dir (void) const
     {
       std::string url = "ftp://" + rep->host + "/";
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   string_vector list (void) const
     {
       std::ostringstream buf;
       std::string url = "ftp://" + rep->host + "/";
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_DIRLISTONLY, 1);
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
       setopt (CURLOPT_DIRLISTONLY, 0);
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
         {
           pos = str.find_first_of('\n', pos);
@@ -438,20 +438,20 @@ public:
           pos = newpos + 1;
         }
       return retval;
     }
 
   void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir) const
     {
-      std::string path = pwd();
+      std::string path = pwd ();
 
       std::string url = "ftp://" + rep->host + "/" + path + "/" + filename;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_FILETIME, 1);
       setopt (CURLOPT_HEADERFUNCTION, throw_away);
       setopt (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories. It also means
       // I can't get the date of directories!
@@ -475,17 +475,17 @@ public:
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // The MDTM command seems to reset the path to the root with the
       // servers I tested with, so cd again into the correct path. Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
     }
 
@@ -498,17 +498,17 @@ public:
       slist = curl_slist_append (slist, "pwd");
       setopt (CURLOPT_POSTQUOTE, slist);
       setopt (CURLOPT_HEADERFUNCTION, write_data);
       setopt (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
 
       if (! error_state)
         {
           perform ();
-          retval = buf.str();
+          retval = buf.str ();
 
           // Can I assume that the path is alway in "" on the last line
           size_t pos2 = retval.rfind ('"');
           size_t pos1 = retval.rfind ('"', pos2 - 1);
           retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
         }
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_WRITEHEADER, 0);
@@ -531,27 +531,27 @@ private:
       std::ostringstream query;
 
       for (int i = 0; i < param.numel (); i += 2)
         {
           std::string name = param(i).string_value ();
           std::string text = param(i+1).string_value ();
 
           // Encode strings.
-          char *enc_name = curl_easy_escape (rep->handle(), name.c_str (),
+          char *enc_name = curl_easy_escape (rep->handle (), name.c_str (),
                                              name.length ());
-          char *enc_text = curl_easy_escape (rep->handle(), text.c_str (),
+          char *enc_text = curl_easy_escape (rep->handle (), text.c_str (),
                                              text.length ());
 
           query << enc_name << "=" << enc_text;
 
           curl_free (enc_name);
           curl_free (enc_text);
 
-          if (i < param.numel()-1)
+          if (i < param.numel ()-1)
             query << "&";
         }
 
       query.flush ();
 
       return query.str ();
     }
 
@@ -610,17 +610,17 @@ public:
    {
      curl_global_init(CURL_GLOBAL_DEFAULT);
    }
 
   ~curl_handles (void)
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
-      map.erase (begin(), end());
+      map.erase (begin (), end ());
 
       curl_global_cleanup ();
     }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
@@ -736,53 +736,53 @@ urlwrite (\"http://www.google.com/search
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value();
+  std::string url = args(0).string_value ();
 
   if (error_state)
     {
       error ("urlwrite: URL must be a character string");
       return retval;
     }
 
   // name to store the file if download is succesful
-  std::string filename = args(1).string_value();
+  std::string filename = args(1).string_value ();
 
   if (error_state)
     {
       error ("urlwrite: LOCALFILE must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 4)
     {
-      method = args(2).string_value();
+      method = args(2).string_value ();
 
       if (error_state)
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(3).cell_value();
+      param = args(3).cell_value ();
 
       if (error_state)
         {
           error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
 
@@ -794,17 +794,17 @@ urlwrite (\"http://www.google.com/search
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
   file_stat fs (filename);
 
-  std::ofstream ofile (filename.c_str(), std::ios::out | std::ios::binary);
+  std::ofstream ofile (filename.c_str (), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
     {
       error ("urlwrite: unable to open file");
       return retval;
     }
 
   unwind_protect_safe frame;
@@ -896,44 +896,44 @@ s = urlread (\"http://www.google.com/sea
 
   // verify arguments
   if (nargin != 1  && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value();
+  std::string url = args(0).string_value ();
 
   if (error_state)
     {
       error ("urlread: URL must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 3)
     {
-      method = args(1).string_value();
+      method = args(1).string_value ();
 
       if (error_state)
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(2).cell_value();
+      param = args(2).cell_value ();
 
       if (error_state)
         {
           error ("urlread: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
       if (param.numel () % 2 == 1 )
@@ -1263,17 +1263,17 @@ DEFUN_DLD (__ftp_mode__, args, ,
        std::string handle = args(0).string_value ();
 
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
           if (curl.is_valid ())
-            retval = (curl.is_ascii() ? "ascii" : "binary");
+            retval = (curl.is_ascii () ? "ascii" : "binary");
           else
             error ("__ftp_binary__: invalid ftp handle");
         }
      }
  #else
    error ("__ftp_mode__: not available in this version of Octave");
  #endif
 
@@ -1417,28 +1417,28 @@ Undocumented internal function\n\
 static string_vector
 mput_directory (const curl_handle& curl, const std::string& base,
                 const std::string& dir)
 {
   string_vector retval;
 
   if (! curl.mkdir (dir, false))
     warning ("__ftp_mput__: can not create the remote directory ""%s""",
-             (base.length() == 0 ? dir : base +
+             (base.length () == 0 ? dir : base +
               file_ops::dir_sep_str () + dir).c_str ());
 
   curl.cwd (dir);
 
   if (! error_state)
     {
       unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, curl);
 
-      std::string realdir = base.length() == 0 ? dir : base +
+      std::string realdir = base.length () == 0 ? dir : base +
                          file_ops::dir_sep_str () + dir;
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
         {
           string_vector files = dirlist.read ();
 
@@ -1464,17 +1464,17 @@ mput_directory (const curl_handle& curl,
                   retval.append (mput_directory (curl, realdir, file));
 
                   if (error_state)
                     break;
                 }
               else
                 {
                   // FIXME Does ascii mode need to be flagged here?
-                  std::ifstream ifile (realfile.c_str(), std::ios::in |
+                  std::ifstream ifile (realfile.c_str (), std::ios::in |
                                        std::ios::binary);
 
                   if (! ifile.is_open ())
                     {
                       error ("__ftp_mput__: unable to open file ""%s""",
                              realfile.c_str ());
                       break;
                     }
@@ -1487,17 +1487,17 @@ mput_directory (const curl_handle& curl,
                     break;
 
                   retval.append (realfile);
                 }
             }
         }
       else
         error ("__ftp_mput__: can not read the directory ""%s""",
-               realdir.c_str());
+               realdir.c_str ());
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
@@ -1542,17 +1542,17 @@ Undocumented internal function\n\
                     {
                       retval.append (mput_directory (curl, "", file));
                       if (error_state)
                         break;
                     }
                   else
                     {
                       // FIXME Does ascii mode need to be flagged here?
-                      std::ifstream ifile (file.c_str(), std::ios::in |
+                      std::ifstream ifile (file.c_str (), std::ios::in |
                                            std::ios::binary);
 
                       if (! ifile.is_open ())
                         {
                           error ("__ftp_mput__: unable to open file");
                           break;
                         }
 
@@ -1588,17 +1588,17 @@ getallfiles (const curl_handle& curl, co
 
   if (!fs || !fs.is_dir ())
     {
       std::string msg;
       int status = octave_mkdir (dir, 0777, msg);
 
       if (status < 0)
         error ("__ftp_mget__: can't create directory %s%s%s. %s",
-               target.c_str(), sep.c_str(), dir.c_str(), msg.c_str());
+               target.c_str (), sep.c_str (), dir.c_str (), msg.c_str ());
     }
 
   if (! error_state)
     {
       curl.cwd (dir);
 
       if (! error_state)
         {
@@ -1616,17 +1616,17 @@ getallfiles (const curl_handle& curl, co
 
               curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
               if (fisdir)
                 getallfiles (curl, sv(i), target + dir + sep);
               else
                 {
                   std::string realfile = target + dir + sep + sv(i);
-                  std::ofstream ofile (realfile.c_str(),
+                  std::ofstream ofile (realfile.c_str (),
                                        std::ios::out |
                                        std::ios::binary);
 
                   if (! ofile.is_open ())
                     {
                       error ("__ftp_mget__: unable to open file");
                       break;
                     }
@@ -1694,17 +1694,17 @@ Undocumented internal function\n\
                       double fsize;
 
                       curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
                       if (fisdir)
                         getallfiles (curl, sv(i), target);
                       else
                         {
-                          std::ofstream ofile ((target + sv(i)).c_str(),
+                          std::ofstream ofile ((target + sv(i)).c_str (),
                                                std::ios::out |
                                                std::ios::binary);
 
                           if (! ofile.is_open ())
                             {
                               error ("__ftp_mget__: unable to open file");
                               break;
                             }
diff --git a/src/OPERATORS/op-bm-bm.cc b/src/OPERATORS/op-bm-bm.cc
--- a/src/OPERATORS/op-bm-bm.cc
+++ b/src/OPERATORS/op-bm-bm.cc
@@ -61,17 +61,17 @@ DEFUNOP (transpose, bool_matrix)
   CAST_UNOP_ARG (const octave_bool_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.bool_matrix_value().transpose ());
+    return octave_value (v.bool_matrix_value ().transpose ());
 }
 
 // bool matrix by bool matrix ops.
 
 DEFNDBINOP_FN (eq, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_eq)
 DEFNDBINOP_FN (ne, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_and, bool_matrix, bool_matrix, bool_array, bool_array,
diff --git a/src/OPERATORS/op-cdm-cdm.cc b/src/OPERATORS/op-cdm-cdm.cc
--- a/src/OPERATORS/op-cdm-cdm.cc
+++ b/src/OPERATORS/op-cdm-cdm.cc
@@ -38,23 +38,23 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, complex_diag_matrix, -)
 
 DEFUNOP (transpose, complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_diag_matrix&);
-  return octave_value (v.complex_diag_matrix_value().transpose ());
+  return octave_value (v.complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_diag_matrix&);
-  return octave_value (v.complex_diag_matrix_value().hermitian ());
+  return octave_value (v.complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-cell.cc b/src/OPERATORS/op-cell.cc
--- a/src/OPERATORS/op-cell.cc
+++ b/src/OPERATORS/op-cell.cc
@@ -41,17 +41,17 @@ DEFUNOP (transpose, cell)
   CAST_UNOP_ARG (const octave_cell&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (Cell (v.cell_value().transpose ()));
+    return octave_value (Cell (v.cell_value ().transpose ()));
 }
 
 DEFCATOP_FN (c_c, cell, cell, concat)
 
 DEFASSIGNANYOP_FN (assign, cell, assign);
 
 DEFNULLASSIGNOP_FN (null_assign, cell, delete_elements)
 
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 
 // char matrix unary ops.
 
 DEFUNOP (transpose, char_matrix)
 {
   CAST_UNOP_ARG (const octave_char_matrix&);
 
-  return octave_value (v.matrix_value().transpose ());
+  return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array,
                concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -46,30 +46,30 @@ DEFUNOP (transpose, complex_matrix)
   CAST_UNOP_ARG (const octave_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.complex_matrix_value().transpose ());
+    return octave_value (v.complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("complex-conjugate transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.complex_matrix_value().hermitian ());
+    return octave_value (v.complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -46,17 +46,17 @@ DEFBINOP_OP (sub, complex_matrix, sparse
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -45,17 +45,17 @@ DEFBINOP_OP (add, complex_matrix, sparse
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-dm-dm.cc b/src/OPERATORS/op-dm-dm.cc
--- a/src/OPERATORS/op-dm-dm.cc
+++ b/src/OPERATORS/op-dm-dm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, diag_matrix, -)
 
 DEFUNOP (transpose, diag_matrix)
 {
   CAST_UNOP_ARG (const octave_diag_matrix&);
-  return octave_value (v.diag_matrix_value().transpose ());
+  return octave_value (v.diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, diag_matrix, diag_matrix, +)
 DEFBINOP_OP (sub, diag_matrix, diag_matrix, -)
 DEFBINOP_OP (mul, diag_matrix, diag_matrix, *)
 
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
     }
   else
@@ -61,17 +61,17 @@ DEFBINOP (mul_dm_scm, diag_matrix, spars
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.scalar_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
@@ -84,17 +84,17 @@ DEFBINOP (mul_cdm_sm, complex_diag_matri
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
@@ -137,97 +137,97 @@ DEFBINOP (ldiv_cdm_scm, complex_diag_mat
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
@@ -235,17 +235,17 @@ DEFBINOP (sub_cdm_scm, complex_diag_matr
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
     }
   else
@@ -258,17 +258,17 @@ DEFBINOP (mul_scm_dm, sparse_complex_mat
       return out;
     }
 }
 
 DEFBINOP (mul_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
     }
   else
@@ -281,25 +281,25 @@ DEFBINOP (mul_sm_cdm, sparse_matrix, com
       return out;
     }
 }
 
 DEFBINOP (mul_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, don't bother with further dispatching.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () * d);
     }
   else
     {
@@ -311,17 +311,17 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
       return out;
     }
 }
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -331,17 +331,17 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
       return xdiv (v1.sparse_complex_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -351,17 +351,17 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
       return xdiv (v1.sparse_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -371,97 +371,97 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
       return xdiv (v1.sparse_complex_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + d);
     }
   else
     return v1.sparse_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + (-d));
     }
   else
     return v1.sparse_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
     return v1.sparse_complex_matrix_value () - v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
     }
   else
@@ -67,33 +67,33 @@ DEFBINOP (ldiv_dm_sm, diag_matrix, spars
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_matrix_value (), typ);
 }
 
 DEFBINOP (add_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () - d);
     }
   else
@@ -101,17 +101,17 @@ DEFBINOP (sub_dm_sm, diag_matrix, sparse
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
     }
   else
@@ -124,17 +124,17 @@ DEFBINOP (mul_sm_dm, sparse_matrix, diag
       return out;
     }
 }
 
 DEFBINOP (div_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -144,33 +144,33 @@ DEFBINOP (div_sm_dm, sparse_matrix, diag
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d + v2.matrix_value ());
     }
   else
     return v1.sparse_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d - v2.matrix_value ());
     }
   else
diff --git a/src/OPERATORS/op-fcdm-fcdm.cc b/src/OPERATORS/op-fcdm-fcdm.cc
--- a/src/OPERATORS/op-fcdm-fcdm.cc
+++ b/src/OPERATORS/op-fcdm-fcdm.cc
@@ -38,23 +38,23 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_complex_diag_matrix, -)
 
 DEFUNOP (transpose, float_complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
-  return octave_value (v.float_complex_diag_matrix_value().transpose ());
+  return octave_value (v.float_complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
-  return octave_value (v.float_complex_diag_matrix_value().hermitian ());
+  return octave_value (v.float_complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -46,30 +46,30 @@ DEFUNOP (transpose, float_complex_matrix
   CAST_UNOP_ARG (const octave_float_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_complex_matrix_value().transpose ());
+    return octave_value (v.float_complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("complex-conjugate transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_complex_matrix_value().hermitian ());
+    return octave_value (v.float_complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
diff --git a/src/OPERATORS/op-fdm-fdm.cc b/src/OPERATORS/op-fdm-fdm.cc
--- a/src/OPERATORS/op-fdm-fdm.cc
+++ b/src/OPERATORS/op-fdm-fdm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_diag_matrix, -)
 
 DEFUNOP (transpose, float_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_diag_matrix&);
-  return octave_value (v.float_diag_matrix_value().transpose ());
+  return octave_value (v.float_diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -46,17 +46,17 @@ DEFUNOP (transpose, float_matrix)
   CAST_UNOP_ARG (const octave_float_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_matrix_value().transpose ());
+    return octave_value (v.float_matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, float_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_matrix, changesign)
 
 // matrix by matrix ops.
 
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -628,17 +628,17 @@ octave_value elem_xpow (FloatNDArray a, 
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
  \
     if (v.ndims () > 2) \
       { \
         error ("transpose not defined for N-d objects"); \
         return octave_value (); \
       } \
     else \
-      return octave_value (v.TYPE ## _array_value().transpose ()); \
+      return octave_value (v.TYPE ## _array_value ().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
   DEFNCUNOP_METHOD (m_decr, TYPE ## _matrix, decrement) \
   DEFNCUNOP_METHOD (m_changesign, TYPE ## _matrix, changesign)
 
 #define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)        \
   /* matrix by matrix ops. */ \
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -46,17 +46,17 @@ DEFUNOP (transpose, matrix)
   CAST_UNOP_ARG (const octave_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.matrix_value().transpose ());
+    return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, matrix, increment)
 DEFNCUNOP_METHOD (decr, matrix, decrement)
 DEFNCUNOP_METHOD (changesign, matrix, changesign)
 
 // matrix by matrix ops.
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -46,17 +46,17 @@ DEFBINOP_OP (add, matrix, sparse_complex
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -45,17 +45,17 @@ DEFBINOP_OP (add, matrix, sparse_matrix,
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
diff --git a/src/OPERATORS/op-pm-pm.cc b/src/OPERATORS/op-pm-pm.cc
--- a/src/OPERATORS/op-pm-pm.cc
+++ b/src/OPERATORS/op-pm-pm.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xpow.h"
 
 DEFUNOP (transpose, perm_matrix)
 {
   CAST_UNOP_ARG (const octave_perm_matrix&);
-  return octave_value (v.perm_matrix_value().transpose ());
+  return octave_value (v.perm_matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (mul, perm_matrix, perm_matrix, *)
 
 DEFBINOP (div, perm_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
 
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -34,23 +34,23 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
-  else if (v1.rows() == 1 && v1.columns() == 1)
+  else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_complex_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
@@ -59,23 +59,23 @@ DEFBINOP (ldiv_pm_scm, perm_matrix, spar
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       std::complex<double> d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_complex_matrix_value ());
   else
     return v1.sparse_complex_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_scm_pm, sparse_complex_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -77,23 +77,23 @@ DEFBINOP (el_or_pm,  perm_matrix, perm_m
 }
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
-  else if (v1.rows() == 1 && v1.columns() == 1)
+  else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
@@ -102,23 +102,23 @@ DEFBINOP (ldiv_pm_sm, perm_matrix, spars
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_pm, sparse_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_matrix_value ());
   else
     return v1.sparse_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_sm_pm, sparse_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -42,27 +42,27 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // range unary ops.
 
 DEFUNOP (not, range)
 {
   CAST_UNOP_ARG (const octave_range&);
 
-  return octave_value (! v.matrix_value());
+  return octave_value (! v.matrix_value ());
 }
 
 DEFUNOP_OP (uplus, range, /* no-op */)
 DEFUNOP_OP (uminus, range, -)
 
 DEFUNOP (transpose, range)
 {
   CAST_UNOP_ARG (const octave_range&);
 
-  return octave_value (v.matrix_value().transpose ());
+  return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (addrs, range, scalar, +)
 DEFBINOP_OP (addsr, scalar, range, +)
 DEFBINOP_OP (subrs, range, scalar, -)
 DEFBINOP_OP (subsr, scalar, range, -)
 DEFBINOP_OP (mulrs, range, scalar, *)
 DEFBINOP_OP (mulsr, scalar, range, *)
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix (1, 1, v1.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -50,17 +50,17 @@ DEFUNOP (uminus, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
   return octave_value ( - v.sparse_matrix_value ());
 }
 
 DEFUNOP (transpose, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
-  return octave_value (v.sparse_bool_matrix_value().transpose ());
+  return octave_value (v.sparse_bool_matrix_value ().transpose ());
 }
 
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, sparse_bool_matrix, mx_el_or)
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -64,17 +64,17 @@ DEFBINOPX (pow, sparse_complex_matrix, c
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -66,17 +66,17 @@ DEFBINOP (pow, sparse_complex_matrix, co
                    const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -65,17 +65,17 @@ DEFBINOPX (pow, sparse_complex_matrix, m
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -74,17 +74,17 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -55,25 +55,25 @@ along with Octave; see the file COPYING.
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value().transpose (),
+    (v.sparse_complex_matrix_value ().transpose (),
      v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value().hermitian (),
+    (v.sparse_complex_matrix_value ().hermitian (),
      v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
 
@@ -95,17 +95,17 @@ DEFBINOP_OP (sub, sparse_complex_matrix,
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -126,17 +126,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -44,17 +44,17 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -74,17 +74,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -64,17 +64,17 @@ DEFBINOPX (pow, sparse_matrix, complex_m
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -66,17 +66,17 @@ DEFBINOP (pow, sparse_matrix, complex)
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -62,17 +62,17 @@ DEFBINOPX (pow, sparse_matrix, matrix)
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -68,17 +68,17 @@ DEFBINOP (pow, sparse_matrix, scalar)
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix(1, 1, v2.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -44,17 +44,17 @@ DEFBINOP_OP (add, sparse_matrix, sparse_
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -74,17 +74,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_co
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_matrix&);
-  return octave_value (v.sparse_matrix_value().transpose (),
+  return octave_value (v.sparse_matrix_value ().transpose (),
                        v.matrix_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 
 // DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
@@ -67,17 +67,17 @@ DEFBINOP_OP (add, sparse_matrix, sparse_
   }
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -97,17 +97,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_ma
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.double_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -39,17 +39,17 @@ DEFUNOP (transpose, char_matrix_str)
   CAST_UNOP_ARG (const octave_char_matrix_str&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.char_matrix_value().transpose (),
+    return octave_value (v.char_matrix_value ().transpose (),
                          a.is_sq_string () ? '\'' : '"');
 }
 
 // string by string ops.
 
 #define DEFCHARNDBINOP_FN(name, op, t1, t2, e1, e2, f)  \
   BINOPDECL (name, a1, a2) \
   { \
diff --git a/src/OPERATORS/op-struct.cc b/src/OPERATORS/op-struct.cc
--- a/src/OPERATORS/op-struct.cc
+++ b/src/OPERATORS/op-struct.cc
@@ -39,17 +39,17 @@ DEFUNOP (transpose, struct)
   CAST_UNOP_ARG (const octave_struct&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.map_value().transpose ());
+    return octave_value (v.map_value ().transpose ());
 }
 
 DEFUNOP (scalar_transpose, scalar_struct)
 {
   CAST_UNOP_ARG (const octave_scalar_struct&);
 
   return octave_value (v.scalar_map_value ());
 }
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -101,17 +101,17 @@ bitopxx(const OP& op, const std::string&
             result(i+k) = op(x(i), y(k));
         else
           result(i) = op(x(i), y(i));
 
       retval = result;
     }
   else
     error ("%s: size of X and Y must match, or one operand must be a scalar",
-           fname.c_str());
+           fname.c_str ());
 
   return retval;
 }
 
 // Trampoline function, instantiates the proper template above, with
 // reflective information hardwired. We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
@@ -151,17 +151,17 @@ bitop(const std::string& fname, const oc
                               args(1).class_name () !=
                               octave_bool::static_class_name ());
 
           if (! (arg0_is_int || arg1_is_int))
             {
               uint64NDArray x (args(0).array_value ());
               uint64NDArray y (args(1).array_value ());
               if (! error_state)
-                retval = bitopx (fname, x, y).array_value();
+                retval = bitopx (fname, x, y).array_value ();
             }
           else
             {
               int p = (arg0_is_int ? 1 : 0);
               int q = (arg0_is_int ? 0 : 1);
 
               NDArray dx = args(p).array_value ();
 
@@ -225,17 +225,17 @@ bitop(const std::string& fname, const oc
                        || args(q).type_id () == octave_int8_scalar::static_type_id ())
                 {
                   int8NDArray x (dx);
                   int8NDArray y = args(q).int8_array_value ();
                   if (! error_state)
                     retval = bitopx (fname, x, y);
                 }
               else
-                error ("%s: invalid operand type", fname.c_str());
+                error ("%s: invalid operand type", fname.c_str ());
             }
         }
       else if (args(0).class_name () == args(1).class_name ())
         {
           if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
               || args(0).type_id () == octave_uint64_scalar::static_type_id ())
             {
               uint64NDArray x = args(0).uint64_array_value ();
@@ -295,20 +295,20 @@ bitop(const std::string& fname, const oc
                    || args(0).type_id () == octave_int8_scalar::static_type_id ())
             {
               int8NDArray x = args(0).int8_array_value ();
               int8NDArray y = args(1).int8_array_value ();
               if (! error_state)
                 retval = bitopx (fname, x, y);
             }
           else
-            error ("%s: invalid operand type", fname.c_str());
+            error ("%s: invalid operand type", fname.c_str ());
         }
       else
-        error ("%s: must have matching operand types", fname.c_str());
+        error ("%s: must have matching operand types", fname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitand, args, ,
@@ -710,17 +710,17 @@ The default for @var{type} is @code{uint
     {
       print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::min ());
   else if (cname == "uint16")
-    retval = octave_uint16 (std::numeric_limits<uint16_t>::min());
+    retval = octave_uint16 (std::numeric_limits<uint16_t>::min ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::min ());
   else if (cname == "uint64")
     retval = octave_uint64 (std::numeric_limits<uint64_t>::min ());
   else if (cname == "int8")
     retval = octave_int8 (std::numeric_limits<int8_t>::min ());
   else if (cname == "int16")
     retval = octave_int16 (std::numeric_limits<int16_t>::min ());
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -5927,17 +5927,17 @@ ordered lists.\n\
 
   octave_value arg = args(0);
 
   int dim = 0;
   if (nargin > 1)
     {
       if (args(1).is_string ())
         {
-          std::string mode = args(1).string_value();
+          std::string mode = args(1).string_value ();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
             {
               error ("sort: MODE must be either \"ascend\" or \"descend\"");
               return retval;
@@ -5955,17 +5955,17 @@ ordered lists.\n\
           return retval;
         }
 
       if (! args(2).is_string ())
         {
           error ("sort: MODE must be a string");
           return retval;
         }
-      std::string mode = args(2).string_value();
+      std::string mode = args(2).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("sort: MODE must be either \"ascend\" or \"descend\"");
           return retval;
@@ -6197,17 +6197,17 @@ Undocumented internal function.\n\
   if (nargin < 1 || nargin > 2 || (nargin == 2 && ! args(1).is_string ()))
     {
       print_usage ();
       return retval;
     }
 
   if (nargin > 1)
     {
-      std::string mode = args(1).string_value();
+      std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
           return retval;
@@ -6456,17 +6456,17 @@ do_accumarray_sum (const idx_vector& idx
                    octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
 
-  NDT retval (dim_vector (n, 1), T());
+  NDT retval (dim_vector (n, 1), T ());
 
   if (vals.numel () == 1)
     retval.idx_add (idx, vals (0));
   else if (vals.numel () == idx.length (n))
     retval.idx_add (idx, vals);
   else
     error ("accumarray: dimensions mismatch");
 
@@ -6649,17 +6649,17 @@ do_accumdim_sum (const idx_vector& idx, 
 
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
-  NDT retval (rdv, T());
+  NDT retval (rdv, T ());
 
   if (idx.length () != vals_dim(dim))
     error ("accumdim: dimension mismatch");
 
   retval.idx_add_nd (idx, vals, dim);
 
   return retval;
 }
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -204,31 +204,31 @@ parse_dbfunction_params (const char *who
       idx = 0;
       symbol_name = get_user_code ()->name ();
     }
   else if (args(0).is_map ())
     {
       // Problem because parse_dbfunction_params() can only pass out a
       // single function
     }
-  else if (args(0).is_string())
+  else if (args(0).is_string ())
     {
       symbol_name = args(0).string_value ();
       if (error_state)
         return;
       idx = 1;
     }
   else
     error ("%s: invalid parameter specified", who);
 
   for (int i = idx; i < nargin; i++ )
     {
       if (args(i).is_string ())
         {
-          int line = atoi (args(i).string_value().c_str ());
+          int line = atoi (args(i).string_value ().c_str ());
           if (error_state)
             break;
           lines[list_idx++] = line;
         }
       else if (args(i).is_map ())
         octave_stdout << who << ": accepting a struct" << std::endl;
       else
         {
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -337,17 +337,17 @@ do_clear_function (const std::string& fc
 
 static void
 clear (octave_shlib& oct_file)
 {
   if (oct_file.number_of_functions_loaded () > 1)
     {
       warning_with_id ("Octave:reload-forces-clear",
                        "reloading %s clears the following functions:",
-                       oct_file.file_name().c_str ());
+                       oct_file.file_name ().c_str ());
 
       octave_shlib_list::remove (oct_file, do_clear_function);
     }
   else
     octave_shlib_list::remove (oct_file, symbol_table::clear_dld_function);
 }
 
 octave_function *
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -833,31 +833,31 @@ Reissue a previous error as defined by @
 that must contain at least the 'message' and 'identifier' fields.  @var{err}\n\
 can also contain a field 'stack' that gives information on the assumed\n\
 location of the error.  Typically @var{err} is returned from\n\
 @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const octave_scalar_map err = args(0).scalar_map_value ();
 
       if (! error_state)
         {
           if (err.contains ("message") && err.contains ("identifier"))
             {
               std::string msg = err.contents("message").string_value ();
               std::string id = err.contents("identifier").string_value ();
-              int len = msg.length();
+              int len = msg.length ();
 
               std::string file;
               std::string nm;
               int l = -1;
               int c = -1;
 
               octave_map err_stack = initialize_last_error_stack ();
 
@@ -987,17 +987,17 @@ maybe_extract_message_id (const std::str
           // For compatibility with Matlab, an identifier must contain
           // ':', but not at the beginning or the end, and it must not
           // contain '%' (even if it is not a valid conversion
           // operator) or whitespace.
 
           if (arg1.find_first_of ("% \f\n\r\t\v") == std::string::npos
               && arg1.find (':') != std::string::npos
               && arg1[0] != ':'
-              && arg1[arg1.length()-1] != ':')
+              && arg1[arg1.length ()-1] != ':')
             {
               if (nargin > 1)
                 {
                   id = arg1;
 
                   nargs.resize (nargin-1);
 
                   for (int i = 1; i < nargin; i++)
@@ -1552,17 +1552,17 @@ as input.  Any fields of @var{err} that 
 unspecified fields are initialized with default values.\n\
 \n\
 If @code{lasterror} is called with the argument \"reset\", all fields are\n\
 set to their default values.\n\
 @seealso{lasterr}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length();
+  int nargin = args.length ();
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   error_state = 0;
 
   if (nargin < 2)
     {
@@ -1570,22 +1570,22 @@ set to their default values.\n\
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
 
       err.assign ("stack", octave_value (Vlast_error_stack));
 
       if (nargin == 1)
         {
-          if (args(0).is_string())
+          if (args(0).is_string ())
             {
               if (args(0).string_value () == "reset")
                 {
-                  Vlast_error_message = std::string();
-                  Vlast_error_id = std::string();
+                  Vlast_error_message = std::string ();
+                  Vlast_error_id = std::string ();
 
                   Vlast_error_stack = initialize_last_error_stack ();
                 }
               else
                 error("lasterror: unrecognized string argument");
             }
           else if (args(0).is_map ())
             {
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -231,17 +231,17 @@ public:
 #if defined (HAVE_FRAMEWORK_OPENGL) && defined (HAVE_GLUTESSCALLBACK_THREEDOTS)
   typedef GLvoid (CALLBACK *fcn) (...);
 #else
   typedef void (CALLBACK *fcn) (void);
 #endif
 
 public:
 
-  opengl_tesselator (void) : glu_tess (0), fill() { init (); }
+  opengl_tesselator (void) : glu_tess (0), fill () { init (); }
 
   virtual ~opengl_tesselator (void)
     { if (glu_tess) gluDeleteTess (glu_tess); }
 
   void begin_polygon (bool filled = true)
     {
       gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
                        (filled ? GL_FALSE : GL_TRUE));
@@ -636,17 +636,17 @@ opengl_renderer::init_gl_context (bool e
   else
     {
       glDisable (GL_BLEND);
       glDisable (GL_LINE_SMOOTH);
     }
 
   // Clear background
 
-  if (c.length() >= 3)
+  if (c.length () >= 3)
     {
       glClearColor (c(0), c(1), c(2), 1);
       glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     }
 }
 
 void
 opengl_renderer::render_grid (const std::string& gridstyle,
@@ -2892,17 +2892,17 @@ opengl_renderer::make_marker_list (const
       }
       break;
     case 's':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (-sz/2, -sz/2);
       glVertex2d (-sz/2, sz/2);
       glVertex2d (sz/2, sz/2);
       glVertex2d (sz/2, -sz/2);
-      glEnd();
+      glEnd ();
       break;
     case 'o':
       {
         double ang_step = M_PI / 5;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (double ang = 0; ang < (2*M_PI); ang += ang_step)
           glVertex2d (sz*cos(ang)/2, sz*sin(ang)/2);
@@ -2910,17 +2910,17 @@ opengl_renderer::make_marker_list (const
       }
       break;
     case 'd':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (0, -sz/2);
       glVertex2d (sz/2, 0);
       glVertex2d (0, sz/2);
       glVertex2d (-sz/2, 0);
-      glEnd();
+      glEnd ();
       break;
     case 'v':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2f (0, sz/2);
       glVertex2f (sz/2, -sz/2);
       glVertex2f (-sz/2, -sz/2);
       glEnd ();
       break;
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1032,17 +1032,17 @@ radio_values::values_as_cell (void) cons
   return retval;
 }
 
 bool
 color_values::str2rgb (std::string str)
 {
   double tmp_rgb[3] = {0, 0, 0};
   bool retval = true;
-  unsigned int len = str.length();
+  unsigned int len = str.length ();
 
   std::transform (str.begin (), str.end (), str.begin (), tolower);
 
   if (str.compare(0, len, "blue", 0, len) == 0)
     tmp_rgb[2] = 1;
   else if (str.compare(0, len, "black", 0, len) == 0
            || str.compare(0, len, "k", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 0;
@@ -1266,17 +1266,17 @@ array_property::is_equal (const octave_v
                   for (int i = 0; flag && i < data.numel (); i++) \
                     if (d1[i] != d2[i]) \
                       flag = false; \
                   \
                   return flag; \
                 } \
             }
 
-          if (data.is_double_type() || data.is_bool_type ())
+          if (data.is_double_type () || data.is_bool_type ())
             CHECK_ARRAY_EQUAL (double, , NDArray)
           else if (data.is_single_type ())
             CHECK_ARRAY_EQUAL (float, float_, FloatNDArray)
           else if (data.is_int8_type ())
             CHECK_ARRAY_EQUAL (octave_int8, int8_, int8NDArray)
           else if (data.is_int16_type ())
             CHECK_ARRAY_EQUAL (octave_int16, int16_, int16NDArray)
           else if (data.is_int32_type ())
@@ -1423,17 +1423,17 @@ callback_property::validate (const octav
   // case 5: empty matrix
 
   if (v.is_function_handle ())
     return true;
   else if (v.is_string ())
     // complete validation will be done at execution-time
     return true;
   else if (v.is_cell () && v.length () > 0
-           && (v.rows() == 1 || v.columns () == 1)
+           && (v.rows () == 1 || v.columns () == 1)
            && v.cell_value ()(0).is_function_handle ())
     return true;
   else if (v.is_empty ())
     return true;
 
   return false;
 }
 
@@ -5624,17 +5624,17 @@ axes::properties::get_extent (bool with_
           else
             {
               Matrix text_ext = text_props.get_extent_matrix ();
 
               bool ignore_horizontal = false;
               bool ignore_vertical = false;
               if (only_text_height)
                 {
-                  double text_rotation = text_props.get_rotation();
+                  double text_rotation = text_props.get_rotation ();
                   if (text_rotation == 0. || text_rotation == 180.)
                       ignore_horizontal = true;
                   else if (text_rotation == 90. || text_rotation == 270.)
                       ignore_vertical = true;
                 }
 
               if (! ignore_horizontal)
                 {
@@ -5672,19 +5672,19 @@ axes::properties::set_units (const octav
 }
 
 void
 axes::properties::update_units (const caseless_str& old_units)
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
   Matrix parent_bb = obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
   caseless_str new_units = get_units ();
-  position.set (octave_value (convert_position (get_position().matrix_value(), old_units, new_units, parent_bb)), false);
-  outerposition.set (octave_value (convert_position (get_outerposition().matrix_value(), old_units, new_units, parent_bb)), false);
-  tightinset.set (octave_value (convert_position (get_tightinset().matrix_value(), old_units, new_units, parent_bb)), false);
+  position.set (octave_value (convert_position (get_position ().matrix_value (), old_units, new_units, parent_bb)), false);
+  outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (), old_units, new_units, parent_bb)), false);
+  tightinset.set (octave_value (convert_position (get_tightinset ().matrix_value (), old_units, new_units, parent_bb)), false);
 }
 
 void
 axes::properties::set_fontunits (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
@@ -6163,17 +6163,17 @@ axes::properties::get_ticklabel_extents 
       if (limits(0) <= val && val <= limits(1))
         {
 #ifdef HAVE_FREETYPE
           ext = text_renderer.get_extent (ticklabels(i));
           wmax = std::max (wmax, ext(0));
           hmax = std::max (hmax, ext(1));
 #else
           //FIXME: find a better approximation
-          int len = ticklabels(i).length();
+          int len = ticklabels(i).length ();
           wmax = std::max (wmax, 0.5*fontsize*len);
           hmax = fontsize;
 #endif
         }
     }
 
   ext(0) = wmax;
   ext(1) = hmax;
@@ -6281,17 +6281,17 @@ axes::update_axis_limits (const std::str
   double max_neg = -octave_Inf;
 
   char update_type = 0;
 
   Matrix limits;
   double val;
 
 #define FIX_LIMITS \
-  if (limits.numel() == 4) \
+  if (limits.numel () == 4) \
     { \
       val = limits(0); \
       if (! (xisinf (val) || xisnan (val))) \
         min_val = val; \
       val = limits(1); \
       if (! (xisinf (val) || xisnan (val))) \
         max_val = val; \
       val = limits(2); \
@@ -6836,17 +6836,17 @@ axes::properties::rotate_view (double de
   if(v(1) > 90)
     v(1) = 90;
   if(v(1) < -90)
     v(1) = -90;
 
   v (0) = fmod(v(0) - delta_az + 720,360);
 
   set_view(v);
-  update_transform();
+  update_transform ();
 }
 
 void
 axes::properties::unzoom (void)
 {
   if (zoom_stack.size () >= 4)
     {
       ylim = zoom_stack.front ();
@@ -6992,17 +6992,17 @@ text::properties::update_text_extent (vo
 
   octave_value string_prop = get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
                            halign, valign, get_rotation ());
   /* The bbox is relative to the text's position.
-     We'll leave it that way, because get_position() does not return
+     We'll leave it that way, because get_position () does not return
      valid results when the text is first constructed.
      Conversion to proper coordinates is performed in get_extent. */
   set_extent (bbox);
 
 #endif
 
   if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
       autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
@@ -7072,17 +7072,17 @@ image::properties::get_color_data (void)
                         cdatamapping_is ("scaled"), 3);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 patch::properties::get_color_data (void) const
 {
-  octave_value fvc = get_facevertexcdata();
+  octave_value fvc = get_facevertexcdata ();
   if (fvc.is_undefined () || fvc.is_empty ())
     return Matrix ();
   else
     return convert_cdata (*this, fvc,cdatamapping_is ("scaled"), 2);
 }
 
 // ---------------------------------------------------------------------
 
@@ -7252,17 +7252,17 @@ hggroup::update_axis_limits (const std::
       update_type = 'c';
     }
   else if (axis_type == "alim" || axis_type == "aliminclude")
     {
       limits = xproperties.get_alim ().matrix_value ();
       update_type = 'a';
     }
 
-  if (limits.numel() == 4)
+  if (limits.numel () == 4)
     {
       val = limits(0);
       if (! (xisinf (val) || xisnan (val)))
         min_val = val;
       val = limits(1);
       if (! (xisinf (val) || xisnan (val)))
         max_val = val;
       val = limits(2);
@@ -7475,17 +7475,17 @@ uicontrol::properties::update_units (voi
   set_position (pos);
 
   cached_units = get_units ();
 }
 
 void
 uicontrol::properties::set_style (const octave_value& st)
 {
-  if (get___object__ ().is_empty())
+  if (get___object__ ().is_empty ())
     style = st;
   else
     error ("set: cannot change the style of a uicontrol object after creation.");
 }
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
@@ -8510,17 +8510,17 @@ values or lists respectively.\n\
   Cell vals;
 
   int nargin = args.length ();
 
   bool use_cell_format = false;
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_empty())
+      if (args(0).is_empty ())
         {
           retval = Matrix ();
           return retval;
         }
 
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
@@ -8913,27 +8913,27 @@ calc_dimensions (const graphics_object& 
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
 
   if ((go.isa ("line") || go.isa ("patch")) && ! go.get("zdata").is_empty ())
     nd = 3;
 
-  Matrix kids = go.get_properties().get_children ();
+  Matrix kids = go.get_properties ().get_children ();
 
   for (octave_idx_type i = 0; i < kids.length (); i++)
     {
       graphics_handle hnd = gh_manager::lookup (kids(i));
 
       if (hnd.ok ())
         {
           const graphics_object& kid = gh_manager::get_object(hnd);
 
-          if (kid.valid_object())
+          if (kid.valid_object ())
             nd = calc_dimensions (kid);
 
           if (nd == 3)
             break;
         }
     }
 
   return nd;
@@ -9852,17 +9852,17 @@ get_property_from_handle (double handle,
   gh_manager::auto_lock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   octave_value retval;
 
   if (obj)
     retval = obj.get (caseless_str (property));
   else
-    error ("%s: invalid handle (= %g)", func.c_str(), handle);
+    error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return retval;
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
@@ -9874,17 +9874,17 @@ set_property_in_handle (double handle, c
   if (obj)
     {
       obj.set (caseless_str (property), arg);
 
       if (! error_state)
         ret = true;
     }
   else
-    error ("%s: invalid handle (= %g)", func.c_str(), handle);
+    error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return ret;
 }
 
 static bool
 compare_property_values (const octave_value& o1, const octave_value& o2)
 {
   octave_value_list args (2);
diff --git a/src/graphics.in.h b/src/graphics.in.h
--- a/src/graphics.in.h
+++ b/src/graphics.in.h
@@ -293,17 +293,17 @@ private:
     }
 };
 
 class scaler
 {
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
-  scaler (const scaler& s) : rep (s.rep->clone()) { }
+  scaler (const scaler& s) : rep (s.rep->clone ()) { }
 
   scaler (const std::string& s)
     : rep (s == "log"
            ? new log_scaler ()
            : (s == "neglog" ? new neg_log_scaler ()
               : (s == "linear" ? new lin_scaler () : new base_scaler ())))
     { }
 
@@ -459,17 +459,17 @@ public:
               if (v.internal_rep () == l(i).internal_rep ())
                 {
                   found = true;
                   break;
                 }
             }
           if (found)
             {
-              for (int j = i; j < l.length() - 1; j++)
+              for (int j = i; j < l.length () - 1; j++)
                 l(j) = l (j + 1);
 
               l.resize (l.length () - 1);
             }
         }
       else
         {
           if (mode == PERSISTENT)
@@ -4408,19 +4408,19 @@ public:
     // properties declarations.
 
     BEGIN_PROPERTIES (image)
       row_vector_property xdata u , Matrix ()
       row_vector_property ydata u , Matrix ()
       array_property cdata u , Matrix ()
       radio_property cdatamapping al , "{scaled}|direct"
       // hidden properties for limit computation
-      row_vector_property xlim hlr , Matrix()
-      row_vector_property ylim hlr , Matrix()
-      row_vector_property clim hlr , Matrix()
+      row_vector_property xlim hlr , Matrix ()
+      row_vector_property ylim hlr , Matrix ()
+      row_vector_property clim hlr , Matrix ()
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property climinclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
@@ -4805,21 +4805,21 @@ public:
         update_limits (h);
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (hggroup)
       // hidden properties for limit computation
-      row_vector_property xlim hr , Matrix()
-      row_vector_property ylim hr , Matrix()
-      row_vector_property zlim hr , Matrix()
-      row_vector_property clim hr , Matrix()
-      row_vector_property alim hr , Matrix()
+      row_vector_property xlim hr , Matrix ()
+      row_vector_property ylim hr , Matrix ()
+      row_vector_property zlim hr , Matrix ()
+      row_vector_property clim hr , Matrix ()
+      row_vector_property alim hr , Matrix ()
       bool_property xliminclude h , "on"
       bool_property yliminclude h , "on"
       bool_property zliminclude h , "on"
       bool_property climinclude h , "on"
       bool_property aliminclude h , "on"
     END_PROPERTIES
 
   private:
@@ -4877,17 +4877,17 @@ public:
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uimenu)
       any_property __object__ , Matrix ()
       string_property accelerator , ""
-      callback_property callback , Matrix()
+      callback_property callback , Matrix ()
       bool_property checked , "off"
       bool_property enable , "on"
       color_property foregroundcolor , color_values (0, 0, 0)
       string_property label , ""
       double_property position , 9
       bool_property separator , "off"
       string_property fltk_label h , ""
     END_PROPERTIES
@@ -4925,17 +4925,17 @@ public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uicontextmenu)
       any_property __object__ , Matrix ()
-      callback_property callback , Matrix()
+      callback_property callback , Matrix ()
       array_property position , Matrix (1, 2, 0.0)
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         position.add_constraint (dim_vector (1, 2));
         position.add_constraint (dim_vector (2, 1));
@@ -5218,17 +5218,17 @@ public:
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uipushtool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
-      callback_property clickedcallback , Matrix()
+      callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
       bool_property separator , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
@@ -5268,20 +5268,20 @@ public:
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uitoggletool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
-      callback_property clickedcallback , Matrix()
+      callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
-      callback_property offcallback , Matrix()
-      callback_property oncallback , Matrix()
+      callback_property offcallback , Matrix ()
+      callback_property oncallback , Matrix ()
       bool_property separator , "off"
       bool_property state , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -521,24 +521,24 @@ load_path::do_initialize (bool set_initi
 
   do_set (xpath, false, true);
 }
 
 void
 load_path::do_clear (std::set<std::string>& new_elts)
 {
   bool warn_default_path_clobbered = false;
-  for (dir_info_list_iterator i = dir_info_list.begin();
-       i != dir_info_list.end();
+  for (dir_info_list_iterator i = dir_info_list.begin ();
+       i != dir_info_list.end ();
        /* conditionally advance iterator in loop body */)
     {
       //Don't remove it if it's gonna be added again, but remove it from
       //list of items to add, to avoid duplicates later on
       std::set<std::string>::iterator j = new_elts.find(i->dir_name);
-      if (j != new_elts.end())
+      if (j != new_elts.end ())
         {
           new_elts.erase(j);
           i++;
         }
       else
         {
           //Warn if removing a default directory and not immediately adding
           //it back again
@@ -590,17 +590,17 @@ split_path (const std::string& p)
 
   return retval;
 }
 
 void
 load_path::do_set (const std::string& p, bool warn, bool is_init)
 {
   std::list<std::string> elts_l = split_path (p);
-  std::set<std::string> elts(elts_l.begin(), elts_l.end());
+  std::set<std::string> elts(elts_l.begin (), elts_l.end ());
 
   // Temporarily disable add hook.
 
   unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -835,17 +835,17 @@ add_hdf5_data (hid_t loc_id, const octav
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
-  std::string t = val.type_name();
+  std::string t = val.type_name ();
 #if HAVE_HDF5_18
   data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
 #endif
   if (data_id < 0)
     goto error_cleanup;
 
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -858,34 +858,34 @@ read_mat5_binary_element (std::istream& 
           = read_mat5_binary_element (is, filename, swap, global, tc2);
 
         if (! is || error_state)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directry seperator
         // and so can ignore the seperator field of m0. I think the
         // sentinel field is also save to ignore.
-        Octave_map m0 = tc2.map_value();
-        Octave_map m1 = m0.contents("function_handle")(0).map_value();
-        std::string ftype = m1.contents("type")(0).string_value();
-        std::string fname = m1.contents("function")(0).string_value();
-        std::string fpath = m1.contents("file")(0).string_value();
+        Octave_map m0 = tc2.map_value ();
+        Octave_map m1 = m0.contents("function_handle")(0).map_value ();
+        std::string ftype = m1.contents("type")(0).string_value ();
+        std::string fname = m1.contents("function")(0).string_value ();
+        std::string fpath = m1.contents("file")(0).string_value ();
 
         if (ftype == "simple" || ftype == "scopedfunction")
           {
-            if (fpath.length() == 0)
+            if (fpath.length () == 0)
               // We have a builtin function
               tc = make_fcn_handle (fname);
             else
               {
                 std::string mroot =
-                  m0.contents("matlabroot")(0).string_value();
+                  m0.contents("matlabroot")(0).string_value ();
 
                 if ((fpath.length () >= mroot.length ()) &&
-                    fpath.substr(0, mroot.length()) == mroot &&
+                    fpath.substr(0, mroot.length ()) == mroot &&
                     OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
@@ -937,17 +937,17 @@ read_mat5_binary_element (std::istream& 
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                         else
                           {
                             warning ("load: can't find the file %s",
-                                     fpath.c_str());
+                                     fpath.c_str ());
                             goto skip_ahead;
                           }
                       }
                   }
                 else
                   {
                     size_t xpos
                       = fpath.find_last_of (file_ops::dir_sep_chars ());
@@ -961,56 +961,56 @@ read_mat5_binary_element (std::istream& 
                       {
                         octave_value tmp (fcn);
 
                         tc = octave_value (new octave_fcn_handle (tmp, fname));
                       }
                     else
                       {
                         warning ("load: can't find the file %s",
-                                 fpath.c_str());
+                                 fpath.c_str ());
                         goto skip_ahead;
                       }
                   }
               }
           }
         else if (ftype == "nested")
           {
             warning ("load: can't load nested function");
             goto skip_ahead;
           }
         else if (ftype == "anonymous")
           {
-            Octave_map m2 = m1.contents("workspace")(0).map_value();
-            uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
+            Octave_map m2 = m1.contents("workspace")(0).map_value ();
+            uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value ();
             octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
-            m2 = subsys_ov.map_value();
-            m2 = m2.contents("MCOS")(0).map_value();
-            tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
-            m2 = tc2.map_value();
+            m2 = subsys_ov.map_value ();
+            m2 = m2.contents("MCOS")(0).map_value ();
+            tc2 = m2.contents("MCOS")(0).cell_value ()(1 + off).cell_value ()(1);
+            m2 = tc2.map_value ();
 
             unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
             frame.add_fcn (symbol_table::erase_scope, local_scope);
 
             symbol_table::set_scope (local_scope);
 
             octave_call_stack::push (local_scope, 0);
             frame.add_fcn (octave_call_stack::pop);
 
-            if (m2.nfields() > 0)
+            if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
-                for (Octave_map::iterator p0 = m2.begin() ;
-                     p0 != m2.end(); p0++)
+                for (Octave_map::iterator p0 = m2.begin () ;
+                     p0 != m2.end (); p0++)
                   {
                     std::string key = m2.key(p0);
                     octave_value val = m2.contents(p0)(0);
 
                     symbol_table::varref (key, local_scope, 0) = val;
                   }
               }
 
@@ -1214,34 +1214,34 @@ read_mat5_binary_element (std::istream& 
 
         if (isclass)
           {
             if (classname == "inline")
               {
                 // inline is not an object in Octave but rather an
                 // overload of a function handle. Special case.
                 tc =
-                  new octave_fcn_inline (m.contents("expr")(0).string_value(),
-                                         m.contents("args")(0).string_value());
+                  new octave_fcn_inline (m.contents("expr")(0).string_value (),
+                                         m.contents("args")(0).string_value ());
               }
             else
               {
                 octave_class* cls
                   = new octave_class (m, classname,
                                       std::list<std::string> ());
 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
                     if (load_path::find_method (classname, "loadobj") !=
-                        std::string())
+                        std::string ())
                       {
                         octave_value_list tmp = feval ("loadobj", tc, 1);
 
                         if (! error_state)
                           tc = tmp(0);
                         else
                           goto data_read_error;
                       }
@@ -1558,17 +1558,17 @@ read_mat5_binary_file_header (std::istre
       bool global;
       read_mat5_binary_element (is, filename, swap, global, tc);
 
       if (!is || error_state)
         return -1;
 
       if (tc.is_uint8_type ())
         {
-          const uint8NDArray itmp = tc.uint8_array_value();
+          const uint8NDArray itmp = tc.uint8_array_value ();
           octave_idx_type ilen = itmp.numel ();
 
           // Why should I have to initialize outbuf as just overwrite
           std::string outbuf (ilen - 7, ' ');
 
           // FIXME -- find a way to avoid casting away const here
           char *ctmp = const_cast<char *> (outbuf.c_str ());
           for (octave_idx_type j = 8; j < ilen; j++)
@@ -2615,21 +2615,21 @@ save_mat5_binary_element (std::ostream& 
       else
         {
           ComplexNDArray m_cmplx = tc.complex_array_value ();
 
           write_mat5_array (os, ::real (m_cmplx), save_as_floats);
           write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
         }
     }
-  else if (tc.is_map () || tc.is_inline_function() || tc.is_object ())
+  else if (tc.is_map () || tc.is_inline_function () || tc.is_object ())
     {
       if (tc.is_inline_function () || tc.is_object ())
         {
-          std::string classname = tc.is_object() ? tc.class_name () : "inline";
+          std::string classname = tc.is_object () ? tc.class_name () : "inline";
           size_t namelen = classname.length ();
 
           if (namelen > max_namelen)
             namelen = max_namelen; // only 31 or 63 char names permitted
 
           int paddedlength = PAD (namelen);
 
           write_mat5_tag (os, miINT8, namelen);
@@ -2637,17 +2637,17 @@ save_mat5_binary_element (std::ostream& 
           memset (paddedname, 0, paddedlength);
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       Octave_map m;
 
       if (tc.is_object () &&
-          load_path::find_method (tc.class_name (), "saveobj") != std::string())
+          load_path::find_method (tc.class_name (), "saveobj") != std::string ())
         {
           octave_value_list tmp = feval ("saveobj", tc, 1);
           if (! error_state)
             m = tmp(0).map_value ();
           else
             goto error_cleanup;
         }
       else
diff --git a/src/ls-mat5.h b/src/ls-mat5.h
--- a/src/ls-mat5.h
+++ b/src/ls-mat5.h
@@ -43,17 +43,17 @@ enum mat5_data_type
     miUTF8,                     // Unicode UTF-8 Encoded Character Data
     miUTF16,                    // Unicode UTF-16 Encoded Character Data
     miUTF32                     // Unicode UTF-32 Encoded Character Data
   };
 
 extern int
 read_mat5_binary_file_header (std::istream& is, bool& swap,
                               bool quiet = false,
-                              const std::string& filename = std::string());
+                              const std::string& filename = std::string ());
 extern std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
                           bool swap, bool& global, octave_value& tc);
 extern bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
                           bool save_as_floats, bool compressing = false);
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -318,17 +318,17 @@ save_ascii_data (std::ostream& os, const
   if (! name.empty ())
     os << "# name: " << name << "\n";
 
   octave_value val = val_arg;
 
   if (mark_as_global)
     os << "# type: global " << val.type_name () << "\n";
   else
-    os << "# type: " << val.type_name() << "\n";
+    os << "# type: " << val.type_name () << "\n";
 
   if (! precision)
     precision = Vsave_precision;
 
   long old_precision = os.precision ();
   os.precision (precision);
 
   success = val.save_ascii (os);
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -69,17 +69,17 @@ save_three_d (std::ostream& os, const oc
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
 bool
 extract_keyword (std::istream& is, const char *keyword, T& value,
                  const bool next_only = false)
 {
   bool status = false;
-  value = T();
+  value = T ();
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
         {
           std::ostringstream buf;
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -392,17 +392,17 @@ public:
 
   mwSize get_m (void) const { return val.rows (); }
 
   mwSize get_n (void) const
   {
     mwSize n = 1;
 
     // Force dims and ndims to be cached.
-    get_dimensions();
+    get_dimensions ();
 
     for (mwIndex i = ndims - 1; i > 0; i--)
       n *= dims[i];
 
     return n;
   }
 
   mwSize *get_dimensions (void) const
@@ -3458,17 +3458,17 @@ mexAtExit (void (*f) (void))
 }
 
 const mxArray *
 mexGet (double handle, const char *property)
 {
   mxArray *m = 0;
   octave_value ret = get_property_from_handle (handle, property, "mexGet");
 
-  if (!error_state && ret.is_defined())
+  if (!error_state && ret.is_defined ())
     m = ret.as_mxArray ();
   return m;
 }
 
 int
 mexIsGlobal (const mxArray *ptr)
 {
   return mxIsFromGlobalWS (ptr);
diff --git a/src/mk-errno-list b/src/mk-errno-list
--- a/src/mk-errno-list
+++ b/src/mk-errno-list
@@ -36,17 +36,17 @@ if [ $1 = "--perl" ]; then
 elif [ $1 = "--python" ]; then
   PYTHON="$2";
   $PYTHON -c '
 from errno import errorcode
 from sys import stdin
 
 t = "#if defined (%s)\n    { \"%s\", %s, },\n#endif\n"
 errstr = ""
-for k in errorcode.keys():
+for k in errorcode.keys ():
     errstr += t % tuple(3*[errorcode[k]])
 
 for l in stdin:
     print l.replace("@SYSDEP_ERRNO_LIST@", errstr),
 '
 fi
 
 exit $?
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -1554,18 +1554,18 @@ keys_ok (const Octave_map& a, const Octa
 
   if (a.nfields () == 0)
     {
       keys = b.keys ();
       retval = true;
     }
   else
     {
-      string_vector a_keys = a.keys().sort ();
-      string_vector b_keys = b.keys().sort ();
+      string_vector a_keys = a.keys ().sort ();
+      string_vector b_keys = b.keys ().sort ();
 
       octave_idx_type a_len = a_keys.length ();
       octave_idx_type b_len = b_keys.length ();
 
       if (a_len == b_len)
         {
           for (octave_idx_type i = 0; i < a_len; i++)
             {
@@ -1580,33 +1580,33 @@ keys_ok (const Octave_map& a, const Octa
 
  done:
   return retval;
 }
 
 Octave_map&
 Octave_map::maybe_delete_elements (const octave_value_list& idx)
 {
-  string_vector t_keys = keys();
+  string_vector t_keys = keys ();
   octave_idx_type len = t_keys.length ();
 
   if (len > 0)
     {
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string k = t_keys[i];
 
           contents(k).delete_elements (idx);
 
           if (error_state)
             break;
         }
 
       if (!error_state)
-        dimensions = contents(t_keys[0]).dims();
+        dimensions = contents(t_keys[0]).dims ();
     }
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const Octave_map& rhs)
 {
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -121,17 +121,17 @@ public:
   bool all_strings_p (void) const;
 
   bool all_scalars (void) const;
 
   bool any_cell (void) const;
 
   bool has_magic_colon (void) const;
 
-  string_vector make_argv (const std::string& = std::string()) const;
+  string_vector make_argv (const std::string& = std::string ()) const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
   void make_storable_values (void);
 
   octave_value& xelem (octave_idx_type i)
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -2872,17 +2872,17 @@ frob_function (const std::string& fname,
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
           fcn->stash_parent_fcn_name (curr_fcn_file_name);
 
           if (current_function_depth > 1)
-            fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size()-2]);
+            fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
       if (lexer_flags.parsing_class_method)
         {
           if (current_class_name == id_name)
             fcn->mark_as_class_constructor ();
@@ -2953,17 +2953,17 @@ finish_function (tree_parameter_list *re
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
           fcn->mark_as_subfunction ();
 
           if (endfunction_found && function_scopes.size () > 1)
             {
               symbol_table::scope_id pscope
-                = function_scopes[function_scopes.size()-2];
+                = function_scopes[function_scopes.size ()-2];
 
               symbol_table::install_nestfunction (nm, octave_value (fcn),
                                                   pscope);
             }
           else
             symbol_table::install_subfunction (nm, octave_value (fcn),
                                                primary_fcn_scope);
         }
@@ -3199,17 +3199,17 @@ finish_cell (tree_cell *c)
   return finish_matrix (c);
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (current_function_depth > 0)
     {
-      tree_statement *tmp = t->back();
+      tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file `%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
@@ -3603,17 +3603,17 @@ parse_fcn_file (const std::string& ff, c
           // interrupt.
 
           frame.add_fcn (cleanup_statement_list, &global_command);
 
           fcn_ptr = primary_fcn_ptr;
 
           if (status != 0)
             error ("parse error while reading %s file %s",
-                   file_type.c_str(), ff.c_str ());
+                   file_type.c_str (), ff.c_str ());
         }
       else
         {
           tree_statement *end_of_script
             = make_end ("endscript", input_line_number, current_input_column);
 
           make_script (0, end_of_script);
 
@@ -3687,17 +3687,17 @@ lookup_autoload (const std::string& nm)
     retval = load_path::find_file (p->second);
 
   return retval;
 }
 
 string_vector
 autoloaded_functions (void)
 {
-  string_vector names (autoload_map.size());
+  string_vector names (autoload_map.size ());
 
   octave_idx_type i = 0;
   typedef std::map<std::string, std::string>::const_iterator am_iter;
   for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
     names[i++] = p->first;
 
   return names;
 }
diff --git a/src/octave-config.in.cc b/src/octave-config.in.cc
--- a/src/octave-config.in.cc
+++ b/src/octave-config.in.cc
@@ -162,17 +162,17 @@ initialize (void)
   vars["LOCALVERFCNFILEDIR"] =substitute_prefix (%OCTAVE_LOCALVERFCNFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["LOCALVEROCTFILEDIR"] =substitute_prefix (%OCTAVE_LOCALVEROCTFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["MAN1DIR"] =substitute_prefix (%OCTAVE_MAN1DIR%, PREFIX, OCTAVE_HOME);
   vars["MAN1EXT"] = %OCTAVE_MAN1EXT%;
   vars["MANDIR"] =substitute_prefix (%OCTAVE_MANDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTFILEDIR"] =substitute_prefix (%OCTAVE_OCTFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTINCLUDEDIR"] =substitute_prefix (%OCTAVE_OCTINCLUDEDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTLIBDIR"] =substitute_prefix (%OCTAVE_OCTLIBDIR%, PREFIX, OCTAVE_HOME);
-  vars["PREFIX"] = (OCTAVE_HOME.empty() ? PREFIX : OCTAVE_HOME);
+  vars["PREFIX"] = (OCTAVE_HOME.empty () ? PREFIX : OCTAVE_HOME);
   vars["STARTUPFILEDIR"] =substitute_prefix (%OCTAVE_STARTUPFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["VERSION"] = %OCTAVE_VERSION%;
 }
 
 int
 main (int argc, char **argv)
 {
   initialize ();
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -234,29 +234,29 @@ octave_base_int_matrix<T>::load_ascii (s
   return success;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
-  os.write (reinterpret_cast<const char *> (this->matrix.data()), this->byte_size());
+  os.write (reinterpret_cast<const char *> (this->matrix.data ()), this->byte_size ());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format )
@@ -298,17 +298,17 @@ octave_base_int_matrix<T>::load_binary (
   T m (dv);
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = dv.numel ();
-      int bytes = nel / m.byte_size();
+      int bytes = nel / m.byte_size ();
       for (int i = 0; i < nel; i++)
         switch (bytes)
           {
           case 8:
             swap_bytes<8> (&m(i));
             break;
           case 4:
             swap_bytes<4> (&m(i));
@@ -359,17 +359,17 @@ octave_base_int_matrix<T>::save_hdf5 (hi
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-                     H5P_DEFAULT, this->matrix.data()) >= 0;
+                     H5P_DEFAULT, this->matrix.data ()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
@@ -417,17 +417,17 @@ octave_base_int_matrix<T>::load_hdf5 (hi
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   T m (dv);
   if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-               H5P_DEFAULT, m.fortran_vec()) >= 0)
+               H5P_DEFAULT, m.fortran_vec ()) >= 0)
     {
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
@@ -496,31 +496,31 @@ octave_base_int_scalar<T>::load_ascii (s
     }
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
-  os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size());
+  os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size ());
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format)
 {
   T tmp;
-  if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size()))
+  if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size ()))
     return false;
 
   if (swap)
-    switch (this->byte_size())
+    switch (this->byte_size ())
       {
       case 8:
         swap_bytes<8> (&tmp);
         break;
       case 4:
         swap_bytes<4> (&tmp);
         break;
       case 2:
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -470,13 +470,13 @@ octave_base_matrix<MT>::fast_elem_insert
       typedef typename MT::element_type ET;
       const builtin_type_t btyp = class_to_btyp<ET>::btyp;
       if (btyp == btyp_unknown) // Dead branch?
         return false;
 
       // Set up the pointer to the proper place.
       void *here = reinterpret_cast<void *> (&matrix(n));
       // Ask x to store there if it can.
-      return x.get_rep().fast_elem_insert_self (here, btyp);
+      return x.get_rep ().fast_elem_insert_self (here, btyp);
     }
   else
     return false;
 }
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1112,42 +1112,42 @@ octave_base_value::as_mxArray (void) con
   return 0;
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type) const
 {
   gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type, octave_idx_type) const
 {
   gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (Array<octave_idx_type> &,
                          octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 sortmode
 octave_base_value::is_sorted (sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::is_sorted ()", type_name ());
 
   return UNSORTED;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -324,21 +324,21 @@ octave_bool_matrix::load_ascii (std::ist
   return success;
 }
 
 bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -204,17 +204,17 @@ octave_sparse_bool_matrix::sparse_comple
 {
   return SparseComplexMatrix (this->matrix);
 }
 
 bool
 octave_sparse_bool_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -435,17 +435,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -84,24 +84,24 @@ octave_bool::do_index_op (const octave_v
 }
 
 octave_value
 octave_bool::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       boolNDArray retval (dv, false);
-      if (dv.numel())
+      if (dv.numel ())
         retval(0) = scalar;
       return retval;
     }
   else
     {
       boolNDArray retval (dv);
-      if (dv.numel())
+      if (dv.numel ())
         retval(0) = scalar;
       return retval;
     }
 }
 
 octave_value
 octave_bool::convert_to_str_internal (bool, bool, char type) const
 {
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -939,17 +939,17 @@ octave_cell::load_ascii (std::istream& i
 bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length();
+  int32_t di = - d.length ();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   Cell tmp = cell_value ();
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -516,17 +516,17 @@ octave_class::subsref (const std::string
             else
               retval(0) = octave_value (map.index (idx.front ()),
                                         c_name, parent_list);
           }
           break;
 
         case '.':
           {
-            if (map.numel() > 0)
+            if (map.numel () > 0)
               {
                 Cell t = dotref (idx.front ());
 
                 retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
               }
           }
           break;
 
@@ -700,17 +700,17 @@ octave_class::subsasgn_common (const oct
           else
             tmp = feval (meth.function_value (), args);
 
           // FIXME -- should the subsasgn method be able to return
           // more than one value?
 
           if (tmp.length () > 1)
             error ("expecting single return value from @%s/subsasgn",
-                   class_name().c_str ());
+                   class_name ().c_str ());
 
           else
             retval = tmp(0);
 
           return retval;
         }
     }
 
@@ -909,17 +909,17 @@ octave_class::subsasgn_common (const oct
                       }
                     else
                       error ("invalid class assignment");
                   }
                 else
                   {
                     if (t_rhs.is_empty ())
                       {
-                        map.delete_elements (idx.front());
+                        map.delete_elements (idx.front ());
 
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
@@ -994,30 +994,30 @@ octave_class::index_vector (void) const
     {
       octave_value_list args;
       args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
-          if (tmp(0).is_object())
+          if (tmp(0).is_object ())
             error ("subsindex function must return a valid index vector");
           else
             // Index vector returned by subsindex is zero based
             // (why this inconsistency Mathworks?), and so we must
             // add one to the value returned as the index_vector method
             // expects it to be one based.
             retval = do_binary_op (octave_value::op_add, tmp (0),
                                    octave_value (1.0)).index_vector ();
         }
     }
   else
     error ("no subsindex method defined for class %s",
-           class_name().c_str ());
+           class_name ().c_str ());
 
   return retval;
 }
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
@@ -1131,17 +1131,17 @@ octave_class::all_strings (bool pad) con
         {
           if (tmp(0).is_string ())
             retval = tmp(0).all_strings (pad);
           else
             error ("cname/char method did not return a character string");
         }
     }
   else
-    error ("no char method defined for class %s", class_name().c_str ());
+    error ("no char method defined for class %s", class_name ().c_str ());
 
   return retval;
 }
 
 
 void
 octave_class::print (std::ostream& os, bool) const
 {
@@ -1269,20 +1269,20 @@ octave_class::reconstruct_parents (void)
   bool retval = true, might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
-      if ( val(0).is_object() )
+      if ( val(0).is_object () )
         {
           dbgstr = "blork";
-          if( key == val(0).class_name() )
+          if( key == val(0).class_name () )
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
             }
         }
     }
 
@@ -1439,17 +1439,17 @@ octave_class::load_ascii (std::istream& 
     }
 
   return success;
 }
 
 bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  int32_t classname_len = class_name().length ();
+  int32_t classname_len = class_name ().length ();
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
@@ -1457,17 +1457,17 @@ octave_class::save_binary (std::ostream&
       if (! error_state)
         m = tmp(0).map_value ();
       else
         return false;
     }
   else
     m = map_value ();
 
-  int32_t len = m.nfields();
+  int32_t len = m.nfields ();
   os.write (reinterpret_cast<char *> (&len), 4);
 
   octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
@@ -2184,17 +2184,17 @@ This function may only be called from a 
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
-      for (int i = 0; i < args.length(); i++)
+      for (int i = 0; i < args.length (); i++)
         {
           std::string class_name = args(i).string_value ();
 
           if (! error_state)
             {
               if (! is_built_in_class (class_name))
                 {
                   std::string this_class_name = fcn->name ();
@@ -2236,17 +2236,17 @@ This function may only be called from a 
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
-      for (int i = 0; i < args.length(); i++)
+      for (int i = 0; i < args.length (); i++)
         {
           std::string class_name = args(i).string_value ();
 
           if (! error_state)
             {
               if (! is_built_in_class (class_name))
                 {
                   std::string this_class_name = fcn->name ();
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -131,17 +131,17 @@ public:
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   size_t nparents (void) const { return parent_list.size (); }
 
   octave_value reshape (const dim_vector& new_dims) const
     {
       octave_class retval = octave_class (*this);
-      retval.map = retval.map_value().reshape (new_dims);
+      retval.map = retval.map_value ().reshape (new_dims);
       return octave_value (new octave_class (retval));
     }
 
   octave_value resize (const dim_vector& dv, bool = false) const
     {
       octave_class retval = octave_class (*this);
       retval.map.resize (dv);
       return octave_value (new octave_class (retval));
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -432,21 +432,21 @@ octave_complex_matrix::load_ascii (std::
 
   return success;
 }
 
 bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -223,17 +223,17 @@ octave_sparse_complex_matrix::sparse_boo
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool
 octave_sparse_complex_matrix::save_binary (std::ostream& os,
                                            bool&save_as_floats)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -281,17 +281,17 @@ octave_sparse_complex_matrix::save_binar
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
        itmp = matrix.ridx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
+   write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st, 2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
@@ -471,17 +471,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -863,17 +863,17 @@ octave_sparse_complex_matrix::as_mxArray
   for (mwIndex i = 0; i < nz; i++)
     {
       Complex val = matrix.data(i);
       pr[i] = std::real (val);
       pi[i] = std::imag (val);
       ir[i] = matrix.ridx(i);
     }
 
-  for (mwIndex i = 0; i < columns() + 1; i++)
+  for (mwIndex i = 0; i < columns () + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
 octave_value
 octave_sparse_complex_matrix::map (unary_mapper_t umap) const
 {
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -396,24 +396,24 @@ octave_fcn_handle::save_ascii (std::ostr
 
 bool
 octave_fcn_handle::load_ascii (std::istream& is)
 {
   bool success = true;
 
   std::streampos pos = is.tellg ();
   std::string octaveroot = extract_keyword (is, "octaveroot", true);
-  if (octaveroot.length() == 0)
+  if (octaveroot.length () == 0)
     {
       is.seekg (pos);
       is.clear ();
     }
   pos = is.tellg ();
   std::string fpath = extract_keyword (is, "path", true);
-  if (fpath.length() == 0)
+  if (fpath.length () == 0)
     {
       is.seekg (pos);
       is.clear ();
     }
 
   is >> nm;
 
   if (nm == anonymous)
@@ -528,17 +528,17 @@ octave_fcn_handle::save_binary (std::ost
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
         nmbuf << nm;
 
-      std::string buf_str = nmbuf.str();
+      std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
 
       std::ostringstream buf;
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
@@ -593,21 +593,21 @@ octave_fcn_handle::load_binary (std::ist
   ctmp1[tmp] = 0;
   nm = std::string (ctmp1);
 
   if (! is)
     return false;
 
   size_t anl = anonymous.length ();
 
-  if (nm.length() >= anl && nm.substr (0, anl) == anonymous)
+  if (nm.length () >= anl && nm.substr (0, anl) == anonymous)
     {
       octave_idx_type len = 0;
 
-      if (nm.length() > anl)
+      if (nm.length () > anl)
         {
           std::istringstream nm_is (nm.substr (anl));
           nm_is >> len;
           nm = nm.substr (0, anl);
         }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -421,21 +421,21 @@ octave_float_complex_matrix::load_ascii 
 
   return success;
 }
 
 bool
 octave_float_complex_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatComplexNDArray m = complex_array_value ();
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -454,21 +454,21 @@ octave_float_matrix::load_ascii (std::is
   return success;
 }
 
 bool
 octave_float_matrix::save_binary (std::ostream& os, bool&)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatNDArray m = float_array_value ();
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -140,17 +140,17 @@ public:
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
     {
       Matrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
       else
         {
           retval = Matrix (dv(0), dv(1));
           double *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = matrix(i).double_value ();
         }
@@ -158,53 +158,53 @@ public:
     }
 
   FloatMatrix
   float_matrix_value (bool = false) const
     {
       FloatMatrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
       else
         {
           retval = FloatMatrix (dv(0), dv(1));
           float *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = matrix(i).float_value ();
         }
       return retval;
     }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
     {
       ComplexMatrix retval;
-      dim_vector dv = dims();
+      dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
       else
         {
           retval = ComplexMatrix (dv(0), dv(1));
           Complex *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = Complex (matrix(i).double_value ());
         }
       return retval;
     }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
     {
       FloatComplexMatrix retval;
-      dim_vector dv = dims();
+      dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
       else
         {
           retval = FloatComplexMatrix (dv(0), dv(1));
           FloatComplex *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = FloatComplex (matrix(i).float_value ());
         }
@@ -284,22 +284,22 @@ public:
       vec[i] = matrix(i).char_value ();
 
     return retval;
   }
 
   // Use matrix_ref here to clear index cache.
   void increment (void)
    {
-     matrix_ref() += OCTAVE_INT_T (1);
+     matrix_ref () += OCTAVE_INT_T (1);
    }
 
   void decrement (void)
    {
-     matrix_ref() -= OCTAVE_INT_T (1);
+     matrix_ref () -= OCTAVE_INT_T (1);
    }
 
   void changesign (void)
    {
      matrix_ref ().changesign ();
    }
 
   idx_vector index_vector (void) const
@@ -474,24 +474,24 @@ public:
   uint64_array_value (void) const
     { return uint64NDArray (dim_vector (1, 1), uint64_scalar_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
     {
       if (fill)
         {
           intNDArray<OCTAVE_INT_T> retval (dv, 0);
-          if (dv.numel())
+          if (dv.numel ())
             retval(0) = scalar;
           return retval;
         }
       else
         {
           intNDArray<OCTAVE_INT_T> retval (dv);
-          if (dv.numel())
+          if (dv.numel ())
             retval(0) = scalar;
           return retval;
         }
     }
 
   double double_value (bool = false) const { return scalar.double_value (); }
 
   float float_value (bool = false) const { return scalar.float_value (); }
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -113,20 +113,20 @@ public:
     }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return NDArray (array_value().reshape (new_dims)); }
+    { return NDArray (array_value ().reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return NDArray (array_value().permute (vec, inv)); }
+    { return NDArray (array_value ().permute (vec, inv)); }
 
   octave_value squeeze (void) const { return range; }
 
   octave_value full_value (void) const { return range.matrix_value (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -556,21 +556,21 @@ octave_matrix::load_ascii (std::istream&
   return success;
 }
 
 bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -256,17 +256,17 @@ octave_sparse_matrix::convert_to_str_int
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::save_binary (std::ostream& os, bool&save_as_floats)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -314,17 +314,17 @@ octave_sparse_matrix::save_binary (std::
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
        itmp = matrix.ridx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   write_doubles (os, matrix.data(), st, nz);
+   write_doubles (os, matrix.data (), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
@@ -501,17 +501,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -852,23 +852,23 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
-  mwSize nz = nzmax();
-  mwSize nr = rows();
-  mwSize nc = columns();
+  mwSize nz = nzmax ();
+  mwSize nr = rows ();
+  mwSize nc = columns ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, nr, nc, nz, mxREAL);
   double *pr = static_cast<double *> (retval->get_data ());
-  mwIndex *ir = retval->get_ir();
-  mwIndex *jc = retval->get_jc();
+  mwIndex *ir = retval->get_ir ();
+  mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       pr[i] = matrix.data(i);
       ir[i] = matrix.ridx(i);
     }
 
   for (mwIndex i = 0; i < nc + 1; i++)
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -460,21 +460,21 @@ octave_char_matrix_str::load_ascii (std:
   return success;
 }
 
 bool
 octave_char_matrix_str::save_binary (std::ostream& os,
                                      bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -149,17 +149,17 @@ octave_struct::subsref (const std::strin
           }
         else
           retval(0) = do_index_op (idx.front ());
       }
       break;
 
     case '.':
       {
-        if (map.numel() > 0)
+        if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front ());
 
             retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
@@ -215,17 +215,17 @@ octave_struct::subsref (const std::strin
           }
         else
           retval = do_index_op (idx.front (), auto_add);
       }
       break;
 
     case '.':
       {
-        if (map.numel() > 0)
+        if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front (), auto_add);
 
             retval = (t.length () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
@@ -476,17 +476,17 @@ octave_struct::subsasgn (const std::stri
                           gripe_nonbraced_cs_list_assignment ();
                       }
                   }
                 else
                   gripe_failed_assignment ();
               }
             else
               {
-                if (t_rhs.is_map() || t_rhs.is_object ())
+                if (t_rhs.is_map () || t_rhs.is_object ())
                   {
                     octave_map rhs_map = t_rhs.map_value ();
 
                     if (! error_state)
                       {
                         map.assign (idx.front (), rhs_map);
 
                         if (! error_state)
@@ -497,19 +497,19 @@ octave_struct::subsasgn (const std::stri
                         else
                           gripe_failed_assignment ();
                       }
                     else
                       error ("invalid structure assignment");
                   }
                 else
                   {
-                    if (t_rhs.is_null_value())
+                    if (t_rhs.is_null_value ())
                       {
-                        map.delete_elements (idx.front());
+                        map.delete_elements (idx.front ());
 
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
@@ -818,17 +818,17 @@ octave_struct::save_binary (std::ostream
 
   octave_idx_type nf = m.nfields ();
 
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length();
+  int32_t di = - d.length ();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   int32_t len = nf;
@@ -1074,17 +1074,17 @@ octave_struct::fast_elem_insert (octave_
   bool retval = false;
 
   if (n < map.numel ())
     {
       // To avoid copying the scalar struct, it just stores a pointer to
       // itself.
       const octave_scalar_map *sm_ptr;
       void *here = reinterpret_cast<void *>(&sm_ptr);
-      return (x.get_rep().fast_elem_insert_self (here, btyp_struct)
+      return (x.get_rep ().fast_elem_insert_self (here, btyp_struct)
               && map.fast_elem_insert (n, *sm_ptr));
     }
 
   return retval;
 }
 DEFINE_OCTAVE_ALLOCATOR(octave_scalar_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_scalar_struct, "scalar struct", "struct");
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -273,17 +273,17 @@ public:
 
   bool is_anonymous_function (void) const { return anonymous_function; }
 
   bool is_anonymous_function_of_class
     (const std::string& cname = std::string ()) const
   {
     return anonymous_function
       ? (cname.empty ()
-         ? (! dispatch_class().empty ())
+         ? (! dispatch_class ().empty ())
          : cname == dispatch_class ())
       : false;
   }
 
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -189,45 +189,45 @@ public:
   octave_value (unsigned long long int i);
 #endif
 
   octave_value (octave_time t);
   octave_value (double d);
   octave_value (float d);
   octave_value (const Array<octave_value>& a, bool is_cs_list = false);
   octave_value (const Cell& c, bool is_cs_list = false);
-  octave_value (const Matrix& m, const MatrixType& t = MatrixType());
-  octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType());
+  octave_value (const Matrix& m, const MatrixType& t = MatrixType ());
+  octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const NDArray& nda);
   octave_value (const FloatNDArray& nda);
   octave_value (const Array<double>& m);
   octave_value (const Array<float>& m);
   octave_value (const DiagMatrix& d);
   octave_value (const FloatDiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const FloatRowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const FloatColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const FloatComplex& C);
-  octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType());
-  octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType());
+  octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType ());
+  octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const ComplexNDArray& cnda);
   octave_value (const FloatComplexNDArray& cnda);
   octave_value (const Array<Complex>& m);
   octave_value (const Array<FloatComplex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const FloatComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const FloatComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (const FloatComplexColumnVector& v);
   octave_value (const PermMatrix& p);
   octave_value (bool b);
-  octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType());
+  octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType ());
   octave_value (const boolNDArray& bnda);
   octave_value (const Array<bool>& bnda);
   octave_value (char c, char type = '\'');
   octave_value (const char *s, char type = '\'');
   octave_value (const std::string& s, char type = '\'');
   octave_value (const string_vector& s, char type = '\'');
   octave_value (const charMatrix& chm,  char type = '\'');
   octave_value (const charNDArray& chnda, char type = '\'');
@@ -453,17 +453,17 @@ public:
   octave_idx_type rows (void) const { return rep->rows (); }
 
   octave_idx_type columns (void) const { return rep->columns (); }
 
   octave_idx_type length (void) const;
 
   int ndims (void) const { return rep->ndims (); }
 
-  bool all_zero_dims (void) const { return dims().all_zero (); }
+  bool all_zero_dims (void) const { return dims ().all_zero (); }
 
   octave_idx_type numel (void) const
     { return rep->numel (); }
 
   octave_idx_type capacity (void) const
     { return rep->capacity (); }
 
   size_t byte_size (void) const
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -370,17 +370,17 @@ rational_approx (double val, int len)
       double n = xround (val);
       double d = 1.;
       double frac = val - n;
       int m = 0;
 
       std::ostringstream buf2;
       buf2.flags (std::ios::fixed);
       buf2 << std::setprecision (0) << static_cast<int>(n);
-      s = buf2.str();
+      s = buf2.str ();
 
       while (1)
         {
           double flip = 1. / frac;
           double step = xround (flip);
           double nextn = n;
           double nextd = d;
 
@@ -402,37 +402,37 @@ rational_approx (double val, int len)
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(n)
               << "/" << static_cast<int>(d);
           m++;
 
           if (n < 0 && d < 0)
             {
               // Double negative, string can be two characters longer..
-              if (buf.str().length() > static_cast<unsigned int>(len + 2) &&
+              if (buf.str ().length () > static_cast<unsigned int>(len + 2) &&
                   m > 1)
                 break;
             }
-          else if (buf.str().length() > static_cast<unsigned int>(len) &&
+          else if (buf.str ().length () > static_cast<unsigned int>(len) &&
                    m > 1)
             break;
 
-          s = buf.str();
+          s = buf.str ();
         }
 
       if (lastd < 0.)
         {
           // Move sign to the top
           lastd = - lastd;
           lastn = - lastn;
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(lastn)
                << "/" << static_cast<int>(lastd);
-          s = buf.str();
+          s = buf.str ();
         }
     }
 
   return s;
 }
 
 class
 pr_rational_float
@@ -455,17 +455,17 @@ operator << (std::ostream& os, const pr_
 
   if (fw >= 0)
     os << std::setw (fw);
 
   std::ios::fmtflags oflags =
     os.flags (static_cast<std::ios::fmtflags>
               (prf.f.fmt | prf.f.up | prf.f.sp));
 
-  if (fw > 0 && s.length() > static_cast<unsigned int>(fw))
+  if (fw > 0 && s.length () > static_cast<unsigned int>(fw))
     os << "*";
   else
     os << s;
 
   os.flags (oflags);
 
   return os;
 }
@@ -2959,18 +2959,18 @@ PRINT_CONV (octave_int8, octave_int16);
 PRINT_CONV (octave_uint8, octave_uint16);
 
 #undef PRINT_CONV
 
 template <class T>
 /* static */ inline void
 pr_int (std::ostream& os, const T& d, int fw = 0)
 {
-  size_t sz = d.byte_size();
-  const unsigned char * tmpi = d.iptr();
+  size_t sz = d.byte_size ();
+  const unsigned char * tmpi = d.iptr ();
 
   // Unless explicitly asked for, always print in big-endian
   // format for hex and bit formats.
   //
   //   {bit,hex}_format == 1: print big-endian
   //   {bit,hex}_format == 2: print native
 
   if (hex_format)
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -109,17 +109,17 @@ tree_identifier::rvalue1 (int nargout)
     retval = tmp(0);
 
   return retval;
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
-  return octave_lvalue (&(xsym().varref ()));
+  return octave_lvalue (&(xsym ().varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -58,19 +58,19 @@ public:
   bool has_magic_end (void) const { return (name () == "__end__"); }
 
   bool is_identifier (void) const { return true; }
 
   // The name doesn't change with scope, so use sym instead of
   // accessing it through sym so that this function may remain const.
   std::string name (void) const { return sym.name (); }
 
-  bool is_defined (void) { return xsym().is_defined (); }
+  bool is_defined (void) { return xsym ().is_defined (); }
 
-  virtual bool is_variable (void) { return xsym().is_variable (); }
+  virtual bool is_variable (void) { return xsym ().is_variable (); }
 
   virtual bool is_black_hole (void) { return false; }
 
   // Try to find a definition for an identifier.  Here's how:
   //
   //   * If the identifier is already defined and is a function defined
   //     in an function file that has been modified since the last time
   //     we parsed it, parse it again.
@@ -82,24 +82,24 @@ public:
   //     function file to parse.
   //
   //   * On systems that support dynamic linking, we prefer .oct files,
   //     then .mex files, then .m files.
 
   octave_value
   do_lookup (const octave_value_list& args = octave_value_list ())
   {
-    return xsym().find (args);
+    return xsym ().find (args);
   }
 
-  void mark_global (void) { xsym().mark_global (); }
+  void mark_global (void) { xsym ().mark_global (); }
 
-  void mark_as_static (void) { xsym().init_persistent (); }
+  void mark_as_static (void) { xsym ().init_persistent (); }
 
-  void mark_as_formal_parameter (void) { xsym().mark_formal (); }
+  void mark_as_formal_parameter (void) { xsym ().mark_formal (); }
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
   bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1105,17 +1105,17 @@ tree_matrix::rvalue1 (int)
 
                       ctmp = *q;
 
                       if (! ctmp.all_zero_dims ())
                         goto found_non_empty;
                     }
                 }
 
-              ctmp = (*(tmp.begin() -> begin()));
+              ctmp = (*(tmp.begin () -> begin ()));
 
             found_non_empty:
 
               if (! all_empty_p)
                 ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
             }
 
           if (! error_state)
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -118,17 +118,17 @@ tree_switch_case::~tree_switch_case (voi
 }
 
 
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
-  if (! error_state && label_value.is_defined() )
+  if (! error_state && label_value.is_defined () )
     {
       if (label_value.is_cell ())
         {
           Cell cell (label_value.cell_value ());
 
           for (octave_idx_type i = 0; i < cell.rows (); i++)
             {
               for (octave_idx_type j = 0; j < cell.columns (); j++)
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 
 DEFUN (issparse, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
-   if (args.length() != 1)
+   if (args.length () != 1)
      {
        print_usage ();
        return octave_value ();
      }
    else
      return octave_value (args(0).is_sparse_type ());
 }
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1136,19 +1136,19 @@ symbol_table::fcn_info::fcn_info_rep::du
 void
 symbol_table::install_nestfunction (const std::string& name,
                                     const octave_value& fcn,
                                     scope_id parent_scope)
 {
   install_subfunction (name, fcn, parent_scope);
 
   // Stash the nest_parent for resolving variables after parsing is done.
-  octave_function *fv = fcn.function_value();
+  octave_function *fv = fcn.function_value ();
 
-  symbol_table *fcn_table_loc = get_instance (fv->scope());
+  symbol_table *fcn_table_loc = get_instance (fv->scope ());
 
   symbol_table *parent_table = get_instance (parent_scope);
 
   parent_table->add_nest_child (*fcn_table_loc);
 }
 
 octave_value
 symbol_table::find (const std::string& name,
@@ -1486,17 +1486,17 @@ symbol_table::do_update_nest (void)
                   ours.invalidate ();
                   ti->second = parents;
                 }
             }
           else
             ours.set_curr_fcn (curr_fcn);
         }
     }
-  else if (nest_children.size())
+  else if (nest_children.size ())
     for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
       ti->second.set_curr_fcn (curr_fcn);
 
   for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
        iter != nest_children.end (); ++iter)
     (*iter)->do_update_nest ();
 }
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -2337,17 +2337,17 @@ private:
   }
 
   void do_clear_objects (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
         symbol_record& sr = p->second;
         octave_value& val = sr.varref ();
-        if (val.is_object())
+        if (val.is_object ())
           p->second.clear (my_scope);
       }
   }
 
  void do_unmark_forced_variables (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       p->second.unmark_forced ();
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -286,17 +286,17 @@ exit status, it will linger until Octave
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
-      std::string exec_file = args(0).string_value();
+      std::string exec_file = args(0).string_value ();
 
       if (! error_state)
         {
           string_vector arg_list;
 
           if (nargin >= 2)
             {
               string_vector tmp = args(1).all_strings ();
@@ -319,17 +319,17 @@ exit status, it will linger until Octave
             {
               arg_list.resize (1);
 
               arg_list[0] = exec_file;
             }
 
           if (! error_state)
             {
-              bool sync_mode = (nargin == 3 ? args(2).bool_value() : false);
+              bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
 
               if (! error_state)
                 {
                   int fildes[2];
                   std::string msg;
                   pid_t pid;
 
                   pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode, fildes, msg, interactive);
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -957,17 +957,17 @@ command shell that is started to run the
                 }
               else
                 retval(0) = pid;
 #elif defined (__WIN32__)
               STARTUPINFO si;
               PROCESS_INFORMATION pi;
               ZeroMemory (&si, sizeof (si));
               ZeroMemory (&pi, sizeof (pi));
-              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length()+1);
+              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length ()+1);
               strcpy (xcmd_str, cmd_str.c_str ());
 
               if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
                 error ("system: CreateProcess failed -- can't create child process");
               else
                 {
                   retval(0) = pi.dwProcessId;
                   CloseHandle (pi.hProcess);
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -235,17 +235,17 @@ private:
 
 ft_manager* ft_manager::instance = 0;
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
     : text_processor (), face (0), bbox (1, 4, 0.0),
       xoffset (0), yoffset (0), multiline_halign (0),
-      multiline_align_xoffsets(), mode (MODE_BBOX),
+      multiline_align_xoffsets (), mode (MODE_BBOX),
       red (0), green (0), blue (0)
 {
 }
 
 ft_render::~ft_render (void)
 {
   if (face)
     FT_Done_Face (face);
@@ -309,17 +309,17 @@ ft_render::visit (text_element_string& e
   if (face)
     {
       int line_index = 0;
       FT_UInt box_line_width = 0;
       std::string str = e.string_value ();
       FT_UInt glyph_index, previous = 0;
 
       if (mode == MODE_BBOX)
-        multiline_align_xoffsets.clear();
+        multiline_align_xoffsets.clear ();
       else if (mode == MODE_RENDER)
         xoffset += multiline_align_xoffsets[line_index];
 
       for (size_t i = 0; i < str.length (); i++)
         {
           glyph_index = FT_Get_Char_Index (face, str[i]);
 
           if (str[i] != '\n'
@@ -371,18 +371,18 @@ ft_render::visit (text_element_string& e
                       // the right amount of horizontal space in the bbox.
                       if (x0 < 0)
                         x0 = 0;
 
                       for (int r = 0; r < bitmap.rows; r++)
                         for (int c = 0; c < bitmap.width; c++)
                           {
                             unsigned char pix = bitmap.buffer[r*bitmap.width+c];
-                            if (x0+c < 0 || x0+c >= pixels.dim2()
-                                || y0-r < 0 || y0-r >= pixels.dim3())
+                            if (x0+c < 0 || x0+c >= pixels.dim2 ()
+                                || y0-r < 0 || y0-r >= pixels.dim3 ())
                               {
                                 //::error ("out-of-bound indexing!!");
                               }
                             else if (pixels(3, x0+c, y0-r).value () == 0)
                               {
                                 pixels(0, x0+c, y0-r) = red;
                                 pixels(1, x0+c, y0-r) = green;
                                 pixels(2, x0+c, y0-r) = blue;
@@ -462,17 +462,17 @@ ft_render::visit (text_element_string& e
                   previous = glyph_index;
             }
         }
       if (mode == MODE_BBOX)
         {
           /* Push last the width associated with the last line */
           multiline_align_xoffsets.push_back(box_line_width);
 
-          for (unsigned int i = 0; i < multiline_align_xoffsets.size(); i++)
+          for (unsigned int i = 0; i < multiline_align_xoffsets.size (); i++)
             {
             /* Center align */
             if (multiline_halign == 1)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
             /* Right align */
             else if (multiline_halign == 2)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i]);
             /* Left align */
@@ -524,42 +524,42 @@ ft_render::render (text_element* elt, Ma
               Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
+              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
               idx(2) = idx_vector (':');
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_180:
             {
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
-              idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
+              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
+              idx(2)=  idx_vector (pixels.dim3 ()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_270:
             {
               Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (':');
-              idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
+              idx(2) = idx_vector (pixels.dim3 ()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         }
     }
 
   return pixels;
 }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1514,17 +1514,17 @@ public:
             text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
             pos = text.find ('%');
             if (pos != std::string::npos)
               text = text.substr (0, pos);
 
             // Push parameter into list ...
             idx += text.length ();
             param.text=text;
-            param.line.assign (text.length(), ' ');
+            param.line.assign (text.length (), ' ');
             params.push_back (param);
           }
       }
 
     return params;
   }
 
 private:
@@ -1971,17 +1971,17 @@ DEFUN (munlock, args, ,
 @deftypefnx {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function @var{fcn}.  If no function is named\n\
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length() == 1)
+  if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         munlock (name);
       else
         error ("munlock: FCN must be a string");
     }
@@ -2007,17 +2007,17 @@ DEFUN (mislocked, args, ,
 @deftypefnx {Built-in Function} {} mislocked (@var{fcn})\n\
 Return true if the named function @var{fcn} is locked.  If no function is\n\
 named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length() == 1)
+  if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         retval = mislocked (name);
       else
         error ("mislocked: FCN must be a string");
     }
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -47,119 +47,119 @@ along with Octave; see the file COPYING.
 // Internal buffer sizes (default and "unbuffered" versions)
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
 /*****************************************************************************/
 
 // Default constructor
-gzfilebuf::gzfilebuf()
+gzfilebuf::gzfilebuf ()
 : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
   buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
-  this->disable_buffer();
+  this->disable_buffer ();
 }
 
 // Destructor
-gzfilebuf::~gzfilebuf()
+gzfilebuf::~gzfilebuf ()
 {
   // Sync output buffer and close only if responsible for file
   // (i.e. attached streams should be left open at this stage)
-  this->sync();
+  this->sync ();
   if (own_fd)
-    this->close();
+    this->close ();
   // Make sure internal buffer is deallocated
-  this->disable_buffer();
+  this->disable_buffer ();
 }
 
 // Set compression level and strategy
 int
 gzfilebuf::setcompression(int comp_level,
                           int comp_strategy)
 {
   return gzsetparams(file, comp_level, comp_strategy);
 }
 
 // Open gzipped file
 gzfilebuf*
 gzfilebuf::open(const char *name,
                 std::ios_base::openmode mode)
 {
   // Fail if file already open
-  if (this->is_open())
+  if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (!this->open_mode(mode, char_mode))
     return 0;
 
   // Attempt to open file
   if ((file = gzopen(name, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
-  this->enable_buffer();
+  this->enable_buffer ();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
 gzfilebuf::attach(int fd,
                   std::ios_base::openmode mode)
 {
   // Fail if file already open
-  if (this->is_open())
+  if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzdopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (!this->open_mode(mode, char_mode))
     return 0;
 
   // Attempt to attach to file
   if ((file = gzdopen(fd, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
-  this->enable_buffer();
+  this->enable_buffer ();
   io_mode = mode;
   own_fd = false;
   return this;
 }
 
 // Close gzipped file
 gzfilebuf*
-gzfilebuf::close()
+gzfilebuf::close ()
 {
   // Fail immediately if no file is open
-  if (!this->is_open())
+  if (!this->is_open ())
     return 0;
   // Assume success
   gzfilebuf* retval = this;
   // Attempt to sync and close gzipped file
-  if (this->sync() == -1)
+  if (this->sync () == -1)
     retval = 0;
   if (gzclose(file) < 0)
     retval = 0;
   // File is now gone anyway (postcondition [27.8.1.3.8])
   file = 0;
   own_fd = false;
   // Destroy internal buffer if it exists
-  this->disable_buffer();
+  this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
 gzfilebuf::open_mode(std::ios_base::openmode mode,
@@ -197,209 +197,209 @@ gzfilebuf::open_mode(std::ios_base::open
 
   strcat(c_mode, "b");
 
   return true;
 }
 
 // Determine number of characters in internal get buffer
 std::streamsize
-gzfilebuf::showmanyc()
+gzfilebuf::showmanyc ()
 {
   // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
+  if (!this->is_open () || !(io_mode & std::ios_base::in))
     return -1;
   // Make sure get area is in use
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return std::streamsize(this->egptr() - this->gptr());
+  if (this->gptr () && (this->gptr () < this->egptr ()))
+    return std::streamsize(this->egptr () - this->gptr ());
   else
     return 0;
 }
 
 // Puts back a character to the stream in two cases. Firstly, when there
 // is no putback position available, and secondly when the character putback
 // differs from the one in the file. We can only support the first case
 // with gzipped files.
 gzfilebuf::int_type
 gzfilebuf::pbackfail (gzfilebuf::int_type c)
 {
-  if (this->is_open())
+  if (this->is_open ())
     {
-      if (gzseek (file, this->gptr() - this->egptr() - 1, SEEK_CUR) < 0)
-        return traits_type::eof();
+      if (gzseek (file, this->gptr () - this->egptr () - 1, SEEK_CUR) < 0)
+        return traits_type::eof ();
 
       // Invalidates contents of the buffer
       enable_buffer ();
 
       // Attempt to fill internal buffer from gzipped file
       // (buffer must be guaranteed to exist...)
       int bytes_read = gzread(file, buffer, buffer_size);
       // Indicates error or EOF
       if (bytes_read <= 0)
         {
           // Reset get area
           this->setg(buffer, buffer, buffer);
-          return traits_type::eof();
+          return traits_type::eof ();
         }
 
       // Make all bytes read from file available as get area
       this->setg(buffer, buffer, buffer + bytes_read);
 
       // If next character in get area differs from putback character
       // flag a failure
-      gzfilebuf::int_type ret = traits_type::to_int_type(*(this->gptr()));
+      gzfilebuf::int_type ret = traits_type::to_int_type(*(this->gptr ()));
       if (ret != c)
-        return traits_type::eof();
+        return traits_type::eof ();
       else
         return ret;
     }
   else
-    return traits_type::eof();
+    return traits_type::eof ();
 }
 
 // Fill get area from gzipped file
 gzfilebuf::int_type
-gzfilebuf::underflow()
+gzfilebuf::underflow ()
 {
   // If something is left in the get area by chance, return it
   // (this shouldn't normally happen, as underflow is only supposed
   // to be called when gptr >= egptr, but it serves as error check)
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return traits_type::to_int_type(*(this->gptr()));
+  if (this->gptr () && (this->gptr () < this->egptr ()))
+    return traits_type::to_int_type(*(this->gptr ()));
 
   // If the file hasn't been opened for reading, produce error
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return traits_type::eof();
+  if (!this->is_open () || !(io_mode & std::ios_base::in))
+    return traits_type::eof ();
 
   // Copy the final characters to the front of the buffer
   int stash = 0;
-  if (this->eback() && buffer && buffer_size > STASHED_CHARACTERS)
+  if (this->eback () && buffer && buffer_size > STASHED_CHARACTERS)
     {
       char_type *ptr1 = buffer;
-      char_type *ptr2 = this->egptr() - STASHED_CHARACTERS + 1;
-      if (ptr2 > this->eback())
+      char_type *ptr2 = this->egptr () - STASHED_CHARACTERS + 1;
+      if (ptr2 > this->eback ())
         while (stash++ <= STASHED_CHARACTERS)
           *ptr1++ = *ptr2++;
     }
 
   // Attempt to fill internal buffer from gzipped file
   // (buffer must be guaranteed to exist...)
   int bytes_read = gzread(file, buffer + stash, buffer_size - stash);
 
   // Indicates error or EOF
   if (bytes_read <= 0)
   {
     // Reset get area
     this->setg(buffer, buffer, buffer);
-    return traits_type::eof();
+    return traits_type::eof ();
   }
   // Make all bytes read from file plus the stash available as get area
   this->setg(buffer, buffer + stash, buffer + bytes_read + stash);
 
   // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr()));
+  return traits_type::to_int_type(*(this->gptr ()));
 }
 
 // Write put area to gzipped file
 gzfilebuf::int_type
 gzfilebuf::overflow(int_type c)
 {
   // Determine whether put area is in use
-  if (this->pbase())
+  if (this->pbase ())
   {
     // Double-check pointer range
-    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())
-      return traits_type::eof();
+    if (this->pptr () > this->epptr () || this->pptr () < this->pbase ())
+      return traits_type::eof ();
     // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
+    if (!traits_type::eq_int_type(c, traits_type::eof ()))
     {
       *(this->pptr()) = traits_type::to_char_type(c);
       this->pbump(1);
     }
     // Number of characters to write to file
-    int bytes_to_write = this->pptr() - this->pbase();
+    int bytes_to_write = this->pptr () - this->pbase ();
     // Overflow doesn't fail if nothing is to be written
     if (bytes_to_write > 0)
     {
       // If the file hasn't been opened for writing, produce error
-      if (!this->is_open() || !(io_mode & std::ios_base::out))
-        return traits_type::eof();
+      if (!this->is_open () || !(io_mode & std::ios_base::out))
+        return traits_type::eof ();
       // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)
-        return traits_type::eof();
+      if (gzwrite(file, this->pbase (), bytes_to_write) != bytes_to_write)
+        return traits_type::eof ();
       // Reset next pointer to point to pbase on success
       this->pbump(-bytes_to_write);
     }
   }
   // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof()))
+  else if (!traits_type::eq_int_type(c, traits_type::eof ()))
   {
     // If the file hasn't been opened for writing, produce error
-    if (!this->is_open() || !(io_mode & std::ios_base::out))
-      return traits_type::eof();
+    if (!this->is_open () || !(io_mode & std::ios_base::out))
+      return traits_type::eof ();
     // Impromptu char buffer (allows "unbuffered" output)
     char_type last_char = traits_type::to_char_type(c);
     // If gzipped file won't accept this character, fail
     if (gzwrite(file, &last_char, 1) != 1)
-      return traits_type::eof();
+      return traits_type::eof ();
   }
 
   // If you got here, you have succeeded (even if c was EOF)
   // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof()))
+  if (traits_type::eq_int_type(c, traits_type::eof ()))
     return traits_type::not_eof(c);
   else
     return c;
 }
 
 // Assign new buffer
 std::streambuf*
 gzfilebuf::setbuf(char_type* p,
                   std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
-  if (this->sync() == -1)
+  if (this->sync () == -1)
     return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
   // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
   if (!p || !n)
   {
     // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer();
+    this->disable_buffer ();
     buffer = 0;
     buffer_size = 0;
     own_buffer = true;
-    this->enable_buffer();
+    this->enable_buffer ();
   }
   else
   {
     // Replace existing buffer (if any) with external buffer
-    this->disable_buffer();
+    this->disable_buffer ();
     buffer = p;
     buffer_size = n;
     own_buffer = false;
-    this->enable_buffer();
+    this->enable_buffer ();
   }
   return this;
 }
 
 // Write put area to gzipped file (i.e. ensures that put area is empty)
 int
-gzfilebuf::sync()
+gzfilebuf::sync ()
 {
-  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;
+  return traits_type::eq_int_type(this->overflow (), traits_type::eof ()) ? -1 : 0;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Allocate internal buffer
 void
-gzfilebuf::enable_buffer()
+gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
@@ -428,23 +428,23 @@ gzfilebuf::enable_buffer()
     // stale chars are lying around
     this->setg(buffer, buffer, buffer);
     this->setp(buffer, buffer + buffer_size - 1);
   }
 }
 
 // Destroy internal buffer
 void
-gzfilebuf::disable_buffer()
+gzfilebuf::disable_buffer ()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
   {
     // Preserve unbuffered status by zeroing size
-    if (!this->pbase())
+    if (!this->pbase ())
       buffer_size = 0;
     delete[] buffer;
     buffer = 0;
     this->setg(0, 0, 0);
     this->setp(0, 0);
   }
   else
   {
@@ -461,22 +461,22 @@ gzfilebuf::disable_buffer()
 
 // Seek functions
 gzfilebuf::pos_type
 gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way,
                    std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
-  if (this->is_open())
+  if (this->is_open ())
     {
       off_type computed_off = off;
 
       if ((io_mode & std::ios_base::in) && way == std::ios_base::cur)
-        computed_off += this->gptr() - this->egptr();
+        computed_off += this->gptr () - this->egptr ();
 
       if (way == std::ios_base::beg)
         ret = pos_type (gzseek (file, computed_off, SEEK_SET));
       else if (way == std::ios_base::cur)
         ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
       else
         // Can't seek from end of a gzipped file, so this will give -1
         ret = pos_type (gzseek (file, computed_off, SEEK_END));
@@ -510,116 +510,116 @@ gzfilebuf::seekpos(pos_type sp, std::ios
     }
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
-gzifstream::gzifstream()
-: std::istream(0), sb()
+gzifstream::gzifstream ()
+: std::istream(0), sb ()
 { this->init(&sb); }
 
 // Initialize stream buffer and open file
 gzifstream::gzifstream(const char* name,
                        std::ios_base::openmode mode)
-: std::istream(0), sb()
+: std::istream(0), sb ()
 {
   this->init(&sb);
   this->open(name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzifstream::gzifstream(int fd,
                        std::ios_base::openmode mode)
-: std::istream(0), sb()
+: std::istream(0), sb ()
 {
   this->init(&sb);
   this->attach(fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzifstream::open(const char* name,
                  std::ios_base::openmode mode)
 {
   if (!sb.open(name, mode | std::ios_base::in))
     this->setstate(std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
 gzifstream::attach(int fd,
                    std::ios_base::openmode mode)
 {
   if (!sb.attach(fd, mode | std::ios_base::in))
     this->setstate(std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Close file
 void
-gzifstream::close()
+gzifstream::close ()
 {
-  if (!sb.close())
+  if (!sb.close ())
     this->setstate(std::ios_base::failbit);
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
-gzofstream::gzofstream()
-: std::ostream(0), sb()
+gzofstream::gzofstream ()
+: std::ostream(0), sb ()
 { this->init(&sb); }
 
 // Initialize stream buffer and open file
 gzofstream::gzofstream(const char* name,
                        std::ios_base::openmode mode)
-: std::ostream(0), sb()
+: std::ostream(0), sb ()
 {
   this->init(&sb);
   this->open(name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzofstream::gzofstream(int fd,
                        std::ios_base::openmode mode)
-: std::ostream(0), sb()
+: std::ostream(0), sb ()
 {
   this->init(&sb);
   this->attach(fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzofstream::open(const char* name,
                  std::ios_base::openmode mode)
 {
   if (!sb.open(name, mode | std::ios_base::out))
     this->setstate(std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
 gzofstream::attach(int fd,
                    std::ios_base::openmode mode)
 {
   if (!sb.attach(fd, mode | std::ios_base::out))
     this->setstate(std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Close file
 void
-gzofstream::close()
+gzofstream::close ()
 {
-  if (!sb.close())
+  if (!sb.close ())
     this->setstate(std::ios_base::failbit);
 }
 
 #endif // HAVE_ZLIB
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -48,21 +48,21 @@ along with Octave; see the file COPYING.
  *  seeking (allowed by zlib but slow/limited), putback and read/write access
  *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
  *  file streambuf.
 */
 class gzfilebuf : public std::streambuf
 {
 public:
   //  Default constructor.
-  gzfilebuf();
+  gzfilebuf ();
 
   //  Destructor.
   virtual
-  ~gzfilebuf();
+  ~gzfilebuf ();
 
   /**
    *  @brief  Set compression level and strategy on the fly.
    *  @param  comp_level  Compression level (see zlib.h for allowed values)
    *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
    *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
    *
    *  Unfortunately, these parameters cannot be modified separately, as the
@@ -74,17 +74,17 @@ public:
   setcompression(int comp_level,
                  int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() const { return (file != 0); }
+  is_open () const { return (file != 0); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
@@ -101,17 +101,17 @@ public:
   attach(int fd,
          std::ios_base::openmode mode);
 
   /**
    *  @brief  Close gzipped file.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  close();
+  close ();
 
 protected:
   /**
    *  @brief  Convert ios open mode int to mode string used by zlib.
    *  @return  True if valid mode flag combination.
   */
   bool
   open_mode(std::ios_base::openmode mode,
@@ -120,39 +120,39 @@ protected:
   /**
    *  @brief  Number of characters available in stream buffer.
    *  @return  Number of characters.
    *
    *  This indicates number of characters in get area of stream buffer.
    *  These characters can be read without accessing the gzipped file.
   */
   virtual std::streamsize
-  showmanyc();
+  showmanyc ();
 
   /**
    *  @brief  Fill get area from gzipped file.
    *  @return  First character in get area on success, EOF on error.
    *
    *  This actually reads characters from gzipped file to stream
    *  buffer. Always buffered.
   */
   virtual int_type
-  underflow();
+  underflow ();
 
   /**
    *  @brief  Write put area to gzipped file.
    *  @param  c  Extra character to add to buffer contents.
    *  @return  Non-EOF on success, EOF on error.
    *
    *  This actually writes characters in stream buffer to
    *  gzipped file. With unbuffered output this is done one
    *  character at a time.
   */
   virtual int_type
-  overflow(int_type c = traits_type::eof());
+  overflow(int_type c = traits_type::eof ());
 
   /**
    *  @brief  Installs external stream buffer.
    *  @param  p  Pointer to char buffer.
    *  @param  n  Size of external buffer.
    *  @return  @c this on success, NULL on failure.
    *
    *  Call setbuf(0,0) to enable unbuffered output.
@@ -163,17 +163,17 @@ protected:
 
   /**
    *  @brief  Flush stream buffer to file.
    *  @return  0 on success, -1 on error.
    *
    *  This calls underflow(EOF) to do the job.
   */
   virtual int
-  sync();
+  sync ();
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekoff(off_type off, std::ios_base::seekdir way,
@@ -185,17 +185,17 @@ protected:
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekpos(pos_type sp, std::ios_base::openmode mode =
           std::ios_base::in|std::ios_base::out);
 
   virtual int_type
-  pbackfail (int_type c = traits_type::eof());
+  pbackfail (int_type c = traits_type::eof ());
 
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
 //  virtual int_type pbackfail(int_type c = traits_type::eof());
 
 private:
@@ -210,27 +210,27 @@ private:
    *  @brief  Allocate internal buffer.
    *
    *  This function is safe to call multiple times. It will ensure
    *  that a proper internal buffer exists if it is required. If the
    *  buffer already exists or is external, the buffer pointers will be
    *  reset to their original state.
   */
   void
-  enable_buffer();
+  enable_buffer ();
 
   /**
    *  @brief  Destroy internal buffer.
    *
    *  This function is safe to call multiple times. It will ensure
    *  that the internal buffer is deallocated if it exists. In any
    *  case, it will also reset the buffer pointers.
   */
   void
-  disable_buffer();
+  disable_buffer ();
 
   /**
    *  Underlying file pointer.
   */
   gzFile file;
 
   /**
    *  Mode in which file was opened.
@@ -277,17 +277,17 @@ private:
  *
  *  This class implements ifstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzifstream : public std::istream
 {
 public:
   //  Default constructor
-  gzifstream();
+  gzifstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
   gzifstream(const char* name,
@@ -301,25 +301,25 @@ public:
   explicit
   gzifstream(int fd,
              std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
-  rdbuf() const
+  rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() { return sb.is_open(); }
+  is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
@@ -345,17 +345,17 @@ public:
          std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
-  close();
+  close ();
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
@@ -366,17 +366,17 @@ private:
  *
  *  This class implements ofstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzofstream : public std::ostream
 {
 public:
   //  Default constructor
-  gzofstream();
+  gzofstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
   gzofstream(const char* name,
@@ -390,25 +390,25 @@ public:
   explicit
   gzofstream(int fd,
              std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
-  rdbuf() const
+  rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() { return sb.is_open(); }
+  is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
@@ -434,17 +434,17 @@ public:
          std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
-  close();
+  close ();
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
@@ -481,17 +481,17 @@ template<typename T1, typename T2>
   };
 
 /*****************************************************************************/
 
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
 setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
-  (gzs.rdbuf())->setcompression(l, s);
+  (gzs.rdbuf ())->setcompression(l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
 template<typename T1, typename T2>
   inline
   gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
                               T1 v1,
diff --git a/test/classes/@Dork/Dork.m b/test/classes/@Dork/Dork.m
--- a/test/classes/@Dork/Dork.m
+++ b/test/classes/@Dork/Dork.m
@@ -1,16 +1,16 @@
 function [ s ] = Dork( gick, gack )
 
   if (nargin==1) && isa(gick,'Dork')
     s = gick;
   else
     s.gack = 0;
     if nargin == 0
-      s0 = Snork();
+      s0 = Snork ();
     elseif nargin==1
       s0 = Snork(gick);
     else
       s0 = Snork(gick);
       s.gack = gack;
     end
     s = class(s,'Dork',s0);
    end 
diff --git a/test/classes/@Dork/getStash.m b/test/classes/@Dork/getStash.m
--- a/test/classes/@Dork/getStash.m
+++ b/test/classes/@Dork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Dork/private/myStash.m b/test/classes/@Dork/private/myStash.m
--- a/test/classes/@Dork/private/myStash.m
+++ b/test/classes/@Dork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 2;
 
 end
diff --git a/test/classes/@Gork/Gork.m b/test/classes/@Gork/Gork.m
--- a/test/classes/@Gork/Gork.m
+++ b/test/classes/@Gork/Gork.m
@@ -1,15 +1,15 @@
 function [ s ] = Gork( g )
   if (nargin==1) && isa(g,'Gork')
     s = sprk;
     return;
   end
 
-  drk  = Dork();
-  prk  = Pork();
-  blrk = Blork();
+  drk  = Dork ();
+  prk  = Pork ();
+  blrk = Blork ();
   s.Cork = Cork(17);  % Aggregation.
   s.gark = -2;
   s.gyrk = -3;
   s = class(s,'Gork',drk,prk,blrk);
    
 end
diff --git a/test/classes/@Pork/Pork.m b/test/classes/@Pork/Pork.m
--- a/test/classes/@Pork/Pork.m
+++ b/test/classes/@Pork/Pork.m
@@ -1,16 +1,16 @@
 function [ s ] = Pork( geek, gurk )
 
   if (nargin==1) && isa(geek,'Pork')
     s = geek;
   else
     s.gurk = 0;
     if nargin == 0
-      s0 = Spork();
+      s0 = Spork ();
     elseif nargin==1
       s0 = Spork(geek);
     else
       s0 = Spork(geek);
       s.gurk = gurk;
     end
     s = class(s,'Pork',s0);
    end 
diff --git a/test/classes/@Pork/private/myStash.m b/test/classes/@Pork/private/myStash.m
--- a/test/classes/@Pork/private/myStash.m
+++ b/test/classes/@Pork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 4;
 
 end
diff --git a/test/classes/@Snork/getStash.m b/test/classes/@Snork/getStash.m
--- a/test/classes/@Snork/getStash.m
+++ b/test/classes/@Snork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Snork/private/myStash.m b/test/classes/@Snork/private/myStash.m
--- a/test/classes/@Snork/private/myStash.m
+++ b/test/classes/@Snork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 1;
         
 end
diff --git a/test/classes/@Spork/getStash.m b/test/classes/@Spork/getStash.m
--- a/test/classes/@Spork/getStash.m
+++ b/test/classes/@Spork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Spork/private/myStash.m b/test/classes/@Spork/private/myStash.m
--- a/test/classes/@Spork/private/myStash.m
+++ b/test/classes/@Spork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 3;
         
 end
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -21,17 +21,17 @@ clear all;
 global files_with_no_tests = {};
 global files_with_tests = {};
 global topsrcdir;
 global topbuilddir;
 
 currdir = canonicalize_file_name (".");
 
 if (nargin == 1)
-  xdir = argv(){1};
+  xdir = argv (){1};
 else
   xdir = ".";
 endif
 
 srcdir = canonicalize_file_name (xdir);
 topsrcdir = canonicalize_file_name (fullfile (xdir, ".."));
 topbuilddir = canonicalize_file_name (fullfile (currdir, ".."));
 
