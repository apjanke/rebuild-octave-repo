# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444100994 14400
#      Mon Oct 05 23:09:54 2015 -0400
# Node ID c4159506118610696fb0564161ce0d7874cc42ba
# Parent  56fee8f84fe70d212b818f631785d42e05789c6d
eliminate more simple uses of error_state

* betainc.cc, file-io.cc, ov-class.cc, ov-struct.cc:
Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -82,204 +82,164 @@ compatible dimensions.\n\
           if (x_arg.is_scalar_type ())
             {
               float x = x_arg.float_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   float a = a_arg.float_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          float b = b_arg.float_value ();
+                      float b = b_arg.float_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<float> b = b_arg.float_array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<float> b = b_arg.float_array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
               else
                 {
                   Array<float> a = a_arg.float_array_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          float b = b_arg.float_value ();
+                      float b = b_arg.float_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<float> b = b_arg.float_array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<float> b = b_arg.float_array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
             }
           else
             {
               Array<float> x = x_arg.float_array_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   float a = a_arg.float_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          float b = b_arg.float_value ();
+                      float b = b_arg.float_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<float> b = b_arg.float_array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<float> b = b_arg.float_array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
               else
                 {
                   Array<float> a = a_arg.float_array_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          float b = b_arg.float_value ();
+                      float b = b_arg.float_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<float> b = b_arg.float_array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<float> b = b_arg.float_array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
             }
         }
       else
         {
           if (x_arg.is_scalar_type ())
             {
               double x = x_arg.double_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   double a = a_arg.double_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          double b = b_arg.double_value ();
+                      double b = b_arg.double_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<double> b = b_arg.array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
               else
                 {
                   Array<double> a = a_arg.array_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          double b = b_arg.double_value ();
+                      double b = b_arg.double_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<double> b = b_arg.array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
             }
           else
             {
               Array<double> x = x_arg.array_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   double a = a_arg.double_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          double b = b_arg.double_value ();
+                      double b = b_arg.double_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<double> b = b_arg.array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
               else
                 {
                   Array<double> a = a_arg.array_value ();
 
-                  if (! error_state)
+                  if (b_arg.is_scalar_type ())
                     {
-                      if (b_arg.is_scalar_type ())
-                        {
-                          double b = b_arg.double_value ();
+                      double b = b_arg.double_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
-                      else
-                        {
-                          Array<double> b = b_arg.array_value ();
+                      retval = betainc (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
 
-                          if (! error_state)
-                            retval = betainc (x, a, b);
-                        }
+                      retval = betainc (x, a, b);
                     }
                 }
             }
         }
     }
   else
     print_usage ();
 
@@ -355,103 +315,83 @@ The inverse is the value @var{x} such th
       if (x_arg.is_scalar_type ())
         {
           double x = x_arg.double_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              if (! error_state)
+              if (b_arg.is_scalar_type ())
                 {
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  double b = b_arg.double_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
+                  retval = betaincinv (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
+                  retval = betaincinv (x, a, b);
                 }
             }
           else
             {
               Array<double> a = a_arg.array_value ();
 
-              if (! error_state)
+              if (b_arg.is_scalar_type ())
                 {
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  double b = b_arg.double_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
+                  retval = betaincinv (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
+                  retval = betaincinv (x, a, b);
                 }
             }
         }
       else
         {
           Array<double> x = x_arg.array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              if (! error_state)
+              if (b_arg.is_scalar_type ())
                 {
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  double b = b_arg.double_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
+                  retval = betaincinv (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
+                  retval = betaincinv (x, a, b);
                 }
             }
           else
             {
               Array<double> a = a_arg.array_value ();
 
-              if (! error_state)
+              if (b_arg.is_scalar_type ())
                 {
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  double b = b_arg.double_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
+                  retval = betaincinv (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
 
-                      if (! error_state)
-                        retval = betaincinv (x, a, b);
-                    }
+                  retval = betaincinv (x, a, b);
                 }
             }
         }
 
       // FIXME: It would be better to have an algorithm for betaincinv which
       // accepted float inputs and returned float outputs.  As it is, we do
       // extra work to calculate betaincinv to double precision and then throw
       // that precision away.
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -177,66 +177,60 @@ normalize_fopen_mode (std::string& mode,
 #if defined (HAVE_ZLIB)
           use_zlib = true;
           mode.erase (pos, 1);
 #else
           error ("this version of Octave does not support gzipped files");
 #endif
         }
 
-      if (! error_state)
-        {
-          // Use binary mode if 't' is not specified, but don't add
-          // 'b' if it is already present.
+      // Use binary mode if 't' is not specified, but don't add
+      // 'b' if it is already present.
 
-          size_t bpos = mode.find ('b');
-          size_t tpos = mode.find ('t');
+      size_t bpos = mode.find ('b');
+      size_t tpos = mode.find ('t');
 
-          if (bpos == std::string::npos && tpos == std::string::npos)
-            mode += 'b';
-        }
+      if (bpos == std::string::npos && tpos == std::string::npos)
+        mode += 'b';
     }
 }
 
 static std::ios::openmode
 fopen_mode_to_ios_mode (const std::string& mode)
 {
   std::ios::openmode retval = std::ios::in;
 
-  if (! error_state)
-    {
-      if (mode == "rt")
-        retval = std::ios::in;
-      else if (mode == "wt")
-        retval = std::ios::out | std::ios::trunc;
-      else if (mode == "at")
-        retval = std::ios::out | std::ios::app;
-      else if (mode == "r+t" || mode == "rt+")
-        retval = std::ios::in | std::ios::out;
-      else if (mode == "w+t" || mode == "wt+")
-        retval = std::ios::in | std::ios::out | std::ios::trunc;
-      else if (mode == "a+t" || mode == "at+")
-        retval = std::ios::in | std::ios::out | std::ios::app;
-      else if (mode == "rb" || mode == "r")
-        retval = std::ios::in | std::ios::binary;
-      else if (mode == "wb" || mode == "w")
-        retval = std::ios::out | std::ios::trunc | std::ios::binary;
-      else if (mode == "ab" || mode == "a")
-        retval = std::ios::out | std::ios::app | std::ios::binary;
-      else if (mode == "r+b" || mode == "rb+" || mode == "r+")
-        retval = std::ios::in | std::ios::out | std::ios::binary;
-      else if (mode == "w+b" || mode == "wb+" || mode == "w+")
-        retval = (std::ios::in | std::ios::out | std::ios::trunc
-                  | std::ios::binary);
-      else if (mode == "a+b" || mode == "ab+" || mode == "a+")
-        retval = (std::ios::in | std::ios::out | std::ios::app
-                  | std::ios::binary);
-      else
-        error ("invalid mode specified");
-    }
+  if (mode == "rt")
+    retval = std::ios::in;
+  else if (mode == "wt")
+    retval = std::ios::out | std::ios::trunc;
+  else if (mode == "at")
+    retval = std::ios::out | std::ios::app;
+  else if (mode == "r+t" || mode == "rt+")
+    retval = std::ios::in | std::ios::out;
+  else if (mode == "w+t" || mode == "wt+")
+    retval = std::ios::in | std::ios::out | std::ios::trunc;
+  else if (mode == "a+t" || mode == "at+")
+    retval = std::ios::in | std::ios::out | std::ios::app;
+  else if (mode == "rb" || mode == "r")
+    retval = std::ios::in | std::ios::binary;
+  else if (mode == "wb" || mode == "w")
+    retval = std::ios::out | std::ios::trunc | std::ios::binary;
+  else if (mode == "ab" || mode == "a")
+    retval = std::ios::out | std::ios::app | std::ios::binary;
+  else if (mode == "r+b" || mode == "rb+" || mode == "r+")
+    retval = std::ios::in | std::ios::out | std::ios::binary;
+  else if (mode == "w+b" || mode == "wb+" || mode == "w+")
+    retval = (std::ios::in | std::ios::out | std::ios::trunc
+              | std::ios::binary);
+  else if (mode == "a+b" || mode == "ab+" || mode == "a+")
+    retval = (std::ios::in | std::ios::out | std::ios::app
+              | std::ios::binary);
+  else
+    error ("invalid mode specified");
 
   return retval;
 }
 
 DEFUN (fclose, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fclose (@var{fid})\n\
 @deftypefnx {Built-in Function} {} fclose (\"all\")\n\
@@ -278,18 +272,17 @@ Clear the stream state for the file spec
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       int fid = octave_stream_list::get_file_number (args(0));
 
       octave_stream os = octave_stream_list::lookup (fid, "fclear");
 
-      if (! error_state)
-        os.clearerr ();
+      os.clearerr ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
@@ -322,18 +315,17 @@ always a good idea to flush the standard
           flush_octave_stdout ();
 
           retval = 0;
         }
       else
         {
           octave_stream os = octave_stream_list::lookup (fid, "fflush");
 
-          if (! error_state)
-            retval = os.flush ();
+          retval = os.flush ();
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -363,29 +355,26 @@ To read a line and return the terminatin
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (! error_state)
-        {
-          octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
+      octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-          bool err = false;
+      bool err = false;
 
-          std::string tmp = os.getl (len_arg, err, who);
+      std::string tmp = os.getl (len_arg, err, who);
 
-          if (! (error_state || err))
-            {
-              retval(1) = tmp.length ();
-              retval(0) = tmp;
-            }
+      if (! err)
+        {
+          retval(1) = tmp.length ();
+          retval(0) = tmp;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -415,29 +404,26 @@ To read a line and discard the terminati
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (! error_state)
-        {
-          octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
+      octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-          bool err = false;
+      bool err = false;
 
-          std::string tmp = os.gets (len_arg, err, who);
+      std::string tmp = os.gets (len_arg, err, who);
 
-          if (! (error_state || err))
-            {
-              retval(1) = tmp.length ();
-              retval(0) = tmp;
-            }
+      if (! err)
+        {
+          retval(1) = tmp.length ();
+          retval(0) = tmp;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -465,27 +451,24 @@ Returns the number of lines skipped (end
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (! error_state)
-        {
-          octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
+      octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
-          bool err = false;
+      bool err = false;
 
-          off_t tmp = os.skipl (count_arg, err, who);
+      off_t tmp = os.skipl (count_arg, err, who);
 
-          if (! (error_state || err))
-            retval = tmp;
-        }
+      if (! err)
+        retval = tmp;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 
@@ -498,61 +481,55 @@ do_stream_open (const std::string& name,
   fid = -1;
 
   std::string mode = mode_arg;
   bool use_zlib = false;
   normalize_fopen_mode (mode, use_zlib);
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
 
-  if (! error_state)
-    {
-      oct_mach_info::float_format flt_fmt =
-        oct_mach_info::string_to_float_format (arch);
+  oct_mach_info::float_format flt_fmt =
+    oct_mach_info::string_to_float_format (arch);
 
-      if (! error_state)
-        {
-          std::string fname = file_ops::tilde_expand (name);
+  std::string fname = file_ops::tilde_expand (name);
 
-          file_stat fs (fname);
+  file_stat fs (fname);
 
-          if (! (md & std::ios::out))
-            fname = find_data_file_in_load_path ("fopen", fname);
+  if (! (md & std::ios::out))
+    fname = find_data_file_in_load_path ("fopen", fname);
 
-          if (! fs.is_dir ())
-            {
+  if (! fs.is_dir ())
+    {
 #if defined (HAVE_ZLIB)
-              if (use_zlib)
-                {
-                  FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
+      if (use_zlib)
+        {
+          FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
 
-                  int fd = fileno (fptr);
+          int fd = fileno (fptr);
 
-                  gzFile gzf = ::gzdopen (fd, mode.c_str ());
+          gzFile gzf = ::gzdopen (fd, mode.c_str ());
 
-                  if (fptr)
-                    retval = octave_zstdiostream::create (fname, gzf, fd,
-                                                          md, flt_fmt);
-                  else
-                    retval.error (gnulib::strerror (errno));
-                }
-              else
+          if (fptr)
+            retval = octave_zstdiostream::create (fname, gzf, fd,
+                                                  md, flt_fmt);
+          else
+            retval.error (gnulib::strerror (errno));
+        }
+      else
 #endif
-                {
-                  FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
-
-                  retval = octave_stdiostream::create (fname, fptr, md,
-                                                       flt_fmt);
+        {
+          FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
 
-                  if (! fptr)
-                    retval.error (gnulib::strerror (errno));
-                }
+          retval = octave_stdiostream::create (fname, fptr, md,
+                                               flt_fmt);
 
-            }
+          if (! fptr)
+            retval.error (gnulib::strerror (errno));
         }
+
     }
 
   return retval;
 }
 
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
@@ -705,22 +682,19 @@ When opening a new file that does not ye
 
           if (nargout < 2 && args(0).string_value () == "all")
             return octave_stream_list::open_file_numbers ();
         }
       else
         {
           string_vector tmp = octave_stream_list::get_info (args(0));
 
-          if (! error_state)
-            {
-              retval(2) = tmp(2);
-              retval(1) = tmp(1);
-              retval(0) = tmp(0);
-            }
+          retval(2) = tmp(2);
+          retval(1) = tmp(1);
+          retval(0) = tmp(0);
 
           return retval;
         }
     }
 
   if (nargin > 0 && nargin < 4)
     {
       octave_value mode = (nargin == 2 || nargin == 3)
@@ -728,17 +702,17 @@ When opening a new file that does not ye
 
       octave_value arch = (nargin == 3)
                           ? args(2) : octave_value ("native");
 
       int fid = -1;
 
       octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
-      if (os && ! error_state)
+      if (os)
         {
           retval(1) = "";
           retval(0) = octave_stream_list::insert (os);
         }
       else
         {
           int error_number = 0;
 
@@ -804,18 +778,17 @@ is equivalent to @code{fseek (@var{fid},
   int result = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
-      if (! error_state)
-        result = os.rewind ();
+      result = os.rewind ();
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -843,23 +816,20 @@ be positive, negative, or zero but not a
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
-      if (! error_state)
-        {
-          octave_value origin_arg = (nargin == 3)
-                                    ? args(2) : octave_value (-1.0);
+      octave_value origin_arg = (nargin == 3)
+        ? args(2) : octave_value (-1.0);
 
-          retval = os.seek (args(1), origin_arg);
-        }
+      retval = os.seek (args(1), origin_arg);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
@@ -873,18 +843,17 @@ beginning of the file specified by file 
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
-      if (! error_state)
-        retval = os.tell ();
+      retval = os.tell ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
@@ -924,35 +893,32 @@ expanded even when the template string i
           os = octave_stream_list::lookup (1, who);
         }
       else
         {
           fmt_n = 1;
           os = octave_stream_list::lookup (args(0), who);
         }
 
-      if (! error_state)
+      if (args(fmt_n).is_string ())
         {
-          if (args(fmt_n).is_string ())
+          octave_value_list tmp_args;
+
+          if (nargin > 1 + fmt_n)
             {
-              octave_value_list tmp_args;
-
-              if (nargin > 1 + fmt_n)
-                {
-                  tmp_args.resize (nargin-fmt_n-1, octave_value ());
+              tmp_args.resize (nargin-fmt_n-1, octave_value ());
 
-                  for (int i = fmt_n + 1; i < nargin; i++)
-                    tmp_args(i-fmt_n-1) = args(i);
-                }
+              for (int i = fmt_n + 1; i < nargin; i++)
+                tmp_args(i-fmt_n-1) = args(i);
+            }
 
-              result = os.printf (args(fmt_n), tmp_args, who);
-            }
-          else
-            error ("%s: format TEMPLATE must be a string", who.c_str ());
+          result = os.printf (args(fmt_n), tmp_args, who);
         }
+      else
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -1031,18 +997,17 @@ Return a non-negative number on success 
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (! error_state)
-        retval = os.puts (args(1), who);
+      retval = os.puts (args(1), who);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (puts, args, ,
@@ -1195,60 +1160,48 @@ complete description of the syntax of th
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (! error_state)
-        {
-          if (args(1).is_string ())
-            retval = os.oscanf (args(1), who);
-          else
-            error ("%s: format TEMPLATE must be a string", who.c_str ());
-        }
+      if (args(1).is_string ())
+        retval = os.oscanf (args(1), who);
+      else
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     {
       retval(2) = "unknown error";
       retval(1) = 0.0;
       retval(0) = Matrix ();
 
       if (nargin == 2 || nargin == 3)
         {
           octave_stream os = octave_stream_list::lookup (args(0), who);
 
-          if (! error_state)
+          if (args(1).is_string ())
             {
-              if (args(1).is_string ())
-                {
-                  octave_idx_type count = 0;
+              octave_idx_type count = 0;
 
-                  Array<double> size = (nargin == 3)
-                                       ? args(2).vector_value ()
-                                       : Array<double> (dim_vector (1, 1),
-                                                        lo_ieee_inf_value ());
+              Array<double> size = (nargin == 3)
+                ? args(2).vector_value ()
+                : Array<double> (dim_vector (1, 1),
+                                 lo_ieee_inf_value ());
 
-                  if (! error_state)
-                    {
-                      octave_value tmp = os.scanf (args(1), size, count, who);
+              octave_value tmp = os.scanf (args(1), size, count, who);
 
-                      if (! error_state)
-                        {
-                          retval(2) = os.error ();
-                          retval(1) = count;
-                          retval(0) = tmp;
-                        }
-                    }
-                }
-              else
-                error ("%s: format must be a string", who.c_str ());
+              retval(2) = os.error ();
+              retval(1) = count;
+              retval(0) = tmp;
             }
+          else
+            error ("%s: format must be a string", who.c_str ());
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
@@ -1315,55 +1268,48 @@ character to be read is returned in @var
         {
           retval(3) = -1.0;
           retval(2) = "unknown error";
           retval(1) = 0.0;
           retval(0) = Matrix ();
 
           std::string data = get_sscanf_data (args(0));
 
-          if (! error_state)
+          octave_stream os = octave_istrstream::create (data);
+
+          if (os.is_valid ())
             {
-              octave_stream os = octave_istrstream::create (data);
-
-              if (os.is_valid ())
+              if (args(1).is_string ())
                 {
-                  if (args(1).is_string ())
-                    {
-                      octave_idx_type count = 0;
-
-                      Array<double> size = (nargin == 3)
-                                           ? args(2).vector_value ()
-                                           : Array<double> (dim_vector (1, 1),
-                                                            lo_ieee_inf_value ());
-
-                      octave_value tmp = os.scanf (args(1), size, count, who);
+                  octave_idx_type count = 0;
 
-                      if (! error_state)
-                        {
-                          // FIXME: is this the right thing to do?
-                          // Extract error message first, because getting
-                          // position will clear it.
-                          std::string errmsg = os.error ();
+                  Array<double> size = (nargin == 3)
+                    ? args(2).vector_value ()
+                    : Array<double> (dim_vector (1, 1),
+                                     lo_ieee_inf_value ());
+
+                  octave_value tmp = os.scanf (args(1), size, count, who);
 
-                          retval(3)
-                            = (os.eof () ? data.length () : os.tell ()) + 1;
-                          retval(2) = errmsg;
-                          retval(1) = count;
-                          retval(0) = tmp;
-                        }
-                    }
-                  else
-                    error ("%s: format TEMPLATE must be a string",
-                           who.c_str ());
+                  // FIXME: is this the right thing to do?
+                  // Extract error message first, because getting
+                  // position will clear it.
+                  std::string errmsg = os.error ();
+
+                  retval(3) = (os.eof () ? data.length () : os.tell ()) + 1;
+                  retval(2) = errmsg;
+                  retval(1) = count;
+                  retval(0) = tmp;
                 }
               else
-                error ("%s: unable to create temporary input buffer",
-                       who.c_str  ());
+                error ("%s: format TEMPLATE must be a string",
+                       who.c_str ());
             }
+          else
+            error ("%s: unable to create temporary input buffer",
+                   who.c_str  ());
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
@@ -1420,19 +1366,18 @@ do_fread (octave_stream& os, const octav
                 {
                   if (arch_arg.is_string ())
                     {
                       std::string arch = arch_arg.string_value ();
 
                       oct_mach_info::float_format flt_fmt
                         = oct_mach_info::string_to_float_format (arch);
 
-                      if (! error_state)
-                        retval = os.read (size, block_size, input_type,
-                                          output_type, skip, flt_fmt, count);
+                      retval = os.read (size, block_size, input_type,
+                                        output_type, skip, flt_fmt, count);
                     }
                   else
                     error ("fread: ARCH architecture type must be a string");
                 }
               else
                 error ("fread: SKIP must be an integer");
             }
           else
@@ -1624,49 +1569,46 @@ The optional return value @var{count} co
 
   if (nargin > 0 && nargin < 6)
     {
       retval(1) = -1.0;
       retval(0) = Matrix ();
 
       octave_stream os = octave_stream_list::lookup (args(0), "fread");
 
-      if (! error_state)
-        {
-          octave_value size = lo_ieee_inf_value ();
-          octave_value prec = "uchar";
-          octave_value skip = 0;
-          octave_value arch = "unknown";
+      octave_value size = lo_ieee_inf_value ();
+      octave_value prec = "uchar";
+      octave_value skip = 0;
+      octave_value arch = "unknown";
 
-          int idx = 1;
+      int idx = 1;
 
-          if (nargin > idx && ! args(idx).is_string ())
-            size = args(idx++);
+      if (nargin > idx && ! args(idx).is_string ())
+        size = args(idx++);
 
-          if (nargin > idx)
-            prec = args(idx++);
+      if (nargin > idx)
+        prec = args(idx++);
 
-          if (nargin > idx)
-            skip = args(idx++);
+      if (nargin > idx)
+        skip = args(idx++);
 
-          if (nargin > idx)
-            arch = args(idx++);
-          else if (skip.is_string ())
-            {
-              arch = skip;
-              skip = 0;
-            }
+      if (nargin > idx)
+        arch = args(idx++);
+      else if (skip.is_string ())
+        {
+          arch = skip;
+          skip = 0;
+        }
 
-          octave_idx_type count = -1;
-
-          octave_value tmp = do_fread (os, size, prec, skip, arch, count);
+      octave_idx_type count = -1;
 
-          retval(1) = count;
-          retval(0) = tmp;
-        }
+      octave_value tmp = do_fread (os, size, prec, skip, arch, count);
+
+      retval(1) = count;
+      retval(0) = tmp;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static int
@@ -1693,19 +1635,18 @@ do_fwrite (octave_stream& os, const octa
             {
               if (arch_arg.is_string ())
                 {
                   std::string arch = arch_arg.string_value ();
 
                   oct_mach_info::float_format flt_fmt
                     = oct_mach_info::string_to_float_format (arch);
 
-                  if (! error_state)
-                    retval = os.write (data, block_size, output_type,
-                                       skip, flt_fmt);
+                  retval = os.write (data, block_size, output_type,
+                                     skip, flt_fmt);
                 }
               else
                 error ("fwrite: ARCH architecture type must be a string");
             }
           else
             error ("fwrite: SKIP must be an integer");
         }
       else
@@ -1742,44 +1683,41 @@ are too large to fit in the specified pr
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 6)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
 
-      if (! error_state)
-        {
-          octave_value prec = "uchar";
-          octave_value skip = 0;
-          octave_value arch = "unknown";
+      octave_value prec = "uchar";
+      octave_value skip = 0;
+      octave_value arch = "unknown";
 
-          int idx = 1;
+      int idx = 1;
 
-          octave_value data = args(idx++);
+      octave_value data = args(idx++);
 
-          if (nargin > idx)
-            prec = args(idx++);
+      if (nargin > idx)
+        prec = args(idx++);
 
-          if (nargin > idx)
-            skip = args(idx++);
+      if (nargin > idx)
+        skip = args(idx++);
 
-          if (nargin > idx)
-            arch = args(idx++);
-          else if (skip.is_string ())
-            {
-              arch = skip;
-              skip = 0;
-            }
+      if (nargin > idx)
+        arch = args(idx++);
+      else if (skip.is_string ())
+        {
+          arch = skip;
+          skip = 0;
+        }
 
-          double status = do_fwrite (os, data, prec, skip, arch);
+      double status = do_fwrite (os, data, prec, skip, arch);
 
-          retval = status;
-        }
+      retval = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("feof", Ffeof, args, ,
@@ -1797,18 +1735,17 @@ end-of-file condition.\n\
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
-      if (! error_state)
-        retval = os.eof () ? 1.0 : 0.0;
+      retval = os.eof () ? 1.0 : 0.0;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ferror", Fferror, args, ,
@@ -1835,37 +1772,31 @@ whether the next operation will result i
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "ferror");
 
-      if (! error_state)
-        {
-          bool clear = false;
+      bool clear = false;
 
-          if (nargin == 2)
-            {
-              std::string opt = args(1).string_value ();
+      if (nargin == 2)
+        {
+          std::string opt = args(1).string_value ();
 
-              if (! error_state)
-                clear = (opt == "clear");
-              else
-                return retval;
-            }
+          clear = (opt == "clear");
+        }
+
+      int error_number = 0;
 
-          int error_number = 0;
-
-          std::string error_message = os.error (clear, error_number);
+      std::string error_message = os.error (clear, error_number);
 
-          retval(1) = error_number;
-          retval(0) = error_message;
-        }
+      retval(1) = error_number;
+      retval(0) = error_message;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen", Fpopen, args, ,
@@ -2271,18 +2202,17 @@ for the new object are @code{@var{mode} 
             {
               status = -1;
               error ("umask: MASK must be a positive integer value");
             }
           else
             {
               int oct_mask = convert (mask, 8, 10);
 
-              if (! error_state)
-                status = convert (octave_umask (oct_mask), 10, 8);
+              status = convert (octave_umask (oct_mask), 10, 8);
             }
         }
       else
         {
           status = -1;
           error ("umask: MASK must be an integer");
         }
     }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -198,18 +198,17 @@ octave_class::octave_class (const octave
                     }
                   else
                     error ("class: parent class dimension mismatch");
                 }
             }
         }
     }
 
-  if (! error_state)
-    symbol_table::add_to_parent_map (id, parent_list);
+  symbol_table::add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
 {
   if (count == obsolete_copies)
     {
       // All remaining copies are obsolete. We don't actually need to clone.
@@ -397,28 +396,25 @@ octave_class::subsref (const std::string
           {
             if (type.length () > 1 && type[1] == '.')
               {
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
-                if (! error_state)
-                  {
-                    Cell t = tmp.index (idx.front ());
+                Cell t = tmp.index (idx.front ());
+
+                retval(0) = (t.numel () == 1) ? t(0)
+                  : octave_value (t, true);
 
-                    retval(0) = (t.numel () == 1) ? t(0)
-                                                   : octave_value (t, true);
+                // We handled two index elements, so tell
+                // next_subsref to skip both of them.
 
-                    // We handled two index elements, so tell
-                    // next_subsref to skip both of them.
-
-                    skip++;
-                  }
+                skip++;
               }
             else
               retval(0) = octave_value (map.index (idx.front ()),
                                         c_name, parent_list);
           }
           break;
 
         case '.':
@@ -452,19 +448,16 @@ octave_class::subsref (const std::string
       octave_value meth = symbol_table::find_method ("subsref", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsref");
 
-          if (error_state)
-            return octave_value_list ();
-
           count++;
           args(0) = octave_value (this);
 
           // FIXME: for Matlab compatibility, let us attempt to set up a proper
           // value for nargout at least in the simple case where the
           // cs-list-type expression - i.e., {} or ().x, is the leading one.
           // Note that Octave does not actually need this, since it will
           // be able to properly react to varargout a posteriori.
@@ -564,20 +557,16 @@ octave_class::subsasgn_common (const oct
               args.resize (2 + lrhs.length ());
               for (octave_idx_type i = 0; i < lrhs.length (); i++)
                 args(2+i) = lrhs(i);
             }
           else
             args(2) = rhs;
 
           args(1) = make_idx_args (type, idx, "subsasgn");
-
-          if (error_state)
-            return octave_value_list ();
-
           args(0) = obj;
 
           // Now comes the magic. Count copies with me:
           // 1. myself (obsolete)
           // 2. the copy inside args (obsolete)
           // 3. the copy in method's symbol table (working)
           // ... possibly more (not obsolete).
           //
@@ -623,16 +612,17 @@ octave_class::subsasgn_common (const oct
 
   octave_base_value *obvp = unique_parent_class (method_class);
   if (obvp != this)
     {
 
       if (obvp)
         {
           obvp->subsasgn (type, idx, rhs);
+
           if (! error_state)
             {
               count++;
               retval = octave_value (this);
             }
           else
             gripe_failed_assignment ();
         }
@@ -677,30 +667,27 @@ octave_class::subsasgn_common (const oct
                       {
                         Cell map_val = map.contents (key);
 
                         Cell map_elt = map_val.index (idx.front (), true);
 
                         u = numeric_conv (map_elt, type.substr (2));
                       }
 
-                    if (! error_state)
-                      {
-                        std::list<octave_value_list> next_idx (idx);
+                    std::list<octave_value_list> next_idx (idx);
 
-                        // We handled two index elements, so subsasgn to
-                        // needs to skip both of them.
+                    // We handled two index elements, so subsasgn to
+                    // needs to skip both of them.
 
-                        next_idx.erase (next_idx.begin ());
-                        next_idx.erase (next_idx.begin ());
+                    next_idx.erase (next_idx.begin ());
+                    next_idx.erase (next_idx.begin ());
 
-                        u.make_unique ();
+                    u.make_unique ();
 
-                        t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
-                      }
+                    t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
                   }
                 else
                   gripe_invalid_index_for_assignment ();
               }
             else
               gripe_invalid_index_for_assignment ();
           }
           break;
@@ -723,37 +710,33 @@ octave_class::subsasgn_common (const oct
             octave_map::iterator pkey = map.seek (key);
             if (pkey != map.end ())
               {
                 map.contents (pkey).make_unique ();
                 tmpc = map.contents (pkey);
               }
 
             // FIXME: better code reuse?
-            if (! error_state)
+            if (tmpc.numel () == 1)
               {
-                if (tmpc.numel () == 1)
-                  {
-                    octave_value& tmp = tmpc(0);
+                octave_value& tmp = tmpc(0);
 
-                    if (! tmp.is_defined () || tmp.is_zero_by_zero ())
-                      {
-                        tmp = octave_value::empty_conv (next_type, rhs);
-                        tmp.make_unique (); // probably a no-op.
-                      }
-                    else
-                      // optimization: ignore copy still stored inside our map.
-                      tmp.make_unique (1);
-
-                    if (! error_state)
-                      t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
+                if (! tmp.is_defined () || tmp.is_zero_by_zero ())
+                  {
+                    tmp = octave_value::empty_conv (next_type, rhs);
+                    tmp.make_unique (); // probably a no-op.
                   }
                 else
-                  gripe_indexed_cs_list ();
+                  // optimization: ignore copy still stored inside our map.
+                  tmp.make_unique (1);
+
+                t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
               }
+            else
+              gripe_indexed_cs_list ();
           }
           break;
 
         case '{':
           gripe_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
@@ -894,28 +877,25 @@ octave_class::index_vector (bool require
 
   if (meth.is_defined ())
     {
       octave_value_list args;
       args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
-      if (!error_state && tmp.length () >= 1)
-        {
-          if (tmp(0).is_object ())
-            error ("subsindex function must return a valid index vector");
-          else
-            // Index vector returned by subsindex is zero based
-            // (why this inconsistency Mathworks?), and so we must
-            // add one to the value returned as the index_vector method
-            // expects it to be one based.
-            retval = do_binary_op (octave_value::op_add, tmp (0),
-                                   octave_value (1.0)).index_vector (require_integers);
-        }
+      if (tmp(0).is_object ())
+        error ("subsindex function must return a valid index vector");
+      else
+        // Index vector returned by subsindex is zero based
+        // (why this inconsistency Mathworks?), and so we must
+        // add one to the value returned as the index_vector method
+        // expects it to be one based.
+        retval = do_binary_op (octave_value::op_add, tmp (0),
+                               octave_value (1.0)).index_vector (require_integers);
     }
   else
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   return retval;
 }
 
@@ -1053,17 +1033,17 @@ octave_class::all_strings (bool pad) con
 
   if (meth.is_defined ())
     {
       octave_value_list args;
       args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
-      if (!error_state && tmp.length () >= 1)
+      if (tmp.length () >= 1)
         {
           if (tmp(0).is_string ())
             retval = tmp(0).all_strings (pad);
           else
             error ("cname/char method did not return a string");
         }
     }
   else
@@ -1265,20 +1245,18 @@ bool
 octave_class::save_ascii (std::ostream& os)
 {
   os << "# classname: " << class_name () << "\n";
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
-      if (! error_state)
-        m = tmp(0).map_value ();
-      else
-        return false;
+
+      m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   os << "# length: " << m.nfields () << "\n";
 
   octave_map::iterator i = m.begin ();
   while (i != m.end ())
@@ -1345,20 +1323,17 @@ octave_class::load_ascii (std::istream& 
                     warning ("load: unable to reconstruct object inheritance");
 
                   if (load_path::find_method (classname, "loadobj")
                       != std::string ())
                     {
                       octave_value in = new octave_class (*this);
                       octave_value_list tmp = feval ("loadobj", in, 1);
 
-                      if (! error_state)
-                        map = tmp(0).map_value ();
-                      else
-                        success = false;
+                      map = tmp(0).map_value ();
                     }
                 }
               else
                 {
                   error ("load: failed to load class");
                   success = false;
                 }
             }
@@ -1393,20 +1368,18 @@ octave_class::save_binary (std::ostream&
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
-      if (! error_state)
-        m = tmp(0).map_value ();
-      else
-        return false;
+
+      m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   int32_t len = m.nfields ();
   os.write (reinterpret_cast<char *> (&len), 4);
 
   octave_map::iterator i = m.begin ();
@@ -1489,20 +1462,17 @@ octave_class::load_binary (std::istream&
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
 
           if (load_path::find_method (c_name, "loadobj") != std::string ())
             {
               octave_value in = new octave_class (*this);
               octave_value_list tmp = feval ("loadobj", in, 1);
 
-              if (! error_state)
-                map = tmp(0).map_value ();
-              else
-                success = false;
+              map = tmp(0).map_value ();
             }
         }
       else
         {
           warning ("load: failed to load class");
           success = false;
         }
     }
@@ -1564,20 +1534,18 @@ octave_class::save_hdf5 (octave_hdf5_id 
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
-      if (! error_state)
-        m = tmp(0).map_value ();
-      else
-        goto error_cleanup;
+
+      m = tmp(0).map_value ();
     }
   else
     m = map_value ();
 
   // recursively add each element of the class to this group
   i = m.begin ();
   while (i != m.end ())
     {
@@ -1735,23 +1703,18 @@ octave_class::load_hdf5 (octave_hdf5_id 
       if (!reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
       if (load_path::find_method (c_name, "loadobj") != std::string ())
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = feval ("loadobj", in, 1);
 
-          if (! error_state)
-            {
-              map = tmp(0).map_value ();
-              retval = true;
-            }
-          else
-            retval = false;
+          map = tmp(0).map_value ();
+          retval = true;
         }
     }
 
 error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
@@ -1912,28 +1875,25 @@ is derived.\n\
                       else
                         {
                           octave_value_list parents = args.slice (2, nargin-2);
 
                           retval
                             = octave_value (new octave_class (m, id, parents));
                         }
 
-                      if (! error_state)
-                        {
-                          octave_class::exemplar_const_iterator it
-                            = octave_class::exemplar_map.find (id);
+                      octave_class::exemplar_const_iterator it
+                        = octave_class::exemplar_map.find (id);
 
-                          if (it == octave_class::exemplar_map.end ())
-                            octave_class::exemplar_map[id]
-                              = octave_class::exemplar_info (retval);
-                          else if (! it->second.compare (retval))
-                            error ("class: object of class '%s' does not match previously constructed objects",
-                                   id.c_str ());
-                        }
+                      if (it == octave_class::exemplar_map.end ())
+                        octave_class::exemplar_map[id]
+                          = octave_class::exemplar_info (retval);
+                      else if (! it->second.compare (retval))
+                        error ("class: object of class '%s' does not match previously constructed objects",
+                               id.c_str ());
                     }
                   else
                     error ("class: expecting structure S as first argument");
                 }
               else
                 error ("class: '%s' is invalid as a class name in this context",
                        id.c_str ());
             }
@@ -2132,28 +2092,22 @@ is a method of this class.\n\
 
       if (arg.is_object ())
         class_name = arg.class_name ();
       else if (arg.is_string ())
         class_name = arg.string_value ();
       else
         error ("ismethod: expecting object or class name as first argument");
 
-      if (! error_state)
-        {
-          std::string method = args(1).string_value ();
+      std::string method = args(1).string_value ();
 
-          if (! error_state)
-            {
-              if (load_path::find_method (class_name, method) != std::string ())
-                retval = true;
-              else
-                retval = false;
-            }
-        }
+      if (load_path::find_method (class_name, method) != std::string ())
+        retval = true;
+      else
+        retval = false;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__methods__, args, ,
@@ -2173,21 +2127,18 @@ Implements @code{methods} for Octave cla
 
   std::string class_name;
 
   if (arg.is_object ())
     class_name = arg.class_name ();
   else if (arg.is_string ())
     class_name = arg.string_value ();
 
-  if (! error_state)
-    {
-      string_vector sv = load_path::methods (class_name);
-      retval = Cell (sv);
-    }
+  string_vector sv = load_path::methods (class_name);
+  retval = Cell (sv);
 
   return retval;
 }
 
 static bool
 is_built_in_class (const std::string& cn)
 {
   static std::set<std::string> built_in_class_names;
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -148,27 +148,24 @@ octave_struct::subsref (const std::strin
       {
         if (type.length () > 1 && type[1] == '.')
           {
             std::list<octave_value_list>::const_iterator p = idx.begin ();
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx);
 
-            if (! error_state)
-              {
-                const Cell t = tmp.index (idx.front ());
-
-                retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
-
-                // We handled two index elements, so tell
-                // next_subsref to skip both of them.
-
-                skip++;
-              }
+            const Cell t = tmp.index (idx.front ());
+
+            retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
+
+            // We handled two index elements, so tell
+            // next_subsref to skip both of them.
+
+            skip++;
           }
         else
           retval(0) = do_index_op (idx.front ());
       }
       break;
 
     case '.':
       {
@@ -214,27 +211,24 @@ octave_struct::subsref (const std::strin
       {
         if (type.length () > 1 && type[1] == '.')
           {
             std::list<octave_value_list>::const_iterator p = idx.begin ();
             octave_value_list key_idx = *++p;
 
             const Cell tmp = dotref (key_idx, auto_add);
 
-            if (! error_state)
-              {
-                const Cell t = tmp.index (idx.front (), auto_add);
-
-                retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
-
-                // We handled two index elements, so tell
-                // next_subsref to skip both of them.
-
-                skip++;
-              }
+            const Cell t = tmp.index (idx.front (), auto_add);
+
+            retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
+
+            // We handled two index elements, so tell
+            // next_subsref to skip both of them.
+
+            skip++;
           }
         else
           retval = do_index_op (idx.front (), auto_add);
       }
       break;
 
     case '.':
       {
@@ -319,19 +313,16 @@ octave_struct::subsasgn (const std::stri
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).string_value ();
 
                 maybe_warn_invalid_field_name (key, "subsasgn");
 
-                if (error_state)
-                  return retval;
-
                 std::list<octave_value_list> next_idx (idx);
 
                 // We handled two index elements, so subsasgn to
                 // needs to skip both of them.
 
                 next_idx.erase (next_idx.begin ());
                 next_idx.erase (next_idx.begin ());
 
@@ -342,103 +333,92 @@ octave_struct::subsasgn (const std::stri
                 if (pkey != map.end ())
                   {
                     map.contents (pkey).make_unique ();
                     tmpc = map.contents (pkey).index (idx.front (), true);
                   }
 
                 // FIXME: better code reuse?
                 //        cf. octave_cell::subsasgn and the case below.
-                if (! error_state)
+                if (tmpc.numel () == 1)
                   {
-                    if (tmpc.numel () == 1)
+                    octave_value& tmp = tmpc(0);
+
+                    bool orig_undefined = tmp.is_undefined ();
+
+                    if (orig_undefined || tmp.is_zero_by_zero ())
                       {
-                        octave_value& tmp = tmpc(0);
-
-                        bool orig_undefined = tmp.is_undefined ();
-
-                        if (orig_undefined || tmp.is_zero_by_zero ())
-                          {
-                            tmp = octave_value::empty_conv (next_type, rhs);
-                            tmp.make_unique (); // probably a no-op.
-                          }
-                        else
-                          // optimization: ignore the copy
-                          // still stored inside our map.
-                          tmp.make_unique (1);
-
-                        if (! error_state)
-                          t_rhs =
-                            (orig_undefined
-                               ? tmp.undef_subsasgn (next_type, next_idx, rhs)
-                               : tmp.subsasgn (next_type, next_idx, rhs));
+                        tmp = octave_value::empty_conv (next_type, rhs);
+                        tmp.make_unique (); // probably a no-op.
                       }
                     else
-                      gripe_indexed_cs_list ();
+                      // optimization: ignore the copy
+                      // still stored inside our map.
+                      tmp.make_unique (1);
+
+                      t_rhs =(orig_undefined
+                              ? tmp.undef_subsasgn (next_type, next_idx, rhs)
+                              : tmp.subsasgn (next_type, next_idx, rhs));
                   }
+                else
+                  gripe_indexed_cs_list ();
               }
             else
               gripe_invalid_index_for_assignment ();
           }
           break;
 
         case '.':
           {
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).string_value ();
 
             maybe_warn_invalid_field_name (key, "subsasgn");
 
-            if (error_state)
-              return retval;
-
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
             octave_map::iterator pkey = map.seek (key);
             if (pkey != map.end ())
               {
                 map.contents (pkey).make_unique ();
                 tmpc = map.contents (pkey);
               }
 
             // FIXME: better code reuse?
-            if (! error_state)
+
+            if (tmpc.numel () == 1)
               {
-                if (tmpc.numel () == 1)
+                octave_value& tmp = tmpc(0);
+
+                bool orig_undefined = tmp.is_undefined ();
+
+                if (orig_undefined || tmp.is_zero_by_zero ())
                   {
-                    octave_value& tmp = tmpc(0);
-
-                    bool orig_undefined = tmp.is_undefined ();
-
-                    if (orig_undefined || tmp.is_zero_by_zero ())
-                      {
-                        tmp = octave_value::empty_conv (next_type, rhs);
-                        tmp.make_unique (); // probably a no-op.
-                      }
-                    else
-                      // optimization: ignore the copy
-                      // still stored inside our map.
-                      tmp.make_unique (1);
-
-                    if (! error_state)
-                      t_rhs = (orig_undefined
-                               ? tmp.undef_subsasgn (next_type, next_idx, rhs)
-                               : tmp.subsasgn (next_type, next_idx, rhs));
+                    tmp = octave_value::empty_conv (next_type, rhs);
+                    tmp.make_unique (); // probably a no-op.
                   }
                 else
-                  gripe_indexed_cs_list ();
+                  // optimization: ignore the copy
+                  // still stored inside our map.
+                  tmp.make_unique (1);
+
+                t_rhs = (orig_undefined
+                         ? tmp.undef_subsasgn (next_type, next_idx, rhs)
+                         : tmp.subsasgn (next_type, next_idx, rhs));
               }
+            else
+              gripe_indexed_cs_list ();
           }
           break;
 
         case '{':
           gripe_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
@@ -459,19 +439,16 @@ octave_struct::subsasgn (const std::stri
                 octave_value_list idxf = idx.front ();
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).string_value ();
 
                 maybe_warn_invalid_field_name (key, "subsasgn");
 
-                if (error_state)
-                  return retval;
-
                 if (! error_state)
                   {
                     if (t_rhs.is_cs_list ())
                       {
                         Cell tmp_cell = Cell (t_rhs.list_value ());
 
                         // Inquire the proper shape of the RHS.
 
@@ -567,19 +544,16 @@ octave_struct::subsasgn (const std::stri
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).string_value ();
 
             maybe_warn_invalid_field_name (key, "subsasgn");
 
-            if (error_state)
-              return retval;
-
             if (t_rhs.is_cs_list ())
               {
                 Cell tmp_cell = Cell (t_rhs.list_value ());
 
                 // The shape of the RHS is irrelevant, we just want
                 // the number of elements to agree and to preserve the
                 // shape of the left hand side of the assignment.
 
@@ -1151,19 +1125,16 @@ octave_scalar_struct::dotref (const octa
   octave_value retval;
 
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
   maybe_warn_invalid_field_name (nm, "subsref");
 
-  if (error_state)
-    return retval;
-
   retval = map.getfield (nm);
 
   if (! auto_add && retval.is_undefined ())
     error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
@@ -1278,53 +1249,46 @@ octave_scalar_struct::subsasgn (const st
       octave_value_list key_idx = idx.front ();
 
       assert (key_idx.length () == 1);
 
       std::string key = key_idx(0).string_value ();
 
       maybe_warn_invalid_field_name (key, "subsasgn");
 
-      if (error_state)
-        return retval;
-
       if (n > 1)
         {
           std::list<octave_value_list> next_idx (idx);
 
           next_idx.erase (next_idx.begin ());
 
           std::string next_type = type.substr (1);
 
           octave_value tmp;
           octave_map::iterator pkey = map.seek (key);
           if (pkey != map.end ())
             {
               map.contents (pkey).make_unique ();
               tmp = map.contents (pkey);
             }
 
-          if (! error_state)
+          bool orig_undefined = tmp.is_undefined ();
+
+          if (orig_undefined || tmp.is_zero_by_zero ())
             {
-              bool orig_undefined = tmp.is_undefined ();
-
-              if (orig_undefined || tmp.is_zero_by_zero ())
-                {
-                  tmp = octave_value::empty_conv (next_type, rhs);
-                  tmp.make_unique (); // probably a no-op.
-                }
-              else
-                // optimization: ignore the copy still stored inside our map.
-                tmp.make_unique (1);
-
-              if (! error_state)
-                t_rhs = (orig_undefined
-                         ? tmp.undef_subsasgn (next_type, next_idx, rhs)
-                         : tmp.subsasgn (next_type, next_idx, rhs));
+              tmp = octave_value::empty_conv (next_type, rhs);
+              tmp.make_unique (); // probably a no-op.
             }
+          else
+            // optimization: ignore the copy still stored inside our map.
+            tmp.make_unique (1);
+
+          t_rhs = (orig_undefined
+                   ? tmp.undef_subsasgn (next_type, next_idx, rhs)
+                   : tmp.subsasgn (next_type, next_idx, rhs));
         }
 
       if (! error_state)
         map.setfield (key, t_rhs.storable_value ());
       else
         gripe_failed_assignment ();
 
       count++;
@@ -1920,47 +1884,35 @@ produces a struct @strong{array}.\n\
   octave_map map (dims);
 
   for (int i = 0; i < nargin; i+= 2)
     {
       // Get key.
 
       std::string key (args(i).string_value ());
 
-      if (error_state)
-        return retval;
-
       maybe_warn_invalid_field_name (key, "struct");
 
-      if (error_state)
-        return retval;
-
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
 
       if (args(i+1).is_cell ())
         {
           const Cell c (args(i+1).cell_value ());
 
-          if (error_state)
-            return retval;
-
           if (scalar (c.dims ()))
             map.setfield (key, Cell (dims, c(0)));
           else
             map.setfield (key, c);
         }
       else
         map.setfield (key, Cell (dims, args(i+1)));
-
-      if (error_state)
-        return retval;
     }
 
   return octave_value (map);
 }
 
 /*
 %!shared x
 %! x(1).a=1;  x(2).a=2;  x(1).b=3;  x(2).b=3;
@@ -2170,22 +2122,17 @@ A(1)\n\
 
       octave_idx_type ext = 0;
 
       int dim = 0;
 
       if (nargin == 3)
         {
           if (args(2).is_real_scalar ())
-            {
-              dim = nargin == 2 ? 0 : args(2).int_value () - 1;
-
-              if (error_state)
-                return retval;
-            }
+            dim = nargin == 2 ? 0 : args(2).int_value () - 1;
           else
             {
               error ("cell2struct: DIM must be a real scalar");
               return retval;
             }
         }
 
       if (dim < 0)
@@ -2274,38 +2221,34 @@ the named fields.\n\
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_map m = args(0).map_value ();
 
       octave_value_list fval = Fcellstr (args(1), 1);
 
-      if (! error_state)
+      Cell fcell = fval(0).cell_value ();
+
+      for (int i = 0; i < fcell.numel (); i++)
         {
-          Cell fcell = fval(0).cell_value ();
-
-          for (int i = 0; i < fcell.numel (); i++)
+          std::string key = fcell(i).string_value ();
+
+          if (m.isfield (key))
+            m.rmfield (key);
+          else
             {
-              std::string key = fcell(i).string_value ();
-
-              if (m.isfield (key))
-                m.rmfield (key);
-              else
-                {
-                  error ("rmfield: structure does not contain field %s",
-                         key.c_str ());
-
-                  break;
-                }
+              error ("rmfield: structure does not contain field %s",
+                     key.c_str ());
+
+              break;
             }
-
-          if (! error_state)
-            retval = m;
         }
+
+      retval = m;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
