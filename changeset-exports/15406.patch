# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1347972087 14400
#      Tue Sep 18 08:41:27 2012 -0400
# Node ID 0b4626dc4d38d710bcfadf54c33d47b78f27d542
# Parent  6d4cd994ea718a025b043de2e4bc38529c0b8fed
# Parent  f52a62a6db3aeb2e42dd60a643cbbad24a1d2ce0
Merge in Ed's changes

diff --git a/libgui/src/history-dockwidget.cc b/libgui/src/history-dockwidget.cc
--- a/libgui/src/history-dockwidget.cc
+++ b/libgui/src/history-dockwidget.cc
@@ -21,85 +21,31 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QVBoxLayout>
 
-#include "cmd-hist.h"
-
 #include "error.h"
 
+#include "cmd-hist.h"
+
 #include "history-dockwidget.h"
+#include "octave-link.h"
 
 history_dock_widget::history_dock_widget (QWidget * p)
-  : QDockWidget (p), octave_event_observer ()
+  : QDockWidget (p)
 {
   setObjectName ("HistoryDockWidget");
   construct ();
 }
 
 void
-history_dock_widget::handle_event (octave_event *e, bool accept)
-{
-  static bool scroll_window = false;
-
-  if (accept)
-    {
-      if (dynamic_cast <octave_update_history_event*> (e))
-        {
-          // Determine the client's (our) history length and the one of the server.
-          int clientHistoryLength = _history_model->rowCount ();
-          int serverHistoryLength = command_history::length ();
-
-          // If were behind the server, iterate through all new entries and add
-          // them to our history.
-          if (clientHistoryLength < serverHistoryLength)
-            {
-              int elts_to_add = serverHistoryLength - clientHistoryLength;
-
-              _history_model->insertRows (clientHistoryLength, elts_to_add);
-
-              for (int i = clientHistoryLength; i < serverHistoryLength; i++)
-                {
-                  std::string entry = command_history::get_entry (i);
-
-                  _history_model->setData (_history_model->index (i),
-                                           QString::fromStdString (entry));
-                }
-
-              // FIXME -- does this behavior make sense?  Calling
-              // _history_list_view->scrollToBottom () here doesn't seem to
-              // have any effect.  Instead, we need to request that action
-              // and wait until the next event occurs in which no items
-              // are added to the history list.
-
-              scroll_window = true;
-            }
-          else if (scroll_window)
-            {
-              scroll_window = false;
-
-              _history_list_view->scrollToBottom ();
-            }
-        }
-
-      // Post a new update event in a given time. This prevents flooding the
-      // event queue.
-      _update_history_model_timer.start ();
-    }
-  else
-    {
-      // octave_event::perform failed to handle event.
-    }
-}
-
-void
 history_dock_widget::construct ()
 {
   _history_model = new QStringListModel ();
   _sort_filter_proxy_model.setSourceModel (_history_model);
   _history_list_view = new QListView (this);
   _history_list_view->setModel (&_sort_filter_proxy_model);
   _history_list_view->setAlternatingRowColors (true);
   _history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
@@ -156,23 +102,68 @@ history_dock_widget::handle_visibility_c
 {
   if (visible)
     emit active_changed (true);
 }
 
 void
 history_dock_widget::request_history_model_update ()
 {
-  octave_link::post_event (new octave_update_history_event (*this));
+  octave_link::post_event (this, &history_dock_widget::update_history_callback);
 }
 
 void
 history_dock_widget::reset_model ()
 {
   _history_model->setStringList (QStringList ());
 }
 
 void
 history_dock_widget::closeEvent (QCloseEvent *e)
 {
   emit active_changed (false);
   QDockWidget::closeEvent (e);
 }
+
+void
+history_dock_widget::update_history_callback (void)
+{
+  static bool scroll_window = false;
+
+  // Determine the client's (our) history length and the one of the server.
+  int clientHistoryLength = _history_model->rowCount ();
+  int serverHistoryLength = command_history::length ();
+
+  // If were behind the server, iterate through all new entries and add
+  // them to our history.
+  if (clientHistoryLength < serverHistoryLength)
+    {
+      int elts_to_add = serverHistoryLength - clientHistoryLength;
+
+      _history_model->insertRows (clientHistoryLength, elts_to_add);
+
+      for (int i = clientHistoryLength; i < serverHistoryLength; i++)
+        {
+          std::string entry = command_history::get_entry (i);
+
+          _history_model->setData (_history_model->index (i),
+                                   QString::fromStdString (entry));
+        }
+
+      // FIXME -- does this behavior make sense?  Calling
+      // _history_list_view->scrollToBottom () here doesn't seem to
+      // have any effect.  Instead, we need to request that action
+      // and wait until the next event occurs in which no items
+      // are added to the history list.
+
+      scroll_window = true;
+    }
+  else if (scroll_window)
+    {
+      scroll_window = false;
+
+      _history_list_view->scrollToBottom ();
+    }
+
+  // Post a new update event in a given time. This prevents flooding the
+  // event queue.
+  _update_history_model_timer.start ();
+}
diff --git a/libgui/src/history-dockwidget.h b/libgui/src/history-dockwidget.h
--- a/libgui/src/history-dockwidget.h
+++ b/libgui/src/history-dockwidget.h
@@ -25,27 +25,22 @@ along with Octave; see the file COPYING.
 
 #include <QDockWidget>
 #include <QLineEdit>
 #include <QListView>
 #include <QSortFilterProxyModel>
 #include <QStringListModel>
 #include <QTimer>
 
-#include "octave-link.h"
-#include "octave-event-observer.h"
-
-class history_dock_widget : public QDockWidget, public octave_event_observer
+class history_dock_widget : public QDockWidget
 {
   Q_OBJECT
   public:
   history_dock_widget (QWidget *parent = 0);
 
-  void handle_event (octave_event *e, bool accept);
-
 public slots:
   void handle_visibility_changed (bool visible);
   void request_history_model_update ();
   void reset_model ();
 
 signals:
   void information (const QString& message);
 
@@ -64,11 +59,13 @@ private:
   QListView *_history_list_view;
   QLineEdit *_filter_line_edit;
   QSortFilterProxyModel _sort_filter_proxy_model;
 
   /** Stores the current history_model. */
   QStringListModel *_history_model;
 
   QTimer _update_history_model_timer;
+
+  void update_history_callback (void);
 };
 
 #endif // HISTORYDOCKWIDGET_H
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -19,40 +19,42 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "file-editor-tab.h"
-#include "file-editor.h"
-#include "find-dialog.h"
-#include "octave-link.h"
-
-
 #include <Qsci/qsciapis.h>
 // Not available in the Debian repos yet!
 // #include <Qsci/qscilexeroctave.h>
 #include "lexer-octave-gui.h"
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
 #include <Qsci/qscilexerdiff.h>
 #include "resource-manager.h"
 #include <QApplication>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QTextStream>
 #include <QVBoxLayout>
 
+#include "file-editor-tab.h"
+#include "file-editor.h"
+#include "find-dialog.h"
+#include "octave-link.h"
+
+#include "debug.h"
+#include "oct-env.h"
+
 file_editor_tab::file_editor_tab(file_editor *fileEditor)
-  : QWidget ((QWidget*)fileEditor), octave_event_observer ()
+  : QWidget ((QWidget*)fileEditor)
 {
   _file_editor = fileEditor;
   _file_name = "";
   _edit_area = new QsciScintilla (this);
 
   // symbols
   _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
   _edit_area->setMarginSensitivity (1, true);
@@ -111,54 +113,16 @@ file_editor_tab::file_editor_tab(file_ed
 
 bool
 file_editor_tab::copy_available ()
 {
   return _copy_available;
 }
 
 void
-file_editor_tab::handle_event (octave_event *e, bool accept)
-{
-  if (accept)
-    {
-      if (dynamic_cast<octave_run_file_event*> (e))
-        {
-          // File was run successfully.
-        }
-
-      if (octave_add_breakpoint_event *abe
-          = dynamic_cast<octave_add_breakpoint_event*> (e))
-        {
-          // TODO: Check file.
-          _edit_area->markerAdd (abe->get_line (), breakpoint);
-        }
-
-      if (octave_remove_breakpoint_event *rbe
-          = dynamic_cast<octave_remove_breakpoint_event*> (e))
-        {
-          // TODO: Check file.
-          _edit_area->markerDelete (rbe->get_line (), breakpoint);
-        }
-
-      if (dynamic_cast<octave_remove_all_breakpoints_event*> (e))
-        {
-          _edit_area->markerDeleteAll (breakpoint);
-        }
-    }
-  else
-    {
-      if (dynamic_cast<octave_run_file_event*> (e))
-        {
-          // Running file failed.
-        }
-    }
-}
-
-void
 file_editor_tab::closeEvent (QCloseEvent *e)
 {
   if (_file_editor->get_main_window ()->is_closing ())
     {
       // close whole application: save file or not if modified
       check_file_modified ("Closing Octave", 0); // no cancel possible
       e->accept ();
     }
@@ -302,34 +266,36 @@ file_editor_tab::request_add_breakpoint 
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::post_event (new octave_add_breakpoint_event
-                           (*this, path.toStdString (),
-                            function_name.toStdString (), line));
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::add_breakpoint_callback, info);
 }
 
 void
 file_editor_tab::request_remove_breakpoint (int line)
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::post_event (new octave_remove_breakpoint_event
-                           (*this, path.toStdString (),
-                            function_name.toStdString (), line));
+  bp_info info (path, function_name, line);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_breakpoint_callback, info);
 }
 
 void
 file_editor_tab::comment_selected_text ()
 {
   do_comment_selected_text (true);
 }
 
@@ -487,19 +453,20 @@ file_editor_tab::remove_all_breakpoints 
 {
   QFileInfo file_info (_file_name);
   QString path = file_info.absolutePath ();
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
 
-  octave_link::post_event (new octave_remove_all_breakpoints_event
-                           (*this, path.toStdString (),
-                            function_name.toStdString ()));
+  bp_info info (path, function_name, 0);
+
+  octave_link::post_event
+    (this, &file_editor_tab::remove_all_breakpoints_callback, info);
 }
 
 void
 file_editor_tab::toggle_breakpoint ()
 {
   int line, cur;
   _edit_area->getCursorPosition (&line, &cur);
   if ( _edit_area->markersAtLine (line) && (1 << breakpoint) )
@@ -744,18 +711,18 @@ file_editor_tab::run_file ()
     = QString::fromStdString (octave_link::last_working_directory ());
   QString function_name = file_info.fileName ();
 
   // We have to cut off the suffix, because octave appends it.
   function_name.chop (file_info.suffix ().length () + 1);
   _file_editor->terminal ()->sendText (QString ("cd \'%1\'\n%2\n")
                                        .arg(path).arg (function_name));
   // TODO: Sending a run event crashes for long scripts. Find out why.
-  //  octave_link::post_event (new octave_run_file_event
-  //                           (*this, _file_name.toStdString ()));
+  // octave_link::post_event
+  //   (this, &file_editor_tab::run_file_callback, _file_name.toStdString ()));
 }
 
 void
 file_editor_tab::file_has_changed (const QString&)
 {
   if (QFile::exists (_file_name))
     {
       // Prevent popping up multiple message boxes when the file has
@@ -834,8 +801,66 @@ file_editor_tab::notice_settings ()
     }
 
   update_lexer ();
 
   _long_title = settings->value ("editor/longWindowTitle",false).toBool ();
 
   update_window_title (false);
 }
+
+void
+file_editor_tab::run_file_callback (void)
+{
+  // Maybe someday we will do something here?
+}
+
+void
+file_editor_tab::add_breakpoint_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  intmap[0] = info.line + 1;
+
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  intmap = bp_table::add_breakpoint (info.function_name, intmap);
+  octave_env::chdir (previous_directory);
+
+  if (intmap.size () > 0)
+    {
+    // FIXME -- Check file.
+      _edit_area->markerAdd (info.line, breakpoint);
+    }
+}
+
+void
+file_editor_tab::remove_breakpoint_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  intmap[0] = info.line;
+
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  bp_table::remove_breakpoint (info.function_name, intmap);
+  octave_env::chdir (previous_directory);
+
+  // FIXME -- check result
+  bool success = true;
+
+  if (success)
+    {
+      // FIXME -- check file.
+      _edit_area->markerDelete (info.line, breakpoint);
+    }
+}
+
+void
+file_editor_tab::remove_all_breakpoints_callback (const bp_info& info)
+{
+  bp_table::intmap intmap;
+  std::string previous_directory = octave_env::get_current_directory ();
+  octave_env::chdir (info.path);
+  intmap = bp_table::remove_all_breakpoints_in_file (info.function_name, true);
+  octave_env::chdir (previous_directory);
+
+  if (intmap.size() > 0)
+    _edit_area->markerDeleteAll (breakpoint);
+}
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -22,28 +22,25 @@ along with Octave; see the file COPYING.
 
 #ifndef FILEEDITORTAB_H
 #define FILEEDITORTAB_H
 
 #include <Qsci/qsciscintilla.h>
 #include <QWidget>
 #include <QCloseEvent>
 #include <QFileSystemWatcher>
-#include "octave-event-observer.h"
 
 class file_editor;
-class file_editor_tab : public QWidget, public octave_event_observer
+class file_editor_tab : public QWidget
 {
   Q_OBJECT
   public:
   file_editor_tab (file_editor *fileEditor);
   bool copy_available ();
 
-  void handle_event (octave_event *e, bool accept);
-
 public slots:
   void update_window_title(bool modified);
   void handle_copy_available(bool enableCopy);
   void handle_margin_clicked (int line, int margin, Qt::KeyboardModifiers state);
   void comment_selected_text ();
   void uncomment_selected_text ();
   void find ();
   void remove_bookmark ();
@@ -82,24 +79,41 @@ signals:
   void editor_state_changed ();
   void close_request ();
 
 protected:
   void closeEvent (QCloseEvent *event);
   void set_file_name (const QString& fileName);
 
 private:
+
+  struct bp_info
+  {
+    bp_info (const QString& p, const QString& fn, int l)
+      : path (p.toStdString ()), function_name (fn.toStdString ()), line (l)
+    { }
+
+    std::string path;
+    std::string function_name;
+    int line;
+  };
+
   void update_lexer ();
   void request_add_breakpoint (int line);
   void request_remove_breakpoint (int line);
 
   void update_tracked_file ();
   int check_file_modified (const QString& msg, int cancelButton);
   void do_comment_selected_text (bool comment);
 
+  void run_file_callback (void);
+  void add_breakpoint_callback (const bp_info& info);
+  void remove_breakpoint_callback (const bp_info& info);
+  void remove_all_breakpoints_callback (const bp_info& info);
+
   file_editor *         _file_editor;
   QsciScintilla *       _edit_area;
 
   QString               _file_name;
   QString               _file_name_short;
 
   bool                  _long_title;
   bool                  _copy_available;
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -32,50 +32,44 @@ along with Octave; see the file COPYING.
 #include <QSettings>
 #include <QStyle>
 #include <QToolBar>
 #include <QDesktopServices>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QIcon>
 
+#include "file-editor.h"
 #include "main-window.h"
-#include "file-editor.h"
+#include "octave-link.h"
 #include "settings-dialog.h"
 
+#include "debug.h"
+#include "defaults.h"
+#include "load-save.h"
+#include "toplev.h"
+#include "variables.h"
+#include "version.h"
+
+#include "cmd-hist.h"
+#include "oct-env.h"
+
 main_window::main_window (QWidget *p)
-  : QMainWindow (p), octave_event_observer ()
+  : QMainWindow (p)
 {
   // We have to set up all our windows, before we finally launch octave.
   construct ();
   octave_link::launch_octave ();
 }
 
 main_window::~main_window ()
 {
 }
 
 void
-main_window::handle_event (octave_event *e, bool accept)
-{
-  if (accept)
-    {
-      if (dynamic_cast<octave_clear_history_event*> (e))
-        {
-          // After clearing the history, we need to reset the model.
-          _history_dock_widget->reset_model ();
-        }
-    }
-  else
-    {
-      // octave_event::perform failed to process event.
-    }
-}
-
-void
 main_window::new_file ()
 {
   _file_editor->request_new_file ();
   focus_editor ();
 }
 
 void
 main_window::open_file ()
@@ -99,45 +93,41 @@ main_window::report_status_message (cons
 
 void
 main_window::handle_save_workspace_request ()
 {
   QString selectedFile =
     QFileDialog::getSaveFileName (this, tr ("Save Workspace"),
                                   resource_manager::get_home_path ());
   if (!selectedFile.isEmpty ())
-    {
-      octave_link::post_event (new octave_save_workspace_event
-                               (*this, selectedFile.toStdString ()));
-    }
+    octave_link::post_event (this, &main_window::save_workspace_callback,
+                             selectedFile.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request ()
 {
   QString selectedFile =
     QFileDialog::getOpenFileName (this, tr ("Load Workspace"),
                                   resource_manager::get_home_path ());
   if (!selectedFile.isEmpty ())
-    {
-      octave_link::post_event (new octave_load_workspace_event
-                               (*this, selectedFile.toStdString ()));
-    }
+    octave_link::post_event (this, &main_window::load_workspace_callback,
+                             selectedFile.toStdString ());
 }
 
 void
 main_window::handle_clear_workspace_request ()
 {
-  octave_link::post_event (new octave_clear_workspace_event (*this));
+  octave_link::post_event (this, &main_window::clear_workspace_callback);
 }
 
 void
 main_window::handle_clear_history_request()
 {
-  octave_link::post_event (new octave_clear_history_event (*this));
+  octave_link::post_event (this, &main_window::clear_history_callback);
 }
 
 void
 main_window::handle_command_double_clicked (const QString& command)
 {
   _terminal->sendText (command);
   _terminal->setFocus ();
 }
@@ -227,27 +217,25 @@ main_window::current_working_directory_h
 
 void
 main_window::change_current_working_directory ()
 {
   QString selectedDirectory =
     QFileDialog::getExistingDirectory(this, tr ("Set working direcotry"));
 
   if (!selectedDirectory.isEmpty ())
-    {
-      octave_link::post_event (new octave_change_directory_event
-                               (*this, selectedDirectory.toStdString ()));
-    }
+    octave_link::post_event (this, &main_window::change_directory_callback,
+                             selectedDirectory.toStdString ());
 }
 
 void
 main_window::set_current_working_directory (const QString& directory)
 {
-  octave_link::post_event (new octave_change_directory_event
-                           (*this, directory.toStdString ()));
+  octave_link::post_event (this, &main_window::change_directory_callback,
+                           directory.toStdString ());
 }
 
 void
 main_window::current_working_directory_up ()
 {
   set_current_working_directory ("..");
 }
 
@@ -355,71 +343,56 @@ main_window::handle_quit_debug_mode ()
   _debug_step_out->setEnabled (false);
   _debug_quit->setEnabled (false);
   _file_editor->handle_quit_debug_mode ();
 }
 
 void
 main_window::debug_continue ()
 {
-  octave_link::post_event (new octave_debug_continue_event (*this));
+  octave_link::post_event (this, &main_window::debug_continue_callback);
 }
 
 void
 main_window::debug_step_into ()
 {
-  octave_link::post_event (new octave_debug_step_into_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_into_callback);
 }
 
 void
 main_window::debug_step_over ()
 {
-  octave_link::post_event (new octave_debug_step_over_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_over_callback);
 }
 
 void
 main_window::debug_step_out ()
 {
-  octave_link::post_event (new octave_debug_step_out_event (*this));
+  octave_link::post_event (this, &main_window::debug_step_out_callback);
 }
 
 void
 main_window::debug_quit ()
 {
-  octave_link::post_event (new octave_debug_quit_event (*this));
+  octave_link::post_event (this, &main_window::debug_quit_callback);
 }
 
 void
 main_window::show_about_octave ()
 {
-  QString message =
-    "GNU Octave\n"
-    "Copyright (C) 2009 John W. Eaton and others.\n"
-    "This is free software; see the source code for copying conditions."
-    "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or"
-    "FITNESS FOR A PARTICULAR PURPOSE.  For details, type `warranty'.\n"
-    "\n"
-    "Additional information about Octave is available at http://www.octave.org.\n"
-    "\n"
-    "Please contribute if you find this software useful."
-    "For more information, visit http://www.octave.org/help-wanted.html\n"
-    "\n"
-    "Report bugs to <bug@octave.org> (but first, please read"
-    "http://www.octave.org/bugs.html to learn how to write a helpful report).\n"
-    "\n"
-    "For information about changes from previous versions, type `news'.\n";
+  QString message = OCTAVE_STARTUP_MESSAGE;
 
   QMessageBox::about (this, tr ("About Octave"), message);
 }
 
 void
 main_window::closeEvent (QCloseEvent *e)
 {
   e->ignore ();
-  octave_link::post_event (new octave_exit_event (*this));
+  octave_link::post_event (this, &main_window::exit_callback);
 }
 
 void
 main_window::read_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
@@ -890,8 +863,75 @@ main_window::construct ()
            SLOT(handle_entered_debug_mode ()));
 
   connect (_octave_qt_event_listener,
            SIGNAL (quit_debug_mode_signal ()),
            this,
            SLOT (handle_quit_debug_mode ()));
 }
 
+void
+main_window::save_workspace_callback (const std::string& file)
+{
+  save_workspace (file);
+}
+
+void
+main_window::load_workspace_callback (const std::string& file)
+{
+  load_workspace (file);
+}
+
+void
+main_window::clear_workspace_callback (void)
+{
+  clear_current_scope ();
+}
+
+void
+main_window::clear_history_callback (void)
+{
+  command_history::clear ();
+
+  _history_dock_widget->reset_model ();
+}
+
+void
+main_window::change_directory_callback (const std::string& directory)
+{
+  octave_env::chdir (directory); 
+}
+
+void
+main_window::debug_continue_callback (void)
+{
+  debug_continue ();
+}
+
+void
+main_window::debug_step_into_callback (void)
+{
+  debug_step ("in");
+}
+
+void
+main_window::debug_step_over_callback (void)
+{
+  debug_step ();
+}
+
+void
+main_window::debug_step_out_callback (void)
+{
+  debug_step ("out");
+}
+
+void
+main_window::debug_quit_callback (void)
+{
+  debug_quit ();
+}
+
+void
+main_window::exit_callback (void)
+{
+  clean_up_and_exit (0);
+}
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -39,39 +39,34 @@ along with Octave; see the file COPYING.
 // Editor includes
 #include "file-editor-interface.h"
 
 // QTerminal includes
 #include "QTerminal.h"
 
 // Own includes
 #include "resource-manager.h"
-#include "octave-link.h"
 #include "workspace-view.h"
 #include "history-dockwidget.h"
 #include "files-dockwidget.h"
 #include "terminal-dockwidget.h"
 #include "documentation-dockwidget.h"
 #include "octave-qt-event-listener.h"
-#include "octave-event-observer.h"
 
 /**
  * \class MainWindow
  *
  * Represents the main window.
  */
-class main_window
-  : public QMainWindow, public octave_event_observer
+class main_window : public QMainWindow
 {
   Q_OBJECT public:
   main_window (QWidget * parent = 0);
   ~main_window ();
 
-  void handle_event (octave_event *e, bool accept);
-
   QTerminal *get_terminal_view () { return _terminal; }
   history_dock_widget *get_history_dock_widget ()
   {
     return _history_dock_widget;
   }
   files_dock_widget *get_files_dock_widget ()
   {
     return _files_dock_widget;
@@ -123,16 +118,38 @@ protected:
   void closeEvent (QCloseEvent * closeEvent);
   void read_settings ();
   void write_settings ();
 
 private:
   void construct ();
   void establish_octave_link ();
 
+  void save_workspace_callback (const std::string& file);
+
+  void load_workspace_callback (const std::string& file);
+
+  void clear_workspace_callback (void);
+
+  void clear_history_callback (void);
+
+  void change_directory_callback (const std::string& directory);
+
+  void debug_continue_callback (void);
+
+  void debug_step_into_callback (void);
+
+  void debug_step_over_callback (void);
+
+  void debug_step_out_callback (void);
+
+  void debug_quit_callback (void);
+
+  void exit_callback (void);
+
   QTerminal *               _terminal;
   file_editor_interface *   _file_editor;
   QMenu *                   _debug_menu;
 
   QAction *                 _debug_continue;
   QAction *                 _debug_step_into;
   QAction *                 _debug_step_over;
   QAction *                 _debug_step_out;
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -79,18 +79,16 @@ noinst_HEADERS += \
   src/history-dockwidget.h \
   src/m-editor/file-editor-interface.h \
   src/m-editor/file-editor-tab.h \
   src/m-editor/file-editor.h \
   src/m-editor/find-dialog.h \
   src/m-editor/lexer-octave-gui.h \
   src/main-window.h \
   src/octave-adapter/octave-event-listener.h \
-  src/octave-adapter/octave-event-observer.h \
-  src/octave-adapter/octave-event.h \
   src/octave-adapter/octave-link.h \
   src/octave-adapter/octave-main-thread.h \
   src/octave-gui.h \
   src/octave-qt-event-listener.h \
   src/qtinfo/parser.h \
   src/qtinfo/webinfo.h \
   src/resource-manager.h \
   src/settings-dialog.h \
@@ -104,17 +102,16 @@ src_libgui_src_la_SOURCES = \
   src/documentation-dockwidget.cc \
   src/files-dockwidget.cc \
   src/history-dockwidget.cc \
   src/m-editor/file-editor-tab.cc \
   src/m-editor/file-editor.cc \
   src/m-editor/find-dialog.cc \
   src/m-editor/lexer-octave-gui.cc \
   src/main-window.cc \
-  src/octave-adapter/octave-event.cc \
   src/octave-adapter/octave-link.cc \
   src/octave-adapter/octave-main-thread.cc \
   src/octave-gui.cc \
   src/octave-qt-event-listener.cc \
   src/qtinfo/parser.cc \
   src/qtinfo/webinfo.cc \
   src/resource-manager.cc \
   src/settings-dialog.cc \
@@ -139,17 +136,17 @@ src_libgui_src_la_CPPFLAGS = \
   -I$(srcdir)/src/octave-adapter \
   -I$(srcdir)/src/qtinfo \
   -I$(top_srcdir)/liboctave/cruft/misc \
   -I$(top_srcdir)/liboctave/array \
   -I$(top_builddir)/liboctave/numeric -I$(top_srcdir)/liboctave/numeric \
   -I$(top_builddir)/liboctave/operators -I$(top_srcdir)/liboctave/operators \
   -I$(top_srcdir)/liboctave/system \
   -I$(top_srcdir)/liboctave/util \
-  -I$(top_srcdir)/libinterp \
+  -I$(top_builddir)/libinterp -I$(top_srcdir)/libinterp \
   -I$(top_builddir)/libinterp/parse-tree -I$(top_srcdir)/libinterp/parse-tree \
   -I$(top_builddir)/libinterp/interp-core -I$(top_srcdir)/libinterp/interp-core \
   -I$(top_builddir)/libinterp/interpfcn -I$(top_srcdir)/libinterp/interpfcn \
   -I$(top_srcdir)/libinterp/octave-value
 
 src_libgui_src_la_CFLAGS = $(AM_CFLAGS) $(WARN_CFLAGS)
 
 src_libgui_src_la_CXXFLAGS = $(AM_CXXFLAGS) $(WARN_CXXFLAGS)
diff --git a/libgui/src/octave-adapter/octave-event-observer.h b/libgui/src/octave-adapter/octave-event-observer.h
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event-observer.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OCTAVEEVENTOBSERVER_H
-#define OCTAVEEVENTOBSERVER_H
-
-class octave_event;
-
-/**
-  * \class octave_event_observer
-  * \brief Implements the observer part for the observer pattern.
-  */
-class octave_event_observer
-{
-  public:
-    octave_event_observer () { }
-    virtual ~octave_event_observer () { }
-
-    /**
-      * This will be called after the octave_event::perform function
-      * has processed an event.  ACCEPT will be true if the event was
-      * successfully handled and false otherwise.
-      */
-    virtual void handle_event (octave_event *e, bool accept) = 0;
-};
-
-#include "octave-event.h"
-
-#endif // OCTAVEEVENTOBSERVER_H
diff --git a/libgui/src/octave-adapter/octave-event.cc b/libgui/src/octave-adapter/octave-event.cc
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event.cc
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-Copyright (C) 2011-2012 John P. Swensen
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string>
-
-#include "cmd-hist.h"
-#include "oct-env.h"
-
-#include "debug.h"
-#include "oct-obj.h"
-#include "parse.h"
-#include "symtab.h"
-#include "toplev.h"
-
-#include "octave-event.h"
-
-#include <readline/readline.h>
-
-void
-octave_event::call_octave_function (const std::string& name)
-{
-  call_octave_function (name, octave_value_list ());
-}
-
-void
-octave_event::call_octave_function (const std::string& name,
-                                    const octave_value_list& args,
-                                    int nargout)
-{
-  try
-    {
-      feval (name, args, nargout);
-    } catch (...) { } // Ignore exceptions. Crashes without that.
-}
-
-void
-octave_event::finish_readline_event () const
-{
-  rl_line_buffer[0] = '\0';
-  rl_point = rl_end = 0;
-  rl_done = 1;
-  //rl_forced_update_display ();
-}
-
-bool
-octave_clear_history_event::perform ()
-{
-  int i;
-  while ((i = command_history::length ()) > 0) {
-    command_history::remove (i - 1);
-  }
-  return true;
-}
-
-bool
-octave_debug_step_into_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value ("in"));
-  call_octave_function ("dbstep", args);
-  finish_readline_event ();
-  return true;
-}
-
-bool
-octave_debug_step_out_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value ("out"));
-  call_octave_function ("dbstep", args);
-  finish_readline_event ();
-  return true;
-}
-
-
-bool
-octave_exit_event::perform ()
-{
-  clean_up_and_exit (0);
-  return true;
-}
-
-bool
-octave_run_file_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("run", args);
-  finish_readline_event ();
-  return true;
-}
-
-bool
-octave_change_directory_event::perform ()
-{
-  return octave_env::chdir (_directory);
-}
-
-bool
-octave_load_workspace_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("load", args);
-  return true;
-}
-
-bool
-octave_save_workspace_event::perform ()
-{
-  octave_value_list args;
-  args.append (octave_value (_file));
-  call_octave_function ("save", args);
-  return true;
-}
-
-bool
-octave_add_breakpoint_event::perform ()
-{
-  bp_table::intmap intmap;
-  intmap[0] = _line + 1;
-
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  intmap = bp_table::add_breakpoint (_function_name, intmap);
-  octave_env::chdir (previous_directory);
-  return intmap.size () > 0;
-}
-
-bool
-octave_remove_breakpoint_event::perform ()
-{
-  bp_table::intmap intmap;
-  intmap[0] = _line;
-
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  bp_table::remove_breakpoint (_function_name, intmap);
-  octave_env::chdir (previous_directory);
-  return true; // TODO: Check result.
-}
-
-bool
-octave_remove_all_breakpoints_event::perform ()
-{
-  bp_table::intmap intmap;
-  std::string previous_directory = octave_env::get_current_directory ();
-  octave_env::chdir (_path);
-  intmap = bp_table::remove_all_breakpoints_in_file (_function_name, true);
-  octave_env::chdir (previous_directory);
-  return intmap.size() > 0;
-}
diff --git a/libgui/src/octave-adapter/octave-event.h b/libgui/src/octave-adapter/octave-event.h
deleted file mode 100644
--- a/libgui/src/octave-adapter/octave-event.h
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
-
-Copyright (C) 2011-2012 Jacob Dawid
-Copyright (C) 2011-2012 John P. Swensen
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OCTAVEEVENT_H
-#define OCTAVEEVENT_H
-
-#include <string>
-
-class octave_value_list;
-
-#include "octave-event-observer.h"
-
-/**
-  * \class octave_event
-  * \brief Base class for an octave event.
-  * In order to make communication with octave threadsafe, comunication is
-  * implemented via events. An application may create events and post them,
-  * however there is no guarantee events will be processed in a given time.
-  *
-  * In order to create an event, there must be an event observer. The event
-  * observer will be given the opportunity to react on the event as soon as
-  * it has been processed in the octave thread. Accepting and ignoring takes
-  * places in the octave thread.
-  */
-class octave_event
-{
-  public:
-    octave_event (octave_event_observer& o)
-      : _octave_event_observer (o)
-    { }
-
-    virtual ~octave_event ()
-    { }
-
-    /** Performs what is necessary to make this event happen. This
-      * code is thread-safe since it will be executed in the octave
-      * thread. However, you should take care to keep this code as
-      * short as possible. */
-    virtual bool perform () = 0;
-
-    /**
-      * Pass the event on to the class that posted the event.  ACCEPT
-      * will be true if the perform function was successful, and false
-      * otherwise.
-      */
-    void handle_event (bool accept)
-    {
-      _octave_event_observer.handle_event (this, accept);
-    }
-
-  protected:
-    void call_octave_function (const std::string& name);
-
-    void call_octave_function (const std::string& name,
-                               const octave_value_list& args,
-                               int nargout = 0);
-
-    void finish_readline_event () const;
-
-  private:
-    octave_event_observer& _octave_event_observer;
-};
-
-class octave_update_history_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_update_history_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    { return true; /* Always grant. */ }
-};
-
-class octave_update_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_update_workspace_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    { return true; /* Always grant. */ }
-};
-
-/** Implements an octave exit event. */
-class octave_exit_event : public octave_event
-{
-  public:
-    /** Creates a new octave_exit_event. */
-    octave_exit_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ();
-};
-
-/** Implements an octave run file event. */
-class octave_run_file_event : public octave_event
-{
-  public:
-    /** Creates a new octave_run_file_event. */
-    octave_run_file_event (octave_event_observer& o,
-                           const std::string& file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-/** Implements a change directory event. */
-class octave_change_directory_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_change_directory_event (octave_event_observer& o,
-                                   const std::string& directory)
-      : octave_event (o)
-    { _directory = directory; }
-
-    bool perform ();
-
-  private:
-    std::string _directory;
-};
-
-/** Implements a clear workspace event. */
-class octave_clear_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_run_file_event. */
-    octave_clear_workspace_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-    bool perform ()
-    {
-      call_octave_function ("clear");
-      return true;
-    }
-};
-
-/** Implements a load workspace event. */
-class octave_load_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_load_workspace_event (octave_event_observer& o,
-                                 const std::string& file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-/** Implements a save workspace event. */
-class octave_save_workspace_event : public octave_event
-{
-  public:
-    /** Creates a new octave_change_directory_event. */
-    octave_save_workspace_event (octave_event_observer& o,
-                                 const std::string& file)
-      : octave_event (o)
-    { _file = file; }
-
-    bool perform ();
-
-  private:
-    std::string _file;
-};
-
-class octave_clear_history_event : public octave_event
-{
-  public:
-    /** Creates a new octave_clear_history_event. */
-    octave_clear_history_event (octave_event_observer& o)
-      : octave_event (o)
-    { }
-
-  bool perform ();
-};
-
-class octave_add_breakpoint_event : public octave_event
-{
-  public:
-    octave_add_breakpoint_event (octave_event_observer& o,
-                                 const std::string& path,
-                                 const std::string& function_name,
-                                 int line)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-      _line = line;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-    int get_line ()
-    {
-      return _line;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-    int _line;
-};
-
-class octave_remove_breakpoint_event : public octave_event
-{
-  public:
-    octave_remove_breakpoint_event (octave_event_observer& o,
-                                    const std::string& path,
-                                    const std::string& function_name,
-                                    int line)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-      _line = line;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-    int get_line ()
-    {
-      return _line;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-    int _line;
-};
-
-class octave_remove_all_breakpoints_event : public octave_event
-{
-  public:
-    octave_remove_all_breakpoints_event (octave_event_observer& o,
-                                         const std::string& path,
-                                         const std::string& function_name)
-      : octave_event (o)
-    {
-      _path = path;
-      _function_name = function_name;
-    }
-
-    bool perform ();
-
-    std::string get_path ()
-    {
-      return _path;
-    }
-
-    std::string get_function_name ()
-    {
-      return _function_name;
-    }
-
-  private:
-    std::string _path;
-    std::string _function_name;
-};
-
-class octave_debug_step_into_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_into_event. */
-    octave_debug_step_into_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ();
-};
-
-class octave_debug_step_over_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_over_event. */
-    octave_debug_step_over_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbnext");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-class octave_debug_step_out_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_step_out_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ();
-};
-
-class octave_debug_continue_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_continue_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbcont");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-class octave_debug_quit_event : public octave_event
-{
-  public:
-    /** Creates a new octave_debug_step_out_event. */
-    octave_debug_quit_event (octave_event_observer& o)
-      : octave_event (o) { }
-
-    bool perform ()
-    {
-      call_octave_function ("dbquit");
-      finish_readline_event ();
-      return true;
-    }
-};
-
-#endif // OCTAVEEVENT_H
diff --git a/libgui/src/octave-adapter/octave-link.cc b/libgui/src/octave-adapter/octave-link.cc
--- a/libgui/src/octave-adapter/octave-link.cc
+++ b/libgui/src/octave-adapter/octave-link.cc
@@ -50,17 +50,17 @@ octave_exit_hook (int)
 {
   octave_link::about_to_exit ();
 }
 
 octave_link *octave_link::instance = 0;
 
 octave_link::octave_link (void)
   : event_listener (0), event_queue_mutex (new octave_mutex ()),
-    event_queue (), last_cwd (), debugging (false)
+    gui_event_queue (), last_cwd (), debugging (false)
 { }
 
 void
 octave_link::do_launch_octave (void)
 {
   // Create both threads.
   main_thread = new octave_main_thread ();
 
@@ -105,68 +105,40 @@ octave_link::do_generate_events (void)
     }
 }
 
 void
 octave_link::do_process_events (void)
 {
   event_queue_mutex->lock ();
 
-  while (event_queue.size () > 0)
-    {
-      octave_event *e = event_queue.front ();
-
-      event_queue.pop ();
-
-      bool status = e->perform ();
-
-      e->handle_event (status);
-
-      delete e;
-    }
+  gui_event_queue.run ();
 
   event_queue_mutex->unlock ();
 }
 
 void
-octave_link::do_post_event (octave_event *e)
-{
-  if (e)
-    {
-      event_queue_mutex->lock ();
-      event_queue.push (e);
-      event_queue_mutex->unlock ();
-    }
-}
-
-void
 octave_link::do_about_to_exit (void)
 {
   event_queue_mutex->lock ();
 
-  while (! event_queue.empty ())
-    event_queue.pop ();
+  gui_event_queue.discard ();
 
   event_queue_mutex->unlock ();
 
   if (event_listener)
     event_listener->about_to_exit ();
 }
 
 std::string
 octave_link::do_last_working_directory (void)
 {
   return last_cwd;
 }
 
-void
-octave_link::handle_event (octave_event *, bool)
-{
-}
-
 bool
 octave_link::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
       instance = new octave_link ();
diff --git a/libgui/src/octave-adapter/octave-link.h b/libgui/src/octave-adapter/octave-link.h
--- a/libgui/src/octave-adapter/octave-link.h
+++ b/libgui/src/octave-adapter/octave-link.h
@@ -19,35 +19,34 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef OCTAVELINK_H
 #define OCTAVELINK_H
 
-#include <queue>
 #include <string>
 
 class octave_mutex;
 
+#include "event-queue.h"
+
 #include "octave-main-thread.h"
-#include "octave-event.h"
-#include "octave-event-observer.h"
 #include "octave-event-listener.h"
 
 // \class OctaveLink
 // \brief Provides threadsafe access to octave.
 // \author Jacob Dawid
 //
 // This class is a wrapper around octave and provides thread safety by
 // buffering access operations to octave and executing them in the
 // readline event hook, which lives in the octave thread.
 
-class octave_link : public octave_event_observer
+class octave_link
 {
 protected:
 
   octave_link (void);
 
 public:
 
   ~octave_link (void) { }
@@ -71,20 +70,35 @@ public:
   }
 
   static void process_events (void)
   {
     if (instance_ok ())
       instance->do_process_events ();
   }
 
-  static void post_event (octave_event *e)
+  template <class T>
+  static void post_event (T *obj, void (T::*method) (void))
   {
     if (instance_ok ())
-      instance->do_post_event (e);
+      instance->do_post_event (obj, method);
+  }
+
+  template <class T, class A>
+  static void post_event (T *obj, void (T::*method) (A), A arg)
+  {
+    if (instance_ok ())
+      instance->do_post_event (obj, method, arg);
+  }
+
+  template <class T, class A>
+  static void post_event (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    if (instance_ok ())
+      instance->do_post_event (obj, method, arg);
   }
 
   static void about_to_exit (void)
   {
     if (instance_ok ())
       instance->do_about_to_exit ();
   }
 
@@ -123,34 +137,49 @@ private:
   octave_event_listener *event_listener;
 
   // Thread running octave_main.
   octave_main_thread *main_thread;
 
   // Semaphore to lock access to the event queue.
   octave_mutex *event_queue_mutex;
 
-  // Buffer for queueing events until they will be processed.
-  std::queue <octave_event *> event_queue;
+  // Event Queue.
+  event_queue gui_event_queue;
 
   // Stores the last known current working directory of octave.
   std::string last_cwd;
 
   bool debugging;
 
   void do_launch_octave (void);
   void do_register_event_listener (octave_event_listener *oel);
 
   void do_generate_events (void);
   void do_process_events (void);
-  void do_post_event (octave_event *e);
+
+  template <class T>
+  void do_post_event (T *obj, void (T::*method) (void))
+  {
+    gui_event_queue.add_method (obj, method);
+  }
+
+  template <class T, class A>
+  void do_post_event (T *obj, void (T::*method) (A), A arg)
+  {
+    gui_event_queue.add_method (obj, method, arg);
+  }
+
+  template <class T, class A>
+  void do_post_event (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    gui_event_queue.add_method (obj, method, arg);
+  }
 
   void do_about_to_exit (void);
 
   void do_entered_readline_hook (void) { }
   void do_finished_readline_hook (void) { }
 
   std::string do_last_working_directory (void);
-
-  void handle_event (octave_event *e, bool accept);
 };
 
 #endif // OCTAVELINK_H
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -24,23 +24,24 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <QTreeWidget>
 #include <QTime>
 
 #include <list>
 
-#include <symtab.h>
+#include "symtab.h"
+#include "variables.h"
 
 #include "workspace-model.h"
 #include "octave-link.h"
 
 workspace_model::workspace_model(QObject *p)
-  : QAbstractItemModel (p), octave_event_observer ()
+  : QAbstractItemModel (p)
 {
   QList<QVariant> rootData;
   rootData << tr ("Name") << tr ("Class") << tr("Dimension") << tr ("Value");
   _rootItem = new tree_item(rootData);
 
   insert_top_level_item(0, new tree_item ("Local"));
   insert_top_level_item(1, new tree_item ("Global"));
   insert_top_level_item(2, new tree_item ("Persistent"));
@@ -58,78 +59,17 @@ workspace_model::workspace_model(QObject
 workspace_model::~workspace_model()
 {
   delete _rootItem;
 }
 
 void
 workspace_model::request_update_workspace ()
 {
-  octave_link::post_event (new octave_update_workspace_event (*this));
-}
-
-void
-workspace_model::handle_event (octave_event *e, bool accept)
-{
-  if (accept)
-    {
-      if (dynamic_cast <octave_update_workspace_event*> (e))
-        {
-          std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
-
-          _symbol_information.clear ();
-          for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
-               iterator != symbolTable.end (); iterator++)
-            _symbol_information.push_back (symbol_information (*iterator));
-
-          beginResetModel();
-          top_level_item (0)->delete_child_items ();
-          top_level_item (1)->delete_child_items ();
-          top_level_item (2)->delete_child_items ();
-
-          foreach (const symbol_information& s, _symbol_information)
-            {
-              tree_item *child = new tree_item ();
-
-              child->set_data (0, s.symbol ());
-              child->set_data (1, s.class_name ());
-              child->set_data (2, s.dimension ());
-              child->set_data (3, s.value ());
-
-              switch (s.scope ())
-                {
-                case symbol_information::local:
-                  top_level_item (0)->add_child (child);
-                  break;
-
-                case symbol_information::global:
-                  top_level_item (1)->add_child (child);
-                  break;
-
-                case symbol_information::persistent:
-                  top_level_item (2)->add_child (child);
-                  break;
-
-                default:
-                  break;
-                }
-            }
-
-          endResetModel();
-          emit model_changed();
-        }
-
-      // Post a new event in a given time.
-      // This prevents flooding the event queue when no events are being processed.
-      _update_workspace_model_timer.start ();
-    }
-  else
-    {
-      // octave_event::perform failed to process event.
-    }
+  octave_link::post_event (this, &workspace_model::update_workspace_callback);
 }
 
 QModelIndex
 workspace_model::index(int row, int column, const QModelIndex &p) const
 {
   if (!hasIndex(row, column, p))
     return QModelIndex();
 
@@ -231,8 +171,59 @@ workspace_model::data(const QModelIndex 
   if (role != Qt::DisplayRole)
     return QVariant();
 
   tree_item *item = static_cast<tree_item*>(idx.internalPointer());
 
   return item->data(idx.column());
 }
 
+void
+workspace_model::update_workspace_callback (void)
+{
+  std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
+
+  _symbol_information.clear ();
+  for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
+       iterator != symbolTable.end (); iterator++)
+    _symbol_information.push_back (symbol_information (*iterator));
+
+  beginResetModel();
+  top_level_item (0)->delete_child_items ();
+  top_level_item (1)->delete_child_items ();
+  top_level_item (2)->delete_child_items ();
+
+  foreach (const symbol_information& s, _symbol_information)
+    {
+      tree_item *child = new tree_item ();
+
+      child->set_data (0, s.symbol ());
+      child->set_data (1, s.class_name ());
+      child->set_data (2, s.dimension ());
+      child->set_data (3, s.value ());
+
+      switch (s.scope ())
+        {
+        case symbol_information::local:
+          top_level_item (0)->add_child (child);
+          break;
+
+        case symbol_information::global:
+          top_level_item (1)->add_child (child);
+          break;
+
+        case symbol_information::persistent:
+          top_level_item (2)->add_child (child);
+          break;
+
+        default:
+          break;
+        }
+    }
+
+  endResetModel();
+  emit model_changed();
+
+  // Post a new event in a given time.
+  // This prevents flooding the event queue when no events are being processed.
+  _update_workspace_model_timer.start ();
+}
+
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -25,17 +25,16 @@ along with Octave; see the file COPYING.
 
 // Qt includes
 #include <QAbstractItemModel>
 #include <QVector>
 #include <QSemaphore>
 #include <QTimer>
 
 #include "symbol-information.h"
-#include "octave-event-observer.h"
 
 class tree_item
 {
 public:
   tree_item (const QList<QVariant> &d, tree_item *p = 0) {
     _parent_item = p;
     _item_data = d;
   }
@@ -107,26 +106,24 @@ public:
 
 private:
   QList<tree_item*> _child_items;
   QList<QVariant> _item_data;
   tree_item *_parent_item;
 };
 
 class workspace_model
-  : public QAbstractItemModel, public octave_event_observer
+  : public QAbstractItemModel
 {
   Q_OBJECT
 
   public:
   workspace_model (QObject *parent = 0);
   ~workspace_model ();
 
-  void handle_event (octave_event *e, bool accept);
-
   QVariant data (const QModelIndex &index, int role) const;
   Qt::ItemFlags flags (const QModelIndex &index) const;
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
   QModelIndex index (int row, int column,
                      const QModelIndex &parent = QModelIndex ()) const;
   QModelIndex parent (const QModelIndex &index) const;
   int rowCount (const QModelIndex &parent = QModelIndex ()) const;
@@ -137,16 +134,19 @@ class workspace_model
 
 public slots:
   void request_update_workspace ();
 
 signals:
   void model_changed ();
 
 private:
+
+  void update_workspace_callback (void);
+
   /** Timer for periodically updating the workspace model from the current
    * symbol information. */
   QTimer _update_workspace_model_timer;
 
   /** Stores the current symbol information. */
   QList <symbol_information> _symbol_information;
   tree_item *_rootItem;
 };
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifndef WORKSPACEVIEW_H
 #define WORKSPACEVIEW_H
 
 #include <QDockWidget>
 #include <QTreeView>
 #include <QSemaphore>
-#include "octave-link.h"
+
 #include "workspace-model.h"
 
 class workspace_view : public QDockWidget
 {
   Q_OBJECT
   public:
   workspace_view (QWidget * parent = 0);
   ~workspace_view ();
diff --git a/libinterp/interp-core/action-container.h b/libinterp/interp-core/action-container.h
new file mode 100644
--- /dev/null
+++ b/libinterp/interp-core/action-container.h
@@ -0,0 +1,342 @@
+/*
+
+Copyright (C) 1993-2012 John W. Eaton
+Copyright (C) 2009-2010 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_action_container_h)
+#define octave_action_container_h 1
+
+// This class allows registering actions in a list for later
+// execution, either explicitly or when the container goes out of
+// scope.
+
+// FIXME -- is there a better name for this class?
+
+class
+OCTINTERP_API
+action_container
+{
+public:
+
+  // A generic unwind_protect element. Knows how to run itself and
+  // discard itself.  Also, contains a pointer to the next element.
+  class elem
+  {
+  public:
+    elem (void) { }
+
+    virtual void run (void) { }
+
+    virtual ~elem (void) { }
+
+    friend class action_container;
+
+  private:
+
+    // No copying!
+
+    elem (const elem&);
+
+    elem& operator = (const elem&);
+  };
+
+  // An element that merely runs a void (*)(void) function.
+
+  class fcn_elem : public elem
+  {
+  public:
+    fcn_elem (void (*fptr) (void))
+      : e_fptr (fptr) { }
+
+    void run (void) { e_fptr (); }
+
+  private:
+    void (*e_fptr) (void);
+  };
+
+  // An element that stores a variable of type T along with a void (*) (T)
+  // function pointer, and calls the function with the parameter.
+
+  template <class T>
+  class fcn_arg_elem : public elem
+  {
+  public:
+    fcn_arg_elem (void (*fcn) (T), T arg)
+      : e_fcn (fcn), e_arg (arg) { }
+
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+
+    // No copying!
+
+    fcn_arg_elem (const fcn_arg_elem&);
+
+    fcn_arg_elem& operator = (const fcn_arg_elem&);
+
+    void (*e_fcn) (T);
+    T e_arg;
+  };
+
+  // An element that stores a variable of type T along with a
+  // void (*) (const T&) function pointer, and calls the function with
+  // the parameter.
+
+  template <class T>
+  class fcn_crefarg_elem : public elem
+  {
+  public:
+    fcn_crefarg_elem (void (*fcn) (const T&), const T& arg)
+      : e_fcn (fcn), e_arg (arg) { }
+
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+    void (*e_fcn) (const T&);
+    T e_arg;
+  };
+
+  // An element for calling a member function.
+
+  template <class T>
+  class method_elem : public elem
+  {
+  public:
+    method_elem (T *obj, void (T::*method) (void))
+      : e_obj (obj), e_method (method) { }
+
+    void run (void) { (e_obj->*e_method) (); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (void);
+
+    // No copying!
+
+    method_elem (const method_elem&);
+
+    method_elem operator = (const method_elem&);
+  };
+
+  // An element for calling a member function with a single argument
+
+  template <class T, class A>
+  class method_arg_elem : public elem
+  {
+  public:
+    method_arg_elem (T *obj, void (T::*method) (A), A arg)
+      : e_obj (obj), e_method (method), e_arg (arg) { }
+
+    void run (void) { (e_obj->*e_method) (e_arg); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (A);
+    A e_arg;
+
+    // No copying!
+
+    method_arg_elem (const method_arg_elem&);
+
+    method_arg_elem operator = (const method_arg_elem&);
+  };
+
+  // An element for calling a member function with a single argument
+
+  template <class T, class A>
+  class method_crefarg_elem : public elem
+  {
+  public:
+    method_crefarg_elem (T *obj, void (T::*method) (const A&), const A& arg)
+      : e_obj (obj), e_method (method), e_arg (arg) { }
+
+    void run (void) { (e_obj->*e_method) (e_arg); }
+
+  private:
+
+    T *e_obj;
+    void (T::*e_method) (const A&);
+    A e_arg;
+
+    // No copying!
+
+    method_crefarg_elem (const method_crefarg_elem&);
+
+    method_crefarg_elem operator = (const method_crefarg_elem&);
+  };
+
+  // An element that stores arbitrary variable, and restores it.
+
+  template <class T>
+  class restore_var_elem : public elem
+  {
+  public:
+    restore_var_elem (T& ref, const T& val)
+      : e_ptr (&ref), e_val (val) { }
+
+    void run (void) { *e_ptr = e_val; }
+
+  private:
+
+    // No copying!
+
+    restore_var_elem (const restore_var_elem&);
+
+    restore_var_elem& operator = (const restore_var_elem&);
+
+    T *e_ptr, e_val;
+  };
+
+  // Deletes a class allocated using new.
+
+  template <class T>
+  class delete_ptr_elem : public elem
+  {
+  public:
+    delete_ptr_elem (T *ptr)
+      : e_ptr (ptr) { }
+
+    void run (void) { delete e_ptr; }
+
+  private:
+
+    T *e_ptr;
+
+    // No copying!
+
+    delete_ptr_elem (const delete_ptr_elem&);
+
+    delete_ptr_elem operator = (const delete_ptr_elem&);
+  };
+
+  action_container (void) { }
+
+  virtual ~action_container (void) { }
+
+  virtual void add (elem *new_elem) = 0;
+
+  // Call to void func (void).
+  void add_fcn (void (*fcn) (void))
+  {
+    add (new fcn_elem (fcn));
+  }
+
+  // Call to void func (T).
+  template <class T>
+  void add_fcn (void (*action) (T), T val)
+  {
+    add (new fcn_arg_elem<T> (action, val));
+  }
+
+  // Call to void func (const T&).
+  template <class T>
+  void add_fcn (void (*action) (const T&), const T& val)
+  {
+    add (new fcn_crefarg_elem<T> (action, val));
+  }
+
+  // Call to T::method (void).
+  template <class T>
+  void add_method (T *obj, void (T::*method) (void))
+  {
+    add (new method_elem<T> (obj, method));
+  }
+
+  // Call to T::method (A).
+  template <class T, class A>
+  void add_method (T *obj, void (T::*method) (A), A arg)
+  {
+    add (new method_arg_elem<T, A> (obj, method, arg));
+  }
+
+  // Call to T::method (const A&).
+  template <class T, class A>
+  void add_method (T *obj, void (T::*method) (const A&), const A& arg)
+  {
+    add (new method_crefarg_elem<T, A> (obj, method, arg));
+  }
+
+  // Call to delete (T*).
+
+  template <class T>
+  void add_delete (T *obj)
+  {
+    add (new delete_ptr_elem<T> (obj));
+  }
+
+  // Protect any variable.
+  template <class T>
+  void protect_var (T& var)
+  {
+    add (new restore_var_elem<T> (var, var));
+  }
+
+  // Protect any variable, value given.
+  template <class T>
+  void protect_var (T& var, const T& val)
+  {
+    add (new restore_var_elem<T> (var, val));
+  }
+
+  operator bool (void) const { return ! empty (); }
+
+  virtual void run_first (void) = 0;
+
+  void run (size_t num)
+  {
+    if (num > size ())
+      num = size ();
+
+    for (size_t i = 0; i < num; i++)
+      run_first ();
+  }
+
+  void run (void) { run (size ()); }
+
+  virtual void discard_first (void) = 0;
+
+  void discard (size_t num)
+  {
+    if (num > size ())
+      num = size ();
+
+    for (size_t i = 0; i < num; i++)
+      discard_first ();
+  }
+
+  void discard (void) { discard (size ()); }
+
+  virtual size_t size (void) const = 0;
+
+  bool empty (void) const { return size () == 0; }
+
+private:
+
+  // No copying!
+
+  action_container (const action_container&);
+
+  action_container& operator = (const action_container&);
+};
+
+#endif
diff --git a/libinterp/interp-core/defun-dld.h b/libinterp/interp-core/defun-dld.h
--- a/libinterp/interp-core/defun-dld.h
+++ b/libinterp/interp-core/defun-dld.h
@@ -52,20 +52,20 @@ along with Octave; see the file COPYING.
 // (the convention is to use a prefix of "G", so "foo" becomes "Gfoo").
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc) \
   DEFUNX_DLD_INTERNAL (name, fname, args_name, nargout_name, doc)
 
 #else
 
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
-  DECLARE_FUN (name, args_name, nargout_name); \
+  DECLARE_FUN_NO_DEFAULTS (name, args_name, nargout_name); \
   DEFINE_FUN_INSTALLER_FUN (name, doc) \
-  DECLARE_FUN (name, args_name, nargout_name)
+  DECLARE_FUN_NO_DEFAULTS (name, args_name, nargout_name)
 
 #define DEFUNX_DLD(name, fname, gname, args_name, nargout_name, doc) \
-  DECLARE_FUNX (fname, args_name, nargout_name); \
+  DECLARE_FUNX_NO_DEFAULTS (fname, args_name, nargout_name); \
   DEFINE_FUNX_INSTALLER_FUN (name, fname, gname, doc) \
-  DECLARE_FUNX (fname, args_name, nargout_name)
+  DECLARE_FUNX_NO_DEFAULTS (fname, args_name, nargout_name)
 
 #endif
 
 #endif
diff --git a/libinterp/interp-core/defun-int.h b/libinterp/interp-core/defun-int.h
--- a/libinterp/interp-core/defun-int.h
+++ b/libinterp/interp-core/defun-int.h
@@ -72,23 +72,33 @@ public:
 };
 
 extern OCTINTERP_API bool
 defun_isargout (int, int);
 
 extern OCTINTERP_API void
 defun_isargout (int, int, bool *);
 
+#define DECLARE_FUNXX(name, args_decl, nargout_decl) \
+  OCTAVE_EXPORT octave_value_list name (args_decl, nargout_decl)
+
 #define DECLARE_FUNX(name, args_name, nargout_name) \
-  OCTAVE_EXPORT octave_value_list \
-  name (const octave_value_list& args_name, int nargout_name)
+  DECLARE_FUNXX (name, \
+                 const octave_value_list& args_name = octave_value_list (), \
+                 int nargout_name = 0)
+
+#define DECLARE_FUNX_NO_DEFAULTS(name, args_name, nargout_name) \
+  DECLARE_FUNXX (name, const octave_value_list& args_name, int nargout_name)
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
+#define DECLARE_FUN_NO_DEFAULTS(name, args_name, nargout_name) \
+  DECLARE_FUNX_NO_DEFAULTS (F ## name, args_name, nargout_name)
+
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
 typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
 
 typedef octave_function * (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
 
diff --git a/libinterp/interp-core/event-queue.h b/libinterp/interp-core/event-queue.h
new file mode 100644
--- /dev/null
+++ b/libinterp/interp-core/event-queue.h
@@ -0,0 +1,126 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_event_queue_h)
+#define octave_event_queue_h 1
+
+#include <queue>
+#include <memory>
+
+#include "action-container.h"
+
+class
+OCTINTERP_API
+event_queue : public action_container
+{
+public:
+
+  event_queue (void) : fifo () { }
+
+  // Destructor should not raise an exception, so all actions
+  // registered should be exception-safe (but setting error_state is
+  // allowed). If you're not sure, see event_queue_safe.
+
+  ~event_queue (void) { run (); }
+
+  void add (elem *new_elem)
+  {
+    fifo.push (new_elem);
+  }
+
+  void run_first (void)
+  {
+    if (! empty ())
+      {
+        // No leak on exception!
+        std::auto_ptr<elem> ptr (fifo.front ());
+        fifo.pop ();
+        ptr->run ();
+      }
+  }
+
+  void discard_first (void)
+  {
+    if (! empty ())
+      {
+        elem *ptr = fifo.front ();
+        fifo.pop ();
+        delete ptr;
+      }
+  }
+
+  size_t size (void) const { return fifo.size (); }
+
+protected:
+
+  std::queue<elem *> fifo;
+
+private:
+
+  // No copying!
+
+  event_queue (const event_queue&);
+
+  event_queue& operator = (const event_queue&);
+};
+
+// Like event_queue, but this one will guard against the
+// possibility of seeing an exception (or interrupt) in the cleanup
+// actions. Not that we can do much about it, but at least we won't
+// crash.
+
+class
+event_queue_safe : public event_queue
+{
+private:
+
+  static void gripe_exception (void);
+
+public:
+
+  event_queue_safe (void) : event_queue () { }
+
+  ~event_queue_safe (void)
+    {
+      while (! empty ())
+        {
+          try
+            {
+              run_first ();
+            }
+          catch (...) // Yes, the black hole. Remember we're in a dtor.
+            {
+              gripe_exception ();
+            }
+        }
+    }
+
+private:
+
+  // No copying!
+
+  event_queue_safe (const event_queue_safe&);
+
+  event_queue_safe& operator = (const event_queue_safe&);
+};
+
+#endif
diff --git a/libinterp/interp-core/module.mk b/libinterp/interp-core/module.mk
--- a/libinterp/interp-core/module.mk
+++ b/libinterp/interp-core/module.mk
@@ -7,23 +7,25 @@ EXTRA_DIST += \
 JIT_INC = \
   interp-core/jit-util.h \
   interp-core/jit-typeinfo.h \
   interp-core/jit-ir.h \
   interp-core/pt-jit.h
 
 INTERP_CORE_INC = \
   interp-core/Cell.h \
+  interp-core/action-container.h \
   interp-core/c-file-ptr-stream.h \
   interp-core/comment-list.h \
   interp-core/cutils.h \
   interp-core/defun-dld.h \
   interp-core/defun-int.h \
   interp-core/display.h \
   interp-core/dynamic-ld.h \
+  interp-core/event-queue.h \
   interp-core/gl-render.h \
   interp-core/gl2ps-renderer.h \
   interp-core/gl2ps.h \
   interp-core/gripes.h \
   interp-core/ls-ascii-helper.h \
   interp-core/ls-hdf5.h \
   interp-core/ls-mat-ascii.h \
   interp-core/ls-mat4.h \
diff --git a/libinterp/interp-core/unwind-prot.cc b/libinterp/interp-core/unwind-prot.cc
--- a/libinterp/interp-core/unwind-prot.cc
+++ b/libinterp/interp-core/unwind-prot.cc
@@ -20,20 +20,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cstddef>
-#include <cstring>
-
 #include "error.h"
 #include "unwind-prot.h"
-#include "utils.h"
 
 void unwind_protect_safe::gripe_exception (void)
 {
   // FIXME: can this throw an exception?
   error ("internal: unhandled exception in unwind_protect handler");
 }
diff --git a/libinterp/interp-core/unwind-prot.h b/libinterp/interp-core/unwind-prot.h
--- a/libinterp/interp-core/unwind-prot.h
+++ b/libinterp/interp-core/unwind-prot.h
@@ -19,326 +19,125 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_unwind_prot_h)
 #define octave_unwind_prot_h 1
 
-#include <cstddef>
-
-#include <string>
+#include <stack>
 #include <memory>
 
-// This class allows registering cleanup actions.
+#include "action-container.h"
+
 class
 OCTINTERP_API
-unwind_protect
+unwind_protect : public action_container
 {
 public:
 
-  // A generic unwind_protect element. Knows how to run itself and discard itself.
-  // Also, contains a pointer to the next element.
-  class elem
-  {
-    elem *next;
-
-  public:
-    elem (void) : next (0) { }
-
-    virtual void run (void) { }
-
-    virtual ~elem (void) { }
-
-    friend class unwind_protect;
-
-  private:
-
-    // No copying!
-
-    elem (const elem&);
-
-    elem& operator = (const elem&);
-  };
-
-  // An element that merely runs a void (*)(void) function.
-
-  class fcn_elem : public elem
-  {
-  public:
-    fcn_elem (void (*fptr) (void))
-      : e_fptr (fptr) { }
+  unwind_protect (void) : lifo () { }
 
-    void run (void) { e_fptr (); }
-
-  private:
-    void (*e_fptr) (void);
-  };
-
-  // An element that stores a variable of type T along with a void (*) (T)
-  // function pointer, and calls the function with the parameter.
-
-  template <class T>
-  class fcn_arg_elem : public elem
-  {
-  public:
-    fcn_arg_elem (void (*fcn) (T), T arg)
-      : e_fcn (fcn), e_arg (arg) { }
+  // Destructor should not raise an exception, so all actions
+  // registered should be exception-safe (but setting error_state is
+  // allowed). If you're not sure, see unwind_protect_safe.
 
-    void run (void) { e_fcn (e_arg); }
-
-  private:
-
-    // No copying!
-
-    fcn_arg_elem (const fcn_arg_elem&);
-
-    fcn_arg_elem& operator = (const fcn_arg_elem&);
-
-    void (*e_fcn) (T);
-    T e_arg;
-  };
-
-  // An element that stores a variable of type T along with a void (*) (const T&)
-  // function pointer, and calls the function with the parameter.
+  ~unwind_protect (void) { run (); }
 
-  template <class T>
-  class fcn_crefarg_elem : public elem
+  virtual void add (elem *new_elem)
   {
-  public:
-    fcn_crefarg_elem (void (*fcn) (const T&), T arg)
-      : e_fcn (fcn), e_arg (arg) { }
-
-    void run (void) { e_fcn (e_arg); }
-
-  private:
-    void (*e_fcn) (const T&);
-    T e_arg;
-  };
-
-  // An element for calling a member function.
-
-  template <class T>
-  class method_elem : public elem
-  {
-  public:
-    method_elem (T *obj, void (T::*method) (void))
-      : e_obj (obj), e_method (method) { }
-
-    void run (void) { (e_obj->*e_method) (); }
-
-  private:
-
-    T *e_obj;
-    void (T::*e_method) (void);
-
-    // No copying!
-
-    method_elem (const method_elem&);
+    lifo.push (new_elem);
+  }
 
-    method_elem operator = (const method_elem&);
-  };
-
-  // An element that stores arbitrary variable, and restores it.
-
-  template <class T>
-  class restore_var_elem : public elem
+  void add (void (*fcn) (void *), void *ptr = 0) GCC_ATTR_DEPRECATED
   {
-  public:
-    restore_var_elem (T& ref, const T& val)
-      : e_ptr (&ref), e_val (val) { }
-
-    void run (void) { *e_ptr = e_val; }
-
-  private:
+    add (new fcn_arg_elem<void *> (fcn, ptr));
+  }
 
-    // No copying!
-
-    restore_var_elem (const restore_var_elem&);
-
-    restore_var_elem& operator = (const restore_var_elem&);
-
-    T *e_ptr, e_val;
-  };
+  operator bool (void) const { return ! empty (); }
 
-  // Deletes a class allocated using new.
-
-  template <class T>
-  class delete_ptr_elem : public elem
-  {
-  public:
-    delete_ptr_elem (T *ptr)
-      : e_ptr (ptr) { }
+  void run_top (void) GCC_ATTR_DEPRECATED { run_first (); }
 
-    void run (void) { delete e_ptr; }
-
-  private:
-
-    T *e_ptr;
-
-    // No copying!
-
-    delete_ptr_elem (const delete_ptr_elem&);
-
-    delete_ptr_elem operator = (const delete_ptr_elem&);
-  };
-
-  unwind_protect (void) : head () { }
-
-  void add (elem *new_elem)
-    {
-      new_elem->next = head;
-      head = new_elem;
-    }
-
-  // For backward compatibility.
-  void add (void (*fcn) (void *), void *ptr = 0)
-    {
-      add (new fcn_arg_elem<void *> (fcn, ptr));
-    }
+  void run_first (void)
+  {
+    if (! empty ())
+      {
+        // No leak on exception!
+        std::auto_ptr<elem> ptr (lifo.top ());
+        lifo.pop ();
+        ptr->run ();
+      }
+  }
 
-  // Call to void func (void).
-  void add_fcn (void (*fcn) (void))
-    {
-      add (new fcn_elem (fcn));
-    }
-
-  // Call to void func (T).
-  template <class T>
-  void add_fcn (void (*action) (T), T val)
-    {
-      add (new fcn_arg_elem<T> (action, val));
-    }
+  void run_top (int num) GCC_ATTR_DEPRECATED { run (num); }
 
-  // Call to void func (const T&).
-  template <class T>
-  void add_fcn (void (*action) (const T&), T val)
-    {
-      add (new fcn_crefarg_elem<T> (action, val));
-    }
-
-  // Call to T::method (void).
-  template <class T>
-  void add_method (T *obj, void (T::*method) (void))
-    {
-      add (new method_elem<T> (obj, method));
-    }
-
-  // Call to delete (T*).
-
-  template <class T>
-  void add_delete (T *obj)
-    {
-      add (new delete_ptr_elem<T> (obj));
-    }
+  void discard_top (void) GCC_ATTR_DEPRECATED { discard_first (); }
 
-  // Protect any variable.
-  template <class T>
-  void protect_var (T& var)
-    {
-      add (new restore_var_elem<T> (var, var));
-    }
-
-  // Protect any variable, value given.
-  template <class T>
-  void protect_var (T& var, const T& val)
-    {
-      add (new restore_var_elem<T> (var, val));
-    }
-
-  operator bool (void) const
-    {
-      return head != 0;
-    }
-
-  void run_top (void)
-    {
-      if (head)
-        {
-          // No leak on exception!
-          std::auto_ptr<elem> ptr (head);
-          head = ptr->next;
-          ptr->run ();
-        }
-    }
-
-  void run_top (int num)
-    {
-      while (num-- > 0)
-        run_top ();
-    }
+  void discard_first (void)
+  {
+    if (! empty ())
+      {
+        elem *ptr = lifo.top ();
+        lifo.pop ();
+        delete ptr;
+      }
+  }
 
-  void discard_top (void)
-    {
-      if (head)
-        {
-          elem *ptr = head;
-          head = ptr->next;
-          delete ptr;
-        }
-    }
+  void discard_top (int num) GCC_ATTR_DEPRECATED { discard (num); }
 
-  void discard_top (int num)
-    {
-      while (num-- > 0)
-        discard_top ();
-    }
+  size_t size (void) const { return lifo.size (); }
 
-  void run (void)
-    {
-      while (head)
-        run_top ();
-    }
+protected:
 
-  void discard (void)
-    {
-      while (head)
-        discard_top ();
-    }
-
-  // Destructor should not raise an exception, so all actions registered should
-  // be exception-safe (but setting error_state is allowed). If you're not sure,
-  // see unwind_protect_safe.
-  ~unwind_protect (void)
-    {
-      run ();
-    }
+  std::stack<elem *> lifo;
 
 private:
 
-  elem *head;
-
   // No copying!
 
   unwind_protect (const unwind_protect&);
 
   unwind_protect& operator = (const unwind_protect&);
 };
 
-// Like unwind_protect, but this one will guard against the possibility of seeing
-// an exception (or interrupt) in the cleanup actions. Not that we can do much about
-// it, but at least we won't crash.
+// Like unwind_protect, but this one will guard against the
+// possibility of seeing an exception (or interrupt) in the cleanup
+// actions. Not that we can do much about it, but at least we won't
+// crash.
 
 class
 OCTINTERP_API
 unwind_protect_safe : public unwind_protect
 {
+private:
+
   static void gripe_exception (void);
 
 public:
+
+  unwind_protect_safe (void) : unwind_protect () { }
+
   ~unwind_protect_safe (void)
     {
-      while (*this)
+      while (! empty ())
         {
           try
             {
-              run_top ();
+              run_first ();
             }
           catch (...) // Yes, the black hole. Remember we're in a dtor.
             {
               gripe_exception ();
             }
         }
     }
+
+private:
+
+  // No copying!
+
+  unwind_protect_safe (const unwind_protect_safe&);
+
+  unwind_protect_safe& operator = (const unwind_protect_safe&);
 };
 
 #endif
diff --git a/libinterp/interpfcn/debug.cc b/libinterp/interpfcn/debug.cc
--- a/libinterp/interpfcn/debug.cc
+++ b/libinterp/interpfcn/debug.cc
@@ -1196,16 +1196,27 @@ execution to continue until the current 
   else
     error ("dbstep: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
+void
+debug_step (const std::string& what)
+{
+  octave_value_list args;
+
+  if (! what.empty ())
+    args(0) = what;
+
+  Fdbstep (args);
+}
+
 DEFUN (dbcont, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont\n\
 Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
@@ -1220,16 +1231,22 @@ Leave command-line debugging mode and co
         print_usage ();
     }
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
+void
+debug_continue (void)
+{
+  Fdbcont ();
+}
+
 DEFUN (dbquit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbquit\n\
 Quit debugging mode immediately without further code execution and\n\
 return to the Octave prompt.\n\
 @seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
@@ -1247,16 +1264,22 @@ return to the Octave prompt.\n\
         print_usage ();
     }
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
+void
+debug_quit (void)
+{
+  Fdbquit ();
+}
+
 DEFUN (isdebugmode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/interpfcn/debug.h b/libinterp/interpfcn/debug.h
--- a/libinterp/interpfcn/debug.h
+++ b/libinterp/interpfcn/debug.h
@@ -124,11 +124,17 @@ private:
 
   void do_remove_all_breakpoints (void);
 
   fname_line_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
 
-std::string get_file_line (const std::string& fname, size_t line);
+extern std::string get_file_line (const std::string& fname, size_t line);
+
+extern void OCTINTERP_API debug_continue (void);
+
+extern void OCTINTERP_API debug_step (const std::string& what = std::string ());
+
+extern void OCTINTERP_API debug_quit (void);
 
 #endif
diff --git a/libinterp/interpfcn/load-save.cc b/libinterp/interpfcn/load-save.cc
--- a/libinterp/interpfcn/load-save.cc
+++ b/libinterp/interpfcn/load-save.cc
@@ -1438,16 +1438,26 @@ dump_octave_core (void)
                 }
               else
                 warning ("unable to open `%s' for writing...", fname);
             }
         }
     }
 }
 
+void
+load_workspace (const std::string& file)
+{
+  octave_value_list args;
+
+  if (! file.empty ())
+    args(0) = file;
+
+  Fload (args);
+}
 
 DEFUN (save, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} save file\n\
 @deftypefnx {Command} {} save options file\n\
 @deftypefnx {Command} {} save options file @var{v1} @var{v2} @dots{}\n\
 @deftypefnx {Command} {} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
@@ -1740,16 +1750,27 @@ the file @file{data} in Octave's binary 
                 }
             }
         }
     }
 
   return retval;
 }
 
+void
+save_workspace (const std::string& file)
+{
+  octave_value_list args;
+
+  if (! file.empty ())
+    args(0) = file;
+
+  Fsave (args);
+}
+
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-workspace\" if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
diff --git a/libinterp/interpfcn/load-save.h b/libinterp/interpfcn/load-save.h
--- a/libinterp/interpfcn/load-save.h
+++ b/libinterp/interpfcn/load-save.h
@@ -82,9 +82,12 @@ do_load (std::istream& stream, const std
 
 extern void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
+extern OCTINTERP_API void load_workspace (const std::string& file);
+extern OCTINTERP_API void save_workspace (const std::string& file);
+
 #endif
diff --git a/libinterp/interpfcn/variables.cc b/libinterp/interpfcn/variables.cc
--- a/libinterp/interpfcn/variables.cc
+++ b/libinterp/interpfcn/variables.cc
@@ -2335,18 +2335,18 @@ without the dash as well.\n\
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
   if (! error_state)
     {
       if (argc == 1)
         {
-          do_clear_globals (argv, argc, 1);
-          do_clear_variables (argv, argc, 1);
+          do_clear_globals (argv, argc, true);
+          do_clear_variables (argv, argc, true);
         }
       else
         {
           int idx = 0;
 
           bool clear_all = false;
           bool clear_functions = false;
           bool clear_globals = false;
@@ -2455,16 +2455,22 @@ without the dash as well.\n\
                 }
             }
         }
     }
 
   return retval;
 }
 
+void
+clear_current_scope (void)
+{
+  Fclear ();
+}
+
 DEFUN (whos_line_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} whos_line_format (@var{new_val}, \"local\")\n\
 Query or set the format string used by the command @code{whos}.\n\
 \n\
 A full format string is:\n\
diff --git a/libinterp/interpfcn/variables.h b/libinterp/interpfcn/variables.h
--- a/libinterp/interpfcn/variables.h
+++ b/libinterp/interpfcn/variables.h
@@ -143,9 +143,12 @@ extern OCTINTERP_API void munlock (const
 extern OCTINTERP_API bool mislocked (const std::string&);
 
 extern OCTINTERP_API void clear_function (const std::string& nm);
 extern OCTINTERP_API void clear_variable (const std::string& nm);
 extern OCTINTERP_API void clear_symbol (const std::string& nm);
 
 extern OCTINTERP_API void maybe_missing_function_hook (const std::string& name);
 
+// Equivalent to Fclear without any arguments.
+extern OCTINTERP_API void clear_current_scope (void);
+
 #endif
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -64,16 +64,18 @@ public:
   void do_process_histcontrol (const std::string&);
 
   std::string do_histcontrol (void) const;
 
   void do_add (const std::string&);
 
   void do_remove (int);
 
+  void do_clear (void);
+
   int do_where (void) const;
 
   int do_length (void) const;
 
   int do_max_input_history (void) const;
 
   int do_base (void) const;
 
@@ -196,16 +198,22 @@ gnu_history::do_add (const std::string& 
 }
 
 void
 gnu_history::do_remove (int n)
 {
   ::octave_remove_history (n);
 }
 
+void
+gnu_history::do_clear (void)
+{
+  ::octave_clear_history ();
+}
+
 int
 gnu_history::do_where (void) const
 {
   return ::octave_where_history ();
 }
 
 int
 gnu_history::do_length (void) const
@@ -582,16 +590,23 @@ command_history::add (const std::string&
 
 void
 command_history::remove (int n)
 {
   if (instance_ok ())
     instance->do_remove (n);
 }
 
+void
+command_history::clear (void)
+{
+  if (instance_ok ())
+    instance->do_clear ();
+}
+
 int
 command_history::where (void)
 {
   return (instance_ok ())
     ? instance->do_where () : 0;
 }
 
 int
@@ -802,16 +817,21 @@ command_history::do_add (const std::stri
 {
 }
 
 void
 command_history::do_remove (int)
 {
 }
 
+void
+command_history::do_clear (void)
+{
+}
+
 int
 command_history::do_where (void) const
 {
   return 0;
 }
 
 int
 command_history::do_length (void) const
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -60,16 +60,18 @@ public:
   static void ignore_entries (bool = true);
 
   static bool ignoring_entries (void);
 
   static void add (const std::string&);
 
   static void remove (int);
 
+  static void clear (void);
+
   static int where (void);
 
   static int length (void);
 
   static int max_input_history (void);
 
   static int base (void);
 
@@ -153,16 +155,18 @@ protected:
   virtual void do_ignore_entries (bool);
 
   virtual bool do_ignoring_entries (void) const;
 
   virtual void do_add (const std::string&);
 
   virtual void do_remove (int);
 
+  virtual void do_clear (void);
+
   virtual int do_where (void) const;
 
   virtual int do_length (void) const;
 
   virtual int do_max_input_history (void) const;
 
   virtual int do_base (void) const;
 
diff --git a/liboctave/util/oct-rl-hist.c b/liboctave/util/oct-rl-hist.c
--- a/liboctave/util/oct-rl-hist.c
+++ b/liboctave/util/oct-rl-hist.c
@@ -205,16 +205,22 @@ octave_remove_history (int n)
     {
       if (discard->line)
         free (discard->line);
 
       free (discard);
     }
 }
 
+void
+octave_clear_history (void)
+{
+  clear_history ();
+}
+
 char *
 octave_history_goto_mark (int n)
 {
   HIST_ENTRY *h;
 
   char *retval = 0;
 
   if (history_set_pos (n))
diff --git a/liboctave/util/oct-rl-hist.h b/liboctave/util/oct-rl-hist.h
--- a/liboctave/util/oct-rl-hist.h
+++ b/liboctave/util/oct-rl-hist.h
@@ -61,16 +61,18 @@ extern int octave_read_history_range (co
 extern int octave_write_history (const char *);
 
 extern int octave_append_history (int, const char *);
 
 extern int octave_history_truncate_file (const char *, int);
 
 extern void octave_remove_history (int);
 
+extern void octave_clear_history (void);
+
 extern char *octave_history_goto_mark (int n);
 
 extern char *octave_history_get (int n);
 
 extern char **octave_history_list (int, int);
 
 extern void octave_replace_history_entry (int, const char *);
 
