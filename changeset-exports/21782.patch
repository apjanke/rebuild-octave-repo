# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1464209476 14400
#      Wed May 25 16:51:16 2016 -0400
# Node ID 2aef506f3fecaa0a2b96461fb22df4bec3ebe00e
# Parent  da4554d2342da99739a49378d70e73a1ff128431
use namespace for lo-mappers.h functions

* lo-mappers.h, lo-mappers.cc (acos, arg, asin, atan, ceil, conj,
copysign, exp2, finite, fix, floor, imag, is_NA, is_NaN_or_NA, isinf,
isinteger, isnan, log2, max, min, mod, negative_sign, nint, nint_big,
positive_sign, rc_acos, rc_acosh, rc_asin, rc_atanh, rc_log, rc_log10,
rc_log2, rc_sqrt, real, rem, round, roundb, signbit, signum, trunc,
x_nint): Define in octave::math namespace.  Deprecate old names.
Change all uses.
* oct-inttypes.h: Put round and isnan functions in octave::math
namespace and rename from xround and xisnan.  Change all uses.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -281,17 +281,17 @@ Creates an integer variable from VAL.")
     }
 
   octave_value retval;
 
   if (args.length () == 1)
     {
       double d = args(0).double_value ();
 
-      retval = octave_value (new octave_integer (NINT (d)));
+      retval = octave_value (new octave_integer (octave::math::nint (d)));
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (doit, args, ,
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -79,18 +79,18 @@ void
 BaseControl::init (QWidget* w, bool callBase)
 {
   if (callBase)
     Object::init (w, callBase);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   Matrix bb = up.get_boundingbox (false);
-  w->setGeometry (xround (bb(0)), xround (bb(1)),
-                  xround (bb(2)), xround (bb(3)));
+  w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                  octave::math::round (bb(2)), octave::math::round (bb(3)));
   w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
   updatePalette (up, w);
   w->setEnabled (up.enable_is ("on"));
   w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
   w->setVisible (up.is_visible ());
   m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
 
   w->installEventFilter (this);
@@ -108,18 +108,18 @@ BaseControl::update (int pId)
   uicontrol::properties& up = properties<uicontrol> ();
   QWidget* w = qWidget<QWidget> ();
 
    switch (pId)
     {
     case uicontrol::properties::ID_POSITION:
         {
           Matrix bb = up.get_boundingbox (false);
-          w->setGeometry (xround (bb(0)), xround (bb(1)),
-                          xround (bb(2)), xround (bb(3)));
+          w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                          octave::math::round (bb(2)), octave::math::round (bb(3)));
         }
       break;
 
     case uicontrol::properties::ID_FONTNAME:
     case uicontrol::properties::ID_FONTSIZE:
     case uicontrol::properties::ID_FONTWEIGHT:
     case uicontrol::properties::ID_FONTANGLE:
       w->setFont (Utils::computeFont<uicontrol> (up));
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -87,18 +87,18 @@ Container::resizeEvent (QResizeEvent* /*
         {
           Object* obj = Object::fromQObject (qObj);
 
           if (obj)
             {
               Matrix bb = obj->properties ().get_boundingbox (false);
 
               obj->qWidget<QWidget> ()
-                ->setGeometry (xround (bb(0)), xround (bb(1)),
-                               xround (bb(2)), xround (bb(3)));
+                ->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                               octave::math::round (bb(2)), octave::math::round (bb(3)));
             }
         }
     }
 }
 
 void
 Container::childEvent (QChildEvent* xevent)
 {
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -71,18 +71,18 @@ ContextMenu::update (int pId)
     {
     case base_properties::ID_VISIBLE:
       if (up.is_visible ())
         {
           Matrix pos = up.get_position ().matrix_value ();
           QWidget* parentW = xmenu->parentWidget ();
           QPoint pt;
 
-          pt.rx () = xround (pos(0));
-          pt.ry () = parentW->height () - xround (pos(1));
+          pt.rx () = octave::math::round (pos(0));
+          pt.ry () = parentW->height () - octave::math::round (pos(1));
           pt = parentW->mapToGlobal (pt);
 
           xmenu->popup (pt);
         }
       else
         xmenu->hide ();
       break;
     default:
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -103,18 +103,18 @@ hasUiMenuChildren (const figure::propert
 
 static QRect
 boundingBoxToRect (const Matrix& bb)
 {
   QRect r;
 
   if (bb.numel () == 4)
     {
-      r = QRect (xround (bb(0)), xround (bb(1)),
-                 xround (bb(2)), xround (bb(3)));
+      r = QRect (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                 octave::math::round (bb(2)), octave::math::round (bb(3)));
       if (! r.isValid ())
         r = QRect ();
     }
 
   return r;
 }
 
 Figure*
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -38,17 +38,17 @@ updateSelection (QListWidget* list, cons
 {
   octave_idx_type n = value.numel ();
   int lc = list->count ();
 
   list->clearSelection ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
-      int idx = xround (value(i));
+      int idx = octave::math::round (value(i));
 
       if (1 <= idx && idx <= lc)
         {
           list->item (idx-1)->setSelected (true);
           list->scrollToItem (list->item (idx-1));
           if (i == 0
               && list->selectionMode () == QAbstractItemView::SingleSelection)
             break;
@@ -91,17 +91,17 @@ ListBoxControl::ListBoxControl (const gr
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       octave_idx_type n = value.numel ();
       int lc = list->count ();
 
       for (octave_idx_type i = 0; i < n; i++)
         {
-          int idx = xround (value(i));
+          int idx = octave::math::round (value(i));
 
           if (1 <= idx && idx <= lc)
             {
               list->item (idx-1)->setSelected (true);
               list->scrollToItem (list->item (idx-1));
               if (i == 0 && (list->selectionMode ()
                              == QAbstractItemView::SingleSelection))
                 break;
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -71,17 +71,17 @@ setupPalette (const uipanel::properties&
 
 static int
 borderWidthFromProperties (const uipanel::properties& pp)
 {
   int bw = 0;
 
   if (! pp.bordertype_is ("none"))
     {
-      bw = xround (pp.get_borderwidth ());
+      bw = octave::math::round (pp.get_borderwidth ());
       if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
         bw *= 2;
     }
 
   return bw;
 }
 
 Panel*
@@ -103,20 +103,20 @@ Panel::create (const graphics_object& go
 Panel::Panel (const graphics_object& go, QFrame* frame)
   : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
 {
   uipanel::properties& pp = properties<uipanel> ();
 
   frame->setObjectName ("UIPanel");
   frame->setAutoFillBackground (true);
   Matrix bb = pp.get_boundingbox (false);
-  frame->setGeometry (xround (bb(0)), xround (bb(1)),
-                      xround (bb(2)), xround (bb(3)));
+  frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                      octave::math::round (bb(2)), octave::math::round (bb(3)));
   frame->setFrameStyle (frameStyleFromProperties (pp));
-  frame->setLineWidth (xround (pp.get_borderwidth ()));
+  frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
   QPalette pal = frame->palette ();
   setupPalette (pp, pal);
   frame->setPalette (pal);
 
   m_container = new Container (frame);
   m_container->canvas (m_handle);
 
   if (frame->hasMouseTracking ())
@@ -231,24 +231,24 @@ Panel::update (int pId)
   m_blockUpdates = true;
 
   switch (pId)
     {
     case uipanel::properties::ID_POSITION:
       {
         Matrix bb = pp.get_boundingbox (false);
 
-        frame->setGeometry (xround (bb(0)), xround (bb(1)),
-                            xround (bb(2)), xround (bb(3)));
+        frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                            octave::math::round (bb(2)), octave::math::round (bb(3)));
         updateLayout ();
       }
       break;
 
     case uipanel::properties::ID_BORDERWIDTH:
-      frame->setLineWidth (xround (pp.get_borderwidth ()));
+      frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
       updateLayout ();
       break;
 
     case uipanel::properties::ID_BACKGROUNDCOLOR:
     case uipanel::properties::ID_FOREGROUNDCOLOR:
     case uipanel::properties::ID_HIGHLIGHTCOLOR:
     case uipanel::properties::ID_SHADOWCOLOR:
       {
@@ -340,20 +340,20 @@ void
 Panel::updateLayout (void)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   Matrix bb = pp.get_boundingbox (true);
   int bw = borderWidthFromProperties (pp);
 
-  frame->setFrameRect (QRect (xround (bb(0)) - bw, xround (bb(1)) - bw,
-                              xround (bb(2)) + 2*bw, xround (bb(3)) + 2*bw));
-  m_container->setGeometry (xround (bb(0)), xround (bb(1)),
-                            xround (bb(2)), xround (bb(3)));
+  frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw, octave::math::round (bb(1)) - bw,
+                              octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
+  m_container->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                            octave::math::round (bb(2)), octave::math::round (bb(3)));
 
   if (m_blockUpdates)
     pp.update_boundingbox ();
 
   if (m_title)
     {
       QSize sz = m_title->sizeHint ();
       int offset = 5;
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -308,41 +308,41 @@ makeImageFromCData (const octave_value& 
           FloatNDArray f = v.float_array_value ();
 
           for (int i = 0; i < w; i++)
             for (int j = 0; j < h; j++)
               {
                 float r = f(j, i, 0);
                 float g = f(j, i, 1);
                 float b = f(j, i, 2);
-                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+                int a = (octave::math::isnan (r) || octave::math::isnan (g) || octave::math::isnan (b) ? 0 : 255);
 
                 img.setPixel (x_off + i, y_off + j,
-                              qRgba (xround (r * 255),
-                                     xround (g * 255),
-                                     xround (b * 255),
+                              qRgba (octave::math::round (r * 255),
+                                     octave::math::round (g * 255),
+                                     octave::math::round (b * 255),
                                      a));
               }
         }
       else if (v.is_real_type ())
         {
           NDArray d = v.array_value ();
 
           for (int i = 0; i < w; i++)
             for (int j = 0; j < h; j++)
               {
                 double r = d(j, i, 0);
                 double g = d(j, i, 1);
                 double b = d(j, i, 2);
-                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+                int a = (octave::math::isnan (r) || octave::math::isnan (g) || octave::math::isnan (b) ? 0 : 255);
 
                 img.setPixel (x_off + i, y_off + j,
-                              qRgba (xround (r * 255),
-                                     xround (g * 255),
-                                     xround (b * 255),
+                              qRgba (octave::math::round (r * 255),
+                                     octave::math::round (g * 255),
+                                     octave::math::round (b * 255),
                                      a));
               }
         }
 
       return img;
     }
 
   return QImage ();
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -58,24 +58,24 @@ SliderControl::SliderControl (const grap
   uicontrol::properties& up = properties<uicontrol> ();
 
   slider->setTracking (false);
   Matrix bb = up.get_boundingbox ();
   slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
   Matrix steps = up.get_sliderstep ().matrix_value ();
   slider->setMinimum (0);
   slider->setMaximum (RANGE_INT_MAX);
-  slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
-  slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
+  slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
+  slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       double dmin = up.get_min (), dmax = up.get_max ();
 
-      slider->setValue (xround (((value(0) - dmin) / (dmax - dmin))
+      slider->setValue (octave::math::round (((value(0) - dmin) / (dmax - dmin))
                                 * RANGE_INT_MAX));
     }
 
   connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
 }
 
 SliderControl::~SliderControl (void)
 {
@@ -88,29 +88,29 @@ SliderControl::update (int pId)
   QScrollBar* slider = qWidget<QScrollBar> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_SLIDERSTEP:
       {
         Matrix steps = up.get_sliderstep ().matrix_value ();
 
-        slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
-        slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
+        slider->setSingleStep (octave::math::round (steps(0) * RANGE_INT_MAX));
+        slider->setPageStep (octave::math::round (steps(1) * RANGE_INT_MAX));
       }
       break;
 
     case uicontrol::properties::ID_VALUE:
       {
         Matrix value = up.get_value ().matrix_value ();
         double dmax = up.get_max (), dmin = up.get_min ();
 
         if (value.numel () > 0)
           {
-            int ival = xround (((value(0) - dmin) / (dmax - dmin))
+            int ival = octave::math::round (((value(0) - dmin) / (dmax - dmin))
                                * RANGE_INT_MAX);
 
             m_blockUpdates = true;
             slider->setValue (ival);
             m_blockUpdates = false;
           }
       }
       break;
@@ -132,17 +132,17 @@ SliderControl::valueChanged (int ival)
       if (go.valid_object ())
         {
           uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
           Matrix value = up.get_value ().matrix_value ();
           double dmin = up.get_min (), dmax = up.get_max ();
 
           int ival_tmp = (value.numel () > 0 ?
-                          xround (((value(0) - dmin) / (dmax - dmin))
+                          octave::math::round (((value(0) - dmin) / (dmax - dmin))
                                   * RANGE_INT_MAX) :
                           0);
 
           if (ival != ival_tmp || value.numel () > 0)
             {
               double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
 
               gh_manager::post_set (m_handle, "value", octave_value (dval));
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -147,17 +147,17 @@ drawcn (const RowVector& X, const RowVec
       pt[0] = start_edge;
       pt[1] = (pt[0] + 1) % 4;
 
       // Calculate contour segment start if first of contour.
       if (first)
         {
           tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
 
-          if (xisnan (tmp))
+          if (octave::math::isnan (tmp))
             ct_x = ct_y = 0.5;
           else
             {
               ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
               ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
             }
 
           start_contour (lvl, ct_x, ct_y);
@@ -176,17 +176,17 @@ drawcn (const RowVector& X, const RowVec
           if (static_cast<char> (1 << stop_edge) & id)
             break;
         }
 
       pt[0] = stop_edge;
       pt[1] = (pt[0] + 1) % 4;
       tmp = fabs (pz[pt[1]]) / fabs (pz[pt[0]]);
 
-      if (xisnan (tmp))
+      if (octave::math::isnan (tmp))
         ct_x = ct_y = 0.5;
       else
         {
           ct_x = px[pt[0]] + (px[pt[1]] - px[pt[0]])/(1 + tmp);
           ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
         }
 
       // Add point to contour.
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1110,17 +1110,17 @@ encode_uint_image (std::vector<Magick::I
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    const double grey = xround (double (*img_fvec) / divisor);
+                    const double grey = octave::math::round (double (*img_fvec) / divisor);
                     Magick::Color c (grey, grey, grey);
                     pix[GM_idx] = c;
                     img_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
@@ -1140,19 +1140,19 @@ encode_uint_image (std::vector<Magick::I
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    double grey = xround (double (*img_fvec) / divisor);
+                    double grey = octave::math::round (double (*img_fvec) / divisor);
                     Magick::Color c (grey, grey, grey,
-                                     MaxRGB - xround (double (*a_fvec) / divisor));
+                                     MaxRGB - octave::math::round (double (*a_fvec) / divisor));
                     pix[GM_idx] = c;
                     img_fvec++;
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
@@ -1175,19 +1175,19 @@ encode_uint_image (std::vector<Magick::I
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    Magick::Color c (xround (double (*img_fvec)          / divisor),
-                                     xround (double (img_fvec[G_offset]) / divisor),
-                                     xround (double (img_fvec[B_offset]) / divisor));
+                    Magick::Color c (octave::math::round (double (*img_fvec)          / divisor),
+                                     octave::math::round (double (img_fvec[G_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[B_offset]) / divisor));
                     pix[GM_idx] = c;
                     img_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
@@ -1210,20 +1210,20 @@ encode_uint_image (std::vector<Magick::I
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    Magick::Color c (xround (double (*img_fvec)          / divisor),
-                                     xround (double (img_fvec[G_offset]) / divisor),
-                                     xround (double (img_fvec[B_offset]) / divisor),
-                                     MaxRGB - xround (double (*a_fvec) / divisor));
+                    Magick::Color c (octave::math::round (double (*img_fvec)          / divisor),
+                                     octave::math::round (double (img_fvec[G_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[B_offset]) / divisor),
+                                     MaxRGB - octave::math::round (double (*a_fvec) / divisor));
                     pix[GM_idx] = c;
                     img_fvec++;
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
@@ -1248,20 +1248,20 @@ encode_uint_image (std::vector<Magick::I
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    Magick::Color c (xround (double (*img_fvec)          / divisor),
-                                     xround (double (img_fvec[M_offset]) / divisor),
-                                     xround (double (img_fvec[Y_offset]) / divisor),
-                                     xround (double (img_fvec[K_offset]) / divisor));
+                    Magick::Color c (octave::math::round (double (*img_fvec)          / divisor),
+                                     octave::math::round (double (img_fvec[M_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[Y_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[K_offset]) / divisor));
                     pix[GM_idx] = c;
                     img_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
@@ -1286,22 +1286,22 @@ encode_uint_image (std::vector<Magick::I
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             Magick::IndexPacket *ind = m_img.getIndexes ();
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    Magick::Color c (xround (double (*img_fvec)          / divisor),
-                                     xround (double (img_fvec[M_offset]) / divisor),
-                                     xround (double (img_fvec[Y_offset]) / divisor),
-                                     xround (double (img_fvec[K_offset]) / divisor));
+                    Magick::Color c (octave::math::round (double (*img_fvec)          / divisor),
+                                     octave::math::round (double (img_fvec[M_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[Y_offset]) / divisor),
+                                     octave::math::round (double (img_fvec[K_offset]) / divisor));
                     pix[GM_idx] = c;
-                    ind[GM_idx] = MaxRGB - xround (double (*a_fvec) / divisor);
+                    ind[GM_idx] = MaxRGB - octave::math::round (double (*a_fvec) / divisor);
                     img_fvec++;
                     a_fvec++;
                     GM_idx += nCols;
                   }
                 GM_idx -= nCols * nRows - 1;
               }
             // Save changes to underlying image.
             m_img.syncPixels ();
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -47,20 +47,20 @@ Reference: @nospell{J. Villadsen}, @nosp
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   if (! args(0).is_scalar_type ())
     error ("colloc: N must be a scalar");
 
   double tmp = args(0).double_value ();
-  if (xisnan (tmp))
+  if (octave::math::isnan (tmp))
     error ("colloc: N cannot be NaN");
 
-  octave_idx_type ncol = NINTbig (tmp);
+  octave_idx_type ncol = octave::math::nint_big (tmp);
   if (ncol < 0)
     error ("colloc: N must be positive");
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -465,17 +465,17 @@ template <typename T, typename ET>
 void
 map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
 {
   f = Array<T>(x.dims ());
   e = Array<ET>(x.dims ());
   for (octave_idx_type i = 0; i < x.numel (); i++)
     {
       int exp;
-      f.xelem (i) = xlog2 (x(i), exp);
+      f.xelem (i) = octave::math::log2 (x(i), exp);
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} log2 (@var{x})\n\
 @deftypefnx {} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
@@ -659,39 +659,39 @@ periodic, @code{mod} is a better choice.
 
         default:
           panic_impossible ();
         }
     }
   else if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-        retval = xrem (args(0).float_value (), args(1).float_value ());
+        retval = octave::math::rem (args(0).float_value (), args(1).float_value ());
       else
         {
           FloatNDArray a0 = args(0).float_array_value ();
           FloatNDArray a1 = args(1).float_array_value ();
-          retval = binmap<float> (a0, a1, xrem<float>, "rem");
+          retval = binmap<float> (a0, a1, octave::math::rem<float>, "rem");
         }
     }
   else
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-        retval = xrem (args(0).scalar_value (), args(1).scalar_value ());
+        retval = octave::math::rem (args(0).scalar_value (), args(1).scalar_value ());
       else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
         {
           SparseMatrix m0 = args(0).sparse_matrix_value ();
           SparseMatrix m1 = args(1).sparse_matrix_value ();
-          retval = binmap<double> (m0, m1, xrem<double>, "rem");
+          retval = binmap<double> (m0, m1, octave::math::rem<double>, "rem");
         }
       else
         {
           NDArray a0 = args(0).array_value ();
           NDArray a1 = args(1).array_value ();
-          retval = binmap<double> (a0, a1, xrem<double>, "rem");
+          retval = binmap<double> (a0, a1, octave::math::rem<double>, "rem");
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (size (rem (zeros (0, 2), zeros (0, 2))), [0, 2])
@@ -840,39 +840,39 @@ negative numbers or when the values are 
 
         default:
           panic_impossible ();
         }
     }
   else if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-        retval = xmod (args(0).float_value (), args(1).float_value ());
+        retval = octave::math::mod (args(0).float_value (), args(1).float_value ());
       else
         {
           FloatNDArray a0 = args(0).float_array_value ();
           FloatNDArray a1 = args(1).float_array_value ();
-          retval = binmap<float> (a0, a1, xmod<float>, "mod");
+          retval = binmap<float> (a0, a1, octave::math::mod<float>, "mod");
         }
     }
   else
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-        retval = xmod (args(0).scalar_value (), args(1).scalar_value ());
+        retval = octave::math::mod (args(0).scalar_value (), args(1).scalar_value ());
       else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
         {
           SparseMatrix m0 = args(0).sparse_matrix_value ();
           SparseMatrix m1 = args(1).sparse_matrix_value ();
-          retval = binmap<double> (m0, m1, xmod<double>, "mod");
+          retval = binmap<double> (m0, m1, octave::math::mod<double>, "mod");
         }
       else
         {
           NDArray a0 = args(0).array_value ();
           NDArray a1 = args(1).array_value ();
-          retval = binmap<double> (a0, a1, xmod<double>, "mod");
+          retval = binmap<double> (a0, a1, octave::math::mod<double>, "mod");
         }
     }
 
   return retval;
 }
 
 /*
 ## empty input test
@@ -4535,17 +4535,17 @@ type and may be either @qcode{\"double\"
         {
           Array<float> x = args(0).float_array_value ();
 
           Array<float> epsval (x.dims ());
 
           for (octave_idx_type i = 0; i < x.numel (); i++)
             {
               float val = ::fabsf (x(i));
-              if (xisnan (val) || xisinf (val))
+              if (octave::math::isnan (val) || octave::math::isinf (val))
                 epsval(i) = lo_ieee_nan_value ();
               else if (val < std::numeric_limits<float>::min ())
                 epsval(i) = powf (2.0, -149e0);
               else
                 {
                   int expon;
                   gnulib::frexpf (val, &expon);
                   epsval(i) = std::pow (2.0f,
@@ -4559,17 +4559,17 @@ type and may be either @qcode{\"double\"
         {
           Array<double> x = args(0).array_value ();
 
           Array<double> epsval (x.dims ());
 
           for (octave_idx_type i = 0; i < x.numel (); i++)
             {
               double val = ::fabs (x(i));
-              if (xisnan (val) || xisinf (val))
+              if (octave::math::isnan (val) || octave::math::isinf (val))
                 epsval(i) = lo_ieee_nan_value ();
               else if (val < std::numeric_limits<double>::min ())
                 epsval(i) = pow (2.0, -1074e0);
               else
                 {
                   int expon;
                   gnulib::frexp (val, &expon);
                   epsval(i) = std::pow (2.0,
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -53,36 +53,36 @@ do_fft (const octave_value_list &args, c
   octave_idx_type n_points = -1;
   int dim = -1;
 
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
         {
           double dval = args(1).double_value ();
-          if (xisnan (dval))
+          if (octave::math::isnan (dval))
             error ("%s: number of points (N) cannot be NaN", fcn);
 
-          n_points = NINTbig (dval);
+          n_points = octave::math::nint_big (dval);
           if (n_points < 0)
             error ("%s: number of points (N) must be greater than zero", fcn);
         }
     }
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
-      if (xisnan (dval))
+      if (octave::math::isnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
       else if (dval < 1 || dval > dims.ndims ())
         error ("%s: DIM must be a valid dimension along which to perform FFT",
                fcn);
       else
         // to be safe, cast it back to int since dim is an int
-        dim = NINT (dval) - 1;
+        dim = octave::math::nint (dval) - 1;
     }
 
   for (octave_idx_type i = 0; i < dims.ndims (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -52,32 +52,32 @@ do_fft2 (const octave_value_list &args, 
   octave_value retval;
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
 
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
-      if (xisnan (dval))
+      if (octave::math::isnan (dval))
         error ("%s: number of rows (N) cannot be NaN", fcn);
 
-      n_rows = NINTbig (dval);
+      n_rows = octave::math::nint_big (dval);
       if (n_rows < 0)
         error ("%s: number of rows (N) must be greater than zero", fcn);
     }
 
   octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
-      if (xisnan (dval))
+      if (octave::math::isnan (dval))
         error ("%s: number of columns (M) cannot be NaN", fcn);
 
-      n_cols = NINTbig (dval);
+      n_cols = octave::math::nint_big (dval);
       if (n_cols < 0)
         error ("%s: number of columns (M) must be greater than zero", fcn);
     }
 
   for (int i = 0; i < dims.ndims (); i++)
     if (dims(i) < 0)
       return retval;
 
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -63,22 +63,22 @@ do_fftn (const octave_value_list &args, 
       if (val.rows () > val.columns ())
         val = val.transpose ();
 
       if (val.columns () != dims.ndims () || val.rows () != 1)
         error ("%s: SIZE must be a vector of length dim", fcn);
 
       for (int i = 0; i < dims.ndims (); i++)
         {
-          if (xisnan (val(i,0)))
+          if (octave::math::isnan (val(i,0)))
             error ("%s: SIZE has invalid NaN entries", fcn);
-          else if (NINTbig (val(i,0)) < 0)
+          else if (octave::math::nint_big (val(i,0)) < 0)
             error ("%s: all dimensions in SIZE must be greater than zero", fcn);
           else
-            dims(i) = NINTbig(val(i,0));
+            dims(i) = octave::math::nint_big(val(i,0));
         }
     }
 
   if (dims.all_zero ())
     {
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -389,19 +389,19 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
     print_usage ();
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).xscalar_value ("find: N must be an integer");
 
-      if (val < 0 || (! xisinf (val) && val != xround (val)))
+      if (val < 0 || (! octave::math::isinf (val) && val != octave::math::round (val)))
         error ("find: N must be a non-negative integer");
-      else if (! xisinf (val))
+      else if (! octave::math::isinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
     {
       direction = 0;
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -600,17 +600,17 @@ ft_text_renderer::compute_bbox (void)
            it != line_bbox.end (); ++it)
         {
           if (bbox.is_empty ())
             bbox = it->extract (0, 0, 0, 3);
           else
             {
               bbox(1) -= (*it)(3);
               bbox(3) += (*it)(3);
-              bbox(2) = xmax (bbox(2), (*it)(2));
+              bbox(2) = octave::math::max (bbox(2), (*it)(2));
             }
         }
       break;
     }
 }
 
 void
 ft_text_renderer::update_line_bbox (void)
@@ -801,17 +801,17 @@ ft_text_renderer::process_character (FT_
 
                       xoffset += (delta.x >> 6);
                     }
 
                   // Extend current X offset box by the width of the current
                   // glyph.  Then extend the line bounding box if necessary.
 
                   xoffset += (face->glyph->advance.x >> 6);
-                  bb(2) = xmax (bb(2), xoffset);
+                  bb(2) = octave::math::max (bb(2), xoffset);
                 }
               break;
             }
         }
     }
 
   return glyph_index;
 }
@@ -1068,17 +1068,17 @@ ft_text_renderer::visit (text_element_co
 {
   int saved_xoffset = xoffset;
   int max_xoffset = xoffset;
 
   for (text_element_combined::iterator it = e.begin (); it != e.end (); ++it)
     {
       xoffset = saved_xoffset;
       (*it)->accept (*this);
-      max_xoffset = xmax (xoffset, max_xoffset);
+      max_xoffset = octave::math::max (xoffset, max_xoffset);
     }
 
   xoffset = max_xoffset;
 }
 
 void
 ft_text_renderer::reset (void)
 {
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "ovl.h"
 
 static double
 simple_gcd (double a, double b)
 {
-  if (! xisinteger (a) || ! xisinteger (b))
+  if (! octave::math::isinteger (a) || ! octave::math::isinteger (b))
     error ("gcd: all values must be integers");
 
   double aa = fabs (a);
   double bb = fabs (b);
 
   while (bb != 0)
     {
       double tt = fmod (aa, bb);
@@ -70,18 +70,18 @@ divide (const std::complex<FP>& a, const
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
 simple_gcd (const std::complex<FP>& a, const std::complex<FP>& b)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
+  if (! octave::math::isinteger (a.real ()) || ! octave::math::isinteger (a.imag ())
+      || ! octave::math::isinteger (b.real ()) || ! octave::math::isinteger (b.imag ()))
     error ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
 
   if (abs (aa) < abs (bb))
     std::swap (aa, bb);
 
@@ -111,17 +111,17 @@ simple_gcd (const octave_int<T>& a, cons
     }
 
   return aa;
 }
 
 static double
 extended_gcd (double a, double b, double& x, double& y)
 {
-  if (! xisinteger (a) || ! xisinteger (b))
+  if (! octave::math::isinteger (a) || ! octave::math::isinteger (b))
     error ("gcd: all values must be integers");
 
   double aa = fabs (a);
   double bb = fabs (b);
 
   double xx, lx, yy, ly;
   xx = 0, lx = 1;
   yy = 1, ly = 0;
@@ -149,18 +149,18 @@ extended_gcd (double a, double b, double
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
+  if (! octave::math::isinteger (a.real ()) || ! octave::math::isinteger (a.imag ())
+      || ! octave::math::isinteger (b.real ()) || ! octave::math::isinteger (b.imag ()))
     error ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -92,17 +92,17 @@ If the group ID does not exist in the da
 @seealso{getgrnam}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double dval = args(0).double_value ();
 
-  if (D_NINT (dval) != dval)
+  if (octave::math::x_nint (dval) != dval)
     error ("getgrgid: GID must be an integer");
 
   gid_t gid = static_cast<gid_t> (dval);
 
   std::string msg;
 
   // octave::sys::group::getgrgid may set msg.
   octave_value val = mk_gr_map (octave::sys::group::getgrgid (gid, msg));
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -96,17 +96,17 @@ If the user ID does not exist in the dat
 @seealso{getpwnam}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double dval = args(0).double_value ();
 
-  if (D_NINT (dval) != dval)
+  if (octave::math::x_nint (dval) != dval)
     error ("getpwuid: UID must be an integer");
 
   uid_t uid = static_cast<uid_t> (dval);
 
   std::string msg;
 
   // octave::sys::password::getpwuid may set msg.
   octave_value val = mk_pw_map (octave::sys::password::getpwuid (uid, msg));
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1257,77 +1257,77 @@ opengl_renderer::draw_axes_x_grid (const
       bool do_xminorgrid = (props.is_xminorgrid ()
                             && (minorgridstyle != "none"));
       bool do_xminortick = props.is_xminortick ();
       Matrix xticks = xform.xscale (props.get_xtick ().matrix_value ());
       Matrix xmticks = xform.xscale (props.get_xmtick ().matrix_value ());
       string_vector xticklabels = props.get_xticklabel ().string_vector_value ();
       int wmax = 0;
       int hmax = 0;
-      bool tick_along_z = nearhoriz || xisinf (fy);
+      bool tick_along_z = nearhoriz || octave::math::isinf (fy);
       bool mirror = props.is_box () && xstate != AXE_ANY_DIR;
 
       set_color (props.get_xcolor_rgb ());
 
       // grid lines
       if (do_xgrid)
         render_grid (gridstyle, xticks, x_min, x_max,
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTick,
                             zpTick, zpTickN, 0., 0.,
-                            signum (zpTick-zpTickN)*fz*xticklen,
+                            octave::math::signum (zpTick-zpTickN)*fz*xticklen,
                             0, mirror);
         }
       else
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTickN,
                             zpTick, zpTick, 0.,
-                            signum (ypTick-ypTickN)*fy*xticklen,
+                            octave::math::signum (ypTick-ypTickN)*fy*xticklen,
                             0., 0, mirror);
         }
 
       // tick texts
       if (xticklabels.numel () > 0)
         {
           int halign = (xstate == AXE_HORZ_DIR ? 1 : (xyzSym ? 0 : 2));
           int valign = (xstate == AXE_VERT_DIR ? 1 : (x2Dtop ? 0 : 2));
 
           if (tick_along_z)
             render_ticktexts (xticks, xticklabels, x_min, x_max, ypTick,
-                              zpTick+signum (zpTick-zpTickN)*fz*xtickoffset,
+                              zpTick+octave::math::signum (zpTick-zpTickN)*fz*xtickoffset,
                               0, halign, valign, wmax, hmax);
           else
             render_ticktexts (xticks, xticklabels, x_min, x_max,
-                              ypTick+signum (ypTick-ypTickN)*fy*xtickoffset,
+                              ypTick+octave::math::signum (ypTick-ypTickN)*fy*xtickoffset,
                               zpTick, 0, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_xminorgrid)
         render_grid (minorgridstyle, xmticks, x_min, x_max,
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum (zpTick-zpTickN)*fz*xticklen/2,
+                              octave::math::signum (zpTick-zpTickN)*fz*xticklen/2,
                               0, mirror);
           else
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTickN,
                               zpTick, zpTick, 0.,
-                              signum (ypTick-ypTickN)*fy*xticklen/2,
+                              octave::math::signum (ypTick-ypTickN)*fy*xticklen/2,
                               0., 0, mirror);
         }
 
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
 }
@@ -1367,75 +1367,75 @@ opengl_renderer::draw_axes_y_grid (const
       bool do_yminorgrid = (props.is_yminorgrid ()
                             && (minorgridstyle != "none"));
       bool do_yminortick = props.is_yminortick ();
       Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
       Matrix ymticks = xform.yscale (props.get_ymtick ().matrix_value ());
       string_vector yticklabels = props.get_yticklabel ().string_vector_value ();
       int wmax = 0;
       int hmax = 0;
-      bool tick_along_z = nearhoriz || xisinf (fx);
+      bool tick_along_z = nearhoriz || octave::math::isinf (fx);
       bool mirror = props.is_box () && ystate != AXE_ANY_DIR
                     && (! props.has_property ("__plotyy_axes__"));
 
       set_color (props.get_ycolor_rgb ());
 
       // grid lines
       if (do_ygrid)
         render_grid (gridstyle, yticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTick,
                           zpTick, zpTickN, 0., 0.,
-                          signum (zpTick-zpTickN)*fz*yticklen,
+                          octave::math::signum (zpTick-zpTickN)*fz*yticklen,
                           1, mirror);
       else
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTickN,
                           zpTick, zpTick,
-                          signum (xPlaneN-xPlane)*fx*yticklen,
+                          octave::math::signum (xPlaneN-xPlane)*fx*yticklen,
                           0., 0., 1, mirror);
 
       // tick texts
       if (yticklabels.numel () > 0)
         {
           int halign = (ystate == AXE_HORZ_DIR
                         ? 1 : (! xyzSym || y2Dright ? 0 : 2));
           int valign = (ystate == AXE_VERT_DIR ? 1 : 2);
 
           if (tick_along_z)
             render_ticktexts (yticks, yticklabels, y_min, y_max, xpTick,
-                              zpTick+signum (zpTick-zpTickN)*fz*ytickoffset,
+                              zpTick+octave::math::signum (zpTick-zpTickN)*fz*ytickoffset,
                               1, halign, valign, wmax, hmax);
           else
             render_ticktexts (yticks, yticklabels, y_min, y_max,
-                              xpTick+signum (xpTick-xpTickN)*fx*ytickoffset,
+                              xpTick+octave::math::signum (xpTick-xpTickN)*fx*ytickoffset,
                               zpTick, 1, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_yminorgrid)
         render_grid (minorgridstyle, ymticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_yminortick)
         {
           if (tick_along_z)
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum (zpTick-zpTickN)*fz*yticklen/2,
+                              octave::math::signum (zpTick-zpTickN)*fz*yticklen/2,
                               1, mirror);
           else
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTickN,
                               zpTick, zpTick,
-                              signum (xpTick-xpTickN)*fx*yticklen/2,
+                              octave::math::signum (xpTick-xpTickN)*fx*yticklen/2,
                               0., 0., 1, mirror);
         }
 
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
 }
@@ -1480,103 +1480,103 @@ opengl_renderer::draw_axes_z_grid (const
       // grid lines
       if (do_zgrid)
         render_grid (gridstyle, zticks, z_min, z_max,
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
 
       // tick marks
       if (xySym)
         {
-          if (xisinf (fy))
+          if (octave::math::isinf (fy))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlane, yPlane,
-                              signum (xPlaneN-xPlane)*fx*zticklen,
+                              octave::math::signum (xPlaneN-xPlane)*fx*zticklen,
                               0., 0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlaneN,
                               yPlane, yPlane, 0.,
-                              signum (yPlane-yPlaneN)*fy*zticklen,
+                              octave::math::signum (yPlane-yPlaneN)*fy*zticklen,
                               0., 2, false);
         }
       else
         {
-          if (xisinf (fx))
+          if (octave::math::isinf (fx))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlaneN, yPlane, 0.,
-                              signum (yPlaneN-yPlane)*fy*zticklen,
+                              octave::math::signum (yPlaneN-yPlane)*fy*zticklen,
                               0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlane, xPlane,
                               yPlaneN, yPlane,
-                              signum (xPlane-xPlaneN)*fx*zticklen,
+                              octave::math::signum (xPlane-xPlaneN)*fx*zticklen,
                               0., 0., 2, false);
         }
 
       // FIXME: tick texts
       if (zticklabels.numel () > 0)
         {
           int halign = 2;
           int valign = (zstate == AXE_VERT_DIR ? 1 : (zSign ? 3 : 2));
 
           if (xySym)
             {
-              if (xisinf (fy))
+              if (octave::math::isinf (fy))
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlaneN+signum (xPlaneN-xPlane)*fx*ztickoffset,
+                                  xPlaneN+octave::math::signum (xPlaneN-xPlane)*fx*ztickoffset,
                                   yPlane, 2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlaneN,
-                                  yPlane+signum (yPlane-yPlaneN)*fy*ztickoffset,
+                                  yPlane+octave::math::signum (yPlane-yPlaneN)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
             }
           else
             {
-              if (xisinf (fx))
+              if (octave::math::isinf (fx))
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlane,
-                                  yPlaneN+signum (yPlaneN-yPlane)*fy*ztickoffset,
+                                  yPlaneN+octave::math::signum (yPlaneN-yPlane)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlane+signum (xPlane-xPlaneN)*fx*ztickoffset,
+                                  xPlane+octave::math::signum (xPlane-xPlaneN)*fx*ztickoffset,
                                   yPlaneN, 2, halign, valign, wmax, hmax);
             }
         }
 
       // minor grid lines
       if (do_zminorgrid)
         render_grid (minorgridstyle, zmticks, z_min, z_max,
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
 
       // minor tick marks
       if (do_zminortick)
         {
           if (xySym)
             {
-              if (xisinf (fy))
+              if (octave::math::isinf (fy))
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlane,
                                   yPlane, yPlane,
-                                  signum (xPlaneN-xPlane)*fx*zticklen/2,
+                                  octave::math::signum (xPlaneN-xPlane)*fx*zticklen/2,
                                   0., 0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlaneN,
                                   yPlane, yPlane, 0.,
-                                  signum (yPlane-yPlaneN)*fy*zticklen/2,
+                                  octave::math::signum (yPlane-yPlaneN)*fy*zticklen/2,
                                   0., 2, false);
             }
           else
             {
-              if (xisinf (fx))
+              if (octave::math::isinf (fx))
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlane, 0.,
-                                  signum (yPlaneN-yPlane)*fy*zticklen/2,
+                                  octave::math::signum (yPlaneN-yPlane)*fy*zticklen/2,
                                   0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlaneN,
-                                  signum (xPlane-xPlaneN)*fx*zticklen/2,
+                                  octave::math::signum (xPlane-xPlaneN)*fx*zticklen/2,
                                   0., 0., 2, false);
             }
         }
 
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
@@ -2000,24 +2000,24 @@ opengl_renderer::draw_surface (const sur
 
                   if (clip(j-1, i-1) || clip(j, i-1)
                       || clip(j-1, i) || clip(j, i))
                     continue;
 
                   if (fc_mode == FLAT)
                     {
                       // "flat" only needs color at lower-left vertex
-                      if (! xfinite (c(j-1,i-1)))
+                      if (! octave::math::finite (c(j-1,i-1)))
                         continue;
                     }
                   else if (fc_mode == INTERP)
                     {
                       // "interp" needs valid color at all 4 vertices
-                      if (! (xfinite (c(j-1, i-1)) && xfinite (c(j, i-1))
-                             && xfinite (c(j-1, i)) && xfinite (c(j, i))))
+                      if (! (octave::math::finite (c(j-1, i-1)) && octave::math::finite (c(j, i-1))
+                             && octave::math::finite (c(j-1, i)) && octave::math::finite (c(j, i))))
                         continue;
                     }
 
                   if (x_mat)
                     {
                       j1 = j-1;
                       j2 = j;
                     }
@@ -2205,23 +2205,23 @@ opengl_renderer::draw_surface (const sur
                   for (int j = 1; j < zr; j++)
                     {
                       if (clip(j-1,i) || clip(j,i))
                         continue;
 
                       if (ec_mode == FLAT)
                         {
                           // "flat" only needs color at lower-left vertex
-                          if (! xfinite (c(j-1,i)))
+                          if (! octave::math::finite (c(j-1,i)))
                             continue;
                         }
                       else if (ec_mode == INTERP)
                         {
                           // "interp" needs valid color at both vertices
-                          if (! (xfinite (c(j-1, i)) && xfinite (c(j, i))))
+                          if (! (octave::math::finite (c(j-1, i)) && octave::math::finite (c(j, i))))
                             continue;
                         }
 
                       if (x_mat)
                         {
                           j1 = j-1;
                           j2 = j;
                         }
@@ -2302,23 +2302,23 @@ opengl_renderer::draw_surface (const sur
                   for (int i = 1; i < zc; i++)
                     {
                       if (clip(j,i-1) || clip(j,i))
                         continue;
 
                       if (ec_mode == FLAT)
                         {
                           // "flat" only needs color at lower-left vertex
-                          if (! xfinite (c(j,i-1)))
+                          if (! octave::math::finite (c(j,i-1)))
                             continue;
                         }
                       else if (ec_mode == INTERP)
                         {
                           // "interp" needs valid color at both vertices
-                          if (! (xfinite (c(j, i-1)) && xfinite (c(j, i))))
+                          if (! (octave::math::finite (c(j, i-1)) && octave::math::finite (c(j, i))))
                             continue;
                         }
 
                       if (y_mat)
                         {
                           i1 = i-1;
                           i2 = i;
                         }
@@ -2440,17 +2440,17 @@ opengl_renderer::draw_surface (const sur
                 continue;
 
               if (x_mat)
                 j1 = j;
 
               if ((do_edge && mecolor.is_empty ())
                   || (do_face && mfcolor.is_empty ()))
                 {
-                  if (! xfinite (c(j,i)))
+                  if (! octave::math::finite (c(j,i)))
                     continue;  // Skip NaNs in color data
 
                   for (int k = 0; k < 3; k++)
                     cc(k) = c(j,i,k);
                 }
 
               Matrix lc = (do_edge ? (mecolor.is_empty () ? cc : mecolor)
                                    : Matrix ());
@@ -2540,17 +2540,17 @@ opengl_renderer::draw_patch (const patch
   boolMatrix clip_f (1, nf, false);
   Array<int> count_f (dim_vector (nf, 1), 0);
 
   for (int i = 0; i < nf; i++)
     {
       bool fclip = false;
       int count = 0;
 
-      for (int j = 0; j < fcmax && ! xisnan (f(i,j)); j++, count++)
+      for (int j = 0; j < fcmax && ! octave::math::isnan (f(i,j)); j++, count++)
         fclip = (fclip || clip(int (f(i,j) - 1)));
 
       clip_f(i) = fclip;
       count_f(i) = count;
     }
 
   if (fc_mode > 0 || ec_mode > 0)
     {
@@ -2988,17 +2988,17 @@ opengl_renderer::draw_image (const image
     x(1) = x(1) + (w-1);
 
   if (h > 1 && y(1) == y(0))
     y(1) = y(1) + (h-1);
 
   const ColumnVector p0 = xform.transform (x(0), y(0), 0);
   const ColumnVector p1 = xform.transform (x(1), y(1), 0);
 
-  if (xisnan (p0(0)) || xisnan (p0(1)) || xisnan (p1(0)) || xisnan (p1(1)))
+  if (octave::math::isnan (p0(0)) || octave::math::isnan (p0(1)) || octave::math::isnan (p1(0)) || octave::math::isnan (p1(1)))
     {
       warning ("opengl_renderer: image X,Y data too large to draw");
       return;
     }
 
   // image pixel size in screen pixel units
   float pix_dx, pix_dy;
   // image pixel size in normalized units
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -133,18 +133,18 @@ private:
   // No copying!
 
   opengl_renderer (const opengl_renderer&);
 
   opengl_renderer& operator = (const opengl_renderer&);
 
   bool is_nan_or_inf (double x, double y, double z) const
   {
-    return (xisnan (x) || xisnan (y) || xisnan (z)
-            || xisinf (x) || xisinf (y) || xisinf (z));
+    return (octave::math::isnan (x) || octave::math::isnan (y) || octave::math::isnan (z)
+            || octave::math::isinf (x) || octave::math::isinf (y) || octave::math::isinf (z));
   }
 
   octave_uint8 clip_code (double x, double y, double z) const
   {
     return ((x < xmin ? 1 : 0)
             | (x > xmax ? 1 : 0) << 1
             | (y < ymin ? 1 : 0) << 2
             | (y > ymax ? 1 : 0) << 3
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -840,21 +840,21 @@ screen_size_pixels (void)
 }
 
 static void
 convert_cdata_2 (bool is_scaled, bool is_real, double clim_0, double clim_1,
                  const double *cmapv, double x, octave_idx_type lda,
                  octave_idx_type nc, octave_idx_type i, double *av)
 {
   if (is_scaled)
-    x = xround ((nc - 1) * (x - clim_0) / (clim_1 - clim_0));
+    x = octave::math::round ((nc - 1) * (x - clim_0) / (clim_1 - clim_0));
   else if (is_real)
-    x = xround (x - 1);
-
-  if (xisnan (x))
+    x = octave::math::round (x - 1);
+
+  if (octave::math::isnan (x))
     {
       av[i]       = x;
       av[i+lda]   = x;
       av[i+2*lda] = x;
     }
   else
     {
       if (x < 0)
@@ -980,17 +980,17 @@ get_array_limits (const Array<T>& m, dou
   const T *data = m.data ();
   octave_idx_type n = m.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       double e = double (data[i]);
 
       // Don't need to test for NaN here as NaN>x and NaN<x is always false
-      if (! xisinf (e))
+      if (! octave::math::isinf (e))
         {
           if (e < emin)
             emin = e;
 
           if (e > emax)
             emax = e;
 
           if (e > 0 && e < eminp)
@@ -1555,17 +1555,17 @@ handle_property::do_set (const octave_va
         return false;
     }
 
   double dv = v.xdouble_value ("set: invalid graphics handle for property \"%s\"",
                               get_name ().c_str ());
 
   graphics_handle gh = gh_manager::lookup (dv);
 
-  if (! (xisnan (gh.value ()) || gh.ok ()))
+  if (! (octave::math::isnan (gh.value ()) || gh.ok ()))
     error ("set: invalid graphics handle (= %g) for property \"%s\"",
            dv, get_name ().c_str ());
 
   if (current_val != gh)
     {
       current_val = gh;
       return true;
     }
@@ -3390,17 +3390,17 @@ graphics_object::get_ancestor (const std
 
 // ---------------------------------------------------------------------
 
 void
 root_figure::properties::set_callbackobject (const octave_value& v)
 {
   graphics_handle val (v);
 
-  if (xisnan (val.value ()))
+  if (octave::math::isnan (val.value ()))
     {
       if (! cbo_stack.empty ())
         {
           val = cbo_stack.front ();
 
           cbo_stack.pop_front ();
         }
 
@@ -3417,17 +3417,17 @@ root_figure::properties::set_callbackobj
     err_set_invalid ("callbackobject");
 }
 
 void
 root_figure::properties::set_currentfigure (const octave_value& v)
 {
   graphics_handle val (v);
 
-  if (xisnan (val.value ()) || is_handle (val))
+  if (octave::math::isnan (val.value ()) || is_handle (val))
     {
       currentfigure = val;
 
       if (val.ok ())
         gh_manager::push_figure (val);
     }
   else
     err_set_invalid ("currentfigure");
@@ -3577,17 +3577,17 @@ root_figure::reset_default_properties (v
 
 // ---------------------------------------------------------------------
 
 void
 figure::properties::set_currentaxes (const octave_value& val)
 {
   graphics_handle hax (val);
 
-  if (xisnan (hax.value ()) || is_handle (hax))
+  if (octave::math::isnan (hax.value ()) || is_handle (hax))
     currentaxes = hax;
   else
     err_set_invalid ("currentaxes");
 }
 
 void
 figure::properties::remove_child (const graphics_handle& h)
 {
@@ -5217,17 +5217,17 @@ axes::properties::update_camera (void)
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0);
       double el = tview(1);
       double d = 5 * sqrt (pb(0)*pb(0) + pb(1)*pb(1) + pb(2)*pb(2));
 
       if (el == 90 || el == -90)
-        c_eye(2) = d*signum (el);
+        c_eye(2) = d*octave::math::signum (el);
       else
         {
           az *= M_PI/180.0;
           el *= M_PI/180.0;
           c_eye(0) = d * cos (el) * sin (az);
           c_eye(1) = -d* cos (el) * cos (az);
           c_eye(2) = d * sin (el);
         }
@@ -5244,19 +5244,19 @@ axes::properties::update_camera (void)
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0);
       double el = tview(1);
 
       if (el == 90 || el == -90)
         {
           c_upv(0) =
-            -signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
+            -octave::math::signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
           c_upv(1) =
-            signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
+            octave::math::signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
         }
       else
         c_upv(2) = 1;
 
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
@@ -5419,18 +5419,18 @@ axes::properties::update_axes_layout (vo
   z_min = zlims(0), z_max = zlims(1);
 
   ColumnVector p1, p2, dir (3);
 
   xstate = ystate = zstate = AXE_ANY_DIR;
 
   p1 = xform.transform (x_min, (y_min+y_max)/2, (z_min+z_max)/2, false);
   p2 = xform.transform (x_max, (y_min+y_max)/2, (z_min+z_max)/2, false);
-  dir(0) = xround (p2(0) - p1(0));
-  dir(1) = xround (p2(1) - p1(1));
+  dir(0) = octave::math::round (p2(0) - p1(0));
+  dir(1) = octave::math::round (p2(1) - p1(1));
   dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     xstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         xstate = AXE_VERT_DIR;
       else if (dir(1) == 0)
@@ -5447,18 +5447,18 @@ axes::properties::update_axes_layout (vo
   else
     xPlane = (dir(2) < 0 ? x_min : x_max);
 
   xPlaneN = (xPlane == x_min ? x_max : x_min);
   fx = (x_max - x_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
   p1 = xform.transform ((x_min + x_max)/2, y_min, (z_min + z_max)/2, false);
   p2 = xform.transform ((x_min + x_max)/2, y_max, (z_min + z_max)/2, false);
-  dir(0) = xround (p2(0) - p1(0));
-  dir(1) = xround (p2(1) - p1(1));
+  dir(0) = octave::math::round (p2(0) - p1(0));
+  dir(1) = octave::math::round (p2(1) - p1(1));
   dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     ystate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         ystate = AXE_VERT_DIR;
       else if (dir(1) == 0)
@@ -5475,18 +5475,18 @@ axes::properties::update_axes_layout (vo
   else
     yPlane = (dir(2) < 0 ? y_min : y_max);
 
   yPlaneN = (yPlane == y_min ? y_max : y_min);
   fy = (y_max - y_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
   p1 = xform.transform ((x_min + x_max)/2, (y_min + y_max)/2, z_min, false);
   p2 = xform.transform ((x_min + x_max)/2, (y_min + y_max)/2, z_max, false);
-  dir(0) = xround (p2(0) - p1(0));
-  dir(1) = xround (p2(1) - p1(1));
+  dir(0) = octave::math::round (p2(0) - p1(0));
+  dir(1) = octave::math::round (p2(1) - p1(1));
   dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     zstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         zstate = AXE_VERT_DIR;
       else if (dir(1) == 0)
@@ -5686,21 +5686,21 @@ axes::properties::update_xlabel_position
                                    get_xlim ().matrix_value ());
 
       double wmax = ext(0);
       double hmax = ext(1);
       double angle = 0.0;
       ColumnVector p =
         graphics_xform::xform_vector ((xpTickN + xpTick)/2, ypTick, zpTick);
 
-      bool tick_along_z = nearhoriz || xisinf (fy);
+      bool tick_along_z = nearhoriz || octave::math::isinf (fy);
       if (tick_along_z)
-        p(2) += (signum (zpTick - zpTickN) * fz * xtickoffset);
+        p(2) += (octave::math::signum (zpTick - zpTickN) * fz * xtickoffset);
       else
-        p(1) += (signum (ypTick - ypTickN) * fy * xtickoffset);
+        p(1) += (octave::math::signum (ypTick - ypTickN) * fy * xtickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (xstate)
         {
         case AXE_ANY_DIR:
           p(0) += (xyzSym ? wmax : -wmax);
           p(1) += hmax;
@@ -5796,21 +5796,21 @@ axes::properties::update_ylabel_position
                                    get_ylim ().matrix_value ());
 
       double wmax = ext(0)+4;
       double hmax = ext(1);
       double angle = 0.0;
       ColumnVector p =
         graphics_xform::xform_vector (xpTick, (ypTickN + ypTick)/2, zpTick);
 
-      bool tick_along_z = nearhoriz || xisinf (fx);
+      bool tick_along_z = nearhoriz || octave::math::isinf (fx);
       if (tick_along_z)
-        p(2) += (signum (zpTick - zpTickN) * fz * ytickoffset);
+        p(2) += (octave::math::signum (zpTick - zpTickN) * fz * ytickoffset);
       else
-        p(0) += (signum (xpTick - xpTickN) * fx * ytickoffset);
+        p(0) += (octave::math::signum (xpTick - xpTickN) * fx * ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
         case AXE_ANY_DIR:
           p(0) += (! xyzSym ? wmax : -wmax);
           p(1) += hmax;
@@ -5902,29 +5902,29 @@ axes::properties::update_zlabel_position
       double hmax = ext(1);
       double angle = 0.0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
                                             (zpTickN + zpTick)/2);
-          if (xisinf (fy))
-            p(0) += (signum (xPlaneN - xPlane) * fx * ztickoffset);
+          if (octave::math::isinf (fy))
+            p(0) += (octave::math::signum (xPlaneN - xPlane) * fx * ztickoffset);
           else
-            p(1) += (signum (yPlane - yPlaneN) * fy * ztickoffset);
+            p(1) += (octave::math::signum (yPlane - yPlaneN) * fy * ztickoffset);
         }
       else
         {
           p = graphics_xform::xform_vector (xPlane, yPlaneN,
                                             (zpTickN + zpTick)/2);
-          if (xisinf (fx))
-            p(1) += (signum (yPlaneN - yPlane) * fy * ztickoffset);
+          if (octave::math::isinf (fx))
+            p(1) += (octave::math::signum (yPlaneN - yPlane) * fy * ztickoffset);
           else
-            p(0) += (signum (xPlane - xPlaneN) * fx * ztickoffset);
+            p(0) += (octave::math::signum (xPlane - xPlaneN) * fx * ztickoffset);
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
         case AXE_ANY_DIR:
           if (camAuto)
@@ -6037,17 +6037,17 @@ axes::properties::update_autopos (const 
 static void
 normalized_aspectratios (Matrix& aspectratios, const Matrix& scalefactors,
                          double xlength, double ylength, double zlength)
 {
   double xval = xlength / scalefactors(0);
   double yval = ylength / scalefactors(1);
   double zval = zlength / scalefactors(2);
 
-  double minval = xmin (xmin (xval, yval), zval);
+  double minval = octave::math::min (octave::math::min (xval, yval), zval);
 
   aspectratios(0) = xval / minval;
   aspectratios(1) = yval / minval;
   aspectratios(2) = zval / minval;
 }
 
 static void
 max_axes_scale (double& s, Matrix& limits, const Matrix& kids,
@@ -6055,25 +6055,25 @@ max_axes_scale (double& s, Matrix& limit
 {
   if (tight)
     {
       double minval = octave::numeric_limits<double>::Inf ();
       double maxval = -octave::numeric_limits<double>::Inf ();
       double min_pos = octave::numeric_limits<double>::Inf ();
       double max_neg = -octave::numeric_limits<double>::Inf ();
       get_children_limits (minval, maxval, min_pos, max_neg, kids, limit_type);
-      if (xfinite (minval) && xfinite (maxval))
+      if (octave::math::finite (minval) && octave::math::finite (maxval))
         {
           limits(0) = minval;
           limits(1) = maxval;
-          s = xmax (s, (maxval - minval) / (pbfactor * dafactor));
+          s = octave::math::max (s, (maxval - minval) / (pbfactor * dafactor));
         }
     }
   else
-    s = xmax (s, (limits(1) - limits(0)) / (pbfactor * dafactor));
+    s = octave::math::max (s, (limits(1) - limits(0)) / (pbfactor * dafactor));
 }
 
 static std::set<double> updating_aspectratios;
 
 void
 axes::properties::update_aspectratios (void)
 {
   if (updating_aspectratios.find (get___myhandle__ ().value ())
@@ -6142,18 +6142,18 @@ axes::properties::update_aspectratios (v
           octave::unwind_protect frame;
           frame.protect_var (updating_aspectratios);
 
           updating_aspectratios.insert (get___myhandle__ ().value ());
 
           dx = pba(0) * da(0);
           dy = pba(1) * da(1);
           dz = pba(2) * da(2);
-          if (xisinf (s))
-            s = 1 / xmin (xmin (dx, dy), dz);
+          if (octave::math::isinf (s))
+            s = 1 / octave::math::min (octave::math::min (dx, dy), dz);
 
           if (xlimmode_is ("auto"))
             {
               dx = s * dx;
               xlimits(0) = 0.5 * (xlimits(0) + xlimits(1) - dx);
               xlimits(1) = xlimits(0) + dx;
               set_xlim (xlimits);
               set_xlimmode ("auto");
@@ -6587,26 +6587,26 @@ axes::get_default (const caseless_str& p
 // FIXME: maybe this should go into array_property class?
 /*
 static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const array_property& data)
 {
   double val = data.min_val ();
-  if (xfinite (val) && val < min_val)
+  if (octave::math::finite (val) && val < min_val)
     min_val = val;
   val = data.max_val ();
-  if (xfinite (val) && val > max_val)
+  if (octave::math::finite (val) && val > max_val)
     max_val = val;
   val = data.min_pos ();
-  if (xfinite (val) && val > 0 && val < min_pos)
+  if (octave::math::finite (val) && val > 0 && val < min_pos)
     min_pos = val;
   val = data.max_neg ();
-  if (xfinite (val) && val < 0 && val > max_neg)
+  if (octave::math::finite (val) && val < 0 && val > max_neg)
     max_neg = val;
 }
 */
 
 static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const octave_value& data)
@@ -6615,29 +6615,29 @@ check_limit_vals (double& min_val, doubl
     {
       Matrix m = data.matrix_value ();
 
       if (m.numel () == 4)
         {
           double val;
 
           val = m(0);
-          if (xfinite (val) && val < min_val)
+          if (octave::math::finite (val) && val < min_val)
             min_val = val;
 
           val = m(1);
-          if (xfinite (val) && val > max_val)
+          if (octave::math::finite (val) && val > max_val)
             max_val = val;
 
           val = m(2);
-          if (xfinite (val) && val > 0 && val < min_pos)
+          if (octave::math::finite (val) && val > 0 && val < min_pos)
             min_pos = val;
 
           val = m(3);
-          if (xfinite (val) && val < 0 && val > max_neg)
+          if (octave::math::finite (val) && val < 0 && val > max_neg)
             max_neg = val;
         }
     }
 }
 
 // magform(x) Returns (a, b),
 // where x = a * 10^b, abs (a) >= 1., and b is integer.
 
@@ -6699,26 +6699,26 @@ axes::properties::get_axis_limits (doubl
                                    double min_pos, double max_neg,
                                    bool logscale)
 {
   Matrix retval;
 
   double min_val = xmin;
   double max_val = xmax;
 
-  if (xisinf (min_val) && min_val > 0 && xisinf (max_val) && max_val < 0)
+  if (octave::math::isinf (min_val) && min_val > 0 && octave::math::isinf (max_val) && max_val < 0)
     {
       retval = default_lim (logscale);
       return retval;
     }
-  else if (! (xisinf (min_val) || xisinf (max_val)))
+  else if (! (octave::math::isinf (min_val) || octave::math::isinf (max_val)))
     {
       if (logscale)
         {
-          if (xisinf (min_pos) && xisinf (max_neg))
+          if (octave::math::isinf (min_pos) && octave::math::isinf (max_neg))
             {
               // FIXME: max_neg is needed for "loglog ([0 -Inf])"
               //        This is the *only* place where max_neg is needed.
               //        Is there another way?
               retval = default_lim ();
               retval(0) = pow (10., retval(0));
               retval(1) = pow (10., retval(1));
               return retval;
@@ -6822,17 +6822,17 @@ axes::properties::calc_ticks_and_lims (a
           lo = std::log10 (lo);
         }
     }
 
   double tick_sep;
 
   if (is_logscale)
     {
-      if (! (xisinf (hi) || xisinf (lo)))
+      if (! (octave::math::isinf (hi) || octave::math::isinf (lo)))
         tick_sep = 1;  // Tick is every order of magnitude (bug #39449)
       else
         tick_sep = 0;
     }
   else
     tick_sep = calc_tick_sep (lo, hi);
 
   int i1 = static_cast<int> (gnulib::floor (lo / tick_sep));
@@ -7123,26 +7123,26 @@ axes::update_axis_limits (const std::str
 
   Matrix limits;
   double val;
 
 #define FIX_LIMITS \
   if (limits.numel () == 4) \
     { \
       val = limits(0); \
-      if (xfinite (val)) \
+      if (octave::math::finite (val)) \
         min_val = val; \
       val = limits(1); \
-      if (xfinite (val)) \
+      if (octave::math::finite (val)) \
         max_val = val; \
       val = limits(2); \
-      if (xfinite (val)) \
+      if (octave::math::finite (val)) \
         min_pos = val; \
       val = limits(3); \
-      if (xfinite (val)) \
+      if (octave::math::finite (val)) \
         max_neg = val; \
     } \
   else \
     { \
       limits.resize (4, 1); \
       limits(0) = min_val; \
       limits(1) = max_val; \
       limits(2) = min_pos; \
@@ -8204,17 +8204,17 @@ patch::properties::update_data (void)
   if (idx.any_element_is_inf_or_nan ())
     {
       for (octave_idx_type jj = 0; jj < idx.columns (); jj++)
         {
           double valid_vert = idx(0,jj);
           bool turn_valid = false;
           for (octave_idx_type ii = 0; ii < idx.rows (); ii++)
             {
-              if (xisnan (idx(ii,jj)) || turn_valid)
+              if (octave::math::isnan (idx(ii,jj)) || turn_valid)
                 {
                   idx(ii,jj) = valid_vert;
                   turn_valid = true;
                 }
               else
                 valid_vert = idx(ii,jj);
             }
         }
@@ -8469,26 +8469,26 @@ hggroup::update_axis_limits (const std::
     {
       limits = xproperties.get_alim ().matrix_value ();
       update_type = 'a';
     }
 
   if (limits.numel () == 4)
     {
       val = limits(0);
-      if (xfinite (val))
+      if (octave::math::finite (val))
         min_val = val;
       val = limits(1);
-      if (xfinite (val))
+      if (octave::math::finite (val))
         max_val = val;
       val = limits(2);
-      if (xfinite (val))
+      if (octave::math::finite (val))
         min_pos = val;
       val = limits(3);
-      if (xfinite (val))
+      if (octave::math::finite (val))
         max_neg = val;
     }
   else
     {
       limits.resize (4, 1);
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
@@ -10104,17 +10104,17 @@ make_graphics_object (const std::string&
 
           val = xargs(i+1).double_value ();
 
           xargs = xargs.splice (i, 2);
           break;
         }
     }
 
-  if (xisnan (val))
+  if (octave::math::isnan (val))
     val = args(0).xdouble_value ("__go_%s__: invalid parent", go_name.c_str ());
 
   graphics_handle parent = gh_manager::lookup (val);
 
   if (! parent.ok ())
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
   graphics_handle h;
@@ -10170,17 +10170,17 @@ Undocumented internal function.\n\
   else
     {
       bool int_fig_handle = true;
 
       octave_value_list xargs = args.splice (0, 1);
 
       graphics_handle h = octave::numeric_limits<double>::NaN ();
 
-      if (xisnan (val))
+      if (octave::math::isnan (val))
         {
           caseless_str pname ("integerhandle");
 
           for (int i = 0; i < xargs.length (); i++)
             {
               if (xargs(i).is_string ()
                   && pname.compare (xargs(i).string_value ()))
                 {
@@ -10205,17 +10205,17 @@ Undocumented internal function.\n\
             {
               // We need to initialize the integerhandle property
               // without calling the set_integerhandle method,
               // because doing that will generate a new handle value...
               graphics_object go = gh_manager::get_object (h);
               go.get_properties ().init_integerhandle ("off");
             }
         }
-      else if (val > 0 && D_NINT (val) == val)
+      else if (val > 0 && octave::math::x_nint (val) == val)
         h = gh_manager::make_figure_handle (val, false);
 
       if (! h.ok ())
         error ("__go_figure__: failed to create figure handle");
 
       adopt (0, h);
 
       gh_manager::push_figure (h);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -6183,17 +6183,17 @@ private:
 
   void do_free (const graphics_handle& h);
 
   void do_renumber_figure (const graphics_handle& old_gh,
                            const graphics_handle& new_gh);
 
   graphics_handle do_lookup (double val)
   {
-    iterator p = (xisnan (val) ? handle_map.end () : handle_map.find (val));
+    iterator p = (octave::math::isnan (val) ? handle_map.end () : handle_map.find (val));
 
     return (p != handle_map.end ()) ? p->first : graphics_handle ();
   }
 
   graphics_object do_get_object (const graphics_handle& h)
   {
     iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -390,17 +390,17 @@ octave_jit_complex_div (Complex lhs, Com
 
   return lhs / rhs;
 }
 
 // FIXME: CP form src/xpow.cc
 static inline int
 xisint (double x)
 {
-  return (D_NINT (x) == x
+  return (octave::math::x_nint (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 extern "C" Complex
 octave_jit_pow_scalar_scalar (double lhs, double rhs)
 {
   // FIXME: almost CP from src/xpow.cc
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1886,17 +1886,17 @@ save_mat5_array_length (const double* va
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
           for (octave_idx_type i = 0; i < nel; i++)
             {
               double tmp = val[i];
 
-              if (xfinite (tmp)
+              if (octave::math::finite (tmp)
                   && fabs (tmp) > std::numeric_limits<float>::max ())
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
 
           if (! too_large_for_float)
@@ -1916,17 +1916,17 @@ save_mat5_array_length (const double* va
       //     double val = val[i];
       //
       //     if (val > max_val)
       //       max_val = val;
       //
       //     if (val < min_val)
       //       min_val = val;
       //
-      //     if (D_NINT (val) != val)
+      //     if (octave::math::x_nint (val) != val)
       //       {
       //         all_integers = false;
       //         break;
       //       }
       //   }
       //
       // if (all_integers)
       //   {
@@ -1971,17 +1971,17 @@ save_mat5_array_length (const float* /* 
       //     float val = val[i];
       //
       //     if (val > max_val)
       //       max_val = val;
       //
       //     if (val < min_val)
       //       min_val = val;
       //
-      //     if (D_NINT (val) != val)
+      //     if (octave::math::x_nint (val) != val)
       //       {
       //         all_integers = false;
       //         break;
       //       }
       //   }
       //
       // if (all_integers)
       //   {
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -39,17 +39,17 @@ do_mgorth (ColumnVector& x, const Matrix
   for (octave_idx_type j = 0; j < Vc; j++)
     {
       ColumnVector Vcj = V.column (j);
       h(j) = RowVector (Vcj.hermitian ()) * x;
       x -= h(j) * Vcj;
     }
 
   h(Vc) = xnorm (x);
-  if (real (h(Vc)) > 0)
+  if (octave::math::real (h(Vc)) > 0)
     x /= h(Vc);
 }
 
 DEFUN (mgorth, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
 Orthogonalize a given column vector @var{x} with respect to a set of\n\
 orthonormal vectors comprising the columns of @var{v} using the modified\n\
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -101,17 +101,17 @@ public:
 
   const octave_handle operator -- (int)
   {
     octave_handle old_value = *this;
     --(*this);
     return old_value;
   }
 
-  bool ok (void) const { return ! xisnan (val); }
+  bool ok (void) const { return ! octave::math::isnan (val); }
 
 private:
   double val;
 };
 
 inline bool
 operator == (const octave_handle& a, const octave_handle& b)
 {
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -92,17 +92,17 @@ convert_to_valid_int (const octave_value
 
       conv_err = 1;
     }
 
   if (! conv_err)
     {
       if (! lo_ieee_isnan (dval))
         {
-          int ival = NINT (dval);
+          int ival = octave::math::nint (dval);
 
           if (ival == dval)
             retval = ival;
           else
             conv_err = 3;
         }
       else
         conv_err = 2;
@@ -114,25 +114,25 @@ convert_to_valid_int (const octave_value
 static int
 get_size (double d, const std::string& who)
 {
   int retval = -1;
 
   if (lo_ieee_isnan (d))
     ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
-  if (xisinf (d))
+  if (octave::math::isinf (d))
     retval = -1;
   else
     {
       if (d < 0.0)
         ::error ("%s: negative value invalid as size specification",
                  who.c_str ());
 
-      retval = NINT (d);
+      retval = octave::math::nint (d);
     }
 
   return retval;
 }
 
 static void
 get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc,
           bool& one_elt_size_spec, const std::string& who)
@@ -154,17 +154,17 @@ get_size (const Array<double>& size, oct
       dnr = size(0);
 
       dnc = (dnr == 0.0) ? 0.0 : 1.0;
     }
   else if (sz_len == 2)
     {
       dnr = size(0);
 
-      if (xisinf (dnr))
+      if (octave::math::isinf (dnr))
         ::error ("%s: invalid size specification", who.c_str ());
 
       dnc = size(1);
     }
   else
     ::error ("%s: invalid size specification", who.c_str ());
 
   nr = get_size (dnr, who);
@@ -2986,17 +2986,17 @@ textscan::scan_complex (delimited_stream
     {
       char *pos = is.tellg ();
       std::ios::iostate state = is.rdstate ();
       //re = octave_read_value<double> (is);
       re = read_double (is, fmt);
 
       // check for "treat as empty" string
       if (treat_as_empty.numel ()
-          && (is.fail () || octave_is_NaN_or_NA (Complex (re))
+          && (is.fail () || octave::math::is_NaN_or_NA (Complex (re))
               || re == octave::numeric_limits<double>::Inf ()))
         {
 
           for (int i = 0; i < treat_as_empty.numel (); i++)
             {
               if (ch == treat_as_empty (i).string_value ()[0])
                 {
                   as_empty = true;   // first char matches, so read the lot
@@ -5360,17 +5360,17 @@ printf_value_cache::get_next_value (char
                   const NDArray val = curr_val.array_value ();
 
                   octave_idx_type idx = elt_idx;
 
                   for (; idx < n_elts; idx++)
                     {
                       double dval = val(idx);
 
-                      if (D_NINT (dval) != dval || dval < 0 || dval > 255)
+                      if (octave::math::x_nint (dval) != dval || dval < 0 || dval > 255)
                         break;
                     }
 
                   octave_idx_type n = idx - elt_idx;
 
                   if (n > 0)
                     {
                       std::string sval (n, '\0');
@@ -5387,17 +5387,17 @@ printf_value_cache::get_next_value (char
           else
             {
               retval = curr_val.fast_elem_extract (elt_idx++);
 
               if (type == 'c' && ! retval.is_string ())
                 {
                   double dval = retval.double_value ();
 
-                  if (D_NINT (dval) == dval && dval >= 0 && dval < 256)
+                  if (octave::math::x_nint (dval) == dval && dval >= 0 && dval < 256)
                     retval = static_cast<char> (dval);
                 }
             }
 
           if (elt_idx >= n_elts)
             {
               elt_idx = 0;
               val_idx++;
@@ -5432,18 +5432,18 @@ int
 printf_value_cache::int_value (void)
 {
   int retval = 0;
 
   octave_value val = get_next_value ();
 
   double dval = val.double_value (true);
 
-  if (D_NINT (dval) == dval)
-    retval = NINT (dval);
+  if (octave::math::x_nint (dval) == dval)
+    retval = octave::math::nint (dval);
   else
     curr_state = conversion_error;
 
   return retval;
 }
 
 // Ugh again and again.
 
@@ -5527,17 +5527,17 @@ ok_for_signed_int_conv (const octave_val
         }
       else
         return true;
     }
   else
     {
       double dval = val.double_value (true);
 
-      if (dval == xround (dval) && dval <= limit)
+      if (dval == octave::math::round (dval) && dval <= limit)
         return true;
     }
 
   return false;
 }
 
 static bool
 ok_for_unsigned_int_conv (const octave_value& val)
@@ -5554,17 +5554,17 @@ ok_for_unsigned_int_conv (const octave_v
       return ov_is_ge_zero.is_true ();
     }
   else
     {
       double dval = val.double_value (true);
 
       uint64_t limit = std::numeric_limits<uint64_t>::max ();
 
-      if (dval == xround (dval) && dval >= 0 && dval <= limit)
+      if (dval == octave::math::round (dval) && dval >= 0 && dval <= limit)
         return true;
     }
 
   return false;
 }
 
 static std::string
 switch_to_g_format (const printf_format_elt *elt)
@@ -6014,17 +6014,17 @@ octave_stream::skipl (const octave_value
   err = false;
 
   int conv_err = 0;
 
   int count = 1;
 
   if (tc_count.is_defined ())
     {
-      if (tc_count.is_scalar_type () && xisinf (tc_count.scalar_value ()))
+      if (tc_count.is_scalar_type () && octave::math::isinf (tc_count.scalar_value ()))
         count = -1;
       else
         {
           count = convert_to_valid_int (tc_count, conv_err);
 
           if (conv_err || count < 0)
             {
               err = true;
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -349,47 +349,47 @@ operator << (std::ostream& os, const pr_
 static inline std::string
 rational_approx (double val, int len)
 {
   std::string s;
 
   if (len <= 0)
     len = 10;
 
-  if (xisinf (val))
+  if (octave::math::isinf (val))
     s = "1/0";
-  else if (xisnan (val))
+  else if (octave::math::isnan (val))
     s = "0/0";
   else if (val < std::numeric_limits<int>::min ()
            || val > std::numeric_limits<int>::max ()
-           || D_NINT (val) == val)
+           || octave::math::x_nint (val) == val)
     {
       std::ostringstream buf;
       buf.flags (std::ios::fixed);
-      buf << std::setprecision (0) << xround (val);
+      buf << std::setprecision (0) << octave::math::round (val);
       s = buf.str ();
     }
   else
     {
       double lastn = 1.;
       double lastd = 0.;
-      double n = xround (val);
+      double n = octave::math::round (val);
       double d = 1.;
       double frac = val - n;
       int m = 0;
 
       std::ostringstream buf2;
       buf2.flags (std::ios::fixed);
       buf2 << std::setprecision (0) << static_cast<int>(n);
       s = buf2.str ();
 
       while (1)
         {
           double flip = 1. / frac;
-          double step = xround (flip);
+          double step = octave::math::round (flip);
           double nextn = n;
           double nextd = d;
 
           // Have we converged to 1/intmax ?
           if (std::abs (flip) > static_cast<double> (std::numeric_limits<int>::max ()))
             {
               lastn = n;
               lastd = d;
@@ -505,17 +505,17 @@ pr_max_internal (const Matrix& m)
   double result = -std::numeric_limits<double>::max ();
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         double val = m(i,j);
-        if (! xfinite (val))
+        if (! octave::math::finite (val))
           continue;
 
         all_inf_or_nan = false;
 
         if (val > result)
           result = val;
       }
 
@@ -534,17 +534,17 @@ pr_min_internal (const Matrix& m)
   double result = std::numeric_limits<double>::max ();
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         double val = m(i,j);
-        if (! xfinite (val))
+        if (! octave::math::finite (val))
           continue;
 
         all_inf_or_nan = false;
 
         if (val < result)
           result = val;
       }
 
@@ -655,19 +655,19 @@ static void
 set_format (double d, int& fw)
 {
   curr_real_fmt = 0;
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
-  bool inf_or_nan = (xisinf (d) || xisnan (d));
-
-  bool int_only = (! inf_or_nan && D_NINT (d) == d);
+  bool inf_or_nan = (octave::math::isinf (d) || octave::math::isnan (d));
+
+  bool int_only = (! inf_or_nan && octave::math::x_nint (d) == d);
 
   double d_abs = d < 0.0 ? -d : d;
 
   int digits = (inf_or_nan || d_abs == 0.0) ? 0 : num_digits (d_abs);
 
   set_real_format (digits, inf_or_nan, int_only, fw);
 }
 
@@ -999,26 +999,26 @@ set_format (const Complex& c, int& r_fw,
   curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   double rp = c.real ();
   double ip = c.imag ();
 
-  bool inf_or_nan = (xisinf (c) || xisnan (c));
-
-  bool int_only = (D_NINT (rp) == rp && D_NINT (ip) == ip);
+  bool inf_or_nan = (octave::math::isinf (c) || octave::math::isnan (c));
+
+  bool int_only = (octave::math::x_nint (rp) == rp && octave::math::x_nint (ip) == ip);
 
   double r_abs = rp < 0.0 ? -rp : rp;
   double i_abs = ip < 0.0 ? -ip : ip;
 
-  int r_x = (! xfinite (rp) || r_abs == 0.0) ? 0 : num_digits (r_abs);
-
-  int i_x = (! xfinite (ip) || i_abs == 0.0) ? 0 : num_digits (i_abs);
+  int r_x = (! octave::math::finite (rp) || r_abs == 0.0) ? 0 : num_digits (r_abs);
+
+  int i_x = (! octave::math::finite (ip) || i_abs == 0.0) ? 0 : num_digits (i_abs);
 
   int x_max, x_min;
 
   if (r_x > i_x)
     {
       x_max = r_x;
       x_min = i_x;
     }
@@ -1517,43 +1517,43 @@ pr_any_float (const float_format *fmt, s
                 }
               else
                 {
                   for (int i = sizeof (double) - 1; i >= 0; i--)
                     PRINT_CHAR_BITS (os, tmp.i[i]);
                 }
             }
         }
-      else if (octave_is_NA (d))
+      else if (octave::math::is_NA (d))
         {
           octave_preserve_stream_state stream_state (os);
 
           if (fw > 0)
             os << std::setw (fw) << "NA";
           else
             os << "NA";
         }
       else if (rat_format)
         os << pr_rational_float (*fmt, d);
-      else if (xisinf (d))
+      else if (octave::math::isinf (d))
         {
           octave_preserve_stream_state stream_state (os);
 
           const char *s;
           if (d < 0.0)
             s = "-Inf";
           else
             s = "Inf";
 
           if (fw > 0)
             os << std::setw (fw) << s;
           else
             os << s;
         }
-      else if (xisnan (d))
+      else if (octave::math::isnan (d))
         {
           octave_preserve_stream_state stream_state (os);
 
           if (fw > 0)
             os << std::setw (fw) << "NaN";
           else
             os << "NaN";
         }
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -214,28 +214,28 @@ variable by routines @code{dblquad} and 
     {
       float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
       float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
 
       int indefinite = 0;
       FloatIndefQuad::IntegralType indef_type
         = FloatIndefQuad::doubly_infinite;
       float bound = 0.0;
-      if (xisinf (a) && xisinf (b))
+      if (octave::math::isinf (a) && octave::math::isinf (b))
         {
           indefinite = 1;
           indef_type = FloatIndefQuad::doubly_infinite;
         }
-      else if (xisinf (a))
+      else if (octave::math::isinf (a))
         {
           indefinite = 1;
           bound = b;
           indef_type = FloatIndefQuad::neg_inf_to_bound;
         }
-      else if (xisinf (b))
+      else if (octave::math::isinf (b))
         {
           indefinite = 1;
           bound = a;
           indef_type = FloatIndefQuad::bound_to_inf;
         }
 
       octave_idx_type ier = 0;
       octave_idx_type nfun = 0;
@@ -307,28 +307,28 @@ variable by routines @code{dblquad} and 
   else
     {
       double a = args(1).xdouble_value ("quad: lower limit of integration A must be a scalar");
       double b = args(2).xdouble_value ("quad: upper limit of integration B must be a scalar");
 
       int indefinite = 0;
       IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
       double bound = 0.0;
-      if (xisinf (a) && xisinf (b))
+      if (octave::math::isinf (a) && octave::math::isinf (b))
         {
           indefinite = 1;
           indef_type = IndefQuad::doubly_infinite;
         }
-      else if (xisinf (a))
+      else if (octave::math::isinf (a))
         {
           indefinite = 1;
           bound = b;
           indef_type = IndefQuad::neg_inf_to_bound;
         }
-      else if (xisinf (b))
+      else if (octave::math::isinf (b))
         {
           indefinite = 1;
           bound = a;
           indef_type = IndefQuad::bound_to_inf;
         }
 
       octave_idx_type ier = 0;
       octave_idx_type nfun = 0;
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1634,21 +1634,21 @@ Mathematical Software, Vol. 37, Issue 3,
       sing = args(4).array_value ().fortran_vec ();
       iivals[0] = a;
       for (i = 0; i < nivals - 1; i++)
         iivals[i + 1] = sing[i];
       iivals[nivals] = b;
     }
 
   // If a or b are +/-Inf, transform the integral.
-  if (xisinf (a) || xisinf (b))
+  if (octave::math::isinf (a) || octave::math::isinf (b))
     {
       wrap = true;
       for (i = 0; i < nivals + 1; i++)
-        if (xisinf (iivals[i]))
+        if (octave::math::isinf (iivals[i]))
           iivals[i] = gnulib::copysign (1.0, iivals[i]);
         else
           iivals[i] = 2.0 * atan (iivals[i]) / M_PI;
     }
 
   // Initialize the heaps.
   for (i = 0; i < cquad_heapsize; i++)
     heap[i] = i;
@@ -1687,17 +1687,17 @@ Mathematical Software, Vol. 37, Issue 3,
         {
           iv->fx[i] = effex(i);
           if (wrap)
             {
               xw = ex(i);
               iv->fx[i] *= (1.0 + xw * xw) * M_PI / 2;
             }
           neval++;
-          if (! xfinite (iv->fx[i]))
+          if (! octave::math::finite (iv->fx[i]))
             {
               nans[nnans++] = i;
               iv->fx[i] = 0.0;
             }
         }
       Vinvfx (iv->fx, &(iv->c[idx[3]]), 3);
       Vinvfx (iv->fx, &(iv->c[idx[2]]), 2);
       Vinvfx (iv->fx, &(iv->c[0]), 0);
@@ -1803,17 +1803,17 @@ Mathematical Software, Vol. 37, Issue 3,
                     xw = ex(i);
                     iv->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[d])
             {
-              if (! xfinite (iv->fx[i]))
+              if (! octave::math::finite (iv->fx[i]))
                 {
                   nans[nnans++] = i;
                   iv->fx[i] = 0.0;
                 }
             }
 
           // Compute the new coefficients.
           Vinvfx (iv->fx, &(iv->c[idx[d]]), d);
@@ -1940,17 +1940,17 @@ Mathematical Software, Vol. 37, Issue 3,
                     xw = ex(i);
                     ivl->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[0])
             {
-              if (! xfinite (ivl->fx[i]))
+              if (! octave::math::finite (ivl->fx[i]))
                 {
                   nans[nnans++] = i;
                   ivl->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivl->fx, ivl->c, 0);
           if (nnans > 0)
             {
@@ -2031,17 +2031,17 @@ Mathematical Software, Vol. 37, Issue 3,
                     xw = ex(i);
                     ivr->fx[j] *= (1.0 + xw * xw) * M_PI / 2;
                   }
               }
           }
           nnans = 0;
           for (i = 0; i <= 32; i += skip[0])
             {
-              if (! xfinite (ivr->fx[i]))
+              if (! octave::math::finite (ivr->fx[i]))
                 {
                   nans[nnans++] = i;
                   ivr->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivr->fx, ivr->c, 0);
           if (nnans > 0)
             {
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -143,39 +143,39 @@ do_rand (const octave_value_list& args, 
               octave_rand::gamma_distribution ();
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else if (tmp.is_scalar_type ())
           {
             double dval = tmp.double_value ();
 
-            if (xisnan (dval))
+            if (octave::math::isnan (dval))
               error ("%s: NaN is invalid matrix dimension", fcn);
 
             dims.resize (2);
 
-            dims(0) = NINTbig (tmp.double_value ());
-            dims(1) = NINTbig (tmp.double_value ());
+            dims(0) = octave::math::nint_big (tmp.double_value ());
+            dims(1) = octave::math::nint_big (tmp.double_value ());
 
             goto gen_matrix;
           }
         else if (tmp.is_range ())
           {
             Range r = tmp.range_value ();
 
             if (! r.all_elements_are_ints ())
               error ("%s: all elements of range must be integers", fcn);
 
             octave_idx_type n = r.numel ();
 
             dims.resize (n);
 
-            octave_idx_type base = NINTbig (r.base ());
-            octave_idx_type incr = NINTbig (r.inc ());
+            octave_idx_type base = octave::math::nint_big (r.base ());
+            octave_idx_type incr = octave::math::nint_big (r.inc ());
 
             for (octave_idx_type i = 0; i < n; i++)
               {
                 // Negative dimensions treated as zero for Matlab compatibility
                 dims(i) = base >= 0 ? base : 0;
                 base += incr;
               }
 
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "sparse-xpow.h"
 
 static inline int
 xisint (double x)
 {
-  return (D_NINT (x) == x
+  return (octave::math::x_nint (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 
 // Safer pow functions.  Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -140,17 +140,17 @@ longer running time.\n\
                 }
               octave_sparse_params::defaults ();
             }
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
-              if (xisnan (val))
+              if (octave::math::isnan (val))
                 error ("spparms: KEY not recognized");
 
               retval = ovl (val);
             }
         }
       else
         {
           NDArray vals = args(0).xarray_value ("spparms: input must be a string or a vector");
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -790,23 +790,23 @@ clc;\n\
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
-      if (xisnan (dval))
+      if (octave::math::isnan (dval))
         warning ("pause: NaN is an invalid delay");
       else
         {
           Fdrawnow ();
 
-          if (xisinf (dval))
+          if (octave::math::isinf (dval))
             {
               flush_octave_stdout ();
               octave_kbhit ();
             }
           else
             octave_sleep (dval);
         }
     }
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -159,17 +159,17 @@ private:
   double next_handle;
 
   curl_handle do_get_handle (void);
 
   void do_free (const curl_handle& h);
 
   curl_handle do_lookup (double val)
   {
-    iterator p = (xisnan (val) ? handle_map.end () : handle_map.find (val));
+    iterator p = (octave::math::isnan (val) ? handle_map.end () : handle_map.find (val));
 
     return (p != handle_map.end ()) ? p->first : curl_handle ();
   }
 
   octave::url_transfer do_get_object (const curl_handle& h)
   {
     iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1160,18 +1160,18 @@ get_dimensions (const octave_value& a, c
     {
       nr = a.rows ();
       nc = a.columns ();
 
       if ((nr != 1 || nc != 2) && (nr != 2 || nc != 1))
         error ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
 
       Array<double> v = a.vector_value ();
-      nr = static_cast<octave_idx_type> (fix (v(0)));
-      nc = static_cast<octave_idx_type> (fix (v(1)));
+      nr = static_cast<octave_idx_type> (octave::math::fix (v(0)));
+      nc = static_cast<octave_idx_type> (octave::math::fix (v(1)));
     }
 
   check_dimensions (nr, nc, warn_for);
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -65,17 +65,17 @@ static void
 err_nonsquare_matrix (void)
 {
   error ("for x^A, A must be a square matrix.  Use .^ for elementwise power.");
 }
 
 static inline int
 xisint (double x)
 {
-  return (D_NINT (x) == x
+  return (octave::math::x_nint (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
@@ -1473,17 +1473,17 @@ elem_xpow (const ComplexNDArray& a, cons
     }
 
   return result;
 }
 
 static inline int
 xisint (float x)
 {
-  return (D_NINT (x) == x
+  return (octave::math::x_nint (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 // Safer pow functions.
 //
 //       op2 \ op1:   s   m   cs   cm
 //            +--   +---+---+----+----+
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -414,17 +414,17 @@ Undocumented internal function.\n\
     error ("__glpk__: invalid dimensions for LB");
 
   double *lb = LB.fortran_vec ();
 
   // LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
-      if (xisinf (lb[i]))
+      if (octave::math::isinf (lb[i]))
         {
           freeLB(i) = 1;
           lb[i] = -octave::numeric_limits<double>::Inf ();
         }
       else
         freeLB(i) = 0;
     }
 
@@ -435,17 +435,17 @@ Undocumented internal function.\n\
   if (UB.numel () < mrowsc)
     error ("__glpk__: invalid dimensions for UB");
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
-      if (xisinf (ub[i]))
+      if (octave::math::isinf (ub[i]))
         {
           freeUB(i) = 1;
           ub[i] = octave::numeric_limits<double>::Inf ();
         }
       else
         freeUB(i) = 0;
     }
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -104,21 +104,21 @@ is stored in the audio file.\n\
 
   if ((nargin == 2 && ! args(1).is_string ()) || nargin == 3)
     {
       RowVector range = args(1).row_vector_value ();
 
       if (range.numel () != 2)
         error ("audioread: invalid specification for range of frames");
 
-      double dstart = xisinf (range(0)) ? info.frames : range(0);
-      double dend = xisinf (range(1)) ? info.frames : range(1);
+      double dstart = octave::math::isinf (range(0)) ? info.frames : range(0);
+      double dend = octave::math::isinf (range(1)) ? info.frames : range(1);
 
       if (dstart < 1 || dstart > dend || dend > info.frames
-          || D_NINT (dstart) != dstart || D_NINT (dend) != dend)
+          || octave::math::x_nint (dstart) != dstart || octave::math::x_nint (dend) != dend)
         error ("audioread: invalid specification for range of frames");
 
       start = dstart - 1;
       end = dend;
     }
 
   sf_count_t items = end - start;
 
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -134,17 +134,17 @@ octave_base_scalar<ST>::diag (octave_idx
 {
   return Array<ST> (dim_vector (1, 1), scalar).diag (m, n);
 }
 
 template <typename ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
-  if (xisnan (scalar))
+  if (octave::math::isnan (scalar))
     err_nan_to_logical_conversion ();
 
   return (scalar != ST ());
 }
 
 template <typename ST>
 void
 octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax)
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -446,24 +446,24 @@ octave_base_value::print_info (std::ostr
       { \
         d = double_value (frc_str_conv); \
       } \
     catch (octave_execution_exception& e) \
       { \
         err_wrong_type_arg (e, "octave_base_value::" #F "_value ()", type_name ()); \
       } \
  \
-    if (require_int && D_NINT (d) != d) \
+    if (require_int && octave::math::x_nint (d) != d) \
       error_with_cfn ("conversion of %g to " #T " value failed", d); \
     else if (d < std::numeric_limits<T>::min ()) \
       retval = std::numeric_limits<T>::min (); \
     else if (d > std::numeric_limits<T>::max ()) \
       retval = std::numeric_limits<T>::max (); \
     else \
-      retval = static_cast<T> (::fix (d)); \
+      retval = static_cast<T> (octave::math::fix (d)); \
  \
     return retval; \
   }
 
 INT_CONV_METHOD (short int, short)
 INT_CONV_METHOD (unsigned short int, ushort)
 
 INT_CONV_METHOD (int, int)
@@ -484,20 +484,20 @@ octave_base_value::nint_value (bool frc_
     {
       d = double_value (frc_str_conv);
     }
   catch (octave_execution_exception& e)
     {
       err_wrong_type_arg (e, "octave_base_value::nint_value ()", type_name ());
     }
 
-  if (xisnan (d))
+  if (octave::math::isnan (d))
     error ("conversion of NaN to integer value failed");
 
-  return static_cast<int> (::fix (d));
+  return static_cast<int> (octave::math::fix (d));
 }
 
 double
 octave_base_value::double_value (bool) const
 {
   err_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
 }
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -477,52 +477,52 @@ octave_complex::map (unary_mapper_t umap
 {
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
-      SCALAR_MAPPER (acos, ::acos);
+      SCALAR_MAPPER (acos, octave::math::acos);
       SCALAR_MAPPER (acosh, xacosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
-      SCALAR_MAPPER (asin, ::asin);
+      SCALAR_MAPPER (asin, octave::math::asin);
       SCALAR_MAPPER (asinh, xasinh);
-      SCALAR_MAPPER (atan, ::atan);
+      SCALAR_MAPPER (atan, octave::math::atan);
       SCALAR_MAPPER (atanh, xatanh);
       SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
-      SCALAR_MAPPER (ceil, ::ceil);
+      SCALAR_MAPPER (ceil, octave::math::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
       SCALAR_MAPPER (expm1, xexpm1);
-      SCALAR_MAPPER (fix, ::fix);
-      SCALAR_MAPPER (floor, ::floor);
+      SCALAR_MAPPER (fix, octave::math::fix);
+      SCALAR_MAPPER (floor, octave::math::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
-      SCALAR_MAPPER (log2, xlog2);
+      SCALAR_MAPPER (log2, octave::math::log2);
       SCALAR_MAPPER (log10, std::log10);
       SCALAR_MAPPER (log1p, xlog1p);
       SCALAR_MAPPER (real, std::real);
-      SCALAR_MAPPER (round, xround);
-      SCALAR_MAPPER (roundb, xroundb);
-      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (round, octave::math::round);
+      SCALAR_MAPPER (roundb, octave::math::roundb);
+      SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
       SCALAR_MAPPER (tanh, std::tanh);
-      SCALAR_MAPPER (isfinite, xfinite);
-      SCALAR_MAPPER (isinf, xisinf);
-      SCALAR_MAPPER (isna, octave_is_NA);
-      SCALAR_MAPPER (isnan, xisnan);
+      SCALAR_MAPPER (isfinite, octave::math::finite);
+      SCALAR_MAPPER (isinf, octave::math::isinf);
+      SCALAR_MAPPER (isna, octave::math::is_NA);
+      SCALAR_MAPPER (isnan, octave::math::isnan);
 
     default:
       return octave_base_value::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -135,27 +135,27 @@ public:
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return scalar != 0.0;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0 && scalar != 1.0)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 0.0);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -760,46 +760,46 @@ octave_complex_matrix::map (unary_mapper
       ARRAY_METHOD_MAPPER (isnan, isnan);
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, ::acos);
+      ARRAY_MAPPER (acos, Complex, octave::math::acos);
       ARRAY_MAPPER (acosh, Complex, xacosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
-      ARRAY_MAPPER (asin, Complex, ::asin);
+      ARRAY_MAPPER (asin, Complex, octave::math::asin);
       ARRAY_MAPPER (asinh, Complex, xasinh);
-      ARRAY_MAPPER (atan, Complex, ::atan);
+      ARRAY_MAPPER (atan, Complex, octave::math::atan);
       ARRAY_MAPPER (atanh, Complex, xatanh);
       ARRAY_MAPPER (erf, Complex, xerf);
       ARRAY_MAPPER (erfc, Complex, xerfc);
       ARRAY_MAPPER (erfcx, Complex, ::erfcx);
       ARRAY_MAPPER (erfi, Complex, ::erfi);
       ARRAY_MAPPER (dawson, Complex, ::dawson);
-      ARRAY_MAPPER (ceil, Complex, ::ceil);
+      ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
       ARRAY_MAPPER (expm1, Complex, xexpm1);
-      ARRAY_MAPPER (fix, Complex, ::fix);
-      ARRAY_MAPPER (floor, Complex, ::floor);
+      ARRAY_MAPPER (fix, Complex, octave::math::fix);
+      ARRAY_MAPPER (floor, Complex, octave::math::floor);
       ARRAY_MAPPER (log, Complex, std::log);
-      ARRAY_MAPPER (log2, Complex, xlog2);
+      ARRAY_MAPPER (log2, Complex, octave::math::log2);
       ARRAY_MAPPER (log10, Complex, std::log10);
       ARRAY_MAPPER (log1p, Complex, xlog1p);
-      ARRAY_MAPPER (round, Complex, xround);
-      ARRAY_MAPPER (roundb, Complex, xroundb);
-      ARRAY_MAPPER (signum, Complex, ::signum);
+      ARRAY_MAPPER (round, Complex, octave::math::round);
+      ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
+      ARRAY_MAPPER (signum, Complex, octave::math::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
 
     default:
       return octave_base_value::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -913,50 +913,50 @@ octave_sparse_complex_matrix::map (unary
       return octave_value (matrix.FCN ())
 
       ARRAY_METHOD_MAPPER (abs, abs);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, ::acos);
+      ARRAY_MAPPER (acos, Complex, octave::math::acos);
       ARRAY_MAPPER (acosh, Complex, xacosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
-      ARRAY_MAPPER (asin, Complex, ::asin);
+      ARRAY_MAPPER (asin, Complex, octave::math::asin);
       ARRAY_MAPPER (asinh, Complex, xasinh);
-      ARRAY_MAPPER (atan, Complex, ::atan);
+      ARRAY_MAPPER (atan, Complex, octave::math::atan);
       ARRAY_MAPPER (atanh, Complex, xatanh);
       ARRAY_MAPPER (erf, Complex, xerf);
       ARRAY_MAPPER (erfc, Complex, xerfc);
       ARRAY_MAPPER (erfcx, Complex, ::erfcx);
       ARRAY_MAPPER (erfi, Complex, ::erfi);
       ARRAY_MAPPER (dawson, Complex, ::dawson);
-      ARRAY_MAPPER (ceil, Complex, ::ceil);
+      ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
       ARRAY_MAPPER (conj, Complex, std::conj<double>);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
       ARRAY_MAPPER (expm1, Complex, xexpm1);
-      ARRAY_MAPPER (fix, Complex, ::fix);
-      ARRAY_MAPPER (floor, Complex, ::floor);
+      ARRAY_MAPPER (fix, Complex, octave::math::fix);
+      ARRAY_MAPPER (floor, Complex, octave::math::floor);
       ARRAY_MAPPER (log, Complex, std::log);
-      ARRAY_MAPPER (log2, Complex, xlog2);
+      ARRAY_MAPPER (log2, Complex, octave::math::log2);
       ARRAY_MAPPER (log10, Complex, std::log10);
       ARRAY_MAPPER (log1p, Complex, xlog1p);
-      ARRAY_MAPPER (round, Complex, xround);
-      ARRAY_MAPPER (roundb, Complex, xroundb);
-      ARRAY_MAPPER (signum, Complex, ::signum);
+      ARRAY_MAPPER (round, Complex, octave::math::round);
+      ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
+      ARRAY_MAPPER (signum, Complex, octave::math::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
-      ARRAY_MAPPER (isnan, bool, xisnan);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
-      ARRAY_MAPPER (isinf, bool, xisinf);
-      ARRAY_MAPPER (isfinite, bool, xfinite);
+      ARRAY_MAPPER (isnan, bool, octave::math::isnan);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+      ARRAY_MAPPER (isinf, bool, octave::math::isinf);
+      ARRAY_MAPPER (isfinite, bool, octave::math::finite);
 
     default: // Attempt to go via dense matrix.
       return octave_base_sparse<SparseComplexMatrix>::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -105,20 +105,20 @@ octave_float_scalar::diag (octave_idx_ty
   return FloatDiagMatrix (Array<float> (dim_vector (1, 1), scalar), m, n);
 }
 
 octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
-  if (xisnan (scalar))
+  if (octave::math::isnan (scalar))
     err_nan_to_character_conversion ();
 
-  int ival = NINT (scalar);
+  int ival = octave::math::nint (scalar);
 
   if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
     {
       // FIXME: is there something better we could do?
 
       ival = 0;
 
       ::warning ("range error for conversion to character value");
@@ -292,58 +292,57 @@ octave_float_scalar::map (unary_mapper_t
     case umap_conj:
       return scalar;
 
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabsf);
-      SCALAR_MAPPER (acos, rc_acos);
-      SCALAR_MAPPER (acosh, rc_acosh);
-      SCALAR_MAPPER (angle, ::arg);
-      SCALAR_MAPPER (arg, ::arg);
-      SCALAR_MAPPER (asin, rc_asin);
+      SCALAR_MAPPER (acos, octave::math::rc_acos);
+      SCALAR_MAPPER (acosh, octave::math::rc_acosh);
+      SCALAR_MAPPER (angle, octave::math::arg);
+      SCALAR_MAPPER (asin, octave::math::rc_asin);
       SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atanf);
-      SCALAR_MAPPER (atanh, rc_atanh);
+      SCALAR_MAPPER (atanh, octave::math::rc_atanh);
       SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, xcbrt);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
       SCALAR_MAPPER (exp, ::expf);
       SCALAR_MAPPER (expm1, xexpm1);
-      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, gnulib::floorf);
-      SCALAR_MAPPER (log, rc_log);
-      SCALAR_MAPPER (log2, rc_log2);
-      SCALAR_MAPPER (log10, rc_log10);
+      SCALAR_MAPPER (log, octave::math::rc_log);
+      SCALAR_MAPPER (log2, octave::math::rc_log2);
+      SCALAR_MAPPER (log10, octave::math::rc_log10);
       SCALAR_MAPPER (log1p, rc_log1p);
-      SCALAR_MAPPER (round, xround);
-      SCALAR_MAPPER (roundb, xroundb);
-      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (round, octave::math::round);
+      SCALAR_MAPPER (roundb, octave::math::roundb);
+      SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sinf);
       SCALAR_MAPPER (sinh, ::sinhf);
-      SCALAR_MAPPER (sqrt, rc_sqrt);
+      SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
       SCALAR_MAPPER (tan, ::tanf);
       SCALAR_MAPPER (tanh, ::tanhf);
-      SCALAR_MAPPER (isfinite, xfinite);
-      SCALAR_MAPPER (isinf, xisinf);
-      SCALAR_MAPPER (isna, octave_is_NA);
-      SCALAR_MAPPER (isnan, xisnan);
-      SCALAR_MAPPER (xsignbit, xsignbit);
+      SCALAR_MAPPER (isfinite, octave::math::finite);
+      SCALAR_MAPPER (isinf, octave::math::isinf);
+      SCALAR_MAPPER (isna, octave::math::is_NA);
+      SCALAR_MAPPER (isnan, octave::math::isnan);
+      SCALAR_MAPPER (xsignbit, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return scalar;
 
     case umap_xisalnum:
     case umap_xisalpha:
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -193,27 +193,27 @@ public:
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -427,52 +427,52 @@ octave_float_complex::map (unary_mapper_
 {
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
-      SCALAR_MAPPER (acos, ::acos);
+      SCALAR_MAPPER (acos, octave::math::acos);
       SCALAR_MAPPER (acosh, xacosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
-      SCALAR_MAPPER (asin, ::asin);
+      SCALAR_MAPPER (asin, octave::math::asin);
       SCALAR_MAPPER (asinh, xasinh);
-      SCALAR_MAPPER (atan, ::atan);
+      SCALAR_MAPPER (atan, octave::math::atan);
       SCALAR_MAPPER (atanh, xatanh);
       SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
-      SCALAR_MAPPER (ceil, ::ceil);
+      SCALAR_MAPPER (ceil, octave::math::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
       SCALAR_MAPPER (expm1, xexpm1);
-      SCALAR_MAPPER (fix, ::fix);
-      SCALAR_MAPPER (floor, ::floor);
+      SCALAR_MAPPER (fix, octave::math::fix);
+      SCALAR_MAPPER (floor, octave::math::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
-      SCALAR_MAPPER (log2, xlog2);
+      SCALAR_MAPPER (log2, octave::math::log2);
       SCALAR_MAPPER (log10, std::log10);
       SCALAR_MAPPER (log1p, xlog1p);
       SCALAR_MAPPER (real, std::real);
-      SCALAR_MAPPER (round, xround);
-      SCALAR_MAPPER (roundb, xroundb);
-      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (round, octave::math::round);
+      SCALAR_MAPPER (roundb, octave::math::roundb);
+      SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
       SCALAR_MAPPER (tanh, std::tanh);
-      SCALAR_MAPPER (isfinite, xfinite);
-      SCALAR_MAPPER (isinf, xisinf);
-      SCALAR_MAPPER (isna, octave_is_NA);
-      SCALAR_MAPPER (isnan, xisnan);
+      SCALAR_MAPPER (isfinite, octave::math::finite);
+      SCALAR_MAPPER (isinf, octave::math::isinf);
+      SCALAR_MAPPER (isna, octave::math::is_NA);
+      SCALAR_MAPPER (isnan, octave::math::isnan);
 
     default:
       return octave_base_value::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -131,27 +131,27 @@ public:
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return scalar != 0.0f;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0.0f && scalar != 1.0f)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 1.0f);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -710,46 +710,46 @@ octave_float_complex_matrix::map (unary_
       ARRAY_METHOD_MAPPER (isnan, isnan);
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, FloatComplex, ::acos);
+      ARRAY_MAPPER (acos, FloatComplex, octave::math::acos);
       ARRAY_MAPPER (acosh, FloatComplex, xacosh);
       ARRAY_MAPPER (angle, float, std::arg);
       ARRAY_MAPPER (arg, float, std::arg);
-      ARRAY_MAPPER (asin, FloatComplex, ::asin);
+      ARRAY_MAPPER (asin, FloatComplex, octave::math::asin);
       ARRAY_MAPPER (asinh, FloatComplex, xasinh);
-      ARRAY_MAPPER (atan, FloatComplex, ::atan);
+      ARRAY_MAPPER (atan, FloatComplex, octave::math::atan);
       ARRAY_MAPPER (atanh, FloatComplex, xatanh);
       ARRAY_MAPPER (erf, FloatComplex, xerf);
       ARRAY_MAPPER (erfc, FloatComplex, xerfc);
       ARRAY_MAPPER (erfcx, FloatComplex, ::erfcx);
       ARRAY_MAPPER (erfi, FloatComplex, ::erfi);
       ARRAY_MAPPER (dawson, FloatComplex, ::dawson);
-      ARRAY_MAPPER (ceil, FloatComplex, ::ceil);
+      ARRAY_MAPPER (ceil, FloatComplex, octave::math::ceil);
       ARRAY_MAPPER (cos, FloatComplex, std::cos);
       ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
       ARRAY_MAPPER (exp, FloatComplex, std::exp);
       ARRAY_MAPPER (expm1, FloatComplex, xexpm1);
-      ARRAY_MAPPER (fix, FloatComplex, ::fix);
-      ARRAY_MAPPER (floor, FloatComplex, ::floor);
+      ARRAY_MAPPER (fix, FloatComplex, octave::math::fix);
+      ARRAY_MAPPER (floor, FloatComplex, octave::math::floor);
       ARRAY_MAPPER (log, FloatComplex, std::log);
-      ARRAY_MAPPER (log2, FloatComplex, xlog2);
+      ARRAY_MAPPER (log2, FloatComplex, octave::math::log2);
       ARRAY_MAPPER (log10, FloatComplex, std::log10);
       ARRAY_MAPPER (log1p, FloatComplex, xlog1p);
-      ARRAY_MAPPER (round, FloatComplex, xround);
-      ARRAY_MAPPER (roundb, FloatComplex, xroundb);
-      ARRAY_MAPPER (signum, FloatComplex, ::signum);
+      ARRAY_MAPPER (round, FloatComplex, octave::math::round);
+      ARRAY_MAPPER (roundb, FloatComplex, octave::math::roundb);
+      ARRAY_MAPPER (signum, FloatComplex, octave::math::signum);
       ARRAY_MAPPER (sin, FloatComplex, std::sin);
       ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
       ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
       ARRAY_MAPPER (tan, FloatComplex, std::tan);
       ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
 
     default:
       return octave_base_value::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -98,17 +98,17 @@ octave_float_diag_matrix::map (unary_map
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
         FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex>
-                                       (rc_sqrt);
+                                       (octave::math::rc_sqrt);
         FloatComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -276,20 +276,20 @@ octave_float_matrix::convert_to_str_inte
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       float d = matrix(i);
 
-      if (xisnan (d))
+      if (octave::math::isnan (d))
         err_nan_to_character_conversion ();
 
-      int ival = NINT (d);
+      int ival = octave::math::nint (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
           ival = 0;
 
           if (! warned)
@@ -738,55 +738,55 @@ octave_float_matrix::map (unary_mapper_t
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
 #define RC_ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
-      RC_ARRAY_MAPPER (acos, FloatComplex, rc_acos);
-      RC_ARRAY_MAPPER (acosh, FloatComplex, rc_acosh);
-      ARRAY_MAPPER (angle, float, ::arg);
-      ARRAY_MAPPER (arg, float, ::arg);
-      RC_ARRAY_MAPPER (asin, FloatComplex, rc_asin);
+      RC_ARRAY_MAPPER (acos, FloatComplex, octave::math::rc_acos);
+      RC_ARRAY_MAPPER (acosh, FloatComplex, octave::math::rc_acosh);
+      ARRAY_MAPPER (angle, float, octave::math::arg);
+      ARRAY_MAPPER (arg, float,octave::math ::arg);
+      RC_ARRAY_MAPPER (asin, FloatComplex, octave::math::rc_asin);
       ARRAY_MAPPER (asinh, float, xasinh);
       ARRAY_MAPPER (atan, float, ::atanf);
-      RC_ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
+      RC_ARRAY_MAPPER (atanh, FloatComplex, octave::math::rc_atanh);
       ARRAY_MAPPER (erf, float, xerf);
       ARRAY_MAPPER (erfinv, float, ::erfinv);
       ARRAY_MAPPER (erfcinv, float, ::erfcinv);
       ARRAY_MAPPER (erfc, float, xerfc);
       ARRAY_MAPPER (erfcx, float, ::erfcx);
       ARRAY_MAPPER (erfi, float, ::erfi);
       ARRAY_MAPPER (dawson, float, ::dawson);
       ARRAY_MAPPER (gamma, float, xgamma);
       RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
       ARRAY_MAPPER (cbrt, float, xcbrt);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
       ARRAY_MAPPER (exp, float, ::expf);
       ARRAY_MAPPER (expm1, float, xexpm1);
-      ARRAY_MAPPER (fix, float, ::fix);
+      ARRAY_MAPPER (fix, float, octave::math::fix);
       ARRAY_MAPPER (floor, float, ::floorf);
-      RC_ARRAY_MAPPER (log, FloatComplex, rc_log);
-      RC_ARRAY_MAPPER (log2, FloatComplex, rc_log2);
-      RC_ARRAY_MAPPER (log10, FloatComplex, rc_log10);
+      RC_ARRAY_MAPPER (log, FloatComplex, octave::math::rc_log);
+      RC_ARRAY_MAPPER (log2, FloatComplex, octave::math::rc_log2);
+      RC_ARRAY_MAPPER (log10, FloatComplex, octave::math::rc_log10);
       RC_ARRAY_MAPPER (log1p, FloatComplex, rc_log1p);
-      ARRAY_MAPPER (round, float, xround);
-      ARRAY_MAPPER (roundb, float, xroundb);
-      ARRAY_MAPPER (signum, float, ::signum);
+      ARRAY_MAPPER (round, float, octave::math::round);
+      ARRAY_MAPPER (roundb, float, octave::math::roundb);
+      ARRAY_MAPPER (signum, float, octave::math::signum);
       ARRAY_MAPPER (sin, float, ::sinf);
       ARRAY_MAPPER (sinh, float, ::sinhf);
-      RC_ARRAY_MAPPER (sqrt, FloatComplex, rc_sqrt);
+      RC_ARRAY_MAPPER (sqrt, FloatComplex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, float, ::tanf);
       ARRAY_MAPPER (tanh, float, ::tanhf);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
-      ARRAY_MAPPER (xsignbit, float, xsignbit);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+      ARRAY_MAPPER (xsignbit, float, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return matrix;
 
     case umap_xisalnum:
     case umap_xisalpha:
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -166,17 +166,17 @@ octave_diag_matrix::map (unary_mapper_t 
       return matrix.abs ();
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
-        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (rc_sqrt);
+        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (octave::math::rc_sqrt);
         ComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -378,20 +378,20 @@ octave_matrix::convert_to_str_internal (
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       double d = matrix(i);
 
-      if (xisnan (d))
+      if (octave::math::isnan (d))
         err_nan_to_character_conversion ();
 
-      int ival = NINT (d);
+      int ival = octave::math::nint (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
           ival = 0;
 
           if (! warned)
@@ -863,55 +863,55 @@ octave_matrix::map (unary_mapper_t umap)
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
 #define RC_ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
-      RC_ARRAY_MAPPER (acos, Complex, rc_acos);
-      RC_ARRAY_MAPPER (acosh, Complex, rc_acosh);
-      ARRAY_MAPPER (angle, double, ::arg);
-      ARRAY_MAPPER (arg, double, ::arg);
-      RC_ARRAY_MAPPER (asin, Complex, rc_asin);
+      RC_ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
+      RC_ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
+      ARRAY_MAPPER (angle, double, octave::math::arg);
+      ARRAY_MAPPER (arg, double,octave::math ::arg);
+      RC_ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
       ARRAY_MAPPER (asinh, double, xasinh);
       ARRAY_MAPPER (atan, double, ::atan);
-      RC_ARRAY_MAPPER (atanh, Complex, rc_atanh);
+      RC_ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
       ARRAY_MAPPER (erf, double, xerf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, xerfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (erfi, double, ::erfi);
       ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, xcbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
       ARRAY_MAPPER (expm1, double, xexpm1);
-      ARRAY_MAPPER (fix, double, ::fix);
+      ARRAY_MAPPER (fix, double, octave::math::fix);
       ARRAY_MAPPER (floor, double, ::floor);
-      RC_ARRAY_MAPPER (log, Complex, rc_log);
-      RC_ARRAY_MAPPER (log2, Complex, rc_log2);
-      RC_ARRAY_MAPPER (log10, Complex, rc_log10);
+      RC_ARRAY_MAPPER (log, Complex, octave::math::rc_log);
+      RC_ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
+      RC_ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
       RC_ARRAY_MAPPER (log1p, Complex, rc_log1p);
-      ARRAY_MAPPER (round, double, xround);
-      ARRAY_MAPPER (roundb, double, xroundb);
-      ARRAY_MAPPER (signum, double, ::signum);
+      ARRAY_MAPPER (round, double, octave::math::round);
+      ARRAY_MAPPER (roundb, double, octave::math::roundb);
+      ARRAY_MAPPER (signum, double, octave::math::signum);
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
-      RC_ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
+      RC_ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
-      ARRAY_MAPPER (xsignbit, double, xsignbit);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+      ARRAY_MAPPER (xsignbit, double, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return matrix;
 
     case umap_xisalnum:
     case umap_xisalpha:
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -214,20 +214,20 @@ octave_sparse_matrix::convert_to_str_int
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j);
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
-            if (xisnan (d))
+            if (octave::math::isnan (d))
               err_nan_to_character_conversion ();
 
-            int ival = NINT (d);
+            int ival = octave::math::nint (d);
 
             if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
               {
                 // FIXME: is there something better we could do?
 
                 ival = 0;
 
                 if (! warned)
@@ -902,54 +902,54 @@ octave_sparse_matrix::map (unary_mapper_
       return octave_value (matrix.FCN ())
 
       ARRAY_METHOD_MAPPER (abs, abs);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
-      ARRAY_MAPPER (acos, Complex, rc_acos);
-      ARRAY_MAPPER (acosh, Complex, rc_acosh);
-      ARRAY_MAPPER (angle, double, ::arg);
-      ARRAY_MAPPER (arg, double, ::arg);
-      ARRAY_MAPPER (asin, Complex, rc_asin);
+      ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
+      ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
+      ARRAY_MAPPER (angle, double, octave::math::arg);
+      ARRAY_MAPPER (arg, double,octave::math ::arg);
+      ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
       ARRAY_MAPPER (asinh, double, xasinh);
       ARRAY_MAPPER (atan, double, ::atan);
-      ARRAY_MAPPER (atanh, Complex, rc_atanh);
+      ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
       ARRAY_MAPPER (erf, double, xerf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, xerfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
       ARRAY_MAPPER (erfi, double, ::erfi);
       ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, xcbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
       ARRAY_MAPPER (expm1, double, xexpm1);
-      ARRAY_MAPPER (fix, double, ::fix);
+      ARRAY_MAPPER (fix, double, octave::math::fix);
       ARRAY_MAPPER (floor, double, ::floor);
-      ARRAY_MAPPER (log, Complex, rc_log);
-      ARRAY_MAPPER (log2, Complex, rc_log2);
-      ARRAY_MAPPER (log10, Complex, rc_log10);
+      ARRAY_MAPPER (log, Complex, octave::math::rc_log);
+      ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
+      ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
       ARRAY_MAPPER (log1p, Complex, rc_log1p);
-      ARRAY_MAPPER (round, double, xround);
-      ARRAY_MAPPER (roundb, double, xroundb);
-      ARRAY_MAPPER (signum, double, ::signum);
+      ARRAY_MAPPER (round, double, octave::math::round);
+      ARRAY_MAPPER (roundb, double, octave::math::roundb);
+      ARRAY_MAPPER (signum, double, octave::math::signum);
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
-      ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
+      ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
-      ARRAY_MAPPER (isnan, bool, xisnan);
-      ARRAY_MAPPER (isna, bool, octave_is_NA);
-      ARRAY_MAPPER (isinf, bool, xisinf);
-      ARRAY_MAPPER (isfinite, bool, xfinite);
+      ARRAY_MAPPER (isnan, bool, octave::math::isnan);
+      ARRAY_MAPPER (isna, bool, octave::math::is_NA);
+      ARRAY_MAPPER (isinf, bool, octave::math::isinf);
+      ARRAY_MAPPER (isfinite, bool, octave::math::finite);
 
     default: // Attempt to go via dense matrix.
       return octave_base_sparse<SparseMatrix>::map (umap);
     }
 }
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -126,20 +126,20 @@ octave_scalar::diag (octave_idx_type m, 
   return DiagMatrix (Array<double> (dim_vector (1, 1), scalar), m, n);
 }
 
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
-  if (xisnan (scalar))
+  if (octave::math::isnan (scalar))
     err_nan_to_character_conversion ();
 
-  int ival = NINT (scalar);
+  int ival = octave::math::nint (scalar);
 
   if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
     {
       // FIXME: is there something better we could do?
 
       ival = 0;
 
       ::warning ("range error for conversion to character value");
@@ -315,58 +315,58 @@ octave_scalar::map (unary_mapper_t umap)
     case umap_conj:
       return scalar;
 
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabs);
-      SCALAR_MAPPER (acos, rc_acos);
-      SCALAR_MAPPER (acosh, rc_acosh);
-      SCALAR_MAPPER (angle, ::arg);
-      SCALAR_MAPPER (arg, ::arg);
-      SCALAR_MAPPER (asin, rc_asin);
+      SCALAR_MAPPER (acos, octave::math::rc_acos);
+      SCALAR_MAPPER (acosh, octave::math::rc_acosh);
+      SCALAR_MAPPER (angle, octave::math::arg);
+      SCALAR_MAPPER (arg,octave::math ::arg);
+      SCALAR_MAPPER (asin, octave::math::rc_asin);
       SCALAR_MAPPER (asinh, xasinh);
       SCALAR_MAPPER (atan, ::atan);
-      SCALAR_MAPPER (atanh, rc_atanh);
+      SCALAR_MAPPER (atanh, octave::math::rc_atanh);
       SCALAR_MAPPER (erf, xerf);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, xerfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
       SCALAR_MAPPER (erfi, ::erfi);
       SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, xcbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
       SCALAR_MAPPER (exp, ::exp);
       SCALAR_MAPPER (expm1, xexpm1);
-      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, gnulib::floor);
-      SCALAR_MAPPER (log, rc_log);
-      SCALAR_MAPPER (log2, rc_log2);
-      SCALAR_MAPPER (log10, rc_log10);
+      SCALAR_MAPPER (log, octave::math::rc_log);
+      SCALAR_MAPPER (log2, octave::math::rc_log2);
+      SCALAR_MAPPER (log10, octave::math::rc_log10);
       SCALAR_MAPPER (log1p, rc_log1p);
-      SCALAR_MAPPER (round, xround);
-      SCALAR_MAPPER (roundb, xroundb);
-      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (round, octave::math::round);
+      SCALAR_MAPPER (roundb, octave::math::roundb);
+      SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sin);
       SCALAR_MAPPER (sinh, ::sinh);
-      SCALAR_MAPPER (sqrt, rc_sqrt);
+      SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
       SCALAR_MAPPER (tan, ::tan);
       SCALAR_MAPPER (tanh, ::tanh);
-      SCALAR_MAPPER (isfinite, xfinite);
-      SCALAR_MAPPER (isinf, xisinf);
-      SCALAR_MAPPER (isna, octave_is_NA);
-      SCALAR_MAPPER (isnan, xisnan);
-      SCALAR_MAPPER (xsignbit, xsignbit);
+      SCALAR_MAPPER (isfinite, octave::math::finite);
+      SCALAR_MAPPER (isinf, octave::math::isinf);
+      SCALAR_MAPPER (isna, octave::math::is_NA);
+      SCALAR_MAPPER (isnan, octave::math::isnan);
+      SCALAR_MAPPER (xsignbit, octave::math::signbit);
 
     // Special cases for Matlab compatibility.
     case umap_xtolower:
     case umap_xtoupper:
       return scalar;
 
     case umap_xisalnum:
     case umap_xisalpha:
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -192,27 +192,27 @@ public:
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
-    if (xisnan (scalar))
+    if (octave::math::isnan (scalar))
       err_nan_to_logical_conversion ();
     if (warn && scalar != 0 && scalar != 1)
       warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -1014,17 +1014,17 @@ static bool val_in_table (const Matrix& 
     return false;
 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
-  if (k != xround (k) || k <= 0)
+  if (k != octave::math::round (k) || k <= 0)
     error ("isargout: K must be a positive integer");
 
   return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isargout (@var{k})\n\
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // unary complex scalar ops.
 
 DEFUNOP (not, complex)
 {
   const octave_complex& v = dynamic_cast<const octave_complex&> (a);
   Complex x = v.complex_value ();
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, complex, /* no-op */)
 DEFUNOP_OP (uminus, complex, -)
 DEFUNOP_OP (transpose, complex, /* no-op */)
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // unary complex scalar ops.
 
 DEFUNOP (not, float_complex)
 {
   const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
   FloatComplex x = v.float_complex_value ();
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_complex, /* no-op */)
 DEFUNOP_OP (uminus, float_complex, -)
 DEFUNOP_OP (transpose, float_complex, /* no-op */)
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // scalar unary ops.
 
 DEFUNOP (not, float_scalar)
 {
   const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
   float x = v.float_value ();
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_scalar, /* no-op */)
 DEFUNOP_OP (uminus, float_scalar, -)
 DEFUNOP_OP (transpose, float_scalar, /* no-op */)
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // scalar unary ops.
 
 DEFUNOP (not, scalar)
 {
   const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
   double x = v.scalar_value ();
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, scalar, /* no-op */)
 DEFUNOP_OP (uminus, scalar, -)
 DEFUNOP_OP (transpose, scalar, /* no-op */)
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -309,17 +309,17 @@ extern void install_ops (void);
 #define DEFSCALARBOOLOP_OP(name, t1, t2, op) \
   static octave_value \
   CONCAT2 (oct_binop_, name) (const octave_base_value& a1, \
                               const octave_base_value& a2) \
   { \
     const CONCAT2 (octave_, t1)& v1 = dynamic_cast<const CONCAT2 (octave_, t1)&> (a1); \
     const CONCAT2 (octave_, t2)& v2 = dynamic_cast<const CONCAT2 (octave_, t2)&> (a2); \
  \
-    if (xisnan (v1.CONCAT2 (t1, _value) ()) || xisnan (v2.CONCAT2 (t2, _value) ())) \
+    if (octave::math::isnan (v1.CONCAT2 (t1, _value) ()) || octave::math::isnan (v2.CONCAT2 (t2, _value) ())) \
       err_nan_to_logical_conversion (); \
  \
     return octave_value \
       (v1.CONCAT2 (t1, _value) () op v2.CONCAT2 (t2, _value) ()); \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   static octave_value \
diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -39,42 +39,42 @@ along with Octave; see the file COPYING.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 template <>
 inline bool
 sort_isnan<Complex> (const Complex& x)
 {
-  return xisnan (x);
+  return octave::math::isnan (x);
 }
 
 // Sort Criteria: 1) isnan, 2) magnitude of z, 3) phase of z in range (-pi, pi]
 
 static bool
 nan_ascending_compare (const Complex& x, const Complex& y)
 {
-  return xisnan (y) ? ! xisnan (x) : x < y;
+  return octave::math::isnan (y) ? ! octave::math::isnan (x) : x < y;
 }
 
 static bool
 nan_descending_compare (const Complex& x, const Complex& y)
 {
-  return xisnan (x) ? ! xisnan (y) : x > y;
+  return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<Complex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<Complex>& a , bool allow_chk)
 {
   Array<Complex>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
-      for (; k < a.numel () && ! xisnan (a(k)); k++) ;
+      for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
             result = octave_sort<Complex>::ascending_compare;
           else if (mode == DESCENDING)
             result = octave_sort<Complex>::descending_compare;
         }
     }
diff --git a/liboctave/array/Array-d.cc b/liboctave/array/Array-d.cc
--- a/liboctave/array/Array-d.cc
+++ b/liboctave/array/Array-d.cc
@@ -41,40 +41,40 @@ along with Octave; see the file COPYING.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 template <>
 inline bool
 sort_isnan<double> (double x)
 {
-  return xisnan (x);
+  return octave::math::isnan (x);
 }
 
 static bool
 nan_ascending_compare (double x, double y)
 {
-  return xisnan (y) ? ! xisnan (x) : x < y;
+  return octave::math::isnan (y) ? ! octave::math::isnan (x) : x < y;
 }
 
 static bool
 nan_descending_compare (double x, double y)
 {
-  return xisnan (x) ? ! xisnan (y) : x > y;
+  return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<double>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<double>& a , bool allow_chk)
 {
   Array<double>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
-      for (; k < a.numel () && ! xisnan (a(k)); k++) ;
+      for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
             result = octave_sort<double>::ascending_compare;
           else if (mode == DESCENDING)
             result = octave_sort<double>::descending_compare;
         }
     }
@@ -102,30 +102,30 @@ Array<double>::is_sorted (sortmode mode)
   const double *el = data ();
 
   if (n <= 1)
     return mode ? mode : ASCENDING;
 
   if (! mode)
     {
       // Auto-detect mode.
-      if (el[n-1] < el[0] || xisnan (el[0]))
+      if (el[n-1] < el[0] || octave::math::isnan (el[0]))
         mode = DESCENDING;
       else
         mode = ASCENDING;
     }
 
   if (mode == DESCENDING)
     {
       octave_idx_type j = 0;
       double r;
       // Sort out NaNs.
       do
         r = el[j++];
-      while (xisnan (r) && j < n);
+      while (octave::math::isnan (r) && j < n);
 
       // Orient the test so that NaN will not pass through.
       for (; j < n; j++)
         {
           if (r >= el[j])
             r = el[j];
           else
             {
@@ -133,17 +133,17 @@ Array<double>::is_sorted (sortmode mode)
               break;
             }
         }
 
     }
   else if (mode == ASCENDING)
     {
       // Sort out NaNs.
-      while (n > 0 && xisnan (el[n-1]))
+      while (n > 0 && octave::math::isnan (el[n-1]))
         n--;
 
       if (n > 0)
         {
           // Orient the test so that NaN will not pass through.
           double r = el[0];
           for (octave_idx_type j = 1; j < n; j++)
             {
diff --git a/liboctave/array/Array-f.cc b/liboctave/array/Array-f.cc
--- a/liboctave/array/Array-f.cc
+++ b/liboctave/array/Array-f.cc
@@ -41,40 +41,40 @@ along with Octave; see the file COPYING.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 template <>
 inline bool
 sort_isnan<float> (float x)
 {
-  return xisnan (x);
+  return octave::math::isnan (x);
 }
 
 static bool
 nan_ascending_compare (float x, float y)
 {
-  return xisnan (y) ? ! xisnan (x) : x < y;
+  return octave::math::isnan (y) ? ! octave::math::isnan (x) : x < y;
 }
 
 static bool
 nan_descending_compare (float x, float y)
 {
-  return xisnan (x) ? ! xisnan (y) : x > y;
+  return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<float>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<float>& a , bool allow_chk)
 {
   Array<float>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
-      for (; k < a.numel () && ! xisnan (a(k)); k++) ;
+      for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
             result = octave_sort<float>::ascending_compare;
           else if (mode == DESCENDING)
             result = octave_sort<float>::descending_compare;
         }
     }
@@ -102,30 +102,30 @@ Array<float>::is_sorted (sortmode mode) 
   const float *el = data ();
 
   if (n <= 1)
     return mode ? mode : ASCENDING;
 
   if (! mode)
     {
       // Auto-detect mode.
-      if (el[n-1] < el[0] || xisnan (el[0]))
+      if (el[n-1] < el[0] || octave::math::isnan (el[0]))
         mode = DESCENDING;
       else
         mode = ASCENDING;
     }
 
   if (mode == DESCENDING)
     {
       octave_idx_type j = 0;
       float r;
       // Sort out NaNs.
       do
         r = el[j++];
-      while (xisnan (r) && j < n);
+      while (octave::math::isnan (r) && j < n);
 
       // Orient the test so that NaN will not pass through.
       for (; j < n; j++)
         {
           if (r >= el[j])
             r = el[j];
           else
             {
@@ -133,17 +133,17 @@ Array<float>::is_sorted (sortmode mode) 
               break;
             }
         }
 
     }
   else if (mode == ASCENDING)
     {
       // Sort out NaNs.
-      while (n > 0 && xisnan (el[n-1]))
+      while (n > 0 && octave::math::isnan (el[n-1]))
         n--;
 
       if (n > 0)
         {
           // Orient the test so that NaN will not pass through.
           float r = el[0];
           for (octave_idx_type j = 1; j < n; j++)
             {
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -39,42 +39,42 @@ along with Octave; see the file COPYING.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 template <>
 inline bool
 sort_isnan<FloatComplex> (const FloatComplex& x)
 {
-  return xisnan (x);
+  return octave::math::isnan (x);
 }
 
 // Sort Criteria: 1) isnan, 2) magnitude of z, 3) phase of z in range (-pi, pi]
 
 static bool
 nan_ascending_compare (const FloatComplex& x, const FloatComplex& y)
 {
-  return xisnan (y) ? ! xisnan (x) : x < y;
+  return octave::math::isnan (y) ? ! octave::math::isnan (x) : x < y;
 }
 
 static bool
 nan_descending_compare (const FloatComplex& x, const FloatComplex& y)
 {
-  return xisnan (x) ? ! xisnan (y) : x > y;
+  return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<FloatComplex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<FloatComplex>& a, bool allow_chk)
 {
   Array<FloatComplex>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
-      for (; k < a.numel () && ! xisnan (a(k)); k++) ;
+      for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
             result = octave_sort<FloatComplex>::ascending_compare;
           else if (mode == DESCENDING)
             result = octave_sort<FloatComplex>::descending_compare;
         }
     }
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2204,17 +2204,17 @@ Array<T>::lookup (const Array<T>& values
   lsort.set_compare (mode);
 
   // This determines the split ratio between the O(M*log2(N)) and O(M+N)
   // algorithms.
   static const double ratio = 1.0;
   sortmode vmode = UNSORTED;
 
   // Attempt the O(M+N) algorithm if M is large enough.
-  if (nval > ratio * n / xlog2 (n + 1.0))
+  if (nval > ratio * n / octave::math::log2 (n + 1.0))
     {
       vmode = values.is_sorted ();
       // The table must not contain a NaN.
       if ((vmode == ASCENDING && sort_isnan<T> (values(nval-1)))
           || (vmode == DESCENDING && sort_isnan<T> (values(0))))
         vmode = UNSORTED;
     }
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1044,17 +1044,17 @@ ComplexMatrix::finverse (MatrixType &mat
   info = 0;
 
   // Calculate the norm of the matrix, for later use.
   double anorm;
   //if (calc_cond)   // Must always calculate anorm for bug #45577
   anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-  if (xisnan (anorm))
+  if (octave::math::isnan (anorm))
     info = -1;
   else
     F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
@@ -1612,17 +1612,17 @@ ComplexMatrix::determinant (MatrixType& 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       //if (calc_cond)   // Must always calculate anorm for bug #45577
       anorm = xnorm (*this, 1);
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-      if (xisnan (anorm))
+      if (octave::math::isnan (anorm))
         info = -1;
       else
         F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
@@ -1807,17 +1807,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
                         row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-              if (xisnan (anorm))
+              if (octave::math::isnan (anorm))
                 info = -1;
               else
                 F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
@@ -1912,17 +1912,17 @@ ComplexMatrix::utsolve (MatrixType &matt
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
-          if (rcond_plus_one == 1.0 || xisnan (rcon))
+          if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 warn_singular_matrix (rcon);
             }
@@ -2002,17 +2002,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
-          if (rcond_plus_one == 1.0 || xisnan (rcon))
+          if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 warn_singular_matrix (rcon);
             }
@@ -2084,17 +2084,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2136,17 +2136,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
-          if (xisnan (anorm))
+          if (octave::math::isnan (anorm))
             info = -2;
           else
             F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
@@ -2171,17 +2171,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2612,17 +2612,17 @@ ComplexMatrix::lssolve (const ComplexMat
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-      double tmp = xlog2 (dminmn / dsmlsizp1);
+      double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
@@ -2802,17 +2802,17 @@ ComplexMatrix::lssolve (const ComplexCol
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-      double tmp = xlog2 (dminmn / dsmlsizp1);
+      double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
@@ -3148,42 +3148,42 @@ ComplexMatrix::row_min (Array<octave_idx
           Complex tmp_min;
 
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_min))
+          if (octave::math::isnan (tmp_min))
             {
               result.elem (i) = Complex_NaN_result;
               idx_arg.elem (i) = 0;
             }
           else
             {
               result.elem (i) = tmp_min;
               idx_arg.elem (i) = idx_j;
@@ -3223,42 +3223,42 @@ ComplexMatrix::row_max (Array<octave_idx
           Complex tmp_max;
 
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_max))
+          if (octave::math::isnan (tmp_max))
             {
               result.elem (i) = Complex_NaN_result;
               idx_arg.elem (i) = 0;
             }
           else
             {
               result.elem (i) = tmp_max;
               idx_arg.elem (i) = idx_j;
@@ -3298,42 +3298,42 @@ ComplexMatrix::column_min (Array<octave_
           Complex tmp_min;
 
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_min))
+          if (octave::math::isnan (tmp_min))
             {
               result.elem (j) = Complex_NaN_result;
               idx_arg.elem (j) = 0;
             }
           else
             {
               result.elem (j) = tmp_min;
               idx_arg.elem (j) = idx_i;
@@ -3373,42 +3373,42 @@ ComplexMatrix::column_max (Array<octave_
           Complex tmp_max;
 
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_max))
+          if (octave::math::isnan (tmp_max))
             {
               result.elem (j) = Complex_NaN_result;
               idx_arg.elem (j) = 0;
             }
           else
             {
               result.elem (j) = tmp_max;
               idx_arg.elem (j) = idx_i;
@@ -3715,17 +3715,17 @@ min (const Complex& c, const ComplexMatr
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (c, m(i, j));
+        result(i, j) = octave::math::min (c, m(i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& m, const Complex& c)
 {
@@ -3735,17 +3735,17 @@ min (const ComplexMatrix& m, const Compl
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (m(i, j), c);
+        result(i, j) = octave::math::min (m(i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 min (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -3771,24 +3771,24 @@ min (const ComplexMatrix& a, const Compl
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = xmin (std::real (a(i, j)), std::real (b(i, j)));
+            result(i, j) = octave::math::min (std::real (a(i, j)), std::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmin (a(i, j), b(i, j));
+              result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
         }
     }
 
   return result;
 }
 
 ComplexMatrix
@@ -3800,17 +3800,17 @@ max (const Complex& c, const ComplexMatr
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (c, m(i, j));
+        result(i, j) = octave::math::max (c, m(i, j));
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& m, const Complex& c)
 {
@@ -3820,17 +3820,17 @@ max (const ComplexMatrix& m, const Compl
   EMPTY_RETURN_CHECK (ComplexMatrix);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (m(i, j), c);
+        result(i, j) = octave::math::max (m(i, j), c);
       }
 
   return result;
 }
 
 ComplexMatrix
 max (const ComplexMatrix& a, const ComplexMatrix& b)
 {
@@ -3858,25 +3858,25 @@ max (const ComplexMatrix& a, const Compl
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmax (std::real (a(i, j)), std::real (b(i, j)));
+              result(i, j) = octave::math::max (std::real (a(i, j)), std::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmax (a(i, j), b(i, j));
+              result(i, j) = octave::math::max (a(i, j), b(i, j));
             }
         }
     }
 
   return result;
 }
 
 ComplexMatrix linspace (const ComplexColumnVector& x1,
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -569,17 +569,17 @@ ComplexNDArray::all_integers (double& ma
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 ComplexNDArray::too_large_for_float (void) const
@@ -723,29 +723,29 @@ NDArray
 ComplexNDArray::abs (void) const
 {
   return do_mx_unary_map<double, Complex, std::abs> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isnan (void) const
 {
-  return do_mx_unary_map<bool, Complex, xisnan> (*this);
+  return do_mx_unary_map<bool, Complex, octave::math::isnan> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isinf (void) const
 {
-  return do_mx_unary_map<bool, Complex, xisinf> (*this);
+  return do_mx_unary_map<bool, Complex, octave::math::isinf> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<bool, Complex, xfinite> (*this);
+  return do_mx_unary_map<bool, Complex, octave::math::finite> (*this);
 }
 
 ComplexNDArray
 conj (const ComplexNDArray& a)
 {
   return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -305,30 +305,30 @@ SparseComplexMatrix::max (Array<octave_i
               tmp_max = 0.;
               abs_max = 0.;
             }
 
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
-              if (xisnan (abs_max) || abs_tmp > abs_max)
+              if (octave::math::isnan (abs_max) || abs_tmp > abs_max)
                 {
                   idx_j = ridx (i);
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_j;
           if (abs_max != 0.)
             nel++;
         }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -367,17 +367,17 @@ SparseComplexMatrix::max (Array<octave_i
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (ix == -1 || std::abs (tmp) > std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -462,30 +462,30 @@ SparseComplexMatrix::min (Array<octave_i
               tmp_min = 0.;
               abs_min = 0.;
             }
 
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
-              if (xisnan (abs_min) || abs_tmp < abs_min)
+              if (octave::math::isnan (abs_min) || abs_tmp < abs_min)
                 {
                   idx_j = ridx (i);
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_j;
           if (abs_min != 0.)
             nel++;
         }
 
       result = SparseComplexMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -524,17 +524,17 @@ SparseComplexMatrix::min (Array<octave_i
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (ix == -1 || std::abs (tmp) < std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -1156,29 +1156,29 @@ SparseComplexMatrix::determinant (octave
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         {
           Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
@@ -1774,17 +1774,17 @@ SparseComplexMatrix::utsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2056,17 +2056,17 @@ SparseComplexMatrix::utsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2285,17 +2285,17 @@ SparseComplexMatrix::utsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2567,17 +2567,17 @@ SparseComplexMatrix::utsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2816,17 +2816,17 @@ SparseComplexMatrix::ltsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3117,17 +3117,17 @@ SparseComplexMatrix::ltsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3370,17 +3370,17 @@ SparseComplexMatrix::ltsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3670,17 +3670,17 @@ SparseComplexMatrix::ltsolve (MatrixType
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -4384,17 +4384,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4503,17 +4503,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4628,17 +4628,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4780,17 +4780,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4944,17 +4944,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5061,17 +5061,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5188,17 +5188,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5345,17 +5345,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5440,28 +5440,28 @@ SparseComplexMatrix::factorize (octave_i
 #if defined (HAVE_UMFPACK)
 
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = octave_sparse_params::get_key ("piv_tol");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
@@ -5501,17 +5501,17 @@ SparseComplexMatrix::factorize (octave_i
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix
-          || rcond_plus_one == 1.0 || xisnan (rcond))
+          || rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
@@ -5660,17 +5660,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -5920,17 +5920,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6208,17 +6208,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6447,17 +6447,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6581,17 +6581,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                 }
 
               retval.maybe_compress ();
 
               rcond = Info (UMFPACK_RCOND);
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (status == UMFPACK_WARNING_singular_matrix
-                  || rcond_plus_one == 1.0 || xisnan (rcond))
+                  || rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
                     warn_singular_matrix (rcond);
                 }
@@ -7194,32 +7194,32 @@ SparseComplexMatrix::ipermute (const Arr
 bool
 SparseComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
-      if (xisnan (val))
+      if (octave::math::isnan (val))
         return true;
     }
 
   return false;
 }
 
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
-      if (xisinf (val) || xisnan (val))
+      if (octave::math::isinf (val) || octave::math::isnan (val))
         return true;
     }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
@@ -7258,17 +7258,17 @@ SparseComplexMatrix::all_integers (doubl
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
@@ -7599,17 +7599,17 @@ min (const Complex& c, const SparseCompl
   if (abs (c) == 0.)
     return SparseComplexMatrix (nr, nc);
   else
     {
       result = SparseComplexMatrix (m);
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
-          result.data (i) = xmin (c, m.data (i));
+          result.data (i) = octave::math::min (c, m.data (i));
     }
 
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
 {
@@ -7642,42 +7642,42 @@ min (const SparseComplexMatrix& a, const
           octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  Complex tmp = xmin (a.data (ja), 0.);
+                  Complex tmp = octave::math::min (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if ((! ja_lt_max)
                        || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
-                  Complex tmp = xmin (0., b.data (jb));
+                  Complex tmp = octave::math::min (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  Complex tmp = xmin (a.data (ja), b.data (jb));
+                  Complex tmp = octave::math::min (a.data (ja), b.data (jb));
                   if (tmp != 0.)
                     {
                       r.data (jx) = tmp;
                       r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
@@ -7709,22 +7709,22 @@ max (const Complex& c, const SparseCompl
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   // Count the number of nonzero elements
-  if (xmax (c, 0.) != 0.)
+  if (octave::math::max (c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
-          result.xdata (m.ridx (i) + j * nr) = xmax (c, m.data (i));
+          result.xdata (m.ridx (i) + j * nr) = octave::math::max (c, m.data (i));
     }
   else
     result = SparseComplexMatrix (m);
 
   return result;
 }
 
 SparseComplexMatrix
@@ -7759,42 +7759,42 @@ max (const SparseComplexMatrix& a, const
           octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  Complex tmp = xmax (a.data (ja), 0.);
+                  Complex tmp = octave::math::max (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if ((! ja_lt_max)
                        || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
-                  Complex tmp = xmax (0., b.data (jb));
+                  Complex tmp = octave::math::max (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  Complex tmp = xmax (a.data (ja), b.data (jb));
+                  Complex tmp = octave::math::max (a.data (ja), b.data (jb));
                   if (tmp != 0.)
                     {
                       r.data (jx) = tmp;
                       r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -38,19 +38,19 @@ along with Octave; see the file COPYING.
 
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
   // will also be an integer, even if the limit is not.  If there is one
   // or fewer elements only the base needs to be an integer
 
-  return (! (xisnan (rng_base) || xisnan (rng_inc))
-          && (NINTbig (rng_base) == rng_base || rng_numel < 1)
-          && (NINTbig (rng_inc) == rng_inc || rng_numel <= 1));
+  return (! (octave::math::isnan (rng_base) || octave::math::isnan (rng_inc))
+          && (octave::math::nint_big (rng_base) == rng_base || rng_numel < 1)
+          && (octave::math::nint_big (rng_inc) == rng_inc || rng_numel <= 1));
 }
 
 Matrix
 Range::matrix_value (void) const
 {
   if (rng_numel > 0 && cache.is_empty ())
     {
       cache.resize (1, rng_numel);
diff --git a/liboctave/array/Range.h b/liboctave/array/Range.h
--- a/liboctave/array/Range.h
+++ b/liboctave/array/Range.h
@@ -57,17 +57,17 @@ public:
     rng_limit = limit_internal ();
   }
 
   // For operators' usage (to preserve element count).
   Range (double b, double i, octave_idx_type n)
     : rng_base (b), rng_limit (b + (n-1) * i), rng_inc (i),
       rng_numel (n), cache ()
   {
-    if (! xfinite (b) || ! xfinite (i) || ! xfinite (rng_limit))
+    if (! octave::math::finite (b) || ! octave::math::finite (i) || ! octave::math::finite (rng_limit))
       rng_numel = -2;
     else
       {
         // Code below is only needed if the resulting range must be 100%
         // correctly constructed.  If the Range object created is only
         // a temporary one used by operators this may be unnecessary.
 
         rng_limit = limit_internal ();
@@ -150,17 +150,17 @@ private:
 
 protected:
 
   // For operators' usage (to allow all values to be set directly).
   Range (double b, double l, double i, octave_idx_type n)
     : rng_base (b), rng_limit (l), rng_inc (i),
       rng_numel (n), cache ()
   {
-    if (! xfinite (b) || ! xfinite (i) || ! xfinite (l))
+    if (! octave::math::finite (b) || ! octave::math::finite (i) || ! octave::math::finite (l))
       rng_numel = -2;
   }
 };
 
 extern OCTAVE_API Range operator - (const Range& r);
 
 extern OCTAVE_API Range operator + (double x, const Range& r);
 
diff --git a/liboctave/array/Sparse-C.cc b/liboctave/array/Sparse-C.cc
--- a/liboctave/array/Sparse-C.cc
+++ b/liboctave/array/Sparse-C.cc
@@ -32,34 +32,34 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "Sparse.h"
 #include "Sparse.cc"
 
 
 static double
 xabs (const Complex& x)
 {
-  return ((xisinf (x.real ()) || xisinf (x.imag ()))
+  return ((octave::math::isinf (x.real ()) || octave::math::isinf (x.imag ()))
           ? octave::numeric_limits<double>::Inf () : abs (x));
 }
 
 
 template <>
 bool
 sparse_ascending_compare<Complex> (const Complex& a, const Complex& b)
 {
-  return (xisnan (b) || (xabs (a) < xabs (b))
+  return (octave::math::isnan (b) || (xabs (a) < xabs (b))
           || ((xabs (a) == xabs (b)) && (arg (a) < arg (b))));
 }
 
 template <>
 bool
 sparse_descending_compare<Complex> (const Complex& a, const Complex& b)
 {
-  return (xisnan (a) || (xabs (a) > xabs (b))
+  return (octave::math::isnan (a) || (xabs (a) > xabs (b))
           || ((xabs (a) == xabs (b)) && (arg (a) > arg (b))));
 }
 
 INSTANTIATE_SPARSE (Complex, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<Complex>&);
 #endif
diff --git a/liboctave/array/Sparse-d.cc b/liboctave/array/Sparse-d.cc
--- a/liboctave/array/Sparse-d.cc
+++ b/liboctave/array/Sparse-d.cc
@@ -30,23 +30,23 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "Sparse.h"
 #include "Sparse.cc"
 
 template <>
 bool
 sparse_ascending_compare<double> (double a, double b)
 {
-  return (xisnan (b) || (a < b));
+  return (octave::math::isnan (b) || (a < b));
 }
 
 template <>
 bool
 sparse_descending_compare<double> (double a, double b)
 {
-  return (xisnan (a) || (a > b));
+  return (octave::math::isnan (a) || (a > b));
 }
 
 INSTANTIATE_SPARSE (double, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<double>&);
 #endif
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -114,21 +114,21 @@ charNDArray::concat (const NDArray& rb, 
 
   if (rb.is_empty ())
     return *this;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = rb.elem (i);
 
-      if (xisnan (d))
+      if (octave::math::isnan (d))
         (*current_liboctave_error_handler)
           ("invalid conversion from NaN to character");
 
-      octave_idx_type ival = NINTbig (d);
+      octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do? Should we warn the user?
         ival = 0;
 
       tmp.elem (i) = static_cast<char>(ival);
     }
 
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1582,17 +1582,17 @@ Matrix::utsolve (MatrixType &mattype, co
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
-          if (rcond_plus_one == 1.0 || xisnan (rcon))
+          if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 warn_singular_matrix (rcon);
             }
@@ -1671,17 +1671,17 @@ Matrix::ltsolve (MatrixType &mattype, co
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
 
-          if (rcond_plus_one == 1.0 || xisnan (rcon))
+          if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 warn_singular_matrix (rcon);
             }
@@ -1751,17 +1751,17 @@ Matrix::fsolve (MatrixType &mattype, con
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -1832,17 +1832,17 @@ Matrix::fsolve (MatrixType &mattype, con
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2262,17 +2262,17 @@ Matrix::lssolve (const Matrix& b, octave
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-      double tmp = xlog2 (dminmn / dsmlsizp1);
+      double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2451,17 +2451,17 @@ Matrix::lssolve (const ColumnVector& b, 
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-      double tmp = xlog2 (dminmn / dsmlsizp1);
+      double tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2694,35 +2694,35 @@ Matrix::row_min (Array<octave_idx_type>&
           octave_idx_type idx_j;
 
           double tmp_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 break;
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               double tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp < tmp_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (i) = tmp_min;
-          idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (i) = octave::math::isnan (tmp_min) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
@@ -2749,35 +2749,35 @@ Matrix::row_max (Array<octave_idx_type>&
           octave_idx_type idx_j;
 
           double tmp_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 break;
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               double tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp > tmp_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (i) = tmp_max;
-          idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (i) = octave::math::isnan (tmp_max) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
@@ -2804,35 +2804,35 @@ Matrix::column_min (Array<octave_idx_typ
           octave_idx_type idx_i;
 
           double tmp_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 break;
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               double tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp < tmp_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (j) = tmp_min;
-          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
+          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
@@ -2859,35 +2859,35 @@ Matrix::column_max (Array<octave_idx_typ
           octave_idx_type idx_i;
 
           double tmp_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 break;
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               double tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp > tmp_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (j) = tmp_max;
-          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
+          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
@@ -3134,17 +3134,17 @@ min (double d, const Matrix& m)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (d, m(i, j));
+        result(i, j) = octave::math::min (d, m(i, j));
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& m, double d)
 {
@@ -3154,17 +3154,17 @@ min (const Matrix& m, double d)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (m(i, j), d);
+        result(i, j) = octave::math::min (m(i, j), d);
       }
 
   return result;
 }
 
 Matrix
 min (const Matrix& a, const Matrix& b)
 {
@@ -3178,17 +3178,17 @@ min (const Matrix& a, const Matrix& b)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (a(i, j), b(i, j));
+        result(i, j) = octave::math::min (a(i, j), b(i, j));
       }
 
   return result;
 }
 
 Matrix
 max (double d, const Matrix& m)
 {
@@ -3198,17 +3198,17 @@ max (double d, const Matrix& m)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (d, m(i, j));
+        result(i, j) = octave::math::max (d, m(i, j));
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& m, double d)
 {
@@ -3218,17 +3218,17 @@ max (const Matrix& m, double d)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (m(i, j), d);
+        result(i, j) = octave::math::max (m(i, j), d);
       }
 
   return result;
 }
 
 Matrix
 max (const Matrix& a, const Matrix& b)
 {
@@ -3242,17 +3242,17 @@ max (const Matrix& a, const Matrix& b)
   EMPTY_RETURN_CHECK (Matrix);
 
   Matrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (a(i, j), b(i, j));
+        result(i, j) = octave::math::max (a(i, j), b(i, j));
       }
 
   return result;
 }
 
 Matrix linspace (const ColumnVector& x1,
                  const ColumnVector& x2,
                  octave_idx_type n)
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -544,24 +544,24 @@ NDArray::operator ! (void) const
     err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, double> (*this, mx_inline_not);
 }
 
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
-  return (neg_zero ? test_all (xnegative_sign)
+  return (neg_zero ? test_all (octave::math::negative_sign)
           : do_mx_check<double> (*this, mx_inline_any_negative));
 }
 
 bool
 NDArray::any_element_is_positive (bool neg_zero) const
 {
-  return (neg_zero ? test_all (xpositive_sign)
+  return (neg_zero ? test_all (octave::math::positive_sign)
           : do_mx_check<double> (*this, mx_inline_any_positive));
 }
 
 bool
 NDArray::any_element_is_nan (void) const
 {
   return do_mx_check<double> (*this, mx_inline_any_nan);
 }
@@ -611,27 +611,27 @@ NDArray::all_integers (double& max_val, 
       double val = elem (i);
 
       if (val > max_val)
         max_val = val;
 
       if (val < min_val)
         min_val = val;
 
-      if (! xisinteger (val))
+      if (! octave::math::isinteger (val))
         return false;
     }
 
   return true;
 }
 
 bool
 NDArray::all_integers (void) const
 {
-  return test_all (xisinteger);
+  return test_all (octave::math::isinteger);
 }
 
 bool
 NDArray::too_large_for_float (void) const
 {
   return test_any (xtoo_large_for_float);
 }
 
@@ -761,21 +761,21 @@ NDArray::concat (const charNDArray& rb, 
 {
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = elem (i);
 
-      if (xisnan (d))
+      if (octave::math::isnan (d))
         (*current_liboctave_error_handler)
           ("invalid conversion from NaN to character");
 
-      octave_idx_type ival = NINTbig (d);
+      octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do? Should we warn the user?
         ival = 0;
 
       retval.elem (i) = static_cast<char>(ival);
     }
 
@@ -816,29 +816,29 @@ NDArray
 NDArray::abs (void) const
 {
   return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
 boolNDArray
 NDArray::isnan (void) const
 {
-  return do_mx_unary_map<bool, double, xisnan> (*this);
+  return do_mx_unary_map<bool, double, octave::math::isnan> (*this);
 }
 
 boolNDArray
 NDArray::isinf (void) const
 {
-  return do_mx_unary_map<bool, double, xisinf> (*this);
+  return do_mx_unary_map<bool, double, octave::math::isinf> (*this);
 }
 
 boolNDArray
 NDArray::isfinite (void) const
 {
-  return do_mx_unary_map<bool, double, xfinite> (*this);
+  return do_mx_unary_map<bool, double, octave::math::finite> (*this);
 }
 
 void
 NDArray::increment_index (Array<octave_idx_type>& ra_idx,
                           const dim_vector& dimensions,
                           int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -314,27 +314,27 @@ SparseMatrix::max (Array<octave_idx_type
 
           if (idx_j != nr)
             tmp_max = 0.;
 
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
-              else if (xisnan (tmp_max) || tmp > tmp_max)
+              else if (octave::math::isnan (tmp_max) || tmp > tmp_max)
                 {
                   idx_j = ridx (i);
                   tmp_max = tmp;
                 }
 
             }
 
-          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_j;
           if (tmp_max != 0.)
             nel++;
         }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -374,17 +374,17 @@ SparseMatrix::max (Array<octave_idx_type
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (ix == -1 || tmp > elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -465,27 +465,27 @@ SparseMatrix::min (Array<octave_idx_type
 
           if (idx_j != nr)
             tmp_min = 0.;
 
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
-              else if (xisnan (tmp_min) || tmp < tmp_min)
+              else if (octave::math::isnan (tmp_min) || tmp < tmp_min)
                 {
                   idx_j = ridx (i);
                   tmp_min = tmp;
                 }
 
             }
 
-          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_j;
           if (tmp_min != 0.)
             nel++;
         }
 
       result = SparseMatrix (1, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
@@ -525,17 +525,17 @@ SparseMatrix::min (Array<octave_idx_type
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (ix == -1 || tmp < elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -1242,29 +1242,29 @@ SparseMatrix::determinant (octave_idx_ty
       err = 0;
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         {
           Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
@@ -1852,17 +1852,17 @@ SparseMatrix::utsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2134,17 +2134,17 @@ SparseMatrix::utsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2365,17 +2365,17 @@ SparseMatrix::utsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2649,17 +2649,17 @@ SparseMatrix::utsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -2902,17 +2902,17 @@ SparseMatrix::ltsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3202,17 +3202,17 @@ SparseMatrix::ltsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3456,17 +3456,17 @@ SparseMatrix::ltsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -3758,17 +3758,17 @@ SparseMatrix::ltsolve (MatrixType &matty
               mattype.mark_as_rectangular ();
             }
           else
             warn_singular_matrix (rcond);
         }
 
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (rcond_plus_one == 1.0 || xisnan (rcond))
+      if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           err = -2;
 
           if (sing_handler)
             {
               sing_handler (rcond);
               mattype.mark_as_rectangular ();
             }
@@ -4491,17 +4491,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4610,17 +4610,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4735,17 +4735,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -4887,17 +4887,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5051,17 +5051,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5200,17 +5200,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5348,17 +5348,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5527,17 +5527,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                              anorm, rcond, pz, piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcond))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
@@ -5635,28 +5635,28 @@ SparseMatrix::factorize (octave_idx_type
 #if defined (HAVE_UMFPACK)
 
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_PRL) = tmp;
   tmp = octave_sparse_params::get_key ("piv_tol");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     {
       Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
       Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   UMFPACK_DNAME (report_control) (control);
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const double *Ax = data ();
   octave_idx_type nr = rows ();
@@ -5692,17 +5692,17 @@ SparseMatrix::factorize (octave_idx_type
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix
-          || rcond_plus_one == 1.0 || xisnan (rcond))
+          || rcond_plus_one == 1.0 || octave::math::isnan (rcond))
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
@@ -5853,17 +5853,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6086,17 +6086,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6345,17 +6345,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -6596,17 +6596,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (rcond_plus_one == 1.0 || xisnan (rcond))
+              if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
@@ -7288,32 +7288,32 @@ SparseMatrix::any_element_is_negative (b
 bool
 SparseMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
-      if (xisnan (val))
+      if (octave::math::isnan (val))
         return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
-      if (xisinf (val) || xisnan (val))
+      if (octave::math::isinf (val) || octave::math::isnan (val))
         return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_not_one_or_zero (void) const
@@ -7345,17 +7345,17 @@ SparseMatrix::all_elements_are_zero (voi
 bool
 SparseMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
-      if (xisnan (val) || D_NINT (val) == val)
+      if (octave::math::isnan (val) || octave::math::x_nint (val) == val)
         continue;
       else
         return false;
     }
 
   return true;
 }
 
@@ -7378,17 +7378,17 @@ SparseMatrix::all_integers (double& max_
       double val = data (i);
 
       if (val > max_val)
         max_val = val;
 
       if (val < min_val)
         min_val = val;
 
-      if (D_NINT (val) != val)
+      if (octave::math::x_nint (val) != val)
         return false;
     }
 
   return true;
 }
 
 bool
 SparseMatrix::too_large_for_float (void) const
@@ -7672,42 +7672,42 @@ min (double d, const SparseMatrix& m)
 
   // Count the number of nonzero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
-            double tmp = xmin (d, m.data (i));
+            double tmp = octave::math::min (d, m.data (i));
             if (tmp != 0.)
               {
                 octave_idx_type idx = m.ridx (i) + j * nr;
                 result.xdata (idx) = tmp;
                 result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
-          if (xmin (d, m.data (i)) != 0.)
+          if (octave::math::min (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
-              double tmp = xmin (d, m.data (i));
+              double tmp = octave::math::min (d, m.data (i));
 
               if (tmp != 0.)
                 {
                   result.xdata (ii) = tmp;
                   result.xridx (ii++) = m.ridx (i);
                 }
             }
           result.xcidx (j+1) = ii;
@@ -7749,42 +7749,42 @@ min (const SparseMatrix& a, const Sparse
           octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  double tmp = xmin (a.data (ja), 0.);
+                  double tmp = octave::math::min (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if ((! ja_lt_max)
                        || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
-                  double tmp = xmin (0., b.data (jb));
+                  double tmp = octave::math::min (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  double tmp = xmin (a.data (ja), b.data (jb));
+                  double tmp = octave::math::min (a.data (ja), b.data (jb));
                   if (tmp != 0.)
                     {
                       r.data (jx) = tmp;
                       r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
@@ -7822,43 +7822,43 @@ max (double d, const SparseMatrix& m)
 
   // Count the number of nonzero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
-            double tmp = xmax (d, m.data (i));
+            double tmp = octave::math::max (d, m.data (i));
 
             if (tmp != 0.)
               {
                 octave_idx_type idx = m.ridx (i) + j * nr;
                 result.xdata (idx) = tmp;
                 result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
-          if (xmax (d, m.data (i)) != 0.)
+          if (octave::math::max (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
-              double tmp = xmax (d, m.data (i));
+              double tmp = octave::math::max (d, m.data (i));
               if (tmp != 0.)
                 {
                   result.xdata (ii) = tmp;
                   result.xridx (ii++) = m.ridx (i);
                 }
             }
           result.xcidx (j+1) = ii;
         }
@@ -7899,42 +7899,42 @@ max (const SparseMatrix& a, const Sparse
           octave_idx_type jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) || (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  double tmp = xmax (a.data (ja), 0.);
+                  double tmp = octave::math::max (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if ((! ja_lt_max)
                        || (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
-                  double tmp = xmax (0., b.data (jb));
+                  double tmp = octave::math::max (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  double tmp = xmax (a.data (ja), b.data (jb));
+                  double tmp = octave::math::max (a.data (ja), b.data (jb));
                   if (tmp != 0.)
                     {
                       r.data (jx) = tmp;
                       r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1904,17 +1904,17 @@ FloatComplexMatrix::utsolve (MatrixType 
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -1998,17 +1998,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2084,17 +2084,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2167,17 +2167,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2619,17 +2619,17 @@ FloatComplexMatrix::lssolve (const Float
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-      float tmp = xlog2 (dminmn / dsmlsizp1);
+      float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
@@ -2812,17 +2812,17 @@ FloatComplexMatrix::lssolve (const Float
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-      float tmp = xlog2 (dminmn / dsmlsizp1);
+      float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
@@ -3161,42 +3161,42 @@ FloatComplexMatrix::row_min (Array<octav
           FloatComplex tmp_min;
 
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_min))
+          if (octave::math::isnan (tmp_min))
             {
               result.elem (i) = FloatComplex_NaN_result;
               idx_arg.elem (i) = 0;
             }
           else
             {
               result.elem (i) = tmp_min;
               idx_arg.elem (i) = idx_j;
@@ -3236,42 +3236,42 @@ FloatComplexMatrix::row_max (Array<octav
           FloatComplex tmp_max;
 
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_max))
+          if (octave::math::isnan (tmp_max))
             {
               result.elem (i) = FloatComplex_NaN_result;
               idx_arg.elem (i) = 0;
             }
           else
             {
               result.elem (i) = tmp_max;
               idx_arg.elem (i) = idx_j;
@@ -3311,42 +3311,42 @@ FloatComplexMatrix::column_min (Array<oc
           FloatComplex tmp_min;
 
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_min))
+          if (octave::math::isnan (tmp_min))
             {
               result.elem (j) = FloatComplex_NaN_result;
               idx_arg.elem (j) = 0;
             }
           else
             {
               result.elem (j) = tmp_min;
               idx_arg.elem (j) = idx_i;
@@ -3386,42 +3386,42 @@ FloatComplexMatrix::column_max (Array<oc
           FloatComplex tmp_max;
 
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
 
               float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
 
-          if (xisnan (tmp_max))
+          if (octave::math::isnan (tmp_max))
             {
               result.elem (j) = FloatComplex_NaN_result;
               idx_arg.elem (j) = 0;
             }
           else
             {
               result.elem (j) = tmp_max;
               idx_arg.elem (j) = idx_i;
@@ -3731,17 +3731,17 @@ min (const FloatComplex& c, const FloatC
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (c, m(i, j));
+        result(i, j) = octave::math::min (c, m(i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& m, const FloatComplex& c)
 {
@@ -3751,17 +3751,17 @@ min (const FloatComplexMatrix& m, const 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (m(i, j), c);
+        result(i, j) = octave::math::min (m(i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 min (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
@@ -3787,24 +3787,24 @@ min (const FloatComplexMatrix& a, const 
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = xmin (std::real (a(i, j)), std::real (b(i, j)));
+            result(i, j) = octave::math::min (std::real (a(i, j)), std::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmin (a(i, j), b(i, j));
+              result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
         }
     }
 
   return result;
 }
 
 FloatComplexMatrix
@@ -3816,17 +3816,17 @@ max (const FloatComplex& c, const FloatC
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (c, m(i, j));
+        result(i, j) = octave::math::max (c, m(i, j));
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& m, const FloatComplex& c)
 {
@@ -3836,17 +3836,17 @@ max (const FloatComplexMatrix& m, const 
   EMPTY_RETURN_CHECK (FloatComplexMatrix);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (m(i, j), c);
+        result(i, j) = octave::math::max (m(i, j), c);
       }
 
   return result;
 }
 
 FloatComplexMatrix
 max (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
@@ -3874,25 +3874,25 @@ max (const FloatComplexMatrix& a, const 
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmax (std::real (a(i, j)), std::real (b(i, j)));
+              result(i, j) = octave::math::max (std::real (a(i, j)), std::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = xmax (a(i, j), b(i, j));
+              result(i, j) = octave::math::max (a(i, j), b(i, j));
             }
         }
     }
 
   return result;
 }
 
 FloatComplexMatrix linspace (const FloatComplexColumnVector& x1,
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -566,17 +566,17 @@ FloatComplexNDArray::all_integers (float
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 FloatComplexNDArray::too_large_for_float (void) const
@@ -732,29 +732,29 @@ FloatNDArray
 FloatComplexNDArray::abs (void) const
 {
   return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isnan (void) const
 {
-  return do_mx_unary_map<bool, FloatComplex, xisnan> (*this);
+  return do_mx_unary_map<bool, FloatComplex, octave::math::isnan> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isinf (void) const
 {
-  return do_mx_unary_map<bool, FloatComplex, xisinf> (*this);
+  return do_mx_unary_map<bool, FloatComplex, octave::math::isinf> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<bool, FloatComplex, xfinite> (*this);
+  return do_mx_unary_map<bool, FloatComplex, octave::math::finite> (*this);
 }
 
 FloatComplexNDArray
 conj (const FloatComplexNDArray& a)
 {
   return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1594,17 +1594,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -1689,17 +1689,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -1774,17 +1774,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -1855,17 +1855,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
-                  if (rcond_plus_one == 1.0 || xisnan (rcon))
+                  if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
                         warn_singular_matrix (rcon);
                     }
@@ -2294,17 +2294,17 @@ FloatMatrix::lssolve (const FloatMatrix&
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-      float tmp = xlog2 (dminmn / dsmlsizp1);
+      float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2483,17 +2483,17 @@ FloatMatrix::lssolve (const FloatColumnV
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-      float tmp = xlog2 (dminmn / dsmlsizp1);
+      float tmp = octave::math::log2 (dminmn / dsmlsizp1);
 
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2711,35 +2711,35 @@ FloatMatrix::row_min (Array<octave_idx_t
           octave_idx_type idx_j;
 
           float tmp_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 break;
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               float tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp < tmp_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (i) = tmp_min;
-          idx_arg.elem (i) = xisnan (tmp_min) ? 0 : idx_j;
+          idx_arg.elem (i) = octave::math::isnan (tmp_min) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 FloatColumnVector
 FloatMatrix::row_max (void) const
@@ -2766,35 +2766,35 @@ FloatMatrix::row_max (Array<octave_idx_t
           octave_idx_type idx_j;
 
           float tmp_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 break;
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               float tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp > tmp_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (i) = tmp_max;
-          idx_arg.elem (i) = xisnan (tmp_max) ? 0 : idx_j;
+          idx_arg.elem (i) = octave::math::isnan (tmp_max) ? 0 : idx_j;
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_min (void) const
@@ -2821,35 +2821,35 @@ FloatMatrix::column_min (Array<octave_id
           octave_idx_type idx_i;
 
           float tmp_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
-              if (! xisnan (tmp_min))
+              if (! octave::math::isnan (tmp_min))
                 break;
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               float tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp < tmp_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                 }
             }
 
           result.elem (j) = tmp_min;
-          idx_arg.elem (j) = xisnan (tmp_min) ? 0 : idx_i;
+          idx_arg.elem (j) = octave::math::isnan (tmp_min) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 FloatRowVector
 FloatMatrix::column_max (void) const
@@ -2876,35 +2876,35 @@ FloatMatrix::column_max (Array<octave_id
           octave_idx_type idx_i;
 
           float tmp_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
-              if (! xisnan (tmp_max))
+              if (! octave::math::isnan (tmp_max))
                 break;
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               float tmp = elem (i, j);
 
-              if (xisnan (tmp))
+              if (octave::math::isnan (tmp))
                 continue;
               else if (tmp > tmp_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                 }
             }
 
           result.elem (j) = tmp_max;
-          idx_arg.elem (j) = xisnan (tmp_max) ? 0 : idx_i;
+          idx_arg.elem (j) = octave::math::isnan (tmp_max) ? 0 : idx_i;
         }
     }
 
   return result;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatMatrix& a)
@@ -3147,17 +3147,17 @@ min (float d, const FloatMatrix& m)
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (d, m(i, j));
+        result(i, j) = octave::math::min (d, m(i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& m, float d)
 {
@@ -3167,17 +3167,17 @@ min (const FloatMatrix& m, float d)
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (m(i, j), d);
+        result(i, j) = octave::math::min (m(i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 min (const FloatMatrix& a, const FloatMatrix& b)
 {
@@ -3191,17 +3191,17 @@ min (const FloatMatrix& a, const FloatMa
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmin (a(i, j), b(i, j));
+        result(i, j) = octave::math::min (a(i, j), b(i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (float d, const FloatMatrix& m)
 {
@@ -3211,17 +3211,17 @@ max (float d, const FloatMatrix& m)
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (d, m(i, j));
+        result(i, j) = octave::math::max (d, m(i, j));
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& m, float d)
 {
@@ -3231,17 +3231,17 @@ max (const FloatMatrix& m, float d)
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (m(i, j), d);
+        result(i, j) = octave::math::max (m(i, j), d);
       }
 
   return result;
 }
 
 FloatMatrix
 max (const FloatMatrix& a, const FloatMatrix& b)
 {
@@ -3255,17 +3255,17 @@ max (const FloatMatrix& a, const FloatMa
   EMPTY_RETURN_CHECK (FloatMatrix);
 
   FloatMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
-        result(i, j) = xmax (a(i, j), b(i, j));
+        result(i, j) = octave::math::max (a(i, j), b(i, j));
       }
 
   return result;
 }
 
 FloatMatrix linspace (const FloatColumnVector& x1,
                       const FloatColumnVector& x2,
                       octave_idx_type n)
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -504,24 +504,24 @@ FloatNDArray::operator ! (void) const
     err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, float> (*this, mx_inline_not);
 }
 
 bool
 FloatNDArray::any_element_is_negative (bool neg_zero) const
 {
-  return (neg_zero ? test_all (xnegative_sign)
+  return (neg_zero ? test_all (octave::math::negative_sign)
           : do_mx_check<float> (*this, mx_inline_any_negative));
 }
 
 bool
 FloatNDArray::any_element_is_positive (bool neg_zero) const
 {
-  return (neg_zero ? test_all (xpositive_sign)
+  return (neg_zero ? test_all (octave::math::positive_sign)
           : do_mx_check<float> (*this, mx_inline_any_positive));
 }
 
 bool
 FloatNDArray::any_element_is_nan (void) const
 {
   return do_mx_check<float> (*this, mx_inline_any_nan);
 }
@@ -571,27 +571,27 @@ FloatNDArray::all_integers (float& max_v
       float val = elem (i);
 
       if (val > max_val)
         max_val = val;
 
       if (val < min_val)
         min_val = val;
 
-      if (! xisinteger (val))
+      if (! octave::math::isinteger (val))
         return false;
     }
 
   return true;
 }
 
 bool
 FloatNDArray::all_integers (void) const
 {
-  return test_all (xisinteger);
+  return test_all (octave::math::isinteger);
 }
 
 bool
 FloatNDArray::too_large_for_float (void) const
 {
   return false;
 }
 
@@ -730,21 +730,21 @@ FloatNDArray::concat (const charNDArray&
 {
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float d = elem (i);
 
-      if (xisnan (d))
+      if (octave::math::isnan (d))
         (*current_liboctave_error_handler)
           ("invalid conversion from NaN to character");
 
-      octave_idx_type ival = NINTbig (d);
+      octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do?  Should we warn the user?
         ival = 0;
 
       retval.elem (i) = static_cast<char>(ival);
     }
 
@@ -787,29 +787,29 @@ FloatNDArray
 FloatNDArray::abs (void) const
 {
   return do_mx_unary_map<float, float, std::abs> (*this);
 }
 
 boolNDArray
 FloatNDArray::isnan (void) const
 {
-  return do_mx_unary_map<bool, float, xisnan> (*this);
+  return do_mx_unary_map<bool, float, octave::math::isnan> (*this);
 }
 
 boolNDArray
 FloatNDArray::isinf (void) const
 {
-  return do_mx_unary_map<bool, float, xisinf> (*this);
+  return do_mx_unary_map<bool, float, octave::math::isinf> (*this);
 }
 
 boolNDArray
 FloatNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<bool, float, xfinite> (*this);
+  return do_mx_unary_map<bool, float, octave::math::finite> (*this);
 }
 
 void
 FloatNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -464,17 +464,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
       count++;
       return this;
     }
 
   // This is wrapped in unique_ptr so that we don't leak on out-of-memory.
   std::unique_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
-  if (ext > len*xlog2 (1.0 + len))
+  if (ext > len*octave::math::log2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       std::copy (data, data + len, new_data);
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
@@ -537,17 +537,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 
 idx_vector::idx_base_rep *
 idx_vector::idx_vector_rep::sort_idx (Array<octave_idx_type>& idx)
 {
   // This is wrapped in unique_ptr so that we don't leak on out-of-memory.
   std::unique_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
-  if (ext > len*xlog2 (1.0 + len))
+  if (ext > len*octave::math::log2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
       for (octave_idx_type i = 0; i < len; i++)
         idx_data[i] = i;
 
       octave_idx_type *new_data = new octave_idx_type [len];
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -222,17 +222,17 @@ jcobi (octave_idx_type n, octave_idx_typ
             }
 
           z /= zc;
           x -= z;
 
           // Famous last words:  100 iterations should be more than
           // enough in all cases.
 
-          if (++k > 100 || xisnan (z))
+          if (++k > 100 || octave::math::isnan (z))
             return false;
 
           if (std::abs (z) <= 100 * std::numeric_limits<double>::epsilon ())
             done = true;
         }
 
       root[i] = x;
       x += sqrt (std::numeric_limits<double>::epsilon ());
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -413,20 +413,20 @@ DASPK::do_integrate (double tout)
         }
 
       if (use_initial_condition_heuristics ())
         {
           Array<double> ich = initial_condition_heuristics ();
 
           if (ich.numel () == 6)
             {
-              iwork(31) = NINTbig (ich(0));
-              iwork(32) = NINTbig (ich(1));
-              iwork(33) = NINTbig (ich(2));
-              iwork(34) = NINTbig (ich(3));
+              iwork(31) = octave::math::nint_big (ich(0));
+              iwork(32) = octave::math::nint_big (ich(1));
+              iwork(33) = octave::math::nint_big (ich(2));
+              iwork(34) = octave::math::nint_big (ich(3));
 
               rwork(13) = ich(4);
               rwork(14) = ich(5);
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
diff --git a/liboctave/numeric/DET.h b/liboctave/numeric/DET.h
--- a/liboctave/numeric/DET.h
+++ b/liboctave/numeric/DET.h
@@ -33,28 +33,28 @@ template <typename T>
 class
 base_det
 {
 public:
 
   base_det (T c = 1, int e = 0)
     : c2 (), e2 ()
   {
-    c2 = xlog2 (c, e2);
+    c2 = octave::math::log2 (c, e2);
     e2 += e;
   }
 
   base_det (T c, double e, double b)
     : c2 (), e2 ()
   {
-    e *= xlog2 (b);
+    e *= octave::math::log2 (b);
     e2 = e;
-    c *= xexp2 (e - e2);
+    c *= octave::math::exp2 (e - e2);
     int f;
-    c2 = xlog2 (c, f);
+    c2 = octave::math::log2 (c, f);
     e2 += f;
   }
 
   base_det (const base_det& a) : c2 (a.c2), e2 (a.e2) { }
 
   base_det& operator = (const base_det& a)
   {
     c2 = a.c2;
@@ -68,17 +68,17 @@ public:
   T value () const { return c2 * static_cast<T> (std::ldexp (1.0, e2)); }
   operator T () const { return value (); }
 
   base_det square () const { return base_det (c2*c2, e2+e2); }
 
   void operator *= (T t)
   {
     int e;
-    c2 *= xlog2 (t, e);
+    c2 *= octave::math::log2 (t, e);
     e2 += e;
   }
 
 private:
 
   T c2;
   int e2;
 };
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -445,27 +445,27 @@ LuAminusSigmaB (const SparseMatrix &m, c
   double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx (j+1) > U.xcidx (j)
           && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
-      if (xisnan (minU) || d < minU)
+      if (octave::math::isnan (minU) || d < minU)
         minU = d;
 
-      if (xisnan (maxU) || d > maxU)
+      if (octave::math::isnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
-  if (rcond_plus_one == 1.0 || xisnan (rcond))
+  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const Matrix &m, const Matrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
@@ -517,27 +517,27 @@ LuAminusSigmaB (const Matrix &m, const M
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave::numeric_limits<double>::NaN ();
   double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem (j,j));
-      if (xisnan (minU) || d < minU)
+      if (octave::math::isnan (minU) || d < minU)
         minU = d;
 
-      if (xisnan (maxU) || d > maxU)
+      if (octave::math::isnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
-  if (rcond_plus_one == 1.0 || xisnan (rcond))
+  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
@@ -609,27 +609,27 @@ LuAminusSigmaB (const SparseComplexMatri
   double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx (j+1) > U.xcidx (j)
           && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
-      if (xisnan (minU) || d < minU)
+      if (octave::math::isnan (minU) || d < minU)
         minU = d;
 
-      if (xisnan (maxU) || d > maxU)
+      if (octave::math::isnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
-  if (rcond_plus_one == 1.0 || xisnan (rcond))
+  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 static bool
 LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
@@ -681,27 +681,27 @@ LuAminusSigmaB (const ComplexMatrix &m, 
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave::numeric_limits<double>::NaN ();
   double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem (j,j));
-      if (xisnan (minU) || d < minU)
+      if (octave::math::isnan (minU) || d < minU)
         minU = d;
 
-      if (xisnan (maxU) || d > maxU)
+      if (octave::math::isnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
-  if (rcond_plus_one == 1.0 || xisnan (rcond))
+  if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
@@ -764,17 +764,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -842,17 +842,17 @@ EigsRealSymmetricMatrix (const M& m, con
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
-      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1037,17 +1037,17 @@ EigsRealSymmetricMatrixShift (const M& m
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -1095,17 +1095,17 @@ EigsRealSymmetricMatrixShift (const M& m
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
-      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1368,17 +1368,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
-      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1559,17 +1559,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -1637,17 +1637,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dnaupd");
 
-      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1881,17 +1881,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -1939,17 +1939,17 @@ EigsRealNonSymmetricMatrixShift (const M
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dsaupd");
 
-      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2267,17 +2267,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in dnaupd");
 
-      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2508,17 +2508,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -2587,17 +2587,17 @@ EigsComplexNonSymmetricMatrix (const M& 
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
-      if (disp > 0 && ! xisnan (workl[iptr (5)-1]))
+      if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2784,17 +2784,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || D_NINT (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -2843,17 +2843,17 @@ EigsComplexNonSymmetricMatrixShift (cons
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
-      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -3128,17 +3128,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
-      if (disp > 0 && ! xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -32,621 +32,463 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "lo-specfun.h"
 #include "lo-utils.h"
 #include "oct-cmplx.h"
 
 #include "f77-fcn.h"
 
-// double -> double mappers.
-
-// Both xtrunc and xround belong here so we can keep gnulib:: out of
+// Functions that forward to gnulib belong here so we can keep gnulib:: out of
 // lo-mappers.h.
 
-double
-xtrunc (double x)
+namespace octave
 {
-  return gnulib::trunc (x);
-}
+  namespace math
+  {
+    bool
+    is_NA (double x)
+    {
+      return lo_ieee_is_NA (x);
+    }
+
+    bool
+    is_NA (const Complex& x)
+    {
+      return (is_NA (real (x)) || is_NA (imag (x)));
+    }
 
-double
-xcopysign (double x, double y)
-{
-  return gnulib::copysign (x, y);
-}
+    bool
+    is_NA (float x)
+    {
+      return lo_ieee_is_NA (x);
+    }
+
+    bool
+    is_NA (const FloatComplex& x)
+    {
+      return (is_NA (real (x)) || is_NA (imag (x)));
+    }
 
-double xfloor (double x)
-{
-  return gnulib::floor (x);
-}
+    bool
+    is_NaN_or_NA (const Complex& x)
+    {
+      return (isnan (real (x)) || isnan (imag (x)));
+    }
+
+    bool
+    is_NaN_or_NA (const FloatComplex& x)
+    {
+      return (isnan (real (x)) || isnan (imag (x)));
+    }
 
-double
-xround (double x)
-{
-  return gnulib::round (x);
-}
+    Complex
+    acos (const Complex& x)
+    {
+      static Complex i (0, 1);
+
+      Complex tmp;
+
+      if (imag (x) == 0.0)
+        {
+          // If the imaginary part of X is 0, then avoid generating an
+          // imaginary part of -0 for the expression 1-x*x.
+          // This effectively chooses the same phase of the branch cut as Matlab.
+          double xr = real (x);
+          tmp = Complex (1.0 - xr*xr);
+        }
+      else
+        tmp = 1.0 - x*x;
+
+      return -i * log (x + i * sqrt (tmp));
+    }
 
-double
-xroundb (double x)
-{
-  double t = xround (x);
+    FloatComplex
+    acos (const FloatComplex& x)
+    {
+      static FloatComplex i (0, 1);
+
+      FloatComplex tmp;
 
-  if (fabs (x - t) == 0.5)
-    t = 2 * xtrunc (0.5 * t);
+      if (imag (x) == 0.0f)
+        {
+          // If the imaginary part of X is 0, then avoid generating an
+          // imaginary part of -0 for the expression 1-x*x.
+          // This effectively chooses the same phase of the branch cut as Matlab.
+          float xr = real (x);
+          tmp = FloatComplex (1.0f - xr*xr);
+        }
+      else
+        tmp = 1.0f - x*x;
 
-  return t;
-}
+      return -i * log (x + i * sqrt (tmp));
+    }
+
+    Complex
+    asin (const Complex& x)
+    {
+      static Complex i (0, 1);
+
+      Complex tmp;
 
-double
-signum (double x)
-{
-  double tmp = 0.0;
+      if (imag (x) == 0.0)
+        {
+          // If the imaginary part of X is 0, then avoid generating an
+          // imaginary part of -0 for the expression 1-x*x.
+          // This effectively chooses the same phase of the branch cut as Matlab.
+          double xr = real (x);
+          tmp = Complex (1.0 - xr*xr);
+        }
+      else
+        tmp = 1.0 - x*x;
+
+      return -i * log (i*x + sqrt (tmp));
+    }
+
+    FloatComplex
+    asin (const FloatComplex& x)
+    {
+      static FloatComplex i (0, 1);
+
+      FloatComplex tmp;
 
-  if (x < 0.0)
-    tmp = -1.0;
-  else if (x > 0.0)
-    tmp = 1.0;
+      if (imag (x) == 0.0f)
+        {
+          // If the imaginary part of X is 0, then avoid generating an
+          // imaginary part of -0 for the expression 1-x*x.
+          // This effectively chooses the same phase of the branch cut as Matlab.
+          float xr = real (x);
+          tmp = FloatComplex (1.0f - xr*xr);
+        }
+      else
+        tmp = 1.0f - x*x;
+
+      return -i * log (i*x + sqrt (tmp));
+    }
 
-  return xisnan (x) ? octave::numeric_limits<double>::NaN () : tmp;
-}
+    Complex
+    atan (const Complex& x)
+    {
+      static Complex i (0, 1);
+
+      return i * log ((i + x) / (i - x)) / 2.0;
+    }
+
+    FloatComplex
+    atan (const FloatComplex& x)
+    {
+      static FloatComplex i (0, 1);
+
+      return i * log ((i + x) / (i - x)) / 2.0f;
+    }
+
+    double log2 (double x) { return gnulib::log2 (x); }
+    float log2 (float x) { return gnulib::log2f (x); }
 
-double
-xlog2 (double x)
-{
-  return gnulib::log2 (x);
-}
+    Complex
+    log2 (const Complex& x)
+    {
+#if defined (M_LN2)
+      static double ln2 = M_LN2;
+#else
+      static double ln2 = gnulib::log (2.0);
+#endif
+      return std::log (x) / ln2;
+    }
 
-Complex
-xlog2 (const Complex& x)
-{
+    FloatComplex
+    log2 (const FloatComplex& x)
+    {
 #if defined (M_LN2)
-  static double ln2 = M_LN2;
+      static float ln2 = M_LN2;
 #else
-  static double ln2 = gnulib::log (2);
+      static float ln2 = log (2.0f);
 #endif
+      return std::log (x) / ln2;
+    }
 
-  return std::log (x) / ln2;
-}
+    double
+    log2 (double x, int& exp)
+    {
+      return gnulib::frexp (x, &exp);
+    }
+
+    float
+    log2 (float x, int& exp)
+    {
+      return gnulib::frexpf (x, &exp);
+    }
 
-double
-xexp2 (double x)
-{
+    Complex
+    log2 (const Complex& x, int& exp)
+    {
+      double ax = std::abs (x);
+      double lax = log2 (ax, exp);
+      return (ax != lax) ? (x / ax) * lax : x;
+    }
+
+    FloatComplex
+    log2 (const FloatComplex& x, int& exp)
+    {
+      float ax = std::abs (x);
+      float lax = log2 (ax, exp);
+      return (ax != lax) ? (x / ax) * lax : x;
+    }
+
+    double
+    exp2 (double x)
+    {
 #if defined (HAVE_EXP2)
-  return exp2 (x);
+      return ::exp2 (x);
 #else
 #  if defined (M_LN2)
-  static double ln2 = M_LN2;
-#else
-  static double ln2 = gnulib::log (2);
-#endif
-
-  return exp (x * ln2);
-#endif
-}
-
-double
-xlog2 (double x, int& exp)
-{
-  return gnulib::frexp (x, &exp);
-}
-
-Complex
-xlog2 (const Complex& x, int& exp)
-{
-  double ax = std::abs (x);
-  double lax = xlog2 (ax, exp);
-  return (ax != lax) ? (x / ax) * lax : x;
-}
-
-// double -> bool mappers.
-
-bool
-xisnan (double x)
-{
-#if defined (HAVE_CMATH_ISNAN)
-  return std::isnan (x);
-#else
-  return lo_ieee_isnan (x);
-#endif
-}
-
-bool
-xfinite (double x)
-{
-#if defined (HAVE_CMATH_ISFINITE)
-  return std::isfinite (x);
-#else
-  return lo_ieee_finite (x);
-#endif
-}
-
-bool
-xisinf (double x)
-{
-#if defined (HAVE_CMATH_ISINF)
-  return std::isinf (x);
-#else
-  return lo_ieee_isinf (x);
+      static double ln2 = M_LN2;
+#  else
+      static double ln2 = gnulib::log (2.0);
+#  endif
+      return exp (x * ln2);
 #endif
-}
-
-bool
-octave_is_NA (double x)
-{
-  return lo_ieee_is_NA (x);
-}
-
-// (double, double) -> double mappers.
-
-// complex -> complex mappers.
-
-Complex
-acos (const Complex& x)
-{
-  static Complex i (0, 1);
-
-  Complex tmp;
-
-  if (imag (x) == 0.0)
-    {
-      // If the imaginary part of X is 0, then avoid generating an
-      // imaginary part of -0 for the expression 1-x*x.
-      // This effectively chooses the same phase of the branch cut as Matlab.
-      double xr = real (x);
-      tmp = Complex (1.0 - xr*xr);
     }
-  else
-    tmp = 1.0 - x*x;
-
-  return -i * log (x + i * sqrt (tmp));
-}
-
-Complex
-asin (const Complex& x)
-{
-  static Complex i (0, 1);
-
-  Complex tmp;
-
-  if (imag (x) == 0.0)
-    {
-      // If the imaginary part of X is 0, then avoid generating an
-      // imaginary part of -0 for the expression 1-x*x.
-      // This effectively chooses the same phase of the branch cut as Matlab.
-      double xr = real (x);
-      tmp = Complex (1.0 - xr*xr);
-    }
-  else
-    tmp = 1.0 - x*x;
-
-  return -i * log (i*x + sqrt (tmp));
-}
-
-Complex
-atan (const Complex& x)
-{
-  static Complex i (0, 1);
 
-  return i * log ((i + x) / (i - x)) / 2.0;
-}
-
-// complex -> bool mappers.
-
-bool
-octave_is_NA (const Complex& x)
-{
-  return (octave_is_NA (real (x)) || octave_is_NA (imag (x)));
-}
-
-bool
-octave_is_NaN_or_NA (const Complex& x)
-{
-  return (xisnan (real (x)) || xisnan (imag (x)));
-}
-
-// (complex, complex) -> complex mappers.
-
-// FIXME: need to handle NA too?
-
-Complex
-xmin (const Complex& x, const Complex& y)
-{
-  return abs (x) <= abs (y) ? x : (xisnan (x) ? x : y);
-}
-
-Complex
-xmax (const Complex& x, const Complex& y)
-{
-  return abs (x) >= abs (y) ? x : (xisnan (x) ? x : y);
-}
-
-
-// float -> float mappers.
-
-// Both xtrunc and xround belong here so we can keep gnulib:: out of
-// lo-mappers.h.
-
-float
-xtrunc (float x)
-{
-  return gnulib::truncf (x);
-}
-
-float
-xcopysign (float x, float y)
-{
-  return gnulib::copysignf (x, y);
-}
-
-float xfloor (float x)
-{
-  return gnulib::floorf (x);
-}
-
-float
-xround (float x)
-{
-  return gnulib::roundf (x);
-}
-
-float
-xroundb (float x)
-{
-  float t = xround (x);
-
-  if (fabsf (x - t) == 0.5)
-    t = 2 * xtrunc (0.5 * t);
-
-  return t;
-}
-
-float
-signum (float x)
-{
-  float tmp = 0.0;
-
-  if (x < 0.0)
-    tmp = -1.0;
-  else if (x > 0.0)
-    tmp = 1.0;
-
-  return xisnan (x) ? octave::numeric_limits<float>::NaN () : tmp;
-}
-
-float
-xlog2 (float x)
-{
-  return gnulib::log2f (x);
-}
-
-FloatComplex
-xlog2 (const FloatComplex& x)
-{
-#if defined (M_LN2)
-  static float ln2 = M_LN2;
-#else
-  static float ln2 = log (2);
-#endif
-
-  return std::log (x) / ln2;
-}
-
-float
-xexp2 (float x)
-{
+    float
+    exp2 (float x)
+    {
 #if defined (HAVE_EXP2F)
-  return exp2f (x);
+      return exp2f (x);
 #elif defined (HAVE_EXP2)
-  return exp2 (x);
+      return ::exp2 (x);
 #else
 #  if defined (M_LN2)
-  static float ln2 = M_LN2;
-#else
-  static float ln2 = log2 (2);
-#endif
-
-  return exp (x * ln2);
+      static float ln2 = M_LN2;
+#  else
+      static float ln2 = log2 (2.0f);
+#  endif
+      return exp (x * ln2);
 #endif
-}
+    }
+
+    double copysign (double x, double y) { return gnulib::copysign (x, y); }
+    float copysign (float x, float y) { return gnulib::copysignf (x, y); }
+
+    double signbit (double x) { return ::signbit (x); }
+    float signbit (float x) { return ::signbit (x); }
 
-float
-xlog2 (float x, int& exp)
-{
-  return gnulib::frexpf (x, &exp);
-}
+    bool negative_sign (double x) { return __lo_ieee_signbit (x); }
+    bool negative_sign (float x) { return __lo_ieee_float_signbit (x); }
+
+    double trunc (double x) { return gnulib::trunc (x); }
+    float trunc (float x) { return gnulib::truncf (x); }
+
+    double floor (double x) { return gnulib::floor (x); }
+    float floor (float x) { return gnulib::floor (x); }
+
+    double round (double x) { return gnulib::round (x); }
+    float round (float x) { return gnulib::roundf (x); }
 
-FloatComplex
-xlog2 (const FloatComplex& x, int& exp)
-{
-  float ax = std::abs (x);
-  float lax = xlog2 (ax, exp);
-  return (ax != lax) ? (x / ax) * lax : x;
-}
-
-// float -> bool mappers.
+    bool
+    isnan (double x)
+    {
+#if defined (HAVE_CMATH_ISNAN)
+      return std::isnan (x);
+#else
+      return lo_ieee_isnan (x);
+#endif
+    }
 
-bool
-xisnan (float x)
-{
+    bool
+    isnan (float x)
+    {
 #if defined (HAVE_CMATH_ISNANF)
-  return std::isnan (x);
+      return std::isnan (x);
 #else
-  return lo_ieee_isnan (x);
+      return lo_ieee_isnan (x);
 #endif
-}
+    }
+
+    bool
+    finite (double x)
+    {
+#if defined (HAVE_CMATH_ISFINITE)
+      return std::isfinite (x);
+#else
+      return lo_ieee_finite (x);
+#endif
+    }
 
-bool
-xfinite (float x)
-{
+    bool
+    finite (float x)
+    {
 #if defined (HAVE_CMATH_ISFINITEF)
-  return std::isfinite (x);
+      return std::isfinite (x);
 #else
-  return lo_ieee_finite (x);
+      return lo_ieee_finite (x);
 #endif
-}
+    }
 
-bool
-xisinf (float x)
-{
+    bool
+    isinf (double x)
+    {
+#if defined (HAVE_CMATH_ISINF)
+      return std::isinf (x);
+#else
+      return lo_ieee_isinf (x);
+#endif
+    }
+
+    bool
+    isinf (float x)
+    {
 #if defined (HAVE_CMATH_ISINFF)
-  return std::isinf (x);
+      return std::isinf (x);
 #else
-  return lo_ieee_isinf (x);
+      return lo_ieee_isinf (x);
 #endif
-}
+    }
 
-bool
-octave_is_NA (float x)
-{
-  return lo_ieee_is_NA (x);
-}
-
-// (float, float) -> float mappers.
+    // Sometimes you need a large integer, but not always.
 
-// complex -> complex mappers.
+    octave_idx_type
+    nint_big (double x)
+    {
+      if (x > std::numeric_limits<octave_idx_type>::max ())
+        return std::numeric_limits<octave_idx_type>::max ();
+      else if (x < std::numeric_limits<octave_idx_type>::min ())
+        return std::numeric_limits<octave_idx_type>::min ();
+      else
+        return static_cast<octave_idx_type> ((x > 0.0) ? (x + 0.5) : (x - 0.5));
+    }
 
-FloatComplex
-acos (const FloatComplex& x)
-{
-  static FloatComplex i (0, 1);
+    octave_idx_type
+    nint_big (float x)
+    {
+      if (x > std::numeric_limits<octave_idx_type>::max ())
+        return std::numeric_limits<octave_idx_type>::max ();
+      else if (x < std::numeric_limits<octave_idx_type>::min ())
+        return std::numeric_limits<octave_idx_type>::min ();
+      else
+        return static_cast<octave_idx_type> ((x > 0.0f) ? (x + 0.5f) : (x - 0.5f));
+    }
 
-  FloatComplex tmp;
-
-  if (imag (x) == 0.0f)
+    int
+    nint (double x)
     {
-      // If the imaginary part of X is 0, then avoid generating an
-      // imaginary part of -0 for the expression 1-x*x.
-      // This effectively chooses the same phase of the branch cut as Matlab.
-      float xr = real (x);
-      tmp = FloatComplex (1.0f - xr*xr);
+      if (x > std::numeric_limits<int>::max ())
+        return std::numeric_limits<int>::max ();
+      else if (x < std::numeric_limits<int>::min ())
+        return std::numeric_limits<int>::min ();
+      else
+        return static_cast<int> ((x > 0.0) ? (x + 0.5) : (x - 0.5));
     }
-  else
-    tmp = 1.0f - x*x;
 
-  return -i * log (x + i * sqrt (tmp));
-}
+    int
+    nint (float x)
+    {
+      if (x > std::numeric_limits<int>::max ())
+        return std::numeric_limits<int>::max ();
+      else if (x < std::numeric_limits<int>::min ())
+        return std::numeric_limits<int>::min ();
+      else
+        return static_cast<int> ((x > 0.0f) ? (x + 0.5f) : (x - 0.5f));
+    }
 
-FloatComplex
-asin (const FloatComplex& x)
-{
-  static FloatComplex i (0, 1);
-
-  FloatComplex tmp;
+    Complex
+    rc_acos (double x)
+    {
+      return fabs (x) > 1.0 ? acos (Complex (x)) : Complex (::acos (x));
+    }
 
-  if (imag (x) == 0.0f)
+    FloatComplex
+    rc_acos (float x)
+    {
+      return fabsf (x) > 1.0f ? acos (FloatComplex (x)) : FloatComplex (::acosf (x));
+    }
+
+    Complex
+    rc_acosh (double x)
     {
-      // If the imaginary part of X is 0, then avoid generating an
-      // imaginary part of -0 for the expression 1-x*x.
-      // This effectively chooses the same phase of the branch cut as Matlab.
-      float xr = real (x);
-      tmp = FloatComplex (1.0f - xr*xr);
+      return x < 1.0 ? acosh (Complex (x)) : Complex (acosh (x));
     }
-  else
-    tmp = 1.0f - x*x;
+
+    FloatComplex
+    rc_acosh (float x)
+    {
+      return x < 1.0f ? acosh (FloatComplex (x)) : FloatComplex (acosh (x));
+    }
 
-  return -i * log (i*x + sqrt (tmp));
-}
+    Complex
+    rc_asin (double x)
+    {
+      return fabs (x) > 1.0 ? asin (Complex (x)) : Complex (::asin (x));
+    }
 
-FloatComplex
-atan (const FloatComplex& x)
-{
-  static FloatComplex i (0, 1);
+    FloatComplex
+    rc_asin (float x)
+    {
+      return fabsf (x) > 1.0f ? asin (FloatComplex (x)) : FloatComplex (::asinf (x));
+    }
 
-  return i * log ((i + x) / (i - x)) / 2.0f;
-}
+    Complex
+    rc_atanh (double x)
+    {
+      return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
+    }
 
-// complex -> bool mappers.
+    FloatComplex
+    rc_atanh (float x)
+    {
+      return fabsf (x) > 1.0f ? xatanh (FloatComplex (x)) : FloatComplex (atanh (x));
+    }
 
-bool
-octave_is_NA (const FloatComplex& x)
-{
-  return (octave_is_NA (real (x)) || octave_is_NA (imag (x)));
-}
+    Complex
+    rc_log (double x)
+    {
+      const double pi = 3.14159265358979323846;
+      return x < 0.0 ? Complex (gnulib::log (-x), pi) : Complex (gnulib::log (x));
+    }
 
-bool
-octave_is_NaN_or_NA (const FloatComplex& x)
-{
-  return (xisnan (real (x)) || xisnan (imag (x)));
-}
+    FloatComplex
+    rc_log (float x)
+    {
+      const float pi = 3.14159265358979323846f;
+      return x < 0.0f ? FloatComplex (gnulib::logf (-x), pi) : FloatComplex (gnulib::logf (x));
+    }
 
-// (complex, complex) -> complex mappers.
-
-// FIXME: need to handle NA too?
+    Complex
+    rc_log2 (double x)
+    {
+      const double pil2 = 4.53236014182719380962; // = pi / log(2)
+      return x < 0.0 ? Complex (log2 (-x), pil2) : Complex (log2 (x));
+    }
 
-FloatComplex
-xmin (const FloatComplex& x, const FloatComplex& y)
-{
-  return abs (x) <= abs (y) ? x : (xisnan (x) ? x : y);
-}
+    FloatComplex
+    rc_log2 (float x)
+    {
+      const float pil2 = 4.53236014182719380962f; // = pi / log(2)
+      return x < 0.0f ? FloatComplex (log2 (-x), pil2) : FloatComplex (log2 (x));
+    }
+
+    Complex
+    rc_log10 (double x)
+    {
+      const double pil10 = 1.36437635384184134748; // = pi / log(10)
+      return x < 0.0 ? Complex (log10 (-x), pil10) : Complex (log10 (x));
+    }
 
-FloatComplex
-xmax (const FloatComplex& x, const FloatComplex& y)
-{
-  return abs (x) >= abs (y) ? x : (xisnan (x) ? x : y);
-}
+    FloatComplex
+    rc_log10 (float x)
+    {
+      const float pil10 = 1.36437635384184134748f; // = pi / log(10)
+      return x < 0.0f ? FloatComplex (log10 (-x), pil10) : FloatComplex (log10f (x));
+    }
 
-Complex
-rc_acos (double x)
-{
-  return fabs (x) > 1.0 ? acos (Complex (x)) : Complex (acos (x));
-}
+    Complex
+    rc_sqrt (double x)
+    {
+      return x < 0.0 ? Complex (0.0, sqrt (-x)) : Complex (sqrt (x));
+    }
 
-FloatComplex
-rc_acos (float x)
-{
-  return fabsf (x) > 1.0f ? acos (FloatComplex (x)) : FloatComplex (acosf (x));
+    FloatComplex
+    rc_sqrt (float x)
+    {
+      return x < 0.0f ? FloatComplex (0.0f, sqrtf (-x)) : FloatComplex (sqrtf (x));
+    }
+  }
 }
-
-Complex
-rc_acosh (double x)
-{
-  return x < 1.0 ? xacosh (Complex (x)) : Complex (xacosh (x));
-}
-
-FloatComplex
-rc_acosh (float x)
-{
-  return x < 1.0f ? xacosh (FloatComplex (x)) : FloatComplex (xacosh (x));
-}
-
-Complex
-rc_asin (double x)
-{
-  return fabs (x) > 1.0 ? asin (Complex (x)) : Complex (asin (x));
-}
-
-FloatComplex
-rc_asin (float x)
-{
-  return fabsf (x) > 1.0f ? asin (FloatComplex (x)) : FloatComplex (asinf (x));
-}
-
-Complex
-rc_atanh (double x)
-{
-  return fabs (x) > 1.0 ? xatanh (Complex (x)) : Complex (xatanh (x));
-}
-
-FloatComplex
-rc_atanh (float x)
-{
-  return fabsf (x) > 1.0f ? xatanh (FloatComplex (x))
-                          : FloatComplex (xatanh (x));
-}
-
-Complex
-rc_log (double x)
-{
-  const double pi = 3.14159265358979323846;
-  return x < 0.0 ? Complex (gnulib::log (-x), pi) : Complex (gnulib::log (x));
-}
-
-FloatComplex
-rc_log (float x)
-{
-  const float pi = 3.14159265358979323846f;
-  return (x < 0.0f
-          ? FloatComplex (gnulib::logf (-x), pi)
-          : FloatComplex (gnulib::logf (x)));
-}
-
-Complex
-rc_log2 (double x)
-{
-  const double pil2 = 4.53236014182719380962; // = pi / log(2)
-  return x < 0.0 ? Complex (xlog2 (-x), pil2) : Complex (xlog2 (x));
-}
-
-FloatComplex
-rc_log2 (float x)
-{
-  const float pil2 = 4.53236014182719380962f; // = pi / log(2)
-  return x < 0.0f ? FloatComplex (xlog2 (-x), pil2) : FloatComplex (xlog2 (x));
-}
-
-Complex
-rc_log10 (double x)
-{
-  const double pil10 = 1.36437635384184134748; // = pi / log(10)
-  return x < 0.0 ? Complex (log10 (-x), pil10) : Complex (log10 (x));
-}
-
-FloatComplex
-rc_log10 (float x)
-{
-  const float pil10 = 1.36437635384184134748f; // = pi / log(10)
-  return x < 0.0f ? FloatComplex (log10 (-x), pil10)
-                  : FloatComplex (log10f (x));
-}
-
-Complex
-rc_sqrt (double x)
-{
-  return x < 0.0 ? Complex (0.0, sqrt (-x)) : Complex (sqrt (x));
-}
-
-FloatComplex
-rc_sqrt (float x)
-{
-  return x < 0.0f ? FloatComplex (0.0f, sqrtf (-x)) : FloatComplex (sqrtf (x));
-}
-
-bool
-xnegative_sign (double x)
-{
-  return __lo_ieee_signbit (x);
-}
-
-bool
-xnegative_sign (float x)
-{
-  return __lo_ieee_float_signbit (x);
-}
-
-// Convert X to the nearest integer value.  Should not pass NaN to
-// this function.
-
-// Sometimes you need a large integer, but not always.
-
-octave_idx_type
-NINTbig (double x)
-{
-  if (x > std::numeric_limits<octave_idx_type>::max ())
-    return std::numeric_limits<octave_idx_type>::max ();
-  else if (x < std::numeric_limits<octave_idx_type>::min ())
-    return std::numeric_limits<octave_idx_type>::min ();
-  else
-    return static_cast<octave_idx_type> ((x > 0) ? (x + 0.5) : (x - 0.5));
-}
-
-octave_idx_type
-NINTbig (float x)
-{
-  if (x > std::numeric_limits<octave_idx_type>::max ())
-    return std::numeric_limits<octave_idx_type>::max ();
-  else if (x < std::numeric_limits<octave_idx_type>::min ())
-    return std::numeric_limits<octave_idx_type>::min ();
-  else
-    return static_cast<octave_idx_type> ((x > 0) ? (x + 0.5) : (x - 0.5));
-}
-
-int
-NINT (double x)
-{
-  if (x > std::numeric_limits<int>::max ())
-    return std::numeric_limits<int>::max ();
-  else if (x < std::numeric_limits<int>::min ())
-    return std::numeric_limits<int>::min ();
-  else
-    return static_cast<int> ((x > 0) ? (x + 0.5) : (x - 0.5));
-}
-
-int
-NINT (float x)
-{
-  if (x > std::numeric_limits<int>::max ())
-    return std::numeric_limits<int>::max ();
-  else if (x < std::numeric_limits<int>::min ())
-    return std::numeric_limits<int>::min ();
-  else
-    return static_cast<int> ((x > 0) ? (x + 0.5) : (x - 0.5));
-}
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -24,327 +24,822 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_lo_mappers_h)
 #define octave_lo_mappers_h 1
 
 #include "octave-config.h"
 
 #include <limits>
 
 #include "oct-cmplx.h"
+#include "oct-inttypes.h"
 #include "lo-math.h"
 #include "lo-ieee.h"
 
-// Double Precision
-extern OCTAVE_API double xtrunc (double x);
-extern OCTAVE_API double xcopysign (double x, double y);
-inline double xceil (double x) { return ceil (x); }
-extern OCTAVE_API double xfloor (double x);
-inline double arg (double x) { return atan2 (0.0, x); }
-inline double conj (double x) { return x; }
-inline double fix (double x) { return xtrunc (x); }
-inline double imag (double) { return 0.0; }
-inline double real (double x) { return x; }
-extern OCTAVE_API double xround (double x);
-extern OCTAVE_API double xroundb (double x);
-extern OCTAVE_API double signum (double x);
-extern OCTAVE_API double xlog2 (double x);
-extern OCTAVE_API Complex xlog2 (const Complex& x);
-extern OCTAVE_API double xlog2 (double x, int& exp);
-extern OCTAVE_API Complex xlog2 (const Complex& x, int& exp);
-extern OCTAVE_API double xexp2 (double x);
+namespace octave
+{
+  namespace math
+  {
+    extern OCTAVE_API bool is_NA (double x);
+    extern OCTAVE_API bool is_NA (float x);
+
+    extern OCTAVE_API bool is_NA (const Complex& x);
+    extern OCTAVE_API bool is_NA (const FloatComplex& x);
+
+    extern OCTAVE_API bool is_NaN_or_NA (const Complex& x);
+    extern OCTAVE_API bool is_NaN_or_NA (const FloatComplex& x);
+
+    extern OCTAVE_API Complex acos (const Complex& x);
+    extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
+
+    extern OCTAVE_API Complex asin (const Complex& x);
+    extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
+
+    extern OCTAVE_API Complex atan (const Complex& x);
+    extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
+
+    inline double arg (double x) { return atan2 (0.0, x); }
+    inline float arg (float x) { return atan2f (0.0f, x); }
+
+    using std::arg;
+
+    inline double conj (double x) { return x; }
+    inline float conj (float x) { return x; }
+
+    using std::conj;
+
+    inline double imag (double) { return 0.0; }
+    inline float imag (float) { return 0.0f; }
+
+    using std::imag;
+
+    inline double real (double x) { return x; }
+    inline float real (float x) { return x; }
+
+    using std::real;
+
+    extern OCTAVE_API double log2 (double x);
+    extern OCTAVE_API float log2 (float x);
+
+    extern OCTAVE_API Complex log2 (const Complex& x);
+    extern OCTAVE_API FloatComplex log2 (const FloatComplex& x);
+
+    extern OCTAVE_API double log2 (double x, int& exp);
+    extern OCTAVE_API float log2 (float x, int& exp);
+
+    extern OCTAVE_API Complex log2 (const Complex& x, int& exp);
+    extern OCTAVE_API FloatComplex log2 (const FloatComplex& x, int& exp);
+
+    extern OCTAVE_API double exp2 (double x);
+    extern OCTAVE_API float exp2 (float x);
+
+    inline double ceil (double x) { return ::ceil (x); }
+    inline float ceil (float x) { return ::ceilf (x); }
+
+    template <typename T>
+    std::complex<T>
+    ceil (const std::complex<T>& x)
+    {
+      return std::complex<T> (ceil (real (x)), ceil (imag (x)));
+    }
+
+    extern OCTAVE_API double copysign (double x, double y);
+    extern OCTAVE_API float copysign (float x, float y);
+
+    extern OCTAVE_API double signbit (double x);
+    extern OCTAVE_API float signbit (float x);
+
+    // Test for negative sign.
+    extern OCTAVE_API bool negative_sign (double x);
+    extern OCTAVE_API bool negative_sign (float x);
+
+    // Test for positive sign.
+    inline bool positive_sign (double x) { return ! negative_sign (x); }
+    inline bool positive_sign (float x) { return ! negative_sign (x); }
+
+    extern OCTAVE_API double trunc (double x);
+    extern OCTAVE_API float trunc (float x);
+
+    template <typename T>
+    std::complex<T>
+    trunc (const std::complex<T>& x)
+    {
+      return std::complex<T> (trunc (real (x)), trunc (imag (x)));
+    }
+
+    inline double fix (double x) { return trunc (x); }
+    inline float fix (float x) { return trunc (x); }
 
-// These are used by the BOOL_OP macros in mx-op-defs.h.
-inline bool xisnan (bool) { return false; }
-inline bool xisnan (char) { return false; }
+    template <typename T>
+    std::complex<T>
+    fix (const std::complex<T>& x)
+    {
+      return trunc (x);
+    }
+
+    extern OCTAVE_API double floor (double x);
+    extern OCTAVE_API float floor (float x);
+
+    template <typename T>
+    std::complex<T>
+    floor (const std::complex<T>& x)
+    {
+      return std::complex<T> (floor (real (x)), floor (imag (x)));
+    }
+
+    extern OCTAVE_API double round (double x);
+    extern OCTAVE_API float round (float x);
+
+    template <typename T>
+    std::complex<T>
+    round (const std::complex<T>& x)
+    {
+      return std::complex<T> (round (real (x)), round (imag (x)));
+    }
+
+    inline double
+    roundb (double x)
+    {
+      double t = round (x);
+
+      if (fabs (x - t) == 0.5)
+        t = 2 * trunc (0.5 * t);
+
+      return t;
+    }
+
+    inline float
+    roundb (float x)
+    {
+      float t = round (x);
+
+      if (fabsf (x - t) == 0.5)
+        t = 2 * trunc (0.5 * t);
+
+      return t;
+    }
 
-extern OCTAVE_API bool xisnan (double x);
-extern OCTAVE_API bool xfinite (double x);
-extern OCTAVE_API bool xisinf (double x);
+    template <typename T>
+    std::complex<T>
+    roundb (const std::complex<T>& x)
+    {
+      return std::complex<T> (roundb (real (x)), roundb (imag (x)));
+    }
+
+    inline bool isnan (bool) { return false; }
+    inline bool isnan (char) { return false; }
+    extern OCTAVE_API bool isnan (double x);
+    extern OCTAVE_API bool isnan (float x);
+
+    template <typename T>
+    bool
+    isnan (const std::complex<T>& x)
+    {
+      return (isnan (real (x)) || isnan (imag (x)));
+    }
+
+    extern OCTAVE_API bool finite (double x);
+    extern OCTAVE_API bool finite (float x);
+
+    template <typename T>
+    bool
+    finite (const std::complex<T>& x)
+    {
+      return (finite (real (x)) && finite (imag (x)));
+    }
+
+    extern OCTAVE_API bool isinf (double x);
+    extern OCTAVE_API bool isinf (float x);
+
+    template <typename T>
+    bool
+    isinf (const std::complex<T>& x)
+    {
+      return (isinf (real (x)) || isinf (imag (x)));
+    }
+
+    // Some useful tests, that are commonly repeated.
+    // Test for a finite integer.
+
+    inline bool isinteger (double x) { return finite (x) && x == round (x); }
+    inline bool isinteger (float x) { return finite (x) && x == round (x); }
+
+    inline double
+    signum (double x)
+    {
+      double tmp = 0.0;
+
+      if (x < 0.0)
+        tmp = -1.0;
+      else if (x > 0.0)
+        tmp = 1.0;
+
+      return isnan (x) ? octave::numeric_limits<double>::NaN () : tmp;
+    }
 
-extern OCTAVE_API bool octave_is_NA (double x);
+    inline float
+    signum (float x)
+    {
+      float tmp = 0.0f;
+
+      if (x < 0.0f)
+        tmp = -1.0f;
+      else if (x > 0.0f)
+        tmp = 1.0f;
+
+      return isnan (x) ? octave::numeric_limits<float>::NaN () : tmp;
+    }
+       
+    template <typename T>
+    std::complex<T>
+    signum (const std::complex<T>& x)
+    {
+      T tmp = abs (x);
+
+      return tmp == 0 ? 0.0 : x / tmp;
+    }
+
+    // Convert X to the nearest integer value.  Should not pass NaN to
+    // this function.
+
+    // For integer types?  Hmm.  Need to be sure T is an integer type...
+    template <typename T>
+    T
+    x_nint (T x)
+    {
+      return x;
+    }
+
+    template <>
+    inline double x_nint (double x) { return (finite (x) ? floor (x + 0.5) : x); }
+    template <>
+    inline float x_nint (float x) { return (finite (x) ? floor (x + 0.5f) : x); }
+
+    extern OCTAVE_API octave_idx_type nint_big (double x);
+    extern OCTAVE_API octave_idx_type nint_big (float x);
+
+    extern OCTAVE_API int nint (double x);
+    extern OCTAVE_API int nint (float x);
+
+    template <typename T>
+    T
+    mod (T x, T y)
+    {
+      T retval;
 
-// Generic xmin, xmax definitions
-template <typename T>
-inline T xmin (T x, T y)
-{
-  return x <= y ? x : y;
-}
+      if (y == 0)
+        retval = x;
+      else
+        {
+          T q = x / y;
+
+          if (x_nint (y) != y
+              && (std::abs ((q - x_nint (q)) / x_nint (q))
+                  < std::numeric_limits<T>::epsilon ()))
+            retval = 0;
+          else
+            {
+              T n = floor (q);
+
+              // Prevent use of extra precision.
+              volatile T tmp = y * n;
+
+              retval = x - tmp;
+            }
+        }
+
+      if (x != y && y != 0)
+        retval = copysign (retval, y);
+
+      return retval;
+    }
+
+    template <typename T>
+    T
+    rem (T x, T y)
+    {
+      T retval;
+
+      if (y == 0)
+        retval = octave::numeric_limits<T>::NaN ();
+      else
+        {
+          T q = x / y;
+
+          if (x_nint (y) != y
+              && (std::abs ((q - x_nint (q)) / x_nint (q))
+                  < std::numeric_limits<T>::epsilon ()))
+            retval = 0;
+          else
+            {
+              T n = trunc (q);
+
+              // Prevent use of extra precision.
+              volatile T tmp = y * n;
 
-template <typename T>
-inline T xmax (T x, T y)
-{
-  return x >= y ? x : y;
-}
+              retval = x - tmp;
+            }
+        }
+
+      if (x != y && y != 0)
+        retval = copysign (retval, x);
+
+      return retval;
+    }
+
+    // Generic min, max definitions
+    template <typename T>
+    T
+    min (T x, T y)
+    {
+      return x <= y ? x : y;
+    }
+
+    template <typename T>
+    T
+    max (T x, T y)
+    {
+      return x >= y ? x : y;
+    }
+
+    // This form is favorable.  GCC will translate (x <= y ? x : y) without a
+    // jump, hence the only conditional jump involved will be the first
+    // (isnan), infrequent and hence friendly to branch prediction.
+
+    inline double
+    min (double x, double y)
+    {
+      return isnan (y) ? x : (x <= y ? x : y);
+    }
+
+    inline double
+    max (double x, double y)
+    {
+      return isnan (y) ? x : (x >= y ? x : y);
+    }
+
+    inline float
+    min (float x, float y)
+    {
+      return isnan (y) ? x : (x <= y ? x : y);
+    }
 
-// This form is favorable.  GCC will translate (x <= y ? x : y) without a
-// jump, hence the only conditional jump involved will be the first
-// (xisnan), infrequent and hence friendly to branch prediction.
-inline double
-xmin (double x, double y)
-{
-  return xisnan (y) ? x : (x <= y ? x : y);
-}
+    inline float
+    max (float x, float y)
+    {
+      return isnan (y) ? x : (x >= y ? x : y);
+    }
+
+    inline std::complex<double>
+    min (const std::complex<double>& x, const std::complex<double>& y)
+    {
+      return abs (x) <= abs (y) ? x : (isnan (x) ? x : y);
+    }
+
+    inline std::complex<float>
+    min (const std::complex<float>& x, const std::complex<float>& y)
+    {
+      return abs (x) <= abs (y) ? x : (isnan (x) ? x : y);
+    }
+
+    inline std::complex<double>
+    max (const std::complex<double>& x, const std::complex<double>& y)
+    {
+      return abs (x) >= abs (y) ? x : (isnan (x) ? x : y);
+    }
 
-inline double
-xmax (double x, double y)
-{
-  return xisnan (y) ? x : (x >= y ? x : y);
+    inline std::complex<float>
+    max (const std::complex<float>& x, const std::complex<float>& y)
+    {
+      return abs (x) >= abs (y) ? x : (isnan (x) ? x : y);
+    }
+
+    // These map reals to Complex.
+
+    extern OCTAVE_API Complex rc_acos (double);
+    extern OCTAVE_API FloatComplex rc_acos (float);
+
+    extern OCTAVE_API Complex rc_acosh (double);
+    extern OCTAVE_API FloatComplex rc_acosh (float);
+
+    extern OCTAVE_API Complex rc_asin (double);
+    extern OCTAVE_API FloatComplex rc_asin (float);
+
+    extern OCTAVE_API Complex rc_atanh (double);
+    extern OCTAVE_API FloatComplex rc_atanh (float);
+
+    extern OCTAVE_API Complex rc_log (double);
+    extern OCTAVE_API FloatComplex rc_log (float);
+
+    extern OCTAVE_API Complex rc_log2 (double);
+    extern OCTAVE_API FloatComplex rc_log2 (float);
+
+    extern OCTAVE_API Complex rc_log10 (double);
+    extern OCTAVE_API FloatComplex rc_log10 (float);
+
+    extern OCTAVE_API Complex rc_sqrt (double);
+    extern OCTAVE_API FloatComplex rc_sqrt (float);
+  }
 }
 
-extern OCTAVE_API Complex acos (const Complex& x);
-extern OCTAVE_API Complex asin (const Complex& x);
-extern OCTAVE_API Complex atan (const Complex& x);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
+inline bool octave_is_NA (double x) { return octave::math::is_NA (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
+inline bool octave_is_NA (float x) { return octave::math::is_NA (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
+inline bool octave_is_NA (const Complex& x) { return octave::math::is_NA (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
+inline bool octave_is_NA (const FloatComplex& x) { return octave::math::is_NA (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::is_NaN_or_NA' instead")
+inline bool octave_is_NaN_or_NA (const Complex& x) { return octave::math::is_NaN_or_NA (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::is_NaN_or_NA' instead")
+inline bool octave_is_NaN_or_NA (const FloatComplex& x) { return octave::math::is_NaN_or_NA (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::acos' instead")
+inline Complex acos (const Complex& x) { return octave::math::acos (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::acos' instead")
+inline FloatComplex acos (const FloatComplex& x) { return octave::math::acos (x); }
 
-extern OCTAVE_API bool octave_is_NA (const Complex& x);
-extern OCTAVE_API bool octave_is_NaN_or_NA (const Complex& x);
+OCTAVE_DEPRECATED ("use 'octave::math::asin' instead")
+inline Complex asin (const Complex& x) { return octave::math::asin (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::asin' instead")
+inline FloatComplex asin (const FloatComplex& x) { return octave::math::asin (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::atan' instead")
+inline Complex atan (const Complex& x) { return octave::math::atan (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::atan' instead")
+inline FloatComplex atan (const FloatComplex& x) { return octave::math::atan (x); }
 
-extern OCTAVE_API Complex xmin (const Complex& x, const Complex& y);
-extern OCTAVE_API Complex xmax (const Complex& x, const Complex& y);
+OCTAVE_DEPRECATED ("use 'octave::math::arg' instead")
+inline double arg (double x) { return octave::math::arg (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::arg' instead")
+inline float arg (float x) { return octave::math::arg (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::conj' instead")
+inline double conj (double x) { return octave::math::conj (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::conj' instead")
+inline float conj (float x) { return octave::math::conj (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::imag' instead")
+inline double imag (double x) { return octave::math::imag (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::imag' instead")
+inline float imag (float x) { return octave::math::imag (x); }
 
-// Single Precision
-extern OCTAVE_API float xtrunc (float x);
-extern OCTAVE_API float xcopysign (float x, float y);
-inline float xceil (float x) { return ceilf (x); }
-extern OCTAVE_API float xfloor (float x);
-inline float arg (float x) { return atan2f (0.0f, x); }
-inline float conj (float x) { return x; }
-inline float fix (float x) { return xtrunc (x); }
-inline float imag (float) { return 0.0f; }
-inline float real (float x) { return x; }
-extern OCTAVE_API float xround (float x);
-extern OCTAVE_API float xroundb (float x);
-extern OCTAVE_API float signum (float x);
-extern OCTAVE_API float xlog2 (float x);
-extern OCTAVE_API FloatComplex xlog2 (const FloatComplex& x);
-extern OCTAVE_API float xlog2 (float x, int& exp);
-extern OCTAVE_API FloatComplex xlog2 (const FloatComplex& x, int& exp);
-extern OCTAVE_API float xexp2 (float x);
+OCTAVE_DEPRECATED ("use 'octave::math::real' instead")
+inline double real (double x) { return octave::math::real (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::real' instead")
+inline float real (float x) { return octave::math::real (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline double xlog2 (double x) { return octave::math::log2 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline float xlog2 (float x) { return octave::math::log2 (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline Complex xlog2 (const Complex& x) { return octave::math::log2 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline FloatComplex xlog2 (const FloatComplex& x) { return octave::math::log2 (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline double xlog2 (double x, int& exp) { return octave::math::log2 (x, exp); }
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline float xlog2 (float x, int& exp) { return octave::math::log2 (x, exp); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline Complex xlog2 (const Complex& x, int& exp) { return octave::math::log2 (x, exp); }
+OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
+inline FloatComplex xlog2 (const FloatComplex& x, int& exp) { return octave::math::log2 (x, exp); }
 
-extern OCTAVE_API bool xisnan (float x);
-extern OCTAVE_API bool xfinite (float x);
-extern OCTAVE_API bool xisinf (float x);
+OCTAVE_DEPRECATED ("use 'octave::math::exp2' instead")
+inline double xexp2 (double x) { return octave::math::exp2 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::exp2' instead")
+inline float xexp2 (float x) { return octave::math::exp2 (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::ceil' instead")
+inline double xceil (double x) { return octave::math::ceil (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::ceil' instead")
+inline float xceil (float x) { return octave::math::ceil (x); }
 
-extern OCTAVE_API bool octave_is_NA (float x);
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::ceil' instead")
+std::complex<T>
+ceil (const std::complex<T>& x)
+{
+  return octave::math::ceil (x);
+}
 
-inline float
-xmin (float x, float y)
+OCTAVE_DEPRECATED ("use 'octave::math::copysign' instead")
+inline double xcopysign (double x, double y) { return octave::math::copysign (x, y); }
+OCTAVE_DEPRECATED ("use 'octave::math::copysign' instead")
+inline float xcopysign (float x, float y) { return octave::math::copysign (x, y); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::signbit' instead")
+T
+xsignbit (T x)
 {
-  return xisnan (y) ? x : (x <= y ? x : y);
+  return octave::math::signbit (x);
 }
 
-inline float
-xmax (float x, float y)
+OCTAVE_DEPRECATED ("use 'octave::math::negative_sign' instead")
+inline bool xnegative_sign (double x) { return octave::math::negative_sign (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::negative_sign' instead")
+inline bool xnegative_sign (float x) { return octave::math::negative_sign (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::positive_sign' instead")
+inline bool xpositive_sign (double x) { return octave::math::positive_sign (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::positive_sign' instead")
+inline bool xpositive_sign (float x) { return octave::math::positive_sign (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
+inline double signum (double x) { return octave::math::signum (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
+inline float signum (float x) { return octave::math::signum (x); }
+       
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
+std::complex<T>
+signum (const std::complex<T>& x)
 {
-  return xisnan (y) ? x : (x >= y ? x : y);
+  return octave::math::signum (x);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::trunc' instead")
+inline double xtrunc (double x) { return octave::math::trunc (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::trunc' instead")
+inline float xtrunc (float x) { return octave::math::trunc (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::trunc' instead")
+std::complex<T>
+xtrunc (const std::complex<T>& x)
+{
+  return octave::math::trunc (x);
+}
+    
+OCTAVE_DEPRECATED ("use 'octave::math::fix' instead")
+inline double fix (double x) { return octave::math::fix (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::fix' instead")
+inline float fix (float x) { return octave::math::fix (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::fix' instead")
+std::complex<T>
+fix (const std::complex<T>& x)
+{
+  return octave::math::fix (x);
+}
+    
+OCTAVE_DEPRECATED ("use 'octave::math::floor' instead")
+inline double xfloor (double x) { return octave::math::floor (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::floor' instead")
+inline float xfloor (float x) { return octave::math::floor (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::floor' instead")
+std::complex<T>
+floor (const std::complex<T>& x)
+{
+  return octave::math::floor (x);
 }
 
-extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
-extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
-extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
+OCTAVE_DEPRECATED ("use 'octave::math::round' instead")
+inline double xround (double x) { return octave::math::round (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::round' instead")
+inline float xround (float x) { return octave::math::round (x); }
 
-extern OCTAVE_API bool octave_is_NA (const FloatComplex& x);
-extern OCTAVE_API bool octave_is_NaN_or_NA (const FloatComplex& x);
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::round' instead")
+std::complex<T>
+xround (const std::complex<T>& x)
+{
+  return octave::math::round (x);
+}
 
-extern OCTAVE_API FloatComplex xmin (const FloatComplex& x,
-                                     const FloatComplex& y);
-extern OCTAVE_API FloatComplex xmax (const FloatComplex& x,
-                                     const FloatComplex& y);
+OCTAVE_DEPRECATED ("use 'octave::math::roundb' instead")
+inline double xroundb (double x) { return octave::math::roundb (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::roundb' instead")
+inline float xroundb (float x) { return octave::math::roundb (x); }
 
-// These map reals to Complex.
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::roundb' instead")
+std::complex<T>
+xroundb (const std::complex<T>& x)
+{
+  return octave::math::roundb (x);
+}
 
-extern OCTAVE_API Complex rc_acos (double);
-extern OCTAVE_API FloatComplex rc_acos (float);
-extern OCTAVE_API Complex rc_acosh (double);
-extern OCTAVE_API FloatComplex rc_acosh (float);
-extern OCTAVE_API Complex rc_asin (double);
-extern OCTAVE_API FloatComplex rc_asin (float);
-extern OCTAVE_API Complex rc_atanh (double);
-extern OCTAVE_API FloatComplex rc_atanh (float);
-extern OCTAVE_API Complex rc_log (double);
-extern OCTAVE_API FloatComplex rc_log (float);
-extern OCTAVE_API Complex rc_log2 (double);
-extern OCTAVE_API FloatComplex rc_log2 (float);
-extern OCTAVE_API Complex rc_log10 (double);
-extern OCTAVE_API FloatComplex rc_log10 (float);
-extern OCTAVE_API Complex rc_sqrt (double);
-extern OCTAVE_API FloatComplex rc_sqrt (float);
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline bool xisnan (bool x) { return octave::math::isnan (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline bool xisnan (char x) { return octave::math::isnan (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline bool xisnan (double x) { return octave::math::isnan (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline bool xisnan (float x) { return octave::math::isnan (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+bool
+xisnan (const std::complex<T>& x)
+{
+  return octave::math::isnan (x);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::finite' instead")
+inline bool xfinite (double x) { return octave::math::finite (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::finite' instead")
+inline bool xfinite (float x) { return octave::math::finite (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::finite' instead")
+bool
+xfinite (const std::complex<T>& x)
+{
+  return octave::math::finite (x);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::isinf' instead")
+inline bool xisinf (double x) { return octave::math::isinf (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::isinf' instead")
+inline bool xisinf (float x) { return octave::math::isinf (x); }
+
+template <typename T>
+OCTAVE_DEPRECATED ("use 'octave::math::isinf' instead")
+bool
+xisinf (const std::complex<T>& x)
+{
+  return octave::math::isinf (x);
+}
 
 // Some useful tests, that are commonly repeated.
 // Test for a finite integer.
+
+OCTAVE_DEPRECATED ("use 'octave::math::isinteger' instead")
 inline bool
 xisinteger (double x)
 {
-  return xfinite (x) && x == xround (x);
+  return octave::math::isinteger (x);
 }
 
+OCTAVE_DEPRECATED ("use 'octave::math::isinteger' instead")
 inline bool
 xisinteger (float x)
 {
-  return xfinite (x) && x == xround (x);
-}
-
-// Test for negative sign.
-extern OCTAVE_API bool xnegative_sign (double x);
-extern OCTAVE_API bool xnegative_sign (float x);
-
-// Test for positive sign.
-inline bool xpositive_sign (double x) { return ! xnegative_sign (x); }
-inline bool xpositive_sign (float x) { return ! xnegative_sign (x); }
-
-// Some old rounding functions.
-
-extern OCTAVE_API octave_idx_type NINTbig (double x);
-extern OCTAVE_API octave_idx_type NINTbig (float x);
-
-extern OCTAVE_API int NINT (double x);
-extern OCTAVE_API int NINT (float x);
-
-template <typename T>
-T
-X_NINT (T x)
-{
-  return (xfinite (x) ? xfloor (x + 0.5) : x);
-}
-
-inline OCTAVE_API double D_NINT (double x) { return X_NINT (x); }
-inline OCTAVE_API float F_NINT (float x) { return X_NINT (x); }
-
-// Template functions can have either float or double arguments.
-
-template <typename T>
-bool
-xisnan (const std::complex<T>& x)
-{
-  return (xisnan (real (x)) || xisnan (imag (x)));
+  return octave::math::isinteger (x);
 }
 
 template <typename T>
-bool
-xfinite (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::x_nint' instead")
+T
+X_NINT (T x)
 {
-  return (xfinite (real (x)) && xfinite (imag (x)));
+  return octave::math::x_nint (x);
 }
 
+OCTAVE_DEPRECATED ("use 'octave::math::x_nint (x)' instead")
+inline double D_NINT (double x) { return octave::math::x_nint (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::x_nint (x)' instead")
+inline float F_NINT (float x) { return octave::math::x_nint (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::nint_big' instead")
+inline octave_idx_type NINTbig (double x) { return octave::math::nint_big (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::nint_big' instead")
+inline octave_idx_type NINTbig (float x) { return octave::math::nint_big (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::nint' instead")
+inline int NINT (double x) { return octave::math::nint (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::nint' instead")
+inline int NINT (float x) { return octave::math::nint (x); }
+
 template <typename T>
-bool
-xisinf (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::mod' instead")
+T
+xmod (T x, T y)
 {
-  return (xisinf (real (x)) || xisinf (imag (x)));
+  return octave::math::mod (x, y);
 }
 
 template <typename T>
-std::complex<T>
-fix (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::rem' instead")
+T
+xrem (T x, T y)
 {
-  return std::complex<T> (fix (real (x)), fix (imag (x)));
+  return octave::math::rem (x, y);
 }
 
 template <typename T>
-std::complex<T>
-ceil (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::min' instead")
+T
+xmin (T x, T y)
 {
-  return std::complex<T> (xceil (real (x)), xceil (imag (x)));
-}
-
-template <typename T>
-std::complex<T>
-floor (const std::complex<T>& x)
-{
-  return std::complex<T> (xfloor (real (x)), xfloor (imag (x)));
-}
-
-template <typename T>
-std::complex<T>
-xround (const std::complex<T>& x)
-{
-  return std::complex<T> (xround (real (x)), xround (imag (x)));
+  return octave::math::min (x, y);
 }
 
 template <typename T>
-std::complex<T>
-xroundb (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::max' instead")
+T
+xmax (T x, T y)
 {
-  return std::complex<T> (xroundb (real (x)), xroundb (imag (x)));
+  return octave::math::max (x, y);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::min' instead")
+inline double
+xmin (double x, double y)
+{
+  return octave::math::min (x, y);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::max' instead")
+inline double
+xmax (double x, double y)
+{
+  return octave::math::max (x, y);
 }
 
-template <typename T>
-std::complex<T>
-signum (const std::complex<T>& x)
+OCTAVE_DEPRECATED ("use 'octave::math::min' instead")
+inline float
+xmin (float x, float y)
+{
+  return octave::math::min (x, y);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::max' instead")
+inline float
+xmax (float x, float y)
 {
-  T tmp = abs (x);
+  return octave::math::max (x, y);
+}
 
-  return tmp == 0 ? 0.0 : x / tmp;
+OCTAVE_DEPRECATED ("use 'octave::math::min' instead")
+inline Complex
+xmin (const Complex& x, const Complex& y)
+{
+  return octave::math::min (x, y);
+}
+
+OCTAVE_DEPRECATED ("use 'octave::math::max' instead")
+inline Complex
+xmax (const Complex& x, const Complex& y)
+{
+  return octave::math::max (x, y);
 }
 
-template <typename T>
-T
-xmod (T x, T y)
+OCTAVE_DEPRECATED ("use 'octave::math::min' instead")
+inline OCTAVE_API FloatComplex
+xmin (const FloatComplex& x, const FloatComplex& y)
 {
-  T retval;
-
-  if (y == 0)
-    retval = x;
-  else
-    {
-      T q = x / y;
+  return octave::math::min (x, y);
+}
 
-      if (X_NINT (y) != y
-          && (std::abs ((q - X_NINT (q)) / X_NINT (q))
-              < std::numeric_limits<T>::epsilon ()))
-        retval = 0;
-      else
-        {
-          T n = xfloor (q);
-
-          // Prevent use of extra precision.
-          volatile T tmp = y * n;
-
-          retval = x - tmp;
-        }
-    }
-
-  if (x != y && y != 0)
-    retval = xcopysign (retval, y);
-
-  return retval;
+OCTAVE_DEPRECATED ("use 'octave::math::max' instead")
+inline FloatComplex
+xmax (const FloatComplex& x, const FloatComplex& y)
+{
+  return octave::math::max (x, y);
 }
 
-template <typename T>
-T
-xrem (T x, T y)
-{
-  T retval;
+OCTAVE_DEPRECATED ("use 'octave::math::rc_acos' instead")
+inline Complex rc_acos (double x) { return octave::math::rc_acos (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_acos' instead")
+inline FloatComplex rc_acos (float x) { return octave::math::rc_acos (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::rc_acosh' instead")
+inline Complex rc_acosh (double x) { return octave::math::rc_acosh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_acosh' instead")
+inline FloatComplex rc_acosh (float x) { return octave::math::rc_acosh (x); }
 
-  if (y == 0)
-    retval = octave::numeric_limits<T>::NaN ();
-  else
-    {
-      T q = x / y;
+OCTAVE_DEPRECATED ("use 'octave::math::rc_asin' instead")
+inline Complex rc_asin (double x) { return octave::math::rc_asin (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_asin' instead")
+inline FloatComplex rc_asin (float x) { return octave::math::rc_asin (x); }
 
-      if (X_NINT (y) != y
-          && (std::abs ((q - X_NINT (q)) / X_NINT (q))
-              < std::numeric_limits<T>::epsilon ()))
-        retval = 0;
-      else
-        {
-          T n = xtrunc (q);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_atanh' instead")
+inline Complex rc_atanh (double x) { return octave::math::rc_atanh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_atanh' instead")
+inline FloatComplex rc_atanh (float x) { return octave::math::rc_atanh (x); }
 
-          // Prevent use of extra precision.
-          volatile T tmp = y * n;
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log' instead")
+inline Complex rc_log (double x) { return octave::math::rc_log (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log' instead")
+inline FloatComplex rc_log (float x) { return octave::math::rc_log (x); }
 
-          retval = x - tmp;
-        }
-    }
-
-  if (x != y && y != 0)
-    retval = xcopysign (retval, x);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log2' instead")
+inline Complex rc_log2 (double x) { return octave::math::rc_log2 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log2' instead")
+inline FloatComplex rc_log2 (float x) { return octave::math::rc_log2 (x); }
 
-  return retval;
-}
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log10' instead")
+inline Complex rc_log10 (double x) { return octave::math::rc_log10 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log10' instead")
+inline FloatComplex rc_log10 (float x) { return octave::math::rc_log10 (x); }
 
-template <typename T>
-T
-xsignbit (T x)
-{
-  return signbit (x);
-}
+OCTAVE_DEPRECATED ("use 'octave::math::rc_sqrt' instead")
+inline Complex rc_sqrt (double x) { return octave::math::rc_sqrt (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_sqrt' instead")
+inline FloatComplex rc_sqrt (float x) { return octave::math::rc_sqrt (x); }
 
 #endif
+
+#endif
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -436,22 +436,22 @@ double
 xgamma (double x)
 {
   double result;
 
   // Special cases for (near) compatibility with Matlab instead of
   // tgamma.  Matlab does not have -0.
 
   if (x == 0)
-    result = (xnegative_sign (x)
+    result = (octave::math::negative_sign (x)
               ? -octave::numeric_limits<double>::Inf ()
               : octave::numeric_limits<double>::Inf ());
-  else if ((x < 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<double>::Inf ();
-  else if (xisnan (x))
+  else if (octave::math::isnan (x))
     result = octave::numeric_limits<double>::NaN ();
   else
     {
 #if defined (HAVE_TGAMMA)
       result = tgamma (x);
 #else
       F77_XFCN (xdgamma, XDGAMMA, (x, result));
 #endif
@@ -464,19 +464,19 @@ double
 xlgamma (double x)
 {
 #if defined (HAVE_LGAMMA)
   return lgamma (x);
 #else
   double result;
   double sgngam;
 
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     result = x;
-  else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<double>::Inf ();
   else
     F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
@@ -486,19 +486,19 @@ rc_lgamma (double x)
   double result;
 
 #if defined (HAVE_LGAMMA_R)
   int sgngam;
   result = lgamma_r (x, &sgngam);
 #else
   double sgngam = 0.0;
 
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     result = x;
-  else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<double>::Inf ();
   else
     F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
 #endif
 
   if (sgngam < 0)
     return result + Complex (0., M_PI);
@@ -510,22 +510,22 @@ float
 xgamma (float x)
 {
   float result;
 
   // Special cases for (near) compatibility with Matlab instead of
   // tgamma.  Matlab does not have -0.
 
   if (x == 0)
-    result = (xnegative_sign (x)
+    result = (octave::math::negative_sign (x)
               ? -octave::numeric_limits<float>::Inf ()
               : octave::numeric_limits<float>::Inf ());
-  else if ((x < 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<float>::Inf ();
-  else if (xisnan (x))
+  else if (octave::math::isnan (x))
     result = octave::numeric_limits<float>::NaN ();
   else
     {
 #if defined (HAVE_TGAMMA)
       result = tgammaf (x);
 #else
       F77_XFCN (xgamma, XGAMMA, (x, result));
 #endif
@@ -538,19 +538,19 @@ float
 xlgamma (float x)
 {
 #if defined (HAVE_LGAMMAF)
   return lgammaf (x);
 #else
   float result;
   float sgngam;
 
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     result = x;
-  else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<float>::Inf ();
   else
     F77_XFCN (algams, ALGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
@@ -560,19 +560,19 @@ rc_lgamma (float x)
   float result;
 
 #if defined (HAVE_LGAMMAF_R)
   int sgngam;
   result = lgammaf_r (x, &sgngam);
 #else
   float sgngam = 0.0f;
 
-  if (xisnan (x))
+  if (octave::math::isnan (x))
     result = x;
-  else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
+  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
     result = octave::numeric_limits<float>::Inf ();
   else
     F77_XFCN (algams, ALGAMS, (x, result, sgngam));
 
 #endif
 
   if (sgngam < 0)
     return result + FloatComplex (0., M_PI);
@@ -739,17 +739,17 @@ xlog1p (const Complex& x)
   return retval;
 }
 
 template <typename T>
 T
 xxcbrt (T x)
 {
   static const T one_third = 0.3333333333333333333f;
-  if (xfinite (x))
+  if (octave::math::finite (x))
     {
       // Use pow.
       T y = std::pow (std::abs (x), one_third) * signum (x);
       // Correct for better accuracy.
       return (x / (y*y) + y + y) / 3;
     }
   else
     return x;
@@ -3041,20 +3041,20 @@ static double do_erfinv (double x, bool 
       y = yn / yd;
     }
   else if (ax < 1.0)
     {
       // Tail region.
       const double q = sqrt (-2*gnulib::log (0.5*(1-ax)));
       const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
       const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
-      y = yn / yd * signum (-x);
+      y = yn / yd * octave::math::signum (-x);
     }
   else if (ax == 1.0)
-    return octave::numeric_limits<double>::Inf () * signum (x);
+    return octave::numeric_limits<double>::Inf () * octave::math::signum (x);
   else
     return octave::numeric_limits<double>::NaN ();
 
   if (refine)
     {
       // One iteration of Halley's method gives full precision.
       double u = (erf (y) - x) * spi2 * exp (y*y);
       y -= u / (1 + y*u);
@@ -3762,17 +3762,17 @@ Lanczos_approximation_psi (const T zc)
 }
 
 template <typename T>
 T
 psi (const T& z)
 {
   static const double euler_mascheroni = 0.577215664901532860606512090082402431042;
 
-  const bool is_int = (xfloor (z) == z);
+  const bool is_int = (octave::math::floor (z) == z);
 
   T p = 0;
   if (z <= 0)
     {
       // limits - zeros of the gamma function
       if (is_int)
         p = -octave::numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
       else
@@ -3781,17 +3781,17 @@ psi (const T& z)
     }
   else if (is_int)
     {
       // Abramowitz and Stegun, page 258, eq 6.3.2
       p = - euler_mascheroni;
       for (octave_idx_type k = z - 1; k > 0; k--)
         p += 1.0 / k;
     }
-  else if (xfloor (z + 0.5) == z + 0.5)
+  else if (octave::math::floor (z + 0.5) == z + 0.5)
     {
       // Abramowitz and Stegun, page 258, eq 6.3.3 and 6.3.4
       for (octave_idx_type k = z; k > 0; k--)
         p += 1.0 / (2 * k - 1);
 
       p = - euler_mascheroni - 2 * gnulib::log (2) + 2 * (p);
     }
   else
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -174,17 +174,17 @@ template <typename R>
 class norm_accumulator_inf
 {
   R max;
 public:
   norm_accumulator_inf () : max (0) {}
   template <typename U>
   void accum (U val)
   {
-    if (xisnan (val))
+    if (octave::math::isnan (val))
       max = octave::numeric_limits<R>::NaN ();
     else
       max = std::max (max, std::abs (val));
   }
   operator R () { return max; }
 };
 
 // norm accumulator for the -inf pseudonorm (min abs value)
@@ -192,17 +192,17 @@ template <typename R>
 class norm_accumulator_minf
 {
   R min;
 public:
   norm_accumulator_minf () : min (octave::numeric_limits<R>::Inf ()) {}
   template <typename U>
   void accum (U val)
   {
-    if (xisnan (val))
+    if (octave::math::isnan (val))
       min = octave::numeric_limits<R>::NaN ();
     else
       min = std::min (min, std::abs (val));
   }
   operator R () { return min; }
 };
 
 // norm accumulator for the 0-pseudonorm (hamming distance)
@@ -398,17 +398,17 @@ higham_subp (const ColVectorT& y, const 
         }
     }
 }
 
 // the p-dual element (should work for both real and complex)
 template <typename T, typename R>
 inline T elem_dual_p (T x, R p)
 {
-  return signum (x) * std::pow (std::abs (x), p-1);
+  return octave::math::signum (x) * std::pow (std::abs (x), p-1);
 }
 
 // the VectorT is used for vectors, but actually it has to be
 // a Matrix type to allow all the operations.  For instance SparseMatrix
 // does not support multiplication with column/row vectors.
 // the dual vector
 template <typename VectorT, typename R>
 VectorT dual_p (const VectorT& x, R p, R q)
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -351,28 +351,28 @@ octave_rand::do_scalar (double a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
           break;
 
         case poisson_dist:
-          if (a < 0.0 || ! xfinite (a))
+          if (a < 0.0 || ! octave::math::finite (a))
             retval = octave::numeric_limits<double>::NaN ();
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
               F77_FUNC (dignpoi, DIGNPOI) (a, retval);
             }
           break;
 
         case gamma_dist:
-          if (a <= 0.0 || ! xfinite (a))
+          if (a <= 0.0 || ! octave::math::finite (a))
             retval = octave::numeric_limits<double>::NaN ();
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -434,28 +434,28 @@ octave_rand::do_float_scalar (float a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, dretval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, dretval);
           break;
 
         case poisson_dist:
-          if (da < 0.0 || ! xfinite (a))
+          if (da < 0.0 || ! octave::math::finite (a))
             dretval = octave::numeric_limits<double>::NaN ();
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
-          if (da <= 0.0 || ! xfinite (a))
+          if (da <= 0.0 || ! octave::math::finite (a))
             dretval = octave::numeric_limits<double>::NaN ();
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -665,17 +665,17 @@ octave_rand::get_dist_id (const std::str
 // 2) NaN, Inf are translated to 2^32-1.
 // 3) -Inf is translated to 0.
 static uint32_t
 double2uint32 (double d)
 {
   uint32_t u;
   static const double TWOUP32 = std::numeric_limits<uint32_t>::max() + 1.0;
 
-  if (! xfinite (d))
+  if (! octave::math::finite (d))
     u = 0;
   else
     {
       d = fmod (d, TWOUP32);
       if (d < 0)
         d += TWOUP32;
       u = static_cast<uint32_t> (d);
     }
@@ -763,17 +763,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
-          if (a < 0.0 || ! xfinite (a))
+          if (a < 0.0 || ! octave::math::finite (a))
 #define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
@@ -784,17 +784,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
-          if (a <= 0.0 || ! xfinite (a))
+          if (a <= 0.0 || ! octave::math::finite (a))
 #define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
@@ -853,17 +853,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da < 0.0 || ! xfinite (a))
+          if (da < 0.0 || ! octave::math::finite (a))
 #define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
@@ -875,17 +875,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da <= 0.0 || ! xfinite (a))
+          if (da <= 0.0 || ! octave::math::finite (a))
 #define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, da, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -383,43 +383,43 @@ sparse_lu<lu_type>::sparse_lu (const lu_
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_defaults<lu_elt_type> (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU
   if (scale)
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
   else
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
@@ -581,49 +581,49 @@ sparse_lu<lu_type>::sparse_lu (const lu_
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   umfpack_defaults<lu_elt_type> (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
-  if (! xisnan (tmp))
+  if (! octave::math::isnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   if (droptol >= 0.)
     Control (UMFPACK_DROPTOL) = droptol;
 
   // Set whether we are allowed to modify Q or not
   if (FixedQ)
     Control (UMFPACK_FIXQ) = 1.0;
   else
     {
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (! xisnan (tmp))
+      if (! octave::math::isnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
     }
 
   // Turn-off UMFPACK scaling for LU
   if (scale)
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
   else
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -182,30 +182,30 @@ DEFMXBOOLOPEQ (mx_inline_and2, &=)
 DEFMXBOOLOPEQ (mx_inline_or2, |=)
 
 template <typename T>
 inline bool
 mx_inline_any_nan (size_t n, const T* x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
-      if (xisnan (x[i]))
+      if (octave::math::isnan (x[i]))
         return true;
     }
 
   return false;
 }
 
 template <typename T>
 inline bool
 mx_inline_all_finite (size_t n, const T* x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
-      if (! xfinite (x[i]))
+      if (! octave::math::finite (x[i]))
         return false;
     }
 
   return true;
 }
 
 template <typename T>
 inline bool
@@ -265,33 +265,33 @@ inline void F (size_t n, T *r, const T *
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
 template <typename T> \
 inline void F (size_t n, T *r, const T *x, T y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
 template <typename T> \
 inline void F (size_t n, T *r, T x, const T *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
-DEFMXMAPPER2 (mx_inline_xmin, xmin)
-DEFMXMAPPER2 (mx_inline_xmax, xmax)
+DEFMXMAPPER2 (mx_inline_xmin, octave::math::min)
+DEFMXMAPPER2 (mx_inline_xmax, octave::math::max)
 
 // Specialize array-scalar max/min
 #define DEFMINMAXSPEC(T, F, OP) \
 template <> \
 inline void F<T> (size_t n, T *r, const T *x, T y) throw () \
 { \
-  if (xisnan (y)) \
+  if (octave::math::isnan (y)) \
     std::memcpy (r, x, n * sizeof (T)); \
   else \
     for (size_t i = 0; i < n; i++) r[i] = (x[i] OP y) ? x[i] : y; \
 } \
 template <> \
 inline void F<T> (size_t n, T *r, T x, const T *y) throw () \
 { \
-  if (xisnan (x)) \
+  if (octave::math::isnan (x)) \
     std::memcpy (r, y, n * sizeof (T)); \
   else \
     for (size_t i = 0; i < n; i++) r[i] = (y[i] OP x) ? y[i] : x; \
 }
 
 DEFMINMAXSPEC (double, mx_inline_xmin, <=)
 DEFMINMAXSPEC (double, mx_inline_xmax, >=)
 DEFMINMAXSPEC (float, mx_inline_xmin, <=)
@@ -464,24 +464,24 @@ inline bool xis_true (T x) { return x; }
 template <typename T>
 inline bool xis_false (T x) { return ! x; }
 // for octave_ints
 template <typename T>
 inline bool xis_true (const octave_int<T>& x) { return x.value (); }
 template <typename T>
 inline bool xis_false (const octave_int<T>& x) { return ! x.value (); }
 // for reals, we want to ignore NaNs.
-inline bool xis_true (double x) { return ! xisnan (x) && x != 0.0; }
+inline bool xis_true (double x) { return ! octave::math::isnan (x) && x != 0.0; }
 inline bool xis_false (double x) { return x == 0.0; }
-inline bool xis_true (float x) { return ! xisnan (x) && x != 0.0f; }
+inline bool xis_true (float x) { return ! octave::math::isnan (x) && x != 0.0f; }
 inline bool xis_false (float x) { return x == 0.0f; }
 // Ditto for complex.
-inline bool xis_true (const Complex& x) { return ! xisnan (x) && x != 0.0; }
+inline bool xis_true (const Complex& x) { return ! octave::math::isnan (x) && x != 0.0; }
 inline bool xis_false (const Complex& x) { return x == 0.0; }
-inline bool xis_true (const FloatComplex& x) { return ! xisnan (x) && x != 0.0f; }
+inline bool xis_true (const FloatComplex& x) { return ! octave::math::isnan (x) && x != 0.0f; }
 inline bool xis_false (const FloatComplex& x) { return x == 0.0f; }
 
 #define OP_RED_SUM(ac, el) ac += el
 #define OP_RED_PROD(ac, el) ac *= el
 #define OP_RED_SUMSQ(ac, el) ac += el*el
 #define OP_RED_SUMSQC(ac, el) ac += cabsq (el)
 
 inline void op_dble_prod (double& ac, float el)
@@ -700,35 +700,35 @@ OP_CUM_FCNN (mx_inline_cumcount, bool, T
 
 #define OP_MINMAX_FCN(F, OP) \
 template <typename T> \
 void F (const T *v, T *r, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type i = 1; \
-  if (xisnan (tmp)) \
+  if (octave::math::isnan (tmp)) \
     { \
-      for (; i < n && xisnan (v[i]); i++) ; \
+      for (; i < n && octave::math::isnan (v[i]); i++) ; \
       if (i < n) tmp = v[i]; \
     } \
   for (; i < n; i++) \
     if (v[i] OP tmp) tmp = v[i]; \
   *r = tmp; \
 } \
 template <typename T> \
 void F (const T *v, T *r, octave_idx_type *ri, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type tmpi = 0; \
   octave_idx_type i = 1; \
-  if (xisnan (tmp)) \
+  if (octave::math::isnan (tmp)) \
     { \
-      for (; i < n && xisnan (v[i]); i++) ; \
+      for (; i < n && octave::math::isnan (v[i]); i++) ; \
       if (i < n) { tmp = v[i]; tmpi = i; } \
     } \
   for (; i < n; i++) \
     if (v[i] OP tmp) { tmp = v[i]; tmpi = i; }\
   *r = tmp; \
   *ri = tmpi; \
 }
 
@@ -745,27 +745,27 @@ inline void \
 F (const T *v, T *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
     {  \
       r[i] = v[i]; \
-      if (xisnan (v[i])) nan = true;  \
+      if (octave::math::isnan (v[i])) nan = true;  \
     } \
   j++; v += m; \
   while (nan && j < n) \
     { \
       nan = false; \
       for (octave_idx_type i = 0; i < m; i++) \
         {  \
-          if (xisnan (v[i])) \
+          if (octave::math::isnan (v[i])) \
             nan = true;  \
-          else if (xisnan (r[i]) || v[i] OP r[i]) \
+          else if (octave::math::isnan (r[i]) || v[i] OP r[i]) \
             r[i] = v[i]; \
         } \
       j++; v += m; \
     } \
   while (j < n) \
     { \
       for (octave_idx_type i = 0; i < m; i++) \
         if (v[i] OP r[i]) r[i] = v[i]; \
@@ -778,27 +778,27 @@ F (const T *v, T *r, octave_idx_type *ri
    octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
     {  \
       r[i] = v[i]; ri[i] = j; \
-      if (xisnan (v[i])) nan = true;  \
+      if (octave::math::isnan (v[i])) nan = true;  \
     } \
   j++; v += m; \
   while (nan && j < n) \
     { \
       nan = false; \
       for (octave_idx_type i = 0; i < m; i++) \
         {  \
-          if (xisnan (v[i])) \
+          if (octave::math::isnan (v[i])) \
             nan = true;  \
-          else if (xisnan (r[i]) || v[i] OP r[i]) \
+          else if (octave::math::isnan (r[i]) || v[i] OP r[i]) \
             { r[i] = v[i]; ri[i] = j; } \
         } \
       j++; v += m; \
     } \
   while (j < n) \
     { \
       for (octave_idx_type i = 0; i < m; i++) \
         if (v[i] OP r[i]) \
@@ -866,19 +866,19 @@ OP_MINMAX_FCNN (mx_inline_max)
 #define OP_CUMMINMAX_FCN(F, OP) \
 template <typename T> \
 void F (const T *v, T *r, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type i = 1; \
   octave_idx_type j = 0; \
-  if (xisnan (tmp)) \
+  if (octave::math::isnan (tmp)) \
     { \
-      for (; i < n && xisnan (v[i]); i++) ; \
+      for (; i < n && octave::math::isnan (v[i]); i++) ; \
       for (; j < i; j++) r[j] = tmp; \
       if (i < n) tmp = v[i]; \
     } \
   for (; i < n; i++) \
     if (v[i] OP tmp) \
       { \
         for (; j < i; j++) r[j] = tmp; \
         tmp = v[i]; \
@@ -887,19 +887,19 @@ void F (const T *v, T *r, octave_idx_typ
 } \
 template <typename T> \
 void F (const T *v, T *r, octave_idx_type *ri, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; octave_idx_type tmpi = 0; \
   octave_idx_type i = 1; \
   octave_idx_type j = 0; \
-  if (xisnan (tmp)) \
+  if (octave::math::isnan (tmp)) \
     { \
-      for (; i < n && xisnan (v[i]); i++) ; \
+      for (; i < n && octave::math::isnan (v[i]); i++) ; \
       for (; j < i; j++) { r[j] = tmp; ri[j] = tmpi; } \
       if (i < n) { tmp = v[i]; tmpi = i; } \
     } \
   for (; i < n; i++) \
     if (v[i] OP tmp) \
       { \
         for (; j < i; j++) { r[j] = tmp; ri[j] = tmpi; } \
         tmp = v[i]; tmpi = i; \
@@ -921,27 +921,27 @@ F (const T *v, T *r, octave_idx_type m, 
 { \
   if (! n) return; \
   bool nan = false; \
   const T *r0; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
     {  \
       r[i] = v[i]; \
-      if (xisnan (v[i])) nan = true;  \
+      if (octave::math::isnan (v[i])) nan = true;  \
     } \
   j++; v += m; r0 = r; r += m; \
   while (nan && j < n) \
     { \
       nan = false; \
       for (octave_idx_type i = 0; i < m; i++) \
         {  \
-          if (xisnan (v[i])) \
+          if (octave::math::isnan (v[i])) \
             { r[i] = r0[i]; nan = true; } \
-          else if (xisnan (r0[i]) || v[i] OP r0[i]) \
+          else if (octave::math::isnan (r0[i]) || v[i] OP r0[i]) \
             r[i] = v[i]; \
           else \
             r[i] = r0[i]; \
         } \
       j++; v += m; r0 = r; r += m; \
     } \
   while (j < n) \
     { \
@@ -960,27 +960,27 @@ F (const T *v, T *r, octave_idx_type *ri
 { \
   if (! n) return; \
   bool nan = false; \
   const T *r0; const octave_idx_type *r0i; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
     {  \
       r[i] = v[i]; ri[i] = 0; \
-      if (xisnan (v[i])) nan = true;  \
+      if (octave::math::isnan (v[i])) nan = true;  \
     } \
   j++; v += m; r0 = r; r += m; r0i = ri; ri += m;  \
   while (nan && j < n) \
     { \
       nan = false; \
       for (octave_idx_type i = 0; i < m; i++) \
         {  \
-          if (xisnan (v[i])) \
+          if (octave::math::isnan (v[i])) \
             { r[i] = r0[i]; ri[i] = r0i[i]; nan = true; } \
-          else if (xisnan (r0[i]) || v[i] OP r0[i]) \
+          else if (octave::math::isnan (r0[i]) || v[i] OP r0[i]) \
             { r[i] = v[i]; ri[i] = j; }\
           else \
             { r[i] = r0[i]; ri[i] = r0i[i]; }\
         } \
       j++; v += m; r0 = r; r += m; r0i = ri; ri += m;  \
     } \
   while (j < n) \
     { \
diff --git a/liboctave/operators/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
--- a/liboctave/operators/mx-op-defs.h
+++ b/liboctave/operators/mx-op-defs.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "lo-array-errwarn.h"
 #include "mx-op-decl.h"
 #include "mx-inlines.cc"
 
 #define SNANCHK(s) \
-  if (xisnan (s)) \
+  if (octave::math::isnan (s)) \
     err_nan_to_logical_conversion ()
 
 #define MNANCHK(m, MT) \
   if (do_mx_check (m, mx_inline_any_nan<MT>)) \
     err_nan_to_logical_conversion ()
 
 // vector by scalar operations.
 
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -40,37 +40,37 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 
 bool xis_int_or_inf_or_nan (double x)
-{ return xisnan (x) || D_NINT (x) == x; }
+{ return octave::math::isnan (x) || octave::math::x_nint (x) == x; }
 
 bool xis_one_or_zero (double x)
 { return x == 0 || x == 1; }
 
 bool xis_zero (double x)
 { return x == 0; }
 
 bool xtoo_large_for_float (double x)
 {
-  return (xfinite (x) && fabs (x) > std::numeric_limits<float>::max ());
+  return (octave::math::finite (x) && fabs (x) > std::numeric_limits<float>::max ());
 }
 
 bool xtoo_large_for_float (const Complex& x)
 {
   return (xtoo_large_for_float (x.real ())
           || xtoo_large_for_float (x.imag ()));
 }
 
 bool xis_int_or_inf_or_nan (float x)
-{ return xisnan (x) || D_NINT (x) == x; }
+{ return octave::math::isnan (x) || octave::math::x_nint (x) == x; }
 
 bool xis_one_or_zero (float x)
 { return x == 0 || x == 1; }
 
 bool xis_zero (float x)
 { return x == 0; }
 
 // Save a string.
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -57,31 +57,31 @@ template <class S>
 T
 octave_int_base<T>::convert_real (const S& value)
 {
   // Compute proper thresholds.
   static const S thmin = compute_threshold (static_cast<S> (min_val ()),
                                             min_val ());
   static const S thmax = compute_threshold (static_cast<S> (max_val ()),
                                             max_val ());
-  if (xisnan (value))
+  if (octave::math::isnan (value))
     {
       return static_cast<T> (0);
     }
   else if (value < thmin)
     {
       return min_val ();
     }
   else if (value > thmax)
     {
       return max_val ();
     }
   else
     {
-      S rvalue = xround (value);
+      S rvalue = octave::math::round (value);
       return static_cast<T> (rvalue);
     }
 }
 
 #define INSTANTIATE_CONVERT_REAL_1(T, S) \
   template \
   OCTAVE_API \
   T \
@@ -591,25 +591,25 @@ static double
 dbleget (bool sign, uint32_t mtis, int exp)
 {
   double x = ldexp (static_cast<double> (mtis), exp);
   return sign ? -x : x;
 }
 
 INT_DOUBLE_BINOP_DECL (*, uint64)
 {
-  if (y >= 0 && y < octave_uint64::max () && y == xround (y))
+  if (y >= 0 && y < octave_uint64::max () && y == octave::math::round (y))
     {
       return x * octave_uint64 (static_cast<uint64_t> (y));
     }
   else if (y == 0.5)
     {
       return x / octave_uint64 (static_cast<uint64_t> (2));
     }
-  else if (y < 0 || xisnan (y) || xisinf (y))
+  else if (y < 0 || octave::math::isnan (y) || octave::math::isinf (y))
     {
       return octave_uint64 (x.value () * y);
     }
   else
     {
       bool sign;
       uint64_t my;
       int e;
@@ -626,25 +626,25 @@ INT_DOUBLE_BINOP_DECL (*, uint64)
     }
 }
 
 DOUBLE_INT_BINOP_DECL (*, uint64)
 { return y * x; }
 
 INT_DOUBLE_BINOP_DECL (*, int64)
 {
-  if (fabs (y) < octave_int64::max () && y == xround (y))
+  if (fabs (y) < octave_int64::max () && y == octave::math::round (y))
     {
       return x * octave_int64 (static_cast<int64_t> (y));
     }
   else if (fabs (y) == 0.5)
     {
       return x / octave_int64 (static_cast<uint64_t> (4*y));
     }
-  else if (xisnan (y) || xisinf (y))
+  else if (octave::math::isnan (y) || octave::math::isinf (y))
     {
       return octave_int64 (x.value () * y);
     }
   else
     {
       bool sign;
       uint64_t my;
       int e;
@@ -672,27 +672,27 @@ DOUBLE_INT_BINOP_DECL (/, uint64)
 
 DOUBLE_INT_BINOP_DECL (/, int64)
 {
   return octave_int64 (x / static_cast<double> (y));
 }
 
 INT_DOUBLE_BINOP_DECL (/, uint64)
 {
-  if (y >= 0 && y < octave_uint64::max () && y == xround (y))
+  if (y >= 0 && y < octave_uint64::max () && y == octave::math::round (y))
     {
       return x / octave_uint64 (y);
     }
   else
     return x * (1.0/y);
 }
 
 INT_DOUBLE_BINOP_DECL (/, int64)
 {
-  if (fabs (y) < octave_int64::max () && y == xround (y))
+  if (fabs (y) < octave_int64::max () && y == octave::math::round (y))
     {
       return x / octave_int64 (y);
     }
   else
     return x * (1.0/y);
 }
 
 #define INSTANTIATE_INT64_DOUBLE_CMP_OP0(OP,T1,T2) \
@@ -760,48 +760,48 @@ template <typename T>
 octave_int<T>
 pow (const double& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.double_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const double& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), b)));
 }
 
 template <typename T>
 octave_int<T>
 pow (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const float& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 // FIXME: Do we really need a differently named single-precision
 //        function integer power function here instead of an overloaded
 //        one?
 template <typename T>
 octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 #define INSTANTIATE_INTTYPE(T) \
   template class OCTAVE_API octave_int<T>; \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const double&, const octave_int<T>&); \
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -31,19 +31,37 @@ along with Octave; see the file COPYING.
 #include <limits>
 #include <iosfwd>
 
 #include "lo-traits.h"
 #include "lo-math.h"
 #include "lo-mappers.h"
 
 #if defined (OCTAVE_INT_USE_LONG_DOUBLE)
-inline long double xround (long double x) { return roundl (x); }
-inline long double xisnan (long double x)
-{ return xisnan (static_cast<double> (x)); }
+
+namespace octave
+{
+  namespace math
+  {
+    inline long double round (long double x) { return roundl (x); }
+
+    inline long double isnan (long double x) { return isnan (static_cast<double> (x)); }
+  }
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline long double xround (long double x) { return octave::math::round (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+inline bool xisnan (long double x) { return octave::math::isnan (x); }
+
+#endif
+
 #endif
 
 // FIXME: we define this by our own because some compilers, such as
 // MSVC, do not provide std::abs (int64_t) and std::abs (uint64_t).  In
 // the future, it should go away in favor of std::abs.
 template <typename T>
 inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
 
@@ -304,19 +322,19 @@ public:
 
 private:
 
   // Computes a real-valued threshold for a max/min check.
   template <typename S>
   static S
   compute_threshold (S val, T orig_val)
   {
-    val = xround (val); // Fool optimizations (maybe redundant)
+    val = octave::math::round (val); // Fool optimizations (maybe redundant)
     // If val is even, but orig_val is odd, we're one unit off.
-    if (orig_val % 2 && val / 2 == xround (val / 2))
+    if (orig_val % 2 && val / 2 == octave::math::round (val / 2))
       // FIXME: is this always correct?
       val *= (static_cast<S> (1) - (std::numeric_limits<S>::epsilon () / 2));
     return val;
   }
 
 public:
 
   // Convert a real number (check NaN and non-int).
@@ -944,20 +962,40 @@ rem (const octave_int<T>& x, const octav
 
 template <typename T>
 inline octave_int<T>
 mod (const octave_int<T>& x, const octave_int<T>& y)
 { return octave_int_arith<T>::mod (x.value (), y.value ()); }
 
 // No mixed integer binary operations!
 
+namespace octave
+{
+  namespace math
+  {
+    template <typename T>
+    bool
+    isnan (const octave_int<T>&)
+    {
+      return false;
+    }
+  }
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
 template <typename T>
-inline bool
-xisnan (const octave_int<T>&)
-{ return false; }
+OCTAVE_DEPRECATED ("use 'octave::math::isnan' instead")
+bool
+xisnan (const octave_int<T>& x)
+{
+  return octave::math::isnan (x);
+}
+
+#endif
 
 // FIXME: can/should any of these be inline?
 
 template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>&, const octave_int<T>&);
 
 template <typename T>
