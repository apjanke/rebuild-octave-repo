# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1240272969 25200
#      Mon Apr 20 17:16:09 2009 -0700
# Node ID c1fff751b5a886bcaea31fd8b461b8c628ddcd45
# Parent  c309e028185ea7d911e97c88cb46c0bde5010222
Update section 17.1 (Utility Functions) of arith.txi

Split section into "Exponents and Logarithms" and "Utility Functions"
Use Tex in many more of the doc strings for pretty printing in pdf format.

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,13 +1,18 @@
 2009-04-19  Ansgar Burchardt  <ansgar@43-1.org>
 
 	* interpreter/numbers.txi: Fix small mistake in example.
 
 2009-04-17  Rik  <rdrider0-list@yahoo.com>
+	* interpreter/arith.txi: Update section 17.1 (Utility Functions) of arith.txi
+	Split section into "Exponents and Logarithms" and "Utility Functions"
+	Use Tex in many more of the doc strings for pretty printing in pdf format.
+
+2009-04-17  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/basics.txi: Update help text for sections 2.5, 2.6, 2.7
 	of basics.txi 
 
 2009-04-17  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/basics.txi: Update help text for sections 2.4 of basics.txi 
 
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -16,104 +16,66 @@
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Arithmetic
 @chapter Arithmetic
 
 Unless otherwise noted, all of the functions described in this chapter
-will work for real and complex scalar or matrix arguments.  Functions described as @dfn{mapping functions} apply the given operation to each element when given a matrix argument.
+will work for real and complex scalar, vector, or matrix arguments.  Functions
+described as @dfn{mapping functions} apply the given operation individually to 
+each element when given a matrix argument.  For example,
+
+@example
+@group
+sin ([1, 2; 3, 4])
+     @result{}  0.84147   0.90930
+         0.14112  -0.75680
+@end group
+@end example
 
 @menu
-* Utility Functions::           
+* Exponents and Logarithms::
 * Complex Arithmetic::          
 * Trigonometry::                
 * Sums and Products::           
+* Utility Functions::           
 * Special Functions::           
 * Coordinate Transformations::
 * Mathematical Constants::      
 @end menu
 
-@node Utility Functions
-@section Utility Functions
-
-The following functions are available for working with complex numbers.
-Each expects a single argument.  They are called @dfn{mapping functions}
-because when given a matrix argument, they apply the given function to
-each element of the matrix.
-
-@DOCSTRING(ceil)
-
-@DOCSTRING(cplxpair)
-
-@DOCSTRING(del2)
+@node Exponents and Logarithms
+@section Exponents and Logarithms
 
 @DOCSTRING(exp)
 
 @DOCSTRING(expm1)
 
-@DOCSTRING(factor)
-
-@DOCSTRING(factorial)
-
-@DOCSTRING(fix)
-
-@DOCSTRING(floor)
-
-@DOCSTRING(fmod)
-
-@DOCSTRING(gcd)
-
-@DOCSTRING(gradient)
-
-@DOCSTRING(hypot)
-
-@DOCSTRING(lcm)
-
 @DOCSTRING(log)
 
 @DOCSTRING(log1p)
 
 @DOCSTRING(log10)
 
 @DOCSTRING(log2)
 
-@DOCSTRING(max)
-
-@DOCSTRING(min)
-
-@DOCSTRING(cummax)
-
-@DOCSTRING(cummin)
-
-@DOCSTRING(mod)
-
 @DOCSTRING(nextpow2)
 
 @DOCSTRING(nthroot)
 
 @DOCSTRING(pow2)
 
-@DOCSTRING(primes)
-
 @DOCSTRING(reallog)
 
 @DOCSTRING(realpow)
 
 @DOCSTRING(realsqrt)
 
-@DOCSTRING(rem)
-
-@DOCSTRING(round)
-
-@DOCSTRING(roundb)
-
-@DOCSTRING(sign)
-
 @DOCSTRING(sqrt)
 
 @node Complex Arithmetic
 @section Complex Arithmetic
 
 The following functions are available for working with complex
 numbers.  Each expects a single argument.  Given a matrix they work on
 an element by element basis.  In the descriptions of the following
@@ -130,16 +92,18 @@ defined as @code{sqrt (-1)}.
 @end ifinfo
 
 @DOCSTRING(abs)
 
 @DOCSTRING(arg)
 
 @DOCSTRING(conj)
 
+@DOCSTRING(cplxpair)
+
 @DOCSTRING(imag)
 
 @DOCSTRING(real)
 
 @node Trigonometry
 @section Trigonometry
 
 Octave provides the following trigonometric functions.  Angles are
@@ -222,16 +186,61 @@ Octave also provides the following funct
 @DOCSTRING(cumsum)
 
 @DOCSTRING(cumprod)
 
 @DOCSTRING(sumsq)
 
 @DOCSTRING(accumarray)
 
+@node Utility Functions
+@section Utility Functions
+
+@DOCSTRING(ceil)
+
+@DOCSTRING(del2)
+
+@DOCSTRING(factor)
+
+@DOCSTRING(factorial)
+
+@DOCSTRING(fix)
+
+@DOCSTRING(floor)
+
+@DOCSTRING(fmod)
+
+@DOCSTRING(gcd)
+
+@DOCSTRING(gradient)
+
+@DOCSTRING(hypot)
+
+@DOCSTRING(lcm)
+
+@DOCSTRING(max)
+
+@DOCSTRING(min)
+
+@DOCSTRING(cummax)
+
+@DOCSTRING(cummin)
+
+@DOCSTRING(mod)
+
+@DOCSTRING(primes)
+
+@DOCSTRING(rem)
+
+@DOCSTRING(round)
+
+@DOCSTRING(roundb)
+
+@DOCSTRING(sign)
+
 @node Special Functions
 @section Special Functions
 
 @DOCSTRING(besselj)
 
 @DOCSTRING(airy)
 
 @DOCSTRING(beta)
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -545,20 +545,21 @@ Matrix Manipulation
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
 * Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 
 Arithmetic
 
-* Utility Functions::           
+* Exponents and Logarithms::
 * Complex Arithmetic::          
 * Trigonometry::                
 * Sums and Products::           
+* Utility Functions::           
 * Special Functions::           
 * Coordinate Transformations::
 * Mathematical Constants::      
 
 Linear Algebra
 
 * Techniques used for Linear Algebra::
 * Basic Matrix Functions::      
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -15,31 +15,31 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} lcm (@var{x}, @dots{})
 ## Compute the least common multiple of the elements of @var{x}, or
-## the list of all the arguments.  For example,
+## of the list of all arguments.  For example,
 ##
 ## @example
 ## lcm (a1, @dots{}, ak)
 ## @end example
 ##
 ## @noindent
 ## is the same as
 ##
 ## @example
 ## lcm ([a1, @dots{}, ak]).
 ## @end example
 ##
 ## All elements must be the same size or scalar.
-## @seealso{gcd, min, max, ceil, floor}
+## @seealso{factor, gcd}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (varargin)
 
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -12,31 +12,33 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} cplxpair (@var{z}, @var{tol}, @var{dim})
+## @deftypefn  {Function File} {} cplxpair (@var{z})
+## @deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol})
+## @deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol}, @var{dim})
 ## Sort the numbers @var{z} into complex conjugate pairs ordered by 
-## increasing real part.  With identical real parts, order by increasing
-## imaginary magnitude.  Place the negative imaginary complex number
-## first within each pair.  Place all the real numbers after all the 
-## complex pairs (those with @code{abs (imag (@var{z}) / @var{z}) < 
-## @var{tol})}, where the default value of @var{tol} is @code{100 * 
-## @var{eps}}.
+## increasing real part.  Place the negative imaginary complex number
+## first within each pair.  Place all the real numbers (those with
+## @code{abs (imag (@var{z}) / @var{z}) < @var{tol})}) after the
+## complex pairs.
+##
+## If @var{tol} is unspecified the default value is 100*@var{eps}.
 ##
 ## By default the complex pairs are sorted along the first non-singleton
 ## dimension of @var{z}.  If @var{dim} is specified, then the complex
 ## pairs are sorted along this dimension.
 ##
 ## Signal an error if some complex numbers could not be paired.  Requires
-## all complex numbers to be exact conjugates within tol, or signals an 
+## all complex numbers to be exact conjugates within @var{tol}, or signals an 
 ## error.  Note that there are no guarantees on the order of the returned
 ## pairs with identical real parts but differing imaginary parts.
 ##
 ## @c Using 'smallexample' to make text fit in page when using 'smallbook'
 ## @smallexample
 ## cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
 ## @end smallexample
 ## @end deftypefn
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{d} =} del2 (@var{m})
+## @deftypefn  {Function File} {@var{d} =} del2 (@var{m})
 ## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{h})
 ## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{dx}, @var{dy}, @dots{})
 ##
-## Calculates the discrete Laplace operator.  If @var{m} is a matrix this is
+## Calculate the discrete Laplace operator.  If @var{m} is a matrix this is
 ## defined as
 ##
 ## @iftex
 ## @tex
 ## $$d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
 ## @end tex
 ## @end iftex
 ## @ifnottex
@@ -39,25 +39,26 @@
 ## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## The above to continued to N-dimensional arrays calculating the second
 ## derivative over the higher dimensions.
 ##
 ## The spacing between evaluation points may be defined by @var{h}, which is a
-## scalar defining the spacing in all dimensions.  Or alternatively, the spacing
+## scalar defining the equidistant spacing in all dimensions.  Alternatively, 
+## the spacing
 ## in each dimension may be defined separately by @var{dx}, @var{dy}, etc. 
 ## Scalar spacing values give equidistant spacing, whereas vector spacing 
 ## values can be used to specify variable spacing.  The length of the vectors
 ## must match the respective dimension of @var{m}.  The default spacing value
 ## is 1.
 ##
-## You need at least 3 data points for each dimension.  Boundary points are
-## calculated as the linear extrapolation of the interior points.
+## At least 3 data points are needed for each dimension.  Boundary points are
+## calculated from the linear extrapolation of interior points.
 ##
 ## @seealso{gradient, diff}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function D = del2 (M, varargin)
   
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {@var{dx} =} gradient (@var{m})
 ## @deftypefnx {Function File} {[@var{dx}, @var{dy}, @var{dz}, @dots{}] =} gradient (@var{m})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{s})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{x}, @var{y}, @var{z}, @dots{})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{s})
 ## @deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{x}, @var{y}, @dots{})
 ##
-## Calculate the gradient of sampled data, or of a function.  If @var{m}
+## Calculate the gradient of sampled data or of a function.  If @var{m}
 ## is a vector, calculate the one dimensional gradient of @var{m}.  If
 ## @var{m} is a matrix the gradient is calculated for each dimension.
 ##
 ## @code{[@var{dx}, @var{dy}] = gradient (@var{m})} calculates the one
 ## dimensional gradient for @var{x} and @var{y} direction if @var{m} is a
 ## matrix.  Additional return arguments can be use for multi-dimensional
 ## matrices.
 ##
@@ -51,16 +51,17 @@
 ## 
 ## If the first argument @var{f} is a function handle, the gradient of the
 ## function at the points in @var{x0} is approximated using central
 ## difference.  For example, @code{gradient (@@cos, 0)} approximates the
 ## gradient of the cosine function in the point @math{x0 = 0}.  As with
 ## sampled data, the spacing values between the points from which the
 ## gradient is estimated can be set via the @var{s} or @var{dx},
 ## @var{dy}, @dots{} arguments.  By default a spacing of 1 is used.
+## @seealso{diff, del2}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
 function varargout = gradient (m, varargin)
   
   if (nargin < 1)
diff --git a/scripts/general/mod.m b/scripts/general/mod.m
--- a/scripts/general/mod.m
+++ b/scripts/general/mod.m
@@ -13,30 +13,30 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} mod (@var{x}, @var{y})
-## Compute modulo function.  Conceptually this is given by
+## Compute the modulo of @var{x} and @var{y}.  Conceptually this is given by
 ##
 ## @example
 ## x - y .* floor (x ./ y)
 ## @end example
 ##
-## and is written in a manner that the correct modulus is returned for
-##integer types.  This function handles negative values correctly.  That
-##is @code{mod (-1, 3)} is 2, not -1 as @code{rem (-1, 3)} returns.
-## Also, @code{mod (@var{x}, 0)} returns @var{x}.
+## and is written such that the correct modulus is returned for
+## integer types.  This function handles negative values correctly.  That
+## is, @code{mod (-1, 3)} is 2, not -1, as @code{rem (-1, 3)} returns.
+## @code{mod (@var{x}, 0)} returns @var{x}.
 ##
-## An error message is printed if the dimensions of the arguments do not
-## agree, or if either of the arguments is complex.
-## @seealso{rem, round}
+## An error results if the dimensions of the arguments do not agree, or if
+## either of the arguments is complex.
+## @seealso{rem, fmod}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Modified by: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Adapted by: jwe
 
 function r = mod (x, y)
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -14,28 +14,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nextpow2 (@var{x})
-## If @var{x} is a scalar, returns the first integer @var{n} such that
+## If @var{x} is a scalar, return the first integer @var{n} such that
 ## @iftex
 ## @tex
 ##  $2^n \ge |x|$.
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##  2^n >= abs (x).
 ## @end ifnottex
 ##
 ## If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
-## @seealso{pow2}
+## @seealso{pow2, log2}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
 
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -14,26 +14,26 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
-## Return the remainder of @code{@var{x} / @var{y}}, computed using the
-## expression
+## Return the remainder of the division @code{@var{x} / @var{y}}, computed 
+## using the expression
 ##
 ## @example
 ## x - y .* fix (x ./ y)
 ## @end example
 ##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
-## @seealso{mod, round}
+## @seealso{mod, fmod}
 ## @end deftypefn
 
 ## Author: jwe
 
 function r = rem (x, y)
 
   if (nargin != 2)
     print_usage ();
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -12,26 +12,26 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{p} =} factor (@var{q})
+## @deftypefn  {Function File} {@var{p} =} factor (@var{q})
 ## @deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})
 ##
 ## Return prime factorization of @var{q}.  That is @code{prod (@var{p})
 ## == @var{q}}.  If @code{@var{q} == 1}, returns 1. 
 ##
 ## With two output arguments, returns the unique primes @var{p} and
 ## their multiplicities.  That is @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
-## 
+## @seealso{gcd, lcm}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
 ## 2002-01-28 Paul Kienzle
 ## * remove recursion; only check existing primes for multiplicity > 1
 ## * return multiplicity as suggested by Dirk Laurie
 ## * add error handling
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} factorial (@var{n})
-## Return the factorial of @var{n}.  If @var{n} is scalar, this is
-## equivalent to @code{prod (1:@var{n})}.  If @var{n} is an array,
-## the factorial of the elements of the array are returned.
+## Return the factorial of @var{n}.  If @var{n} is a scalar, this is
+## equivalent to @code{prod (1:@var{n})}.  For vector or matrix arguments,
+## return the factorial of each element in the array.
 ## @end deftypefn
 
 function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != round (n(:))))
     error ("factorial: n must all be nonnegative integers");
   endif
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -24,26 +24,28 @@
 ## @iftex
 ## @tex
 ##  $2^x$
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##  2 .^ x
 ## @end ifnottex
-## for each element of @var{x}.  With two arguments, returns
+## for each element of @var{x}.
+##
+## With two arguments, returns
 ## @iftex
 ## @tex
 ##  $f \cdot 2^e$.
 ## @end tex
 ## @end iftex
 ## @ifnottex
 ##  f .* (2 .^ e).
 ## @end ifnottex
-## @seealso{nextpow2}
+## @seealso{log2, nextpow2}
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = pow2 (f, e)
 
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -16,22 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} primes (@var{n})
 ##
 ## Return all primes up to @var{n}.  
 ##
+## The algorithm used is the Sieve of Erastothenes.
+##
 ## Note that if you need a specific number of primes, you can use the
 ## fact the distance from one prime to the next is on average
 ## proportional to the logarithm of the prime.  Integrating, you find
 ## that there are about @math{k} primes less than @math{k \log (5 k)}.
-##
-## The algorithm used is called the Sieve of Erastothenes.
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Author: Francesco Potortì
 ## Author: Dirk Laurie
 
 function x = primes (p)
 
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} reallog (@var{x})
-## Return the real natural logarithm of @var{x}.  If any element results in the
-## return value being complex @code{reallog} produces an error.
-## @seealso{log, realsqrt, realpow}
+## Return the real-valued natural logarithm of each element of @var{x}.  Report 
+## an error if any element results in a complex return value.
+## @seealso{log, realpow, realsqrt}
 ## @end deftypefn
 
 function y = reallog (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("reallog: produced complex result");
   else    
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realpow (@var{x}, @var{y})
-## Return the element by element power operator.  This is equivalent to
-## @code{@var{x} .^ @var{y}}, except that if the return value
-## is complex @code{realpow} produces an error.
+## Compute the real-valued, element-by-element power operator.  This is 
+## equivalent to @w{@code{@var{x} .^ @var{y}}}, except that @code{realpow}
+## reports an error if any return value is complex.
 ## @seealso{reallog, realsqrt}
 ## @end deftypefn
 
 function z = realpow (x, y)
   if (nargin != 2)
     print_usage ();
   else
     z = x .^ y;
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realsqrt (@var{x})
-## Return the real sqrt of @var{x}.  If any element results in the
-## return value being complex @code{realsqrt} produces an error.
-## @seealso{sqrt, reallog, realpow}
+## Return the real-valued square root of each element of @var{x}.  Report an
+## error if any element results in a complex return value.
+## @seealso{sqrt, realpow, reallog}
 ## @end deftypefn
 
 function y = realsqrt (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("realsqrt: produced complex result");
   else    
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -46,60 +46,60 @@ is_integer_value (double x)
 static inline bool
 is_integer_value (float x)
 {
   return x == std::floor (x);
 }
 
 DEFUN_DLD (gcd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @dots{})\n\
+@deftypefn  {Loadable Function} {@var{g} =} gcd (@var{a})\n\
+@deftypefnx {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
-If a single argument is given then compute the greatest common divisor of\n\
-the elements of this argument.  Otherwise if more than one argument is\n\
-given all arguments must be the same size or scalar.  In this case the\n\
-greatest common divisor is calculated for element individually.  All\n\
-elements must be integers.  For example,\n\
+Compute the greatest common divisor of the elements of @var{a}.  If more\n\
+than one argument is given all arguments must be the same size or scalar.\n\
+  In this case the greatest common divisor is calculated for each element\n\
+individually.  All elements must be integers.  For example,\n\
 \n\
 @example\n\
 @group\n\
 gcd ([15, 20])\n\
     @result{}  5\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 and\n\
 \n\
 @example\n\
 @group\n\
-gcd ([15, 9], [20 18])\n\
+gcd ([15, 9], [20, 18])\n\
     @result{}  5  9\n\
 @end group\n\
 @end example\n\
 \n\
-Optional return arguments @var{v1}, etc, contain integer vectors such\n\
+Optional return arguments @var{v1}, etc., contain integer vectors such\n\
 that,\n\
 \n\
 @ifnottex\n\
 @example\n\
 @var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @dots{}\n\
 @end example\n\
 @end ifnottex\n\
 @iftex\n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @end iftex\n\
 \n\
 For backward compatibility with previous versions of this function, when\n\
 all arguments are scalar, a single return argument @var{v1} containing\n\
 all of the values of @var{v1}, @dots{} is acceptable.\n\
-@seealso{lcm, min, max, ceil, floor}\n\
+@seealso{lcm, factor}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -679,19 +679,20 @@ along with Octave; see the file COPYING.
     MINMAX_SINGLE_BODY (FCN) \
   else \
     MINMAX_DOUBLE_BODY (FCN) \
  \
  return retval;
 
 DEFUN_DLD (min, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn  {Loadable Function} {} min (@var{x})\n\
+@deftypefnx {Loadable Function} {} min (@var{x}, @var{y})\n\
+@deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
-@cindex Utility Functions\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined.  For two matrices\n\
 (or a matrix and scalar), return the pair-wise minimum.\n\
 Thus,\n\
 \n\
 @example\n\
 min (min (@var{x}))\n\
@@ -719,16 +720,17 @@ minimum value(s).  Thus,\n\
 \n\
 @example\n\
 @group\n\
 [x, ix] = min ([1, 3, 0, 2, 5])\n\
     @result{}  x = 0\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
+@seealso{max, cummin, cummax}\n\
 @end deftypefn")
 {
   MINMAX_BODY (min);
 }
 
 /*
 
 %% test/octave.test/arith/min-1.m
@@ -753,31 +755,32 @@ minimum value(s).  Thus,\n\
 %! assert (ndims(y), 2);
 %! assert (i, [2, 2; 2, 2]);
 %! assert (ndims(i), 2);
 
 */
 
 DEFUN_DLD (max, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn  {Loadable Function} {} max (@var{x})\n\
+@deftypefnx {Loadable Function} {} max (@var{x}, @var{y})\n\
+@deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
-@cindex Utility Functions\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined.  For two matrices\n\
 (or a matrix and scalar), return the pair-wise maximum.\n\
 Thus,\n\
 \n\
 @example\n\
 max (max (@var{x}))\n\
 @end example\n\
 \n\
 @noindent\n\
-returns the largest element of @var{x}, and\n\
+returns the largest element of the matrix @var{x}, and\n\
 \n\
 @example\n\
 @group\n\
 max (2:5, pi)\n\
     @result{}  3.1416  3.1416  4.0000  5.0000\n\
 @end group\n\
 @end example\n\
 @noindent\n\
@@ -793,16 +796,17 @@ maximum value(s).  Thus,\n\
 \n\
 @example\n\
 @group\n\
 [x, ix] = max ([1, 3, 5, 2, 5])\n\
     @result{}  x = 5\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
+@seealso{min, cummax, cummin}\n\
 @end deftypefn")
 {
   MINMAX_BODY (max);
 }
 
 /* 
 
 %% test/octave.test/arith/max-1.m
@@ -909,75 +913,92 @@ maximum value(s).  Thus,\n\
     MINMAX_SINGLE_SBODY (FCN) \
   else \
     MINMAX_DOUBLE_SBODY (FCN) \
  \
  return retval;
 
 DEFUN_DLD (cummin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
+@deftypefn  {Loadable Function} {} cummin (@var{x})\n\
+@deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
-@cindex Utility Functions\n\
-Return the cumulative minimum values.  That means, the call\n\
+Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
+is unspecified it defaults to column-wise operation.  For example,\n\
+\n\
+@example\n\
+@group\n\
+cummin ([5 4 6 2 3 1])\n\
+    @result{}  5  4  4  2  2  1\n\
+@end group\n\
+@end example\n\
+\n\
+\n\
+The call\n\
 @example\n\
   [w, iw] = cummin (x, dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 @example\n\
 @group\n\
-  w = iw = zeros (size (x));\n\
-  idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
-  for i = 1:size (x, dim)\n\
-    idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
-    [w(idxw@{:@}), iw(idxw@{:@})] =\\n\
- min(x(idxx@{:@}), [], dim);\n\
-  endfor\n\
+w = iw = zeros (size (x));\n\
+idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
+for i = 1:size (x, dim)\n\
+  idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
+  [w(idxw@{:@}), iw(idxw@{:@})] = min(x(idxx@{:@}), [], dim);\n\
+endfor\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
-The behavior if @var{dim} or @var{iw} is unspecified is analogous\n\
-to @code{min}.\n\
+@seealso{cummax, min, max}\n\
 @end deftypefn")
 {
   CUMMINMAX_BODY (cummin);
 }
 
 DEFUN_DLD (cummax, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
+@deftypefn  {Loadable Function} {} cummax (@var{x})\n\
+@deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
-@cindex Utility Functions\n\
-Return the cumulative maximum values.  That means, the call\n\
+Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
+is unspecified it defaults to column-wise operation.  For example,\n\
+\n\
 @example\n\
-  [w, iw] = cummax (x, dim)\n\
+@group\n\
+cummax ([1 3 2 6 4 5])\n\
+    @result{}  1  3  3  6  6  6\n\
+@end group\n\
+@end example\n\
+\n\
+The call\n\
+@example\n\
+[w, iw] = cummax (x, dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 @example\n\
 @group\n\
-  w = iw = zeros (size (x));\n\
-  idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
-  for i = 1:size (x, dim)\n\
-    idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
-    [w(idxw@{:@}), iw(idxw@{:@})] =\\n\
- max(x(idxx@{:@}), [], dim);\n\
-  endfor\n\
+w = iw = zeros (size (x));\n\
+idxw = idxx = repmat (@{':'@}, 1, ndims (x));\n\
+for i = 1:size (x, dim)\n\
+  idxw@{dim@} = i; idxx@{dim@} = 1:i;\n\
+  [w(idxw@{:@}), iw(idxw@{:@})] = max(x(idxx@{:@}), [], dim);\n\
+endfor\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
-The behavior if @var{dim} or @var{iw} is unspecified is analogous\n\
-to @code{max}.\n\
+@seealso{cummin, max, min}\n\
 @end deftypefn")
 {
   CUMMINMAX_BODY (cummax);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -730,19 +730,19 @@ and @var{x}.  The result is in the range
 %!error <Invalid call to atan2.*> atan2 (1, 2, 3);
 
 */
 
 
 
 DEFUN (hypot, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} hypot (@var{x}, @var{y})\n\
-Compute square-root of the squares of @var{x} and @var{y}\n\
-element-by-element.  This equivalent to @code{sqrt (@var{x}.^ 2 + @var{y}\n\
+@deftypefn {Built-in Function} {} hypot (@var{x}, @var{y})\n\
+Compute the element-by-element square root of the squares of @var{x} and\n\
+@var{y}.  This is equivalent to @code{sqrt (@var{x}.^ 2 + @var{y}\n\
 .^ 2)}, but calculated in a manner that avoids overflows for large\n\
 values of @var{x} or @var{y}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -988,21 +988,30 @@ map_2_xlog2 (const Array<T>& x, Array<T>
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log2 (@var{x})\n\
 @deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
-Compute the base-2 logarithm for each element of @var{x}.\n\
-If called with two output arguments, split @var{x} to\n\
-binary mantissa and exponent so that @code{1/2 <= abs(f) < 1} and\n\
-@var{e} is an integer.  If @code{x = 0}, @code{f = e = 0}.\n\
-@seealso{log, log10, log2, exp}\n\
+Compute the base-2 logarithm of each element of @var{x}.\n\
+\n\
+If called with two output arguments, split @var{x} into\n\
+binary mantissa and exponent so that\n\
+@iftex\n\
+@tex\n\
+${1 \\over 2} \\le \\left| f \\right| < 1$\n\
+@end tex\n\
+@end iftex\n\
+@ifnottex\n\
+@code{1/2 <= abs(f) < 1}\n\ 
+@end ifnottex\n\
+and @var{e} is an integer.  If @code{x = 0}, @code{f = e = 0}.\n\
+@seealso{pow2, log, log10, exp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (nargout < 2)
         retval(0) = args(0).log2 ();
@@ -1076,17 +1085,18 @@ binary mantissa and exponent so that @co
 %! assert (e, [0,1; 2,3; 0,0]);
 */
 
 DEFUN (fmod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Compute the floating point remainder of dividing @var{x} by @var{y}\n\
 using the C library function @code{fmod}.  The result has the same\n\
-sign as @var{x}.  If @var{y} is zero, the result is implementation-defined.\n\
+sign as @var{x}.  If @var{y} is zero, the result is implementation-dependent.\n\
+@seealso{mod, rem}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -340,18 +340,26 @@ Compute the inverse hyperbolic tangent o
 %!error atanh ();
 %!error atanh (1, 2);
 
 */
 
 DEFUN (ceil, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
-Return the smallest integer not less than @var{x}.  If @var{x} is\n\
+Return the smallest integer not less than @var{x}.  This is equivalent to\n\
+rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
+@example\n\
+@group\n\
+ceil ([-2.7, 2.7])\n\
+   @result{}  -2   3\n\
+@end group\n\
+@end example\n\
+@seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).ceil ();
   else
     print_usage ();
 
@@ -581,18 +589,28 @@ Computes the complementary error functio
 %! a = -1i*sqrt(-1/(6.4187*6.4187));
 %! assert (erfc(a), erfc(real(a)));
 
 */
 
 DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
-Compute the exponential of @var{x}.  To compute the matrix exponential,\n\
-see @ref{Linear Algebra}.\n\
+Compute\n\
+@iftex\n\
+@tex\n\
+$e^{x}$\n\
+@end tex\n\
+@end iftex\n\
+@ifnottex\n\
+@code{e^x}\n\
+@end ifnottex\n\
+for each element of @var{x}.  To compute the matrix\n\
+exponential, see @ref{Linear Algebra}.\n\
+@seealso{log}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).exp ();
   else
     print_usage ();
 
@@ -612,17 +630,27 @@ see @ref{Linear Algebra}.\n\
 %!assert(exp (Inf) == Inf && exp (-Inf) == 0 && isnan (exp (NaN)));
 %!assert(exp (Inf ('single')) == Inf('single') && exp (-Inf('single')) == 0 && isnan (exp (NaN('single'))));
 
 */
 
 DEFUN (expm1, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} expm1 (@var{x})\n\
-Compute exp (@var{x}) - 1 accurately in neighborhood of zero.\n\
+Compute \n\
+@iftex\n\
+@tex\n\
+$ e^{x} - 1 $\n\
+@end tex\n\
+@end iftex\n\
+@ifnottex\n\
+@code{exp (@var{x}) - 1}\n\
+@end ifnottex\n\
+accurately in the neighborhood of zero.\n\
+@seealso{exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).expm1 ();
   else
     print_usage ();
 
@@ -662,18 +690,26 @@ finite ([13, Inf, NA, NaN])\n\
 %!assert(!(finite (single(NaN))));
 %!assert(finite (single(rand(1,10))));
 
  */
 
 DEFUN (fix, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
-Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
+Truncate fractional portion of @var{x} and return integer portion.  This\n\
+is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
+@example\n\
+@group\n\
+fix ([-2.7, 2.7])\n\
+   @result{} -2   2\n\
+@end group\n\
+@end example\n\
+@seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).fix ();
   else
     print_usage ();
 
@@ -690,18 +726,26 @@ Truncate @var{x} toward zero.  If @var{x
 %!error fix ();
 %!error fix (1, 2);
 
 */
 
 DEFUN (floor, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
-Return the largest integer not greater than @var{x}.  If @var{x} is\n\
+Return the largest integer not greater than @var{x}.  This is equivalent to\n\
+rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
+@example\n\
+@group\n\
+floor ([-2.7, 2.7])\n\
+     @result{} -3   2\n\
+@end group\n\
+@end example\n\
+@seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).floor ();
   else
     print_usage ();
 
@@ -1154,19 +1198,28 @@ Return the natural logarithm of the gamm
 %!error lgamma();
 %!error lgamma(1,2);
 
 */
 
 DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
-Compute the natural logarithm for each element of @var{x}.  To compute the\n\
+Compute the natural logarithm,\n\
+@iftex\n\
+@tex\n\
+$\\ln{(x)},$\n\
+@end tex\n\
+@end iftex\n\
+@ifnottex\n\
+@code{ln (@var{x})},\n\
+@end ifnottex\n\
+for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
-@seealso{log2, log10, logspace, exp}\n\
+@seealso{exp, log1p, log2, log10, logspace}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).log ();
   else
     print_usage ();
 
@@ -1184,17 +1237,17 @@ matrix logarithm, see @ref{Linear Algebr
 %!error log ();
 %!error log (1, 2);
 
  */
 
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
-Compute the base-10 logarithm for each element of @var{x}.\n\
+Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).log10 ();
   else
     print_usage ();
@@ -1210,17 +1263,27 @@ Compute the base-10 logarithm for each e
 %!error log10 ();
 %!error log10 (1, 2);
 
 */
 
 DEFUN (log1p, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
-Compute log (1 + @var{x}) accurately in neighborhood of zero.\n\
+Compute\n\
+@iftex\n\
+@tex\n\
+$\\ln{(1 + x)}$\n\
+@end tex\n\
+@end iftex\n\
+@ifnottex\n\
+@code{log (1 + @var{x})}\n\
+@end ifnottex\n\
+accurately in the neighborhood of zero.\n\
+@seealso{log, exp, expm1}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).log1p ();
   else
     print_usage ();
 
@@ -1260,17 +1323,23 @@ Return the real part of @var{z}.\n\
 
 */
 
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
-@seealso{rem}\n\
+@example\n\
+@group\n\
+round ([-2.7, 2.7])\n\
+     @result{} -3   3\n\
+@end group\n\
+@end example\n\
+@seealso{ceil, floor, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).round ();
   else
     print_usage ();
 
@@ -1301,17 +1370,17 @@ Return the integer nearest to @var{x}.  
 */
 
 DEFUN (roundb, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} roundb (@var{x})\n\
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
-@seealso{rem}\n\
+@seealso{round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).roundb ();
   else
     print_usage ();
 
@@ -1435,19 +1504,20 @@ Compute the hyperbolic sine of each elem
 %!error sinh ();
 %!error sinh (1, 2);
 
  */
 
 DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
-Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
-result is returned.  To compute the matrix square root, see\n\
+Compute the square root of each element of @var{x}.  If @var{x} is negative,\n\
+a complex result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
+@seealso{realsqrt}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).sqrt ();
   else
     print_usage ();
 
