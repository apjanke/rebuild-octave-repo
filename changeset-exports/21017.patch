# HG changeset patch
# User Rik <rik@octave.org>
# Date 1451507613 28800
#      Wed Dec 30 12:33:33 2015 -0800
# Node ID 93748bcaec17bc7540d1c0f96c532ae71643545c
# Parent  c22219b8a6a6775e7a04eccc0cb8494dc0bfac5c
maint: Replace emtpy 'std::string ()' calls with "".

* Backend.cc, comment-list.h, debug.cc, defaults.in.h, dynamic-ld.h, error.cc,
graphics.cc, graphics.in.h, help.cc, hook-fcn.h, load-path.cc, load-path.h,
ls-ascii-helper.cc, ls-mat-ascii.cc, ls-mat5.cc, ls-mat5.h, ls-oct-text.cc,
oct-iostrm.h, oct-lvalue.h, oct-stream.cc, oct-stream.h, oct-strstrm.h,
regexp.cc, schur.cc, sqrtm.cc, strfns.cc, symtab.cc, symtab.h, sysdep.cc,
toplev.cc, urlwrite.cc, variables.cc, variables.h, ov-builtin.h, ov-cell.cc,
ov-class.cc, ov-classdef.cc, ov-classdef.h, ov-dld-fcn.h, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-fcn-inline.h, ov-fcn.h, ov-lazy-idx.cc, ov-mex-fcn.h,
ov-struct.cc, ov-typeinfo.cc, ov-typeinfo.h, ov-usr-fcn.cc, ov-usr-fcn.h, ov.h,
ovl.h, octave.cc, lex.h, parse.h, pt-classdef.h, pt-exp.cc, pt-pr-code.h,
token.h, version.cc, version.in.h, oct-rand.h, dir-ops.h, file-ops.cc,
file-ops.h, file-stat.h, oct-env.cc, oct-group.cc, oct-passwd.cc,
oct-syscalls.cc, cmd-edit.cc, cmd-edit.h, cmd-hist.cc, cmd-hist.h, kpse.cc,
lo-array-gripes.h, pathsearch.cc, pathsearch.h, str-vec.h, url-transfer.h:
Replace emtpy 'std::string ()' calls with "".

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -60,17 +60,17 @@ toolkitObjectProperty (const graphics_ob
            || go.isa ("uitoolbar")
            || go.isa ("uipushtool")
            || go.isa ("uitoggletool"))
     return std::string ("__object__");
   else
     qCritical ("QtHandles::Backend: no __object__ property known for object "
                "of type %s", go.type ().c_str ());
 
-  return std::string ();
+  return "";
 }
 
 Backend::Backend (void)
   : QObject (), base_graphics_toolkit ("qt")
 {
   ObjectFactory* factory = ObjectFactory::instance ();
 
   connect (this, SIGNAL (createObject (double)),
diff --git a/libinterp/corefcn/comment-list.h b/libinterp/corefcn/comment-list.h
--- a/libinterp/corefcn/comment-list.h
+++ b/libinterp/corefcn/comment-list.h
@@ -43,17 +43,17 @@ public:
     unknown,
     block,
     full_line,
     end_of_line,
     doc_string,
     copyright
   };
 
-  octave_comment_elt (const std::string& s = std::string (),
+  octave_comment_elt (const std::string& s = "",
                       comment_type t = unknown)
     : txt (s), typ (t) { }
 
   octave_comment_elt (const octave_comment_elt& oc)
     : txt (oc.txt), typ (oc.typ) { }
 
   octave_comment_elt& operator = (const octave_comment_elt& oc)
   {
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -162,17 +162,17 @@ get_file_line (const std::string& fname,
   return retval;
 }
 
 // Return a pointer to the user-defined function FNAME.  If FNAME is
 // empty, search backward for the first user-defined function in the
 // current call stack.
 
 static octave_user_code *
-get_user_code (const std::string& fname = std::string ())
+get_user_code (const std::string& fname = "")
 {
   octave_user_code *dbg_fcn = 0;
 
   if (fname.empty ())
     dbg_fcn = octave_call_stack::caller_user_code ();
   else
     {
       std::string name = fname;
@@ -192,17 +192,17 @@ get_user_code (const std::string& fname 
 }
 
 static void
 parse_dbfunction_params (const char *who, const octave_value_list& args,
                          std::string& symbol_name, bp_table::intmap& lines)
 {
   int idx = 0;
   int list_idx = 0;
-  symbol_name = std::string ();
+  symbol_name = "";
   lines = bp_table::intmap ();
 
   if (args.length () == 0)
     return;
 
   if (args(0).is_string ())
     {
       // string could be function name or line number
diff --git a/libinterp/corefcn/defaults.in.h b/libinterp/corefcn/defaults.in.h
--- a/libinterp/corefcn/defaults.in.h
+++ b/libinterp/corefcn/defaults.in.h
@@ -226,14 +226,14 @@ extern OCTINTERP_API std::string Vbuilt_
 // Name of the FFTW wisdom program.
 extern OCTINTERP_API std::string Vfftw_wisdom_program;
 
 extern OCTINTERP_API std::string subst_octave_home (const std::string&);
 
 extern OCTINTERP_API void install_defaults (void);
 
 extern OCTINTERP_API void
-set_exec_path (const std::string& path = std::string ());
+set_exec_path (const std::string& path = "");
 
 extern OCTINTERP_API void
-set_image_path (const std::string& path = std::string ());
+set_image_path (const std::string& path = "");
 
 #endif
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -37,22 +37,22 @@ protected:
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
   static octave_function *
   load_oct (const std::string& fcn_name,
-            const std::string& file_name = std::string (),
+            const std::string& file_name = "",
             bool relative = false);
 
   static octave_function *
   load_mex (const std::string& fcn_name,
-            const std::string& file_name = std::string (),
+            const std::string& file_name = "",
             bool relative = false);
 
   static bool remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   static bool remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
@@ -65,22 +65,22 @@ private:
   static octave_dynamic_loader *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
-               const std::string& file_name = std::string (),
+               const std::string& file_name = "",
                bool relative = false);
 
   octave_function *
   do_load_mex (const std::string& fcn_name,
-               const std::string& file_name = std::string (),
+               const std::string& file_name = "",
                bool relative = false);
 
   bool do_remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   bool do_remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1035,17 +1035,17 @@ error.  Typically @var{err} is returned 
 
 static bool
 maybe_extract_message_id (const std::string& caller,
                           const octave_value_list& args,
                           octave_value_list& nargs,
                           std::string& id)
 {
   nargs = args;
-  id = std::string ();
+  id = "";
 
   int nargin = args.length ();
 
   bool have_fmt = nargin > 1;
 
   if (nargin > 0)
     {
       std::string arg1 = args(0).string_value ();
@@ -1854,18 +1854,18 @@ fields are set to their default values.\
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           if (args(0).string_value () != "reset")
             error ("lasterror: unrecognized string argument");
 
-          Vlast_error_message = std::string ();
-          Vlast_error_id = std::string ();
+          Vlast_error_message = "";
+          Vlast_error_id = "";
 
           Vlast_error_stack = initialize_last_error_stack ();
         }
       else if (args(0).is_map ())
         {
           octave_scalar_map new_err = args(0).scalar_map_value ();
           octave_scalar_map new_err_stack;
           std::string new_error_message;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6921,17 +6921,17 @@ axes::properties::calc_ticklabels (const
       for (int i = 0; i < values.numel (); i++)
         {
           if (values(i) < 0.0)
             exponent = gnulib::floor (std::log10 (-values(i)));
           else
             exponent = gnulib::floor (std::log10 (values(i)));
           significand = values(i) * std::pow (10., -exponent);
 
-          os.str (std::string ());
+          os.str ("");
           if ((std::abs (significand) - 1) >
               std::numeric_limits<double>::epsilon())
             os << significand << ".";
           else if (significand < 0)
             os << "-";
 
           os << "10^{";
 
@@ -6945,17 +6945,17 @@ axes::properties::calc_ticklabels (const
           os << exponent << "}";
           c(i) = os.str ();
         }
     }
   else
     {
       for (int i = 0; i < values.numel (); i++)
         {
-          os.str (std::string ());
+          os.str ("");
           os << values(i);
           c(i) = os.str ();
         }
     }
 
   labels = c;
 }
 
@@ -8089,17 +8089,17 @@ patch::properties::update_fvc (void)
   if (updating_patch_data)
     return;
 
   Matrix xd = get_xdata ().matrix_value ();
   Matrix yd = get_ydata ().matrix_value ();
   Matrix zd = get_zdata ().matrix_value ();
   NDArray cd = get_cdata ().array_value ();
 
-  bad_data_msg = std::string ();
+  bad_data_msg = "";
   if (xd.dims () != yd.dims ()
       || (xd.dims () != zd.dims () && ! zd.is_empty ()))
     {
       bad_data_msg = "x/y/zdata must have the same dimensions";
       return;
     }
 
   // Faces and Vertices
@@ -8176,17 +8176,17 @@ patch::properties::update_data (void)
   Matrix idx = get_faces ().matrix_value ().transpose ();
   Matrix vert = get_vertices ().matrix_value ();
   NDArray fvc = get_facevertexcdata ().array_value ();
 
   octave_idx_type nfaces = idx.columns ();
   octave_idx_type nvert = vert.rows ();
 
   // Check all vertices in faces are defined
-  bad_data_msg = std::string ();
+  bad_data_msg = "";
   if (static_cast<double> (nvert) < idx.row_max ().max ())
     {
       bad_data_msg = "some vertices in \"faces\" property are undefined";
       return;
     }
 
   // Replace NaNs
   if (idx.any_element_is_inf_or_nan ())
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -729,17 +729,17 @@ public:
     if (stored_type == char_t)
       return octave_value (char_value ());
     else
       return octave_value (cell_value ());
   }
 
   std::string string_value (void) const
   {
-    return value.empty () ? std::string () : value[0];
+    return value.empty () ? "" : value[0];
   }
 
   string_vector string_vector_value (void) const { return value; }
 
   charMatrix char_value (void) const { return charMatrix (value, ' '); }
 
   Cell cell_value (void) const {return Cell (value); }
 
@@ -823,17 +823,17 @@ private:
   type stored_type;
 };
 
 // ---------------------------------------------------------------------
 
 class radio_values
 {
 public:
-  OCTINTERP_API radio_values (const std::string& opt_string = std::string ());
+  OCTINTERP_API radio_values (const std::string& opt_string = "");
 
   radio_values (const radio_values& a)
     : default_val (a.default_val), possible_vals (a.possible_vals) { }
 
   radio_values& operator = (const radio_values& a)
   {
     if (&a != this)
       {
@@ -2300,17 +2300,17 @@ public:
   static void unload_all_toolkits (void)
   {
     if (instance_ok ())
       instance->do_unload_all_toolkits ();
   }
 
   static std::string default_toolkit (void)
   {
-    return instance_ok () ? instance->do_default_toolkit () : std::string ();
+    return instance_ok () ? instance->do_default_toolkit () : "";
   }
 
 private:
 
   gtk_manager (void) { }
 
   ~gtk_manager (void) { }
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1196,17 +1196,17 @@ Undocumented internal function.\n\
   return octave_value (Cell (bif));
 }
 
 static std::string
 do_which (const std::string& name, std::string& type)
 {
   std::string file;
 
-  type = std::string ();
+  type = "";
 
   octave_value val = symbol_table::find_function (name);
 
   if (name.find_first_of ('.') == std::string::npos)
     {
       if (val.is_defined ())
         {
           octave_function *fcn = val.function_value ();
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -39,17 +39,17 @@ public:
   friend class hook_function;
 
   base_hook_function (void) : count (1) { }
 
   base_hook_function (const base_hook_function&) : count (1) { }
 
   virtual ~base_hook_function (void) { }
 
-  virtual std::string id (void) { return std::string (); }
+  virtual std::string id (void) { return ""; }
 
   virtual bool is_valid (void) { return false; }
 
   virtual void eval (const octave_value_list&) { }
 
 protected:
 
   size_t count;
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -1094,21 +1094,21 @@ load_path::loader::find_fcn (const std::
       if (pos != std::string::npos)
         {
           std::string class_name = fcn.substr (1, pos-1);
           std::string meth = fcn.substr (pos+1);
 
           retval = find_method (class_name, meth, dir_name);
         }
       else
-        retval = std::string ();
+        retval = "";
     }
   else
     {
-      dir_name = std::string ();
+      dir_name = "";
 
       const_fcn_map_iterator p = fcn_map.find (fcn);
 
       if (p != fcn_map.end ())
         {
           const file_info_list_type& file_info_list = p->second;
 
           for (const_file_info_list_iterator i = file_info_list.begin ();
@@ -1121,17 +1121,17 @@ load_path::loader::find_fcn (const std::
 
               if (check_file_type (retval, type, fi.types,
                                    fcn, "load_path::do_find_fcn"))
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
               else
-                retval = std::string ();
+                retval = "";
             }
         }
     }
 
   return retval;
 }
 
 std::string
@@ -1168,17 +1168,17 @@ std::string
 load_path::loader::find_method (const std::string& class_name,
                                 const std::string& meth,
                                 std::string& dir_name, int type) const
 {
   std::string retval;
 
   //  update ();
 
-  dir_name = std::string ();
+  dir_name = "";
 
   const_method_map_iterator q = method_map.find (class_name);
 
   if (q != method_map.end ())
     {
       const fcn_map_type& m = q->second;
 
       const_fcn_map_iterator p = m.find (meth);
@@ -1199,17 +1199,17 @@ load_path::loader::find_method (const st
                                             meth, "load_path::do_find_method");
 
               if (found)
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
               else
-                retval = std::string ();
+                retval = "";
             }
         }
     }
 
   return retval;
 }
 
 std::list<std::string>
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -91,34 +91,34 @@ public:
   static bool contains_canonical (const std::string& dir_name)
   {
     return instance_ok () ? instance->do_contains_canonical (dir_name) : false;
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth,
                                   std::string& dir_name,
-                                  const std::string& pack_name = std::string ())
+                                  const std::string& pack_name = "")
   {
     return instance_ok ()
       ? instance->get_loader (pack_name).find_method (class_name, meth,
                                                       dir_name)
-      : std::string ();
+      : "";
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth,
-                                  const std::string& pack_name = std::string ())
+                                  const std::string& pack_name = "")
   {
     std::string dir_name;
     return find_method (class_name, meth, dir_name, pack_name);
   }
 
   static std::list<std::string> methods (const std::string& class_name,
-                                         const std::string& pack_name = std::string ())
+                                         const std::string& pack_name = "")
   {
     return instance_ok ()
       ? instance->get_loader(pack_name).methods (class_name)
       : std::list<std::string> ();
   }
 
   static std::list<std::string> overloads (const std::string& meth)
   {
@@ -136,91 +136,91 @@ public:
   get_all_package_names (bool only_top_level = true)
   {
     return instance_ok ()
       ? instance->do_get_all_package_names (only_top_level)
       : std::list<std::string> ();
   }
 
   static std::string find_fcn (const std::string& fcn, std::string& dir_name,
-                               const std::string& pack_name = std::string ())
+                               const std::string& pack_name = "")
   {
     return instance_ok ()
       ? instance->get_loader (pack_name).find_fcn (fcn, dir_name)
-      : std::string ();
+      : "";
   }
 
   static std::string find_fcn (const std::string& fcn,
-                               const std::string& pack_name = std::string ())
+                               const std::string& pack_name = "")
   {
     std::string dir_name;
     return find_fcn (fcn, dir_name, pack_name);
   }
 
   static std::string find_private_fcn (const std::string& dir,
                                        const std::string& fcn,
-                                       const std::string& pack_name = std::string ())
+                                       const std::string& pack_name = "")
   {
     return instance_ok ()
       ? instance->get_loader (pack_name).find_private_fcn (dir, fcn)
-      : std::string ();
+      : "";
   }
 
   static std::string find_fcn_file (const std::string& fcn,
-                                    const std::string& pack_name = std::string ())
+                                    const std::string& pack_name = "")
   {
     std::string dir_name;
 
     return instance_ok ()
       ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : std::string ();
+      : "";
   }
 
   static std::string find_oct_file (const std::string& fcn,
-                                    const std::string& pack_name = std::string ())
+                                    const std::string& pack_name = "")
   {
     std::string dir_name;
 
     return instance_ok ()
       ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : std::string ();
+      : "";
   }
 
   static std::string find_mex_file (const std::string& fcn,
-                                    const std::string& pack_name = std::string ())
+                                    const std::string& pack_name = "")
   {
     std::string dir_name;
 
     return instance_ok ()
       ? instance->get_loader (pack_name).find_fcn (fcn, dir_name, M_FILE)
-      : std::string ();
+      : "";
   }
 
   static std::string find_file (const std::string& file)
   {
     return instance_ok ()
-           ? instance->do_find_file (file) : std::string ();
+           ? instance->do_find_file (file) : "";
   }
 
   static std::string find_dir (const std::string& dir)
   {
     return instance_ok ()
-           ? instance->do_find_dir (dir) : std::string ();
+           ? instance->do_find_dir (dir) : "";
   }
 
   static string_vector find_matching_dirs (const std::string& dir)
   {
     return instance_ok ()
            ? instance->do_find_matching_dirs (dir) : string_vector ();
   }
 
   static std::string find_first_of (const string_vector& files)
   {
     return instance_ok () ?
-           instance->do_find_first_of (files) : std::string ();
+           instance->do_find_first_of (files) : "";
   }
 
   static string_vector find_all_first_of (const string_vector& files)
   {
     return instance_ok () ?
            instance->do_find_all_first_of (files) : string_vector ();
   }
 
@@ -243,17 +243,17 @@ public:
 
   static string_vector fcn_names (void)
   {
     return instance_ok () ? instance->do_fcn_names () : string_vector ();
   }
 
   static std::string path (void)
   {
-    return instance_ok () ? instance->do_path () : std::string ();
+    return instance_ok () ? instance->do_path () : "";
   }
 
   static void display (std::ostream& os)
   {
     if (instance_ok ())
       instance->do_display (os);
   }
 
@@ -267,22 +267,22 @@ public:
       command_line_path = p;
     else
       command_line_path += dir_path::path_sep_str () + p;
   }
 
   static std::string get_command_line_path (void)
   {
     return instance_ok () ? instance->do_get_command_line_path ()
-                          : std::string ();
+                          : "";
   }
 
   static std::string system_path (void)
   {
-    return instance_ok () ? instance->do_system_path () : std::string ();
+    return instance_ok () ? instance->do_system_path () : "";
   }
 
 private:
 
   static const int M_FILE = 1;
   static const int OCT_FILE = 2;
   static const int MEX_FILE = 4;
 
@@ -485,17 +485,17 @@ private:
   typedef std::map<std::string, fcn_map_type> method_map_type;
 
   typedef method_map_type::const_iterator const_method_map_iterator;
   typedef method_map_type::iterator method_map_iterator;
 
   class loader
   {
   public:
-    loader (const std::string& pfx = std::string ())
+    loader (const std::string& pfx = "")
       : prefix (pfx), dir_list (), fcn_map (), private_fcn_map (),
         method_map () { }
 
     loader (const loader& l)
       : prefix (l.prefix), dir_list (l.dir_list),
         private_fcn_map (l.private_fcn_map), method_map (l.method_map) { }
 
     ~loader (void) { }
@@ -630,20 +630,20 @@ private:
 
   bool contains (const std::string& dir) const;
 
   bool do_contains_canonical (const std::string& dir) const;
 
   void do_move (dir_info_list_iterator i, bool at_end);
 
   void move (const dir_info& di, bool at_end,
-             const std::string& pname = std::string ());
+             const std::string& pname = "");
 
   void remove (const dir_info& di,
-               const std::string& pname = std::string ());
+               const std::string& pname = "");
 
   void do_initialize (bool set_initial_path);
 
   void do_clear (void);
 
   void do_set (const std::string& p, bool warn, bool is_init = false);
 
   void do_append (const std::string& dir, bool warn);
@@ -717,17 +717,17 @@ private:
   void do_display (std::ostream& os) const;
 
   std::string do_system_path (void) const { return sys_path; }
 
   std::string do_get_command_line_path (void) const
   { return command_line_path; }
 
   void add (const dir_info& di, bool at_end,
-            const std::string& pname = std::string (),
+            const std::string& pname = "",
             bool updating = false) const;
 
   friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
 };
 
 extern std::string
 genpath (const std::string& dir, const string_vector& skip = "private");
 
diff --git a/libinterp/corefcn/ls-ascii-helper.cc b/libinterp/corefcn/ls-ascii-helper.cc
--- a/libinterp/corefcn/ls-ascii-helper.cc
+++ b/libinterp/corefcn/ls-ascii-helper.cc
@@ -124,17 +124,17 @@ skip_preceeding_newline (std::istream& i
 // Depending on KEEP_NEWLINE, either eat newline from stream or keep
 // it unread.  Characters read are stored and returned as
 // std::string.
 
 std::string
 read_until_newline (std::istream& is, bool keep_newline)
 {
   if (! is)
-    return std::string ();
+    return "";
 
   std::ostringstream buf;
 
   while (is)
     {
       char c = is.peek ();
 
       if (c == '\n' || c == '\r')
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -105,17 +105,17 @@ get_mat_data_input_line (std::istream& i
   while (! (have_data || is.eof ()));
 
   return retval;
 }
 
 static void
 get_lines_and_columns (std::istream& is,
                        octave_idx_type& nr, octave_idx_type& nc,
-                       const std::string& filename = std::string (),
+                       const std::string& filename = "",
                        bool quiet = false, bool check_numeric = false)
 {
   std::streampos pos = is.tellg ();
 
   int file_line_number = 0;
 
   nr = 0;
   nc = 0;
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1201,17 +1201,17 @@ read_mat5_binary_element (std::istream& 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
                     if (load_path::find_method (classname, "loadobj")
-                        != std::string ())
+                        != "")
                       {
                         try
                           {
                             octave_value_list tmp = feval ("loadobj", tc, 1);
 
                             tc = tmp(0);
                           }
                         catch (const octave_execution_exception&)
@@ -2596,17 +2596,17 @@ save_mat5_binary_element (std::ostream& 
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       octave_map m;
 
       if (tc.is_object ()
           && load_path::find_method (tc.class_name (),
-                                     "saveobj") != std::string ())
+                                     "saveobj") != "")
         {
           try
             {
               octave_value_list tmp = feval ("saveobj", tc, 1);
 
               m = tmp(0).map_value ();
             }
           catch (const octave_execution_exception&)
diff --git a/libinterp/corefcn/ls-mat5.h b/libinterp/corefcn/ls-mat5.h
--- a/libinterp/corefcn/ls-mat5.h
+++ b/libinterp/corefcn/ls-mat5.h
@@ -43,17 +43,17 @@ enum mat5_data_type
   miUTF8,                     // Unicode UTF-8 Encoded Character Data
   miUTF16,                    // Unicode UTF-16 Encoded Character Data
   miUTF32                     // Unicode UTF-32 Encoded Character Data
 };
 
 extern int
 read_mat5_binary_file_header (std::istream& is, bool& swap,
                               bool quiet = false,
-                              const std::string& filename = std::string ());
+                              const std::string& filename = "");
 extern std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
                           bool swap, bool& global, octave_value& tc);
 extern bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
                           bool save_as_floats, bool compressing = false);
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -241,17 +241,17 @@ read_text_data (std::istream& is, const 
   std::string name = extract_keyword (is, "name");
 
   if (name.empty ())
     {
       if (count == 0)
         error ("load: empty name keyword or no data found in file '%s'",
                filename.c_str ());
 
-      return std::string ();
+      return "";
     }
 
   if (! (name == ".nargin." || name == ".nargout."
          || name == CELL_ELT_TAG || valid_identifier (name)))
     error ("load: invalid identifier '%s' found in file '%s'",
            name.c_str (), filename.c_str ());
 
   // Look for type keyword.
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "oct-stream.h"
 
 class
 octave_base_iostream : public octave_base_stream
 {
 public:
 
-  octave_base_iostream (const std::string& n = std::string (),
+  octave_base_iostream (const std::string& n = "",
                         std::ios::openmode m = std::ios::in|std::ios::out,
                         oct_mach_info::float_format ff
                           = oct_mach_info::native_float_format ())
     : octave_base_stream (m, ff), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
@@ -73,24 +73,24 @@ private:
   octave_base_iostream& operator = (const octave_base_iostream&);
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
-  octave_istream (std::istream *arg = 0, const std::string& n = std::string ())
+  octave_istream (std::istream *arg = 0, const std::string& n = "")
     : octave_base_iostream (n, std::ios::in,
                             oct_mach_info::native_float_format ()),
       is (arg)
   { }
 
   static octave_stream
-  create (std::istream *arg = 0, const std::string& n = std::string ());
+  create (std::istream *arg = 0, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return is; }
 
   std::ostream *output_stream (void) { return 0; }
@@ -112,24 +112,24 @@ private:
   octave_istream& operator = (const octave_istream&);
 };
 
 class
 octave_ostream : public octave_base_iostream
 {
 public:
 
-  octave_ostream (std::ostream *arg, const std::string& n = std::string ())
+  octave_ostream (std::ostream *arg, const std::string& n = "")
     : octave_base_iostream (n, std::ios::out,
                             oct_mach_info::native_float_format ()),
       os (arg)
   { }
 
   static octave_stream
-  create (std::ostream *arg, const std::string& n = std::string ());
+  create (std::ostream *arg, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return os; }
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -83,17 +83,17 @@ public:
   void assign (octave_value::assign_op, const octave_value&);
 
   void numel (octave_idx_type n) { nel = n; }
 
   octave_idx_type numel (void) const { return nel; }
 
   void set_index (const std::string& t, const std::list<octave_value_list>& i);
 
-  void clear_index (void) { type = std::string (); idx.clear (); }
+  void clear_index (void) { type = ""; idx.clear (); }
 
   std::string index_type (void) const { return type; }
 
   bool index_is_empty (void) const;
 
   void do_unary_op (octave_value::unary_op op);
 
   octave_value value (void) const;
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4103,17 +4103,17 @@ string_vector
 octave_stream_list::get_info (const octave_value& fid)
 {
   return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
 }
 
 std::string
 octave_stream_list::list_open_files (void)
 {
-  return (instance_ok ()) ? instance->do_list_open_files () : std::string ();
+  return (instance_ok ()) ? instance->do_list_open_files () : "";
 }
 
 octave_value
 octave_stream_list::open_file_numbers (void)
 {
   return (instance_ok ())
          ? instance->do_open_file_numbers () : octave_value ();
 }
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -50,17 +50,17 @@ public:
   {
     whitespace_conversion = 1,
     literal_conversion = 2,
     null = 3
   };
 
   scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
                     char typ = '\0', char mod = '\0',
-                    const std::string& ch_class = std::string ())
+                    const std::string& ch_class = "")
     : text (strsave (txt)), width (w), discard (d), type (typ),
       modifier (mod), char_class (ch_class) { }
 
   scanf_format_elt (const scanf_format_elt& e)
     : text (strsave (e.text)), width (e.width), discard (e.discard),
       type (e.type), modifier (e.modifier), char_class (e.char_class) { }
 
   scanf_format_elt& operator = (const scanf_format_elt& e)
@@ -101,17 +101,17 @@ public:
 };
 
 class
 OCTINTERP_API
 scanf_format_list
 {
 public:
 
-  scanf_format_list (const std::string& fmt = std::string ());
+  scanf_format_list (const std::string& fmt = "");
 
   ~scanf_format_list (void);
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   // The length can be different than the number of conversions.
   // For example, "x %d y %d z" has 2 conversions but the length of
   // the list is 3 because of the characters that appear after the
@@ -169,17 +169,17 @@ private:
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
                         octave_idx_type& num_elts,
-                        const std::string& char_class = std::string ());
+                        const std::string& char_class = "");
 
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& width, bool& discard, char& type,
                            char& modifier, octave_idx_type& num_elts);
 
   int finish_conversion (const std::string& s, size_t& i, size_t n,
                          int& width, bool discard, char& type,
                          char modifier, octave_idx_type& num_elts);
@@ -191,17 +191,17 @@ private:
 };
 
 class
 printf_format_elt
 {
 public:
 
   printf_format_elt (const char *txt = 0, int n = 0, int w = -1,
-                     int p = -1, const std::string& f = std::string (),
+                     int p = -1, const std::string& f = "",
                      char typ = '\0', char mod = '\0')
     : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
       type (typ), modifier (mod) { }
 
   printf_format_elt (const printf_format_elt& e)
     : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
       flags (e.flags), type (e.type), modifier (e.modifier) { }
 
@@ -247,17 +247,17 @@ public:
 };
 
 class
 OCTINTERP_API
 printf_format_list
 {
 public:
 
-  printf_format_list (const std::string& fmt = std::string ());
+  printf_format_list (const std::string& fmt = "");
 
   ~printf_format_list (void);
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   const printf_format_elt *first (void)
   {
     curr_idx = 0;
@@ -687,24 +687,24 @@ public:
 
   ~octave_stream_list (void) { }
 
   static bool instance_ok (void);
 
   static int insert (octave_stream& os);
 
   static octave_stream
-  lookup (int fid, const std::string& who = std::string ());
+  lookup (int fid, const std::string& who = "");
 
   static octave_stream
-  lookup (const octave_value& fid, const std::string& who = std::string ());
+  lookup (const octave_value& fid, const std::string& who = "");
 
-  static int remove (int fid, const std::string& who = std::string ());
+  static int remove (int fid, const std::string& who = "");
   static int remove (const octave_value& fid,
-                     const std::string& who = std::string ());
+                     const std::string& who = "");
 
   static void clear (bool flush = true);
 
   static string_vector get_info (int fid);
   static string_vector get_info (const octave_value& fid);
 
   static std::string list_open_files (void);
 
@@ -722,23 +722,23 @@ private:
 
   static octave_stream_list *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   int do_insert (octave_stream& os);
 
   octave_stream do_lookup (int fid,
-                           const std::string& who = std::string ()) const;
+                           const std::string& who = "") const;
   octave_stream do_lookup (const octave_value& fid,
-                           const std::string& who = std::string ()) const;
+                           const std::string& who = "") const;
 
-  int do_remove (int fid, const std::string& who = std::string ());
+  int do_remove (int fid, const std::string& who = "");
   int do_remove (const octave_value& fid,
-                 const std::string& who = std::string ());
+                 const std::string& who = "");
 
   void do_clear (bool flush = true);
 
   string_vector do_get_info (int fid) const;
   string_vector do_get_info (const octave_value& fid) const;
 
   std::string do_list_open_files (void) const;
 
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -43,17 +43,17 @@ public:
   int seek (off_t, int);
 
   // Return current stream position.
 
   virtual off_t tell (void);
 
   // The name of the file.
 
-  std::string name (void) const { return std::string (); }
+  std::string name (void) const { return ""; }
 
   virtual std::streambuf *rdbuf (void) = 0;
 
   virtual bool bad (void) const = 0;
 
   virtual void clear (void) = 0;
 
 protected:
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -390,17 +390,17 @@ octregexp (const octave_value_list &args
       retval(5) = nmap;
     }
 
   if (options.once ())
     {
       regexp::match_data::const_iterator p = rx_lst.begin ();
 
       retval(4) = sz ? p->tokens () : Cell ();
-      retval(3) = sz ? p->match_string () : std::string ();
+      retval(3) = sz ? p->match_string () : "";
       retval(2) = sz ? p->token_extents () : Matrix ();
 
       if (sz)
         {
           double start = p->start ();
           double end = p->end ();
 
           Cell split (dim_vector (1, 2));
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -138,22 +138,22 @@ in control (see @code{are} and @code{dar
   std::string ord;
   if (nargin == 2)
     ord = args(1).xstring_value ("schur: second argument must be a string");
 
   bool force_complex = false;
 
   if (ord == "real")
     {
-      ord = std::string ();
+      ord = "";
     }
   else if (ord == "complex")
     {
       force_complex = true;
-      ord = std::string ();
+      ord = "";
     }
   else
     {
       char ord_char = ord.empty () ? 'U' : ord[0];
 
       if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
           && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
         {
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -172,17 +172,17 @@ do_sqrtm (const octave_value& arg)
           break;
 
         default:
           {
             ComplexMatrix u;
 
             do
               {
-                ComplexSCHUR schur (x, std::string (), true);
+                ComplexSCHUR schur (x, "", true);
                 x = schur.schur_matrix ();
                 u = schur.unitary_matrix ();
               }
             while (0); // schur no longer needed.
 
             sqrtm_utri_inplace (x);
 
             x = u * x; // original x no longer needed.
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -350,17 +350,17 @@ do_strcmp_fun (const octave_value& arg0,
       octave_idx_type r = str.numel ();
 
       if (r == 0 || r == 1)
         {
           // Broadcast the string.
 
           boolNDArray output (cell_val.dims (), false);
 
-          std::string s = r == 0 ? std::string () : str[0];
+          std::string s = r == 0 ? "" : str[0];
 
           if (cell_val.is_cellstr ())
             {
               const Array<std::string> cellstr = cell_val.cellstr_value ();
               for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 output(i) = str_op (cellstr(i), s, n);
             }
           else
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -180,18 +180,18 @@ split_name_with_package (const std::stri
 //
 // FIXME: perhaps this should be done for all loaded functions when
 // the prompt is printed or the directory has changed, and then we
 // would not check for it when finding symbol definitions.
 
 static inline bool
 load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
                       octave_value& function,
-                      const std::string& dispatch_type = std::string (),
-                      const std::string& package_name = std::string ())
+                      const std::string& dispatch_type = "",
+                      const std::string& package_name = "")
 {
   bool retval = false;
 
   octave_function *fcn = load_fcn_from_file (ff, dir_name, dispatch_type,
                                              package_name);
 
   if (fcn)
     {
@@ -1160,17 +1160,17 @@ symbol_table::is_superiorto (const std::
   return (q != inferior_classes.end ());
 }
 
 static std::string
 fcn_file_name (const octave_value& fcn)
 {
   const octave_function *f = fcn.function_value ();
 
-  return f ? f->fcn_file_name () : std::string ();
+  return f ? f->fcn_file_name () : "";
 }
 
 void
 symbol_table::fcn_info::fcn_info_rep::dump (std::ostream& os,
                                             const std::string& prefix) const
 {
   os << prefix << full_name ()
      << " ["
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -478,17 +478,17 @@ public:
       symbol_record_rep (const symbol_record_rep& ov);
 
       symbol_record_rep& operator = (const symbol_record_rep&);
     };
 
   public:
 
     symbol_record (scope_id s = xcurrent_scope,
-                   const std::string& nm = std::string (),
+                   const std::string& nm = "",
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
       : rep (new symbol_record_rep (s, nm, v, sc)) { }
 
     symbol_record (const symbol_record& sr)
       : rep (sr.rep)
     {
       rep->count++;
@@ -635,17 +635,17 @@ public:
 
     scope_id scope (void) const { return rep->scope (); }
 
     unsigned int xstorage_class (void) const { return rep->storage_class; }
 
     void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
 
     void
-    dump (std::ostream& os, const std::string& prefix = std::string ()) const
+    dump (std::ostream& os, const std::string& prefix = "") const
     {
       rep->dump (os, prefix);
     }
 
   private:
 
     symbol_record_rep *rep;
 
@@ -977,17 +977,17 @@ public:
 
       fcn_info_rep (const fcn_info_rep&);
 
       fcn_info_rep& operator = (const fcn_info_rep&);
     };
 
   public:
 
-    fcn_info (const std::string& nm = std::string ())
+    fcn_info (const std::string& nm = "")
       : rep (new fcn_info_rep (nm)) { }
 
     fcn_info (const fcn_info& fi) : rep (fi.rep)
     {
       rep->count++;
     }
 
     fcn_info& operator = (const fcn_info& fi)
@@ -1138,17 +1138,17 @@ public:
     { return rep->help_for_dispatch (); }
 
     dispatch_map_type get_dispatch (void) const
     {
       return rep->get_dispatch ();
     }
 
     void
-    dump (std::ostream& os, const std::string& prefix = std::string ()) const
+    dump (std::ostream& os, const std::string& prefix = "") const
     {
       rep->dump (os, prefix);
     }
 
   private:
 
     fcn_info_rep *rep;
   };
@@ -2907,17 +2907,17 @@ private:
         return true;
       }
 
     return false;
   }
 };
 
 extern bool out_of_date_check (octave_value& function,
-                               const std::string& dispatch_type = std::string (),
+                               const std::string& dispatch_type = "",
                                bool check_relative = true);
 
 extern OCTINTERP_API std::string
 get_dispatch_type (const octave_value_list& args);
 extern OCTINTERP_API std::string
 get_dispatch_type (const octave_value_list& args, builtin_type_t& builtin_type);
 
 #endif
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -648,17 +648,17 @@ string.\n\
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string var = args(0).xstring_value ("setenv: VAR must be a string");
 
   std::string val = (nargin == 2
                      ? args(1).xstring_value ("setenv: VALUE must be a string")
-                     : std::string ());
+                     : "");
 
   octave_env::putenv (var, val);
 
   return retval;
 }
 
 DEFALIAS (putenv, setenv);
 
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -102,17 +102,17 @@ bool octave_interpreter_ready = false;
 // TRUE means we've processed all the init code and we are good to go.
 bool octave_initialized = false;
 
 octave_call_stack *octave_call_stack::instance = 0;
 
 std::string
 octave_call_stack::stack_frame::fcn_file_name (void) const
 {
-  return m_fcn ? m_fcn->fcn_file_name () : std::string ();
+  return m_fcn ? m_fcn->fcn_file_name () : "";
 }
 
 std::string
 octave_call_stack::stack_frame::fcn_name (bool print_subfn) const
 {
   std::string retval;
 
   if (m_fcn)
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -505,17 +505,17 @@ Undocumented internal function\n\
   std::string host = args(0).xstring_value ("__ftp__: HOST must be a string");
 
   std::string user = (nargin > 1)
     ? args(1).xstring_value ("__ftp__: USER must be a string")
     : std::string ("anonymous");
 
   std::string passwd = (nargin > 2)
     ? args(2).xstring_value ("__ftp__: PASSWD must be a string")
-    : std::string ();
+    : "";
 
   curl_handle ch
     = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
   return octave_value (ch.value ());
 }
 
 DEFUN (__ftp_pwd__, args, ,
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1097,17 +1097,17 @@ get_dims_str (const octave_value& val)
 
 class
 symbol_info_list
 {
 private:
   struct symbol_info
   {
     symbol_info (const symbol_table::symbol_record& sr,
-                 const std::string& expr_str = std::string (),
+                 const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
         varval (expr_val.is_undefined () ? sr.varval () : expr_val),
         is_automatic (sr.is_automatic ()),
         is_complex (varval.is_complex_type ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
         is_persistent (sr.is_persistent ())
@@ -1584,17 +1584,17 @@ public:
 
 private:
   std::list<symbol_info> lst;
 
 };
 
 static octave_value
 do_who (int argc, const string_vector& argv, bool return_list,
-        bool verbose = false, std::string msg = std::string ())
+        bool verbose = false, std::string msg = "")
 {
   octave_value retval;
 
   std::string my_name = argv[0];
 
   bool global_only = false;
   bool have_regexp = false;
 
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -41,21 +41,21 @@ class string_vector;
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern OCTINTERP_API void clear_mex_functions (void);
 
 extern OCTINTERP_API octave_function *
-is_valid_function (const octave_value&, const std::string& = std::string (),
+is_valid_function (const octave_value&, const std::string& = "",
                    bool warn = false);
 
 extern OCTINTERP_API octave_function *
-is_valid_function (const std::string&, const std::string& = std::string (),
+is_valid_function (const std::string&, const std::string& = "",
                    bool warn = false);
 
 extern OCTINTERP_API octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer);
 
 extern OCTINTERP_API string_vector
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -39,18 +39,18 @@ OCTINTERP_API
 octave_builtin : public octave_function
 {
 public:
 
   octave_builtin (void) : octave_function (), f (0), file (), jtype (0) { }
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
-  octave_builtin (fcn ff, const std::string& nm = std::string (),
-                  const std::string& ds = std::string ())
+  octave_builtin (fcn ff, const std::string& nm = "",
+                  const std::string& ds = "")
     : octave_function (nm, ds), f (ff), file (), jtype (0) { }
 
   octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
     : octave_function (nm, ds), f (ff), file (fnm), jtype (0) { }
 
   ~octave_builtin (void) { }
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -598,17 +598,17 @@ octave_cell::string_vector_value (bool p
                 t += std::string (max_len - t_len, ' ');
 
               retval[k++] = t;
             }
         }
       else if (pad)
         retval[k++] = std::string (max_len, ' ');
       else
-        retval[k++] = std::string ();
+        retval[k++] = "";
     }
 
   return retval;
 }
 
 Array<std::string>
 octave_cell::cellstr_value (void) const
 {
@@ -789,17 +789,17 @@ octave_cell::load_ascii (std::istream& i
       Cell tmp(dv);
 
       for (octave_idx_type i = 0; i < dv.numel (); i++)
         {
           octave_value t2;
           bool dummy;
 
           // recurse to read cell elements
-          std::string nm = read_text_data (is, std::string (),
+          std::string nm = read_text_data (is, "",
                                            dummy, t2, i);
 
           if (nm != CELL_ELT_TAG)
             error ("load: cell array element had unexpected name");
 
           if (is)
             tmp.elem (i) = t2;
         }
@@ -824,17 +824,17 @@ octave_cell::load_ascii (std::istream& i
           for (octave_idx_type j = 0; j < nc; j++)
             {
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   octave_value t2;
                   bool dummy;
 
                   // recurse to read cell elements
-                  std::string nm = read_text_data (is, std::string (),
+                  std::string nm = read_text_data (is, "",
                                                    dummy, t2, i);
 
                   if (nm != CELL_ELT_TAG)
                     error ("load: cell array element had unexpected name");
 
                   if (is)
                     tmp.elem (i, j) = t2;
                 }
@@ -934,17 +934,17 @@ octave_cell::load_binary (std::istream& 
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value t2;
       bool dummy;
       std::string doc;
 
       // recurse to read cell elements
-      std::string nm = read_binary_data (is, swap, fmt, std::string (),
+      std::string nm = read_binary_data (is, swap, fmt, "",
                                          dummy, t2, doc);
 
       if (nm != CELL_ELT_TAG)
         error ("load: cell array element had unexpected name");
 
       if (is)
         tmp.elem (i) = t2;
     }
@@ -1277,17 +1277,17 @@ To convert back from a cellstr to a char
   octave_value_list tmp = Fiscellstr (args, 1);
 
   if (tmp(0).is_true ())
     return ovl (args(0));
   else
     {
       string_vector s = args(0).xstring_vector_value ("cellstr: argument STRING must be a 2-D character array");
 
-      return ovl (s.is_empty () ? Cell (octave_value (std::string ()))
+      return ovl (s.is_empty () ? Cell (octave_value (""))
                                 : Cell (s, true));
     }
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1163,17 +1163,17 @@ octave_class::reconstruct_parents (void)
   return retval;
 }
 
 bool
 octave_class::save_ascii (std::ostream& os)
 {
   os << "# classname: " << class_name () << "\n";
   octave_map m;
-  if (load_path::find_method (class_name (), "saveobj") != std::string ())
+  if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1214,17 +1214,17 @@ octave_class::load_ascii (std::istream& 
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
 
           // recurse to read cell elements
           std::string nm
-            = read_text_data (is, std::string (), dummy, t2, j);
+            = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
           m.assign (nm, tcell);
         }
@@ -1236,17 +1236,17 @@ octave_class::load_ascii (std::istream& 
       reconstruct_exemplar ();
 
       map = m;
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
       if (load_path::find_method (classname, "loadobj")
-          != std::string ())
+          != "")
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
         }
     }
   else if (len == 0)
@@ -1264,17 +1264,17 @@ bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
   int32_t classname_len = class_name ().length ();
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
-  if (load_path::find_method (class_name (), "saveobj") != std::string ())
+  if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1333,17 +1333,17 @@ octave_class::load_binary (std::istream&
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (),
+          std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2);
 
           m.assign (nm, tcell);
@@ -1351,17 +1351,17 @@ octave_class::load_binary (std::istream&
 
       if (is)
         {
           map = m;
 
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
 
-          if (load_path::find_method (c_name, "loadobj") != std::string ())
+          if (load_path::find_method (c_name, "loadobj") != "")
             {
               octave_value in = new octave_class (*this);
               octave_value_list tmp = feval ("loadobj", in, 1);
 
               map = tmp(0).map_value ();
             }
         }
       else
@@ -1424,17 +1424,17 @@ octave_class::save_hdf5 (octave_hdf5_id 
   data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT,
                         H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
-  if (load_path::find_method (class_name (), "saveobj") != std::string ())
+  if (load_path::find_method (class_name (), "saveobj") != "")
     {
       octave_value in = new octave_class (*this);
       octave_value_list tmp = feval ("saveobj", in, 1);
 
       m = tmp(0).map_value ();
     }
   else
     m = map_value ();
@@ -1586,17 +1586,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
 
   if (retval2 >= 0)
     {
       map = m;
 
       if (! reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
 
-      if (load_path::find_method (c_name, "loadobj") != std::string ())
+      if (load_path::find_method (c_name, "loadobj") != "")
         {
           octave_value in = new octave_class (*this);
           octave_value_list tmp = feval ("loadobj", in, 1);
 
           map = tmp(0).map_value ();
           retval = true;
         }
     }
@@ -1924,17 +1924,17 @@ Return true if the string @var{method} i
     class_name = arg.class_name ();
   else if (arg.is_string ())
     class_name = arg.string_value ();
   else
     error ("ismethod: first argument must be object or class name");
 
   std::string method = args(1).string_value ();
 
-  if (load_path::find_method (class_name, method) != std::string ())
+  if (load_path::find_method (class_name, method) != "")
     return ovl (true);
   else
     return ovl (false);
 }
 
 DEFUN (__methods__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __methods__ (@var{x})\n\
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -305,18 +305,18 @@ in_class_method (const cdef_class& cls)
 {
   cdef_class ctx = get_class_context ();
 
   return (ctx.ok () && is_superclass (ctx, cls));
 }
 
 static bool
 check_access (const cdef_class& cls, const octave_value& acc,
-              const std::string& meth_name = std::string (),
-              const std::string& prop_name = std::string (),
+              const std::string& meth_name = "",
+              const std::string& prop_name = "",
               bool is_prop_set = false)
 {
   if (acc.is_string ())
     {
       std::string acc_s = acc.string_value ();
 
       if (acc_s == "public")
         return true;
@@ -650,18 +650,18 @@ make_class (const std::string& name,
             const std::list<cdef_class>& super_list = std::list<cdef_class> ())
 {
   cdef_class cls (name, super_list);
 
   cls.set_class (cdef_class::meta_class ());
   cls.put ("Abstract", false);
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
-  cls.put ("Description", std::string ());
-  cls.put ("DetailedDescription", std::string ());
+  cls.put ("Description", "");
+  cls.put ("DetailedDescription", "");
   cls.put ("Events", Cell ());
   cls.put ("Hidden", false);
   cls.put ("InferiorClasses", Cell ());
   cls.put ("Methods", Cell ());
   cls.put ("Properties", Cell ());
   cls.put ("Sealed", false);
 
   if (name == "handle")
@@ -723,18 +723,18 @@ make_property (const cdef_class& cls, co
                const octave_value& get_method = Matrix (),
                const std::string& get_access = "public",
                const octave_value& set_method = Matrix (),
                const std::string& set_access = "public")
 {
   cdef_property prop (name);
 
   prop.set_class (cdef_class::meta_property ());
-  prop.put ("Description", std::string ());
-  prop.put ("DetailedDescription", std::string ());
+  prop.put ("Description", "");
+  prop.put ("DetailedDescription", "");
   prop.put ("Abstract", false);
   prop.put ("Constant", false);
   prop.put ("GetAccess", get_access);
   prop.put ("SetAccess", set_access);
   prop.put ("Dependent", false);
   prop.put ("Transient", false);
   prop.put ("Hidden", false);
   prop.put ("GetObservable", false);
@@ -767,18 +767,18 @@ make_method (const cdef_class& cls, cons
              bool is_static = false)
 {
   cdef_method meth (name);
 
   meth.set_class (cdef_class::meta_method ());
   meth.put ("Abstract", false);
   meth.put ("Access", m_access);
   meth.put ("DefiningClass", to_ov (cls));
-  meth.put ("Description", std::string ());
-  meth.put ("DetailedDescription", std::string ());
+  meth.put ("Description", "");
+  meth.put ("DetailedDescription", "");
   meth.put ("Hidden", false);
   meth.put ("Sealed", true);
   meth.put ("Static", is_static);
 
   if (fcn.is_defined ())
     make_function_of_class (cls, fcn);
 
   meth.set_function (fcn);
@@ -796,17 +796,17 @@ make_method (const cdef_class& cls, cons
 {
   octave_value fcn (new octave_builtin (ff, name));
 
   return make_method (cls, name, fcn, m_access, is_static);
 }
 
 static cdef_package
 make_package (const std::string& nm,
-              const std::string& parent = std::string ())
+              const std::string& parent = "")
 {
   cdef_package pack (nm);
 
   pack.set_class (cdef_class::meta_package ());
   if (parent.empty ())
     pack.put ("ContainingPackage", Matrix ());
   else
     pack.put ("ContainingPackage", to_ov (cdef_manager::find_package (parent)));
@@ -1067,17 +1067,17 @@ public:
 
     return subsref (type, l, nargout);
   }
 
   bool is_postfix_index_handled (char type) const
   { return object.meta_is_postfix_index_handled (type); }
 
   bool
-  is_classdef_constructor (const std::string& cname = std::string ()) const
+  is_classdef_constructor (const std::string& cname = "") const
   {
     bool retval = false;
 
     if (object.is_class ())
       {
         if (cname.empty ())
           retval = true;
         else
@@ -3011,28 +3011,28 @@ cdef_property::cdef_property_rep::set_va
     }
 }
 
 bool
 cdef_property::cdef_property_rep::check_get_access (void) const
 {
   cdef_class cls (to_cdef (get ("DefiningClass")));
 
-  return ::check_access (cls, get ("GetAccess"), std::string (),
+  return ::check_access (cls, get ("GetAccess"), "",
                          get_name (), false);
 
   return false;
 }
 
 bool
 cdef_property::cdef_property_rep::check_set_access (void) const
 {
   cdef_class cls (to_cdef (get ("DefiningClass")));
 
-  return ::check_access (cls, get ("SetAccess"), std::string (),
+  return ::check_access (cls, get ("SetAccess"), "",
                          get_name (), true);
 
   return false;
 }
 
 void
 cdef_method::cdef_method_rep::check_method (void)
 {
@@ -3687,17 +3687,17 @@ cdef_manager::do_find_package (const std
     }
   else
     {
       if (load_if_not_found && load_path::find_package (name))
         {
           size_t pos = name.find ('.');
 
           if (pos == std::string::npos)
-            retval = make_package (name, std::string ());
+            retval = make_package (name, "");
           else
             {
               std::string parent_name = name.substr (0, pos);
 
               retval = make_package (name, parent_name);
             }
         }
       else if (error_if_not_found)
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -933,25 +933,25 @@ private:
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_constant (void) const { return get("Constant").bool_value (); }
 
     octave_value get_value (bool do_check_access = true,
-                            const std::string& who = std::string ());
+                            const std::string& who = "");
 
     octave_value get_value (const cdef_object& obj,
                             bool do_check_access = true,
-                            const std::string& who = std::string ());
+                            const std::string& who = "");
 
     void set_value (cdef_object& obj, const octave_value& val,
                     bool do_check_access = true,
-                    const std::string& who = std::string ());
+                    const std::string& who = "");
 
     bool check_get_access (void) const;
 
     bool check_set_access (void) const;
 
   private:
     cdef_property_rep (const cdef_property_rep& p)
       : cdef_meta_object_rep (p) { }
@@ -987,26 +987,26 @@ public:
   cdef_property& operator = (const cdef_property& prop)
   {
     cdef_object::operator= (prop);
 
     return *this;
   }
 
   octave_value get_value (const cdef_object& obj, bool do_check_access = true,
-                          const std::string& who = std::string ())
+                          const std::string& who = "")
   { return get_rep ()->get_value (obj, do_check_access, who); }
 
   octave_value get_value (bool do_check_access = true,
-                          const std::string& who = std::string ())
+                          const std::string& who = "")
   { return get_rep ()->get_value (do_check_access, who); }
 
   void set_value (cdef_object& obj, const octave_value& val,
                   bool do_check_access = true,
-                  const std::string& who = std::string ())
+                  const std::string& who = "")
   { get_rep ()->set_value (obj, val, do_check_access, who); }
 
   bool check_get_access (void) const
   { return get_rep ()->check_get_access (); }
 
   bool check_set_access (void) const
   { return get_rep ()->check_set_access (); }
 
@@ -1055,22 +1055,22 @@ private:
 
     bool is_external (void) const { return ! dispatch_type.empty (); }
 
     void mark_as_external (const std::string& dtype)
     { dispatch_type = dtype; }
 
     octave_value_list execute (const octave_value_list& args, int nargout,
                                bool do_check_access = true,
-                               const std::string& who = std::string ());
+                               const std::string& who = "");
 
     octave_value_list execute (const cdef_object& obj,
                                const octave_value_list& args, int nargout,
                                bool do_check_access = true,
-                               const std::string& who = std::string ());
+                               const std::string& who = "");
 
     bool is_constructor (void) const;
 
     octave_value_list
     meta_subsref (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
 
     bool meta_is_postfix_index_handled (char type) const
@@ -1122,24 +1122,24 @@ public:
     cdef_object::operator= (meth);
 
     return *this;
   }
 
   // normal invocation
   octave_value_list execute (const octave_value_list& args, int nargout,
                              bool do_check_access = true,
-                             const std::string& who = std::string ())
+                             const std::string& who = "")
   { return get_rep ()->execute (args, nargout, do_check_access, who); }
 
   // dot-invocation: object is pushed as 1st argument
   octave_value_list execute (const cdef_object& obj,
                              const octave_value_list& args, int nargout,
                              bool do_check_access = true,
-                             const std::string& who = std::string ())
+                             const std::string& who = "")
   { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
 
   bool check_access (void) const { return get_rep ()->check_access (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_static (void) const { return get_rep ()->is_static (); }
 
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -44,18 +44,18 @@ octave_dld_function : public octave_buil
 {
 public:
 
   octave_dld_function (void)
     : sh_lib (), t_checked (), system_fcn_file ()
   { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
-                       const std::string& nm = std::string (),
-                       const std::string& ds = std::string ());
+                       const std::string& nm = "",
+                       const std::string& ds = "");
 
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
   octave_time time_parsed (void) const;
@@ -65,18 +65,18 @@ public:
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
   static octave_dld_function* create (octave_builtin::fcn ff,
                                       const octave_shlib& shl,
-                                      const std::string& nm = std::string (),
-                                      const std::string& ds = std::string ());
+                                      const std::string& nm = "",
+                                      const std::string& ds = "");
 
   octave_shlib get_shlib (void) const
   { return sh_lib; }
 
 private:
 
   octave_shlib sh_lib;
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -143,17 +143,17 @@ octave_fcn_handle::do_multi_index_op (in
 
 octave_value_list
 octave_fcn_handle::do_multi_index_op (int nargout,
                                       const octave_value_list& args,
                                       const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
-  out_of_date_check (fcn, std::string (), false);
+  out_of_date_check (fcn, "", false);
 
   if (has_overloads)
     {
       // Possibly overloaded function.
       octave_value ov_fcn;
 
       // Compute dispatch type.
       builtin_type_t btyp;
@@ -364,17 +364,17 @@ octave_fcn_handle::save_ascii (std::ostr
               if (! save_text_data (os, p->varval (0), p->name (), false, 0))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       octave_function *f = function_value ();
-      std::string fnm = f ? f->fcn_file_name () : std::string ();
+      std::string fnm = f ? f->fcn_file_name () : "";
 
       os << "# octaveroot: " << OCTAVE_EXEC_PREFIX << "\n";
       if (! fnm.empty ())
         os << "# path: " << fnm << "\n";
       os << nm << "\n";
     }
 
   return true;
@@ -439,17 +439,17 @@ octave_fcn_handle::load_ascii (std::istr
           if (len > 0)
             {
               for (octave_idx_type i = 0; i < len; i++)
                 {
                   octave_value t2;
                   bool dummy;
 
                   std::string name
-                    = read_text_data (is, std::string (), dummy, t2, i);
+                    = read_text_data (is, "", dummy, t2, i);
 
                   if (! is)
                     error ("load: failed to load anonymous function handle");
 
                   symbol_table::assign (name, t2, local_scope, 0);
                 }
             }
         }
@@ -539,17 +539,17 @@ octave_fcn_handle::save_binary (std::ost
             }
         }
     }
   else
     {
       std::ostringstream nmbuf;
 
       octave_function *f = function_value ();
-      std::string fnm = f ? f->fcn_file_name () : std::string ();
+      std::string fnm = f ? f->fcn_file_name () : "";
 
       nmbuf << nm << "\n" << OCTAVE_EXEC_PREFIX << "\n" << fnm;
 
       std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
     }
@@ -620,17 +620,17 @@ octave_fcn_handle::load_binary (std::ist
         {
           for (octave_idx_type i = 0; i < len; i++)
             {
               octave_value t2;
               bool dummy;
               std::string doc;
 
               std::string name =
-                read_binary_data (is, swap, fmt, std::string (),
+                read_binary_data (is, swap, fmt, "",
                                   dummy, t2, doc);
 
               if (! is)
                 error ("load: failed to load anonymous function handle");
 
               symbol_table::assign (name, t2, local_scope);
             }
         }
@@ -829,17 +829,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Gclose (data_hid);
         }
     }
   else
     {
       std::string octaveroot = OCTAVE_EXEC_PREFIX;
 
       octave_function *f = function_value ();
-      std::string fpath = f ? f->fcn_file_name () : std::string ();
+      std::string fpath = f ? f->fcn_file_name () : "";
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = octaveroot.length ();
       space_hid = H5Screate_simple (0 , hdims, 0);
       if (space_hid < 0)
         {
           H5Tclose (type_hid);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -719,17 +719,17 @@ functions from strings is through the us
                 while (i < fun_length && isspace (c))
                   c = fun[i++];
 
                 // Do we have a variable or a function?
                 if (c != '(')
                   terminate_arg = true;
                 else
                   {
-                    tmp_arg = std::string ();
+                    tmp_arg = "";
                     is_arg = false;
                   }
               }
           else if (! is_arg)
             {
               if (c == 'e' || c == 'E')
                 {
                   // possible number in exponent form, not arg
@@ -757,17 +757,17 @@ functions from strings is through the us
 
               if (! have_arg && tmp_arg != "i" && tmp_arg != "j"
                   && tmp_arg != "NaN" && tmp_arg != "nan"
                   && tmp_arg != "Inf" && tmp_arg != "inf"
                   && tmp_arg != "NA" && tmp_arg != "pi"
                   && tmp_arg != "e" && tmp_arg != "eps")
                 fargs.append (tmp_arg);
 
-              tmp_arg = std::string ();
+              tmp_arg = "";
               is_arg = false;
             }
         }
 
       // Sort the arguments into ascii order.
       fargs.sort ();
 
       if (fargs.is_empty ())
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -41,17 +41,17 @@ OCTINTERP_API
 octave_fcn_inline : public octave_fcn_handle
 {
 public:
 
   octave_fcn_inline (void)
     : octave_fcn_handle (), iftext (), ifargs () { }
 
   octave_fcn_inline (const std::string& f, const string_vector& a,
-                     const std::string& n = std::string ());
+                     const std::string& n = "");
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) { }
 
   octave_base_value *clone (void) const
   { return new octave_fcn_inline (*this); }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -54,75 +54,75 @@ public:
   octave_base_value *empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
-  virtual std::string fcn_file_name (void) const { return std::string (); }
+  virtual std::string fcn_file_name (void) const { return ""; }
 
-  virtual std::string src_file_name (void) const { return std::string (); }
+  virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
-  virtual std::string parent_fcn_name (void) const { return std::string (); }
+  virtual std::string parent_fcn_name (void) const { return ""; }
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual symbol_table::scope_id scope (void) { return -1; }
 
   virtual octave_time time_parsed (void) const
   { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
   { return octave_time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
 
-  virtual bool is_class_constructor (const std::string& = std::string ()) const
+  virtual bool is_class_constructor (const std::string& = "") const
   { return false; }
 
   virtual bool
-  is_classdef_constructor (const std::string& = std::string ()) const
+  is_classdef_constructor (const std::string& = "") const
   { return false; }
 
-  virtual bool is_class_method (const std::string& = std::string ()) const
+  virtual bool is_class_method (const std::string& = "") const
   { return false; }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
   void stash_dispatch_class (const std::string& nm) { xdispatch_class = nm; }
 
   std::string dispatch_class (void) const { return xdispatch_class; }
 
   void stash_package_name (const std::string& pack) { xpackage_name = pack; }
 
   std::string package_name (void) const { return xpackage_name; }
 
   virtual void
-  mark_as_private_function (const std::string& cname = std::string ())
+  mark_as_private_function (const std::string& cname = "")
   {
     private_function = true;
     xdispatch_class = cname;
   }
 
   bool is_private_function (void) const { return private_function; }
 
   bool is_private_function_of_class (const std::string& nm) const
   { return private_function && xdispatch_class == nm; }
 
   virtual bool
-  is_anonymous_function_of_class (const std::string& = std::string ()) const
+  is_anonymous_function_of_class (const std::string& = "") const
   { return false; }
 
   std::string dir_name (void) const { return my_dir_name; }
 
   void stash_dir_name (const std::string& dir) { my_dir_name = dir; }
 
   void lock (void)
   {
@@ -177,17 +177,17 @@ public:
   virtual void accept (tree_walker&) { }
 
   virtual bool is_postfix_index_handled (char type) const
   { return (type == '(' || type == '{'); }
 
 protected:
 
   octave_function (const std::string& nm,
-                   const std::string& ds = std::string ())
+                   const std::string& ds = "")
     : relative (false), locked (false), private_function (false),
       xdispatch_class (), my_name (nm), my_dir_name (), doc (ds) { }
 
   // TRUE if this function was found from a relative path element.
   bool relative;
 
   // TRUE if this function is tagged so that it can't be cleared.
   bool locked;
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -163,40 +163,40 @@ bool octave_lazy_index::save_ascii (std:
 {
   return save_text_data (os, make_value (), value_save_tag, false, 0);
 }
 
 bool octave_lazy_index::load_ascii (std::istream& is)
 {
   bool dummy;
 
-  std::string nm = read_text_data (is, std::string (), dummy, value, 0);
+  std::string nm = read_text_data (is, "", dummy, value, 0);
 
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
   else
     index = value.index_vector ();
 
   return true;
 }
 
 
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
   return save_binary_data (os, make_value (), value_save_tag,
-                           std::string (), false, save_as_floats);
+                           "", false, save_as_floats);
 }
 
 bool octave_lazy_index::load_binary (std::istream& is, bool swap,
                                      oct_mach_info::float_format fmt)
 {
   bool dummy;
   std::string doc;
 
-  std::string nm = read_binary_data (is, swap, fmt, std::string (),
+  std::string nm = read_binary_data (is, swap, fmt, "",
                                      dummy, value, doc);
 
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
   else
     index = value.index_vector ();
 
   return true;
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -43,17 +43,17 @@ octave_mex_function : public octave_func
 {
 public:
 
   octave_mex_function (void)
     : mex_fcn_ptr (), exit_fcn_ptr (), have_fmex (), sh_lib (),
       t_checked (), system_fcn_file () { }
 
   octave_mex_function (void *fptr, bool fmex, const octave_shlib& shl,
-                       const std::string& nm = std::string ());
+                       const std::string& nm = "");
 
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -736,17 +736,17 @@ octave_struct::load_ascii (std::istream&
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
 
           // recurse to read cell elements
           std::string nm
-            = read_text_data (is, std::string (), dummy, t2, j);
+            = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
           m.setfield (nm, tcell);
         }
@@ -848,17 +848,17 @@ octave_struct::load_binary (std::istream
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (),
+          std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2);
 
           m.setfield (nm, tcell);
@@ -1375,17 +1375,17 @@ octave_scalar_struct::load_ascii (std::i
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
 
           // recurse to read cell elements
           std::string nm
-            = read_text_data (is, std::string (), dummy, t2, j);
+            = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
           m.setfield (nm, t2);
         }
 
       if (! is)
@@ -1449,17 +1449,17 @@ octave_scalar_struct::load_binary (std::
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (),
+          std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
           m.setfield (nm, t2);
         }
 
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -190,17 +190,17 @@ octave_value_typeinfo::do_register_type 
       return i;
 
   int len = types.numel ();
 
   if (i == len)
     {
       len *= 2;
 
-      types.resize (dim_vector (len, 1), std::string ());
+      types.resize (dim_vector (len, 1), "");
 
       vals.resize (dim_vector (len, 1), octave_value ());
 
       unary_ops.resize (dim_vector (octave_value::num_unary_ops, len), 0);
 
       non_const_unary_ops.resize
         (dim_vector (octave_value::num_unary_ops, len), 0);
 
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -187,17 +187,17 @@ public:
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
-    : num_types (0), types (dim_vector (init_tab_sz, 1), std::string ()),
+    : num_types (0), types (dim_vector (init_tab_sz, 1), ""),
       vals (dim_vector (init_tab_sz, 1)),
       unary_class_ops (dim_vector (octave_value::num_unary_ops, 1), 0),
       unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
       non_const_unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
       binary_class_ops (dim_vector (octave_value::num_binary_ops, 1), 0),
       binary_ops (dim_vector (octave_value::num_binary_ops, init_tab_sz, init_tab_sz), 0),
       compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), 0),
       compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -174,17 +174,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (symbol_table::scope_id sid, tree_parameter_list *pl,
    tree_parameter_list *rl, tree_statement_list *cl)
-  : octave_user_code (std::string (), std::string ()),
+  : octave_user_code ("", ""),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -61,17 +61,17 @@ public:
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
   virtual tree_statement_list *body (void) = 0;
 
 protected:
 
   octave_user_code (const std::string& nm,
-                    const std::string& ds = std::string ())
+                    const std::string& ds = "")
     : octave_function (nm, ds) { }
 
 private:
 
   // No copying!
 
   octave_user_code (const octave_user_code& f);
 
@@ -84,20 +84,20 @@ class
 octave_user_script : public octave_user_code
 {
 public:
 
   octave_user_script (void);
 
   octave_user_script (const std::string& fnm, const std::string& nm,
                       tree_statement_list *cmds,
-                      const std::string& ds = std::string ());
+                      const std::string& ds = "");
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      const std::string& ds = std::string ());
+                      const std::string& ds = "");
 
   ~octave_user_script (void);
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_script *user_script_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
@@ -261,17 +261,17 @@ public:
   {
     symbol_table::erase_subfunctions_in_scope (local_scope);
   }
 
   bool takes_varargs (void) const;
 
   bool takes_var_return (void) const;
 
-  void mark_as_private_function (const std::string& cname = std::string ())
+  void mark_as_private_function (const std::string& cname = "")
   {
     symbol_table::mark_subfunctions_in_scope_as_private (local_scope, cname);
 
     octave_function::mark_as_private_function (cname);
   }
 
   void lock_subfunctions (void);
 
@@ -300,17 +300,17 @@ public:
 
   bool is_inline_function (void) const { return inline_function; }
 
   void mark_as_anonymous_function (void) { anonymous_function = true; }
 
   bool is_anonymous_function (void) const { return anonymous_function; }
 
   bool is_anonymous_function_of_class
-  (const std::string& cname = std::string ()) const
+  (const std::string& cname = "") const
   {
     return anonymous_function
            ? (cname.empty ()
               ? (! dispatch_class ().empty ())
               : cname == dispatch_class ())
            : false;
   }
 
@@ -325,31 +325,31 @@ public:
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
   void mark_as_class_constructor (void) { class_constructor = legacy; }
 
   void mark_as_classdef_constructor (void) { class_constructor = classdef; }
 
-  bool is_class_constructor (const std::string& cname = std::string ()) const
+  bool is_class_constructor (const std::string& cname = "") const
   {
     return class_constructor == legacy
       ? (cname.empty () ? true : cname == dispatch_class ()) : false;
   }
 
-  bool is_classdef_constructor (const std::string& cname = std::string ()) const
+  bool is_classdef_constructor (const std::string& cname = "") const
   {
     return class_constructor == classdef
       ? (cname.empty () ? true : cname == dispatch_class ()) : false;
   }
 
   void mark_as_class_method (void) { class_method = true; }
 
-  bool is_class_method (const std::string& cname = std::string ()) const
+  bool is_class_method (const std::string& cname = "") const
   {
     return class_method
            ? (cname.empty () ? true : cname == dispatch_class ()) : false;
   }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1251,17 +1251,17 @@ public:
                                                  const octave_value& limit,
                                                  bool is_for_cmd_expr);
 
   const octave_base_value& get_rep (void) const { return *rep; }
 
   bool is_copy_of (const octave_value &val) const { return rep == val.rep; }
 
   void print_info (std::ostream& os,
-                   const std::string& prefix = std::string ()) const;
+                   const std::string& prefix = "") const;
 
   bool save_ascii (std::ostream& os) { return rep->save_ascii (os); }
 
   bool load_ascii (std::istream& is) { return rep->load_ascii (is); }
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
   { return rep->save_binary (os, save_as_floats); }
 
diff --git a/libinterp/octave-value/ovl.h b/libinterp/octave-value/ovl.h
--- a/libinterp/octave-value/ovl.h
+++ b/libinterp/octave-value/ovl.h
@@ -127,17 +127,17 @@ public:
   bool all_strings_p (void) const;
 
   bool all_scalars (void) const;
 
   bool any_cell (void) const;
 
   bool has_magic_colon (void) const;
 
-  string_vector make_argv (const std::string& = std::string ()) const;
+  string_vector make_argv (const std::string& = "") const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
   void make_storable_values (void);
 
   octave_value& xelem (octave_idx_type i) { return data.xelem (i); }
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -267,19 +267,19 @@ gripe_safe_source_exception (const std::
 
 // Execute commands from a file and catch potential exceptions in a consistent
 // way.  This function should be called anywhere we might parse and execute
 // commands from a file before before we have entered the main loop in
 // toplev.cc.
 
 static void
 safe_source_file (const std::string& file_name,
-                  const std::string& context = std::string (),
+                  const std::string& context = "",
                   bool verbose = false, bool require_file = true,
-                  const std::string& warn_for = std::string ())
+                  const std::string& warn_for = "")
 {
   try
     {
       source_file (file_name, context, verbose, require_file, warn_for);
     }
   catch (const octave_interrupt_exception&)
     {
       recover_from_exception ();
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -766,17 +766,17 @@ protected:
   octave_lexer& operator = (const octave_lexer&);
 };
 
 class
 octave_push_lexer : public octave_base_lexer
 {
 public:
 
-  octave_push_lexer (const std::string& input = std::string (),
+  octave_push_lexer (const std::string& input = "",
                      bool eof = false)
     : octave_base_lexer (), pflag (1)
   {
     append_input (input, eof);
   }
 
   bool is_push_lexer (void) const { return true; }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -98,27 +98,27 @@ extern OCTINTERP_API std::string lookup_
 
 extern OCTINTERP_API string_vector autoloaded_functions (void);
 
 extern OCTINTERP_API string_vector
 reverse_lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API octave_function *
 load_fcn_from_file (const std::string& file_name,
-                    const std::string& dir_name = std::string (),
-                    const std::string& dispatch_type = std::string (),
-                    const std::string& package_name = std::string (),
-                    const std::string& fcn_name = std::string (),
+                    const std::string& dir_name = "",
+                    const std::string& dispatch_type = "",
+                    const std::string& package_name = "",
+                    const std::string& fcn_name = "",
                     bool autoload = false);
 
 extern OCTINTERP_API void
 source_file (const std::string& file_name,
-             const std::string& context = std::string (),
+             const std::string& context = "",
              bool verbose = false, bool require_file = true,
-             const std::string& warn_for = std::string ());
+             const std::string& warn_for = "");
 
 extern OCTINTERP_API octave_value_list
 feval (const std::string& name,
        const octave_value_list& args = octave_value_list (),
        int nargout = 0);
 
 extern OCTINTERP_API octave_value_list
 feval (octave_function *fcn,
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -587,17 +587,17 @@ private:
 class tree_classdef : public tree_command
 {
 public:
 
   tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
                  tree_classdef_superclass_list *sc,
                  tree_classdef_body *b, octave_comment_list *lc,
                  octave_comment_list *tc,
-                 const std::string& pn = std::string (), int l = -1,
+                 const std::string& pn = "", int l = -1,
                  int c = -1)
     : tree_command (l, c), attr_list (a), id (i),
       supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
       pack_name (pn) { }
 
   ~tree_classdef (void)
   {
     delete attr_list;
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -72,10 +72,10 @@ octave_lvalue
 tree_expression::lvalue (void)
 {
   error ("invalid lvalue function called in expression");
 }
 
 std::string
 tree_expression::original_text (void) const
 {
-  return std::string ();
+  return "";
 }
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -35,17 +35,17 @@ class tree_expression;
 // How to print the code that the parse trees represent.
 
 class
 tree_print_code : public tree_walker
 {
 public:
 
   tree_print_code (std::ostream& os_arg,
-                   const std::string& pfx = std::string (),
+                   const std::string& pfx = "",
                    bool pr_orig_txt = true)
     : os (os_arg), prefix (pfx), nesting (),
       print_original_text (pr_orig_txt),
       curr_print_indent_level (0), beginning_of_line (true),
       suppress_newlines (0)
   {
     // For "none".
     nesting.push ('n');
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -60,17 +60,17 @@ public:
     unwind_protect_end,
     while_end,
   };
 
   token (int tv, int l = -1, int c = -1);
   token (int tv, bool is_keyword, int l = -1, int c = -1);
   token (int tv, const char *s, int l = -1, int c = -1);
   token (int tv, const std::string& s, int l = -1, int c = -1);
-  token (int tv, double d, const std::string& s = std::string (),
+  token (int tv, double d, const std::string& s = "",
          int l = -1, int c = -1);
   token (int tv, end_tok_type t, int l = -1, int c = -1);
   token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
   token (int tv, const std::string& mth, const std::string& cls,
          int l = -1, int c = -1);
 
   ~token (void);
 
diff --git a/libinterp/version.cc b/libinterp/version.cc
--- a/libinterp/version.cc
+++ b/libinterp/version.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 #include "defaults.h"
 #include "version.h"
 
 static std::string
-octave_warranty_statement (const std::string& extra_info = std::string ())
+octave_warranty_statement (const std::string& extra_info = "")
 {
   return "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\n\
 FITNESS FOR A PARTICULAR PURPOSE."
          + extra_info;
 }
 
 static std::string
 format_url (bool html, const std::string& url)
diff --git a/libinterp/version.in.h b/libinterp/version.in.h
--- a/libinterp/version.in.h
+++ b/libinterp/version.in.h
@@ -53,17 +53,17 @@ extern OCTINTERP_API std::string octave_
 extern OCTINTERP_API std::string octave_contrib_statement (bool html = false);
 
 extern OCTINTERP_API std::string octave_bugs_statement (bool html = false);
 
 extern OCTINTERP_API std::string octave_name_version_and_copyright (void);
 
 extern OCTINTERP_API std::string
 octave_name_version_copyright_copying_and_warranty
-  (bool html = false, const std::string& extra_info = std::string ());
+  (bool html = false, const std::string& extra_info = "");
 
 extern OCTINTERP_API std::string
 octave_name_version_copyright_copying_warranty_and_bugs
-  (bool html = false, const std::string& extra_info = std::string ());
+  (bool html = false, const std::string& extra_info = "");
 
 extern OCTINTERP_API std::string octave_startup_message (bool html = false);
 
 #endif
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -61,40 +61,40 @@ public:
   // Reset the seed.
   static void reset (void)
   {
     if (instance_ok ())
       instance->do_reset ();
   }
 
   // Return the current state.
-  static ColumnVector state (const std::string& d = std::string ())
+  static ColumnVector state (const std::string& d = "")
   {
     return instance_ok () ? instance->do_state (d) : ColumnVector ();
   }
 
   // Set the current state/
   static void state (const ColumnVector &s,
-                     const std::string& d = std::string ())
+                     const std::string& d = "")
   {
     if (instance_ok ())
       instance->do_state (s, d);
   }
 
   // Reset the current state/
   static void reset (const std::string& d)
   {
     if (instance_ok ())
       instance->do_reset (d);
   }
 
   // Return the current distribution.
   static std::string distribution (void)
   {
-    return instance_ok () ? instance->do_distribution () : std::string ();
+    return instance_ok () ? instance->do_distribution () : "";
   }
 
   // Set the current distribution.  May be either "uniform" (the
   // default), "normal", "exponential", "poisson", or "gamma".
   static void distribution (const std::string& d)
   {
     if (instance_ok ())
       instance->do_distribution (d);
diff --git a/liboctave/system/dir-ops.h b/liboctave/system/dir-ops.h
--- a/liboctave/system/dir-ops.h
+++ b/liboctave/system/dir-ops.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 class
 OCTAVE_API
 dir_entry
 {
 public:
 
-  dir_entry (const std::string& n = std::string ())
+  dir_entry (const std::string& n = "")
     : name (n), dir (0), fail (false), errmsg ()
   {
     if (! name.empty ())
       open ();
   }
 
   dir_entry (const dir_entry& d)
     : name (d.name), dir (d.dir), fail (d.fail), errmsg (d.errmsg) { }
@@ -53,27 +53,27 @@ public:
         errmsg = d.errmsg;
       }
 
     return *this;
   }
 
   ~dir_entry (void) { close (); }
 
-  bool open (const std::string& = std::string ());
+  bool open (const std::string& = "");
 
   string_vector read (void);
 
   void close (void);
 
   bool ok (void) const { return dir && ! fail; }
 
   operator bool () const { return ok (); }
 
-  std::string error (void) const { return ok () ? std::string () : errmsg; }
+  std::string error (void) const { return ok () ? "" : errmsg; }
 
 private:
 
   // Name of the directory.
   std::string name;
 
   // A pointer to the contents of the directory.  We use void here to
   // avoid possible conflicts with the way some systems declare the
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -397,17 +397,17 @@ octave_mkdir (const std::string& nm, mod
 {
   std::string msg;
   return octave_mkdir (nm, md, msg);
 }
 
 int
 octave_mkdir (const std::string& name, mode_t mode, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::mkdir (name.c_str (), mode);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
@@ -419,17 +419,17 @@ octave_mkfifo (const std::string& nm, mo
 {
   std::string msg;
   return octave_mkfifo (nm, md, msg);
 }
 
 int
 octave_mkfifo (const std::string& name, mode_t mode, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   // With gnulib we will always have mkfifo, but some systems like MinGW
   // don't have working mkfifo functions.  On those systems, mkfifo will
   // always return -1 and set errno.
 
   status = gnulib::mkfifo (name.c_str (), mode);
@@ -446,17 +446,17 @@ octave_link (const std::string& old_name
   std::string msg;
   return octave_link (old_name, new_name, msg);
 }
 
 int
 octave_link (const std::string& old_name,
              const std::string& new_name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::link (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
@@ -469,17 +469,17 @@ octave_symlink (const std::string& old_n
   std::string msg;
   return octave_symlink (old_name, new_name, msg);
 }
 
 int
 octave_symlink (const std::string& old_name,
                 const std::string& new_name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::symlink (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
@@ -494,17 +494,17 @@ octave_readlink (const std::string& path
 }
 
 int
 octave_readlink (const std::string& path, std::string& result,
                  std::string& msg)
 {
   int status = -1;
 
-  msg = std::string ();
+  msg = "";
 
   char buf[MAXPATHLEN+1];
 
   status = gnulib::readlink (path.c_str (), buf, MAXPATHLEN);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
   else
@@ -525,17 +525,17 @@ octave_rename (const std::string& from, 
 }
 
 int
 octave_rename (const std::string& from, const std::string& to,
                std::string& msg)
 {
   int status = -1;
 
-  msg = std::string ();
+  msg = "";
 
   status = gnulib::rename (from.c_str (), to.c_str ());
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
   return status;
 }
@@ -545,17 +545,17 @@ octave_rmdir (const std::string& name)
 {
   std::string msg;
   return octave_rmdir (name, msg);
 }
 
 int
 octave_rmdir (const std::string& name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::rmdir (name.c_str ());
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
@@ -569,17 +569,17 @@ octave_recursive_rmdir (const std::strin
 {
   std::string msg;
   return octave_recursive_rmdir (name, msg);
 }
 
 int
 octave_recursive_rmdir (const std::string& name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = 0;
 
   dir_entry dir (name);
 
   if (dir)
     {
       string_vector dirlist = dir.read ();
@@ -654,17 +654,17 @@ octave_unlink (const std::string& name)
 {
   std::string msg;
   return octave_unlink (name, msg);
 }
 
 int
 octave_unlink (const std::string& name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::unlink (name.c_str ());
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
@@ -677,17 +677,17 @@ octave_tempnam (const std::string& dir, 
   std::string msg;
   return octave_tempnam (dir, pfx, msg);
 }
 
 std::string
 octave_tempnam (const std::string& dir, const std::string& pfx,
                 std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   std::string retval;
 
   // get dir path to use for template
   std::string templatename;
   if (dir.empty ())
     templatename = octave_env::get_temp_directory ();
   else if (! file_stat (dir, false).is_dir ())
@@ -725,17 +725,17 @@ octave_canonicalize_file_name (const std
 {
   std::string msg;
   return octave_canonicalize_file_name (name, msg);
 }
 
 std::string
 octave_canonicalize_file_name (const std::string& name, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   std::string retval;
 
   char *tmp = gnulib::canonicalize_file_name (name.c_str ());
 
   if (tmp)
     {
       retval = tmp;
diff --git a/liboctave/system/file-ops.h b/liboctave/system/file-ops.h
--- a/liboctave/system/file-ops.h
+++ b/liboctave/system/file-ops.h
@@ -57,22 +57,22 @@ public:
 
   static char dir_sep_char (void)
   {
     return instance_ok () ? instance->xdir_sep_char : 0;
   }
 
   static std::string dir_sep_str (void)
   {
-    return instance_ok () ? instance->xdir_sep_str : std::string ();
+    return instance_ok () ? instance->xdir_sep_str : "";
   }
 
   static std::string dir_sep_chars (void)
   {
-    return instance_ok () ? instance->xdir_sep_chars : std::string ();
+    return instance_ok () ? instance->xdir_sep_chars : "";
   }
 
   static bool is_dir_sep (char c)
   {
     std::string tmp = dir_sep_chars ();
     return tmp.find (c) != std::string::npos;
   }
 
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -128,17 +128,17 @@ public:
   std::string mode_as_string (void) const;
 
   bool ok (void) const { return initialized && ! fail; }
 
   operator bool () const { return ok (); }
 
   bool exists (void) const { return ok (); }
 
-  std::string error (void) const { return ok () ? std::string () : errmsg; }
+  std::string error (void) const { return ok () ? "" : errmsg; }
 
   // Has the file referenced by this object been modified since TIME?
   bool is_newer (const octave_time& time) const { return fs_mtime > time; }
 
   // It's nice to be able to hide the file_stat object if we don't
   // really care about it.
   static int is_newer (const std::string&, const octave_time&);
 
@@ -196,17 +196,17 @@ protected:
 };
 
 class
 OCTAVE_API
 file_stat : public base_file_stat
 {
 public:
 
-  file_stat (const std::string& n = std::string (), bool fl = true)
+  file_stat (const std::string& n = "", bool fl = true)
     : base_file_stat (), file_name (n), follow_links (fl)
   {
     if (! file_name.empty ())
       update_internal ();
   }
 
   file_stat (const file_stat& fs)
     : base_file_stat (fs), file_name (fs.file_name),
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -99,17 +99,17 @@ octave_env::instance_ok (void)
 
   return retval;
 }
 
 std::string
 octave_env::polite_directory_format (const std::string& name)
 {
   return (instance_ok ())
-         ? instance->do_polite_directory_format (name) : std::string ();
+         ? instance->do_polite_directory_format (name) : "";
 }
 
 bool
 octave_env::absolute_pathname (const std::string& s)
 {
   return (instance_ok ())
          ? instance->do_absolute_pathname (s) : false;
 }
@@ -120,80 +120,80 @@ octave_env::rooted_relative_pathname (co
   return (instance_ok ())
          ? instance->do_rooted_relative_pathname (s) : false;
 }
 
 std::string
 octave_env::base_pathname (const std::string& s)
 {
   return (instance_ok ())
-         ? instance->do_base_pathname (s) : std::string ();
+         ? instance->do_base_pathname (s) : "";
 }
 
 std::string
 octave_env::make_absolute (const std::string& s, const std::string& dot_path)
 {
   return (instance_ok ())
-         ? instance->do_make_absolute (s, dot_path) : std::string ();
+         ? instance->do_make_absolute (s, dot_path) : "";
 }
 
 std::string
 octave_env::get_current_directory ()
 {
   return (instance_ok ())
-         ? instance->do_getcwd () : std::string ();
+         ? instance->do_getcwd () : "";
 }
 
 std::string
 octave_env::get_home_directory ()
 {
   return (instance_ok ())
-         ? instance->do_get_home_directory () : std::string ();
+         ? instance->do_get_home_directory () : "";
 }
 
 std::string
 octave_env::get_temp_directory ()
 {
   return (instance_ok ())
-         ? instance->do_get_temp_directory () : std::string ();
+         ? instance->do_get_temp_directory () : "";
 }
 
 std::string
 octave_env::get_program_name (void)
 {
   return (instance_ok ())
-         ? instance->prog_name : std::string ();
+         ? instance->prog_name : "";
 }
 
 std::string
 octave_env::get_program_invocation_name (void)
 {
   return (instance_ok ())
-         ? instance->prog_invocation_name : std::string ();
+         ? instance->prog_invocation_name : "";
 }
 
 void
 octave_env::set_program_name (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_program_name (s);
 }
 
 std::string
 octave_env::get_user_name (void)
 {
   return (instance_ok ())
-         ? instance->do_get_user_name () : std::string ();
+         ? instance->do_get_user_name () : "";
 }
 
 std::string
 octave_env::get_host_name (void)
 {
   return (instance_ok ())
-         ? instance->do_get_host_name () : std::string ();
+         ? instance->do_get_host_name () : "";
 }
 
 std::string
 octave_env::do_get_temp_directory (void) const
 {
   std::string tempd;
 
 #if defined (__MINGW32__) || defined (_MSC_VER)
@@ -233,17 +233,17 @@ octave_env::do_get_temp_directory (void)
 // FIXME: this leaves no way to distinguish between a
 // variable that is not set and one that is set to the empty string.
 // Is this a problem?
 
 std::string
 octave_env::getenv (const std::string& name)
 {
   return (instance_ok ())
-         ? instance->do_getenv (name) : std::string ();
+         ? instance->do_getenv (name) : "";
 }
 
 void
 octave_env::putenv (const std::string& name, const std::string& value)
 {
   octave_putenv (name, value);
 }
 
diff --git a/liboctave/system/oct-group.cc b/liboctave/system/oct-group.cc
--- a/liboctave/system/oct-group.cc
+++ b/liboctave/system/oct-group.cc
@@ -79,17 +79,17 @@ octave_group::getgrent (void)
   std::string msg;
   return getgrent (msg);
 }
 
 octave_group
 octave_group::getgrent (std::string& msg)
 {
 #if defined (HAVE_GETGRENT)
-  msg = std::string ();
+  msg = "";
   return octave_group (::getgrent (), msg);
 #else
   msg = NOT_SUPPORTED ("getgrent");
   return octave_group ();
 #endif
 }
 
 octave_group
@@ -98,17 +98,17 @@ octave_group::getgrgid (gid_t gid)
   std::string msg;
   return getgrgid (gid, msg);
 }
 
 octave_group
 octave_group::getgrgid (gid_t gid, std::string& msg)
 {
 #if defined (HAVE_GETGRGID)
-  msg = std::string ();
+  msg = "";
   return octave_group (::getgrgid (gid), msg);
 #else
   msg = NOT_SUPPORTED ("getgruid");
   return octave_group ();
 #endif
 }
 
 octave_group
@@ -117,17 +117,17 @@ octave_group::getgrnam (const std::strin
   std::string msg;
   return getgrnam (nm, msg);
 }
 
 octave_group
 octave_group::getgrnam (const std::string& nm, std::string& msg)
 {
 #if defined (HAVE_GETGRNAM)
-  msg = std::string ();
+  msg = "";
   return octave_group (::getgrnam (nm.c_str ()), msg);
 #else
   msg = NOT_SUPPORTED ("getgrnam");
   return octave_group ();
 #endif
 }
 
 int
@@ -136,17 +136,17 @@ octave_group::setgrent (void)
   std::string msg;
   return setgrent (msg);
 }
 
 int
 octave_group::setgrent (std::string& msg)
 {
 #if defined (HAVE_SETGRENT)
-  msg = std::string ();
+  msg = "";
   ::setgrent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("setgrent");
   return -1;
 #endif
 }
 
@@ -156,30 +156,30 @@ octave_group::endgrent (void)
   std::string msg;
   return endgrent (msg);
 }
 
 int
 octave_group::endgrent (std::string& msg)
 {
 #if defined (HAVE_ENDGRENT)
-  msg = std::string ();
+  msg = "";
   ::endgrent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("endgrent");
   return -1;
 #endif
 }
 
 octave_group::octave_group (void *p, std::string& msg)
   : gr_name (), gr_passwd (), gr_gid (0), gr_mem (), valid (false)
 {
 #if defined (HAVE_GRP_H)
-  msg = std::string ();
+  msg = "";
 
   if (p)
     {
       struct group *gr = static_cast<struct group *> (p);
 
       gr_name = gr->gr_name;
 
 #if defined (HAVE_GR_PASSWD)
diff --git a/liboctave/system/oct-passwd.cc b/liboctave/system/oct-passwd.cc
--- a/liboctave/system/oct-passwd.cc
+++ b/liboctave/system/oct-passwd.cc
@@ -105,17 +105,17 @@ octave_passwd::getpwent (void)
   std::string msg;
   return getpwent (msg);
 }
 
 octave_passwd
 octave_passwd::getpwent (std::string& msg)
 {
 #if defined HAVE_GETPWENT
-  msg = std::string ();
+  msg = "";
   return octave_passwd (::getpwent (), msg);
 #else
   msg = NOT_SUPPORTED ("getpwent");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
@@ -124,17 +124,17 @@ octave_passwd::getpwuid (uid_t uid)
   std::string msg;
   return getpwuid (uid, msg);
 }
 
 octave_passwd
 octave_passwd::getpwuid (uid_t uid, std::string& msg)
 {
 #if defined (HAVE_GETPWUID)
-  msg = std::string ();
+  msg = "";
   return octave_passwd (::getpwuid (uid), msg);
 #else
   msg = NOT_SUPPORTED ("getpwuid");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
@@ -143,17 +143,17 @@ octave_passwd::getpwnam (const std::stri
   std::string msg;
   return getpwnam (nm, msg);
 }
 
 octave_passwd
 octave_passwd::getpwnam (const std::string& nm, std::string& msg)
 {
 #if defined (HAVE_GETPWNAM)
-  msg = std::string ();
+  msg = "";
   return octave_passwd (::getpwnam (nm.c_str ()), msg);
 #else
   msg = NOT_SUPPORTED ("getpwnam");
   return octave_passwd ();
 #endif
 }
 
 int
@@ -162,17 +162,17 @@ octave_passwd::setpwent (void)
   std::string msg;
   return setpwent (msg);
 }
 
 int
 octave_passwd::setpwent (std::string& msg)
 {
 #if defined (HAVE_SETPWENT)
-  msg = std::string ();
+  msg = "";
   ::setpwent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("setpwent");
   return -1;
 #endif
 }
 
@@ -182,31 +182,31 @@ octave_passwd::endpwent (void)
   std::string msg;
   return endpwent (msg);
 }
 
 int
 octave_passwd::endpwent (std::string& msg)
 {
 #if defined (HAVE_ENDPWENT)
-  msg = std::string ();
+  msg = "";
   ::endpwent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("endpwent");
   return -1;
 #endif
 }
 
 octave_passwd::octave_passwd (void *p, std::string& msg)
   : pw_name (), pw_passwd (), pw_uid (0), pw_gid (0), pw_gecos (),
     pw_dir (), pw_shell (), valid (false)
 {
 #if defined (HAVE_PWD_H)
-  msg = std::string ();
+  msg = "";
 
   if (p)
     {
       struct passwd *pw = static_cast<struct passwd *> (p);
 
       pw_name = pw->pw_name;
       pw_passwd = pw->pw_passwd;
       pw_uid = pw->pw_uid;
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -52,17 +52,17 @@ octave_syscalls::dup2 (int old_fd, int n
 {
   std::string msg;
   return dup2 (old_fd, new_fd, msg);
 }
 
 int
 octave_syscalls::dup2 (int old_fd, int new_fd, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
 #if defined (HAVE_DUP2)
   status = gnulib::dup2 (old_fd, new_fd);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
@@ -79,17 +79,17 @@ octave_syscalls::execvp (const std::stri
   std::string msg;
   return execvp (file, argv, msg);
 }
 
 int
 octave_syscalls::execvp (const std::string& file, const string_vector& args,
                          std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
 #if defined (HAVE_EXECVP)
   char **argv = args.c_str_vec ();
 
   status = ::execvp (file.c_str (), argv);
 
@@ -224,17 +224,17 @@ octave_syscalls::pipe (int *fildes)
 {
   std::string msg;
   return pipe (fildes, msg);
 }
 
 int
 octave_syscalls::pipe (int *fildes, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
 #if defined (HAVE_PIPE)
   status = ::pipe (fildes);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
@@ -252,17 +252,17 @@ octave_syscalls::waitpid (pid_t pid, int
   return waitpid (pid, status, options, msg);
 }
 
 pid_t
 octave_syscalls::waitpid (pid_t pid, int *status, int options,
                           std::string& msg)
 {
   pid_t retval = -1;
-  msg = std::string ();
+  msg = "";
 
 #if defined (HAVE_WAITPID)
   retval = ::octave_waitpid (pid, status, options);
 
   if (retval < 0)
     msg = gnulib::strerror (errno);
 #else
   msg = NOT_SUPPORTED ("waitpid");
@@ -276,17 +276,17 @@ octave_syscalls::kill (pid_t pid, int si
 {
   std::string msg;
   return kill (pid, sig, msg);
 }
 
 int
 octave_syscalls::kill (pid_t pid, int sig, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
 #if defined (HAVE_KILL)
   status = ::kill (pid, sig);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
@@ -400,17 +400,17 @@ octave_fcntl (int fd, int cmd, long arg)
 {
   std::string msg;
   return octave_fcntl (fd, cmd, arg, msg);
 }
 
 int
 octave_fcntl (int fd, int cmd, long arg, std::string& msg)
 {
-  msg = std::string ();
+  msg = "";
 
   int status = -1;
 
   status = gnulib::fcntl (fd, cmd, arg);
 
   if (status < 0)
     msg = gnulib::strerror (errno);
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -913,17 +913,17 @@ default_command_editor::do_get_line_buff
 {
   return "";
 }
 
 std::string
 default_command_editor::do_get_current_line (void) const
 {
   // FIXME
-  return std::string ();
+  return "";
 }
 
 void
 default_command_editor::do_replace_line (const std::string&, bool)
 {
   // FIXME
 }
 
@@ -1156,17 +1156,17 @@ command_editor::set_screen_size (int ht,
   if (instance_ok ())
     instance->do_set_screen_size (ht, wd);
 }
 
 std::string
 command_editor::decode_prompt_string (const std::string& s)
 {
   return (instance_ok ())
-         ? instance->do_decode_prompt_string (s) : std::string ();
+         ? instance->do_decode_prompt_string (s) : "";
 }
 
 int
 command_editor::current_command_number (void)
 {
   return (instance_ok ())
          ? instance->command_number : 0;
 }
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -154,17 +154,17 @@ public:
   static void remove_pre_input_hook (pre_input_hook_fcn f);
 
   static void add_event_hook (event_hook_fcn f);
 
   static void remove_event_hook (event_hook_fcn f);
 
   static void run_event_hooks (void);
 
-  static void read_init_file (const std::string& file = std::string ());
+  static void read_init_file (const std::string& file = "");
 
   static void re_read_init_file (void);
 
   static bool filename_completion_desired (bool);
 
   static bool filename_quoting_desired (bool);
 
   static bool prefer_env_winsize (bool);
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -559,31 +559,31 @@ command_history::set_file (const std::st
       instance->do_set_file (f);
     }
 }
 
 std::string
 command_history::file (void)
 {
   return (instance_ok ())
-         ? instance->do_file () : std::string ();
+         ? instance->do_file () : "";
 }
 
 void
 command_history::process_histcontrol (const std::string& control_arg)
 {
   if (instance_ok ())
     instance->do_process_histcontrol (control_arg);
 }
 
 std::string
 command_history::histcontrol (void)
 {
   return (instance_ok ())
-         ? instance->do_histcontrol () : std::string ();
+         ? instance->do_histcontrol () : "";
 }
 
 void
 command_history::set_size (int n)
 {
   if (instance_ok ())
     instance->do_set_size (n);
 }
@@ -755,17 +755,17 @@ command_history::list (int limit, bool n
   return (instance_ok ())
          ? instance->do_list (limit, number_lines) : string_vector ();
 }
 
 std::string
 command_history::get_entry (int n)
 {
   return (instance_ok ())
-         ? instance->do_get_entry (n) : std::string ();
+         ? instance->do_get_entry (n) : "";
 }
 
 void
 command_history::replace_entry (int which, const std::string& line)
 {
   if (instance_ok ())
     instance->do_replace_entry (which, line);
 }
@@ -987,17 +987,17 @@ string_vector
 command_history::do_list (int, bool) const
 {
   return string_vector ();
 }
 
 std::string
 command_history::do_get_entry (int) const
 {
-  return std::string ();
+  return "";
 }
 
 void
 command_history::do_replace_entry (int, const std::string&)
 {
 }
 
 void
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -94,29 +94,29 @@ public:
 
   static void read (const std::string&, bool = true);
 
   static void read_range (int = -1, int = -1, bool = true);
 
   static void read_range (const std::string&, int = -1, int = -1,
                           bool = true);
 
-  static void write (const std::string& = std::string ());
+  static void write (const std::string& = "");
 
-  static void append (const std::string& = std::string ());
+  static void append (const std::string& = "");
 
-  static void truncate_file (const std::string& = std::string (), int = -1);
+  static void truncate_file (const std::string& = "", int = -1);
 
   static string_vector list (int = -1, bool = false);
 
   static std::string get_entry (int);
 
   static void replace_entry (int, const std::string&);
 
-  static void clean_up_and_save (const std::string& = std::string (), int = -1);
+  static void clean_up_and_save (const std::string& = "", int = -1);
 
 private:
 
   // No copying!
 
   command_history (const command_history&);
 
   command_history& operator = (const command_history&);
@@ -137,17 +137,17 @@ protected:
   // necessary, and make instance point to the new class.
 
   virtual void do_set_file (const std::string&);
 
   virtual std::string do_file (void);
 
   virtual void do_process_histcontrol (const std::string&);
 
-  virtual std::string do_histcontrol (void) const { return std::string (); }
+  virtual std::string do_histcontrol (void) const { return ""; }
 
   virtual void do_initialize (bool, const std::string&, int,
                               const std::string&);
 
   virtual bool do_is_initialized (void) const;
 
   virtual void do_set_size (int);
 
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -611,31 +611,31 @@ kpse_readable_file (const std::string& n
       ret = kpse_truncate_filename (name);
 
       /* Perhaps some other error will occur with the truncated name,
          so let's call access again.  */
 
       if (! READABLE (ret, st))
         {
           /* Failed.  */
-          ret = std::string ();
+          ret = "";
         }
 #endif /* ENAMETOOLONG */
 
     }
   else
     {
       /* Some other error.  */
       if (errno == EACCES)
         {
           /* Maybe warn them if permissions are bad.  */
           perror (name.c_str ());
         }
 
-      ret = std::string ();
+      ret = "";
     }
 
   return ret;
 }
 
 /* Sorry this is such a system-dependent mess, but I can't see any way
    to usefully generalize.  */
 
@@ -932,17 +932,17 @@ search (const std::string& path, const s
    In any case, return the complete filename if found, otherwise NULL.  */
 
 static std::string
 kpse_path_search (const std::string& path, const std::string& name,
                   bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
-  return ret_list.empty () ? std::string () : ret_list[0];
+  return ret_list.empty () ? "" : ret_list[0];
 }
 
 /* Search all elements of PATH for files named NAME.  Not sure if it's
    right to assert 'must_exist' here, but it suffices now.  */
 
 /* Like 'kpse_path_search' with MUST_EXIST true, but return a list of
    all the filenames (or NULL if none), instead of taking the first.  */
 
@@ -1152,17 +1152,17 @@ find_first_of (const std::string& path, 
    Return the first one found.  */
 
 static std::string
 kpse_path_find_first_of (const std::string& path, const string_vector& names,
                          bool must_exist)
 {
   string_vector ret_list = find_first_of (path, names, must_exist, false);
 
-  return ret_list.empty () ? std::string () : ret_list[0];
+  return ret_list.empty () ? "" : ret_list[0];
 }
 
 /* Search each element of PATH for each element of NAMES and return a
    list containing everything found, in the order found.  */
 
 /* Like 'kpse_path_find_first_of' with MUST_EXIST true, but return a
    list of all the filenames (or NULL if none), instead of taking the
    first.  */
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -68,17 +68,17 @@ public:
     if (nd == 0)
       {
         nd  = nd_arg;
         dim = dim_arg;
       }
   }
 
   // Name of variable being indexed.  eye(2)(1,1) gives "<unknown>".
-  void set_var (const std::string& var_arg = std::string ())
+  void set_var (const std::string& var_arg = "")
   {
     var = var_arg;
   }
 
 private:
 
   // Value of invalid index.
   std::string index;
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -114,30 +114,30 @@ dir_path::all_directories (void)
     }
 
   return retval;
 }
 
 std::string
 dir_path::find_first (const std::string& nm)
 {
-  return initialized ? kpse_path_search (p, nm, true) : std::string ();
+  return initialized ? kpse_path_search (p, nm, true) : "";
 }
 
 string_vector
 dir_path::find_all (const std::string& nm)
 {
   return initialized ? kpse_all_path_search (p, nm) : string_vector ();
 }
 
 std::string
 dir_path::find_first_of (const string_vector& names)
 {
   return initialized
-         ? kpse_path_find_first_of (p, names, true) : std::string ();
+         ? kpse_path_find_first_of (p, names, true) : "";
 }
 
 string_vector
 dir_path::find_all_first_of (const string_vector& names)
 {
   return initialized
          ? kpse_all_path_find_first_of (p, names) : string_vector ();
 }
diff --git a/liboctave/util/pathsearch.h b/liboctave/util/pathsearch.h
--- a/liboctave/util/pathsearch.h
+++ b/liboctave/util/pathsearch.h
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 class
 OCTAVE_API
 dir_path
 {
 public:
 
-  dir_path (const std::string& s = std::string (),
-            const std::string& d = std::string ())
+  dir_path (const std::string& s = "",
+            const std::string& d = "")
     : p_orig (s), p_default (d), initialized (false), p (), pv ()
   {
     if (! p_orig.empty ())
       init ();
   }
 
   dir_path (const dir_path& dp)
     : p_orig (dp.p_orig), p_default (dp.p_default),
@@ -141,17 +141,17 @@ private:
         {
           instance->xpath_sep_char = c;
           instance->xpath_sep_str = std::string (1, c);
         }
     }
 
     static std::string path_sep_str (void)
     {
-      return instance_ok () ? instance->xpath_sep_str : std::string ();
+      return instance_ok () ? instance->xpath_sep_str : "";
     }
 
   private:
 
     static static_members *instance;
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -83,17 +83,17 @@ public:
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
-  void resize (octave_idx_type n, const std::string& rfv = std::string ())
+  void resize (octave_idx_type n, const std::string& rfv = "")
   {
     Array<std::string>::resize (dim_vector (n, 1), rfv);
   }
 
   std::string& operator[] (octave_idx_type i)
   { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const
@@ -102,20 +102,20 @@ public:
   string_vector& sort (bool make_uniq = false);
 
   string_vector& uniq (void);
 
   string_vector& append (const std::string& s);
 
   string_vector& append (const string_vector& sv);
 
-  std::string join (const std::string& sep = std::string ()) const;
+  std::string join (const std::string& sep = "") const;
 
   char **c_str_vec (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
   std::ostream&
   list_in_columns (std::ostream&, int width = 0,
-                   const std::string& prefix = std::string ()) const;
+                   const std::string& prefix = "") const;
 };
 
 #endif
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -122,17 +122,17 @@ public:
 
   virtual string_vector list (void) { return string_vector (); }
 
   virtual void get_fileinfo (const std::string& /* filename */,
                              double& /* filesize */,
                              time_t& /* filetime */,
                              bool& /* fileisdir */) { }
 
-  virtual std::string pwd (void) { return std::string (); }
+  virtual std::string pwd (void) { return ""; }
 
   virtual void http_get (const Array<std::string>& /* param */) { }
 
   virtual void http_post (const Array<std::string>& /* param */) { }
 
   virtual void http_action (const Array<std::string>& /* param */,
                             const std::string& /* action */) { }
 
