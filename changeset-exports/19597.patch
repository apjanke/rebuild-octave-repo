# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1421767794 18000
#      Tue Jan 20 10:29:54 2015 -0500
# Node ID db92e7e28e1fd3f18e0f5cf6046a722b041cb21d
# Parent  0e1f5a750d00dff0e13cc782b293e413f64b4f0a
strip trailing whitespace from most source files

* NEWS, doc/interpreter/contributors.in, doc/interpreter/func.txi,
doc/interpreter/genpropdoc.m, doc/interpreter/octave_logo.eps,
doc/interpreter/plot.txi, doc/interpreter/stmt.txi,
examples/data/Makefile.am, libinterp/corefcn/data.cc,
libinterp/corefcn/debug.cc, libinterp/corefcn/error.cc,
libinterp/corefcn/file-io.cc, libinterp/corefcn/gl-render.cc,
libinterp/corefcn/graphics.cc, libinterp/corefcn/graphics.in.h,
libinterp/corefcn/load-path.cc, libinterp/corefcn/pr-output.cc,
libinterp/corefcn/pt-jit.cc, libinterp/corefcn/strfind.cc,
libinterp/corefcn/toplev.cc, libinterp/corefcn/toplev.h,
libinterp/corefcn/urlwrite.cc, libinterp/corefcn/variables.cc,
libinterp/octave-value/ov-classdef.cc,
libinterp/octave-value/ov-classdef.h, libinterp/octave.cc,
libinterp/parse-tree/lex.h, libinterp/parse-tree/oct-parse.in.yy,
libinterp/parse-tree/pt-classdef.h, liboctave/system/file-ops.cc,
liboctave/system/oct-env.cc, m4/acinclude.m4,
scripts/deprecated/finite.m, scripts/deprecated/fmod.m,
scripts/deprecated/fnmatch.m, scripts/deprecated/luinc.m,
scripts/deprecated/octave_tmp_file_name.m, scripts/deprecated/syl.m,
scripts/deprecated/usage.m, scripts/general/inputParser.m,
scripts/general/interp1.m, scripts/general/interp2.m,
scripts/general/interp3.m, scripts/general/isequal.m,
scripts/general/private/__isequal__.m, scripts/geometry/voronoi.m,
scripts/image/image.m, scripts/image/imshow.m,
scripts/image/ind2rgb.m, scripts/linear-algebra/bandwidth.m,
scripts/linear-algebra/isbanded.m, scripts/miscellaneous/bzip2.m,
scripts/miscellaneous/cast.m, scripts/miscellaneous/copyfile.m,
scripts/miscellaneous/delete.m, scripts/miscellaneous/fullfile.m,
scripts/miscellaneous/getappdata.m, scripts/miscellaneous/gunzip.m,
scripts/miscellaneous/isappdata.m, scripts/miscellaneous/ls.m,
scripts/miscellaneous/mex.m, scripts/miscellaneous/movefile.m,
scripts/miscellaneous/orderfields.m, scripts/miscellaneous/recycle.m,
scripts/miscellaneous/rmappdata.m, scripts/miscellaneous/setfield.m,
scripts/miscellaneous/symvar.m, scripts/miscellaneous/tar.m,
scripts/miscellaneous/tmpnam.m, scripts/miscellaneous/unpack.m,
scripts/miscellaneous/ver.m, scripts/miscellaneous/what.m,
scripts/miscellaneous/xor.m, scripts/miscellaneous/zip.m,
scripts/optimization/fminbnd.m, scripts/optimization/sqp.m,
scripts/path/private/getsavepath.m, scripts/path/savepath.m,
scripts/pkg/pkg.m, scripts/pkg/private/installed_packages.m,
scripts/plot/draw/plotyy.m, scripts/plot/draw/polar.m,
scripts/plot/draw/private/__quiver__.m,
scripts/plot/draw/private/__scatter__.m,
scripts/plot/draw/private/__stem__.m, scripts/plot/draw/surface.m,
scripts/plot/draw/surfnorm.m, scripts/plot/util/copyobj.m,
scripts/plot/util/hgload.m, scripts/plot/util/hgsave.m,
scripts/plot/util/isprop.m, scripts/plot/util/linkprop.m,
scripts/plot/util/private/__go_draw_axes__.m, scripts/set/setdiff.m,
scripts/set/union.m, scripts/signal/periodogram.m,
scripts/sparse/eigs.m, scripts/sparse/ilu.m, scripts/sparse/qmr.m,
scripts/sparse/sprand.m, scripts/sparse/sprandn.m,
scripts/specfun/beta.m, scripts/specfun/ellipke.m,
scripts/specfun/isprime.m, scripts/statistics/base/lscov.m,
scripts/testfun/__run_test_suite__.m, scripts/testfun/test.m:
Strip trailing whitespace.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -17,17 +17,17 @@ Summary of important user-visible change
 
       audiodevinfo  audioread
       audioinfo     audiorecorder
       audioplayer   audiowrite
 
  ** Other new classes in Octave 4.2:
 
       audioplayer    inputParser
-      audiorecorder  
+      audiorecorder
 
  ** Optional stricter Matlab compatibility for ranges, diagonal matrices,
     and permutation matrices.
 
     Octave has internal optimizations which use space-efficient storage
     for the three data types above.  Three new functions have been added
     which control whether the optimizations are used (default), or whether
     the data types are stored as full matrices.
@@ -148,17 +148,17 @@ Summary of important user-visible change
       unsetenv
       zoom
 
  ** inline() scheduled for eventual deprecation by Matlab
 
     Functions created through the use of inline are scheduled for deprecation
     by Matlab.  When this occurs Octave will continue to support inline
     functions for an indeterminate amount of time before also removing support.
-    All new code should use anonymous functions in place of inline functions. 
+    All new code should use anonymous functions in place of inline functions.
 
  ** Deprecated functions.
 
     The following functions have been deprecated in Octave 4.2 and will
     be removed from Octave 4.6 (or whatever version is the second major
     release after 4.2):
 
       Function             | Replacement
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -80,17 +80,17 @@ Torsten Finke
 Colin Foster
 Jose Daniel Munoz Frias
 Brad Froehle
 Castor Fu
 Eduardo Gallestey
 Walter Gautschi
 Klaus Gebhardt
 Driss Ghaddab
-Eugenio Gianniti 
+Eugenio Gianniti
 Nicolo Giorgetti
 Arun Giridhar
 Michael D. Godfrey
 Michael Goffioul
 Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1399,17 +1399,17 @@ quad (@@sin, 0, pi)
 @end example
 
 @noindent
 rather than using the anonymous function @code{@@(x) sin (x)}.  There are many
 operators which have functional equivalents that may be better choices than an
 anonymous function.  Instead of writing
 
 @example
-f = @@(x, y) x + y 
+f = @@(x, y) x + y
 @end example
 
 @noindent
 this should be coded as
 
 @example
 f = @@plus
 @end example
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -1,302 +1,302 @@
 ## Copyright (C) 2014 Pantxo Diribarne
-## 
+##
 ## This program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this program.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## -*- texinfo -*- 
+## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} genpropdoc (@var{OBJNAME}, @var{FILENAME})
 ##
 ## Print FILENAME texinfo source file associated to OBJNAME objects.
 ## This function is meant to be run for generating octave
 ## documentation (see doc/interpreter/graphics_properties.mk).
 ##
 ## All the hard coded documentation is written in getdoc
 ## function.  See the comments in getdoc bellow for instruction on how
 ## to document a graphics property.
-## 
+##
 ## @seealso{}
 ## @end deftypefn
 
-function genpropdoc (objname, fname)  
+function genpropdoc (objname, fname)
   objnames = {"root", "figure", "axes", "line", ...
               "text", "image", "patch", "surface"};
 
   ## Base properties
   base = getstructure ("base");
 
   ## Object properties
   if (any (strcmp (objname, objnames)))
     obj = getstructure (objname, base);
   else
     error ("genpropdoc: unknown object %s", objname);
   endif
 
   ## Docstring
   str = printdoc (objname, obj);
-  
+
   fid = fopen (fname,  "w+");
   if (fid < 0)
     error ("genpropdoc: couldn't open %s.", fname);
   endif
-  
+
   fprintf (fid, str);
   fclose (fid);
 endfunction
 
 function s = getdoc (objname, field, base)
   ## Properties are represented by a struct with fields :
-  ## 
+  ##
   ## -"doc": string to be printed verbatim after being expanded
   ##   through expand_doc function.  Special keywords are:
   ##   "__objname__" further replaced by the current object name;
   ##   "__prop__"  further replaced by the current property name;
   ##   "__modemsg__"  further replaced by a message explaining that
   ##   the propmode will be toggled to "manual".
   ##   You may also cross reference properties using the label format
   ##   OBJNAMEPROPERTY, e.g, "@xref{XREFaxescolor, , axes color
-  ##   property}." 
-  ## 
+  ##   property}."
+  ##
   ## -"valid": string that describes valid values for the
   ##   current property.  Use "packopt" function to join options with
   ##   " | " separator and "markdef" to mark default among valid
-  ##   values between curly braces. 
+  ##   values between curly braces.
   ##   If not provided, valid values for radio properties are
   ##   automatically retrieved using set function.
-  ## 
+  ##
   ## -"default": string.  If not provided the default value is
   ##   automatically retrieved using get function.
   ##
   ## -"printdefault": a boolean (def. true) that specifies whether the
   ## default value should be printed.  It is useful for properties
-  ## like root "screendepth" that default to screen dependant values. 
+  ## like root "screendepth" that default to screen dependant values.
 
   packopt = @(c) strjoin (c, ' | ');
   markdef = @(s) ["@{" s "@}"];
-  
-  ## Some generic templates: 
+
+  ## Some generic templates:
   valid_color = "colorspec";
   valid_handle = "graphics handle";
   valid_string = "string";
   valid_fcn = packopt ({"string", "function handle"});
   valid_cellstring = packopt ({"string", "cell array of strings"});
   valid_2elvec = "two elements vector";
   valid_3elvec = "three elements vector";
   valid_4elvec = "four elements vector";
   valid_vecmat = packopt ({"vector", "matrix"});
   valid_scalmat = packopt ({"scalar", "matrix"});
-  
+
   doc_notimpl =  "%s is not yet implemented for __objname__ \
 objects.  __prop__ is unused.";
   doc_unused =  "__prop__ is unused.";
 
 
   ## Initialize structure
   if (isfield (base, field))
     s = base.(field);
   else
     s = struct ("valid", "", "default", "", "doc", "", ...
                 "printdefault", true);
   endif
 
   ## Base properties: write generic documentation as it will, by
   ## default, be included in the list of each graphics object.
   ## If a given graphics object interprets the property differently
-  ## than most others, the doc will have to be rewritten for this object. 
+  ## than most others, the doc will have to be rewritten for this object.
   if (strcmp (objname, "base"))
     switch field
       case "beingdeleted"
       case "busyaction"
       case "buttondownfcn"
         s.valid = valid_fcn;
       case "children"
         s.doc = "Graphics handles of the __objname__'s children.";
         s.valid = "vector of graphics handles";
-        
+
       case "clipping"
         s.doc = "If __prop__ is @qcode{\"on\"}, the __objname__ is \
 clipped in its parent axes limits.";
-        
+
       case "createfcn"
         s.doc = "Callback functions to be executed right after \
 the __objname__ has been created.  Those functions have to be set by \
 default using e.g.  @code{set (0, \"default__objname__createfcn\", \
 'disp (\"__objname__ created!\")') }.";
         s.valid = valid_fcn;
-        
+
       case "deletefcn"
         s.doc = "Callback functions to be executed right before \
 the __objname__ is deleted.";
         s.valid = valid_fcn;
-        
+
       case "handlevisibility"
         s.doc = "If __prop__ is @qcode{\"off\"}, the __objname__'s \
 handle is not visible into its parent's children list.";
-        
+
       case "hittest"
       case "interruptible"
       case "parent"
         s.doc = "Handle of the parent graphics object.";
         s.valid = valid_handle;
-        
+
       case "selected"
       case "selectionhighlight"
       case "tag"
         s.valid = valid_string;
-        
+
       case "type"
         s.doc = "Class name of the graphics object.  __prop__ is \
 always @qcode{\"__objname__\"}";
         s.valid = valid_string;
         s.printdefault = false;
-        
+
       case "uicontextmenu"
       case "userdata"
       case "visible"
         s.doc = "If __prop__ is @qcode{\"off\"}, the __objname__ is \
 not rendered on screen.";
     endswitch
-    
-  ## Root properties: 
+
+  ## Root properties:
   elseif (strcmp (objname, "root"))
     switch field
       ## Overridden shared properties
       case {"beingdeleted", "busyaction", "buttondownfcn", ...
             "clipping", "createfcn", "deletefcn", "handlevisibility", ...
             "hittest", "interruptible", "selected", ...
             "selectionhighlight", "uicontextmenu", "visible"}
         s.doc = doc_unused;
-        
+
       case "parent"
         s.doc = "Root figure has no parent graphics object.  __prop__ \
 is always empty.";
-        
+
       ## Specific properties
       case "callbackobject"
         s.valid = valid_handle;
-        
+
       case "commandwindowsize"
       case "currentfigure"
         s.doc = "Graphics handle of the current figure.";
         s.valid = valid_handle;
-        
+
       case "diary"
         s.doc = "If __prop__ is @qcode{\"on\"}, the octave \
 command window session is saved to file.  @xref{XREFrootdiaryfile, , \
 diaryfile property}.";
         s.valid = valid_string;
-        
+
       case "diaryfile"
         s.doc = "The name of the diary file.  \
 @xref{XREFdiary, , diary function}.";
         s.valid = valid_string;
-        
+
       case "echo"
         s.doc = "Control whether octave displays commands executed \
 from scripts.  @xref{XREFecho, , echo function}.";
-        
+
       case "errormessage"
         s.doc = "The last error message octave raised.  \
 @xref{XREFlasterr, , lasterr function}.";
         s.valid = valid_string;
-        
+
       case "fixedwidthfontname"
         s.valid = valid_string;
-        
+
       case "format"
         s.doc = "This property is a wrapper around @code{format} \
 function.  @xref{XREFformat, , format function}.";
-        
+
       case "formatspacing"
         s.doc = "This property is a wrapper around @code{format} \
 function.  @xref{XREFformat, , format function}.";
-        
+
       case "language"
         s.valid = valid_string;
-        
+
       case "monitorpositions"
         s.valid = valid_4elvec;
-        
+
       case "pointerlocation"
         s.valid = valid_2elvec;
-        
+
       case "pointerwindow"
         s.valid = valid_handle;
-        
+
       case "recursionlimit"
         s.doc = "The maximum number of times a function can be \
 called recursively.  @xref{XREFmax_recursion_depth, , \
 max_recursion_depth function}.";
         s.valid = "double";
-        
+
       case "screendepth"
         s.valid = "double";
         s.printdefault = false;
-        
+
       case "screenpixelsperinch"
         s.valid = "double";
         s.printdefault = false;
-        
+
       case "screensize"
         s.valid = valid_4elvec;
         s.printdefault = false;
-        
+
       case "showhiddenhandles"
         s.doc = "If __prop__ is @qcode{\"on\"}, all graphics objects \
 handle are visible in their parents' children list, regardless of \
-the value of their @code{handlevisibility} property."; 
-        
+the value of their @code{handlevisibility} property.";
+
       case "units"
     endswitch
 
   ## Figure properties
   elseif (strcmp (objname, "figure"))
     switch field
       ## Overridden shared properties
       case "clipping"
         s.doc = doc_unused;
 
       ## Specific properties
       case "alphamap"
         s.doc = sprintf (doc_notimpl, "Transparency");
       case "closerequestfcn"
         s.valid = valid_fcn;
-        
+
       case "color"
         s.doc = "Color of the figure background.  @xref{Colors, , \
 colorspec}.";
         s.valid = valid_color;
-        
+
       case "colormap"
         s.doc = "A matrix containing the RGB color map for \
 the current axes.";
         s.valid = "N-by-3 matrix";
-        
+
       case "currentaxes"
         s.doc = "Handle to the graphics object of the current axes.";
         s.valid = valid_handle;
-        
+
       case "currentcharacter"
         s.doc = doc_unused;
-        
+
       case "currentobject"
         s.valid = valid_handle;
-        
+
       case "currentpoint"
         s.doc = "A 1-by-2 matrix which holds the coordinates of \
 the point over which the mouse pointer was when a mouse event \
 occurred.  The x and y coordinates are in units defined by the \
 figures @qcode{\"units\"} property and their origin is the lower \
 left corner of the plotting area.\
 \n\nEvents which set @qcode{\"currentpoint\"} are\n\
 @table @asis\n\
@@ -304,27 +304,27 @@ left corner of the plotting area.\
 always\n\
 @item A mouse button was released\n\
 only if the figures callback @qcode{\"windowbuttonupfcn\"} is defined\n\
 @item The pointer was moved while pressing mouse button (drag)\n\
  only if the figures callback @qcode{\"windowbuttonmotionfcn\"} is \
 defined \n\
 @end table";
         s.valid = valid_2elvec;
-        
+
       case "dockcontrols"
         s.doc = doc_unused;
-        
+
       case "doublebuffer"
       case "filename"
       case "integerhandle"
       case "inverthardcopy"
       case "keypressfcn"
         s.valid = valid_fcn;
-        
+
       case "keyreleasefcn"
         s.doc = "With @code{keypressfcn}, the keyboard callback \
 functions.  These callback functions get called when a key is \
 pressed/released respectively.  The functions are called with two \
 input arguments.  The first argument holds the handle of the calling \
 figure.  The second argument holds the event structure which has the \
 following members:\n\
 @table @code\n\
@@ -332,200 +332,200 @@ following members:\n\
 The ASCII value of the key\n\
 @item Key:\n\
 lowercase value of the key\n\
 @item Modifier:\n\
 A cell array containing strings representing the modifiers pressed \
 with the key.\n\
 @end table";
         s.valid = valid_fcn;
-        
+
       case "menubar"
       case "mincolormap"
       case "name"
         s.doc = "Name to be displayed in the figure title bar.  If \
 __prop__ is empty, the title of the figure is \"figure\" followed \
 by the figure handle value.";
         s.valid = valid_string;
-        
+
       case "nextplot"
       case "numbertitle"
       case "outerposition"
         s.valid = valid_4elvec;
-        
+
       case "paperorientation"
       case "paperposition"
         s.doc = "Vector @qcode{[x0 y0 width height]} defining the \
 position of the figure (in @code{paperunits} units) in the printed \
-page.  __modemsg__."; 
+page.  __modemsg__.";
         s.valid = valid_4elvec;
-        
+
       case "paperpositionmode"
         s.doc = "If __prop__ is set to @qcode{\"auto\"}, the \
 @qcode{\"paperposition\"} property is automatically computed: the \
 printed figure will have the same size as on-screen figure and will \
-be centered in the output page."; 
+be centered in the output page.";
       case "papersize"
         s.doc = "Vector @qcode{[width height]} defining the size of the \
 printing paper.  Setting this property forces the @code{papertype} \
 property to be set to @qcode{\"<custom>\"}.";
         s.valid = valid_2elvec;
-        
+
       case "papertype"
         s.doc = "Name of the paper to be used for printed output.  \
 Setting __prop__ also changes @code{papersize} accordingly.";
-        
+
       case "paperunits"
         s.doc = "The unit used to compute the @code{paperposition} \
 property.";
-        
+
       case "pointer"
       case "pointershapecdata"
         s.doc = doc_unused;
-        
+
       case "pointershapehotspot"
         s.doc = doc_unused;
-        
+
       case "position"
         s.valid = valid_4elvec;
-        
+
       case "renderer"
       case "renderermode"
       case "resize"
       case "resizefcn"
         s.valid = valid_fcn;
-        
+
       case "selectiontype"
       case "toolbar"
       case "units"
         s.doc = "The unit used to compute the @code{position} and \
 @code{outerposition} properties.";
-      case "windowbuttondownfcn" 
+      case "windowbuttondownfcn"
         s.doc = "@xref{XREFfigurewindowbuttonupfcn, , \
 windowbuttonupfcn property}.";
         s.valid = valid_fcn;
-        
+
       case "windowbuttonmotionfcn"
         s.doc = "@xref{XREFfigurewindowbuttonupfcn, , \
 windowbuttonupfcn property}.";
         s.valid = valid_fcn;
-        
+
       case "windowbuttonupfcn"
         s.doc = "With @code{windowbuttondownfcn} and \
 @code{windowbuttonmotionfcn}, the mouse callback functions.  These \
 callback functions get called when the mouse button is pressed, \
 dragged, and released respectively.  When these callback functions \
 are called, the @code{currentpoint} property holds the current \
 coordinates of the cursor.";
         s.valid = valid_fcn;
-        
+
       case "windowkeypressfcn"
         s.valid = valid_fcn;
-        
+
       case "windowkeyreleasefcn"
         s.valid = valid_fcn;
-        
+
       case "windowscrollwheelfcn"
         s.valid = valid_fcn;
-        
+
       case "windowstyle"
       case "wvisual"
       case "wvisualmode"
       case "xdisplay"
       case "xvisual"
       case "xvisualmode"
       case "__graphics_toolkit__"
         s.doc = "The graphics toolkit that is used to render the \
 figure.  @xref{XREFavailable_graphics_toolkits, , \
 available_graphics_toolkits function}.";
     endswitch
-    
+
   ## Axes properties
   elseif (strcmp (objname, "axes"))
     switch field
       ## Overridden shared properties
       case "clipping"
         s.doc = doc_unused;
 
       ## Specific properties
       case "activepositionproperty"
       case "alim"
         s.doc = sprintf (doc_notimpl, "Transparency");
       case "alimmode"
       case "ambientlightcolor"
         s.doc = sprintf (doc_notimpl, "Light");
       case "box"
         s.doc = "Control wether the axes has a surrounding box.";
-        
+
       case "cameraposition"
         s.valid = valid_3elvec;
-        
+
       case "camerapositionmode"
       case "cameratarget"
         s.valid = valid_3elvec;
-        
+
       case "cameratargetmode"
       case "cameraupvector"
         s.valid = valid_3elvec;
-        
+
       case "cameraupvectormode"
       case "cameraviewangle"
         s.valid = "scalar";
-        
+
       case "cameraviewanglemode"
       case "clim"
         s.valid = valid_2elvec;
         s.doc = "Define the limits for the color axis of image \
 children.  __modemsg__.  @xref{XREFpcolor, , pcolor function}.";
-        
+
       case "climmode"
       case "color"
         s.doc = "Color of the axes background.  @xref{Colors, , \
 colorspec}.";
         s.valid = valid_color;
-        
+
       case "colororder"
         s.doc = "RGB values to be used by plot function for \
 automatic line coloring.";
         s.valid = "N-by-3 RGB matrix";
-        
+
       case "currentpoint"
         s.doc = "Matrix @qcode{[xf, yf, zf; xb, yb, zb]} which holds \
 the coordinates of the point over which the mouse pointer was when \
 the mouse button was pressed in axes data units.  If a mouse \
 callback function is defined, @code{currentpoint} holds the \
 pointer coordinates at the time the mouse button was pressed.  For \
 3D plots, the first row of the returned matrix specifies the point \
 nearest to the current camera position and the second rows the \
 furthest point.  The two points forms a line which is perpendicular \
 to the screen.";
         s.valid = "2-by-3 matrix";
-        
+
       case "dataaspectratio"
         s.doc = "Specify the relative height and width of the data \
 displayed in the axes.  Setting @code{dataaspectratio} to @samp{[1, \
 2]} causes the length of one unit as displayed on the y-axis to be \
 the same as the length of 2 units on the x-axis.  __modemsg__.";
         s.valid = valid_3elvec;
-        
+
       case "dataaspectratiomode"
       case "drawmode"
       case "fontangle"
       case "fontname"
         s.doc = "Name of the font to be used for axes annotations.";
         s.valid = valid_string;
-        
+
       case "fontsize"
         s.doc = "Size of the font to be used for axes annotations.  \
 @xref{XREFaxesfontunits, , fontunits property}.";
         s.valid = "scalar";
-        
+
       case "fontunits"
         s.doc = "Unit used to interpret @code{fontsize} property.";
-        
+
       case "fontweight"
       case "gridlinestyle"
       case "interpreter"
       case "layer"
       case "linestyleorder"
       case "linewidth"
       case "minorgridlinestyle"
       case "nextplot"
@@ -533,591 +533,591 @@ the same as the length of 2 units on the
         s.doc = "Specify the position of the plot, including titles, \
 axes and legend.  The four elements of the vector are the \
 coordinates of the lower left corner and width and height of the \
 plot, in units normalized to the width and height of the plot \
 window.  For example, @qcode{[0.2, 0.3, 0.4, 0.5]} sets the lower \
 left corner of the axes at @math{(0.2, 0.3)} and the width and \
 height to be 0.4 and 0.5 respectively.  @xref{XREFaxesposition, , position property}.";
         s.valid = valid_4elvec;
-        
+
       case "plotboxaspectratio"
       case "plotboxaspectratiomode"
       case "position"
         s.doc = "Specify the position of the plot, excluding titles, \
 axes and legend.  The four elements of the vector are the \
 coordinates of the lower left corner and width and height of the \
 plot, in units normalized to the width and height of the plot \
 window.  For example, @qcode{[0.2, 0.3, 0.4, 0.5]} sets the lower \
 left corner of the axes at @math{(0.2, 0.3)} and the width and \
 height to be 0.4 and 0.5 respectively.  @xref{XREFaxesouterposition, , \
-outerposition property}."; 
+outerposition property}.";
         s.valid = valid_4elvec;
-        
+
       case "projection"
       case "tickdir"
       case "tickdirmode"
       case "ticklength"
       case "tightinset"
       case "title"
         s.doc = "Graphics handle of the title text object.";
         s.valid = valid_handle;
-        
+
       case "units"
       case "view"
         s.doc = "Specify the view point for three-dimensional plots";
         s.valid = valid_2elvec;
-        
+
       case "xaxislocation"
       case "xcolor"
         s.doc = "Color of the x-axis.  @xref{Colors, , colorspec}.";
         s.valid = packopt ({markdef(valid_color), ...
                             "@qcode{\"none\"}"});
-        
+
       case "xdir"
       case "xgrid"
         s.doc = "Control wether major x grid lines are displayed.";
-        
+
       case "xlabel"
         s.doc = "Graphics handle of the x label text object.";
         s.valid = valid_handle;
-        
+
       case "xlim"
         s.doc = "Specify the limits for x-axis.  __modemsg__.  \
 @xref{XREFxlim, , xlim function}.";
         s.valid = valid_2elvec;
-        
+
       case "xlimmode"
       case "xminorgrid"
         s.doc = "Control wether minor x grid lines are displayed.";
-        
+
       case "xminortick"
       case "xscale"
       case "xtick"
         s.doc = "Position of x tick marks.  __modemsg__.";
         s.valid = "vector";
-        
+
       case "xticklabel"
         s.doc = "Labels of x tick marks.  __modemsg__.";
         s.valid = valid_cellstring;
-        
+
       case "xticklabelmode"
       case "xtickmode"
       case "yaxislocation"
       case "ycolor"
         s.doc = "Color of the y-axis.  @xref{Colors, , colorspec}.";
         s.valid = packopt ({markdef(valid_color), ...
                             "@qcode{\"none\"}"});
-        
+
       case "ydir"
       case "ygrid"
         s.doc = "Control wether major y grid lines are displayed.";
-        
+
       case "ylabel"
         s.doc = "Graphics handle of the y label text object.";
         s.valid = valid_handle;
-        
+
       case "ylim"
         s.doc = "Specify the limits for y-axis.  __modemsg__.  \
 @xref{XREFylim, , ylim function}.";
         s.valid = valid_2elvec;
-        
+
       case "ylimmode"
       case "yminorgrid"
         s.doc = "Control wether minor y grid lines are displayed.";
-        
+
       case "yminortick"
       case "yscale"
       case "ytick"
         s.doc = "Position of y tick marks.  __modemsg__.";
         s.valid = "vector";
-        
+
       case "yticklabel"
         s.doc = "Labels of y tick marks.  __modemsg__.";
         s.valid = valid_cellstring;
-        
+
       case "yticklabelmode"
       case "ytickmode"
       case "zcolor"
         s.doc = "Color of the z-axis.  @xref{Colors, , colorspec}.";
         s.valid = packopt ({markdef(valid_color), ...
                             "@qcode{\"none\"}"});
-        
+
       case "zdir"
       case "zgrid"
         s.doc = "Control wether major z grid lines are displayed.";
-        
+
       case "zlabel"
         s.doc = "Graphics handle of the z label text object.";
         s.valid = valid_handle;
-        
+
       case "zlim"
         s.doc = "Specify the limits for z-axis.  __modemsg__.  \
 @xref{XREFzlim, , zlim function}.";
         s.valid = valid_2elvec;
-        
+
       case "zlimmode"
       case "zminorgrid"
         s.doc = "Control wether minor z grid lines are displayed.";
-        
+
       case "zminortick"
       case "zscale"
       case "ztick"
         s.doc = "Position of z tick marks.  __modemsg__.";
         s.valid = "vector";
-        
+
       case "zticklabel"
         s.doc = "Labels of z tick marks.  __modemsg__.";
         s.valid = valid_cellstring;
-        
+
       case "zticklabelmode"
       case "ztickmode"
     endswitch
-    
+
   ## Line properties
   elseif (strcmp (objname, "line"))
     switch field
       ## Overridden shared properties
       case "children"
         s.doc = doc_unused;
-        
+
       ## Specific properties
       case "color"
         s.doc = "Color of the line object.  @xref{Colors, , \
 colorspec}.";
         s.valid = valid_color;
-        
+
       case "displayname"
         s.doc = "The text of the legend entry corresponding to this \
 line.";
         s.valid = valid_cellstring;
-        
+
       case "erasemode"
         s.doc = doc_unused;
-        
+
       case "interpreter"
       case "linestyle"
         s.doc = "@xref{Line Styles}.";
-        
+
       case "linewidth"
         s.doc = "Width in points of the line object.";
-        
+
       case "marker"
         s.doc = "The shape of the marker to be used.  @xref{Marker \
 Styles}.";
-        
+
       case "markeredgecolor"
         s.doc = "Color of the edge of the markers.  If set \
 @qcode{\"auto\"}, the markers edges have the same color as the line.  If \
 set @qcode{\"none\"}, the markers edges are not displayed.  This property \
 can also be set to any color.  @xref{Colors, , colorspec}.";
-        
+
       case "markerfacecolor"
         s.doc = "Color of the face of the markers.  If set \
 @qcode{\"auto\"}, the markers faces have the same color as the line.  If \
 set @qcode{\"none\"}, the markers faces are not displayed.  This property \
 can also be set to any color.  @xref{Colors, , colorspec}.";
-        
+
       case "markersize"
         s.doc = "Size of the markers  in points.";
         s.valid = "scalar";
-        
+
       case "xdata"
         s.doc = "Vector of x data to be plotted.";
         s.valid = "vector";
-        
+
       case "xdatasource"
         s.valid = valid_string;
         s.doc = "Name of the vector in the current base workspace \
 that should be used as x data.";
-        
+
       case "ydata"
         s.doc = "Vector of y data to be plotted.";
         s.valid = "vector";
-        
+
       case "ydatasource"
         s.valid = valid_string;
         s.doc = "Name of the vector in the current base workspace \
 that should be used as y data.";
-        
+
       case "zdata"
         s.doc = "Vector of z data to be plotted.";
         s.valid = "vector";
-        
+
       case "zdatasource"
         s.valid = valid_string;
         s.doc = "Name of the vector in the current base workspace \
 that should be used as z data.";
-        
+
     endswitch
 
   ## Text properties
   elseif (strcmp (objname, "text"))
     switch field
       ## Overridden shared properties
       case "children"
         s.doc = doc_unused;
 
       ## Specific properties
       case "backgroundcolor"
         s.doc = sprintf (doc_notimpl, "Background area");
         s.valid = valid_color;
-        
+
       case "color"
         s.doc = "Color of the text.  @xref{Colors, ,colorspec}.  ";
         s.valid = valid_color;
-        
+
       case "displayname"
       case "edgecolor"
         s.doc = sprintf (doc_notimpl, "Background area");
         s.valid = valid_color;
-        
+
       case "editing"
       case "erasemode"
         s.doc = doc_unused;
-        
+
       case "extent"
       case "fontangle"
         s.doc = "Flag whether the font is italic or normal.  \
 @code{fontangle} is currently unused.";
-        
+
       case "fontname"
         s.doc = "The font used for the text.";
         s.valid = valid_string;
-        
+
       case "fontsize"
         s.doc = "The font size of the text.";
         s.valid = "scalar";
-        
+
       case "fontunits"
         s.doc = "The units used to interpret @code{fontsize} \
 property.";
-        
+
       case "fontweight"
         s.doc = "Flag whether the font is bold, etc.";
-        
+
       case "horizontalalignment"
       case "interpreter"
       case "linestyle"
         s.doc = sprintf (doc_notimpl, "Background area");
-        
+
       case "linewidth"
         s.doc = sprintf (doc_notimpl, "Background area");
         s.valid = "scalar";
-        
+
       case "margin"
         s.doc = sprintf (doc_notimpl, "Background area");
         s.valid = "scalar";
-        
+
       case "position"
         s.doc = "Vector @qcode{[X0 Y0 Z0]} where X0, Y0 and Z0 \
 indicate the position of the text anchor as defined by \
 @code{verticalalignment} and @code{horizontalalignment}.";
         s.valid = valid_4elvec;
-        
+
       case "rotation"
         s.doc = "The angle of rotation for the displayed text, \
 measured in degrees.";
         s.valid = "scalar";
-        
+
       case "string"
         s.doc = "The text object string content.";
         s.valid = valid_string;
-        
+
       case "units"
       case "verticalalignment"
     endswitch
 
   ## Image properties
   elseif (strcmp (objname, "image"))
     switch field
       ## Overridden shared properties
       case "children"
         s.doc = doc_unused;
 
       ## Specific properties
       case "alphadata"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "alphadatamapping"
         s.doc = sprintf (doc_notimpl, "Transparency");
-        
+
       case "cdata"
         s.valid = "matrix";
-        
+
       case "cdatamapping"
       case "displayname"
         s.doc = "The text of the legend entry corresponding to this \
 image.";
         s.valid = valid_cellstring;
-        
+
       case "erasemode"
         s.doc = doc_unused;
-        
+
       case "xdata"
         s.doc = "Two element vector @qcode{[xmin xmax]} specifying the x \
 coordinates of the first and last columns of the image.  \
 \n\nSetting @code{xdata} empty matrix makes octave automatically \
 affect it the value @qcode{[1 columns(image)]}.";
         s.valid = valid_2elvec;
-        
+
       case "ydata"
         s.doc = "Vector @qcode{[ymin ymax]} specifying the y \
 coordinates of the first and last columns of the image.  \
 \n\nSetting @code{ydata} empty matrix makes octave automatically \
 affect it the value @qcode{[1 rows(image)]}.";
         s.valid = valid_2elvec;
-        
+
     endswitch
-    
+
   ## Surface properties
   elseif (strcmp (objname, "surface"))
     switch field
       ## Overridden shared properties
       case "children"
         s.doc = doc_unused;
 
       ## Specific properties
       case "alphadata"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "alphadatamapping"
         s.doc = sprintf (doc_notimpl, "Transparency");
-        
+
       case "ambientstrength"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "backfacelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "cdata"
         s.valid = "matrix";
-        
+
       case "cdatamapping"
       case "cdatasource"
       case "diffusestrength"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "displayname"
         s.doc = "The text of the legend entry corresponding to this \
 surface.";
-        
+
       case "edgealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = "scalar";
-        
+
       case "edgecolor"
       case "edgelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "erasemode"
         s.doc = doc_unused;
       case "facealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "facecolor"
       case "facelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "interpreter"
       case "linestyle"
         s.doc = "@xref{Line Styles}.";
-        
+
       case "linewidth"
         s.doc = "@xref{XREFlinelinewidth, , line linewidth \
 property}.";
-        
+
       case "marker"
         s.doc = "@xref{Marker Styles}.";
-        
+
       case "markeredgecolor"
         s.doc = "@xref{XREFlinemarkeredgecolor, , line \
-markeredgecolor property}."; 
-        
+markeredgecolor property}.";
+
       case "markerfacecolor"
         s.doc = "@xref{XREFlinemarkerfacecolor, , line \
-markerfacecolor property}."; 
-        
+markerfacecolor property}.";
+
       case "markersize"
         s.doc = "@xref{XREFlinemarkersize, , line \
-markersize property}."; 
+markersize property}.";
         s.valid = "scalar";
-        
+
       case "meshstyle"
       case "normalmode"
       case "specularcolorreflectance"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "specularexponent"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "specularstrength"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "vertexnormals"
       case "xdata"
         s.valid = "matrix";
-        
+
       case "xdatasource"
       case "ydata"
         s.valid = "matrix";
-        
+
       case "ydatasource"
       case "zdata"
         s.valid = "matrix";
-        
+
       case "zdatasource"
     endswitch
-    
+
   ## Patch properties
   elseif (strcmp (objname, "patch"))
     switch field
       ## Overridden shared properties
       case "children"
         s.doc = doc_unused;
 
       ## Specific properties
       case "alphadatamapping"
         s.doc = sprintf (doc_notimpl, "Transparency");
-        
+
       case "ambientstrength"
         s.doc = sprintf (doc_notimpl, "Light");
         s.valid = "scalar";
-        
+
       case "backfacelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "cdata"
         s.doc = "Data defining the patch object color.\n\
 Patch color can be defined for faces or for vertices.  \n\n\
 If @code{cdata} is a scalar index into the current colormap or a RGB \
 triplet, it defines the color of all faces.  \n\n\
 If @code{cdata} is a N-by-1 vector of indices or a N-by-3 (RGB) \
 matrix, it defines the color of each one of the N faces.\n\n\
 If @code{cdata} is a N-by-M or a N-by-M-by-3 (RGB) \
 matrix, it defines the color all vertices.";
         s.valid = valid_scalmat;
-        
+
       case "diffusestrength"
         s.doc = sprintf (doc_notimpl, "Light");
         s.valid = "scalar";
-        
+
       case "displayname"
         s.doc = "The text of the legend entry corresponding to this \
 patch.";
       case "edgealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "edgecolor"
       case "edgelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "erasemode"
         s.doc = doc_unused;
-        
+
       case "facealpha"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "facecolor"
         ## Don't provide a default value, and mark colorspec with
         ## braces, this forces the default rgb triplet to be displayed
         s.valid = packopt ({markdef(valid_color), ...
                             "@qcode{\"flat\"}", ...
                             "@qcode{\"none\"}", ...
                             "@qcode{\"interp\"}"});
-        
+
       case "facelighting"
         s.doc = sprintf (doc_notimpl, "Light");
-        
+
       case "faces"
       case "xdata"
         s.valid = valid_vecmat;
-        
+
       case "facevertexalphadata"
         s.doc = sprintf (doc_notimpl, "Transparency");
         s.valid = valid_scalmat;
-        
+
       case "facevertexcdata"
       case "interpreter"
         s.doc = doc_unused;
-        
+
       case "linestyle"
       case "linewidth"
       case "marker"
         s.doc = "@xref{XREFlinemarker, , line marker property}.";
-        
+
       case "markeredgecolor"
         s.doc = "@xref{XREFlinemarkeredgecolor, , line \
-markeredgecolor property}."; 
-        
+markeredgecolor property}.";
+
       case "markerfacecolor"
         s.doc = "@xref{XREFlinemarkerfacecolor, , line \
-markerfacecolor property}."; 
-        
+markerfacecolor property}.";
+
       case "markersize"
         s.doc = "@xref{XREFlinemarkersize, , line \
-markersize property}."; 
+markersize property}.";
         s.valid = "scalar";
-        
+
       case "normalmode"
       case "specularcolorreflectance"
         s.doc = sprintf (doc_notimpl, "Light");
         s.valid = "scalar";
-        
+
       case "specularexponent"
         s.doc = sprintf (doc_notimpl, "Light");
         s.valid = "scalar";
-        
+
       case "specularstrength"
         s.doc = sprintf (doc_notimpl, "Light");
         s.valid = "scalar";
-        
+
       case "vertexnormals"
       case "vertices"
         s.valid = valid_vecmat;
-        
+
       case "xdata"
         s.valid = valid_vecmat;
-        
+
       case "ydata"
         s.valid = valid_vecmat;
-        
+
       case "zdata"
         s.valid = valid_vecmat;
-        
+
     endswitch
   endif
-  
+
   ## Replace keywords
   if (! isempty (s.doc) && ! strcmp (objname, "base"))
     s.doc = expand_doc (s.doc, field, objname);
   endif
-  
+
 endfunction
 
 function strout = expand_doc (strin, field, objname)
   strout = strrep (strin, "__objname__", objname);
   strout = strrep (strout, "__prop__", ["@code{" field "}"]);
 
   modemsg = "Setting @code{%s} also forces the @code{%smode} \
 property to be set to @qcode{\"manual\"}";
   modemsg = sprintf (modemsg, field, field);
   strout = strrep (strout, "__modemsg__", modemsg);
 endfunction
 
 function s = getstructure (objname, base = [])
   hf = [];
   if (! strcmp (objname, "root"))
     ## Use an improbable figure number to avoid ishandle to return
-    ## true for 1 
+    ## true for 1
     hf = figure (2265465, "visible", "off");
   endif
 
   ## Build a default object to extract its properties list and default
   ## values.
   if (strcmp (objname, "base"))
     ## Base properties are extracted from hggroup that only have 2
     ## additional regular (non-hidden) properties, "displayname" and
@@ -1125,69 +1125,69 @@ function s = getstructure (objname, base
     h = hggroup ();
   elseif (strcmp (objname, "root"))
     h = 0;
   elseif (strcmp (objname, "figure"))
     h = hf;
   else
     eval (["h = " objname " ();"]);
   endif
-  
+
   gprop = get (h);
   sprop = set (h);
 
   fields = fieldnames (gprop);
   nf = numel (fields);
   args = cell (2*nf, 1);
   for ii = 1:nf
     field = fields{ii};
 
     ## Get hard coded documentation
     val = getdoc (objname, field, base);
-    
+
     ## Extract the default values that are not hard coded in getdoc
     if (isempty (val.default) && val.printdefault)
       val.default = getdefault (h, objname, field);
     endif
-    
+
     val.isreadonly = ! isfield (sprop, field);
 
     ## Extract the valid values that are not hard coded in getdoc
     if (! val.isreadonly && isempty (val.valid))
       val.valid = sprop.(field);
       if (! isempty (val.valid) &&
           iscellstr (val.valid))
         ## Add double quotes around string radio properties
         val.valid = cellfun (@(s) ["@qcode{\"" s "\"}"], val.valid,
                              "uniformoutput", false);
         val.valid = strjoin (val.valid, ' | ');
       endif
     endif
-    
+
     args{2*(ii-1)+1} = field;
     args{2*ii} = val;
   endfor
 
   ## Build struct and remove unused fields in base properties
   s = struct (args{:});
 
   if (strcmp (objname, "base"))
     s = rmfield (s, {"displayname", "erasemode"});
   endif
 
   if (isfigure (hf))
     close (hf)
   endif
 endfunction
 
-function def = getdefault (h, objname, field)         
+function def = getdefault (h, objname, field)
   ## This function is meant to be run without initialization file so
   ## that the properties we get are the default.
   def = get (h, field);
-  
+
   ## Don't print default values for graphics handles
   if (isscalar (def) && def != 0 && ishandle (def))
     def = "";
   else
     if (ischar (def))
       def = ["@qcode{\"" def "\"}"];
     else
       if ((isvector (def) && numel (def) < 5) ||
@@ -1201,74 +1201,74 @@ function def = getdefault (h, objname, f
         ## Add [] around vector values
         if (ismatrix (def) && numel (def) > 1)
           str = ["[" str "]"];
           ## Add ";" between columns vector values
           if (rows (def) != 1)
             str = strrep (str, "\n", "; ");
           endif
         endif
-        
+
         ## Replace texinfo reserved characters
         def = strrep (str, "{", "@{");
         def = strrep (def, "}", "@}");
         def = strrep (def, "@", "@@");
-        
+
         def = ["@code{" def "}"];
       else
         args = arrayfun (@(x) num2str (x), size (def),
-                         "uniformoutput", false); 
+                         "uniformoutput", false);
         def = [strjoin(args, "-by-") " " class(def)];
       endif
     endif
   endif
 endfunction
 
 function str = printdoc (objname, obj)
   ## Sort fields so that they appear in alphabetic order in the manual
   fields = sort (fieldnames (obj));
   nf = numel (fields);
 
   ## File header and begining of properties table
   str = [warn_autogen() "\n\n@table @asis"];
 
-  
-  for ii = 1:nf 
+
+  for ii = 1:nf
     field = fields{ii};
     str = sprintf ("%s\n\n", str);
 
     ## @anchor: cross reference using XREFobjnamefield label
     ## Concept index: call info from octave with
-    ## 'doc ("objname field")' 
+    ## 'doc ("objname field")'
     str = sprintf ("%s@anchor{XREF%s%s}\n@cindex %s %s\n",
                    str, objname, field, objname, field);
 
     ## Item
     str = sprintf ("%s@item @code{%s}", str, field);
 
     ## Mark item read-only if needed
     if (obj.(field).isreadonly)
       str = sprintf ("%s (read-only):", str);
     else
       str = sprintf ("%s:", str);
     endif
-    
+
     ## Print valid and default values
     tmp = print_options (obj.(field).valid,
                          obj.(field).default);
     if (! isempty (tmp))
       str = sprintf ("%s %s\n", str, tmp);
     else
       str = sprintf ("%s\n", str);
     endif
 
     ## Print documentation
     str = sprintf ("%s%s\n", str, obj.(field).doc);
   endfor
-  
+
   ## End of properties table
   str = sprintf ("%s\n@end table", str);
 endfunction
 
 function str = warn_autogen ()
   str = "@c DO NOT EDIT!  Generated automatically by genpropdoc.m.\n\
 \n\
 @c Copyright (C) 2014 Pantxo Diribarne\n\
diff --git a/doc/interpreter/octave_logo.eps b/doc/interpreter/octave_logo.eps
--- a/doc/interpreter/octave_logo.eps
+++ b/doc/interpreter/octave_logo.eps
@@ -64,30 +64,30 @@ userdict begin
 /d1 { setcachedevice } bind def
 %%EndProlog
 %%Page: 1 1
 %%BeginPageSetup
 %%PageBoundingBox: 1 1 229 230
 %%EndPageSetup
 q
 1 0.498039 0.164706 rg
-16.258 153.068 m 61.023 153.068 l 67.812 153.068 73.277 147.599 73.277 
-140.81 c 73.277 96.048 l 73.277 89.259 67.812 83.791 61.023 83.791 c 
-16.258 83.791 l 9.469 83.791 4.004 89.259 4.004 96.048 c 4.004 140.81 l 
+16.258 153.068 m 61.023 153.068 l 67.812 153.068 73.277 147.599 73.277
+140.81 c 73.277 96.048 l 73.277 89.259 67.812 83.791 61.023 83.791 c
+16.258 83.791 l 9.469 83.791 4.004 89.259 4.004 96.048 c 4.004 140.81 l
 4.004 147.599 9.469 153.068 16.258 153.068 c h
 16.258 153.068 m f
 0.831373 0.333333 0 rg
 5.030871 w
 0 J
 0 j
 [] 0.0 d
 4 M q 1 0 0 -1 0 230.399994 cm
-16.258 77.332 m 61.023 77.332 l 67.812 77.332 73.277 82.801 73.277 
-89.59 c 73.277 134.352 l 73.277 141.141 67.812 146.609 61.023 146.609 c 
-16.258 146.609 l 9.469 146.609 4.004 141.141 4.004 134.352 c 4.004 
+16.258 77.332 m 61.023 77.332 l 67.812 77.332 73.277 82.801 73.277
+89.59 c 73.277 134.352 l 73.277 141.141 67.812 146.609 61.023 146.609 c
+16.258 146.609 l 9.469 146.609 4.004 141.141 4.004 134.352 c 4.004
 89.59 l 4.004 82.801 9.469 77.332 16.258 77.332 c h
 16.258 77.332 m S Q
 Q q
 q 0 0 231 231 rectclip
 % Fallback Image: x=19, y=1, w=210, h=228 res=300dpi size=2499228
 [ 0.24 0 0 0.24 19 1.159994 ] concat
 /DeviceRGB setcolorspace
 8 dict dup begin
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1350,22 +1350,22 @@ struct2hdl (fig_struct);
 * Text Properties::
 * Image Properties::
 * Patch Properties::
 * Surface Properties::
 @end menu
 
 In this Section the graphics object properties are discussed in detail, starting
 with the root figure properties and continuing through the objects
-hierarchy.  The documentation about a specific graphics object can be displayed 
-using @code{doc} function, e.g., @code{doc ("axes properties")} will show 
-@ref{Axes Properties}. 
-
-The allowed values for radio (string) properties can be retrieved 
-programmatically or displayed using the one or 
+hierarchy.  The documentation about a specific graphics object can be displayed
+using @code{doc} function, e.g., @code{doc ("axes properties")} will show
+@ref{Axes Properties}.
+
+The allowed values for radio (string) properties can be retrieved
+programmatically or displayed using the one or
 two arguments call to @code{set} function.  @xref{XREFset, , set}.
 
 In the following documentation, default values are enclosed in @{ @}.
 
 @node Root Figure Properties
 @subsubsection Root Figure Properties
 @cindex root figure properties
 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -460,17 +460,17 @@ simple.
 
 The @code{do-until} statement is similar to the @code{while} statement,
 except that it repeatedly executes a statement until a condition becomes
 true, and the test of the condition is at the end of the loop, so the
 body of the loop is always executed at least once.  As with the
 condition in an @code{if} statement, the condition in a @code{do-until}
 statement is considered true if its value is nonzero, and false if its
 value is zero.  If the value of the conditional expression in a
-@code{do-until} statement is a vector or a matrix, it is considered 
+@code{do-until} statement is a vector or a matrix, it is considered
 true only if it is non-empty and @emph{all} of the elements are nonzero.
 
 Octave's @code{do-until} statement looks like this:
 
 @example
 @group
 do
   @var{body}
diff --git a/examples/data/Makefile.am b/examples/data/Makefile.am
--- a/examples/data/Makefile.am
+++ b/examples/data/Makefile.am
@@ -1,24 +1,24 @@
 # Makefile for Octave's examples/data directory
 #
 # Copyright (C) 2012-2013 John W. Eaton
 #
 # This file is part of Octave.
-# 
+#
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
-# 
+#
 # Octave is distributed in the hope that it will be useful, but WITHOUT
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 DATA_FILES = \
    penny.mat
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -3072,17 +3072,17 @@ inputs, @qcode{\"extra\"} is the same as
             MAKE_INT_BRANCH (int16);
             MAKE_INT_BRANCH (int32);
             MAKE_INT_BRANCH (int64);
             MAKE_INT_BRANCH (uint8);
             MAKE_INT_BRANCH (uint16);
             MAKE_INT_BRANCH (uint32);
             MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
-            
+
             // GAGME: Accursed Matlab compatibility...
             case btyp_char:
               if (isextra)
                 retval = arg.array_value (true).xsum (dim);
               else
                 retval = arg.array_value (true).sum (dim);
               break;
             case btyp_bool:
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -717,17 +717,17 @@ The special keyword @qcode{\"all\"} will
 files.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
-  int nargin = args.length (); 
+  int nargin = args.length ();
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
 
   if (nargin == 1 && symbol_name == "all")
     bp_table::remove_all_breakpoints ();
   else
   {
     if (! error_state)
@@ -916,23 +916,23 @@ do_dbtype (std::ostream& os, const std::
 
   if (! ff.empty ())
     {
       std::ifstream fs (ff.c_str (), std::ios::in);
 
       if (fs)
         {
           int line = 1;
-          std::string text;  
+          std::string text;
 
           while (std::getline (fs, text) && line <= end)
           {
             if (line >= start)
               os << line << "\t" << text << "\n";
-            
+
             line++;
           }
         }
       else
         os << "dbtype: unable to open '" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1252,17 +1252,17 @@ display_warning_options (std::ostream& o
   if (all_state == "on")
     os << "By default, warnings are enabled.";
   else if (all_state == "off")
     os << "By default, warnings are disabled.";
   else if (all_state == "error")
     os << "By default, warnings are treated as errors.";
   else
     panic_impossible ();
-  
+
   if (nel > 1)
     os << "\n\n";
 
   // The state for all is always supposed to be first in the list.
 
   for (octave_idx_type i = 1; i < nel; i++)
     {
       std::string tid = ident(i).string_value ();
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1990,40 +1990,40 @@ see @code{tmpfile}.\n\
 %! else
 %!   envname = "TMPDIR";
 %! endif
 %! envdir = getenv (envname);
 %! unsetenv (envname);
 %! unwind_protect
 %!   ## Test 0-argument form
 %!   fname = tempname ();
-%!   [tmpdir, tmpfname] = fileparts (fname); 
+%!   [tmpdir, tmpfname] = fileparts (fname);
 %!   assert (tmpdir, P_tmpdir);
 %!   assert (tmpfname (1:4), "oct-");
-%!   ## Test 1-argument form 
+%!   ## Test 1-argument form
 %!   tmp_tmpdir = [P_tmpdir filesep() substr(tmpfname, -5)];
 %!   mkdir (tmp_tmpdir) || error ("Unable to create tmp dir");
 %!   setenv (envname, P_tmpdir);
 %!   fname = tempname (tmp_tmpdir);
-%!   [tmpdir, tmpfname] = fileparts (fname); 
+%!   [tmpdir, tmpfname] = fileparts (fname);
 %!   assert (tmpdir, tmp_tmpdir);
 %!   assert (tmpfname (1:4), "oct-");
 %!   ## Test 1-argument form w/null tmpdir
 %!   fname = tempname ("");
-%!   [tmpdir, tmpfname] = fileparts (fname); 
+%!   [tmpdir, tmpfname] = fileparts (fname);
 %!   assert (tmpdir, P_tmpdir);
 %!   assert (tmpfname (1:4), "oct-");
-%!   ## Test 2-argument form 
+%!   ## Test 2-argument form
 %!   fname = tempname (tmp_tmpdir, "pfx-");
-%!   [tmpdir, tmpfname] = fileparts (fname); 
+%!   [tmpdir, tmpfname] = fileparts (fname);
 %!   assert (tmpdir, tmp_tmpdir);
 %!   assert (tmpfname (1:4), "pfx-");
 %!   ## Test 2-argument form w/null prefix
 %!   fname = tempname (tmp_tmpdir, "");
-%!   [tmpdir, tmpfname] = fileparts (fname); 
+%!   [tmpdir, tmpfname] = fileparts (fname);
 %!   assert (tmpdir, tmp_tmpdir);
 %!   assert (tmpfname (1:4), "file");
 %! unwind_protect_cleanup
 %!   rmdir (tmp_tmpdir);
 %!   if (isempty (envdir))
 %!     unsetenv (envname);
 %!   else
 %!     setenv (envname, envdir);
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1448,17 +1448,17 @@ opengl_renderer::draw_axes (const axes::
       || x_min < -floatmax || y_min < -floatmax || z_min < -floatmax)
     {
       warning ("opengl_renderer: data values greater than float capacity.  (1) Scale data, or (2) Use gnuplot");
       return;
     }
 
   setup_opengl_transformation (props);
 
-  // Disable line smoothing for axes 
+  // Disable line smoothing for axes
   GLboolean antialias;
   glGetBooleanv (GL_LINE_SMOOTH, &antialias);
   if (antialias == GL_TRUE)
     glDisable (GL_LINE_SMOOTH);
 
   // draw axes object
 
   draw_axes_planes (props);
@@ -2472,17 +2472,17 @@ opengl_renderer::draw_patch (const patch
 
           set_linestyle (props.get_linestyle (), false);
           set_linewidth (props.get_linewidth ());
 
           // NOTE: patch contour cannot be offset.  Offset must occur with the
           // filled portion of the patch above.  The tesselator uses
           // GLU_TESS_BOUNDARY_ONLY to get the outline of the patch and OpenGL
           // automatically sets the glType to GL_LINE_LOOP.  This primitive is
-          // not supported by glPolygonOffset which is used to do Z offsets. 
+          // not supported by glPolygonOffset which is used to do Z offsets.
           patch_tesselator tess (this, ec_mode, el_mode);
 
           for (int i = 0; i < nf; i++)
             {
               if (clip_f(i))
                 {
                   // This is an unclosed contour.  Draw it as a line.
                   bool flag = false;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2768,17 +2768,17 @@ xreset_default_properties (graphics_hand
     {
       std::string pname = it->first;
 
       // Don't reset internal properties and handle_properties
       if (! obj.has_readonly_property (pname) &&
           pname.find ("__") != 0 && pname.find ("current") != 0 &&
           pname != "uicontextmenu" && pname != "parent")
         {
-          // Store *mode prop/val in order to set them last 
+          // Store *mode prop/val in order to set them last
           if (pname.find ("mode") == (pname.length () - 4))
             pval[pname] = it->second;
           else
             obj.set (pname, it->second);
         }
     }
 
   // set *mode properties
@@ -2931,18 +2931,18 @@ base_properties::set_parent (const octav
           new_parent = gh_manager::lookup (hnp);
 
           if (new_parent.ok ())
             {
               // Remove child from current parent
               graphics_object old_parent_obj;
               old_parent_obj = gh_manager::get_object (get_parent ());
 
-               
-              if (old_parent_obj.get_handle () != hnp) 
+
+              if (old_parent_obj.get_handle () != hnp)
                 old_parent_obj.remove_child (__myhandle__);
               else
                 // Do nothing more
                 return;
 
               // Check new parent's parent is not this child to avoid recursion
               graphics_object new_parent_obj;
               new_parent_obj = gh_manager::get_object (new_parent);
@@ -3129,25 +3129,25 @@ base_graphics_object::remove_all_listene
 
       property p = get_properties ().get_property (pa->first);
 
       if (! error_state && p.ok ())
         p.delete_listener ();
     }
 }
 
-void 
+void
 base_graphics_object::reset_default_properties (void)
   {
     if (valid_object ())
       {
-        property_list::pval_map_type factory_pval = 
+        property_list::pval_map_type factory_pval =
           gh_manager::get_object (0).get_factory_defaults_list ()
           .find (type ())->second;
-        
+
         xreset_default_properties (get_handle (), factory_pval);
 
         override_defaults (*this);
       }
   }
 
 std::string
 base_graphics_object::values_as_string (void)
@@ -3347,17 +3347,17 @@ root_figure::properties::get_diary (void
 
 void
 root_figure::properties::set_diary (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       diary.set (val, false);
-      
+
       if (! error_state)
         {
           Fdiary (ovl (diary.current_value ()));
 
           diary.run_listeners ();
         }
     }
 }
@@ -3370,17 +3370,17 @@ root_figure::properties::get_diaryfile (
 
 void
 root_figure::properties::set_diaryfile (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       diaryfile.set (val, false);
-      
+
       if (! error_state)
         {
           Fdiary (ovl (diaryfile.string_value ()));
 
           diaryfile.run_listeners ();
         }
     }
 }
@@ -3397,17 +3397,17 @@ root_figure::properties::get_echo (void)
 
 void
 root_figure::properties::set_echo (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       echo.set (val, false);
-      
+
       if (! error_state)
         {
           Fecho (ovl (echo.current_value ()));
 
           echo.run_listeners ();
         }
     }
 }
@@ -3426,20 +3426,20 @@ root_figure::properties::get_format (voi
 
 void
 root_figure::properties::set_format (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       format.set (val, false);
-      
+
       if (! error_state)
         {
-          Fformat (ovl (format.current_value ()));     
+          Fformat (ovl (format.current_value ()));
 
           format.run_listeners ();
         }
     }
 }
 
 std::string
 root_figure::properties::get_formatspacing (void) const
@@ -3453,17 +3453,17 @@ root_figure::properties::get_formatspaci
 
 void
 root_figure::properties::set_formatspacing (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       formatspacing.set (val, false);
-      
+
       if (! error_state)
         {
           std::string strval = formatspacing.current_value ();
 
           if (strval == "compact")
             F__compactformat__ (ovl (true));
           else
             F__compactformat__ (ovl (false));
@@ -3482,17 +3482,17 @@ root_figure::properties::get_recursionli
 
 void
 root_figure::properties::set_recursionlimit (const octave_value& val)
 {
   if (! error_state)
     {
       // Input checking and abrev. matching
       recursionlimit.set (val, false);
-      
+
       if (! error_state)
         {
           double dval = recursionlimit.double_value ();
 
           Fmax_recursion_depth (ovl (dval));
 
           recursionlimit.run_listeners ();
         }
@@ -3634,17 +3634,17 @@ property_list
 root_figure::factory_properties = root_figure::init_factory_properties ();
 
 void
 root_figure::reset_default_properties (void)
 {
   // empty list of local defaults
   default_properties = property_list ();
 
-  xreset_default_properties (get_handle (), 
+  xreset_default_properties (get_handle (),
                              xproperties.factory_defaults ());
 }
 
 // ---------------------------------------------------------------------
 
 void
 figure::properties::set_currentaxes (const octave_value& v)
 {
@@ -3682,17 +3682,17 @@ figure::properties::remove_child (const 
               break;
             }
         }
 
       currentaxes = new_currentaxes;
     }
 }
 
-void 
+void
 figure::properties::adopt (const graphics_handle& h)
 {
   base_properties::adopt (h);
 
   if (! get_currentaxes ().ok ())
     {
       graphics_object go = gh_manager::get_object (h);
 
@@ -3824,17 +3824,17 @@ figure::properties::set_position (const 
             }
         }
 
       if (modified)
         {
           position.run_listeners (POSTSET);
           mark_modified ();
         }
-      
+
       if (paperpositionmode.is ("auto"))
         paperposition.set (get_auto_paperposition ());
     }
 }
 
 void
 figure::properties::set_outerposition (const octave_value& v,
                                        bool do_notify_toolkit)
@@ -4052,21 +4052,21 @@ papersize_from_type (const caseless_str 
 }
 
 
 Matrix
 figure::properties::get_auto_paperposition (void)
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix sz;
-  
+
   caseless_str funits = get_units ();
   caseless_str punits = get_paperunits ();
 
-  // Convert position from figure units to paperunits 
+  // Convert position from figure units to paperunits
   if (funits == "normalized" || punits == "normalized")
     {
       sz = screen_size_pixels ();
       pos = convert_position (pos, funits, "inches", sz);
 
       if (punits == "normalized")
         sz = papersize_from_type ("points", get_papertype ());
 
@@ -4085,75 +4085,75 @@ figure::properties::get_auto_paperpositi
 }
 
 /*
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
-%!   ## paperpositionmode "auto" converts figure size to paper units 
+%!   ## paperpositionmode "auto" converts figure size to paper units
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set (hf, "paperunits", "centimeters");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4) * 2.54;
-%!   pos = [(psz/2 .- fsz/2) fsz];  
+%!   pos = [(psz/2 .- fsz/2) fsz];
 %!   set (hf, "paperpositionmode", "auto");
 %!   assert (get (hf, "paperposition"), pos, tol)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
-%!   ## likewise with normalized units 
+%!   ## likewise with normalized units
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   psz = get (hf, "papersize");
 %!   set (hf, "paperunits", "normalized");
 %!   fsz = in_pos(3:4) ./ psz;
-%!   pos = [([0.5 0.5] .- fsz/2) fsz];  
+%!   pos = [([0.5 0.5] .- fsz/2) fsz];
 %!   assert (get (hf, "paperposition"), pos, tol)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
-%!   ## changing papertype updates paperposition 
+%!   ## changing papertype updates paperposition
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set  (hf, "papertype", "a4");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4);
-%!   pos = [(psz/2 .- fsz/2) fsz];  
+%!   pos = [(psz/2 .- fsz/2) fsz];
 %!   assert (get (hf, "paperposition"), pos, tol)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
 %! tol = 20 * eps ();
 %! unwind_protect
 %!   ## lanscape updates paperposition
 %!   set (hf, "units", "inches");
 %!   set (hf, "position", in_pos);
 %!   set (hf, "paperorientation", "landscape");
 %!   psz = get (hf, "papersize");
 %!   fsz = in_pos(3:4);
-%!   pos = [(psz/2 .- fsz/2) fsz];  
+%!   pos = [(psz/2 .- fsz/2) fsz];
 %!   assert (get (hf, "paperposition"), pos, tol)
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off", "paperpositionmode", "auto");
 %! in_pos = [0 0 4 5];
@@ -4966,17 +4966,17 @@ axes::properties::set_defaults (base_gra
 
   // Replace/Reset preserves Position and Units properties
   if (mode != "replace" && mode != "reset")
     {
       outerposition = default_axes_outerposition ();
       position = default_axes_position ();
       activepositionproperty = "outerposition";
     }
-  
+
   if (mode != "reset")
     {
       delete_children (true);
 
       xlabel = gh_manager::make_graphics_handle ("text", __myhandle__,
                                                  false, false);
       ylabel = gh_manager::make_graphics_handle ("text", __myhandle__,
                                                  false, false);
@@ -6874,17 +6874,17 @@ axes::properties::calc_ticks_and_lims (a
       else
         {
           hi = std::log10 (hi);
           lo = std::log10 (lo);
         }
     }
 
   double tick_sep;
-  
+
   if (is_logscale)
     {
       if (! (xisinf (hi) || xisinf (lo)))
         tick_sep = 1;  // Tick is every order of magnitude (bug #39449)
       else
         tick_sep = 0;
     }
   else
@@ -7127,17 +7127,17 @@ get_children_limits (double& min_val, do
 }
 
 static std::set<double> updating_axis_limits;
 
 void
 axes::update_axis_limits (const std::string& axis_type,
                           const graphics_handle& h)
 {
-  if (updating_axis_limits.find (get_handle ().value ()) != 
+  if (updating_axis_limits.find (get_handle ().value ()) !=
       updating_axis_limits.end ())
     return;
 
   Matrix kids = Matrix (1, 1, h.value ());
 
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
@@ -7330,17 +7330,17 @@ axes::update_axis_limits (const std::str
 
   xproperties.update_transform ();
 
 }
 
 void
 axes::update_axis_limits (const std::string& axis_type)
 {
-  if ((updating_axis_limits.find (get_handle ().value ()) != 
+  if ((updating_axis_limits.find (get_handle ().value ()) !=
        updating_axis_limits.end ()) ||
       (updating_aspectratios.find (get_handle ().value ()) !=
        updating_aspectratios.end ()))
     return;
 
   Matrix kids = xproperties.get_children ();
 
   double min_val = octave_Inf;
@@ -8004,17 +8004,17 @@ patch::properties::update_fvc (void)
     return;
 
   Matrix xd = get_xdata ().matrix_value ();
   Matrix yd = get_ydata ().matrix_value ();
   Matrix zd = get_zdata ().matrix_value ();
   NDArray cd = get_cdata ().array_value ();
 
   bad_data_msg = std::string ();
-  if (xd.dims () != yd.dims () || 
+  if (xd.dims () != yd.dims () ||
       (xd.dims () != zd.dims () && ! zd.is_empty ()))
     {
       bad_data_msg = "x/y/zdata should have the same dimensions";
       return;
     }
 
   // Faces and Vertices
   dim_vector dv;
@@ -8116,64 +8116,64 @@ patch::properties::update_data (void)
                   idx(ii,jj) = valid_vert;
                   turn_valid = true;
                 }
               else
                 valid_vert = idx(ii,jj);
             }
         }
     }
-  
+
   // Build cdata
   dim_vector dv = dim_vector::alloc (3);
   NDArray cd;
   bool pervertex = false;
 
   if (fvc.rows () == nfaces || fvc.rows () == 1)
     {
       dv(0) = 1;
       dv(1) = fvc.rows ();
       dv(2) = fvc.columns ();
       cd = fvc.reshape (dv);
     }
-  else 
+  else
     {
       if (! fvc.is_empty ())
         {
           dv(0) = idx.rows ();
           dv(1) = nfaces;
           dv(2) = fvc.columns ();
           cd.resize (dv);
           pervertex = true;
         }
     }
 
-  // Build x,y,zdata and eventually per vertex cdata 
-  Matrix xd (idx.dims ()); 
+  // Build x,y,zdata and eventually per vertex cdata
+  Matrix xd (idx.dims ());
   Matrix yd (idx.dims ());
   Matrix zd;
   bool has_zd = false;
   if (vert.columns () > 2)
     {
       zd = Matrix (idx.dims ());
       has_zd = true;
     }
 
-  
+
   for (octave_idx_type jj = 0; jj < nfaces; jj++)
     {
       for (octave_idx_type ii = 0; ii < idx.rows (); ii++)
         {
           octave_idx_type row = static_cast<octave_idx_type> (idx(ii,jj)-1);
           xd(ii,jj) = vert(row,0);
           yd(ii,jj) = vert(row,1);
 
           if (has_zd)
             zd(ii,jj) = vert(row,2);
-          
+
           if (pervertex)
             for (int kk = 0; kk < fvc.columns (); kk++)
               cd(ii,jj,kk) = fvc(row,kk);
         }
     }
 
 
   unwind_protect frame;
@@ -8824,17 +8824,17 @@ uitoolbar::get_default (const caseless_s
 }
 
 void
 uitoolbar::reset_default_properties (void)
 {
   // empty list of local defaults
   default_properties = property_list ();
 
-  xreset_default_properties (get_handle (), 
+  xreset_default_properties (get_handle (),
                              xproperties.factory_defaults ());
 
   // override with parents' defaults
   override_defaults (*this);
 }
 
 // ---------------------------------------------------------------------
 
@@ -9497,28 +9497,28 @@ each individual object will be reset.\n\
 
 /*
 
 %!test  # line object
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   tol = 20 * eps;
 %!   hax = axes ("defaultlinelinewidth", 3);
-%!   
+%!
 %!   hli = line (1:10, 1:10, 1:10, "marker", "o",
 %!               "markerfacecolor", "b", "linestyle", ":");
-%!   
+%!
 %!   reset (hli);
 %!   assert (get (hli, "marker"), get (0, "defaultlinemarker"));
-%!   assert (get (hli, "markerfacecolor"), 
+%!   assert (get (hli, "markerfacecolor"),
 %!           get (0, "defaultlinemarkerfacecolor"));
-%!   assert (get (hli, "linestyle"), 
+%!   assert (get (hli, "linestyle"),
 %!           get (0, "defaultlinelinestyle"));
-%!   assert (get (hli, "linewidth"), 3, tol);  # parent axes defaults  
-%!   
+%!   assert (get (hli, "linewidth"), 3, tol);  # parent axes defaults
+%!
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # patch object
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   tol = 20 * eps;
@@ -9555,61 +9555,61 @@ each individual object will be reset.\n\
 %!           get (0, "defaultsurfaceedgecolor"), tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # image object
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   tol = 20 * eps;   
+%!   tol = 20 * eps;
 %!   him = image (rand (10,10), "cdatamapping", "scaled");
 %!
 %!   reset (him);
 %!   assert (get (him, "cdata"), get (0, "defaultimagecdata"), tol);
 %!   assert (get (him, "cdatamapping"),
 %!           get (0, "defaultimagecdatamapping"), tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # text object
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   tol = 20 * eps;   
+%!   tol = 20 * eps;
 %!   hte = text (5, 5, "Hi!", "fontsize", 20 ,"color", "r");
 %!
 %!   reset (hte);
 %!   assert (get (hte, "position"), get (0, "defaulttextposition"), tol);
 %!   assert (get (hte, "fontsize"), get (0, "defaulttextfontsize"), tol);
 %!   assert (get (hte, "color"), get (0, "defaulttextcolor"), tol);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%!test  # axes object  
+%!test  # axes object
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   tol = 20 * eps;
 %!   pos = get (0, "defaultaxesposition") * .5;
 %!   hax = axes ("linewidth", 2, "position", pos);
 %!   title ("Reset me, please!");
-%! 
+%!
 %!   reset (hax);
 %!   assert (get (hax, "linewidth"), get (0, "defaultaxeslinewidth"), tol);
 %!   assert (get (hax, "position"), pos, tol); # axes position is unchanged
 %!   assert (get (hax, "default"), struct ()); # no more axes' defaults
 %!   assert (get (get (hax, "title"), "string"), "");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test  # root figure object
 %! set (0, "defaultfigurevisible", "off");
-%! hf = figure ("visible", "off", "paperunits", "centimeters", 
+%! hf = figure ("visible", "off", "paperunits", "centimeters",
 %!              "papertype", "a4");
 %! unwind_protect
 %!   reset (hf);
 %!   assert (get (hf, "papertype"), get (0, "defaultfigurepapertype"));
 %!   assert (get (hf, "paperunits"), "centimeters"); # paperunits is unchanged
 %!   assert (get (hf, "visible"), get (0, "defaultfigurevisible"));
 %! unwind_protect_cleanup
 %!   close (hf);
@@ -9727,17 +9727,17 @@ being @qcode{\"portrait\"}.\n\
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
                       obj.set (args(1).map_value ());
                     }
                   else if (nargin == 2 && args(1).is_string ())
                     {
                       std::string property = args(1).string_value ();
-                      
+
                       octave_map pmap = obj.values_as_struct ();
 
                       if (obj.has_readonly_property (property))
                         if (nargout != 0)
                           retval = Matrix ();
                         else
                           octave_stdout << "set: " << property
                                         <<" is read-only" << std::endl;
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1992,67 +1992,67 @@ private:
 typedef std::pair <std::string, octave_value> pval_pair;
 
 class pval_vector : public std::vector <pval_pair>
 {
  public:
   const_iterator find (const std::string pname) const
   {
     const_iterator it;
- 
+
     for (it = (*this).begin (); it != (*this).end (); it++)
       if (pname.compare ((*it).first) == 0)
         return it;
-    
+
     return (*this).end ();
   }
 
   iterator find (const std::string pname)
   {
     iterator it;
- 
+
     for (it = (*this).begin (); it != (*this).end (); it++)
       if (pname.compare ((*it).first) == 0)
         return it;
-    
+
     return (*this).end ();
   }
-  
+
   octave_value lookup (const std::string pname) const
   {
     octave_value retval;
 
     const_iterator it = find (pname);
 
     if (it != (*this).end ())
      retval = (*it).second;
 
     return retval;
   }
 
-  octave_value& operator [] (const std::string pname)   
+  octave_value& operator [] (const std::string pname)
   {
     iterator it = find (pname);
-    
+
     if (it == (*this).end ())
       {
         push_back (pval_pair (pname, octave_value ()));
         return (*this).back ().second;
       }
-    
+
     return (*it).second;
   }
 
   void erase (const std::string pname)
   {
     iterator it = find (pname);
     if (it != (*this).end ())
       erase (it);
   }
-  
+
   void erase (iterator it)
   {
     std::vector <pval_pair>::erase (it);
   }
 
 };
 
 class property_list
@@ -3046,19 +3046,19 @@ public:
 
   bool has_readonly_property (const caseless_str& pname) const
   {
     return rep->has_readonly_property (pname);
   }
 
   std::string values_as_string (void) { return rep->values_as_string (); }
 
-  std::string value_as_string (const std::string& prop) 
-  { 
-    return rep->value_as_string (prop); 
+  std::string value_as_string (const std::string& prop)
+  {
+    return rep->value_as_string (prop);
   }
 
   octave_map values_as_struct (void) { return rep->values_as_struct (); }
 
   graphics_handle get_parent (void) const { return rep->get_parent (); }
 
   graphics_handle get_handle (void) const { return rep->get_handle (); }
 
@@ -3300,17 +3300,17 @@ public:
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
   void reset_default_properties (void);
-  
+
   bool has_readonly_property (const caseless_str& pname) const
   {
     bool retval = xproperties.has_readonly_property (pname);
     if (! retval)
       retval = base_properties::has_readonly_property (pname);
     return retval;
   }
 
@@ -3467,17 +3467,17 @@ public:
       outerposition.add_constraint (dim_vector (1, 4));
       paperposition.add_constraint (dim_vector (1, 4));
       papersize.add_constraint (dim_vector (1, 2));
       pointershapecdata.add_constraint (dim_vector (16, 16));
       pointershapehotspot.add_constraint (dim_vector (1, 2));
       position.add_constraint (dim_vector (1, 4));
     }
 
-  private:    
+  private:
     Matrix get_auto_paperposition (void);
 
     void update_paperpositionmode (void)
     {
       if (paperpositionmode.is ("auto"))
         paperposition.set (get_auto_paperposition ());
     }
 
@@ -3542,17 +3542,17 @@ public:
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
   void reset_default_properties (void);
-  
+
   bool has_readonly_property (const caseless_str& pname) const
   {
     bool retval = xproperties.has_readonly_property (pname);
     if (! retval)
       retval = base_properties::has_readonly_property (pname);
     return retval;
   }
 
@@ -4643,51 +4643,51 @@ public:
     {
       if (cdatamapping_is ("scaled"))
         set_clim (cdata.get_limits ());
       else
         clim = cdata.get_limits ();
 
       if (xdatamode.is ("auto"))
         update_xdata ();
-      
+
       if (ydatamode.is ("auto"))
         update_ydata ();
     }
 
     void update_xdata (void)
     {
       if (xdata.get ().is_empty ())
         set_xdatamode ("auto");
-        
+
       if (xdatamode.is ("auto"))
         {
           set_xdata (get_auto_xdata ());
           set_xdatamode ("auto");
         }
-      
+
       Matrix limits = xdata.get_limits ();
       float dp = pixel_xsize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_xlim (limits);
     }
 
     void update_ydata (void)
     {
       if (ydata.get ().is_empty ())
         set_ydatamode ("auto");
-        
+
       if (ydatamode.is ("auto"))
         {
-          set_ydata (get_auto_ydata ()); 
+          set_ydata (get_auto_ydata ());
           set_ydatamode ("auto");
         }
-      
+
       Matrix limits = ydata.get_limits ();
       float dp = pixel_ysize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_ylim (limits);
     }
 
@@ -4778,19 +4778,19 @@ class OCTINTERP_API patch : public base_
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
     // Matlab allows incoherent data to be stored into patch properties.
-    // The patch should then be ignored by the renderer. 
-    bool has_bad_data (std::string &msg) const 
-      { 
+    // The patch should then be ignored by the renderer.
+    bool has_bad_data (std::string &msg) const
+      {
         msg = bad_data_msg;
         return ! msg.empty ();
       }
 
     bool is_aliminclude (void) const
     { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
     { return aliminclude.current_value (); }
@@ -4877,51 +4877,51 @@ public:
     void update_faces (void) { update_data ();}
 
     void update_vertices (void)  {  update_data ();}
 
     void update_facevertexcdata (void) { update_data ();}
 
     void update_fvc (void);
 
-    void update_xdata (void) 
-    { 
+    void update_xdata (void)
+    {
       if (get_xdata ().is_empty ())
         {
-          // For compatibility with matlab behavior, 
-          // if x/ydata are set empty, silently empty other *data and 
-          // faces properties while vertices remain unchanged. 
+          // For compatibility with matlab behavior,
+          // if x/ydata are set empty, silently empty other *data and
+          // faces properties while vertices remain unchanged.
           set_ydata (Matrix ());
           set_zdata (Matrix ());
           set_cdata (Matrix ());
           set_faces (Matrix ());
         }
       else
         update_fvc ();
 
       set_xlim (xdata.get_limits ());
     }
 
-    void update_ydata (void) 
-    { 
+    void update_ydata (void)
+    {
       if (get_ydata ().is_empty ())
         {
           set_xdata (Matrix ());
           set_zdata (Matrix ());
           set_cdata (Matrix ());
           set_faces (Matrix ());
         }
       else
         update_fvc ();
 
       set_ylim (ydata.get_limits ());
     }
 
-    void update_zdata (void) 
-    { 
+    void update_zdata (void)
+    {
       update_fvc ();
       set_zlim (zdata.get_limits ());
     }
 
     void update_cdata (void)
     {
       update_fvc ();
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -515,17 +515,17 @@ load_path::move (const dir_info& di, boo
     }
 }
 
 void
 load_path::loader::move (const dir_info& di, bool at_end)
 {
   std::string dir_name = di.dir_name;
 
-  std::list<std::string>::iterator s = 
+  std::list<std::string>::iterator s =
     std::find (dir_list.begin (), dir_list.end (), dir_name);
 
   if (s != dir_list.end ())
     {
       dir_list.erase (s);
 
       if (at_end)
         dir_list.push_back (dir_name);
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3867,17 +3867,17 @@ set_format_style (int argc, const string
         {
           Vcompact_format = false;
           return;
         }
       else
         {
           error ("format: unrecognized format state '%s'", arg.c_str ());
           return;
-        }  
+        }
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
       format = std::string ("short");
     }
 
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -2061,17 +2061,17 @@ tree_jit::initialize (void)
   // sometimes this fails pre main
   engine = llvm::ExecutionEngine::createJIT (module);
 
   if (! engine)
     return false;
 
 #ifdef LEGACY_PASSMANAGER
   module_pass_manager = new llvm::legacy::PassManager ();
-  pass_manager = new llvm::legacy::FunctionPassManager (module); 
+  pass_manager = new llvm::legacy::FunctionPassManager (module);
 #else
   module_pass_manager = new llvm::PassManager ();
   pass_manager = new llvm::FunctionPassManager (module);
 #endif
   module_pass_manager->add (llvm::createAlwaysInlinerPass ());
 
 #ifdef HAVE_LLVM_DATALAYOUT
   pass_manager->add (new llvm::DataLayout (*engine->getDataLayout ()));
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -327,17 +327,17 @@ qs_replace (const Array<char>& str, cons
 
               retsiz += siz - k;
             }
           else
             retsiz = siz + nidx * (rsiz - psiz);
 
           if (retsiz == 0)
             ret.clear (dim_vector (0, 0));
-          else 
+          else
             {
               ret.clear (dim_vector (1, retsiz));
               const char *src = str.data ();
               const char *reps = rep.data ();
               char *dest = ret.fortran_vec ();
 
               octave_idx_type k = 0;
               for (octave_idx_type i = 0; i < nidx; i++)
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -121,17 +121,17 @@ octave_call_stack::stack_frame::fcn_name
 
       if (print_subfn && ! parent_fcn_name.empty ())
         retval = parent_fcn_name + Vfilemarker;
 
       retval += m_fcn->name ();
     }
   else
     retval = "<unknown>";
-  
+
   return retval;
 }
 
 void
 octave_call_stack::create_instance (void)
 {
   instance = new octave_call_stack ();
 
@@ -363,17 +363,17 @@ octave_map
 octave_call_stack::do_backtrace (size_t nskip,
                                  octave_idx_type& curr_user_frame,
                                  bool print_subfn) const
 {
   std::list<octave_call_stack::stack_frame> frames
     = do_backtrace_frames (nskip, curr_user_frame);
 
   size_t nframes = frames.size ();
-  
+
   octave_map retval (dim_vector (nframes, 1), bt_fields);
 
   Cell& file = retval.contents (0);
   Cell& name = retval.contents (1);
   Cell& line = retval.contents (2);
   Cell& column = retval.contents (3);
   Cell& scope = retval.contents (4);
   Cell& context = retval.contents (5);
@@ -476,17 +476,17 @@ octave_call_stack::do_goto_frame_relativ
 
                   octave_stdout << buf.str ();
                 }
 
               retval = true;
               break;
             }
         }
-      else if (incr == 0)  // Break out of infinite loop by choosing an incr. 
+      else if (incr == 0)  // Break out of infinite loop by choosing an incr.
         incr = -1;
 
       // There is no need to set scope and context here.  That will
       // happen when the dbup/dbdown/keyboard frame is popped and we
       // jump to the new "prev" frame set above.
     }
 
   return retval;
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -295,17 +295,17 @@ public:
   static octave_map backtrace (size_t nskip = 0)
   {
     octave_idx_type curr_user_frame = -1;
 
     return instance_ok ()
            ? instance->do_backtrace (nskip, curr_user_frame, true)
            : octave_map ();
   }
-  
+
   static octave_map backtrace (size_t nskip, octave_idx_type& curr_user_frame,
                                bool print_subfn = true)
   {
     return instance_ok ()
            ? instance->do_backtrace (nskip, curr_user_frame, print_subfn)
            : octave_map ();
   }
 
@@ -313,17 +313,17 @@ public:
   backtrace_frames (size_t nskip = 0)
   {
     octave_idx_type curr_user_frame = -1;
 
     return instance_ok ()
            ? instance->do_backtrace_frames (nskip, curr_user_frame)
            : std::list<octave_call_stack::stack_frame> ();
   }
-  
+
   static std::list<octave_call_stack::stack_frame>
   backtrace_frames (size_t nskip, octave_idx_type& curr_user_frame)
   {
     return instance_ok ()
            ? instance->do_backtrace_frames (nskip, curr_user_frame)
            : std::list<octave_call_stack::stack_frame> ();
   }
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -341,39 +341,39 @@ urlwrite (\"http://www.google.com/search
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     {
       print_usage ();
       return retval;
     }
 
-  if (! args(0).is_string ()) 
+  if (! args(0).is_string ())
     {
       error ("urlwrite: URL must be a string");
       return retval;
     }
 
   std::string url = args(0).string_value ();
 
-  if (! args(1).is_string ()) 
+  if (! args(1).is_string ())
     {
       error ("urlwrite: LOCALFILE must be a string");
       return retval;
     }
 
   // name to store the file if download is succesful
   std::string filename = args(1).string_value ();
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
-      if (! args(2).is_string ()) 
+      if (! args(2).is_string ())
         {
           error ("urlwrite: METHOD must be a string");
           return retval;
         }
 
       method = args(2).string_value ();
 
       if (method != "get" && method != "post")
@@ -498,30 +498,30 @@ s = urlread (\"http://www.google.com/sea
 
   // verify arguments
   if (nargin != 1 && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
-  if (! args(0).is_string ()) 
+  if (! args(0).is_string ())
     {
       error ("urlread: URL must be a string");
       return retval;
     }
 
   std::string url = args(0).string_value ();
 
   std::string method;
   Array<std::string> param;
 
   if (nargin == 3)
     {
-      if (! args(1).is_string ()) 
+      if (! args(1).is_string ())
         {
           error ("urlread: METHOD must be a string");
           return retval;
         }
 
       method = args(1).string_value ();
 
       if (method != "get" && method != "post")
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -931,17 +931,17 @@ set_internal_variable (std::string& var,
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      if (args(0).is_string ()) 
+      if (args(0).is_string ())
         {
           std::string sval = args(0).string_value ();
 
           if (empty_ok || ! sval.empty ())
             var = sval;
           else
             error ("%s: value must not be empty", nm);
         }
@@ -972,17 +972,17 @@ set_internal_variable (int& var, const o
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
         warning ("\"local\" has no effect outside a function");
     }
 
   if (nargin == 1)
     {
-      if (args(0).is_string ()) 
+      if (args(0).is_string ())
         {
           std::string sval = args(0).string_value ();
 
           int i = 0;
           for (; i < nchoices; i++)
             {
               if (sval == choices[i])
                 {
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -406,17 +406,17 @@ check_access (const cdef_class& cls, con
                     return true;
                 }
             }
         }
     }
   else
     error ("invalid property/method access in class `%s'",
            cls.get_name ().c_str ());
-  
+
   return false;
 }
 
 static bool
 is_dummy_method (const octave_value& fcn)
 {
   bool retval = false;
 
@@ -1389,17 +1389,17 @@ cdef_object::map_value (void) const
 
 string_vector
 cdef_object_rep::map_keys (void) const
 {
   cdef_class cls = get_class ();
 
   if (cls.ok ())
     return cls.get_names ();
-  
+
   return string_vector ();
 }
 
 octave_value_list
 cdef_object_scalar::subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout, size_t& skip,
                              const cdef_class& context, bool auto_add)
@@ -1529,17 +1529,17 @@ cdef_object_scalar::subsasgn (const std:
                         {
                           prop.set_value (obj, rhs, true, "subsasgn");
 
                           if (! error_state)
                             retval = to_ov (obj);
                         }
                       else
                         {
-                          octave_value val = 
+                          octave_value val =
                             prop.get_value (obj, true, "subsasgn");
 
                           if (! error_state)
                             {
                               std::list<octave_value_list> args (idx);
 
                               args.erase (args.begin ());
 
@@ -1895,17 +1895,17 @@ cdef_object_array::fill_empty_values (Ar
                     arr.xelem (i) = obj;
                 }
               else
                 arr.xelem (i) = obj.copy ();
             }
         }
     }
 }
-  
+
 bool cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
 {
   return (is_constructed ()
           || ctor_list.find (cls) == ctor_list.end ());
 }
 
 bool cdef_object_scalar::is_partially_constructed_for (const cdef_class& cls) const
 {
@@ -3112,29 +3112,29 @@ cdef_property::cdef_property_rep::get_va
 
       if (! obj.is_partially_constructed_for (cls))
         {
           ::error ("cannot reference properties of class `%s' for non-constructed object",
                    cls.get_name ().c_str ());
           return retval;
         }
     }
- 
+
   octave_value get_fcn = get ("GetMethod");
 
   // FIXME: should check whether we're already in get accessor method
 
   if (get_fcn.is_empty () || is_method_executing (get_fcn, obj))
     retval = obj.get (get ("Name").string_value ());
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
-      
+
       args = execute_ov (get_fcn, args, 1);
 
       if (! error_state)
         retval = args(0);
     }
 
   return retval;
 }
@@ -3179,17 +3179,17 @@ cdef_property::cdef_property_rep::set_va
 
       if (! obj.is_partially_constructed_for (cls))
         {
           ::error ("cannot reference properties of class `%s' for non-constructed object",
                    cls.get_name ().c_str ());
           return;
         }
     }
- 
+
   octave_value set_fcn = get ("SetMethod");
 
   if (set_fcn.is_empty () || is_method_executing (set_fcn, obj))
     obj.put (get ("Name").string_value (), val);
   else
     {
       octave_value_list args;
 
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -535,17 +535,17 @@ public:
 
   virtual bool is_class (void) const { return false; }
 
   virtual bool is_property (void) const { return false; }
 
   virtual bool is_method (void) const { return false; }
 
   virtual bool is_package (void) const { return false; }
-  
+
   virtual octave_value_list
   meta_subsref (const std::string& /* type */,
                 const std::list<octave_value_list>& /* idx */,
                 int /* nargout */)
     {
       ::error ("subsref: invalid meta object");
       return octave_value_list ();
     }
@@ -600,17 +600,17 @@ public:
   void meta_release (void) { get_rep ()->meta_release (); }
 
   bool meta_is_postfix_index_handled (char type) const
     { return get_rep ()->meta_is_postfix_index_handled (type); }
 
 private:
   cdef_meta_object_rep* get_rep (void)
     { return dynamic_cast<cdef_meta_object_rep *> (cdef_object::get_rep ()); }
-  
+
   const cdef_meta_object_rep* get_rep (void) const
     { return dynamic_cast<const cdef_meta_object_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_class : public cdef_meta_object
 {
 private:
@@ -705,17 +705,17 @@ private:
     void mark_as_meta_class (void) { meta = true; }
 
     bool is_meta_class (void) const { return meta; }
 
   private:
     void load_all_methods (void);
 
     void find_names (std::set<std::string>& names, bool all);
-    
+
     void find_properties (std::map<std::string,cdef_property>& props,
                           int mode = 0);
 
     void find_methods (std::map<std::string, cdef_method>& meths,
                        bool only_inherited);
 
     cdef_class wrap (void)
       {
@@ -799,17 +799,17 @@ public:
   cdef_method find_method (const std::string& nm, bool local = false);
 
   void install_method (const cdef_method& meth)
     { get_rep ()->install_method (meth); }
 
   Cell get_methods (void) { return get_rep ()->get_methods (); }
 
   cdef_property find_property (const std::string& nm);
-  
+
   void install_property (const cdef_property& prop)
     { get_rep ()->install_property (prop); }
 
   Cell get_properties (int mode = property_normal)
     { return get_rep ()->get_properties (mode); }
 
   std::map<std::string, cdef_property>
   get_property_map (int mode = property_normal)
@@ -881,17 +881,17 @@ public:
       property_normal,
       property_inherited,
       property_all
     };
 
 private:
   cdef_class_rep* get_rep (void)
     { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
-  
+
   const cdef_class_rep* get_rep (void) const
     { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
 
 private:
@@ -956,17 +956,17 @@ private:
 
     bool check_set_access (void) const;
 
   private:
     cdef_property_rep (const cdef_property_rep& p)
       : cdef_meta_object_rep (p) { }
 
     bool is_recursive_set (const cdef_object& obj) const;
-    
+
     cdef_property wrap (void)
       {
         refcount++;
         return cdef_property (this);
       }
   };
 
 public:
@@ -1005,28 +1005,28 @@ public:
 
   void set_value (cdef_object& obj, const octave_value& val,
                   bool do_check_access = true,
                   const std::string& who = std::string ())
     { get_rep ()->set_value (obj, val, do_check_access, who); }
 
   bool check_get_access (void) const
     { return get_rep ()->check_get_access (); }
-  
+
   bool check_set_access (void) const
     { return get_rep ()->check_set_access (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_constant (void) const { return get_rep ()->is_constant (); }
 
 private:
   cdef_property_rep* get_rep (void)
     { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
-  
+
   const cdef_property_rep* get_rep (void) const
     { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_method : public cdef_meta_object
 {
   friend class cdef_class;
@@ -1137,17 +1137,17 @@ public:
   /* dot-invokation: object is pushed as 1st argument */
   octave_value_list execute (const cdef_object& obj,
                              const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
     { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
 
   bool check_access (void) const { return get_rep ()->check_access (); }
-  
+
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_static (void) const { return get_rep ()->is_static (); }
 
   void set_function (const octave_value& fcn)
     { get_rep ()->set_function (fcn); }
 
   octave_value get_function (void) const
@@ -1159,17 +1159,17 @@ public:
   bool is_external (void) const { return get_rep ()->is_external (); }
 
   void mark_as_external (const std::string& dtype)
     { get_rep ()->mark_as_external (dtype); }
 
 private:
   cdef_method_rep* get_rep (void)
     { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
-  
+
   const cdef_method_rep* get_rep (void) const
     { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object_rep::get_class (void) const
 {
   gripe_invalid_object ("get_class");
@@ -1386,17 +1386,17 @@ public:
 
   octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
 
   static const cdef_package& meta (void) { return _meta; }
 
 private:
   cdef_package_rep* get_rep (void)
     { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
-  
+
   const cdef_package_rep* get_rep (void) const
     { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
 
 private:
   static cdef_package _meta;
 
   friend void install_classdef (void);
 };
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -312,17 +312,17 @@ execute_startup_files (void)
                         require_file);
 
       safe_source_file (Vsite_defaults_file, context, verbose, require_file);
     }
 
   if (read_init_files)
     {
       // Try to execute commands from $HOME/$OCTAVE_INITFILE and
-      // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set, 
+      // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set,
       // .octaverc is assumed.
 
       bool home_rc_already_executed = false;
 
       std::string initfile = octave_env::getenv ("OCTAVE_INITFILE");
 
       if (initfile.empty ())
         initfile = ".octaverc";
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -258,17 +258,17 @@ public:
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
       looking_for_object_index (false),
       looking_at_indirect_ref (false), parsing_class_method (false),
       parsing_classdef (false), maybe_classdef_get_set_method (false),
       parsing_classdef_get_method (false),
-      parsing_classdef_set_method (false), 
+      parsing_classdef_set_method (false),
       quote_is_transpose (false), force_script (false),
       reading_fcn_file (false), reading_script_file (false),
       reading_classdef_file (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
       block_comment_nesting_level (0), command_arg_paren_count (0),
       token_count (0), current_input_line (), comment_text (),
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3392,17 +3392,17 @@ octave_base_parser::make_index_expressio
       delete args;
 
       return retval;
     }
 
   int l = expr->line ();
   int c = expr->column ();
 
-  if (! expr->is_postfix_indexed ()) 
+  if (! expr->is_postfix_indexed ())
     expr->set_postfix_index (type);
 
   if (expr->is_index_expression ())
     {
       tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
 
       tmp->append (args, type);
 
@@ -3420,17 +3420,17 @@ tree_index_expression *
 octave_base_parser::make_indirect_ref (tree_expression *expr,
                                        const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
-  if (! expr->is_postfix_indexed ()) 
+  if (! expr->is_postfix_indexed ())
     expr->set_postfix_index ('.');
 
   if (expr->is_index_expression ())
     {
       tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
 
       tmp->append (elt);
 
@@ -3450,17 +3450,17 @@ tree_index_expression *
 octave_base_parser::make_indirect_ref (tree_expression *expr,
                                        tree_expression *elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
-  if (! expr->is_postfix_indexed ()) 
+  if (! expr->is_postfix_indexed ())
     expr->set_postfix_index ('.');
 
   if (expr->is_index_expression ())
     {
       tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
 
       tmp->append (elt);
 
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -55,17 +55,17 @@ public:
 
   tree_expression *expression (void) { return expr; }
 
   bool negate (void) { return neg; }
 
   void accept (tree_walker&);
 
 private:
-  
+
   tree_identifier *id;
   tree_expression *expr;
   bool neg;
 
   // No copying!
 
   tree_classdef_attribute (const tree_classdef_attribute&);
 
@@ -177,17 +177,17 @@ public:
 
 private:
 
   // List of attributes that apply to this class.
   tree_classdef_attribute_list *attr_list;
 
   // The list of objects contained in this block.
   octave_base_list<T> *elt_list;
-  
+
   // Comment preceding the token marking the beginning of the block.
   octave_comment_list *lead_comm;
 
   // Comment preceding END token.
   octave_comment_list *trail_comm;
 
   // No copying!
 
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -707,17 +707,17 @@ octave_tempnam (const std::string& dir, 
   char tname [templatename.length () + 1];
 
   strcpy (tname, templatename.c_str ());
 
   if (gen_tempname (tname, 0, 0, GT_NOCREATE) == -1)
     msg = gnulib::strerror (errno);
   else
     retval = tname;
-  
+
   return retval;
 }
 
 std::string
 octave_canonicalize_file_name (const std::string& name)
 {
   std::string msg;
   return octave_canonicalize_file_name (name, msg);
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -192,17 +192,17 @@ octave_env::get_host_name (void)
 }
 
 std::string
 octave_env::do_get_temp_directory (void) const
 {
   std::string tempd;
 
 #if defined (__MINGW32__) || defined (_MSC_VER)
-  
+
   tempd = do_getenv ("TEMP");
 
   if (tempd.empty ())
     tempd = do_getenv ("TMP");
 
   #if defined (P_tmpdir)
   if (tempd.empty ())
     tempd = P_tmpdir;
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1839,17 +1839,17 @@ AC_DEFUN([OCTAVE_LLVM_LEGACY_PASSMANAGER
       save_LIBS="$LIBS"
       LIBS="$LLVM_LIBS $LIBS"
       AC_LINK_IFELSE(
         [AC_LANG_PROGRAM([[
           #include <llvm/IR/LegacyPassManager.h>
           ]], [[
           llvm::Module *module;
           llvm::legacy::PassManager *module_pass_manager;
-          llvm::legacy::FunctionPassManager *pass_manager;      
+          llvm::legacy::FunctionPassManager *pass_manager;
           module_pass_manager = new llvm::legacy::PassManager ();
           pass_manager = new llvm::legacy::FunctionPassManager (module);
         ]])],
         octave_cv_legacy_passmanager=yes,
         octave_cv_legacy_passmanager=no)
       LIBS="$save_LIBS"
     AC_LANG_POP(C++)
   ])
diff --git a/scripts/deprecated/finite.m b/scripts/deprecated/finite.m
--- a/scripts/deprecated/finite.m
+++ b/scripts/deprecated/finite.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Mapping Function} {} finite (@var{x})
 ##
 ## @code{finite} is deprecated and will be removed in Octave version 4.6.
 ## Please use @code{isfinite} in all new code.
 ##
 ## Return a logical array which is true where the elements of @var{x} are
 ## finite values and false where they are not.
 ## For example:
-## 
+##
 ## @example
 ## @group
 ## finite ([13, Inf, NA, NaN])
 ##      @result{} [ 1, 0, 0, 0 ]
 ## @end group
 ## @end example
 ## @seealso{isfinite, isinf, isnan, isna}
 ## @end deftypefn
diff --git a/scripts/deprecated/fmod.m b/scripts/deprecated/fmod.m
--- a/scripts/deprecated/fmod.m
+++ b/scripts/deprecated/fmod.m
@@ -19,21 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})
 ##
 ## @code{fmod} is deprecated and will be removed in Octave version 4.6.
 ## Please use @code{rem} in all new code.
 ##
 ## Return the remainder of the division @code{@var{x} / @var{y}}, computed
 ## using the expression
-## 
+##
 ## @example
 ## x - y .* fix (x ./ y)
 ## @end example
-## 
+##
 ## An error message is printed if the dimensions of the arguments do not
 ## agree, or if either of the arguments is complex.
 ## @seealso{rem, mod}
 ## @end deftypefn
 
 ## Deprecated in version 4.2
 
 function retval = fmod (varargin)
diff --git a/scripts/deprecated/fnmatch.m b/scripts/deprecated/fnmatch.m
--- a/scripts/deprecated/fnmatch.m
+++ b/scripts/deprecated/fnmatch.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})
 ##
 ## @code{fnmatch} is deprecated and will be removed in Octave version 4.6.
 ## Please use @code{glob} or @code{regexp} in all new code.
 ##
 ## Return true or false for each element of @var{string} that matches any of
 ## the elements of the string array @var{pattern}, using the rules of
 ## filename pattern matching.  For example:
-## 
+##
 ## @example
 ## @group
 ## fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})
 ##      @result{} [ 1; 1; 0 ]
 ## @end group
 ## @end example
 ## @seealso{glob, regexp}
 ## @end deftypefn
diff --git a/scripts/deprecated/luinc.m b/scripts/deprecated/luinc.m
--- a/scripts/deprecated/luinc.m
+++ b/scripts/deprecated/luinc.m
@@ -21,61 +21,61 @@
 ## @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})
 ##
 ## @code{luinc} is deprecated and will be removed in Octave version 4.6.
 ## Please use @code{ilu} or @code{ichol} in all new code.
 ##
 ## Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.
 ## Two types of incomplete factorization are possible, and the type
 ## is determined by the second argument to @code{luinc}.
-## 
+##
 ## Called with a second argument of @qcode{'0'}, the zero-level incomplete
 ## LU@tie{}factorization is produced.  This creates a factorization of @var{A}
 ## where the position of the nonzero arguments correspond to the same
 ## positions as in the matrix @var{A}.
-## 
+##
 ## Alternatively, the fill-in of the incomplete LU@tie{}factorization can
 ## be controlled through the variable @var{droptol} or the structure
 ## @var{opts}.  The @sc{umfpack} multifrontal factorization code by Tim A.
 ## Davis is used for the incomplete LU@tie{}factorization, (availability
 ## @url{http://www.cise.ufl.edu/research/sparse/umfpack/})
-## 
+##
 ## @var{droptol} determines the values below which the values in the
 ## LU@tie{} factorization are dropped and replaced by zero.  It must be a
 ## positive scalar, and any values in the factorization whose absolute value
 ## are less than this value are dropped, expect if leaving them increase the
 ## sparsity of the matrix.  Setting @var{droptol} to zero results in a complete
 ## LU@tie{}factorization which is the default.
-## 
+##
 ## @var{opts} is a structure containing one or more of the fields
-## 
+##
 ## @table @code
 ## @item droptol
 ## The drop tolerance as above.  If @var{opts} only contains @code{droptol}
 ## then this is equivalent to using the variable @var{droptol}.
-## 
+##
 ## @item milu
 ## A logical variable flagging whether to use the modified incomplete
 ## LU@tie{} factorization.  In the case that @code{milu} is true, the dropped
 ## values are subtracted from the diagonal of the matrix @var{U} of the
 ## factorization.  The default is @code{false}.
-## 
+##
 ## @item udiag
 ## A logical variable that flags whether zero elements on the diagonal of
 ## @var{U} should be replaced with @var{droptol} to attempt to avoid singular
 ## factors.  The default is @code{false}.
-## 
+##
 ## @item thresh
 ## Defines the pivot threshold in the interval [0,1].  Values outside that
 ## range are ignored.
 ## @end table
-## 
+##
 ## All other fields in @var{opts} are ignored.  The outputs from @code{luinc}
 ## are the same as for @code{lu}.
-## 
+##
 ## Given the string argument @qcode{\"vector\"}, @code{luinc} returns the
 ## values of @var{p} @var{q} as vector values.
 ## @seealso{ilu, ichol, lu, sparse}
 ## @end deftypefn
 
 ## Deprecated in version 4.2
 
 function [L, U, P, Q] = luinc (varargin)
diff --git a/scripts/deprecated/octave_tmp_file_name.m b/scripts/deprecated/octave_tmp_file_name.m
--- a/scripts/deprecated/octave_tmp_file_name.m
+++ b/scripts/deprecated/octave_tmp_file_name.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Built-in Function} {@var{fname} =} octave_tmp_file_name ()
 ## @deftypefnx {Built-in Function} {@var{fname} =} octave_tmp_file_name (@var{dir})
 ## @deftypefnx {Built-in Function} {@var{fname} =} octave_tmp_file_name (@var{dir}, @var{prefix})
 ##
 ## @code{octave_tmp_file_name} is deprecated and will be removed in Octave
 ## version 4.6.  Use @code{tempname} for equivalent functionality.
 ##
 ## Return a unique temporary file name as a string.
-## 
+##
 ## If @var{prefix} is omitted, a value of @qcode{"oct-"} is used.
 ## If @var{dir} is also omitted, the default directory for temporary files
 ## (@code{P_tmpdir} is used.  If @var{dir} is provided, it must exist,
 ## otherwise the default directory for temporary files is used.
 ## @seealso{tempname, tmpnam, mkstemp, tempdir, P_tmpdir, tmpfile}
 ## @end deftypefn
 
 ## Deprecated in version 4.2
diff --git a/scripts/deprecated/syl.m b/scripts/deprecated/syl.m
--- a/scripts/deprecated/syl.m
+++ b/scripts/deprecated/syl.m
@@ -24,24 +24,24 @@
 ##
 ## Solve the Sylvester equation
 ## @tex
 ## $$
 ##  A X + X B + C = 0
 ## $$
 ## @end tex
 ## @ifnottex
-## 
+##
 ## @example
 ## A X + X B + C = 0
 ## @end example
-## 
+##
 ## @end ifnottex
 ## using standard @sc{lapack} subroutines.  For example:
-## 
+##
 ## @example
 ## @group
 ## syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
 ##    @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]
 ## @end group
 ## @end example
 ## @end deftypefn
 
diff --git a/scripts/deprecated/usage.m b/scripts/deprecated/usage.m
--- a/scripts/deprecated/usage.m
+++ b/scripts/deprecated/usage.m
@@ -21,34 +21,34 @@
 ##
 ## @code{usage} is deprecated and will be removed in Octave version 4.6.
 ## Please use @code{print_usage} in all new code.
 ##
 ## Print the message @var{msg}, prefixed by the string @samp{usage: }, and
 ## set Octave's internal error state such that control will return to the
 ## top level without evaluating any more commands.  This is useful for
 ## aborting from functions.
-## 
+##
 ## After @code{usage} is evaluated, Octave will print a traceback of all
 ## the function calls leading to the usage message.
-## 
+##
 ## You should use this function for reporting problems errors that result
 ## from an improper call to a function, such as calling a function with an
 ## incorrect number of arguments, or with arguments of the wrong type.  For
 ## example, most functions distributed with Octave begin with code like
 ## this
-## 
+##
 ## @example
 ## @group
 ## if (nargin != 2)
 ##   usage (\"foo (a, b)\");
 ## endif
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## to check for the proper number of arguments.
 ## @seealso{print_usage}
 ## @end deftypefn
 
 ## Deprecated in version 4.2
 
 function retval = usage (varargin)
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -140,17 +140,17 @@
 ##
 ## @seealso{nargin, validateattributes, validatestring, varargin}
 ## @end deftypefn
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} addOptional (@var{argname}, @var{default})
 ## @deftypefnx {Function File} {} addOptional (@var{argname}, @var{default}, @var{validator})
 ## Add new optional argument to the object @var{parser} of the class inputParser
-## to implement an ordered arguments type of API 
+## to implement an ordered arguments type of API
 ##
 ## @var{argname} must be a string with the name of the new argument.  The order
 ## in which new arguments are added with @command{addOptional}, represents the
 ## expected order of arguments.
 ##
 ## @var{default} will be the value used when the argument is not specified.
 ##
 ## @var{validator} is an optional anonymous function to validate the given
@@ -510,17 +510,17 @@ endclassdef
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
 
 ## check optional is skipped and considered ParamValue if unvalidated string
 %!test
 %! p = create_p ();
 %! p.parse ("file", "line", "circle");
 %! r = p.Results;
-%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line}, 
+%! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "val", 78,    false,     "circle"});
 
 ## check case insensitivity
 %!test
 %! p = create_p ();
 %!  p.CaseSensitive = false;
 %! p.parse ("file", "foo", 80, "LiNE", "circle", "vERbOSe");
 %! r = p.Results;
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -97,17 +97,17 @@
 ## xf = [0:0.05:10];
 ## yf = sin (2*pi*xf/5);
 ## xp = [0:10];
 ## yp = sin (2*pi*xp/5);
 ## lin = interp1 (xp, yp, xf);
 ## near = interp1 (xp, yp, xf, "nearest");
 ## pch = interp1 (xp, yp, xf, "pchip");
 ## spl = interp1 (xp, yp, xf, "spline");
-## plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xf,pch,"c", xf,spl,"m", 
+## plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xf,pch,"c", xf,spl,"m",
 ##       xp,yp,"r*");
 ## legend ("original", "nearest", "linear", "pchip", "spline");
 ## @end group
 ## @end example
 ##
 ## @seealso{pchip, spline, interpft, interp2, interp3, interpn}
 ## @end deftypefn
 
@@ -192,17 +192,17 @@ function yi = interp1 (x, y, varargin)
   ## check whether x is sorted; sort if not.
   if (! issorted (x, "either"))
     [x, p] = sort (x);
     y = y(p,:);
   endif
 
   if (any (strcmp (method, {"previous", "*previous", "next", "*next"})))
     rightcontinuous = NaN; # needed for these methods to work
-  endif 
+  endif
 
   if (isnan (rightcontinuous))
     ## If not specified, set the continuity condition
     if (x(end) < x(1))
       rightcontinuous = false;
     else
       rightcontinuous = true;
     endif
@@ -217,17 +217,17 @@ function yi = interp1 (x, y, varargin)
   ## by running "previous" with vectors flipped.
   if (strcmp (method, "next"))
     x = flipud (x);
     y = flipud (y);
     method = "previous";
   elseif (strcmp (method, "*next"))
     x = flipud (x);
     y = flipud (y);
-    method = "*previous";  
+    method = "*previous";
   endif
 
   starmethod = method(1) == "*";
 
   if (starmethod)
     dx = x(2) - x(1);
   else
     jumps = x(1:end-1) == x(2:end);
@@ -538,34 +538,34 @@ endfunction
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
 ## This test is expected to fail, so commented out.
 ## "previous" and "next" options are not symmetric w.r.t to flipping xp,yp
-#%!assert (interp1 (xp,yp,xi,style),... 
+#%!assert (interp1 (xp,yp,xi,style),...
 #%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 %!assert (interp1 (xp,[yp',yp'],xi,style),
 %!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
 %!test style = ["*",style];
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),... 
+# %!assert (interp1 (xp,yp,xi,style),...
 # %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
 %!test style = "next";
 ## BLOCK
@@ -573,34 +573,34 @@ endfunction
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),... 
+# %!assert (interp1 (xp,yp,xi,style),...
 # %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 %!assert (interp1 (xp,[yp',yp'],xi,style),
 %!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
 %!test style = ["*",style];
 %!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
 %!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
 %!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
 %!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
 %!assert (isempty (interp1 (xp',yp',[],style)))
 %!assert (isempty (interp1 (xp,yp,[],style)))
 %!assert (interp1 (xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
-# %!assert (interp1 (xp,yp,xi,style),... 
+# %!assert (interp1 (xp,yp,xi,style),...
 # %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
 %!test style = "linear";
 ## BLOCK
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -188,24 +188,24 @@ function ZI = interp2 (varargin)
     error ("interp2: X and Y must be matrices of equal size");
   endif
   if (columns (Z) != length (X) || rows (Z) != length (Y))
     error ("interp2: X and Y size must match the dimensions of Z");
   endif
   dx = diff (X);
   if (all (dx < 0))
     X = flipud (X);
-    Z = fliplr (Z); 
+    Z = fliplr (Z);
   elseif (any (dx <= 0))
     error ("interp2: X must be strictly monotonic");
   endif
   dy = diff (Y);
   if (all (dy < 0))
     Y = flipud (Y);
-    Z = flipud (Z); 
+    Z = flipud (Z);
   elseif (any (dy <= 0))
     error ("interp2: Y must be strictly monotonic");
   endif
 
   if (any (strcmp (method, {"nearest", "linear", "pchip", "cubic"})))
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -188,51 +188,51 @@ endfunction
 %! vi = interp3 (x, y, z, v, xxi, yyi, zzi);
 %! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
 %! vi2 = interpn (y, x, z, v, xxi, yyi, zzi);
 %! assert (vi, vi2, 10*eps);
 
 %!test  # meshgridded xi, yi, zi
 %! x = z = 1:2;  y = 1:3;
 %! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
-%! xi = zi = .6:1.6;  yi = 1; 
+%! xi = zi = .6:1.6;  yi = 1;
 %! [xxi3, yyi3, zzi3] = meshgrid (xi, yi, zi);
 %! [xxi, yyi, zzi] = ndgrid (yi, xi, zi);
 %! vi = interp3 (x, y, z, v, xxi3, yyi3, zzi3, "nearest");
 %! vi2 = interpn (y, x, z, v, xxi, yyi, zzi, "nearest");
 %! assert (vi, vi2);
 
 %!test  # vector xi, yi, zi
 %! x = z = 1:2;  y = 1:3;
 %! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
-%! xi = zi = .6:1.6;  yi = 1; 
+%! xi = zi = .6:1.6;  yi = 1;
 %! vi = interp3 (x, y, z, v, xi, yi, zi, "nearest");
 %! vi2 = interpn (y, x, z, v, yi, xi, zi,"nearest");
 %! assert (vi, vi2);
 
 %!test  # vector xi+1 with extrap value
 %! x = z = 1:2;  y = 1:3;
 %! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
-%! xi = zi = .6:1.6;  yi = 1; 
+%! xi = zi = .6:1.6;  yi = 1;
 %! vi = interp3 (x, y, z, v, xi+1, yi, zi, "nearest", 3);
 %! vi2 = interpn (y, x, z, v, yi, xi+1, zi, "nearest", 3);
 %! assert (vi, vi2);
 
 %!test  # input value matrix--no x,y,z
 %! x = z = 1:2;  y = 1:3;
 %! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
-%! xi = zi = .6:1.6;  yi = 1; 
+%! xi = zi = .6:1.6;  yi = 1;
 %! vi = interp3 (v, xi, yi, zi, "nearest");
 %! vi2 = interpn (v, yi, xi, zi,"nearest");
 %! assert (vi, vi2);
 
 %!test  # input value matrix--no x,y,z, with extrap value
 %! x = z = 1:2;  y = 1:3;
 %! v = ones ([3,2,2]);  v(:,2,1) = [7;5;4];  v(:,1,2) = [2;3;5];
-%! xi = zi = .6:1.6;  yi = 1; 
+%! xi = zi = .6:1.6;  yi = 1;
 %! vi = interp3 (v, xi, yi, zi, "nearest", 3);
 %! vi2 = interpn (v, yi, xi, zi, "nearest", 3);
 %! assert (vi, vi2);
 
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -62,19 +62,19 @@ endfunction
 
 ## test all numeric built-in primitives
 %!assert (isequal (false, logical (0), char (0),
 %!                 int8 (0), int16 (0), int32 (0), int64 (0),
 %!                 uint8 (0), uint16 (0), uint32 (0), uint64 (0),
 %!                 double (0), single (0),
 %!                 double (complex (0,0)), single (complex (0,0))),
 %!        true)
-%!assert (isequal (true, logical (1), char (1), 
-%!                 int8 (1), int16 (1), int32 (1), int64 (1), 
-%!                 uint8 (1), uint16 (1), uint32 (1), uint64 (1), 
+%!assert (isequal (true, logical (1), char (1),
+%!                 int8 (1), int16 (1), int32 (1), int64 (1),
+%!                 uint8 (1), uint16 (1), uint32 (1), uint64 (1),
 %!                 double (1), single (1),
 %!                 double (complex (1,0)), single (complex (1,0))),
 %!        true)
 
 ## test characters and strings
 %!assert (isequal ('a', "a"), true)
 %!assert (isequal ("abab", ["a", "b", "a", "b"]), true)
 %!assert (isequal (["a","b","c","d"], ["a","b","c","d"]), true)
@@ -96,17 +96,17 @@ endfunction
 %!assert (isequal (struct ("a",1), struct ("b",1)), false)
 %!assert (isequal (struct ("a",1,"b",2), struct ("a",1,"b",2)), true)
 %!assert (isequal (struct ("a",1,"b",2), struct ("b",2,"a",1)), true)
 %!assert (isequal (struct ("a",1,"b",2), struct ("a",1,"b",2),
 %!                 struct ("a",1,"b",2)), true)
 %!assert (isequal (struct ("a","abc","b",2), struct ("a","abc","b",2)), true)
 
 ## recursive structure
-%!test  
+%!test
 %! x.a = "a1";
 %! x.b.a = "ba1";
 %! x.b.b = "bb1";
 %! assert (isequal (x, x, x), true);
 %! y = x;
 %! y.b.b = "bb2";
 %! assert (isequal (x, y), false);
 %! y = x;
@@ -150,16 +150,16 @@ endfunction
 %!assert (isequal (eye (300), speye (300)), true)
 %!assert (isequal (sparse (0,1), sparse (1,0)), false)
 
 ## test NaN
 %!assert (isequal (NaN, NaN), false)
 %!assert (isequal (NaN, Inf), false)
 %!assert (isequal (NaN, 1.0), false)
 %!assert (isequal ([1,2,NaN,4], [1,2,NaN,4]), false)
-%!assert (isequal (struct ("a",NaN,"b",2), struct ("a",NaN,"b",2), 
+%!assert (isequal (struct ("a",NaN,"b",2), struct ("a",NaN,"b",2),
 %!                 struct ("a",NaN,"b",2)), false)
 
 ## test input validation
 %!error isequal ()
 %!error isequal (1)
 %!error isequal ([1,1])
 
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -117,17 +117,17 @@ function t = __isequal__ (nans_compare_e
 
     elseif (iscell (x))
       ## Check that each element of a cell is equal.
       l_x = numel (x);
       idx = 0;
       while (t && idx < l_x)
         idx++;
         args = cell (1, 2+l_v);
-        args(1:2) = {nans_compare_equal, x{idx}}; 
+        args(1:2) = {nans_compare_equal, x{idx}};
         args(3:end) = [cellindexmat(varargin, idx){:}];
 
         t = __isequal__ (args{:});
       endwhile
 
     elseif (ischar (x) && all (cellfun ("isclass", varargin, "char")))
       ## Sizes are equal already, so we can just make everything into a
       ## row and test the rows.
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -148,17 +148,17 @@ function [vx, vy] = voronoi (varargin)
     poutside = (1:rows (p)) ...
         (p(:, 1) < xmin - xdelta | p(:, 1) > xmax + xdelta | ...
          p(:, 2) < ymin - ydelta | p(:, 2) > ymax + ydelta);
     edgeoutside = ismember (edges(1, :), poutside) & ...
                   ismember (edges(2, :), poutside);
     edges(:, edgeoutside) = [];
   else
     ## look for the edge between the two given points
-    for edge = edges(1:2,:) 
+    for edge = edges(1:2,:)
       if (det ([[[1;1],p(edge,1:2)];1,x(1),y(1)])
           * det ([[[1;1],p(edge,1:2)];1,x(2),y(2)]) < 0)
         edges = edge;
         break;
       endif
     endfor
     ## Use larger plot limits to make it more likely single bisector is shown.
     xdelta = ydelta = max (xdelta, ydelta);
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -228,23 +228,23 @@ endfunction
 %!   nx = 64; ny = 64;
 %!   cdata = rand (ny, nx)*127;
 %!   hi = image (cdata);             # x/ydatamode is auto
 %!   assert (get (hi, "xdata"), [1 nx])
 %!   assert (get (hi, "ydata"), [1 ny])
 %!   set (hi, "cdata", cdata(1:2:end, 1:2:end))
 %!   assert (get (hi, "xdata"), [1 nx/2])
 %!   assert (get (hi, "ydata"), [1 ny/2])
-%! 
+%!
 %!   set (hi, "xdata", [10 100])     # xdatamode is now manual
 %!   set (hi, "ydata", [10 1000])    # ydatamode is now manual
 %!   set (hi, "cdata", cdata)
 %!   assert (get (hi, "xdata"), [10 100])
 %!   assert (get (hi, "ydata"), [10 1000])
-%! 
+%!
 %!   set (hi, "ydata", [])           # ydatamode is now auto
 %!   set (hi, "cdata", cdata(1:2:end, 1:2:end))
 %!   assert (get (hi, "xdata"), [10 100])
 %!   assert (get (hi, "ydata"), [1 ny/2])
 %! unwind_protect_cleanup
 %!   close (hf)
 %! end_unwind_protect
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -261,19 +261,19 @@ endfunction
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "uint32"))
 %!error <TrueColor image must be uint8> imshow (ones (3,3,3, "int16"))
 %!error <expecting MxN or MxNx3 matrix> imshow (ones (4,4,4))
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   fail ("imshow ([1,1], [2 0 0])", "invalid colormap MAP");
-%!   fail ("imshow ([1,1], [1 0 0 0])", "argument number 2 is invalid"); 
-%!   fail ('imshow ([1,1], "colormap", [2 0 0])', "invalid colormap"); 
-%!   fail ('imshow ([1,1], "xdata", ones (2,2))', "xdata must be a vector"); 
-%!   fail ('imshow ([1,1], "ydata", ones (2,2))', "ydata must be a vector"); 
+%!   fail ("imshow ([1,1], [1 0 0 0])", "argument number 2 is invalid");
+%!   fail ('imshow ([1,1], "colormap", [2 0 0])', "invalid colormap");
+%!   fail ('imshow ([1,1], "xdata", ones (2,2))', "xdata must be a vector");
+%!   fail ('imshow ([1,1], "ydata", ones (2,2))', "ydata must be a vector");
 %!   fail ('imshow ([1,1], "foobar")', "warning", "unrecognized property foobar")
-%!   fail ("imshow ([1,1], {1})", "argument number 2 is invalid"); 
+%!   fail ("imshow ([1,1], {1})", "argument number 2 is invalid");
 %!   fail ("imshow ([1+i,1-i])", "warning", "only showing real part of complex image");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -86,17 +86,17 @@ endfunction
 %!assert (ergb, rgb)
 %!assert (ergb, reshape ([r(:) g(:) b(:)], [size(img) 3]))
 %!test
 %! ## test correction for integers
 %! img = uint8 (img - 1);
 %! [rgb] = ind2rgb (img, map);
 %! assert (ergb, rgb);
 %!test
-%! ## Check that values below lower bound are mapped to first color value 
+%! ## Check that values below lower bound are mapped to first color value
 %! rgb = ind2rgb ([-1 0 2], gray (64));
 %! assert (rgb(:,1:2,:), zeros (1,2,3));
 %! assert (rgb(:,3,:), 1/63 * ones (1,1,3));
 
 %% Test input validation
 %!error ind2rgb ()
 %!error ind2rgb (1,2,3)
 %!error <X must be an indexed image> ind2rgb (ones (3,3,3), jet (64))
diff --git a/scripts/linear-algebra/bandwidth.m b/scripts/linear-algebra/bandwidth.m
--- a/scripts/linear-algebra/bandwidth.m
+++ b/scripts/linear-algebra/bandwidth.m
@@ -19,21 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{bw} =} bandwidth (@var{A}, @var{type})
 ## @deftypefnx {Function File} {[@var{lower}, @var{upper}] =} bandwidth (@var{A})
 ## Compute the bandwidth of @var{A}.
 ##
 ## The @var{type} argument is the string @qcode{"lower"} for the lower
 ## bandwidth and @qcode{"upper"} for the upper bandwidth.
 ## If no @var{type} is specified return both the lower and upper bandwidth
-## of @var{A}. 
+## of @var{A}.
 ##
 ## The lower/upper bandwidth of a matrix is the number of
 ## subdiagonals/superdiagonals with nonzero entries.
-## 
+##
 ## @seealso{isbanded, isdiag, istril, istriu}
 ## @end deftypefn
 
 ## Author: Massimiliano Fasi
 
 function [lower, upper] = bandwidth (A, type)
 
   if (! ((nargin == 1 && nargout == 2) || (nargin == 2 && nargout <= 1)))
diff --git a/scripts/linear-algebra/isbanded.m b/scripts/linear-algebra/isbanded.m
--- a/scripts/linear-algebra/isbanded.m
+++ b/scripts/linear-algebra/isbanded.m
@@ -35,17 +35,17 @@ function retval = isbanded (A, lower, up
   endif
 
   if (! isreal (lower) || ! isreal (upper) || lower < 0 || upper < 0)
     error ("isbanded: LOWER and UPPER must be non-negative integers");
   endif
 
   if (isempty (A))
     retval = [];
-  else 
+  else
     retval = (isnumeric (A) || islogical (A)) && ndims (A) == 2;
     if (retval)
       [i, j] = find (A);
       pupp = j >= i;
       retval = all (j(pupp) - i(pupp) <= upper);
       if (retval)
         plow = i >= j;
         retval = all (i(plow) - j(plow) <= lower);
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -21,17 +21,17 @@
 ## @deftypefn  {Function File} {@var{filelist} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{filelist} =} bzip2 (@var{files}, @var{dir})
 ## Compress the list of files specified in @var{files}.
 ##
 ## @var{files} is a character array or cell array of strings.  Shell
 ## wildcards in the filename such as @samp{*} or @samp{?} are accepted and
 ## expanded.  Each file is compressed separately and a new file with a
 ## @file{".bz2"} extension is created.  The original files are not modified,
-## but existing compressed files will be silently overwritten. 
+## but existing compressed files will be silently overwritten.
 ##
 ## If @var{dir} is defined the compressed files are placed in this directory,
 ## rather than the original directory where the uncompressed file resides.
 ## If @var{dir} does not exist it is created.
 ##
 ## The optional output @var{filelist} is a list of the compressed files.
 ## @seealso{bunzip2, unpack, gzip, zip, tar}
 ## @end deftypefn
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cast (@var{val}, "@var{type}")
 ## Convert @var{val} to data type @var{type}.
 ##
 ## @var{val} must be one of the numeric classes:
-## 
+##
 ## @example
 ## @group
 ## "double"
 ## "single"
 ## "logical"
 ## "char"
 ## "int8"
 ## "int16"
@@ -65,17 +65,17 @@ function retval = cast (val, type)
 
   if (! ischar (type))
     error ("cast: TYPE must be a string");
   elseif (! any (strcmp (type, {"int8"; "uint8"; "int16"; "uint16";
                                 "int32"; "uint32"; "int64"; "uint64";
                                 "double"; "single"; "logical"; "char"})))
     error ("cast: TYPE '%s' is not a built-in type", type);
   endif
-    
+
   retval = feval (type, val);
 
 endfunction
 
 
 %!assert (cast (single (2.5), "double"), 2.5)
 %!assert (cast (2.5, "single"), single (2.5))
 %!assert (cast ([5 0 -5], "logical"), [true false true])
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -132,17 +132,17 @@ endfunction
 
 %!test
 %! unwind_protect
 %!   f1 = tempname;
 %!   tmp_var = pi;
 %!   save (f1, "tmp_var");
 %!   f2 = tempname;
 %!   assert (copyfile (f1, f2));
-%!   assert (exist (f2, "file")); 
+%!   assert (exist (f2, "file"));
 %!   fid = fopen (f1, "rb");
 %!   assert (fid >= 0);
 %!   orig_data = fread (fid);
 %!   fclose (fid);
 %!   fid = fopen (f2, "rb");
 %!   assert (fid >= 0);
 %!   new_data = fread (fid);
 %!   fclose (fid);
@@ -155,10 +155,10 @@ endfunction
 %! end_unwind_protect
 
 ## Test input validation
 %!error copyfile ()
 %!error copyfile (1)
 %!error copyfile (1,2,3,4)
 %!error <F1 must be a string> copyfile (1, "foobar")
 %!error <F2 must be a string> copyfile ("foobar", 1)
-%!error <F2 must be a directory> copyfile ({"a", "b"}, "%_NOT_A_DIR_%") 
+%!error <F2 must be a directory> copyfile ({"a", "b"}, "%_NOT_A_DIR_%")
 
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -75,21 +75,21 @@ endfunction
 %!   delete (file);
 %!   assert (! exist (file, "file"));
 %! unwind_protect_cleanup
 %!   unlink (file);
 %! end_unwind_protect
 
 %!test
 %! unwind_protect
-%!   hf = figure ("visible", "off"); 
+%!   hf = figure ("visible", "off");
 %!   hl = plot (1:10);
-%!   assert (get (gca, "children"), hl); 
+%!   assert (get (gca, "children"), hl);
 %!   delete (hl);
-%!   assert (get (gca, "children"), zeros (0,1)); 
+%!   assert (get (gca, "children"), zeros (0,1));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %% Test input validation
 %!error delete ()
 %!error <first argument must be a filename> delete (struct ())
 
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -106,14 +106,14 @@ endfunction
 %!test
 %! if (ispc)
 %!   assert (fullfile ('\/\/\//A:/\/\', "x/", "/", "/", "y", "/", "/"), ...
 %!           ['A:\' xfsyfs]);
 %! endif
 
 %% Windows specific - drive letters and file sep type, cell array
 %!test
-%! if (ispc) 
+%! if (ispc)
 %!  tmp = fullfile ({"\\\/B:\//", "A://c", "\\\C:/g/h/i/j\/"});
 %!  assert (tmp{1}, 'B:\');
 %!  assert (tmp{2}, 'A:\c');
 %!  assert (tmp{3}, 'C:\g\h\i\j\');
 %! endif
\ No newline at end of file
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -35,23 +35,23 @@
 function value = getappdata (h, name)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! all (ishandle (h(:))))
     error ("getappdata: H must be a scalar or vector of graphic handles");
-  endif 
+  endif
 
   if (nargin == 2)
     if (! ischar (name))
       error ("getappdata: NAME must be a string");
     endif
-    
+
     ## FIXME: Is there a better way to handle non-existent appdata
     ##        and missing fields?
     value = cell (numel (h), 1);
     appdata = struct ();
     for i = 1:numel (h)
       try
         appdata = get (h(i), "__appdata__");
       end_try_catch
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{filelist} =} gunzip (@var{gzfile})
 ## @deftypefnx {Function File} {@var{filelist} =} gunzip (@var{gzfile}, @var{dir})
 ## Unpack the gzip archive @var{gzfile}.
 ##
 ## If @var{gzfile} is a directory, all gzfiles in the directory will be
-## recursively unpacked.  
+## recursively unpacked.
 ##
 ## If @var{dir} is specified the files are unpacked in this directory rather
 ## than the one where @var{gzfile} is located.
 ##
 ## The optional output @var{filelist} is a list of the uncompressed files.
 ## @seealso{gzip, unpack, bunzip2, unzip, untar}
 ## @end deftypefn
 
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -33,17 +33,17 @@ function valid = isappdata (h, name)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! all (ishandle (h(:))))
     error ("isappdata: H must be a scalar or vector of graphic handles");
   elseif (! ischar (name))
     error ("isappdata: NAME must be a string");
-  endif 
+  endif
 
   valid = false (size (h));
   for i = 1:numel (h)
     try
       appdata = get (h(i), "__appdata__");
       if (isfield (appdata, name))
         valid(i) = true;
       endif
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -65,17 +65,17 @@ function retval = ls (varargin)
     error ("ls: all arguments must be character strings");
   endif
 
   if (nargin > 0)
     args = tilde_expand (varargin);
     if (ispc () && ! isunix ())
       idx = ! strncmp (args, '/', 1);
       ## Enclose paths, potentially having spaces, in double quotes:
-      args(idx) = strcat ('"', args(idx), '"');    
+      args(idx) = strcat ('"', args(idx), '"');
       ## shell (cmd.exe) on MinGW uses '^' as escape character
       args = regexprep (args, '([^\w.*?])', '^$1');
     else
       ## Escape any special characters in filename
       args = regexprep (args, '([^][\w.*?-])', '\\$1');
       ## Undo escaped spaces following command args
       ## Only used for command form where single str contains many args.
       ## Example: list = ls ("-l /usr/bin")
@@ -117,14 +117,14 @@ endfunction
 %! if (isunix ())
 %!   list = ls ("/");
 %!   list = (list')(:)';   # transform to a single row vector
 %!   assert (! isempty (strfind (list, "sbin")));
 %!   list2 = ls ("-l /");
 %!   list2 = (list2')(:)';   # transform to a single row vector
 %!   assert (! isempty (strfind (list2, "sbin")));
 %!   assert (rows (list) == rows (list2));
-%! endif 
+%! endif
 
 %!error <all arguments must be character strings> ls (1)
 ## Test below is valid, but produces confusing output on screen
 %!#error <command exited abnormally> ls ("-!")
 
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} mex [options] file @dots{}
 ## Compile source code written in C, C++, or Fortran, to a MEX file.
-## 
+##
 ## This is equivalent to @code{mkoctfile --mex [options] file}.
 ## @seealso{mkoctfile, mexext}
 ## @end deftypefn
 
 function retval = mex (varargin)
 
   [output, status] = mkoctfile ("--mex", varargin{:});
 
@@ -33,11 +33,11 @@ function retval = mex (varargin)
   endif
   if (nargout > 0)
     retval = status;
   endif
 
 endfunction
 
 
-## Remove from test statistics.  All real tests are in mkoctfile. 
+## Remove from test statistics.  All real tests are in mkoctfile.
 %!assert (1)
 
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -142,28 +142,28 @@ endfunction
 %!   tmp_var = pi;
 %!   save (f1, "tmp_var");
 %!   fid = fopen (f1, "rb");
 %!   assert (fid >= 0);
 %!   orig_data = fread (fid);
 %!   fclose (fid);
 %!   f2 = tempname;
 %!   assert (movefile (f1, f2));
-%!   assert (! exist (f1, "file")); 
-%!   assert (exist (f2, "file")); 
+%!   assert (! exist (f1, "file"));
+%!   assert (exist (f2, "file"));
 %!   fid = fopen (f2, "rb");
 %!   assert (fid >= 0);
 %!   new_data = fread (fid);
 %!   fclose (fid);
 %!   if (orig_data != new_data)
 %!     error ("moved file not equal to original file!");
 %!   endif
 %! unwind_protect_cleanup
 %!   delete (f2);
 %! end_unwind_protect
 
 ## Test input validation
 %!error movefile ()
 %!error movefile (1,2,3,4)
 %!error <F1 must be a string> movefile (1, "foobar")
 %!error <F2 must be a string> movefile ("foobar", 1)
-%!error <F2 must be a directory> movefile ({"a", "b"}, "%_NOT_A_DIR_%") 
+%!error <F2 must be a directory> movefile ({"a", "b"}, "%_NOT_A_DIR_%")
 
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -25,17 +25,17 @@
 ## Return a @emph{copy} of @var{s1} with fields arranged alphabetically, or as
 ## specified by the second input.
 ##
 ## Given one input struct @var{s1}, arrange field names alphabetically.
 ##
 ## If a second struct argument is given, arrange field names in @var{s1} as they
 ## appear in @var{s2}.  The second argument may also specify the order in a
 ## cell array of strings @var{cellstr}.  The second argument may also be a
-## permutation vector. 
+## permutation vector.
 ##
 ## The optional second output argument @var{p} is the permutation vector which
 ## converts the original name order to the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -45,17 +45,17 @@ function retval = recycle (state)
   if (nargin == 0 || nargout > 0)
     retval = current_state;
   endif
 
   if (nargin == 1)
     if (! ischar (state))
       error ("recycle: STATE must be a character string");
     endif
-    
+
     if (strcmpi (state, "on"))
       error ("recycle: recycling files is not implemented");
     elseif (strcmpi (state, "off"))
       current_state = "off";
     else
       error ("recycle: invalid value of STATE = '%s'", state);
     endif
   endif
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -47,17 +47,17 @@ function rmappdata (h, varargin)
   for hg = h
     if (isprop (hg, "__appdata__"))
       appdata = get (hg, "__appdata__");
       vld = isfield (appdata, varargin);
       if (! all (vld))
         ## FIXME: Should we bother to error out?  Or just silently continue?
         missing = varargin{find (! vld, 1)};
         error ("rmappdata: appdata '%s' is not present", missing);
-      endif 
+      endif
       appdata = rmfield (appdata, varargin);
       set (hg, "__appdata__", appdata);
     endif
   endfor
 
 endfunction
 
 
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -68,17 +68,17 @@
 ##     scalar structure containing the fields:
 ##       baz =  42
 ##       foo =
 ##         scalar structure containing the fields:
 ##           bar =  54
 ## @end group
 ## @end example
 ##
-## The example begins with an ordinary scalar structure to which a nested 
+## The example begins with an ordinary scalar structure to which a nested
 ## scalar structure is added.  In all cases, if the structure index @var{sidx}
 ## is not specified it defaults to 1 (scalar structure).  Thus, the example
 ## above could be written more concisely as
 ## @code{setfield (@var{s}, "foo", "bar", 54)}
 ##
 ## Finally, an example with nested structure arrays:
 ##
 ## @example
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -36,20 +36,20 @@
 ##      [2,1] = y
 ##    @}
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function vars = symvar (str)
   vars = argnames (inline (str));
-  ## Correct for auto-generated 'x' variable when no symvar was found. 
+  ## Correct for auto-generated 'x' variable when no symvar was found.
   if (numel (vars) == 1 && strcmp (vars{1}, "x") && ! any (str == "x"))
     vars = {};
-  endif 
+  endif
 
 endfunction
 
 
 %!assert (symvar ("3*x + 4*y + 5*cos (z)"), {"x"; "y"; "z"})
 %!assert (symvar ("sin()^2 + cos()^2 == 1"), {})
 %!assert (symvar ("1./x"), {"x"})
 
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -49,17 +49,17 @@ function filelist = tar (tarfile, files,
     files = cellstr (files);
   elseif (! iscellstr (files))
     error ("tar: FILES must be a character array or cellstr");
   endif
 
   rootdir = tilde_expand (rootdir);
 
   tarfile = make_absolute_filename (tarfile);
-       
+
   cmd = sprintf ("tar cvf %s -C %s %s",
                           tarfile, rootdir, sprintf (" %s", files{:}));
 
   [status, output] = system (cmd);
 
   if (status)
     error ("tar: tar exited with status = %d", status);
   endif
@@ -84,21 +84,21 @@ endfunction
 %!   chdir (dirname);
 %!   dirname2 = "dir2";
 %!   assert (mkdir (dirname2));
 %!   fname1 = "f1";
 %!   fname2 = fullfile (dirname2, "f2");
 %!   fid = fopen (fname1, "wt");
 %!   assert (fid >= 0);
 %!   fdisp (fid, "Hello World");
-%!   fclose (fid); 
+%!   fclose (fid);
 %!   fid = fopen (fname2, "wt");
 %!   assert (fid >= 0);
 %!   fdisp (fid, "Goodbye World");
-%!   fclose (fid); 
+%!   fclose (fid);
 %!   tarname = [tempname ".tar"];
 %!   filelist = tar (tarname, {dirname2, fname1});
 %!   if (! strcmp (filelist{3}, fname1))
 %!     error ("tar file contents does not match expected file");
 %!   endif
 %!   if (! exist (tarname, "file"))
 %!     error ("tar archive file cannot be found!");
 %!   endif
diff --git a/scripts/miscellaneous/tmpnam.m b/scripts/miscellaneous/tmpnam.m
--- a/scripts/miscellaneous/tmpnam.m
+++ b/scripts/miscellaneous/tmpnam.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{fname} =} tmpnam ()
 ## @deftypefnx {Function File} {@var{fname} =} tmpnam (@var{dir})
 ## @deftypefnx {Function File} {@var{fname} =} tmpnam (@var{dir}, @var{prefix})
 ## Return a unique temporary file name as a string.
-## 
+##
 ## If @var{prefix} is omitted, a value of @qcode{"oct-"} is used.
 ## If @var{dir} is also omitted, the default directory for temporary files
 ## (@code{P_tmpdir} is used.  If @var{dir} is provided, it must exist,
 ## otherwise the default directory for temporary files is used.
 ##
 ## Programming Note: Because the named file is not opened by @code{tmpnam},
 ## it is possible, though relatively unlikely, that it will not be available
 ## by the time your program attempts to open it.  If this is a concern,
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -189,17 +189,17 @@ function filelist = unpack (file, dir = 
   else
     nodotext = ext(ext != '.');
   endif
 
   if (isfield (commandlist, tolower (nodotext)))
     [commandv, commandq, parsefcn, move] = deal (commandlist.(nodotext){:});
     origdir = pwd ();
     if (move)
-      startdir = fileparts (file); 
+      startdir = fileparts (file);
     else
       startdir = origdir;
     endif
     cstartdir = canonicalize_file_name (startdir);
     cenddir = canonicalize_file_name (dir);
     needmove = move && ! strcmp (cstartdir, cenddir);
     if (nargout > 0 || needmove)
       command = commandv;
@@ -301,17 +301,17 @@ endfunction
 %! fprintf (fid, "Hello World\n");
 %! fprintf (fid, "123 456 789\n");
 %! fclose (fid);
 %! unwind_protect
 %!   copyfile (filename, [filename ".orig"]);
 %!   gzip (filename, dirname);
 %!   [~, f] = fileparts (filename);
 %!   filelist = unpack (fullfile (dirname, [f ".gz"]), P_tmpdir);
-%!   assert (filelist{1}, filename); 
+%!   assert (filelist{1}, filename);
 %!   fid = fopen ([filename ".orig"], "rb");
 %!   assert (fid >= 0);
 %!   orig_data = fread (fid);
 %!   fclose (fid);
 %!   fid = fopen (filename, "rb");
 %!   assert (fid >= 0);
 %!   new_data = fread (fid);
 %!   fclose (fid);
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -93,17 +93,17 @@ function retval = ver (package = "")
                        "Release", [], "Date", []);
       for i = 1:numel (lst)
         retval(end+1) = struct ("Name", lst{i}.name, "Version", lst{i}.version,
                                 "Release", [], "Date", lst{i}.date);
       endfor
     elseif (strcmpi (package, "Octave"))
       retval = struct ("Name", "Octave", "Version", version,
                        "Release", [], "Date", []);
-    else 
+    else
       lst = pkg ("list", package);
       if (isempty (lst))
         retval = struct ("Name", "", "Version", [],
                          "Release", [], "Date", []);
       else
         retval = struct ("Name", lst{1}.name, "Version", lst{1}.version,
                          "Release", [], "Date", lst{1}.date);
       endif
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -101,17 +101,17 @@ function retval = what (dir)
   w.packages = cell (0, 1);
 
   for i = 1 : length (files)
     n = files{i};
     ## Ignore . and ..
     if (strcmp (n, ".") || strcmp (n, ".."))
       continue;
     else
-      ## Ignore mdl, slx, p, and packages since they are not  
+      ## Ignore mdl, slx, p, and packages since they are not
       [~, f, e] = fileparts (n);
       if (strcmp (e, ".m"))
         w.m{end+1} = n;
       elseif (strcmp (e, ".mat"))
         w.mat{end+1} = n;
       elseif (strcmp (e, ".oct"))
         w.oct{end+1} = n;
       elseif (strcmp (e, mexext ()))
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -57,17 +57,17 @@ function z = xor (x, y, varargin)
     print_usage ();
   endif
 
   z = __xor__ (x, y);
 
   ## Slow expansion to multiple arguments.
   ## Probably okay number of elements ## will be small.
   if (! isempty (varargin))
-    for i = 1:numel (varargin) 
+    for i = 1:numel (varargin)
       z = __xor__ (z, varargin{i});
     endfor
   endif
 
 endfunction
 
 function z = __xor__ (x, y)
 
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -45,21 +45,21 @@ function filelist = zip (zipfile, files,
 
   if (! ischar (zipfile))
     error ("zip: ZIPFILE must be a string");
   elseif (ischar (files))
     files = cellstr (files);
   elseif (! iscellstr (files))
     error ("zip: FILES must be a character array or cellstr");
   endif
-  
+
   rootdir = tilde_expand (rootdir);
 
   zipfile = make_absolute_filename (zipfile);
-       
+
   cmd = sprintf ("cd %s; zip -r %s %s",
                      rootdir,   zipfile, sprintf (" %s", files{:}));
 
   [status, output] = system (cmd);
 
   if (status)
     error ("zip: zip failed with exit status = %d", status);
   endif
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -65,17 +65,17 @@ function [x, fval, info, output] = fminb
     x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8,
                   "OutputFcn", [], "FunValCheck", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
-  
+
   if (xmin > xmax)
     error ("Octave:invalid-input-arg",
            "fminbnd: the lower bound cannot be greater than the upper one");
   endif
 
   if (ischar (fun))
     fun = str2func (fun, "global");
   endif
@@ -283,13 +283,13 @@ endfunction
 
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
 %!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt (eps))
 %!assert (fminbnd (@(x) abs (x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt (eps))
 %!assert (fminbnd (@(x) x^2 + sin (2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos (2*pi*x), [0.4, 1], opt0), sqrt (eps))
-%!assert (fminbnd (@(x) x > 0.3, 0, 1) < 0.3) 
-%!assert (fminbnd (@(x) sin (x), 0, 0), 0, eps) 
+%!assert (fminbnd (@(x) x > 0.3, 0, 1) < 0.3)
+%!assert (fminbnd (@(x) sin (x), 0, 0), 0, eps)
 
 %!error <lower bound cannot be greater> fminbnd (@(x) sin (x), 0, -pi)
 
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -124,27 +124,27 @@
 ##
 ## The eighth argument @var{tol} specifies the tolerance for the
 ## stopping criteria.  The default value is @code{sqrt (eps)}.
 ##
 ## The value returned in @var{info} may be one of the following:
 ##
 ## @table @asis
 ## @item 101
-## The algorithm terminated normally. 
+## The algorithm terminated normally.
 ## All constraints meet the specified tolerance.
 ##
 ## @item 102
 ## The BFGS update failed.
 ##
 ## @item 103
 ## The maximum number of iterations was reached.
 ##
 ## @item 104
-## The stepsize has become too small, i.e., 
+## The stepsize has become too small, i.e.,
 ## @tex
 ## $\Delta x,$
 ## @end tex
 ## @ifnottex
 ## delta @var{x},
 ## @end ifnottex
 ## is less than @code{@var{tol} * norm (x)}.
 ## @end table
diff --git a/scripts/path/private/getsavepath.m b/scripts/path/private/getsavepath.m
--- a/scripts/path/private/getsavepath.m
+++ b/scripts/path/private/getsavepath.m
@@ -39,15 +39,15 @@ function [filelines, startline, endline]
         endline = linenum;
       endif
     endwhile
     if (fclose (fid) < 0)
       error ("getsavepath: could not close file after reading, %s", file);
     endif
   endif
 
-  ## Verify the file was correctly formatted. 
+  ## Verify the file was correctly formatted.
   if (startline > endline || (startline > 0 && endline == 0))
     error ("getsavepath: unable to parse file, %s", file);
   endif
 
 endfunction
 
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -41,17 +41,17 @@
 
 ## Author: Bill Denney <bill@givebillmoney.com>
 
 function retval = savepath (file)
 
   beginstring = "## Begin savepath auto-created section, do not edit";
   endstring   = "## End savepath auto-created section";
 
-  ## Use project-specific or user's .octaverc when no file specified 
+  ## Use project-specific or user's .octaverc when no file specified
   if (nargin == 0)
     file = fullfile (pwd, ".octaverc");
     if (! exist (file, "file"))
       file = fullfile ("~", ".octaverc");
     endif
   endif
 
   ## Read in the file
@@ -192,17 +192,17 @@ endfunction
 %! assert (status == 0);
 %! old_dir = pwd;
 %! unwind_protect
 %!   cd (P_tmpdir);
 %!   if (exist (fullfile (pwd, ".octaverc")))
 %!     unlink (".octaverc");
 %!   endif
 %!   ## Create blank .octaverc file
-%!   fid = fopen (".octaverc", "wt"); 
+%!   fid = fopen (".octaverc", "wt");
 %!   assert (fid >= 0);
 %!   fclose (fid);
 %!   ## Save path into local .octaverc file
 %!   warning ("off", "Octave:savepath-local");
 %!   status = savepath ();
 %!   assert (status == 0);
 %!   ## Compare old and new versions
 %!   fid = fopen (fname, "rb");
@@ -211,10 +211,10 @@ endfunction
 %!   fclose (fid);
 %!   fid = fopen (".octaverc", "rb");
 %!   assert (fid >= 0);
 %!   new_data = fread (fid);
 %!   fclose (fid);
 %!   assert (orig_data, new_data);
 %! unwind_protect_cleanup
 %!   cd (old_dir);
-%! end_unwind_protect 
+%! end_unwind_protect
 
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -124,17 +124,17 @@
 ## Show the list of currently installed packages.  For example,
 ##
 ## @example
 ## pkg list
 ## @end example
 ##
 ## @noindent
 ## will produce a short report with the package name, version, and installation
-## directory for each installed package.  Supply a package name to limit 
+## directory for each installed package.  Supply a package name to limit
 ## reporting to a particular package.  For example:
 ##
 ## @example
 ## pkg list image
 ## @end example
 ##
 ## If a single return argument is requested then @code{pkg} returns a cell
 ## array where each element is a structure with information on a single
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -103,17 +103,17 @@ function [out1, out2] = installed_packag
     return;
   endif
 
   ## Compute the maximal lengths of name, version, and dir.
   h1 = "Package Name";
   h2 = "Version";
   h3 = "Installation directory";
   max_name_length = max ([length(h1), cellfun(@length, installed_names)]);
-  version_lengths = cellfun (@(x) length (x.version), installed_pkgs_lst); 
+  version_lengths = cellfun (@(x) length (x.version), installed_pkgs_lst);
   max_version_length = max ([length(h2), version_lengths]);
   ncols = terminal_size ()(2);
   max_dir_length = ncols - max_name_length - max_version_length - 7;
   if (max_dir_length < 20)
     max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -80,17 +80,17 @@ function [ax, h1, h2] = plotyy (varargin
       hax = get (hax, "__plotyy_axes__");
     else
       hax(2) = axes ("nextplot", get (hax(1), "nextplot"));
     endif
 
     [axtmp, h1tmp, h2tmp] = __plotyy__ (hax, varargin{:});
 
     set (gcf, "currentaxes", hax(1));
-     
+
   unwind_protect_cleanup
     if (! isempty (oldfig))
       set (0, "currentfigure", oldfig);
     endif
   end_unwind_protect
 
   if (nargout > 0)
     ax = axtmp;
diff --git a/scripts/plot/draw/polar.m b/scripts/plot/draw/polar.m
--- a/scripts/plot/draw/polar.m
+++ b/scripts/plot/draw/polar.m
@@ -286,19 +286,19 @@ function __update_patch__ (hax, ~, hg)
 
 endfunction
 
 function __update_layer__ (hax,  ~, hg)
 
   set (hg, "handlevisibility", "on");
   kids = get (hax, "children");
   if (strcmp (get (hax, "layer"), "bottom"))
-    set (hax, "children", [kids(kids != hg); hg]); 
+    set (hax, "children", [kids(kids != hg); hg]);
   else
-    set (hax, "children", [hg; kids(kids != hg)]); 
+    set (hax, "children", [hg; kids(kids != hg)]);
   endif
   set (hg, "handlevisibility", "off");
 
 endfunction
 
 function __update_polar_grid__ (hax, ~, hg)
 
   ## Delete existing polar grid
diff --git a/scripts/plot/draw/private/__quiver__.m b/scripts/plot/draw/private/__quiver__.m
--- a/scripts/plot/draw/private/__quiver__.m
+++ b/scripts/plot/draw/private/__quiver__.m
@@ -114,17 +114,17 @@ function hg = __quiver__ (varargin)
 
   ## Scale the arrows to fit in the grid
   uu = u;
   vv = v;
   if (is3d)
     ww = w;
     len = max (sqrt (u(:).^2 + v(:).^2 + w(:).^2));
   else
-    len = max (sqrt (u(:).^2 + v(:).^2));      
+    len = max (sqrt (u(:).^2 + v(:).^2));
   endif
   if (len > 0 && autoscale && numel (u) > 1)
     if (isvector (x))
       nx = ny = sqrt (length (x));
     else
       [ny, nx] = size (x);  # assume meshgrid fmt, x in columns, y in rows
     endif
     dx = (max (x(:)) - min (x(:))) / nx;
diff --git a/scripts/plot/draw/private/__scatter__.m b/scripts/plot/draw/private/__scatter__.m
--- a/scripts/plot/draw/private/__scatter__.m
+++ b/scripts/plot/draw/private/__scatter__.m
@@ -80,19 +80,19 @@ function hg = __scatter__ (varargin)
                 || strcmpi (varargin{istart}, "fill")))
     c = varargin{istart};
     firstnonnumeric++;
   else
     c = [];
   endif
 
   ## Validate inputs
-  if (nd == 2 && ! size_equal (x, y)) 
+  if (nd == 2 && ! size_equal (x, y))
     error ([fcn ": X and Y must have the same size"]);
-  elseif (nd == 3 && ! size_equal (x, y, z)) 
+  elseif (nd == 3 && ! size_equal (x, y, z))
     error ([fcn ": X, Y, and Z must have the same size"]);
   endif
 
   if (! isscalar (s) && ! size_equal (x, s))
     error ([fcn ": size of S must match X, Y, and Z"]);
   endif
 
   if (rows (c) > 1 && rows (c) != rows (x))
diff --git a/scripts/plot/draw/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/draw/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -44,17 +44,17 @@ function h = __stem__ (have_z, varargin)
   unwind_protect
     hax = newplot (hax);
     hold_state = get (hax, "nextplot");
     set (hax, "nextplot", "add");
 
     h = [];
     nx = rows (x);
     h_baseline = [];
-    
+
     for i = 1 : columns (x)
       if (have_z)
         xt = x(:)';
         xt = [xt; xt; NaN(1, nx)](:);
         yt = y(:)';
         yt = [yt; yt; NaN(1, nx)](:);
         zt = z(:)';
         zt = [zeros(1, nx); zt; NaN(1, nx)](:);
@@ -91,17 +91,17 @@ function h = __stem__ (have_z, varargin)
       if (have_z)
         __line__ (hax, xt, yt, zt, "color", lc, "linestyle", ls, "parent", hg);
         __line__ (hax, x, y, z, "color", mc, "linestyle", "none",
                        "marker", ms, "markerfacecolor", fc, "parent", hg);
       else
         __line__ (hax, xt, yt, "color", lc, "linestyle", ls, "parent", hg);
         __line__ (hax, x(:,i), y(:, i), "color", mc, "linestyle", "none",
                        "marker", ms, "markerfacecolor", fc, "parent", hg);
-        
+
         x_axis_range = get (hax, "xlim");
         if (isempty (h_baseline))
           h_baseline = line (hax, x_axis_range, [0, 0], "color", [0, 0, 0]);
           set (h_baseline, "handlevisibility", "off", "xliminclude", "off");
           addproperty ("basevalue", h_baseline, "data", 0);
         else
           set (h_baseline, "xdata", x_axis_range);
         endif
@@ -154,17 +154,17 @@ function h = __stem__ (have_z, varargin)
     ## baseline listeners
     if (! isempty (h_baseline))
       addlistener (hax, "xlim", @update_xlim);
       for hg = h'
         addlistener (hg, "showbaseline", @show_baseline);
         addlistener (hg, "visible", {@show_baseline, h});
         addlistener (hg, "basevalue", @move_baseline);
       endfor
-      
+
       addlistener (h_baseline, "basevalue", {@update_baseline, 0});
       addlistener (h_baseline, "ydata", {@update_baseline, 1});
       addlistener (h_baseline, "visible", {@update_baseline, 2});
       set (h_baseline, "parent", get (hg(1), "parent"));
     endif
 
     ## property/value pairs
     if (! isempty (args))
diff --git a/scripts/plot/draw/surface.m b/scripts/plot/draw/surface.m
--- a/scripts/plot/draw/surface.m
+++ b/scripts/plot/draw/surface.m
@@ -170,17 +170,17 @@ function [h, bad_usage] = __surface__ (a
     case 1
       x = 1:3;
       y = x';
       c = z = eye (3);
 
     otherwise
       bad_usage = true;
       return;
-  
+
   endswitch
 
   if (firststring < nargin)
     other_args = varargin(firststring:end);
   else
     other_args = {};  # make a default surface object.
   endif
   h = __go_surface__ (ax, "xdata", x, "ydata", y, "zdata", z, "cdata", c,
diff --git a/scripts/plot/draw/surfnorm.m b/scripts/plot/draw/surfnorm.m
--- a/scripts/plot/draw/surfnorm.m
+++ b/scripts/plot/draw/surfnorm.m
@@ -30,17 +30,17 @@
 ## @var{y} values.  If only a single input @var{z} is given then @var{x} is
 ## taken to be @code{1:rows (@var{z})} and @var{y} is
 ## @code{1:columns (@var{z})}.
 ##
 ## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.
 ##
 ## Any property/value input pairs are assigned to the surface object.
-## 
+##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## If output arguments are requested then the components of the normal
 ## vectors are returned in @var{nx}, @var{ny}, and @var{nz} and no plot is
 ## made.
 ##
 ## An example of the use of @code{surfnorm} is
@@ -138,18 +138,18 @@ function [Nx, Ny, Nz] = surfnorm (vararg
         set (hax, "nextplot", "add");
 
         ## FIXME: Scale unit normals by data aspect ratio in order for
         ##        normals to appear correct.
         ##daratio = daspect (hax);
         ##daspect ("manual");
         ##len = norm (daratio);
         ## This assumes an even meshgrid which isn't a great assumption
-        ##dx = x(1,2) - x(1,1);  
-        ##dy = y(2,1) - y(1,1);  
+        ##dx = x(1,2) - x(1,1);
+        ##dy = y(2,1) - y(1,1);
         ##nx *= daratio(1);
         ##ny *= daratio(2);
         ##nz *= daratio(3);
         ##len = sqrt (nx.^2 + ny.^2 + nz.^2);
         ##nx ./= len;
         ##ny ./= len;
         ##nz ./= len;
         plot3 ([x(:).'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
diff --git a/scripts/plot/util/copyobj.m b/scripts/plot/util/copyobj.m
--- a/scripts/plot/util/copyobj.m
+++ b/scripts/plot/util/copyobj.m
@@ -42,17 +42,17 @@ function hnew = copyobj (horig, hparent 
     hparent = figure (fix (hparent));
   elseif (! any (strcmpi (get (hparent).type, partypes)))
     print_usage ();
   endif
 
   ## current figure and axes
   cf = gcf ();
   ca = get (cf, "currentaxes");
-  
+
   ## compatibility of input handles
   kididx = find (strcmp (alltypes, get (horig).type));
   paridx = find (strcmp (alltypes, get (hparent).type));
 
   if (kididx <= paridx)
     error ("copyobj: %s object can't be children to %s.",
            alltypes{kididx}, alltypes{paridx});
   elseif (nargin == 1)
@@ -163,17 +163,17 @@ endfunction
 %!   assert (map1, map2);
 %!   assert (alpha1, alpha2);
 %! unwind_protect_cleanup
 %!   close (h1);
 %!   close (h2);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%!test 
+%!test
 %! unwind_protect
 %!   tag = "foo";
 %!   hf = figure ("visible", "off");
 %!   hax = axes ("tag", tag);
 %!   hpa = patch ();
 %!   set (hpa, "facecolor", [.5 .5 .5], "tag", tag)
 %!   hax2 = copyobj (hax, hf);
 %!   assert (get (hax2, "tag"), tag)
diff --git a/scripts/plot/util/hgload.m b/scripts/plot/util/hgload.m
--- a/scripts/plot/util/hgload.m
+++ b/scripts/plot/util/hgload.m
@@ -42,26 +42,26 @@ function h = hgload (filename)
     elseif (isempty (file_in_loadpath (filename)))
       error ("hgload: unable to locate file %s", filename);
     endif
   else
     if (isempty (file_in_loadpath (filename)))
       error ("hgload: unable to locate file %s", filename);
     endif
   endif
-    
+
   ## Load the handle
   try
     stmp = load (filename, "s_oct40");
   catch
     error ("hgload: could not load hgsave-formatted object in file %s", filename);
   end_try_catch
 
   h = struct2hdl (stmp.s_oct40);
-  
+
 endfunction
 
 
 ## Functional test for hgload/hgsave pair is in hgsave.m
 
 %% Test input validation
 %!error hgload ()
 %!error hgload (1, 2)
diff --git a/scripts/plot/util/hgsave.m b/scripts/plot/util/hgsave.m
--- a/scripts/plot/util/hgsave.m
+++ b/scripts/plot/util/hgsave.m
@@ -18,19 +18,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hgsave (@var{filename})
 ## @deftypefnx {Function File} {} hgsave (@var{h}, @var{filename})
 ## @deftypefnx {Function File} {} hgsave (@var{h}, @var{filename}, @var{fmt})
 ## Save the graphics handle @var{h} to the file @var{filename} in the format
 ## @var{fmt}.
 ##
-## If unspecified, @var{h} is the current figure as returned by @code{gcf}. 
+## If unspecified, @var{h} is the current figure as returned by @code{gcf}.
 ## When @var{filename} does not have an extension the default filename
-## extension @file{.ofig} will be appended.  If present, @var{fmt} should 
+## extension @file{.ofig} will be appended.  If present, @var{fmt} should
 ## should be one of the following:
 ##
 ## @itemize @bullet
 ## @item @option{-binary}, @option{-float-binary}
 ##
 ## @item @option{-hdf5}, @option{-float-hdf5}
 ##
 ## @item @option{-V7}, @option{-v7}, @code{-7}, @option{-mat7-binary}
diff --git a/scripts/plot/util/isprop.m b/scripts/plot/util/isprop.m
--- a/scripts/plot/util/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{res} =} isprop (@var{obj}, "@var{prop}")
 ## Return true if @var{prop} is a property of the object @var{obj}.
 ##
 ## @var{obj} may also be an array of objects in which case @var{res} will be a
 ## logical array indicating whether each handle has the property @var{prop}.
-## 
+##
 ## For plotting, @var{obj} is a handle to a graphics object.  Otherwise,
 ## @var{obj} should be an instance of a class.
 ## @seealso{get, set, ismethod, isobject}
 ## @end deftypefn
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
 function res = isprop (h, prop)
diff --git a/scripts/plot/util/linkprop.m b/scripts/plot/util/linkprop.m
--- a/scripts/plot/util/linkprop.m
+++ b/scripts/plot/util/linkprop.m
@@ -68,19 +68,19 @@ function hlink = linkprop (h, prop)
 
   if (ischar (prop))
     prop = {prop};
   elseif (! iscellstr (prop))
     error ("linkprop: PROP must be a string or cell string array");
   endif
 
   h = h(:)';  # set() prefers column vectors
-  ## Match all objects to the first one in the list before linking 
+  ## Match all objects to the first one in the list before linking
   for j = 1 : numel (prop)
-    set (h(2:end), prop{j}, get (h(1), prop{j})); 
+    set (h(2:end), prop{j}, get (h(1), prop{j}));
   endfor
 
   ## Add listeners to all objects
   for i = 1 : numel (h)
     for j = 1 : numel (prop)
       addlistener (h(i), prop{j},
                    {@update_prop, [h(1:i-1),h(i+1:end)], prop{j}});
     endfor
diff --git a/scripts/plot/util/private/__go_draw_axes__.m b/scripts/plot/util/private/__go_draw_axes__.m
--- a/scripts/plot/util/private/__go_draw_axes__.m
+++ b/scripts/plot/util/private/__go_draw_axes__.m
@@ -770,17 +770,17 @@ function __go_draw_axes__ (h, plot_strea
                color = [0, 1, 0];
              endif
 
              if (nd == 3 && numel (xcol) == 3)
                if (isnan (ccdat))
                  ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
                  addedcmap = [addedcmap; reshape(color, 1, 3)];
                elseif (numel (ccdat) <= 1)
-                 ccdat = zcol;  
+                 ccdat = zcol;
                endif
                data{data_3d_idx} = [data{data_3d_idx}, ...
                                     [[xcol; xcol(end)], [ycol; ycol(end)], ...
                                     [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
              else
                if (mono)
                  colorspec = "";
                elseif (__gnuplot_has_feature__ ("transparent_patches")
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}] =} setdiff (@dots{})
 ## Return the elements in @var{a} that are not in @var{b} sorted in
 ## ascending order.
 ##
 ## If @var{a} and @var{b} are both column vectors return a column vector;
 ## Otherwise, return a row vector.  The inputs may also be cell arrays of
 ## strings.
 ##
-## If the optional input @qcode{"rows"} is given then return the rows in 
+## If the optional input @qcode{"rows"} is given then return the rows in
 ## @var{a} that are not in @var{b}.  The inputs must be 2-D matrices to use
 ## this option.
 ##
 ## If requested, return the index vector @var{ia} such that
 ## @code{@var{c} = @var{a}(@var{ia})}.
 ## @seealso{unique, union, intersect, setxor, ismember}
 ## @end deftypefn
 
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -27,17 +27,17 @@
 ##
 ## If @var{a} and @var{b} are both column vectors return a column vector;
 ## Otherwise, return a row vector.  The inputs may also be cell arrays of
 ## strings.
 ##
 ## If the optional input @qcode{"rows"} is given then return rows that are in
 ## either @var{a} or @var{b}.  The inputs must be 2-D matrices to use this
 ## option.
-## 
+##
 ## The optional outputs @var{ia} and @var{ib} are index vectors such that
 ## @code{@var{a}(@var{ia})} and @code{@var{b}(@var{ib})} are disjoint sets
 ## whose union is @var{c}.
 ##
 ## @seealso{unique, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
 
 ## Author: jwe
@@ -83,17 +83,17 @@ endfunction
 ## Test multi-dimensional arrays
 %!test
 %! a = rand (3,3,3);
 %! b = a;
 %! b(1,1,1) = 2;
 %! assert (union (a, b), sort ([a(1:end), 2]));
 
 %!test
-%! a = [3, 1, 4, 1, 5]; 
+%! a = [3, 1, 4, 1, 5];
 %! b = [1, 2, 3, 4];
 %! [y, ia, ib] = union (a, b.');
 %! assert (y, [1, 2, 3, 4, 5]);
 %! assert (y, sort ([a(ia), b(ib)]));
 
 
 %% Test common input validation for set routines contained in validsetargs
 %!error <cell array of strings cannot be combined> union ({"a"}, 1)
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -39,17 +39,17 @@
 ##
 ## @item win
 ## window weight data.  If window is empty or unspecified a default rectangular
 ## window is used.  Otherwise, the window is applied to the signal
 ## (@code{@var{x} .* @var{win}}) before computing the periodogram.  The window
 ## data must be a vector of the same length as @var{x}.
 ##
 ## @item nfft
-## number of frequency bins.  The default is 256 or the next higher power of 
+## number of frequency bins.  The default is 256 or the next higher power of
 ## 2 greater than the length of @var{x}
 ## (@code{max (256, 2.^nextpow2 (length (x)))}).  If @var{nfft} is greater
 ## than the length of the input then @var{x} will be zero-padded to the length
 ## of @var{nfft}.
 ##
 ## @item Fs
 ## sampling rate.  The default is 1.
 ##
@@ -64,17 +64,17 @@
 ## is even and [0, pi) if @var{nfft} is odd.  Similarly, for a two-sided
 ## calculation @var{w} is in the range [0, 2*pi] or [0, 2*pi) depending on
 ## @var{nfft}.
 ##
 ## If a sampling frequency is specified, @var{Fs}, then the output frequencies
 ## @var{f} will be in the range [0, @var{Fs}/2] or [0, @var{Fs}/2) for
 ## one-sided calculations.  For two-sided calculations the range will be
 ## [0, @var{Fs}).
-## 
+##
 ## When called with no outputs the periodogram is immediately plotted in the
 ## current figure window.
 ## @seealso{fft}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute the periodogram
 
@@ -102,17 +102,17 @@ function [pxx, f] = periodogram (x, vara
       j++;
     endif
   endfor
 
   if (! isvector (x))
     error ("periodogram: X must be a real or complex vector");
   endif
   x = x(:);  # Use column vectors from now on
-  
+
   n = rows (x);
 
   if (! isempty (window))
     if (! isvector (window) || length (window) != n)
       error ("periodogram: WIN must be a vector of the same length as X");
     endif
     window = window(:);
     x .*= window;
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
--- a/scripts/sparse/eigs.m
+++ b/scripts/sparse/eigs.m
@@ -177,17 +177,17 @@
 ## are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The
 ## eigenvalues themselves are returned in @var{d} in the form of a
 ## @var{n}-by-@var{k} matrix, where the elements on the diagonal are the
 ## eigenvalues.
 ##
 ## Given a third return argument @var{flag}, @code{eigs} returns the status
 ## of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.
 ## Any other value indicates a failure to converge.
-## 
+##
 ## This function is based on the @sc{arpack} package, written by
 ## @nospell{R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang}.  For more
 ## information see @url{http://www.caam.rice.edu/software/ARPACK/}.
 ##
 ## @seealso{eig, svds}
 ## @end deftypefn
 
 function varargout = eigs (varargin)
diff --git a/scripts/sparse/ilu.m b/scripts/sparse/ilu.m
--- a/scripts/sparse/ilu.m
+++ b/scripts/sparse/ilu.m
@@ -1,11 +1,11 @@
 ## Copyright (C) 2014 Eduardo Ramos Fernndez <eduradical951@gmail.com>
 ## Copyright (C) 2013 Kai T. Ohlhus <k.ohlhus@gmail.com>
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} ilu (@var{A}, @var{opts})
 ## @deftypefnx {Function File} {[@var{L}, @var{U}] =} ilu (@dots{})
 ## @deftypefnx {Function File} {[@var{L}, @var{U}, @var{P}] =} ilu (@dots{})
 ##
 ## Compute the incomplete LU factorization of the sparse square matrix @var{A}.
 ##
 ## @code{ilu} returns a unit lower triangular matrix @var{L}, an upper
 ## triangular matrix @var{U}, and optionally a permutation matrix @var{P}, such
-## that @code{@var{L}*@var{U}} approximates @code{@var{P}*@var{A}}. 
+## that @code{@var{L}*@var{U}} approximates @code{@var{P}*@var{A}}.
 ##
 ## The factors given by this routine may be useful as preconditioners for a
 ## system of linear equations being solved by iterative methods such as BICG
 ## (BiConjugate Gradients) or GMRES (Generalized Minimum Residual Method).
 ##
 ## The factorization may be modified by passing options in a structure
 ## @var{opts}.  The option name is a field of the structure and the setting
 ## is the value of field.  Names and specifiers are case sensitive.
@@ -71,22 +71,22 @@
 ##
 ## @code{abs (@var{L}(i,j)) >= droptol * norm (@var{A}(:,j))/@var{U}(j,j)}.
 ##
 ## @item milu
 ## Modified incomplete LU factorization:
 ##
 ## @table @asis
 ## @item @qcode{"row"}
-## Row-sum modified incomplete LU factorization. 
+## Row-sum modified incomplete LU factorization.
 ## The factorization preserves row sums:
 ## @code{@var{A} * e = @var{L} * @var{U} * e}, where e is a vector of ones.
 ##
 ## @item @qcode{"col"}
-## Column-sum modified incomplete LU factorization. 
+## Column-sum modified incomplete LU factorization.
 ## The factorization preserves column sums:
 ## @code{e' * @var{A} = e' * @var{L} * @var{U}}.
 ##
 ## @item @qcode{"off"} (default)
 ## Row and column sums are not necessarily preserved.
 ## @end table
 ##
 ## @item udiag
@@ -95,17 +95,17 @@
 ## @code{droptol * norm (@var{A}(:,j))/@var{U}(j,j)}.  The default is false.
 ##
 ## @item thresh
 ## Pivot threshold for factorization.  It can range between 0 (diagonal
 ## pivoting) and 1 (default), where the maximum magnitude entry in the column
 ## is chosen to be the pivot.
 ## @end table
 ##
-## If @code{ilu} is called with just one output, the returned matrix is 
+## If @code{ilu} is called with just one output, the returned matrix is
 ## @code{@var{L} + @var{U} - speye (size (@var{A}))}, where @var{L} is unit
 ## lower triangular and @var{U} is upper triangular.
 ##
 ## With two outputs, @code{ilu} returns a unit lower triangular matrix @var{L}
 ## and an upper triangular matrix @var{U}.  For @var{opts}.type ==
 ## @qcode{"ilutp"}, one of the factors is permuted based on the value of
 ## @var{opts}.milu.  When @var{opts}.milu == @qcode{"row"}, @var{U} is a
 ## column permuted upper triangular factor.  Otherwise, @var{L} is a
@@ -137,18 +137,18 @@
 ## This shows that @var{A} has 7,840 nonzeros, the complete LU factorization has
 ## 126,478 nonzeros, and the incomplete LU factorization, with 0 level of
 ## fill-in, has 7,840 nonzeros, the same amount as @var{A}.  Taken from:
 ## http://www.mathworks.com/help/matlab/ref/ilu.html
 ##
 ## @example
 ## @group
 ## A = gallery ("wathen", 10, 10);
-## b = sum (A, 2); 
-## tol = 1e-8; 
+## b = sum (A, 2);
+## tol = 1e-8;
 ## maxit = 50;
 ## opts.type = "crout";
 ## opts.droptol = 1e-4;
 ## [L, U] = ilu (A, opts);
 ## x = bicg (A, b, tol, maxit, L, U);
 ## norm (A * x - b, inf)
 ## @end group
 ## @end example
@@ -169,17 +169,17 @@ function [L, U, P] = ilu (A, opts = stru
     error ("ichol: A must be a sparse square matrix");
   endif
 
   if (! isstruct (opts))
     error ("ichol: OPTS must be a structure.");
   endif
 
   ## If A is empty then return empty L, U and P for Matlab compatibility
-  if (isempty (A)) 
+  if (isempty (A))
     L = U = P = A;
     return;
   endif
 
   ## Parse input options
   if (! isfield (opts, "type"))
     opts.type = "nofill";  # set default
   else
@@ -318,69 +318,69 @@ endfunction
 %! n_small = 40;
 %! n_medium = 600;
 %! n_large = 10000;
 %! A_tiny = spconvert ([1 4 2 3 3 4 2 5; 1 1 2 3 4 4 5 5; 1 2 3 4 5 6 7 8]');
 %! A_small = sprand (n_small, n_small, 1/n_small) + speye (n_small);
 %! A_medium = sprand (n_medium, n_medium, 1/n_medium) + speye (n_medium);
 %! A_large = sprand (n_large, n_large, 1/n_large/10) + speye (n_large);
 %!
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_tiny);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), 0, n_tiny * eps);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_small);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), 0, 1);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_medium);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), 0, 1);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_large);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), 0, 1);
 %!
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_tiny, opts);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_small, opts);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_medium, opts);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_large, opts);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);
 %!
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_tiny, opts);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_small, opts);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_medium, opts);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_large, opts);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);
 
 ## Tests for complex matrices of different sizes for ilu0, iluc and ilutp.
 %!shared n_tiny, n_small, n_medium, n_large, A_tiny, A_small, A_medium, A_large
@@ -392,69 +392,69 @@ endfunction
 %! A_tiny(1,1) += 1i;
 %! A_small = sprand (n_small, n_small, 1/n_small) + ...
 %!   i * sprand (n_small, n_small, 1/n_small) + speye (n_small);
 %! A_medium = sprand (n_medium, n_medium, 1/n_medium) + ...
 %!   i * sprand (n_medium, n_medium, 1/n_medium) + speye (n_medium);
 %! A_large = sprand (n_large, n_large, 1/n_large/10) + ...
 %!   i * sprand (n_large, n_large, 1/n_large/10) + speye (n_large);
 %!
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_tiny);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), 0, n_tiny * eps);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_small);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), 0, 1);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_medium);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), 0, 1);
-%!test 
+%!test
 %! opts.type = "nofill";
 %! [L, U] = ilu (A_large);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), 0, 1);
 %!
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_tiny, opts);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_small, opts);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_medium, opts);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "crout";
 %! [L, U] = ilu (A_large, opts);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);
 %!
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_tiny, opts);
 %! assert (norm (A_tiny - L*U, "fro") / norm (A_tiny, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_small, opts);
 %! assert (norm (A_small - L*U, "fro") / norm (A_small, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_medium, opts);
 %! assert (norm (A_medium - L*U, "fro") / norm (A_medium, "fro"), eps, eps);
-%!test 
+%!test
 %! opts.type = "ilutp";
 %! opts.droptol = 0;
 %! opts.thresh = 0;
 %! [L, U] = ilu (A_large, opts);
 %! assert (norm (A_large - L*U, "fro") / norm (A_large, "fro"), eps, eps);
 
 ## Specific tests for ilutp
 
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -153,17 +153,17 @@ function [x, flag, relres, iter, resvec]
 
     if (nargin < 7 || isempty (x0))
       x = zeros (size (b));
     else
       x = x0;
     endif
 
     r = b - Ax (x);
-    
+
     bnorm = norm (b);
     res0 = norm (r);
     if (nargout > 4)
       resvec(1) = res0;
     endif
     vt = r;
 
     y = M1m1x (vt);
@@ -221,17 +221,17 @@ function [x, flag, relres, iter, resvec]
       endif
       x += d;
       r -= s;
 
       res1 = norm (r) / bnorm;
       if (nargout > 4)
         resvec(iter + 1, 1) = norm (r);
       end
-      
+
       if (res1 < tol)
         ## Convergence achieved.
         flag = 0;
         break;
       elseif (res0 <= res1)
         ## Stagnation encountered.
         flag = 3;
         break;
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -73,20 +73,20 @@ endfunction
 
 %% Test 4-input calling form
 %!test
 %! d = rand ();
 %! s1 = sprand (100, 100, d, 0.4);
 %! rc = [5, 4, 3, 2, 1, 0.1];
 %! s2 = sprand (100, 100, d, rc);
 %! s3 = sprand (6, 4, d, rc);
-%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps)); 
+%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
 %! assert (1/cond (s1), 0.4, sqrt (eps));
 %! assert (nnz (s1) / (100*100), d, 0.02);
-%! assert (nnz (s2) / (100*100), d, 0.02); 
+%! assert (nnz (s2) / (100*100), d, 0.02);
 %! assert (svd (s3)', [5 4 3 2], sqrt (eps));
 
 %% Test 1-input calling form
 %!test
 %! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j, v] = find (s);
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -31,17 +31,17 @@
 ##
 ## If called with a single matrix argument, a sparse matrix is generated with
 ## random values wherever the matrix @var{s} is nonzero.
 ##
 ## If called with a scalar fourth argument @var{rc}, a random sparse matrix
 ## with reciprocal condition number @var{rc} is generated.  If @var{rc} is
 ## a vector, then it specifies the first singular values of the generated
 ## matrix (@code{length (@var{rc}) <= min (@var{m}, @var{n})}).
-## 
+##
 ## @seealso{sprand, sprandsym, randn}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function s = sprandn (m, n, d, rc)
 
   if (nargin == 1 )
@@ -65,20 +65,20 @@ endfunction
 
 %% Test 4-input calling form
 %!test
 %! d = rand ();
 %! s1 = sprandn (100, 100, d, 0.4);
 %! rc = [5, 4, 3, 2, 1, 0.1];
 %! s2 = sprandn (100, 100, d, rc);
 %! s3 = sprandn (6, 4, d, rc);
-%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps)); 
+%! assert (svd (s2)'(1:length (rc)), rc, sqrt (eps));
 %! assert (1/cond (s1), 0.4, sqrt (eps));
-%! assert (nnz (s1) / (100*100), d, 0.02); 
-%! assert (nnz (s2) / (100*100), d, 0.02); 
+%! assert (nnz (s1) / (100*100), d, 0.02);
+%! assert (nnz (s2) / (100*100), d, 0.02);
 %! assert (svd (s3)', [5 4 3 2], sqrt (eps));
 
 %% Test 1-input calling form
 %!test
 %! s = sprandn (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j] = find (s);
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
-## Compute the Beta function for real inputs @var{a} and @var{b}. 
+## Compute the Beta function for real inputs @var{a} and @var{b}.
 ##
 ## The Beta function definition is
 ## @tex
 ## $$
 ##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @ifnottex
diff --git a/scripts/specfun/ellipke.m b/scripts/specfun/ellipke.m
--- a/scripts/specfun/ellipke.m
+++ b/scripts/specfun/ellipke.m
@@ -95,17 +95,17 @@ function [k, e] = ellipke (m, tol = [])
 
   sz = size (m);
   m = m(:);
   if (! isreal (m))
     error ("ellipke: M must be real");
   elseif (any (m > 1))
     error ("ellipke: M must be <= 1");
   endif
- 
+
   if (isempty (tol))
     tol = eps (class (m));
   elseif (! (isreal (tol) && isscalar (tol) && tol > 0))
     error ("ellipke: TOL must be a real scalar > 0")
   endif
 
   k = e = zeros (sz);
 
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -22,17 +22,17 @@
 ## Return a logical array which is true where the elements of @var{x} are
 ## prime numbers and false where they are not.
 ##
 ## A prime number is conventionally defined as a positive integer greater than
 ## 1 (e.g., 2, 3, @dots{}) which is divisible only by itself and 1.  Octave
 ## extends this definition to include both negative integers and complex
 ## values.  A negative integer is prime if its positive counterpart is prime.
 ## This is equivalent to @code{isprime (abs (x))}.
-## 
+##
 ## If @code{class (@var{x})} is complex, then primality is tested in the domain
 ## of Gaussian integers (@url{http://en.wikipedia.org/wiki/Gaussian_integer}).
 ## Some non-complex integers are prime in the ordinary sense, but not in the
 ## domain of Gaussian integers.  For example, @math{5 = (1+2i)*(1-2i)} shows
 ## that 5 is not prime because it has a factor other than itself and 1.
 ## Exercise caution when testing complex and real values together in the same
 ## matrix.
 ##
diff --git a/scripts/statistics/base/lscov.m b/scripts/statistics/base/lscov.m
--- a/scripts/statistics/base/lscov.m
+++ b/scripts/statistics/base/lscov.m
@@ -15,18 +15,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} lscov (@var{A}, @var{b})
 ## @deftypefnx {Function File} {@var{x} =} lscov (@var{A}, @var{b}, @var{V})
 ## @deftypefnx {Function File} {@var{x} =} lscov (@var{A}, @var{b}, @var{V}, @var{alg})
 ## @deftypefnx {Function File} {[@var{x}, @var{stdx}, @var{mse}, @var{S}] =} lscov (@dots{})
 ##
 ## Compute a generalized linear least squares fit.
-## Estimate @var{x} under the model @var{b} = @var{A}@var{x} + @var{w}, 
-## where the noise @var{w} is assumed to follow a normal distribution 
+## Estimate @var{x} under the model @var{b} = @var{A}@var{x} + @var{w},
+## where the noise @var{w} is assumed to follow a normal distribution
 ## with covariance matrix @math{{\sigma^2} V}.
 ##
 ## If the size of the coefficient matrix @var{A} is n-by-p, the
 ## size of the vector/array of constant terms @var{b} must be n-by-k.
 ##
 ## The optional input argument @var{V} may be a n-by-1 vector of positive
 ## weights (inverse variances), or a n-by-n symmetric positive
 ## semidefinite matrix representing the covariance of @var{b}.  If
@@ -50,62 +50,62 @@
 
 ## Author: Nir Krakauer
 
 function [x, stdx, mse, S] = lscov (A, b, V = [], alg)
 
   if (nargin < 2 || (rows (A) != rows (b)))
     print_usage ();
   endif
-  
+
   n = rows (A);
   p = columns (A);
   k = columns (b);
-  
+
   if (! isempty (V))
     if (rows (V) != n || ! any (columns (V) == [1 n]))
       error ("lscov: V should be a square matrix or a vector with the same number of rows as A");
     endif
-    
+
     if (isvector (V))
       ## n-by-1 vector of inverse variances
       v = diag (sqrt (V));
       A = v * A;
       b = v * b;
     else
       ## n-by-n covariance matrix
       try
         ## ordinarily V will be positive definite
         B = chol (V)';
       catch
         ## if V is only positive semidefinite, use its
         ## eigendecomposition to find a factor B such that V = B*B'
         [B, lambda] = eig (V);
         image_dims = (diag (lambda) > 0);
         B = B(:, image_dims) * sqrt (lambda(image_dims, image_dims));
-      end_try_catch     
+      end_try_catch
       A = B \ A;
       b = B \ b;
     endif
   endif
-  
+
   pinv_A = pinv (A); #pseudoinverse
 
   x = pinv_A * b;
-  
+
   if (isargout (3))
     dof = n - p; #degrees of freedom remaining after fit
     SSE = sumsq (b - A * x);
     mse = SSE / dof;
   endif
-  
+
   s = pinv_A * pinv_A';
 
   stdx = sqrt (diag (s) * mse);
-  
+
   if (isargout (4))
     if (k == 1)
       S = mse * s;
     else
       S = nan (p, p, k);
       for i = 1:k
         S(:, :, i) = mse(i) * s;
       endfor
@@ -145,26 +145,26 @@ endfunction
 %! alpha = 0.05;
 %! [b, stdb, mse] = lscov (X, y);
 %! assert(b, V(:,1), 3e-6);
 %! assert(stdb, V(:,2), -1.e-5);
 %! assert(sqrt (mse), rsd, -1E-6);
 
 %!test
 %! ## Adapted from example in Matlab documentation
-%! x1 = [.2 .5 .6 .8 1.0 1.1]'; 
-%! x2 = [.1 .3 .4 .9 1.1 1.4]'; 
-%! X = [ones(size(x1)) x1 x2]; 
+%! x1 = [.2 .5 .6 .8 1.0 1.1]';
+%! x2 = [.1 .3 .4 .9 1.1 1.4]';
+%! X = [ones(size(x1)) x1 x2];
 %! y = [.17 .26 .28 .23 .27 .34]';
 %! [b, se_b, mse, S] = lscov(X, y);
 %! assert(b, [0.1203 0.3284 -0.1312]', 1E-4);
 %! assert(se_b, [0.0643 0.2267 0.1488]', 1E-4);
 %! assert(mse, 0.0015, 1E-4);
 %! assert(S, [0.0041 -0.0130 0.0075; -0.0130 0.0514 -0.0328; 0.0075 -0.0328 0.0221], 1E-4);
-%! w = [1 1 1 1 1 .1]'; 
+%! w = [1 1 1 1 1 .1]';
 %! [bw, sew_b, msew] = lscov (X, y, w);
 %! assert(bw, [0.1046 0.4614 -0.2621]', 1E-4);
 %! assert(sew_b, [0.0309 0.1152 0.0814]', 1E-4);
 %! assert(msew, 3.4741e-004, -1E-4);
 %! V = .2*ones(length(x1)) + .8*diag(ones(size(x1)));
 %! [bg, sew_b, mseg] = lscov (X, y, V);
 %! assert(bg, [0.1203 0.3284 -0.1312]', 1E-4);
 %! assert(sew_b, [0.0672 0.2267 0.1488]', 1E-4);
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -125,17 +125,17 @@ function print_test_file_name (nm)
 endfunction
 
 function print_pass_fail (p, n, xf, sk)
   if ((n + sk) > 0)
     printf (" PASS   %4d/%-4d", p, n);
     nfail = n - p - xf;
     if (nfail > 0)
       printf ("\n%71s %3d", "FAIL ", nfail);
-    endif    
+    endif
     if (sk > 0)
       printf ("\n%71s %3d", "SKIP ", sk);
     endif
     if (xf > 0)
       printf ("\n%71s %3d", "XFAIL", xf);
     endif
   endif
   puts ("\n");
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -43,17 +43,17 @@
 ## reporting.  Tests which require user interaction, i.e., demo blocks,
 ## are never run in batch mode.
 ##
 ## Batch mode is enabled by either 1) specifying a logfile using the third
 ## argument @var{fname} or @var{fid}, or 2) requesting an output argument
 ## such as @var{success}, @var{n}, etc.
 ##
 ## The optional second argument determines the amount of output to generate and
-## which types of tests to run.  The default value is @qcode{"normal"}. 
+## which types of tests to run.  The default value is @qcode{"normal"}.
 ## Requesting an output argument will suppress printing the final summary
 ## message and any intermediate warnings, unless verbose reporting is
 ## enabled.
 ##
 ## @table @asis
 ## @item @qcode{"quiet"}
 ## Print a summary message when all tests pass, or print an error with the
 ## results of the first bad test when a failure occurs.  Don't run tests which
@@ -93,17 +93,17 @@
 ## PASSES 5 out of 5 tests
 ##
 ## [n, nmax] = test ("sind")
 ## @result{}
 ## n =  5
 ## nmax =  5
 ## @end group
 ## @end example
-## 
+##
 ## Additional Calling Syntaxes
 ##
 ## If the second argument is the string @qcode{"grabdemo"}, the contents of
 ## any built-in demo blocks are extracted but not executed.  The text for all
 ## code blocks is concatenated and returned as @var{code} with @var{idx} being
 ## a vector of positions of the ends of each demo block.  For an easier way to
 ## extract demo blocks from files, @xref{XREFexample,,example}.
 ##
@@ -524,17 +524,17 @@ function [__n, __nmax, __nxfail, __nskip
         ## Code already processed.
         __code = "";
 
 ### TESTIF
 
       elseif (strcmp (__type, "testif"))
         __e = regexp (__code, '.$', 'lineanchors', 'once');
         ## Strip any comment from testif line before looking for features
-        __feat_line = strtok (__code(1:__e), '#%'); 
+        __feat_line = strtok (__code(1:__e), '#%');
         __feat = regexp (__feat_line, '\w+', 'match');
         __feat = strrep (__feat, "HAVE_", "");
         __have_feat = __have_feature__ (__feat);
         if (__have_feat)
           __istest = true;
           __code = __code(__e + 1 : end);
         else
           __xskip++;
@@ -639,17 +639,17 @@ function [__n, __nmax, __nxfail, __nskip
       __successes += __success && (__istest || __isxtest);
 
     unwind_protect_cleanup
       warning ("off", "all");
       warning (orig_wstate);
     end_unwind_protect
   endfor
 
-  ## Clear any functions created during test run 
+  ## Clear any functions created during test run
   eval (__clearfcn, "");
 
   if (nargout == 0)
     if (__tests || __xfail || __xskip)
       if (__xfail)
         printf ("PASSES %d out of %d test%s (%d expected failure%s)\n",
                 __successes, __tests, ifelse (__tests > 1, "s", ""),
                 __xfail, ifelse (__xfail > 1, "s", ""));
@@ -799,24 +799,24 @@ endfunction
 ## Now verify test() itself
 
 ## Test 'fail' keyword
 %!fail ("test", "Invalid call to test")  # no args, generates usage()
 %!fail ("test (1,2,3,4)", "usage.*test") # too many args, generates usage()
 %!fail ('test ("test", "bogus")', "unknown flag")  # incorrect args
 %!fail ('garbage','garbage.*undefined')  # usage on nonexistent function should be
 
-## Test 'error' keyword 
+## Test 'error' keyword
 %!error test              # no args, generates usage()
 %!error test (1,2,3,4)    # too many args, generates usage()
 %!error <unknown flag> test ("test", "bogus"); # incorrect args
 %!error test ("test", "bogus");  # test without pattern
 %!error <'garbage' undefined> garbage; # usage on nonexistent function is error
 
-## Test 'warning' keyword 
+## Test 'warning' keyword
 %!warning warning ("warning message");   # no pattern
 %!warning <warning message> warning ("warning message");   # with pattern
 
 ## Test 'shared' keyword
 %!shared a                # create a shared variable
 %!test a = 3;             # assign to a shared variable
 %!test assert (a, 3)      # variable should equal 3
 %!shared b,c              # replace shared variables
@@ -829,60 +829,60 @@ endfunction
 %!test c=6;               # update a value
 %!test assert ([a,b,c], [1,2,6]); # show that the update sticks
 %!shared                  # clear all shared variables
 %!test assert (!exist ("a", "var")) # show that they are cleared
 %!shared a,b,c            # support for initializer shorthand
 %! a=1; b=2; c=4;
 %!shared                  # clear all shared variables for remainder of tests
 
-## Test 'function' keyword 
+## Test 'function' keyword
 %!function x = __test_a (y)
 %! x = 2*y;
 %!endfunction
 %!assert (__test_a (2), 4)  # Test a test function
 
 %!function __test_a (y)
 %! x = 2*y;
 %!endfunction
 %!test
 %! __test_a (2);            # Test a test function with no return value
 
 %!function [x,z] = __test_a (y)
 %! x = 2*y;
 %! z = 3*y;
 %!endfunction
-%!test                      
+%!test
 %! [x,z] = __test_a (3);    # Test a test function with multiple returns
 %! assert (x,6);
 %! assert (z,9);
 
-## Test 'assert' keyword 
+## Test 'assert' keyword
 %!assert (isempty ([]))     # support for test assert shorthand
 %!assert (size (ones (1,2,3)), [1 2 3])
 
-## Test 'demo' keyword 
+## Test 'demo' keyword
 %!demo                      # multiline demo block
 %! t = [0:0.01:2*pi]; x = sin (t);
 %! plot (t,x);
 %! % you should now see a sine wave in your figure window
 
 %!demo a=3                  # single line demo blocks work too
 
 %!test
 %! [code, idx] = test ("test", "grabdemo");
 %! assert (numel (idx), 4);
 %! assert (code(idx(3):end),
 %!         " a=3                  # single line demo blocks work too");
 
-## Test 'testif' keyword 
+## Test 'testif' keyword
 %!testif HAVE_BOGUS_FEATURE
 %! error ("testif executed code despite not having feature");
 
-## Test 'xtest' keyword 
+## Test 'xtest' keyword
 %!xtest
 %! assert (1, 1);      # Test passes
 %!xtest
 %! assert (0, 1);      # Test fails
 
 ## Test comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
