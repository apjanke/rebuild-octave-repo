# HG changeset patch
# User jwe
# Date 1110999292 0
#      Wed Mar 16 18:54:52 2005 +0000
# Node ID 32c569794216f27ba66c10daf5b5ae98064a2f97
# Parent  eecc24b92d97776524dcfd741bc1c4a30fb7329d
[project @ 2005-03-16 18:54:42 by jwe]

diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -276,38 +276,17 @@ 1 2 2 2 2 5 3 2 8
 1 3 1 2 3 4 3 3 7
 @end example
 @end ifinfo
 
 @noindent
 but not @code{rand (5, 30)}.
 @end deffn
 
-@deffn {Command} gset options
-@deffnx {Command} gshow options
-@deffnx {Command} replot options
-In addition to the basic plotting commands, the whole range of
-@code{gset} and @code{gshow} commands from @code{gnuplot} are available,
-as is @code{replot}.
-
-@findex set
-@findex show
-Note that in Octave 2.0, the @code{set} and @code{show} commands were
-renamed to @code{gset} and @code{gshow} in order to allow for
-compatibility with the @sc{Matlab} graphics and GUI commands in a future
-version of Octave.  (For now, the old @code{set} and @code{show}
-commands do work, but they print an annoying warning message to try to
-get people to switch to using @code{gset} and @code{gshow}.)
-
-The @code{gset} and @code{gshow} commands allow you to set and show
-@code{gnuplot} parameters.  For more information about the @code{gset}
-and @code{gshow} commands, see the documentation for @code{set} and
-@code{show} in the @code{gnuplot} user's guide (also available on line
-if you run @code{gnuplot} directly, instead of running it from Octave).
-
+@deffn {Command} replot options
 The @code{replot} command allows you to force the plot to be
 redisplayed.  This is useful if you have changed something about the
 plot, such as the title or axis labels.  The @code{replot} command also
 accepts the same arguments as @code{gplot} or @code{gsplot} (except for
 data ranges) so you can add additional lines to existing plots.  
 
 For example,
 
@@ -332,18 +311,17 @@ to the plot, and force the new plot to b
 sent to the plot device.  This last step is normally required in order
 to update the plot.  This default is reasonable for slow terminals or
 hardcopy output devices because even when you are adding additional
 lines with a replot command, gnuplot always redraws the entire plot, and
 you probably don't want to have a completely new plot generated every
 time something as minor as an axis label changes.
 
 @findex shg
-The command @code{shg} is equivalent to executing @code{replot} without
-any arguments.
+The command @code{shg} is equivalent to executing @code{replot}.
 @end deffn
 
 Note that NaN values in the plot data are automatically omitted, and
 Inf values are converted to a very large value before calling gnuplot.
 
 @c XXX FIXME XXX -- add info about what to do to get plots on remote X
 @c terminals.  People often forget how to properly set DISPLAY and run
 @c xhost.
@@ -351,18 +329,16 @@ Inf values are converted to a very large
 
 @node Interaction with gnuplot
 @section Interaction with @code{gnuplot}
 
 @DOCSTRING(gnuplot_binary)
 
 @DOCSTRING(gnuplot_has_frames)
 
-@DOCSTRING(graw)
-
 @DOCSTRING(gnuplot_command_plot)
 
 @DOCSTRING(gnuplot_command_replot)
 
 @DOCSTRING(gnuplot_command_splot)
 
 @DOCSTRING(gnuplot_command_using)
 
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,20 +1,29 @@
 2005-03-16  John W. Eaton  <jwe@octave.org>
 
-	* __axis_label__.m, __errplot__.m, __plt__.m, axis.m, bar.m,
-	bottom_title.m, contour.m, errorbar.m, figure.m, grid.m, loglog.m,
-	loglogerr.m, mesh.m, meshgrid.m, mplot.m, multiplot.m, oneplot.m,
-	plot.m, plot_border.m, polar.m, semilogx.m, semilogxerr.m,
-	semilogy.m, semilogyerr.m, shg.m, stairs.m, subplot.m,
-	subwindow.m, title.m, top_title.m, xlabel.m: Use __gplot__ instead
-	of gplot, __gsplot__ instead of gsplot, __gset__ instead of gset.
-	Remove gplot, gsplot from @seealso docs.
-
-2005-03-16  John W. Eaton  <jwe@octave.org>
+	* control/base/__stepimp__.m, control/base/bode.m,
+	control/base/frdemo.m, control/base/nichols.m,
+	control/base/nyquist.m, control/base/pzmap.m,
+	control/base/rldemo.m, control/base/rlocus.m,
+	control/hinf/dhinfdemo.m, control/hinf/hinfdemo.m,
+	plot/__axis_label__.m, plot/__errplot__.m, plot/__plt__.m,
+	plot/axis.m, plot/bar.m, plot/bottom_title.m, plot/contour.m,
+	plot/errorbar.m, plot/figure.m, plot/grid.m, plot/loglog.m,
+	plot/loglogerr.m, plot/mesh.m, plot/meshgrid.m, plot/mplot.m,
+	plot/multiplot.m, plot/oneplot.m, plot/plot.m, plot/plot_border.m,
+	plot/polar.m, plot/semilogx.m, plot/semilogxerr.m,
+	plot/semilogy.m, plot/semilogyerr.m, plot/shg.m, plot/stairs.m,
+	plot/subplot.m, plot/subwindow.m, plot/title.m, plot/top_title.m,
+	plot/xlabel.m, quaternion/demoquat.m,
+	quaternion/qcoordinate_plot.m, signal/freqz_plot.m, sparse/spy.m,
+	statistics/base/ppplot.m, statistics/base/qqplot.m:
+	Use __gnuplot_plot__ instead of gplot, __gnuplot_splot__ instead
+	of gsplot, and __gnuplot_set__ instead of gset. Remove gplot,
+	gsplot from @seealso docs.
 
 	* plot/replot.m: New file.
 
 2005-03-15  David Bateman  <dbateman@free.fr>
 
 	* set/unique.m, set/ismember.m: Handle cell arrays.
 
 2005-03-09  John W. Eaton  <jwe@octave.org>
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -215,20 +215,20 @@ function [y, t] = __stepimp__ (sitype, s
   endif
   
   save_automatic_replot = automatic_replot;
   unwind_protect
     automatic_replot = 0;
     if(nargout == 0)
       ## Plot the information
       oneplot();
-      gset nogrid
-      gset nologscale
-      gset autoscale
-      gset nokey
+      __gnuplot_set__ nogrid
+      __gnuplot_set__ nologscale
+      __gnuplot_set__ autoscale
+      __gnuplot_set__ nokey
       if (IMPULSE)
 	gm = zeros(NOUT, 1);
 	tt = "impulse";
       else
 	ssys = ss(F, G, C, D, t_step);
 	gm = dcgain(ssys);
 	tt = "step";
       endif
diff --git a/scripts/control/base/bode.m b/scripts/control/base/bode.m
--- a/scripts/control/base/bode.m
+++ b/scripts/control/base/bode.m
@@ -143,20 +143,20 @@ function [mag_r, phase_r, w_r] = bode (s
   phase = arg(f)*180.0/pi;
 
   if (nargout < 1),
     ## Plot the information
     save_automatic_replot = automatic_replot;
     unwind_protect
       automatic_replot = 0;
       oneplot();
-      gset autoscale;
-      gset nokey;
+      __gnuplot_set__ autoscale;
+      __gnuplot_set__ nokey;
       clearplot();
-      gset data style lines;
+      __gnuplot_set__ data style lines;
       if(is_digital(sys))
 	xlstr = ["Digital frequency w=rad/sec.  pi/T=",num2str(pi/systsam)];
 	tistr = "(exp(jwT)) ";
       else
 	xlstr = "Frequency in rad/sec";
 	tistr = "(jw)";
       endif
       xlabel(xlstr);
diff --git a/scripts/control/base/frdemo.m b/scripts/control/base/frdemo.m
--- a/scripts/control/base/frdemo.m
+++ b/scripts/control/base/frdemo.m
@@ -540,19 +540,19 @@ function frdemo ()
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the new discrete poles and zeros, use the command:");
           cmd = "sysout(dsys3,""zp"")";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following");
           disp("commands:\n");
-          cmd = "gset xrange [-4:2];";
+          cmd = "__gnuplot_set__ xrange [-4:2];";
           disp(cmd); eval(cmd);
-          cmd = "gset yrange [-2.5:2.5];";
+          cmd = "__gnuplot_set__ yrange [-2.5:2.5];";
           disp(cmd); eval(cmd);
           cmd = "nyquist(dsys3);";
           run_cmd;
           disp("Notice that the asymptotes swamp out the behavior of the plot")
           disp("near the origin.  You may use interactive nyquist plots")
           disp("to \"zoom in\" on a plot as follows:")
 
           cmd = "atol = 1;";
diff --git a/scripts/control/base/nichols.m b/scripts/control/base/nichols.m
--- a/scripts/control/base/nichols.m
+++ b/scripts/control/base/nichols.m
@@ -104,21 +104,21 @@ function [mag, phase, w] = nichols (sys,
 
   ## Get the magnitude and phase of f.
   mag = abs(f);
   phase = arg(f)*180.0/pi;
 
   if (nargout < 1),
     ## Plot the information
     oneplot();
-    gset autoscale;
-    gset nokey;
+    __gnuplot_set__ autoscale;
+    __gnuplot_set__ nokey;
     clearplot();
     grid("on");
-    gset data style lines;
+    __gnuplot_set__ data style lines;
     if(is_digital(sys))
       tistr = "(exp(jwT)) ";
     else
       tistr = "(jw)";
     endif
     xlabel("Phase (deg)");
     if(is_siso(sys))
       title(["Nichols plot of |[Y/U]",tistr,"|, u=", ...
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -130,36 +130,36 @@ function [realp, imagp, w] = nyquist (sy
   realp = real(f);
   imagp = imag(f);
 
   ## No output arguments, then display plot, otherwise return data.
   if (nargout == 0)
     dnplot = 0;
     while(!dnplot)
       oneplot();
-      gset key;
+      __gnuplot_set__ key;
       clearplot();
       grid ("on");
-      gset data style lines;
+      __gnuplot_set__ data style lines;
 
       if(is_digital(sys))
         tstr = " G(e^{jw}) ";
       else
         tstr = " G(jw) ";
       endif
       xlabel(["Re(",tstr,")"]);
       ylabel(["Im(",tstr,")"]);
 
       [stn, inn, outn] = sysgetsignals(sys);
       if(is_siso(sys))
         title(sprintf("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]", ...
           inn{1}, outn{1}, w(1), w(length(w))) )
       endif
 
-      gset nologscale xy;
+      __gnuplot_set__ nologscale xy;
 
       axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
       plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
 
       ## check for interactive plots
       dnplot = 1; # assume done; will change later if atol is satisfied
       if(atol > 0 & length(f) > 2)
 
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -61,17 +61,17 @@ function [zer, pol]=pzmap (sys)
       poldata = [real(pol(:,1)), imag(pol(:,1))];
     endif
 
     ## determine continuous or discrete plane
     vars = "sz";
     varstr = vars(is_digital(sys) + 1);
 
     ## Plot the data
-    gset nologscale xy;
+    __gnuplot_set__ nologscale xy;
     if(is_siso(sys))
       title(sprintf("Pole-zero map from %s to %s", ...
 	 sysgetsignals(sys,"in",1,1), sysgetsignals(sys,"out",1,1) ));
     endif
     xlabel(["Re(",varstr,")"]);
     ylabel(["Im(",varstr,")"]);
     grid;
 
diff --git a/scripts/control/base/rldemo.m b/scripts/control/base/rldemo.m
--- a/scripts/control/base/rldemo.m
+++ b/scripts/control/base/rldemo.m
@@ -30,17 +30,17 @@ function rldemo ()
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
         "Display continuous system's open loop poles and zeros (pzmap)", ...
         "Display discrete system's open loop poles and zeros (pzmap)", ...
         "Display root locus diagram of SISO continuous system (rlocus)", ...
         "Display root locus diagram of SISO discrete system (rlocus)", ...
         "Return to main demo menu");
-    gset autoscale
+    __gnuplot_set__ autoscale
     if (k == 1)
       clc
       help pzmap
       prompt
 
       clc
       disp("Display continuous system's open loop poles and zeros (pzmap)\n");
       disp("Example #1, Consider the following continuous transfer function:");
diff --git a/scripts/control/base/rlocus.m b/scripts/control/base/rlocus.m
--- a/scripts/control/base/rlocus.m
+++ b/scripts/control/base/rlocus.m
@@ -195,17 +195,17 @@ function [rldata, k_break, rlpol, gvec, 
 
   ## Plot the data
   if(nargout  == 0)
     rlpolv = vec(rlpol);
     idx = find(real(rlpolv) >= xmin & real(rlpolv) <= xmax);
     axdata = [real(rlpolv(idx)),imag(rlpolv(idx))];
     axlim = axis2dlim(axdata);
     axlim(1:2) = [xmin, xmax];
-    gset nologscale xy;
+    __gnuplot_set__ nologscale xy;
     grid("on");
     rldata = [real(rlpolv), imag(rlpolv) ];
     axis(axlim);
     [stn,inname,outname] = sysgetsignals(sys);
     xlabel(sprintf("Root locus from %s to %s, gain=[%f,%f]: Real axis", ...
         inname{1}, outname{1},gvec(1),gvec(ngain)));
     ylabel("Imag. axis");
 
diff --git a/scripts/control/hinf/dhinfdemo.m b/scripts/control/hinf/dhinfdemo.m
--- a/scripts/control/hinf/dhinfdemo.m
+++ b/scripts/control/hinf/dhinfdemo.m
@@ -145,17 +145,17 @@ if (length(yn) >= 1)
     gwx = sysprune(GWC, 1, 1);
     mag1 = bode(gwx, ww);
     if (columns(mag1) > 1);  mag1 = mag1';  endif
     gwx = sysprune(GWC, 2, 1);
     mag2 = bode(gwx, ww);
     if (columns(mag2) > 1);  mag2 = mag2';  endif
     figure(fig_n)
     fig_n = fig_n + 1;
-    gset grid
+    __gnuplot_set__ grid
     loglog(ww, [mag1 mag2]);
   endif
 endif
 
 Kd = c2d(K, "bi", Ts);
 GG = buildssic([1 2; 2 1], [], [1 2], [-2], Gd, Kd);
 disp(" o closed loop poles...");
 damp(GG);
diff --git a/scripts/control/hinf/hinfdemo.m b/scripts/control/hinf/hinfdemo.m
--- a/scripts/control/hinf/hinfdemo.m
+++ b/scripts/control/hinf/hinfdemo.m
@@ -395,17 +395,17 @@ switch (sys_type)
         gwx = sysprune(GWC, 1, 1);
         mag1 = bode(gwx, ww);
         if (columns(mag1) > 1);  mag1 = mag1';  endif
         gwx = sysprune(GWC, 2, 1);
         mag2 = bode(gwx, ww);
         if (columns(mag2) > 1);  mag2 = mag2';  endif
         figure(fig_n)
         fig_n = fig_n + 1;
-        gset grid
+        __gnuplot_set__ grid
         loglog(ww, [mag1 mag2]);
       endif
     endif
 
     Kd = c2d(K, "bi", Ts);
     GG = buildssic([1 2; 2 1], [], [1 2], [-2], Gd, Kd);
     disp(" o closed loop poles...");
     damp(GG);
diff --git a/scripts/plot/__axis_label__.m b/scripts/plot/__axis_label__.m
--- a/scripts/plot/__axis_label__.m
+++ b/scripts/plot/__axis_label__.m
@@ -25,17 +25,17 @@
 ## Author: jwe
 
 function h = __axis_label__ (caller, text)
 
   if (nargin == 0)
     usage ("__axis_label__ (caller, text)");
   elseif (nargin == 2)
     if (isstr (text))
-      eval (sprintf ("__gset__ %s \"%s\"", caller,
+      eval (sprintf ("__gnuplot_set__ %s \"%s\"", caller,
 		     undo_string_escapes (undo_string_escapes (text))));
       if (automatic_replot)
 	replot ();
       endif
     else
       error ("%s: text must be a string", caller);
     endif
   else
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -62,13 +62,13 @@ function __errplot__ (fstr,a1,a2,a3,a4,a
       case 5
 	error ("error plot requires 2, 3, 4 or 6 columns");
 	## tmp = [a1(:,i), a2(:,i), a3(:,i), a4(:,i), a5(:,i)];
       case 6
 	tmp = [a1(:,i), a2(:,i), ...
 	       a1(:,i)-a3(:,i), a1(:,i)+a4(:,i), ...
 	       a2(:,i)-a5(:,i), a2(:,i)+a6(:,i)];
     endswitch
-    cmd = sprintf ("__gplot__ tmp %s", ifmt);
+    cmd = sprintf ("__gnuplot_plot__ tmp %s", ifmt);
     eval (cmd);
 endfor
 
 endfunction
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -31,17 +31,17 @@ function __plt__ (caller, varargin)
 
     k = 1;
     j = 1;
 
     x_set = false;
     y_set = false;
     have_gp_cmd = false;
 
-    gp_cmd = "__gplot__";
+    gp_cmd = "__gnuplot_plot__";
     sep = "";
 
     ## Gather arguments, decode format, gather plot strings, and plot lines.
 
     while (--nargs > 0 || x_set)
 
       if (nargs == 0)
 	## Force the last plot when input variables run out.
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -124,116 +124,116 @@ function curr_axis = axis (ax, varargin)
   ## It isn't hard to compute good axis limits:
   ##   scale = 10 ^ floor (log10 (max - min) - 1);
   ##   r = scale * [floor (min / scale), ceil (max / scale)];
   ## However, with axis("manual") there is little need to know the current
   ## limits.
 
   if (nargin == 0)
     if (nargout == 0)
-      __gset__ autoscale;
+      __gnuplot_set__ autoscale;
     else
       curr_axis = __current_axis__;
     endif
 
   elseif (isstr (ax))
     ax = tolower (ax);
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
     if (strcmp (ax, "ij"))
-      __gset__ yrange [] reverse; 
+      __gnuplot_set__ yrange [] reverse; 
     elseif (strcmp (ax, "xy"))
-      __gset__ yrange [] noreverse;
+      __gnuplot_set__ yrange [] noreverse;
 
       ## aspect ratio
     elseif (strcmp (ax, "image"))
-      __gset__ size ratio -1; 
-      __gset__ autoscale; ## XXX FIXME XXX should be the same as "tight"
+      __gnuplot_set__ size ratio -1; 
+      __gnuplot_set__ autoscale; ## XXX FIXME XXX should be the same as "tight"
     elseif (strcmp (ax, "equal"))
-      __gset__ size ratio -1;
+      __gnuplot_set__ size ratio -1;
     elseif (strcmp (ax, "square"))
-      __gset__ size ratio 1;
+      __gnuplot_set__ size ratio 1;
     elseif (strcmp (ax, "normal"))
-      __gset__ size noratio;
+      __gnuplot_set__ size noratio;
 
 
       ## axis limits
     elseif (len >= 4 && strcmp (ax(1:4), "auto"))
       if (len > 4)
-      	eval (sprintf ("__gset__ autoscale %s;", ax(5:len)));
+      	eval (sprintf ("__gnuplot_set__ autoscale %s;", ax(5:len)));
       else
-	__gset__ autoscale;
+	__gnuplot_set__ autoscale;
       endif
     elseif (strcmp (ax, "manual"))
       ## fixes the axis limits, like axis(axis) should;
-      __gset__ xrange [] writeback;
-      __gset__ yrange [] writeback;
-      __gset__ zrange [] writeback;
+      __gnuplot_set__ xrange [] writeback;
+      __gnuplot_set__ yrange [] writeback;
+      __gnuplot_set__ zrange [] writeback;
       ## XXX FIXME XXX if writeback were set in plot, no need to replot here.
       replot ();
-      __gset__ noautoscale x;
-      __gset__ noautoscale y;
-      __gset__ noautoscale z;
+      __gnuplot_set__ noautoscale x;
+      __gnuplot_set__ noautoscale y;
+      __gnuplot_set__ noautoscale z;
     elseif (strcmp (ax, "tight"))
       ## XXX FIXME XXX if tight, plot must set ranges to limits of the
       ## all the data on the current plot, even if from a previous call.
       ## Instead, just let gnuplot do as it likes.
-      __gset__ autoscale;
+      __gnuplot_set__ autoscale;
 
 
       ## tic marks
     elseif (strcmp (ax, "on"))
-      __gset__ xtics;
-      __gset__ ytics;
-      __gset__ ztics;
-      __gset__ format;
+      __gnuplot_set__ xtics;
+      __gnuplot_set__ ytics;
+      __gnuplot_set__ ztics;
+      __gnuplot_set__ format;
     elseif (strcmp (ax, "off"))
-      __gset__ noxtics;
-      __gset__ noytics;
-      __gset__ noztics;
+      __gnuplot_set__ noxtics;
+      __gnuplot_set__ noytics;
+      __gnuplot_set__ noztics;
     elseif (strcmp (ax, "tic"))
-      __gset__ xtics;
-      __gset__ ytics;
-      __gset__ ztics;
+      __gnuplot_set__ xtics;
+      __gnuplot_set__ ytics;
+      __gnuplot_set__ ztics;
     elseif (len > 3 && strcmp (ax(1:3), "tic"))
       if (any (ax == "x"))
-	__gset__ xtics;
+	__gnuplot_set__ xtics;
       else
-	__gset__ noxtics;
+	__gnuplot_set__ noxtics;
       endif
       if (any (ax == "y"))
-	__gset__ ytics;
+	__gnuplot_set__ ytics;
       else
-	__gset__ noytics;
+	__gnuplot_set__ noytics;
       endif
       if (any (ax == "z"))
-	__gset__ ztics;
+	__gnuplot_set__ ztics;
       else
-	__gset__ noztics;
+	__gnuplot_set__ noztics;
       endif
     elseif (strcmp (ax, "label"))
-      __gset__ format;
+      __gnuplot_set__ format;
     elseif (strcmp (ax, "nolabel"))
-      __gset__ format "\\0";
+      __gnuplot_set__ format "\\0";
     elseif (len > 5 && strcmp (ax(1:5), "label"))
       if (any (ax == "x"))
-	__gset__ format x;
+	__gnuplot_set__ format x;
       else
-	__gset__ format x "\\0";
+	__gnuplot_set__ format x "\\0";
       endif
       if (any (ax == "y"))
-	__gset__ format y;
+	__gnuplot_set__ format y;
       else
-	__gset__ format y "\\0";
+	__gnuplot_set__ format y "\\0";
       endif
       if (any (ax == "z"))
-	__gset__ format z;
+	__gnuplot_set__ format z;
       else
-	__gset__ format z "\\0";
+	__gnuplot_set__ format z "\\0";
       endif
 
     else
       warning ("unknown axis option '%s'", ax);
     endif
 
   elseif (isvector (ax))
 
@@ -241,25 +241,25 @@ function curr_axis = axis (ax, varargin)
 
     if (len != 2 && len != 4 && len != 6)
       error ("axis: expecting vector with 2, 4, or 6 elements");
     endif
 
     __current_axis__ = reshape (ax, 1, len);
 
     if (len > 1)
-      eval (sprintf ("__gset__ xrange [%g:%g];", ax(1), ax(2)));
+      eval (sprintf ("__gnuplot_set__ xrange [%g:%g];", ax(1), ax(2)));
     endif
 
     if (len > 3)
-      eval (sprintf ("__gset__ yrange [%g:%g];", ax(3), ax(4)));
+      eval (sprintf ("__gnuplot_set__ yrange [%g:%g];", ax(3), ax(4)));
     endif
 
     if (len > 5)
-      eval (sprintf ("__gset__ zrange [%g:%g];", ax(5), ax(6)));
+      eval (sprintf ("__gnuplot_set__ zrange [%g:%g];", ax(5), ax(6)));
     endif
 
   else
     error ("axis: expecting no args, or a vector with 2, 4, or 6 elements");
   endif
 
   if (nargin > 1)
     axis (varargin{:});
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -27,17 +27,17 @@
 
 function bottom_title (text)
 
   if (nargin != 1)
     usage ("bottom_title (text)");
   endif
 
   if (isstr (text))
-    __gset__ top_title;
-    __gset__ title;
-    eval (sprintf ("__gset__ bottom_title \"%s\"",
+    __gnuplot_set__ top_title;
+    __gnuplot_set__ title;
+    eval (sprintf ("__gnuplot_set__ bottom_title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
   else
     error ("bottom_title: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -39,34 +39,34 @@ function contour (x, y, z, n)
   if (nargin == 1 || nargin == 2)
     z = x;
     if (nargin == 1) 
       n = 10;
     else
       n = y; 
     endif
     if (ismatrix (z))
-      __gset__ nosurface;
-      __gset__ contour;
-      __gset__ cntrparam bspline;
+      __gnuplot_set__ nosurface;
+      __gnuplot_set__ contour;
+      __gnuplot_set__ cntrparam bspline;
       if (isscalar (n))
-        command = sprintf ("__gset__ cntrparam levels %d", n);
+        command = sprintf ("__gnuplot_set__ cntrparam levels %d", n);
       elseif (isvector (n))
         tmp = sprintf ("%f", n(1));
         for i = 2:length (n)
           tmp = sprintf ("%s, %f", tmp, n(i));
         endfor
-        command = sprintf ("__gset__ cntrparam levels discrete %s", tmp);
+        command = sprintf ("__gnuplot_set__ cntrparam levels discrete %s", tmp);
       else
 	error ("contour: levels must be a scalar or vector") ;
       endif
       eval (command);
-      __gset__ noparametric;
-      __gset__ view 0, 0, 1, 1;
-      __gsplot__ z w l 1;
+      __gnuplot_set__ noparametric;
+      __gnuplot_set__ view 0, 0, 1, 1;
+      __gnuplot_splot__ z w l 1;
     else
       error ("contour: z of contour (z, levels) must be a matrix");
     endif
   elseif (nargin == 3 || nargin == 4)
     if (nargin == 3)
       n = 10;
     endif
     if (ismatrix (z))
@@ -99,34 +99,34 @@ function contour (x, y, z, n)
 	  zz = zeros (z_size(2), nc);
 	  zz(:,1:3:nc) = x';
 	  zz(:,2:3:nc) = y';
 	  zz(:,3:3:nc) = z';
 	else
 	  error (size_msg);
 	endif
       endif
-      __gset__ nosurface;
-      __gset__ contour;
-      __gset__ cntrparam bspline;
+      __gnuplot_set__ nosurface;
+      __gnuplot_set__ contour;
+      __gnuplot_set__ cntrparam bspline;
       if (isscalar (n))
-        command = sprintf ("__gset__ cntrparam levels %d", n);
+        command = sprintf ("__gnuplot_set__ cntrparam levels %d", n);
       elseif (isvector (n))
         tmp = sprintf ("%f", n(1));
         for i = 2:length (n)
           tmp = sprintf ("%s, %f", tmp, n(i));
         endfor
-        command = sprintf ("__gset__ cntrparam levels discrete %s", tmp);
+        command = sprintf ("__gnuplot_set__ cntrparam levels discrete %s", tmp);
       else
 	error ("contour: levels must be a scalar or vector") ;
       endif
       eval (command);
-      __gset__ parametric;
-      __gset__ view 0, 0, 1, 1;
-      __gsplot__ zz w l 1;
+      __gnuplot_set__ parametric;
+      __gnuplot_set__ view 0, 0, 1, 1;
+      __gnuplot_splot__ zz w l 1;
     else
       error ("contour: x and y must be vectors and z must be a matrix");
     endif
   else
     usage ("contour (x, y, z, levels) or contour (z, levels)");
   endif
 
 endfunction
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -112,15 +112,15 @@
 ## Keywords: errorbar, plotting
 
 function errorbar (varargin)
 
   if (nargin < 2)
     usage ("errorbar (...)");
   endif
 
-  __gset__ nologscale x;
-  __gset__ nologscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale x;
+  __gnuplot_set__ nologscale y;
+  __gnuplot_set__ nopolar;
 
   __errcomm__ ("errorbar", varargin{:});
 
 endfunction
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -42,17 +42,17 @@ function f = figure (n)
     if (gnuplot_has_frames)
       gnuterm = getenv ("GNUTERM");
       if (isempty (gnuterm) && ! isempty ("DISPLAY"))
 	gnuterm = "x11";
       endif
       if (! isempty (gnuterm))
         oneplot ();
         figure_list = union (figure_list, f);
-        eval (sprintf ("__gset__ term %s %d\n", gnuterm, f));
+        eval (sprintf ("__gnuplot_set__ term %s %d\n", gnuterm, f));
       else
         error ("figure: requires GNUTERM (Aqua) or DISPLAY (X11)");
       endif
     else
       error ("figure: gnuplot doesn't appear to support this feature");
     endif
   elseif (rem (nargin, 2) == 0)
     if (! figure_called)
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -33,25 +33,25 @@
 
 function grid (x)
 
   usage_msg = "grid (\"on\" | \"off\")";
 
   do_replot = false;
 
   if (nargin == 0)
-    __gset__ grid;
+    __gnuplot_set__ grid;
     do_replot = true;
   elseif (nargin == 1)
     if (isstr (x))
       if (strcmp ("off", x))
-        __gset__ nogrid;
+        __gnuplot_set__ nogrid;
 	do_replot = true;
       elseif (strcmp ("on", x))
-        __gset__ grid;
+        __gnuplot_set__ grid;
 	do_replot = true;
       else
 	usage (usage_msg);
       endif
     else
       error ("grid: argument must be a string");
     endif
   else
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -30,15 +30,15 @@
 ## Author: jwe
 
 function loglog (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  __gset__ logscale x;
-  __gset__ logscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ logscale x;
+  __gnuplot_set__ logscale y;
+  __gnuplot_set__ nopolar;
 
   __plt__ ("loglog", varargin{:});
 
 endfunction
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -43,15 +43,15 @@
 ## Keywords: errorbar, plotting
 
 function loglogerr (varargin)
 
   if (nargin < 2)
     usage ("loglogerr(...)");
   endif
 
-  __gset__ logscale x;
-  __gset__ logscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ logscale x;
+  __gnuplot_set__ logscale y;
+  __gnuplot_set__ nopolar;
 
   __errcomm__ ("loglogerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -36,24 +36,24 @@ function mesh (x, y, z)
 
   ## XXX FIXME XXX -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   if (nargin == 1)
     z = x;
     if (ismatrix (z))
-      __gset__ hidden3d;
-      __gset__ data style lines;
-      __gset__ surface;
-      __gset__ nocontour;
-      __gset__ noparametric;
-      __gset__ nologscale;
-      __gset__ view 60, 30, 1, 1
-      __gsplot__ (z');
+      __gnuplot_set__ hidden3d;
+      __gnuplot_set__ data style lines;
+      __gnuplot_set__ surface;
+      __gnuplot_set__ nocontour;
+      __gnuplot_set__ noparametric;
+      __gnuplot_set__ nologscale;
+      __gnuplot_set__ view 60, 30, 1, 1
+      __gnuplot_splot__ (z');
     else
       error ("mesh: argument must be a matrix");
     endif
   elseif (nargin == 3)
     if (isvector (x) && isvector (y) && ismatrix (z))
       xlen = length (x);
       ylen = length (y);
       if (xlen == columns (z) && ylen == rows (z))
@@ -64,25 +64,25 @@ function mesh (x, y, z)
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(k) * ones (ylen, 1);
           zz(:,i+1) = y;
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-        __gset__ hidden3d;
-        __gset__ data style lines;
-        __gset__ surface;
-        __gset__ nocontour;
-        __gset__ nologscale;
-        __gset__ parametric;
-        __gset__ view 60, 30, 1, 1
-        __gsplot__ (zz);
-        __gset__ noparametric;
+        __gnuplot_set__ hidden3d;
+        __gnuplot_set__ data style lines;
+        __gnuplot_set__ surface;
+        __gnuplot_set__ nocontour;
+        __gnuplot_set__ nologscale;
+        __gnuplot_set__ parametric;
+        __gnuplot_set__ view 60, 30, 1, 1
+        __gnuplot_splot__ (zz);
+        __gnuplot_set__ noparametric;
       else
         msg = "mesh: rows (z) must be the same as length (y) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (x)", msg);
         error (msg);
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       xlen = columns (z);
       ylen = rows (z);
@@ -92,25 +92,25 @@ function mesh (x, y, z)
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
           zz(:,i)   = x(:,k);
           zz(:,i+1) = y(:,k);
           zz(:,i+2) = z(:,k);
           k++;
         endfor
-        __gset__ hidden3d;
-        __gset__ data style lines;
-        __gset__ surface;
-        __gset__ nocontour;
-        __gset__ nologscale;
-        __gset__ parametric;
-        __gset__ view 60, 30, 1, 1
-        __gsplot__ (zz);
-        __gset__ noparametric;
+        __gnuplot_set__ hidden3d;
+        __gnuplot_set__ data style lines;
+        __gnuplot_set__ surface;
+        __gnuplot_set__ nocontour;
+        __gnuplot_set__ nologscale;
+        __gnuplot_set__ parametric;
+        __gnuplot_set__ view 60, 30, 1, 1
+        __gnuplot_splot__ (zz);
+        __gnuplot_set__ noparametric;
       else
         error ("mesh: x, y, and z must have same dimensions");
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif
   else
     usage ("mesh (z)");
diff --git a/scripts/plot/mplot.m b/scripts/plot/mplot.m
--- a/scripts/plot/mplot.m
+++ b/scripts/plot/mplot.m
@@ -39,18 +39,18 @@ function mplot (varargin)
   global __multiplot_mode__ = 0;
   global __multiplot_xsize__;
   global __multiplot_ysize__;
   global __multiplot_xn__;
   global __multiplot_yn__;
   global __multiplot_xi__;
   global __multiplot_yi__;
 
-  __gset__ nologscale;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale;
+  __gnuplot_set__ nopolar;
 
   __plt__ ("plot", varargin{:});
 
   ## update the plot position
 
   if (__multiplot_mode__)
 
     if (__multiplot_xi__ < __multiplot_xn__)
@@ -62,13 +62,13 @@ function mplot (varargin)
       else
         __multiplot_yi__ = 1;
       endif
     endif
 
     xo = (__multiplot_xi__ - 1.0) * __multiplot_xsize__;
     yo = (__multiplot_yn__ - __multiplot_yi__) * __multiplot_ysize__;
 
-    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
+    eval (sprintf ("__gnuplot_set__ origin %g, %g", xo, yo));
 
   endif
 
 endfunction
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -68,27 +68,27 @@ function multiplot (xn, yn)
     __multiplot_yi__ = 1;
 
   else
 
     if (xn < 1 || yn < 1)
       error ("multiplot: xn and yn have to be positive integers");
     endif
 
-    __gset__ multiplot;
+    __gnuplot_set__ multiplot;
 
     xsize = 1.0 ./ xn;
     ysize = 1.0 ./ yn;
 
-    eval (sprintf ("__gset__ size %g, %g", xsize, ysize));
+    eval (sprintf ("__gnuplot_set__ size %g, %g", xsize, ysize));
 
     xo = 0.0;
     yo = (yn - 1.0)*ysize;
 
-    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
+    eval (sprintf ("__gnuplot_set__ origin %g, %g", xo, yo));
 
     __multiplot_mode__ = 1;
     __multiplot_xsize__ = xsize;
     __multiplot_ysize__ = ysize;
     __multiplot_xn__ = xn;
     __multiplot_yn__ = yn;
     __multiplot_xi__ = 1;
     __multiplot_yi__ = 1;
diff --git a/scripts/plot/oneplot.m b/scripts/plot/oneplot.m
--- a/scripts/plot/oneplot.m
+++ b/scripts/plot/oneplot.m
@@ -26,16 +26,16 @@
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function oneplot ()
 
   global __multiplot_mode__ = 0;
 
   if (__multiplot_mode__)
-    __gset__ nomultiplot;
-    __gset__ size 1, 1;
-    __gset__ origin 0, 0;
+    __gnuplot_set__ nomultiplot;
+    __gnuplot_set__ size 1, 1;
+    __gnuplot_set__ origin 0, 0;
     __multiplot_mode__ = 0;
     gnuplot_command_replot = "rep";
   endif
 
 endfunction
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -170,14 +170,14 @@
 ## Author: jwe
 
 function plot (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  __gset__ nologscale;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale;
+  __gnuplot_set__ nopolar;
 
   __plt__ ("plot", varargin{:});
 
 endfunction
diff --git a/scripts/plot/plot_border.m b/scripts/plot/plot_border.m
--- a/scripts/plot/plot_border.m
+++ b/scripts/plot/plot_border.m
@@ -95,23 +95,23 @@ function plot_border (varargin)
       elseif (strcmp (arg, "all") || strcmp (arg, "ALL")
               || strcmp (arg, "a") || strcmp (arg, "A"))
         all = 1;
       endif
     endif
   endwhile
 
   if (none)
-    __gset__ noborder;
+    __gnuplot_set__ noborder;
   else
     if (all)
       border = 15;
     else
       border = south + west + north + east;
     endif
-    eval (sprintf ("__gset__ border %d", border));
+    eval (sprintf ("__gnuplot_set__ border %d", border));
   endif
 
   if (automatic_replot)
     replot ();
   endif
 
 endfunction
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -31,18 +31,18 @@
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  __gset__ nologscale;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale;
+  __gnuplot_set__ nopolar;
 
   if (nargin == 3)
     if (isstr (fmt))
       fmt = __pltopt__ ("polar", fmt);
     else
       error ("polar: third argument must be a string");
     endif
     __plr2__ (x1, x2, fmt);
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -30,15 +30,15 @@
 ## Author: jwe
 
 function semilogx (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  __gset__ logscale x;
-  __gset__ nologscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ logscale x;
+  __gnuplot_set__ nologscale y;
+  __gnuplot_set__ nopolar;
 
   __plt__ ("semilogx", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -43,15 +43,15 @@
 ## Keywords: errorbar, plotting
 
 function semilogxerr (varargin)
 
   if (nargin < 2)
     usage ("semilogxerr (...)");
   endif
 
-  __gset__ logscale x;
-  __gset__ nologscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ logscale x;
+  __gnuplot_set__ nologscale y;
+  __gnuplot_set__ nopolar;
 
   __errcomm__ ("semilogxerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -30,15 +30,15 @@
 ## Author: jwe
 
 function semilogy (varargin)
 
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
-  __gset__ nologscale x;
-  __gset__ logscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale x;
+  __gnuplot_set__ logscale y;
+  __gnuplot_set__ nopolar;
 
   __plt__ ("semilogy", varargin{:});
 
 endfunction
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -43,15 +43,15 @@
 ## Keywords: errorbar, plotting
 
 function semilogyerr (varargin)
 
   if (nargin < 2)
     usage ("semilogyerr (...)");
   endif
 
-  __gset__ nologscale x;
-  __gset__ logscale y;
-  __gset__ nopolar;
+  __gnuplot_set__ nologscale x;
+  __gnuplot_set__ logscale y;
+  __gnuplot_set__ nopolar;
 
   __errcomm__ ("semilogyerr", varargin{:});
 
 endfunction
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
 ## Sets @code{gnuplot} in multiplot mode and plots in location
 ## given by index (there are @var{cols} by @var{rows} subwindows).
 ##
 ## The global variable @var{__multiplot_scale__} should be used when the
-## command @code{__gset__ size xsize, ysize} has been used prior to calling
+## command @code{__gnuplot_set__ size xsize, ysize} has been used prior to calling
 ## @code{subplot}.
 ##
 ## The value of @var{__multiplot_scale__} should be a vector with two
 ## elements, the first set equal to @var{xsize} and the second to
 ## @var{ysize}.
 ##
 ## Input:
 ##
@@ -152,31 +152,31 @@ function subplot (rows, columns, index)
       __multiplot_mode__ = 1;
       __multiplot_xn__ = columns;
       __multiplot_yn__ = rows;
       __multiplot_xsize__ = __multiplot_scale__(1) ./ columns;
       __multiplot_ysize__ = __multiplot_scale__(2) ./ rows;
 
       gnuplot_command_replot = "cle;rep";
 
-      __gset__ multiplot;
+      __gnuplot_set__ multiplot;
 
-      eval (sprintf ("__gset__ size %g, %g", __multiplot_xsize__,
+      eval (sprintf ("__gnuplot_set__ size %g, %g", __multiplot_xsize__,
                      __multiplot_ysize__));
     endif
 
     ## get the sub plot location
 
     yp = fix ((index-1)/columns);
     xp = index - yp*columns - 1;
     __multiplot_xi__ = ++xp;
     __multiplot_yi__ = ++yp;
 
     ## set the origin
 
     xo = (xp - 1.0) * __multiplot_xsize__;
     yo = (rows - yp) * __multiplot_ysize__;
 
-    eval (sprintf ("__gset__ origin %g, %g", xo, yo));
+    eval (sprintf ("__gnuplot_set__ origin %g, %g", xo, yo));
 
   endif
 
 endfunction
diff --git a/scripts/plot/subwindow.m b/scripts/plot/subwindow.m
--- a/scripts/plot/subwindow.m
+++ b/scripts/plot/subwindow.m
@@ -66,13 +66,13 @@ function subwindow (xn, yn)
 
   if (xn < 1 || xn > __multiplot_xn__ || yn < 1 || yn > __multiplot_yn__)
     error ("subwindow: incorrect xn and yn");
   endif
 
   xo = (xn - 1.0) * __multiplot_xsize__;
   yo = (__multiplot_yn__ - yn) * __multiplot_ysize__;
 
-  eval (sprintf ("__gset__ origin %g, %g", xo, yo));
+  eval (sprintf ("__gnuplot_set__ origin %g, %g", xo, yo));
 
   clearplot;
 
 endfunction
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -29,17 +29,17 @@
 
 function h = title (text)
 
   if (nargin != 1)
     usage ("title (text)");
   endif
 
   if (isstr (text))
-    eval (sprintf ("__gset__ title \"%s\"",
+    eval (sprintf ("__gnuplot_set__ title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
     if (automatic_replot)
       replot ();
     endif
   else
     error ("title: text must be a string");
   endif
 
diff --git a/scripts/plot/top_title.m b/scripts/plot/top_title.m
--- a/scripts/plot/top_title.m
+++ b/scripts/plot/top_title.m
@@ -29,19 +29,19 @@
 
 function top_title (text)
 
   if (nargin != 1)
     usage ("top_title (text)");
   endif
 
   if (isstr (text))
-    __gset__ bottom_title;
-    __gset__ title;
-    eval (sprintf ("__gset__ top_title \"%s\"",
+    __gnuplot_set__ bottom_title;
+    __gnuplot_set__ title;
+    eval (sprintf ("__gnuplot_set__ top_title \"%s\"",
 		   undo_string_escapes (undo_string_escapes (text))));
     if (automatic_replot)
       replot ();
     endif
   else
     error ("error: top_title: text must be a string");
   endif
 
diff --git a/scripts/quaternion/demoquat.m b/scripts/quaternion/demoquat.m
--- a/scripts/quaternion/demoquat.m
+++ b/scripts/quaternion/demoquat.m
@@ -243,20 +243,20 @@ function opt = demoquat ()
 	[vv,th] = quaternion(qb);
 	printf("      = (vector) = [%8.4f %8.4f %8.4f], th=%5.2f deg\n", ...
 	  vv(1), vv(2), vv(3), th*180/pi);
 
 	qb = qmult(qb,qi);
 	title(sprintf("yaw=%5.2f deg, pitch=%5.2f deg",thy,thp))
 	qcoordinate_plot(qi,qb,qview);
 	# uncomment the next four lines to get eps output
-	#gset terminal postscript eps 
-	#eval(sprintf("gset output 'fig%d.eps'",kk));
+	#__gnuplot_set__ terminal postscript eps 
+	#eval(sprintf("__gnuplot_set__ output 'fig%d.eps'",kk));
 	#replot
-	#gset terminal x11
+	#__gnuplot_set__ terminal x11
 	#prompt
       endfor
 
     case(quitopt)
       printf ("Exiting quaternion demo\n");
 
     otherwise
       error ("invalid option %f", opt);
diff --git a/scripts/quaternion/qcoordinate_plot.m b/scripts/quaternion/qcoordinate_plot.m
--- a/scripts/quaternion/qcoordinate_plot.m
+++ b/scripts/quaternion/qcoordinate_plot.m
@@ -105,17 +105,17 @@ function qcoordinate_plot (qf, qb, qv)
   jfv = jnk(:,2);
   kfv = jnk(:,3);
 
   jnk = qtransvmat (qb);
   ibv = jnk(:,1);
   jbv = jnk(:,2);
   kbv = jnk(:,3);
 
-  gset size square
+  __gnuplot_set__ size square
   axis ([-2, 2, -2, 2]);
 
   [vv, theta] = quaternion (qb);
 
   xlabel (sprintf ("rotate about eigenaxis %5.2f deg", th_eig/degrees));
 
   plot ([ibv(1), 0], [ibv(3), 0], "-@11;x (body);",
         [0, jbv(1)], [0, jbv(3)], "-@21;y (body);",
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -40,28 +40,28 @@ function freqz_plot(w,h)
     unwind_protect
 
       ## Protect graph state.
 
       replot_state = automatic_replot;
       automatic_replot = 0;
 
       subplot (311);
-      gset lmargin 10;
+      __gnuplot_set__ lmargin 10;
       axis ("labely");
       xlabel ("");
       grid ("on");
       axis ([ w(1), w(n), maxmag-3, maxmag ]);
       plot (w, mag, ";Pass band (dB);");
 
       subplot (312);
       axis ("labely");
       title ("");
       xlabel ("");
-      gset tmargin 0;
+      __gnuplot_set__ tmargin 0;
       grid ("on");
       if (maxmag - min (mag) > 100)
       	axis ([ w(1), w(n), maxmag-100, maxmag ]);
       else
       	axis ("autoy");
       endif
       plot (w, mag, ";Stop band (dB);");
       
@@ -79,17 +79,17 @@ function freqz_plot(w,h)
       ## Restore graph state.
 
       ## XXX FIXME XXX -- if automatic_replot is non-zero, this will
       ## mess up the graph, however if we don't do it here then the user
       ## will have to do it themselves.
 
       grid ("off");
       axis ("auto", "label");
-      gset lmargin;
-      gset tmargin;
+      __gnuplot_set__ lmargin;
+      __gnuplot_set__ tmargin;
       oneplot ();
 
       automatic_replot = replot_state;
 
     end_unwind_protect
 
 endfunction
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -26,25 +26,25 @@ function spy(S)
     [i,j,s] = find(S);
     [m,n] = size(S);
   endif
 
   arp = automatic_replot;
   unwind_protect
     automatic_replot = 0;
 
-    eval(sprintf('gset nokey'))
-    eval(sprintf('gset yrange [0:%d] reverse',m+1))
-    eval(sprintf('gset xrange [0:%d] noreverse',n+1))
+    eval(sprintf('__gnuplot_set__ nokey'))
+    eval(sprintf('__gnuplot_set__ yrange [0:%d] reverse',m+1))
+    eval(sprintf('__gnuplot_set__ xrange [0:%d] noreverse',n+1))
 
     if (length(i)<1000)
       plot(j,i,'*');
     else
       plot(j,i,'.');
     endif
 
     #TODO: we should store the reverse state so we don't undo it
-    gset yrange [0:1] noreverse
+    __gnuplot_set__ yrange [0:1] noreverse
     axis;
   unwind_protect_cleanup
     automatic_replot = arp;
   end_unwind_protect
 endfunction
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -64,13 +64,13 @@ function [p, y] = ppplot (x, dist, varar
   if (nargin <= 2)
     y = feval (F, s);
   else
     y = feval (F, s, varargin{:});
   endif
 
   if (nargout == 0)
     axis ([0, 1, 0, 1]);
-    gset nokey;
+    __gnuplot_set__ nokey;
     plot (p, y);
   endif
 
 endfunction
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -75,13 +75,13 @@ function [q, s] = qqplot (x, dist, varar
     endif
     q_label = sprintf ("%s with parameter(s) %g%s", func2str (f),
 		       varargin{1}, tmp);
   endif
 
   if (nargout == 0)
     xlabel (q_label);
     ylabel ("sample points");
-    gset nokey;
+    __gnuplot_set__ nokey;
     plot (q, s);
   endif
 
 endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,20 @@
+2005-03-16  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/gplot.l (Fset, Fshow): Delete.
+	(F__gnuplot_plot__): Rename from Fgplot.
+	(F__gnuplot_splot__): Rename from Fgsplot.
+	(F__gnuplot_raw__): Rename from Fgraw.
+	(F__gnuplot_set__): Rename from Fgset.
+	(F__gnuplot_show__): Rename from Fgshow.
+	(F__gnuplot_replot__): Rename from Freplot.
+	(WARN_DEPRECATED, DEPRECATED_BODY): New macros.
+	(Fgplot, Fgsplot, Fgraw, Fgset, Fgshow): New functions.
+
 2005-03-15  John W. Eaton  <jwe@octave.org>
 
 	* lex.l (<COMMAND_START>{NL}): Reset lexer_flags.doing_rawcommand
 	state here.
 
 	* version.h (OCTAVE_API_VERSION): Now 2.9.0.
 	(OCTAVE_API_VERSION): Now api-v14.
 
diff --git a/src/DLD-FUNCTIONS/gplot.l b/src/DLD-FUNCTIONS/gplot.l
--- a/src/DLD-FUNCTIONS/gplot.l
+++ b/src/DLD-FUNCTIONS/gplot.l
@@ -1,24 +1,32 @@
 %option prefix="gpt"
 %option noyywrap
 
 %{
+// PKG_ADD: mark_as_rawcommand ("__gnuplot_plot__");
+// PKG_ADD: mark_as_rawcommand ("__gnuplot_set__");
+// PKG_ADD: mark_as_rawcommand ("__gnuplot_splot__");
+// PKG_ADD: mark_as_rawcommand ("__gnuplot_replot__");
+
 // PKG_ADD: mark_as_rawcommand ("gplot");
 // PKG_ADD: mark_as_rawcommand ("gset");
 // PKG_ADD: mark_as_rawcommand ("gsplot");
-
 // PKG_ADD: mark_as_rawcommand ("replot");
 
+// PKG_ADD: mark_as_command ("__gnuplot_show__");
+
 // PKG_ADD: mark_as_command ("gshow");
+
 // PKG_ADD: mark_as_command ("hold");
+
 // PKG_ADD: mark_as_command ("set");
 // PKG_ADD: mark_as_command ("show");
 
-// PKG_ADD: __gplot_init__ ();
+// PKG_ADD: __gnuplot_init__ ();
 
 // PKG_ADD: atexit ("closeplot");
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
@@ -1113,49 +1121,23 @@ doplot (std::string caller, octave_value
     {
       if (e.msg.empty ())
 	error ("could not parse plot command");
       else
 	error (e.msg.c_str ());
     }
 }
 
-DEFUN_DLD (gplot, args, ,
-  "Plot with gnuplot.\n")
-{
-  doplot ("plot", args);
-  return octave_value_list ();
-}
-
-DEFUN_DLD (gsplot, args, ,
-  "Plot with gnuplot.\n")
-{
-  doplot ("splot", args);
-  return octave_value_list ();
-}
-
-DEFUN_DLD (replot, args, ,
-  "Plot with gnuplot.\n")
-{
-  doplot ("replot", args);
-  return octave_value_list ();
-}
-
 DEFUN_DLD (clearplot, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} clearplot\n\
 @deftypefnx {Built-in Function} {} clg\n\
 Clear the plot window and any titles or axis labels.  The name\n\
 @code{clg} is aliased to @code{clearplot} for compatibility with\n\
 @sc{Matlab}.\n\
-\n\
-The commands @kbd{gplot clear}, @kbd{gsplot clear}, and @kbd{replot\n\
-clear} are equivalent to @code{clearplot}.  (Previously, commands like\n\
-@kbd{gplot clear} would evaluate @code{clear} as an ordinary expression\n\
-and clear all the visible variables.)\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   send_to_plot_stream ("clear\n");
 
   // XXX FIXME XXX -- instead of just clearing these things, it would
   // be nice if we could reset things to a user-specified default
@@ -1261,19 +1243,19 @@ A future version of Octave will eliminat
 files to hold the plot data.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   cleanup_tmp_files ();
   return retval;
 }
 
-DEFUN_DLD (graw, args, ,
+DEFUN_DLD (__gnuplot_raw__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} graw (@var{string})\n\
+@deftypefn {Built-in Function} {} __gnuplot_raw__ (@var{string})\n\
 Send @var{string} directly to gnuplot subprocess.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1 && args(0).is_string ())
     {
       std::string cmd = args(0).string_value ();
@@ -1289,19 +1271,19 @@ Send @var{string} directly to gnuplot su
 	}
     }
   else
     print_usage ("raw");
 
   return retval;
 }
 
-DEFUN_DLD (gset, args, ,
+DEFUN_DLD (__gnuplot_set__, args, ,
   "-*- texinfo -*-\n\
-@deffn {Command} gset options\n\
+@deffn {Command} __gnuplot_set__ options\n\
 Set plotting options for gnuplot\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("set");
@@ -1343,27 +1325,19 @@ Set plotting options for gnuplot\n\
 
   send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
   OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
-DEFUN_DLD (set, args, nargout,
+DEFUN_DLD (__gnuplot_show__, args, ,
   "-*- texinfo -*-\n\
-This command is has been replaced by @code{gset}.")
-{
-  warning ("set is obsolete -- use gset instead");
-  return Fgset (args, nargout);
-}
-
-DEFUN_DLD (gshow, args, ,
-  "-*- texinfo -*-\n\
-@deffn {Command} gshow options\n\
+@deffn {Command} __gnuplot_show__ options\n\
 Show plotting options.\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("show");
@@ -1383,22 +1357,92 @@ Show plotting options.\n\
 
   send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
   OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
-DEFUN_DLD (show, args, nargout,
-  "-*- texinfo -*-\n\
-This command is has been replaced by @code{gshow}.")
+DEFUN_DLD (__gnuplot_plot__, args, ,
+  "Plot with gnuplot.\n")
+{
+  doplot ("plot", args);
+  return octave_value_list ();
+}
+
+DEFUN_DLD (__gnuplot_splot__, args, ,
+  "Plot with gnuplot.\n")
+{
+  doplot ("splot", args);
+  return octave_value_list ();
+}
+
+DEFUN_DLD (__gnuplot_replot__, args, ,
+  "Plot with gnuplot.\n")
 {
-  warning ("show is obsolete -- use gshow instead");
-  return Fgshow (args, nargout);
+  doplot ("replot", args);
+  return octave_value_list ();
+}
+
+// Deprecated functions.
+
+#define WARN_DEPRECATED(FOLD, FNEW) \
+  do \
+    { \
+      static bool warned = false; \
+      if (! warned) \
+	{ \
+	  warned = true; \
+	  warning (#FOLD " is deprecated and will be removed from a future"); \
+	  warning ("version of Octave."); \
+	  warning ("You should use the higher-level plot functions"); \
+	  warning ("(\"plot\", \"mesh\", \"semilogx\", etc.) instead"); \
+	  warning ("of the low-level plotting commands."); \
+	  warning ("If you absolutely must use this function, use the"); \
+	  warning ("internal version " #FNEW " instead."); \
+	} \
+    } \
+  while (0)
+    
+#define DEPRECATED_BODY(FOLD, FNEW) \
+  WARN_DEPRECATED (FOLD, FNEW); \
+  return feval (#FNEW, args)
+
+// We can't further simplify this by putting the DEFUN_DLD in a macro
+// because then the mk-oct-links script will fail.
+
+DEFUN_DLD (gplot, args, ,
+  "")
+{
+  DEPRECATED_BODY (gplot, __gnuplot_plot__);
+}
+
+DEFUN_DLD (gsplot, args, ,
+  "")
+{
+  DEPRECATED_BODY (gsplot, __gnuplot_splot__);
+}
+
+DEFUN_DLD (graw, args, ,
+  "")
+{
+  DEPRECATED_BODY (graw, __gnuplot__raw__);
+}
+
+DEFUN_DLD (gset, args, ,
+  "")
+{
+  DEPRECATED_BODY (gset, __gnuplot_set__);
+}
+
+DEFUN_DLD (gshow, args, ,
+  "")
+{
+  DEPRECATED_BODY (gshow, __gnuplot__show__);
 }
 
 static int
 automatic_replot (void)
 {
   Vautomatic_replot = check_preference ("automatic_replot");
 
   return 0;
@@ -1479,29 +1523,29 @@ gnuplot_command_end (void)
 static int
 gnuplot_has_frames (void)
 {
   Vgnuplot_has_frames = check_preference ("gnuplot_has_frames");
 
   return 0;
 }
 
-DEFUN_DLD (__gplot_init__, , ,
+DEFUN_DLD (__gnuplot_init__, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} __gplot_init__ ()\n\
+@deftypefn {Loadable Function} __gnuplot_init__ ()\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  static bool gplot_initialized = false;
+  static bool gnuplot_initialized = false;
 
-  if (gplot_initialized)
+  if (gnuplot_initialized)
     return retval;
 
-  gplot_initialized = true;
+  gnuplot_initialized = true;
 
   DEFVAR (automatic_replot, true, automatic_replot,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} automatic_replot\n\
 You can tell Octave to redisplay the plot each time anything about it\n\
 changes by setting the value of the builtin variable\n\
 @code{automatic_replot} to a nonzero value.  Although it is fairly\n\
 inefficient, especially for large plots, the default value is 1 for\n\
