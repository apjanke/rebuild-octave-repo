# HG changeset patch
# User dbateman
# Date 1191875161 0
#      Mon Oct 08 20:26:01 2007 +0000
# Node ID 2883ea1c5c180e4ed4cdf68ce52287a9a6e24055
# Parent  b75630794a1185328b9081bb5a2ca37ebaac225c
[project @ 2007-10-08 20:23:48 by dbateman]

diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -51,16 +51,21 @@ public:
 
   Array2 (void) : Array<T> (dim_vector (0, 0)) { }
 
   Array2 (octave_idx_type r, octave_idx_type c) : Array<T> (dim_vector (r, c)) { }
 
   Array2 (octave_idx_type r, octave_idx_type c, const T& val)
     : Array<T> (dim_vector (r, c), val) { }
 
+  Array2 (const dim_vector& dv) : Array<T> (dv) { }
+
+  Array2 (const dim_vector& dv, const T& val) 
+    : Array<T> (dv) { Array<T>::fill (val); }
+
   Array2 (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
 
   Array2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : Array<T> (a, dim_vector (r, c)) { }
 
   ~Array2 (void) { }
 
   Array2<T>& operator = (const Array2<T>& a)
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -42,16 +42,21 @@ public:
 
   ComplexMatrix (void) : MArray2<Complex> () { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<Complex> (r, c) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
 
+  ComplexMatrix (const dim_vector& dv) : MArray2<Complex> (dv) { }
+
+  ComplexMatrix (const dim_vector& dv, const Complex& val) 
+    : MArray2<Complex> (dv, val) { }
+
   ComplexMatrix (const ComplexMatrix& a) : MArray2<Complex> (a) { }
 
   ComplexMatrix (const MArray2<Complex>& a) : MArray2<Complex> (a) { }
 
   explicit ComplexMatrix (const Matrix& a);
 
   explicit ComplexMatrix (const RowVector& rv);
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,96 @@
+2007-10-08  David Bateman  <dbateman@free.fr>
+
+	* oct-rl-edit. (typedef rl_quoting_fcn_ptr, rl_dequoting_fcn_ptr,
+	rl_char_is_quoted_fcn_ptr, rl_command_fcn_ptr): New  typedefs
+	for readline compatible functions.
+	(octave_rl_redisplay): Redisplay the current line of text.
+	(octave_rl_newline):  Change interface to the same
+	as used by the equivalent readline function itself.
+	(octave_rl_filename_quoting_desired,
+	octave_rl_set_filename_quote_characters,
+	octave_rl_set_completer_quote_characters,
+	octave_rl_qet_quoting_function, octave_rl_qet_dequoting_function,
+	octave_rl_set_char_is_quoted_function): New functions to control
+	readline filename quoting and line acceptace.
+	* oct-rl-edit.c (octave_rl_newline): Change interface to the same
+	as used by the equivalent readline function itself.
+	(octave_rl_redisplay): Redisplay the current line of text.
+	(octave_rl_filename_quoting_desired,
+	octave_rl_set_filename_quote_characters,
+	octave_rl_set_completer_quote_characters,
+	octave_rl_qet_quoting_function, octave_rl_qet_dequoting_function,
+	octave_rl_set_char_is_quoted_function): New functions to control
+	readline filename quoting and line acceptace.
+	* cmd-edit.h (typedef quoting_fcn, typedef dequoting_fcn,
+	typedef char_is_quoted_fcn, user_accept_line_fcn): New typedefs
+	to map C++ function to readline compatible functions.
+	(set_filename_quote_characters): New function to set the
+	characters to if they appear in a filename that force the filename
+	to be quoted.
+	(set_completer_quote_characters): The characters that the readline
+	completion function considers as quotation characters.
+	(set_quoting_function, set_dequoting_function,
+	set_char_is_quoted_function, set_user_accept_line_function):
+	Functions to set the Octave functions to perform quoting and the
+	acceptance of a line of text by readline.
+	(get_quoting_function, get_dequoting_function,
+	get_char_is_quoted_function, get_user_accept_line_function):
+	Functions to get the above functions.
+	(accept_line): New method for the command_editor to accept a line
+	of text.
+	(file_quoting_desired): Function to set whether readline should
+	attempt to quote filenames.
+	(do_set_filename_quoting_characters, 
+	do_set_completer_quote_characters, do_set_quoting_function,
+	do_set_dequoting_function, do_set_char_is_quoted_function,
+	do_set_user_accept_line_function, do_get_quoting_function,
+	do_get_dequoting_function, do_get_char_is_quoted_function,
+	do_get_user_accept_line_function, do_filename_quoting_desired):
+	Virtual functions to control the behavior of readline quoting and
+	acceptance of lines.
+	(do_accept_line): Virtual function for the accept line function.
+	* cmd-edit.cc (class gnu_readline do_set_filename_quote_characters, 
+	do_completer_quote_characters, do_set_quoting_function,
+	do_set_dequoting_function, do_set_char_is_quoted_function,
+	do_set_user_accept_line_function, do_get_quoting_function,
+	do_get_dequoting_function, do_get_user_accept_line_function, 
+	do_accept_line, do_filename_quoting_desired, command_quoter,
+	command_dequoter, command_char_is_quoted, command_accept_line):
+	New functions in gnu_readline class to control filename quoting 
+	and line acceptance.
+	(quoting_function, dequoting_function, char_is_quoted_function,
+	user_accept_line_function): private variable to store functions
+	supplied for readline quoting and line acceptance.
+	(gnu_readline::gnu_readline): Also set the new function pointers
+	to zero.
+	(gnu_readline::do_newline): Adapt to new octave_rl_newline
+	interface.
+	(gnu_readeline::operate_and_get_next): Use new accept_line
+	function rather than newline.
+	(default_ommand_editor::do_accept_line): New method.
+	(class command_editor set_filename_quote_characters, 
+	set_completer_quote_characters, set_quoting_function,
+	set_dequoting_function, set_char_is_quoted_function,
+	set_user_accept_line_function, get_quoting_function,
+	get_dequoting_function, get_user_accept_line_function, 
+	accept_line, filename_quoting_desired): New functions checking
+	instance before calling virtual function.
+
+	* CMatrix.h, dMatrix.h, boolMatrix.h, chMatrix.h, MArray2.h,
+	Array2.h: Add dim_vector constructors.
+	* charNDArray.h (charNDArray (const dim_vector&)): Add missing
+	const to dim_vector constructors. 
+	* boolMatrix.cc, chMatrix.cc, intNDArray.cc (diag (void), diag
+	(octave_idx_type)): New methods to constructor diagonal matrices.
+	* boolMatrix.h, chMatrix.h, intNDArray.h (diag (void), diag
+	(octave_idx_type)): Declare them.
+
+
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
 	* lo-specfun.cc: (zlgamma): Delete.
 	(xgamma): Use C library gamma function if available.
 	(xlgamma): Use C library lgamma function if available.
 	(xlgamma) [! HAVE_LGAMMA]: Allow calculation for any value of X
 	other than NaN or Inf.
 
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -46,16 +46,20 @@ protected:
 public:
 
   MArray2 (void) : Array2<T> () { }
 
   MArray2 (octave_idx_type n, octave_idx_type m) : Array2<T> (n, m) { }
 
   MArray2 (octave_idx_type n, octave_idx_type m, const T& val) : Array2<T> (n, m, val) { }
 
+  MArray2 (const dim_vector& dv) : Array2<T> (dv) { }
+
+  MArray2 (const dim_vector& dv, const T& val) : Array2<T> (dv, val) { }
+
   MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
 
   MArray2 (const Array2<T>& a) : Array2<T> (a) { }
 
   ~MArray2 (void) { }
 
   MArray2<T>& operator = (const MArray2<T>& a)
     {
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -72,16 +72,63 @@ boolMatrix::operator ! (void) const
     for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
 // other operations
 
+boolMatrix
+boolMatrix::diag (void) const
+{
+  return diag (0);
+}
+
+boolMatrix
+boolMatrix::diag (octave_idx_type k) const
+{
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
+  if (k > 0)
+    nnc -= k;
+  else if (k < 0)
+    nnr += k;
+
+  boolMatrix d;
+
+  if (nnr > 0 && nnc > 0)
+    {
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+      d.resize (ndiag, 1);
+
+      if (k > 0)
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i, i+k);
+	}
+      else if (k < 0)
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i-k, i);
+	}
+      else
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i, i);
+	}
+    }
+  else
+    (*current_liboctave_error_handler)
+      ("diag: requested diagonal out of range");
+
+  return d;
+}
+
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 boolMatrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -33,16 +33,18 @@ class
 OCTAVE_API
 boolMatrix : public Array2<bool>
 {
 public:
 
   boolMatrix (void) : Array2<bool> () { }
   boolMatrix (octave_idx_type r, octave_idx_type c) : Array2<bool> (r, c) { }
   boolMatrix (octave_idx_type r, octave_idx_type c, bool val) : Array2<bool> (r, c, val) { }
+  boolMatrix (const dim_vector& dv) : Array2<bool> (dv) { }
+  boolMatrix (const dim_vector& dv, bool val) : Array2<bool> (dv, val) { }
   boolMatrix (const Array2<bool>& a) : Array2<bool> (a) { }
   boolMatrix (const boolMatrix& a) : Array2<bool> (a) { }
 
   boolMatrix& operator = (const boolMatrix& a)
     {
       Array2<bool>::operator = (a);
       return *this;
     }
@@ -57,16 +59,19 @@ public:
   boolMatrix& insert (const boolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
+  boolMatrix diag (void) const;
+  boolMatrix diag (octave_idx_type k) const;
+
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -184,16 +184,63 @@ charMatrix::extract (octave_idx_type r1,
 
   for (octave_idx_type j = 0; j < new_c; j++)
     for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
+charMatrix
+charMatrix::diag (void) const
+{
+  return diag (0);
+}
+
+charMatrix
+charMatrix::diag (octave_idx_type k) const
+{
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
+  if (k > 0)
+    nnc -= k;
+  else if (k < 0)
+    nnr += k;
+
+  charMatrix d;
+
+  if (nnr > 0 && nnc > 0)
+    {
+      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+      d.resize (ndiag, 1);
+
+      if (k > 0)
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i, i+k);
+	}
+      else if (k < 0)
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i-k, i);
+	}
+      else
+	{
+	  for (octave_idx_type i = 0; i < ndiag; i++)
+	    d.xelem (i) = elem (i, i);
+	}
+    }
+  else
+    (*current_liboctave_error_handler)
+      ("diag: requested diagonal out of range");
+
+  return d;
+}
+
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 charMatrix::all (int dim) const
 {
   MX_ALL_OP (dim);
 }
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -37,16 +37,18 @@ charMatrix : public MArray2<char>
 {
 friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : MArray2<char> () { }
   charMatrix (octave_idx_type r, octave_idx_type c) : MArray2<char> (r, c) { }
   charMatrix (octave_idx_type r, octave_idx_type c, char val) : MArray2<char> (r, c, val) { }
+  charMatrix (const dim_vector& dv) : MArray2<char> (dv) { }
+  charMatrix (const dim_vector& dv, char val) : MArray2<char> (dv, val) { }
   charMatrix (const MArray2<char>& a) : MArray2<char> (a) { }
   charMatrix (const charMatrix& a) : MArray2<char> (a) { }
   charMatrix (char c);
   charMatrix (const char *s);
   charMatrix (const std::string& s);
   charMatrix (const string_vector& s);
 
   charMatrix& operator = (const charMatrix& a)
@@ -66,16 +68,19 @@ public:
   charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false, bool raw = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
+  charMatrix diag (void) const;
+  charMatrix diag (octave_idx_type k) const;
+
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -33,19 +33,19 @@ 02110-1301, USA.
 class
 OCTAVE_API
 charNDArray : public MArrayN<char>
 {
 public:
 
   charNDArray (void) : MArrayN<char> () { }
 
-  charNDArray (dim_vector& dv) : MArrayN<char> (dv) { }
+  charNDArray (const dim_vector& dv) : MArrayN<char> (dv) { }
 
-  charNDArray (dim_vector& dv, char val) : MArrayN<char> (dv, val) { }
+  charNDArray (const dim_vector& dv, char val) : MArrayN<char> (dv, val) { }
   
   charNDArray (const charNDArray& a) : MArrayN<char> (a) { }
 
   charNDArray (const charMatrix& a) : MArrayN<char> (a) { }
 
   charNDArray (char c) : MArrayN<char> (charMatrix (c)) { }
 
   charNDArray (const char *s) : MArrayN<char> (charMatrix (s)) { }
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -102,67 +102,108 @@ public:
   void do_blink_matching_paren (bool flag);
 
   void do_set_basic_word_break_characters (const std::string& s);
 
   void do_set_completer_word_break_characters (const std::string& s);
 
   void do_set_basic_quote_characters (const std::string& s);
 
+  void do_set_filename_quote_characters (const std::string& s);
+
+  void do_set_completer_quote_characters (const std::string& s);
+
   void do_set_completion_append_character (char c);
 
   void do_set_completion_function (completion_fcn f);
 
+  void do_set_quoting_function (quoting_fcn f);
+
+  void do_set_dequoting_function (dequoting_fcn f);
+
+  void do_set_char_is_quoted_function (char_is_quoted_fcn f);
+
+  void do_set_user_accept_line_function (user_accept_line_fcn f);
+
   completion_fcn do_get_completion_function (void) const;
 
+  quoting_fcn do_get_quoting_function (void) const;
+
+  dequoting_fcn do_get_dequoting_function (void) const;
+
+  char_is_quoted_fcn do_get_char_is_quoted_function (void) const;
+
+  user_accept_line_fcn do_get_user_accept_line_function (void) const;
+
   string_vector
   do_generate_filename_completions (const std::string& text);
 
   void do_insert_text (const std::string& text);
 
   void do_newline (void);
 
+  void do_accept_line (void);
+
   void do_clear_undo_list (void);
 
   void set_startup_hook (startup_hook_fcn f);
 
   void restore_startup_hook (void);
 
   void set_event_hook (event_hook_fcn f);
 
   void restore_event_hook (void);
 
   void do_restore_event_hook (void);
 
   void do_read_init_file (const std::string& file);
 
   bool do_filename_completion_desired (bool);
 
+  bool do_filename_quoting_desired (bool);
+
   static int operate_and_get_next (int, int);
 
   static int history_search_backward (int, int);
 
   static int history_search_forward (int, int);
 
 private:
 
   startup_hook_fcn previous_startup_hook;
 
   event_hook_fcn previous_event_hook;
 
   completion_fcn completion_function;
 
+  quoting_fcn quoting_function;
+
+  dequoting_fcn dequoting_function;
+
+  char_is_quoted_fcn char_is_quoted_function;
+
+  user_accept_line_fcn user_accept_line_function;
+
   static char *command_generator (const char *text, int state);
 
+  static char *command_quoter (char *text, int match_type, char *quote_pointer);
+  static char *command_dequoter (char *text, int match_type);
+
+  static int command_char_is_quoted (char *text, int index);
+
+  static int command_accept_line (int count, int key);
+
   static char **command_completer (const char *text, int start, int end);
 };
 
 gnu_readline::gnu_readline ()
   : command_editor (), previous_startup_hook (0),
-    previous_event_hook (0), completion_function (0)
+    previous_event_hook (0), completion_function (0),
+    quoting_function (0), dequoting_function (0),
+    char_is_quoted_function (0), user_accept_line_function (0)
 {
   // FIXME -- need interface to rl_add_defun, rl_initialize, and
   // a function to set rl_terminal_name
 
   std::string term = octave_env::getenv ("TERM");
 
   octave_rl_set_terminal_name (term.c_str ());
 
@@ -182,18 +223,16 @@ gnu_readline::gnu_readline ()
 		       gnu_readline::history_search_backward,
 		       octave_rl_meta ('P'));
 
   octave_rl_add_defun ("history-search-forward",
 		       gnu_readline::history_search_forward,
 		       octave_rl_meta ('N'));
 }
 
-
-
 void
 gnu_readline::do_set_name (const std::string& nm)
 {
   ::octave_rl_set_name (nm.c_str ());
 }
 
 std::string
 gnu_readline::do_readline (const std::string& prompt, bool& eof)
@@ -314,38 +353,120 @@ gnu_readline::do_set_completer_word_brea
 
 void
 gnu_readline::do_set_basic_quote_characters (const std::string& s)
 {
   ::octave_rl_set_basic_quote_characters (s.c_str ());
 }
 
 void
+gnu_readline::do_set_filename_quote_characters (const std::string& s)
+{
+  ::octave_rl_set_filename_quote_characters (s.c_str ());
+}
+
+void
+gnu_readline::do_set_completer_quote_characters (const std::string& s)
+{
+  ::octave_rl_set_completer_quote_characters (s.c_str ());
+}
+
+void
 gnu_readline::do_set_completion_append_character (char c)
 {
   ::octave_rl_set_completion_append_character (c);
 }
 
 void
 gnu_readline::do_set_completion_function (completion_fcn f)
 {
   completion_function = f;
 
   rl_attempted_completion_fcn_ptr fp
     = f ? gnu_readline::command_completer : 0;
 
   ::octave_rl_set_completion_function (fp);
 }
 
+void
+gnu_readline::do_set_quoting_function (quoting_fcn f)
+{
+  quoting_function = f;
+
+  rl_quoting_fcn_ptr fp
+    = f ? gnu_readline::command_quoter : 0;
+
+  ::octave_rl_set_quoting_function (fp);
+}
+
+void
+gnu_readline::do_set_dequoting_function (dequoting_fcn f)
+{
+  dequoting_function = f;
+
+  rl_dequoting_fcn_ptr fp
+    = f ? gnu_readline::command_dequoter : 0;
+
+  ::octave_rl_set_dequoting_function (fp);
+}
+
+void
+gnu_readline::do_set_char_is_quoted_function (char_is_quoted_fcn f)
+{
+  char_is_quoted_function = f;
+
+  rl_char_is_quoted_fcn_ptr fp
+    = f ? gnu_readline::command_char_is_quoted : 0;
+
+  ::octave_rl_set_char_is_quoted_function (fp);
+}
+
+void
+gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
+{
+  user_accept_line_function = f;
+
+  if (f)
+    octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line, 
+			 ::octave_rl_ctrl ('M'));
+  else
+    octave_rl_add_defun ("accept-line", ::octave_rl_newline,
+			 ::octave_rl_ctrl ('M'));
+}
+
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
 {
   return completion_function;
 }
 
+gnu_readline::quoting_fcn
+gnu_readline::do_get_quoting_function (void) const
+{
+  return quoting_function;
+}
+
+gnu_readline::dequoting_fcn
+gnu_readline::do_get_dequoting_function (void) const
+{
+  return dequoting_function;
+}
+
+gnu_readline::char_is_quoted_fcn
+gnu_readline::do_get_char_is_quoted_function (void) const
+{
+  return char_is_quoted_function;
+}
+
+gnu_readline::user_accept_line_fcn
+gnu_readline::do_get_user_accept_line_function (void) const
+{
+  return user_accept_line_function;
+}
+
 string_vector
 gnu_readline::do_generate_filename_completions (const std::string& text)
 {
   string_vector retval;
 
   int n = 0;
   int count = 0;
 
@@ -384,17 +505,23 @@ void
 gnu_readline::do_insert_text (const std::string& text)
 {
   ::octave_rl_insert_text (text.c_str ());
 }
 
 void
 gnu_readline::do_newline (void)
 {
-  ::octave_rl_newline ();
+  ::octave_rl_newline (1, '\n');
+}
+
+void
+gnu_readline::do_accept_line (void)
+{
+  command_accept_line (1, '\n');
 }
 
 void
 gnu_readline::do_clear_undo_list ()
 {
   ::octave_rl_clear_undo_list ();
 }
 
@@ -434,22 +561,28 @@ gnu_readline::do_read_init_file (const s
 }
 
 bool
 gnu_readline::do_filename_completion_desired (bool arg)
 {
   return ::octave_rl_filename_completion_desired (arg);
 }
 
+bool
+gnu_readline::do_filename_quoting_desired (bool arg)
+{
+  return ::octave_rl_filename_quoting_desired (arg);
+}
+
 int
 gnu_readline::operate_and_get_next (int /* count */, int /* c */)
 {
   // Accept the current line.
 
-  command_editor::newline ();
+  command_editor::accept_line ();
 
   // Find the current line, and find the next line to use.
 
   int x_where = command_history::where ();
 
   int x_length = command_history::length ();
 
   if ((command_history::is_stifled ()
@@ -492,16 +625,79 @@ gnu_readline::command_generator (const c
       retval = static_cast<char *> (malloc (len+1));
 
       strcpy (retval, tmp.c_str ());
     }
 
   return retval;
 }
 
+char *
+gnu_readline::command_quoter (char *text, int matches, char *qcp)
+{
+  char *retval = 0;
+
+  quoting_fcn f = command_editor::get_quoting_function ();
+
+  std::string tmp = f (text, matches, *qcp);
+
+  size_t len = tmp.length ();
+
+  if (len > 0)
+    {
+      retval = static_cast<char *> (malloc (len+1));
+
+      strcpy (retval, tmp.c_str ());
+    }
+
+  return retval;
+}
+
+char *
+gnu_readline::command_dequoter (char *text, int quote)
+{
+  char *retval = 0;
+
+  dequoting_fcn f = command_editor::get_dequoting_function ();
+
+  std::string tmp = f (text, quote);
+
+  size_t len = tmp.length ();
+
+  if (len > 0)
+    {
+      retval = static_cast<char *> (malloc (len+1));
+
+      strcpy (retval, tmp.c_str ());
+    }
+
+  return retval;
+}
+
+int
+gnu_readline::command_char_is_quoted (char *text, int quote)
+{
+  char_is_quoted_fcn f = command_editor::get_char_is_quoted_function ();
+
+  return f (text, quote);
+}
+
+int
+gnu_readline::command_accept_line (int count, int key)
+{
+  user_accept_line_fcn f = command_editor::get_user_accept_line_function ();
+
+  if (f)
+    f (::octave_rl_line_buffer ());
+
+  ::octave_rl_redisplay ();
+
+  return ::octave_rl_newline (count, key);
+}
+
 char **
 gnu_readline::command_completer (const char *text, int, int)
 {
   char **matches = 0;
   matches
     = ::octave_rl_completion_matches (text, gnu_readline::command_generator);
   return matches;
 }
@@ -529,16 +725,18 @@ public:
   FILE *do_get_output_stream (void);
 
   string_vector do_generate_filename_completions (const std::string& text);
 
   void do_insert_text (const std::string&);
 
   void do_newline (void);
 
+  void do_accept_line (void);
+
 private:
 
   FILE *input_stream;
 
   FILE *output_stream;
 };
 
 std::string
@@ -588,16 +786,22 @@ default_command_editor::do_insert_text (
 }
 
 void
 default_command_editor::do_newline (void)
 {
   // FIXME
 }
 
+void
+default_command_editor::do_accept_line (void)
+{
+  // FIXME
+}
+
 bool
 command_editor::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     make_command_editor ();
 
@@ -789,36 +993,106 @@ command_editor::set_completer_word_break
 void
 command_editor::set_basic_quote_characters (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_basic_quote_characters (s);
 }
 
 void
+command_editor::set_filename_quote_characters (const std::string& s)
+{
+  if (instance_ok ())
+    instance->do_set_filename_quote_characters (s);
+}
+
+void
+command_editor::set_completer_quote_characters (const std::string& s)
+{
+  if (instance_ok ())
+    instance->do_set_completer_quote_characters (s);
+}
+
+void
 command_editor::set_completion_append_character (char c)
 {
   if (instance_ok ())
     instance->do_set_completion_append_character (c);
 }
 
 void
 command_editor::set_completion_function (completion_fcn f)
 {
   if (instance_ok ())
     instance->do_set_completion_function (f);
 }
 
+void
+command_editor::set_quoting_function (quoting_fcn f)
+{
+  if (instance_ok ())
+    instance->do_set_quoting_function (f);
+}
+
+void
+command_editor::set_dequoting_function (dequoting_fcn f)
+{
+  if (instance_ok ())
+    instance->do_set_dequoting_function (f);
+}
+
+void
+command_editor::set_char_is_quoted_function (char_is_quoted_fcn f)
+{
+  if (instance_ok ())
+    instance->do_set_char_is_quoted_function (f);
+}
+
+void
+command_editor::set_user_accept_line_function (user_accept_line_fcn f)
+{
+  if (instance_ok ())
+    instance->do_set_user_accept_line_function (f);
+}
+
 command_editor::completion_fcn
 command_editor::get_completion_function (void)
 {
   return (instance_ok ())
     ? instance->do_get_completion_function () : 0;
 }
 
+command_editor::quoting_fcn
+command_editor::get_quoting_function (void)
+{
+  return (instance_ok ())
+    ? instance->do_get_quoting_function () : 0;
+}
+
+command_editor::dequoting_fcn
+command_editor::get_dequoting_function (void)
+{
+  return (instance_ok ())
+    ? instance->do_get_dequoting_function () : 0;
+}
+
+command_editor::char_is_quoted_fcn
+command_editor::get_char_is_quoted_function (void)
+{
+  return (instance_ok ())
+    ? instance->do_get_char_is_quoted_function () : 0;
+}
+
+command_editor::user_accept_line_fcn
+command_editor::get_user_accept_line_function (void)
+{
+  return (instance_ok ())
+    ? instance->do_get_user_accept_line_function () : 0;
+}
+
 string_vector
 command_editor::generate_filename_completions (const std::string& text)
 {
   return (instance_ok ())
     ? instance->do_generate_filename_completions (text) : string_vector ();
 }
 
 void
@@ -831,16 +1105,23 @@ command_editor::insert_text (const std::
 void
 command_editor::newline (void)
 {
   if (instance_ok ())
     instance->do_newline ();
 }
 
 void
+command_editor::accept_line (void)
+{
+  if (instance_ok ())
+    instance->do_accept_line ();
+}
+
+void
 command_editor::clear_undo_list (void)
 {
   if (instance_ok ())
     instance->do_clear_undo_list ();
 }
 
 void
 command_editor::add_startup_hook (startup_hook_fcn f)
@@ -907,16 +1188,23 @@ command_editor::read_init_file (const st
 
 bool
 command_editor::filename_completion_desired (bool arg)
 {
   return (instance_ok ())
     ? instance->do_filename_completion_desired (arg) : false;
 }
 
+bool
+command_editor::filename_quoting_desired (bool arg)
+{
+  return (instance_ok ())
+    ? instance->do_filename_quoting_desired (arg) : false;
+}
+
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows: 
 //   
 //	\a	bell (ascii 07)
 //	\d	the date
 //	\e	escape (ascii 033)
 //	\h	the hostname up to the first `.'
 //	\H	the hostname
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -43,16 +43,24 @@ protected:
 public:
 
   typedef int (*startup_hook_fcn) (void);
 
   typedef int (*event_hook_fcn) (void);
 
   typedef std::string (*completion_fcn) (const std::string&, int);
 
+  typedef std::string (*quoting_fcn) (const std::string&, int, char);
+
+  typedef std::string (*dequoting_fcn) (const std::string&, int);
+
+  typedef int (*char_is_quoted_fcn) (const std::string&, int);
+
+  typedef void (*user_accept_line_fcn) (const std::string&);
+
   virtual ~command_editor (void) { }
 
   static void set_name (const std::string& n);
 
   static std::string readline (const std::string& prompt);
 
   static std::string readline (const std::string& prompt, bool& eof);
 
@@ -79,42 +87,66 @@ public:
   static void blink_matching_paren (bool flag);
 
   static void set_basic_word_break_characters (const std::string& s);
 
   static void set_completer_word_break_characters (const std::string& s);
 
   static void set_basic_quote_characters (const std::string& s);
 
+  static void set_filename_quote_characters (const std::string& s);
+
+  static void set_completer_quote_characters (const std::string& s);
+
   static void set_completion_append_character (char c);
 
   static void set_completion_function (completion_fcn f);
 
+  static void set_quoting_function (quoting_fcn f);
+
+  static void set_dequoting_function (dequoting_fcn f);
+
+  static void set_char_is_quoted_function (char_is_quoted_fcn f);
+
+  static void set_user_accept_line_function (user_accept_line_fcn f);
+
   static completion_fcn get_completion_function (void);
 
+  static quoting_fcn get_quoting_function (void);
+
+  static dequoting_fcn get_dequoting_function (void);
+
+  static char_is_quoted_fcn get_char_is_quoted_function (void);
+
+  static user_accept_line_fcn get_user_accept_line_function (void);
+
   static string_vector generate_filename_completions (const std::string& text);
 
   static void insert_text (const std::string& text);
 
   static void newline (void);
 
+  static void accept_line (void);
+
   static void clear_undo_list (void);
 
   static void add_startup_hook (startup_hook_fcn f);
 
   static void remove_startup_hook (startup_hook_fcn f);
 
   static void add_event_hook (event_hook_fcn f);
 
   static void remove_event_hook (event_hook_fcn f);
 
   static void read_init_file (const std::string& file = std::string ());
 
   static bool filename_completion_desired (bool);
 
+  static bool filename_quoting_desired (bool);
+
   static int current_command_number (void);
 
   static void reset_current_command_number (int n);
 
   static void increment_current_command_number (void);
 
 private:
 
@@ -187,42 +219,66 @@ protected:
   virtual void do_blink_matching_paren (bool) { }
 
   virtual void do_set_basic_word_break_characters (const std::string&) { }
 
   virtual void do_set_completer_word_break_characters (const std::string&) { }
 
   virtual void do_set_basic_quote_characters (const std::string&) { }
 
+  virtual void do_set_filename_quote_characters (const std::string&) { }
+
+  virtual void do_set_completer_quote_characters (const std::string&) { }
+
   virtual void do_set_completion_append_character (char) { }
 
   virtual void do_set_completion_function (completion_fcn) { }
 
+  virtual void do_set_quoting_function (quoting_fcn) { }
+
+  virtual void do_set_dequoting_function (dequoting_fcn) { }
+
+  virtual void do_set_char_is_quoted_function (char_is_quoted_fcn) { }
+
+  virtual void do_set_user_accept_line_function (user_accept_line_fcn) { }
+
   virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
+  virtual quoting_fcn do_get_quoting_function (void) const { return 0; }
+
+  virtual dequoting_fcn do_get_dequoting_function (void) const { return 0; }
+
+  virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const { return 0; }
+
+  virtual user_accept_line_fcn do_get_user_accept_line_function (void) const { return 0; }
+
   virtual string_vector do_generate_filename_completions (const std::string& text) = 0;
 
   virtual void do_insert_text (const std::string&) = 0;
 
   virtual void do_newline (void) = 0;
 
+  virtual void do_accept_line (void) = 0;
+
   virtual void do_clear_undo_list (void) { }
 
   virtual void set_startup_hook (startup_hook_fcn) { }
 
   virtual void restore_startup_hook (void) { }
 
   virtual void set_event_hook (startup_hook_fcn) { }
 
   virtual void restore_event_hook (void) { }
 
   virtual void do_read_init_file (const std::string&) { }
 
   virtual bool do_filename_completion_desired (bool) { return false; }
 
+  virtual bool do_filename_quoting_desired (bool) { return false; }
+
   int read_octal (const std::string& s);
 
   void error (int);
 
   void error (const std::string&);
 
   // The current command number.
   int command_number;
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -40,16 +40,20 @@ public:
   typedef void (*solve_singularity_handler) (double rcond);
 
   Matrix (void) : MArray2<double> () { }
 
   Matrix (octave_idx_type r, octave_idx_type c) : MArray2<double> (r, c) { }
 
   Matrix (octave_idx_type r, octave_idx_type c, double val) : MArray2<double> (r, c, val) { }
 
+  Matrix (const dim_vector& dv) : MArray2<double> (dv) { }
+
+  Matrix (const dim_vector& dv, double val) : MArray2<double> (dv, val) { }
+
   Matrix (const Matrix& a) : MArray2<double> (a) { }
 
   Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
 
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -56,16 +56,78 @@ intNDArray<T>::any_element_not_one_or_ze
 
       if (val != 0.0 && val != 1.0)
 	return true;
     }
 
   return false;
 }
 
+
+template <class T>
+intNDArray<T>
+intNDArray<T>::diag (void) const
+{
+  return diag (0);
+}
+
+template <class T>
+intNDArray<T>
+intNDArray<T>::diag (octave_idx_type k) const
+{
+  dim_vector dv = this->dims ();
+  octave_idx_type nd = dv.length ();
+
+  if (nd > 2)
+    {
+      (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");    
+      return intNDArray<T>();
+    }
+  else
+    {
+      octave_idx_type nnr = dv (0);
+      octave_idx_type nnc = dv (1);
+
+      if (k > 0)
+	nnc -= k;
+      else if (k < 0)
+	nnr += k;
+
+      intNDArray<T> d;
+
+      if (nnr > 0 && nnc > 0)
+	{
+	  octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+	  d.resize (dim_vector (ndiag, 1));
+
+	  if (k > 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		d.xelem (i) = this->elem (i, i+k);
+	    }
+	  else if (k < 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		d.xelem (i) = this->elem (i-k, i);
+	    }
+	  else
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		d.xelem (i) = this->elem (i, i);
+	    }
+	}
+      else
+	(*current_liboctave_error_handler)
+	  ("diag: requested diagonal out of range");
+
+      return d;
+    }
+}
+
 // FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (this->elem (iter_idx) == T (0)), true);
 }
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -61,16 +61,19 @@ public:
       MArrayN<T>::operator = (a);
       return *this;
     }
 
   boolNDArray operator ! (void) const;
 
   bool any_element_not_one_or_zero (void) const;
 
+  intNDArray diag (void) const;
+  intNDArray diag (octave_idx_type k) const;
+
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray squeeze (void) const
     { return intNDArray<T> (MArrayN<T>::squeeze ()); }
 
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -42,16 +42,22 @@ 02110-1301, USA.
       free (ss); \
       ss = 0; \
     } \
  \
   ss = malloc (strlen (s) + 1); \
  \
   strcpy (ss, s)
 
+void
+octave_rl_redisplay (void)
+{
+  rl_redisplay ();
+}
+
 int
 octave_rl_screen_height (void)
 {
   int rows, cols;
   rl_get_screen_size (&rows, &cols);
   return rows;
 }
 
@@ -113,20 +119,26 @@ octave_rl_restore_terminal_state ()
 }
 
 void
 octave_rl_insert_text (const char *s)
 {
   rl_insert_text (s);
 }
 
-void
-octave_rl_newline (void)
+int
+octave_rl_newline (int count, int key)
 {
-  rl_newline (1, '\n');
+  return rl_newline (count, key);
+}
+
+const char *
+octave_rl_line_buffer (void)
+{
+  return rl_line_buffer;
 }
 
 void
 octave_rl_clear_undo_list (void)
 {
   if (rl_undo_list)
     {
       rl_free_undo_list ();
@@ -191,16 +203,24 @@ octave_rl_read_init_file (const char *f)
 int
 octave_rl_filename_completion_desired (int arg)
 {
   int retval = rl_filename_completion_desired;
   rl_filename_completion_desired = arg;
   return retval;
 }
 
+int
+octave_rl_filename_quoting_desired (int arg)
+{
+  int retval = rl_filename_quoting_desired;
+  rl_filename_quoting_desired = arg;
+  return retval;
+}
+
 char *
 octave_rl_filename_completion_function (const char *text, int state)
 {
   return rl_filename_completion_function (text, state);
 }
 
 void
 octave_rl_set_basic_word_break_characters (const char *s)
@@ -222,28 +242,62 @@ void
 octave_rl_set_basic_quote_characters (const char *s)
 {
   OCTAVE_RL_SAVE_STRING (ss, s);
 
   rl_basic_quote_characters = ss;
 }
 
 void
+octave_rl_set_filename_quote_characters (const char *s)
+{
+  OCTAVE_RL_SAVE_STRING (ss, s);
+
+  rl_filename_quote_characters = ss;
+}
+
+void
+octave_rl_set_completer_quote_characters (const char *s)
+{
+  OCTAVE_RL_SAVE_STRING (ss, s);
+
+  rl_completer_quote_characters = ss;
+}
+
+void
 octave_rl_set_completion_append_character (char c)
 {
   rl_completion_append_character = c;
 }
 
 void
 octave_rl_set_completion_function (rl_attempted_completion_fcn_ptr f)
 {
   rl_attempted_completion_function = f;
 }
 
 void
+octave_rl_set_quoting_function (rl_quoting_fcn_ptr f)
+{
+  rl_filename_quoting_function = f;
+}
+
+void
+octave_rl_set_dequoting_function (rl_dequoting_fcn_ptr f)
+{
+  rl_filename_dequoting_function = f;
+}
+
+void
+octave_rl_set_char_is_quoted_function (rl_char_is_quoted_fcn_ptr f)
+{
+  rl_char_is_quoted_p = f;
+}
+
+void
 octave_rl_set_startup_hook (rl_startup_hook_fcn_ptr f)
 {
   rl_startup_hook = f;
 }
 
 rl_startup_hook_fcn_ptr
 octave_rl_get_startup_hook (void)
 {
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
--- a/liboctave/oct-rl-edit.h
+++ b/liboctave/oct-rl-edit.h
@@ -29,38 +29,50 @@ typedef int (*rl_startup_hook_fcn_ptr) (
 typedef int (*rl_event_hook_fcn_ptr) (void);
 
 typedef int (*rl_fcn_ptr) (int, int);
 
 typedef char ** (*rl_attempted_completion_fcn_ptr) (const char *, int, int);
 
 typedef char * (*rl_completer_fcn_ptr) (const char *, int);
 
+typedef char * (*rl_quoting_fcn_ptr) (char *, int, char *);
+
+typedef char * (*rl_dequoting_fcn_ptr) (char *, int);
+
+typedef int (*rl_char_is_quoted_fcn_ptr) (char *, int);
+
+typedef int (*rl_command_fcn_ptr) (int, int);
+
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 
+  extern void octave_rl_redisplay (void);
+
 extern int octave_rl_screen_height (void);
 
 extern int octave_rl_screen_width (void);
 
 extern void octave_rl_enable_paren_matching (int);
 
 extern void octave_rl_init (void);
 
 extern void octave_rl_clear_screen (void);
 
 extern void octave_rl_resize_terminal (void);
 
 extern void octave_rl_restore_terminal_state (void);
 
 extern void octave_rl_insert_text (const char *);
 
-extern void octave_rl_newline (void);
+extern int octave_rl_newline (int, int);
+
+extern const char *octave_rl_line_buffer (void);
 
 extern void octave_rl_clear_undo_list (void);
 
 extern void octave_rl_set_name (const char *);
 
 extern char *octave_rl_readline (const char *);
 
 extern void octave_rl_set_input_stream (FILE *);
@@ -70,29 +82,43 @@ extern FILE *octave_rl_get_input_stream 
 extern void octave_rl_set_output_stream (FILE *);
 
 extern FILE *octave_rl_get_output_stream (void);
 
 extern void octave_rl_read_init_file (const char *);
 
 extern int octave_rl_filename_completion_desired (int);
 
+extern int octave_rl_filename_quoting_desired (int);
+
 extern char *octave_rl_filename_completion_function (const char *, int);
 
 extern void octave_rl_set_basic_word_break_characters (const char *);
 
 extern void octave_rl_set_completer_word_break_characters (const char *);
 
 extern void octave_rl_set_basic_quote_characters (const char *);
 
+extern void octave_rl_set_filename_quote_characters (const char *);
+
+extern void octave_rl_set_completer_quote_characters (const char *);
+
 extern void octave_rl_set_completion_append_character (char);
 
 extern void
 octave_rl_set_completion_function (rl_attempted_completion_fcn_ptr);
 
+extern void
+octave_rl_set_quoting_function (rl_quoting_fcn_ptr);
+
+extern void
+octave_rl_set_dequoting_function (rl_dequoting_fcn_ptr);
+
+extern void octave_rl_set_char_is_quoted_function (rl_char_is_quoted_fcn_ptr);
+
 extern void octave_rl_set_startup_hook (rl_startup_hook_fcn_ptr);
 
 extern rl_startup_hook_fcn_ptr octave_rl_get_startup_hook (void);
 
 extern void octave_rl_set_event_hook (rl_event_hook_fcn_ptr f);
 
 extern rl_event_hook_fcn_ptr octave_rl_get_event_hook (void);
 
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,13 @@
+2007-10-08  David Bateman  <dbateman@free.fr>
+
+	* general/interp2.m: Relax test for values outside the grid to
+	allow monotonically decreasing abscissa as well.
+
 2007-10-08  Ben Abbott <bpabbott@mac.com>
 
 	* polynomial/residue.m: Doc fix.  Add tests.  Restore multiplicity
 	as output parameter.
 
 2007-10-08  Peter A. Gustafson  <petegus@umich.edu>
 
 	* plot/__go_draw_axes__.m, plot/legend.m:
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -214,17 +214,38 @@ function ZI = interp2 (varargin)
       ytable = Y(:, 1)';
       ii = (XI - xtable(xidx) > xtable(xidx + 1) - XI);
       jj = (YI - ytable(yidx) > ytable(yidx + 1) - YI);
       idx = sub2ind (size (Z), yidx+jj, xidx+ii);
       ZI = Z(idx);
     endif
 
     ## set points outside the table to 'extrapval'
-    ZI (XI < X(1,1) | XI > X(1,end) | YI < Y(1,1) | YI > Y(end,1)) = extrapval;
+    if (X (1, 1) < X (1, end))
+      if (Y (1, 1) < Y (end, 1))
+        ZI (XI < X(1,1) | XI > X(1,end) | YI < Y(1,1) | YI > Y(end,1)) = ...
+		extrapval;
+	disp("1\n");
+      else
+        ZI (XI < X(1,1) | XI > X(1,end) | YI < Y(end,1) | YI > Y(1,1)) = ...
+		extrapval;
+	disp("2\n");
+      endif
+    else
+      if (Y (1, 1) < Y (end, 1))
+        ZI (XI < X(1,end) | XI > X(1,1) | YI < Y(1,1) | YI > Y(end,1)) = ...
+		extrapval;
+	disp("3\n");
+      else
+        ZI (XI < X(1,end) | XI > X(1,1) | YI < Y(end,1) | YI > Y(1,1)) = ...
+		extrapval;
+	disp("4\n");
+      endif
+    endif
+
     ZI = reshape (ZI, shape);
   else
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
       X = X(:).';
       Y = Y(:);
       if (!isequal ([length(X), length(Y)], size(Z)))
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,24 @@
+2007-10-08  David Bateman  <dbateman@free.fr>
+
+	*  input.cc (quoting_filename): Function to add a leading quote to
+	a string if needed.
+	(accept_line): Function to check if a string needs a closing quote
+	before calling the rl_newline function.
+	(initialize_command_input): Initialize completer_quote_characters,
+	filename_quote_characters, quoting_function,
+	user_accept_line_function.
+
+	* data.cc (template <class T> static make_diag (...)): New
+	template class version of make_diag. Make other make_diag
+	functions depend on it.
+	( static octave_value make_diag (const octave_value&, 
+	octave_idx_type)): Treat all possible internal Octave types.
+
 2007-10-08  John W. Eaton  <jwe@octave.org>
 
 	* load-save.cc 	(save_vars, dump_octave_core):
 	Don't pass INFNAN_WARNED to do_save.
 	(do_save): Delete unused arg, INFNAN_WARNED.
 	Don't pass INFNAN_WARNED to save_ascii_data.
 	* ls-oct-ascii.cc (save_ascii_data_for_plotting):
 	Don't pass INFNAN_WARNED to save_ascii.
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -428,215 +428,191 @@ is omitted, it defaults to 1 (column-wis
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the cumulative sum of the elements as a vector with the\n\
 same orientation as @var{x}.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumsum);
 }
 
-// FIXME -- we could eliminate some duplicate code here with
-// some template functions or macros.
-
+template <class T>
 static octave_value
-make_diag (const Matrix& v, octave_idx_type k)
+make_diag (const T& v, octave_idx_type k)
 {
-  octave_idx_type nr = v.rows ();
-  octave_idx_type nc = v.columns ();
-  assert (nc == 1 || nr == 1);
-
   octave_value retval;
-
-  octave_idx_type roff = 0;
-  octave_idx_type coff = 0;
-  if (k > 0)
-    {
-      roff = 0;
-      coff = k;
-    }
-  else if (k < 0)
-    {
-      roff = -k;
-      coff = 0;
-    }
-
-  if (nr == 1)
-    {
-      octave_idx_type n = nc + std::abs (k);
-      Matrix m (n, n, 0.0);
-      for (octave_idx_type i = 0; i < nc; i++)
-	m (i+roff, i+coff) = v (0, i);
-      retval = m;
-    }
+  dim_vector dv = v.dims ();
+  octave_idx_type nd = dv.length ();
+
+  if (nd > 2)
+    error ("diag: expecting 2-dimensional matrix");
   else
     {
-      octave_idx_type n = nr + std::abs (k);
-      Matrix m (n, n, 0.0);
-      for (octave_idx_type i = 0; i < nr; i++)
-	m (i+roff, i+coff) = v (i, 0);
-      retval = m;
+      octave_idx_type nr = dv (0);
+      octave_idx_type nc = dv (1);
+
+      if (nr == 0 || nc == 0)
+	retval = T ();
+      else if (nr != 1 && nc != 1)
+	retval = v.diag (k);
+      else
+	{
+	  octave_idx_type roff = 0;
+	  octave_idx_type coff = 0;
+	  if (k > 0)
+	    {
+	      roff = 0;
+	      coff = k;
+	    }
+	  else if (k < 0)
+	    {
+	      roff = -k;
+	      coff = 0;
+	    }
+
+	  if (nr == 1)
+	    {
+	      octave_idx_type n = nc + std::abs (k);
+	      T m (dim_vector (n, n), T::resize_fill_value ());
+
+	      for (octave_idx_type i = 0; i < nc; i++)
+		m (i+roff, i+coff) = v (0, i);
+	      retval = m;
+	    }
+	  else
+	    {
+	      octave_idx_type n = nr + std::abs (k);
+	      T m (dim_vector (n, n), T::resize_fill_value ());
+	      for (octave_idx_type i = 0; i < nr; i++)
+		m (i+roff, i+coff) = v (i, 0);
+	      retval = m;
+	    }
+	}
     }
-
+  
   return retval;
 }
 
+#if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
+static octave_value
+make_diag (const Matrix& v, octave_idx_type k);
+
+static octave_value
+make_diag (const ComplexMatrix& v, octave_idx_type k);
+
+static octave_value
+make_diag (const charMatrix& v, octave_idx_type k);
+
+static octave_value
+make_diag (const boolMatrix& v, octave_idx_type k);
+
+static octave_value
+make_diag (const int8NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const int16NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const int32NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const int64NDArray& v, octave_idx_type k);
+
 static octave_value
-make_diag (const ComplexMatrix& v, octave_idx_type k)
+make_diag (const uint8NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const uint16NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const uint32NDArray& v, octave_idx_type k);
+
+static octave_value
+make_diag (const uint64NDArray& v, octave_idx_type k);
+#endif
+
+static octave_value
+make_diag (const octave_value& a, octave_idx_type k)
 {
-  octave_idx_type nr = v.rows ();
-  octave_idx_type nc = v.columns ();
-  assert (nc == 1 || nr == 1);
-
   octave_value retval;
-
-  octave_idx_type roff = 0;
-  octave_idx_type coff = 0;
-  if (k > 0)
-    {
-      roff = 0;
-      coff = k;
-    }
-  else if (k < 0)
+  std::string result_type = a.class_name ();
+
+  if (result_type == "double")
     {
-      roff = -k;
-      coff = 0;
+      if (a.is_real_type ())
+	{
+	  Matrix m = a.matrix_value ();
+	  if (!error_state)
+	    retval = make_diag (m, k);
+	}
+      else
+	{
+	  ComplexMatrix m = a.complex_matrix_value ();
+	  if (!error_state)
+	    retval = make_diag (m, k);
+	}
     }
-
-  if (nr == 1)
+#if 0
+  else if (result_type == "single")
+    retval = make_diag (a.single_array_value (), k);
+#endif
+  else if (result_type == "char")
     {
-      octave_idx_type n = nc + std::abs (k);
-      ComplexMatrix m (n, n, 0.0);
-      for (octave_idx_type i = 0; i < nc; i++)
-	m (i+roff, i+coff) = v (0, i);
-      retval = m;
+      charMatrix m = a.char_matrix_value ();
+      if (!error_state)
+	{
+	  retval = make_diag (m, k);
+	  if (a.is_sq_string ())
+	    retval = octave_value (retval.char_array_value (), true, '\'');
+	}
+    }
+  else if (result_type == "logical")
+    {
+      boolMatrix m = a.bool_matrix_value ();
+      if (!error_state)
+	retval = make_diag (m, k);
     }
+  else if (result_type == "int8")
+    retval = make_diag (a.int8_array_value (), k);
+  else if (result_type == "int16")
+    retval = make_diag (a.int16_array_value (), k);
+  else if (result_type == "int32")
+    retval = make_diag (a.int32_array_value (), k);
+  else if (result_type == "int64")
+    retval = make_diag (a.int64_array_value (), k);
+  else if (result_type == "uint8")
+    retval = make_diag (a.uint8_array_value (), k);
+  else if (result_type == "uint16")
+    retval = make_diag (a.uint16_array_value (), k);
+  else if (result_type == "uint32")
+    retval = make_diag (a.uint32_array_value (), k);
+  else if (result_type == "uint64")
+    retval = make_diag (a.uint64_array_value (), k);
   else
-    {
-      octave_idx_type n = nr + std::abs (k);
-      ComplexMatrix m (n, n, 0.0);
-      for (octave_idx_type i = 0; i < nr; i++)
-	m (i+roff, i+coff) = v (i, 0);
-      retval = m;
-    }
+    gripe_wrong_type_arg ("diag", a);
 
   return retval;
 }
 
 static octave_value
 make_diag (const octave_value& arg)
 {
-  octave_value retval;
-
-  if (arg.is_real_type ())
-    {
-      Matrix m = arg.matrix_value ();
-
-      if (! error_state)
-	{
-	  octave_idx_type nr = m.rows ();
-	  octave_idx_type nc = m.columns ();
-
-	  if (nr == 0 || nc == 0)
-	    retval = Matrix ();
-	  else if (nr == 1 || nc == 1)
-	    retval = make_diag (m, 0);
-	  else
-	    {
-	      ColumnVector v = m.diag ();
-	      if (v.numel () > 0)
-		retval = v;
-	    }
-	}
-      else
-	gripe_wrong_type_arg ("diag", arg);
-    }
-  else if (arg.is_complex_type ())
-    {
-      ComplexMatrix cm = arg.complex_matrix_value ();
-
-      if (! error_state)
-	{
-	  octave_idx_type nr = cm.rows ();
-	  octave_idx_type nc = cm.columns ();
-
-	  if (nr == 0 || nc == 0)
-	    retval = Matrix ();
-	  else if (nr == 1 || nc == 1)
-	    retval = make_diag (cm, 0);
-	  else
-	    {
-	      ComplexColumnVector v = cm.diag ();
-	      if (v.numel () > 0)
-		retval = v;
-	    }
-	}
-      else
-	gripe_wrong_type_arg ("diag", arg);
-    }
-  else
-    gripe_wrong_type_arg ("diag", arg);
-
-  return retval;
+  return make_diag (arg, 0);
 }
 
 static octave_value
 make_diag (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
 
   octave_idx_type k = b.int_value ();
 
   if (error_state)
-    {
-      error ("diag: invalid second argument");      
-      return retval;
-    }
-
-  if (a.is_real_type ())
-    {
-      Matrix m = a.matrix_value ();
-
-      if (! error_state)
-	{
-	  octave_idx_type nr = m.rows ();
-	  octave_idx_type nc = m.columns ();
-
-	  if (nr == 1 || nc == 1)
-	    retval = make_diag (m, k);
-	  else if (nr == 0 || nc == 0)
-	    retval = Matrix ();
-	  else
-	    {
-	      ColumnVector d = m.diag (k);
-	      retval = d;
-	    }
-	}
-    }
-  else if (a.is_complex_type ())
-    {
-      ComplexMatrix cm = a.complex_matrix_value ();
-
-      if (! error_state)
-	{
-	  octave_idx_type nr = cm.rows ();
-	  octave_idx_type nc = cm.columns ();
-
-	  if (nr == 1 || nc == 1)
-	    retval = make_diag (cm, k);
-	  else if (nr == 0 || nc == 0)
-	    retval = Matrix ();
-	  else
-	    {
-	      ComplexColumnVector d = cm.diag (k);
-	      retval = d;
-	    }
-	}
-    }
+    error ("diag: invalid second argument");      
   else
-    gripe_wrong_type_arg ("diag", a);
+    retval = make_diag (a, k);
 
   return retval;
 }
 
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} diag (@var{v}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -502,17 +502,17 @@ generate_completion (const std::string& 
 	      if (list_index <= name_list_len && ! prefix.empty ())
 		retval = prefix + "." + name;
 	      else
 		retval = name;
 
 	      // FIXME -- looks_like_struct is broken for now,
 	      // so it always returns false.
 
- 	      if (matches == 1 && looks_like_struct (retval))
+	      if (matches == 1 && looks_like_struct (retval))
  		{
  		  // Don't append anything, since we don't know
  		  // whether it should be '(' or '.'.
 
  		  command_editor::set_completion_append_character ('\0');
  		}
  	      else
  		command_editor::set_completion_append_character
@@ -521,16 +521,50 @@ generate_completion (const std::string& 
 	      break;
 	    }
 	}
     }
 
   return retval;
 }
 
+static std::string
+quoting_filename (const std::string &text, int, char quote)
+{
+  if (quote)
+    return text;
+  else
+    return (std::string ("'") + text);
+}
+
+static void
+accept_line (const std::string &text)
+{
+  // Close open strings if needed
+  bool sq = false;
+  bool dq = false;
+  bool pass_next = false;
+
+  for (std::string::const_iterator it = text.begin(); it < text.end(); it++)
+    {
+      if (pass_next)
+	pass_next = false;
+      else if (*it == '\\')
+	pass_next = true;
+      else if (*it == '\'' && ! dq)
+	sq = !sq;
+      else if (*it == '"' && ! sq)
+	dq = !dq;
+    }
+  if (sq)
+    command_editor::insert_text("'");
+  if (dq)
+    command_editor::insert_text("\"");
+}
+
 void
 initialize_command_input (void)
 {
   // If we are using readline, this allows conditional parsing of the
   // .inputrc file.
 
   command_editor::set_name ("Octave");
 
@@ -540,17 +574,24 @@ initialize_command_input (void)
   static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
 
   command_editor::set_basic_word_break_characters (s);
 
   command_editor::set_completer_word_break_characters (s);
 
   command_editor::set_basic_quote_characters ("\"");
 
+  command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
+  command_editor::set_completer_quote_characters ("'\"");
+
   command_editor::set_completion_function (generate_completion);
+
+  command_editor::set_quoting_function (quoting_filename);
+
+  command_editor::set_user_accept_line_function (accept_line);
 }
 
 static bool
 match_sans_spaces_semi (const std::string& standard, const std::string& test)
 {
   size_t beg = test.find_first_not_of (" \t");
 
   if (beg != NPOS)
