# HG changeset patch
# User jwe
# Date 1028919616 0
#      Fri Aug 09 19:00:16 2002 +0000
# Node ID 22bd65326ec1a0082e329fe4e879255c6f24dd9d
# Parent  2cc57b6169cfb2d270d152e3417af816f06980ba
[project @ 2002-08-09 18:58:13 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -6,16 +6,17 @@ 2002-08-09  John W. Eaton  <jwe@bevo.che
 	* deprecated/is_list.m: New file.
 	* deprecated/is_matrix.m: New file.
 	* deprecated/is_scalar.m: New file.
 	* deprecated/is_square.m: New file.
 	* deprecated/is_stream.m: New file.
 	* deprecated/is_struct.m: New file.
 	* deprecated/is_symmetric.m: New file.
 	* deprecated/is_vector.m: New file.
+	* Change all callers of these functions to use the new names.
 
 	* deprecated: New directory.
 	* Makefile.in (SUBDIRS): Add it to the list.
 
 	* general/isscalar.m: Rename from is_scalar.m.
 	* general/issquare.m: Rename from is_square.m.
 	* general/issymmetric.m: Rename from is_symmetric.m.
 	* general/isvector.m: Rename from is_vector.m.
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -28,17 +28,17 @@
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
   usage_msg = "playaudio (name, ext)  or  playaudio (X)";
 
-  if (nargin == 1 && is_vector (name) && ! isstr (name))
+  if (nargin == 1 && isvector (name) && ! isstr (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
         name = name';
         nr = nc;
       else
         error ("playaudio: X must be a vector");
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -53,17 +53,17 @@
 function [f, w, rsys] = __bodquist__ (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
     usage ("[f, w] = __bodquist__ (sys, w, outputs, inputs, rname)");
   endif
 
   ## check each argument to see if it's in the correct form
-  if (!is_struct(sys))
+  if (!isstruct(sys))
     error("sys must be a system data structure");
   endif
 
   ## let __freqresp__ determine w if it's not already given
   USEW = freqchkw(w);
 
   ## get initial dimensions (revised below if sysprune is called)
   [nn,nz,mm,pp ] = sysdimensions(sys);
diff --git a/scripts/control/base/are.m b/scripts/control/base/are.m
--- a/scripts/control/base/are.m
+++ b/scripts/control/base/are.m
@@ -72,31 +72,31 @@ function x = are (a, b, c, opt)
              || strcmp (opt, "n") || strcmp (opt, "p") ...
              || strcmp (opt, "s") || strcmp (opt, "b")))
         warning ("are: opt has an invalid value; setting to B");
         opt = "B";
       endif
     else
       opt = "B";
     endif
-    if ((n = is_square(a)) == 0)
+    if ((n = issquare(a)) == 0)
       error ("are: a is not square");
     endif
 
     if (is_controllable(a,b) == 0)
       warning ("are: a, b are not controllable");
     endif
-    if ((m = is_square (b)) == 0)
+    if ((m = issquare (b)) == 0)
       b = b * b';
       m = rows (b);
     endif
     if (is_observable (a, c) == 0)
       warning ("are: a,c are not observable");
     endif
-    if ((p = is_square (c)) == 0)
+    if ((p = issquare (c)) == 0)
       c = c' * c;
       p = rows (c);
     endif
     if (n != m || n != p)
       error ("are: a, b, c not conformably dimensioned.");
     endif
 
 ## Should check for controllability/observability here
diff --git a/scripts/control/base/ctrb.m b/scripts/control/base/ctrb.m
--- a/scripts/control/base/ctrb.m
+++ b/scripts/control/base/ctrb.m
@@ -35,17 +35,17 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 ## based on is_controllable.m of Scottedward Hodel
 
 function Qs = ctrb (sys, b)
 
   if (nargin == 2)
     a = sys;
-  elseif (nargin == 1 && is_struct(sys))
+  elseif (nargin == 1 && isstruct(sys))
     sysupdate(sys,"ss");
     [a,b] = sys2ss(sys);
   else
     usage("ctrb(sys [, b])")
   endif
 
   if (!is_abcd(a,b))
     Qs = [];
diff --git a/scripts/control/base/damp.m b/scripts/control/base/damp.m
--- a/scripts/control/base/damp.m
+++ b/scripts/control/base/damp.m
@@ -32,30 +32,30 @@
 
 function damp (p, tsam)
 
   ## assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
     usage("damp(p,[ tsamp])")
   endif
-  if(is_struct(p))
+  if(isstruct(p))
     if (nargin != 1)
       error("damp: when p is a system, tsamp parameter is not allowed.");
     endif
     [aa, b, c, d, t_samp] = sys2ss(p);
     DIGITAL = is_digital(p);
   else
     aa = p;
     if (nargin == 2)
         DIGITAL = 1;
         t_samp = tsam;
     endif
   endif
-  if (!is_square(aa))
+  if (!issquare(aa))
     error("damp: Matrix p is not square.")
   endif
   if (DIGITAL && t_samp <= 0.0)
     error("damp: Sampling time tsam must not be <= 0.")
   endif
 
   ## all checks done.
   e = eig(aa);
diff --git a/scripts/control/base/dare.m b/scripts/control/base/dare.m
--- a/scripts/control/base/dare.m
+++ b/scripts/control/base/dare.m
@@ -88,25 +88,25 @@ function x = dare (a, b, c, r, opt)
 
     ## dimension checks are done in is_controllable, is_observable
     if (is_controllable (a, b) == 0)
       warning ("dare: a,b are not controllable");
     elseif (is_observable (a, c) == 0)
       warning ("dare: a,c are not observable");
     endif
 
-    if ((p = is_square (c)) == 0)
+    if ((p = issquare (c)) == 0)
       c = c'*c;
       p = rows (c);
     endif
 
     ## Check r dimensions.
     n = rows(a);
     m = columns(b);
-    if ((m1 = is_square (r)) == 0)
+    if ((m1 = issquare (r)) == 0)
       warning ("dare: r is not square");
     elseif (m1 != m)
       warning ("b,r are not conformable");
     endif
 
     s1 = [a, zeros(n) ; -c, eye(n)];
     s2 = [eye(n), (b/r)*b' ; zeros(n), a'];
     [c,d,s1,s2] = balance(s1,s2,opt);
diff --git a/scripts/control/base/dcgain.m b/scripts/control/base/dcgain.m
--- a/scripts/control/base/dcgain.m
+++ b/scripts/control/base/dcgain.m
@@ -27,17 +27,17 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 1, 1997
 
 function gm = dcgain (sys, tol)
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
     usage("[gm, ok] = dcgain(sys[, tol])");
   endif
-  if(!is_struct(sys))
+  if(!isstruct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
   sys = sysupdate(sys, "ss");
   [aa,bb,cc,dd] = sys2ss(sys);
   if (is_digital(sys))  aa = aa - eye(size(aa));  endif
   if (nargin == 1)  tol = 1.0e-10;  endif
   r = rank(aa, tol);
   if (r < rows(aa))
diff --git a/scripts/control/base/dkalman.m b/scripts/control/base/dkalman.m
--- a/scripts/control/base/dkalman.m
+++ b/scripts/control/base/dkalman.m
@@ -110,43 +110,43 @@
 
 function [Lp, Lf, P, Z] = dkalman (A, G, C, Qw, Rv, S)
 
   if (nargin != 5 && nargin != 6)
     error ("dkalman: invalid number of arguments");
   endif
 
   ## Check A.
-  if ((n = is_square (A)) == 0)
+  if ((n = issquare (A)) == 0)
     error ("dkalman: requires 1st parameter(A) to be square");
   endif
 
   ## Check C.
   [p, n1] = size (C);
   if (n1 != n)
     error ("dkalman: A,C not conformal");
   endif
 
   ## Check G.
   [n1, nw] = size (G);
   if (n1 != n)
     error ("dkalman: A,G not conformal");
   endif
 
   ## Check Qw.
-  if ((nw1 = is_square (Qw)) == 0)
+  if ((nw1 = issquare (Qw)) == 0)
     error ("dkalman: requires 4rd parameter(Qw) to be square");
   else
     if (nw1 != nw)
       error ("dkalman: G,Qw not conformal");
     endif
   endif
 
   ## Check Rv.
-  if ((p1 = is_square (Rv)) == 0)
+  if ((p1 = issquare (Rv)) == 0)
     error ("dkalman: requires 5rd parameter(Rv) to be square");
   else
     if (p1 != p)
       error ("dkalman: C,Rv not conformal");
     endif
   endif
 
   ## Check S if it is there
diff --git a/scripts/control/base/dlqr.m b/scripts/control/base/dlqr.m
--- a/scripts/control/base/dlqr.m
+++ b/scripts/control/base/dlqr.m
@@ -106,33 +106,33 @@
 
 function [k, p, e] = dlqr (a, b, q, r, s)
 
   if (nargin != 4 && nargin != 5)
     error ("dlqr: invalid number of arguments");
   endif
 
   ## Check a.
-  if ((n = is_square (a)) == 0)
+  if ((n = issquare (a)) == 0)
     error ("dlqr: requires 1st parameter(a) to be square");
   endif
 
   ## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("dlqr: a,b not conformal");
   endif
 
   ## Check q.
-  if ((n1 = is_square (q)) == 0 || n1 != n)
+  if ((n1 = issquare (q)) == 0 || n1 != n)
     error ("dlqr: q must be square and conformal with a");
   endif
 
   ## Check r.
-  if((m1 = is_square(r)) == 0 || m1 != m)
+  if((m1 = issquare(r)) == 0 || m1 != m)
     error ("dlqr: r must be square and conformal with column dimension of b");
   endif
 
   ## Check if n is there.
   if (nargin == 5)
     [n1, m1] = size (s);
     if (n1 != n || m1 != m)
       error ("dlqr: z must be identically dimensioned with b");
@@ -144,17 +144,17 @@ function [k, p, e] = dlqr (a, b, q, r, s
     qo = q - (s/r)*s';
   else
     s = zeros (n, m);
     ao = a;
     qo = q;
   endif
 
   ## Check that q, (r) are symmetric, positive (semi)definite
-  if (is_symmetric (q) && is_symmetric (r)
+  if (issymmetric (q) && issymmetric (r)
       && all (eig (q) >= 0) && all (eig (r) > 0))
     p = dare (ao, b, qo, r);
     k = (r+b'*p*b)\(b'*p*a + s');
     e = eig (a - b*k);
   else
     error ("dlqr: q (r) must be symmetric positive (semi) definite");
   endif
 
diff --git a/scripts/control/base/dlyap.m b/scripts/control/base/dlyap.m
--- a/scripts/control/base/dlyap.m
+++ b/scripts/control/base/dlyap.m
@@ -58,21 +58,21 @@
 ## 2, pages 303--323 (1982).
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 
 function x = dlyap (a, b)
 
-  if ((n = is_square (a)) == 0)
+  if ((n = issquare (a)) == 0)
     warning ("dlyap: a must be square");
   endif
 
-  if ((m = is_square (b)) == 0)
+  if ((m = issquare (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
       b = b*b';
       m = n1;
     else
       b = b'*b;
       a = a';
     endif
diff --git a/scripts/control/base/dre.m b/scripts/control/base/dre.m
--- a/scripts/control/base/dre.m
+++ b/scripts/control/base/dre.m
@@ -87,32 +87,32 @@
 ## @end example
 ## @end table
 ## @end deftypefn
 
 function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
     usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
-  elseif(!is_struct(sys))
+  elseif(!isstruct(sys))
     error("sys must be a system data structure")
   elseif(is_digital(sys))
     error("sys must be a continuous time system")
-  elseif(!is_matrix(Q) | !is_matrix(R) | !is_matrix(Qf))
+  elseif(!ismatrix(Q) | !ismatrix(R) | !ismatrix(Qf))
     error("Q, R, and Qf must be matrices.");
-  elseif(!is_scalar(t0) | !is_scalar(tf))
+  elseif(!isscalar(t0) | !isscalar(tf))
     error("t0 and tf must be scalars")
   elseif(t0 >= tf)              error("t0=%e >= tf=%e",t0,tf);
   elseif(nargin == 6)           Ptol = 0.1;
-  elseif(!is_scalar(Ptol))      error("Ptol must be a scalar");
+  elseif(!isscalar(Ptol))      error("Ptol must be a scalar");
   elseif(Ptol <= 0)             error("Ptol must be positive");
   endif
 
   if(nargin < 8) maxits = 10;
-  elseif(!is_scalar(maxits))    error("maxits must be a scalar");
+  elseif(!isscalar(maxits))    error("maxits must be a scalar");
   elseif(maxits <= 0)           error("maxits must be positive");
   endif
   maxits = ceil(maxits);
 
   [aa,bb] = sys2ss(sys);
   nn = sysdimensions(sys,"cst");
   mm = sysdimensions(sys,"in");
   pp = sysdimensions(sys,"out");
diff --git a/scripts/control/base/freqchkw.m b/scripts/control/base/freqchkw.m
--- a/scripts/control/base/freqchkw.m
+++ b/scripts/control/base/freqchkw.m
@@ -25,17 +25,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function USEW = freqchkw (w)
 
   if(isempty(w))
     USEW = 0;
-  elseif(!is_vector(w))
+  elseif(!isvector(w))
     error(["w (",num2str(rows(w)),"x",num2str(columns(w)), ...
       "): must be [], a vector or a scalar"]);
   elseif( (max(abs(imag(w))) != 0) && (min(real(w)) <= 0) )
     error("w must have real positive entries");
   else
     w = sort(w);
     USEW = 1;   # vector provided (check values later)
   endif
diff --git a/scripts/control/base/impulse.m b/scripts/control/base/impulse.m
--- a/scripts/control/base/impulse.m
+++ b/scripts/control/base/impulse.m
@@ -53,17 +53,17 @@ function [y, t] = impulse (sys, inp, tst
   if ((nargin < 1) || (nargin > 4))
     usage ("[y, u] = impulse (sys, inp, tstop, n)");
   endif
 
   if (nargout > 2)
     usage ("[y, u] = impulse (sys, inp, tstop, n)");
   endif
 
-  if (! is_struct (sys))
+  if (! isstruct (sys))
     error ("impulse: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
       case (1)
         __stepimp__ (2, sys);
       case (2)
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -67,17 +67,17 @@
 ## Created: August 1995
 ## revised for new system format August 1996
 
 function [K, Q1, P1, Ee, Er] = lqg (sys, Sigw, Sigv, Q, R, input_list)
 
   if ( (nargin < 5) | (nargin > 6))
     usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
 
-  elseif(!is_struct(sys) )
+  elseif(!isstruct(sys) )
     error("sys must be in system data structure");
   endif
 
   DIG = is_digital(sys);
   [A,B,C,D,tsam,n,nz,stname,inname,outname] = sys2ss(sys);
   [n,nz,nin,nout] = sysdimensions(sys);
   if(nargin == 5)
     ## construct default input_list
@@ -103,17 +103,17 @@ function [K, Q1, P1, Ee, Er] = lqg (sys,
 
   if(length(input_list) != columns(R))
     error(["lqg: length(input_list)=",num2str(length(input_list)), ...
           ", columns(R)=", num2str(columns(R))]);
   endif
 
   varname = list("Sigw","Sigv","Q","R");
   for kk=1:length(varname);
-    eval(sprintf("chk = is_square(%s);",nth(varname,kk)));
+    eval(sprintf("chk = issquare(%s);",nth(varname,kk)));
     if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
   endfor
 
   ## permute (if need be)
   if(nargin == 6)
     all_inputs = sysreorder(nin,input_list);
     B = B(:,all_inputs);
     inname = inname(all_inputs);
diff --git a/scripts/control/base/lqr.m b/scripts/control/base/lqr.m
--- a/scripts/control/base/lqr.m
+++ b/scripts/control/base/lqr.m
@@ -118,33 +118,33 @@ function [k, p, e] = lqr (a, b, q, r, s)
 
   ## disp("lqr: entry");
 
   if ((nargin != 4) && (nargin != 5))
     error ("lqr: invalid number of arguments");
   endif
 
   ## Check a.
-  if ((n = is_square (a)) == 0)
+  if ((n = issquare (a)) == 0)
     error ("lqr: requires 1st parameter(a) to be square");
   endif
 
   ## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("lqr: a,b not conformal");
   endif
 
   ## Check q.
-  if ( ((n1 = is_square (q)) == 0) || (n1 != n))
+  if ( ((n1 = issquare (q)) == 0) || (n1 != n))
     error ("lqr: q must be square and conformal with a");
   endif
 
   ## Check r.
-  if ( ((m1 = is_square(r)) == 0) || (m1 != m))
+  if ( ((m1 = issquare(r)) == 0) || (m1 != m))
     error ("lqr: r must be square and conformal with column dimension of b");
   endif
 
   ## Check if n is there.
   if (nargin == 5)
     [n1, m1] = size (s);
     if ( (n1 != n) || (m1 != m))
       error ("lqr: z must be identically dimensioned with b");
@@ -156,17 +156,17 @@ function [k, p, e] = lqr (a, b, q, r, s)
   else
     s = zeros (n, m);
     ao = a;
     qo = q;
   endif
 
   ## Check that q, (r) are symmetric, positive (semi)definite
 
-  if (is_symmetric (q) && is_symmetric (r) ...
+  if (issymmetric (q) && issymmetric (r) ...
       && all (eig (q) >= 0) && all (eig (r) > 0))
     p = are (ao, (b/r)*b', qo);
     k = r\(b'*p + s');
     e = eig (a - b*k);
   else
     error ("lqr: q (r) must be symmetric positive (semi) definite");
   endif
 
diff --git a/scripts/control/base/lsim.m b/scripts/control/base/lsim.m
--- a/scripts/control/base/lsim.m
+++ b/scripts/control/base/lsim.m
@@ -40,17 +40,17 @@
 ## modified by John Ingram for system format August 1996
 
 function [y, x] = lsim (sys, u, t, x0)
 
   if((nargin < 3)||(nargin > 4))
     usage("[y,x] = lsim(sys,u,t[,x0])");
   endif
 
-  if(!is_struct(sys))
+  if(!isstruct(sys))
     error("sys must be in system data structure");
   endif
 
   sys = sysupdate(sys,"ss");
 
   [ncstates, ndstates, nin, nout] = sysdimensions(sys);
   [a,b,c,d] = sys2ss(sys);
 
diff --git a/scripts/control/base/ltifr.m b/scripts/control/base/ltifr.m
--- a/scripts/control/base/ltifr.m
+++ b/scripts/control/base/ltifr.m
@@ -49,21 +49,21 @@ function out = ltifr (a, b, w)
 
   if ((nargin < 2) || (nargin > 3))
     error("incorrect number of input arguments");
   endif
 
   if (nargin == 2)
     sys = a;
     w = b;
-    if(!is_struct(sys))
+    if(!isstruct(sys))
       error("two arguments: 1st must be a system data structure");
     endif
 
-    if (!is_vector(w))
+    if (!isvector(w))
       error("w must be a vector");
     endif
 
     [nn,nz,mm,pp] = sysdimensions(sys);
     if(mm != 1)       error("sys has %d > 1 inputs",mm); endif
 
     [a,b] = sys2ss(sys);
 
@@ -74,23 +74,23 @@ function out = ltifr (a, b, w)
         rows(a), columns(a), rows(b), columns(b));
     endif
 
     if(columns(b) != 1)
       error("ltifr: b(%dx%d) must be a single column vector", ...
         rows(b),columns(b));
     endif
 
-    if (!is_square(a))
+    if (!issquare(a))
       error("ltifr:  A(%dx$d) must be square.",rows(a),columns(a))
     endif
 
   endif
 
-  if (!is_vector(w))
+  if (!isvector(w))
     error("w must be a vector");
   endif
 
   ey = eye(size(a));
   lw = length(w);
   out = ones(columns(a),lw);
 
   for ii=1:lw,
diff --git a/scripts/control/base/lyap.m b/scripts/control/base/lyap.m
--- a/scripts/control/base/lyap.m
+++ b/scripts/control/base/lyap.m
@@ -81,25 +81,25 @@
 ## Adapted-By: jwe
 
 function x = lyap (a, b, c)
 
   if (nargin != 3 && nargin != 2)
     usage ("lyap (a, b {,c})");
   endif
 
-  if ((n = is_square(a)) == 0)
+  if ((n = issquare(a)) == 0)
     error ("lyap: a is not square");
   endif
 
   if (nargin == 2)
 
     ## Transform Lyapunov equation to Sylvester equation form.
 
-    if ((m = is_square (b)) == 0)
+    if ((m = issquare (b)) == 0)
       if ((m = rows (b)) == n)
 
         ## solve a x + x a' + b b' = 0
 
         b = b * b';
         a = a';
       else
 
@@ -119,17 +119,17 @@ function x = lyap (a, b, c)
     c = b;
     b = a;
     a = b';
 
   else
 
     ## Check dimensions.
 
-    if ((m = is_square (b)) == 0)
+    if ((m = issquare (b)) == 0)
       error ("lyap: b must be square in a sylvester equation");
     endif
 
     [n1, m1] = size(c);
 
     if (n != n1 || m != m1)
       error("lyap: a,b,c not conformably dimensioned");
     endif
diff --git a/scripts/control/base/obsv.m b/scripts/control/base/obsv.m
--- a/scripts/control/base/obsv.m
+++ b/scripts/control/base/obsv.m
@@ -38,17 +38,17 @@
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: November 4, 1997
 
 function Qb = obsv (sys, c)
 
   if (nargin == 2)
     a = sys;
-  elseif (nargin == 1 && is_struct(sys))
+  elseif (nargin == 1 && isstruct(sys))
     sysupdate(sys,"ss");
     [a,b,c] = sys2ss(sys);
   else
     usage("obsv(sys [, c])")
   endif
 
   if (!is_abcd(a,c'))
     Qb = [];
diff --git a/scripts/control/base/place.m b/scripts/control/base/place.m
--- a/scripts/control/base/place.m
+++ b/scripts/control/base/place.m
@@ -44,17 +44,17 @@
 
 function K = place (sys, P)
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   ## check arguments
 
-  if(!is_struct(sys))
+  if(!isstruct(sys))
     error("sys must be in system data structure format (see ss2sys)");
   endif
   sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
   if(!is_controllable(sys))
     error("sys is not controllable.");
   elseif( min(size(P)) != 1)
     error("P must be a vector")
   else
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -31,17 +31,17 @@
 function [zer, pol]=pzmap (sys)
 
   save_emp = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
 
   if(nargin != 1)
     usage("pzmap(sys) or [zer,pol] = pzmap(sys)");
-  elseif (!is_struct(sys));
+  elseif (!isstruct(sys));
     error("sys must be in system format");
   endif
 
   [zer,pol] = sys2zp(sys);
 
   ## force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
   if(length(zer))
diff --git a/scripts/control/base/step.m b/scripts/control/base/step.m
--- a/scripts/control/base/step.m
+++ b/scripts/control/base/step.m
@@ -54,17 +54,17 @@ function [y, t] = step (sys, inp, tstop,
   if ((nargin < 1) || (nargin > 4))
     usage ("[y, u] = step(sys, inp, tstop, n)");
   endif
 
   if (nargout > 2)
     usage ("[y, u] = step (sys, inp, tstop, n)");
   endif
 
-  if (! is_struct (sys))
+  if (! isstruct (sys))
     error ("step: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
       case (1)
         __stepimp__ (1, sys);
       case (2)
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -50,17 +50,17 @@
 ## Created: July 4, 1994
 ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
 function [zer, gain] = tzero (A, B, C, D)
 
   ## get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss2sys(A,B,C,D);
-  elseif( (nargin == 1) && (! is_struct(A)))
+  elseif( (nargin == 1) && (! isstruct(A)))
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   else
     Asys = A;
     [A,B,C,D] = sys2ss(Asys);
   endif
 
diff --git a/scripts/control/hinf/h2norm.m b/scripts/control/hinf/h2norm.m
--- a/scripts/control/hinf/h2norm.m
+++ b/scripts/control/hinf/h2norm.m
@@ -28,17 +28,17 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## updated for system data structure by John Ingram November 1996
 
 function h2gain = h2norm (sys)
 
   if((nargin != 1))
     usage("h2gain = h2norm(sys)");
-  elseif(!is_struct(sys))
+  elseif(!isstruct(sys))
     error("Sys must be in system data structure");
   end
   dflg = is_digital(sys);
 
   if(!is_stable(sys))
     warning("h2norm: unstable input system; returning Inf");
     h2gain = Inf;
   else
diff --git a/scripts/control/hinf/hinfnorm.m b/scripts/control/hinf/hinfnorm.m
--- a/scripts/control/hinf/hinfnorm.m
+++ b/scripts/control/hinf/hinfnorm.m
@@ -62,17 +62,17 @@
 ## Int. J. Control, vol 54, #5, 1991
 ## Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
 ## @end deftypefn
 
 function [g, gmin, gmax] = hinfnorm (sys, tol, gmin, gmax, ptol)
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
-  elseif(!is_struct(sys))
+  elseif(!isstruct(sys))
     error("Sys must be a system data structure");
   endif
 
   ## set defaults where applicable
   if(nargin < 5)
     ptol = 1e-9;        # pole tolerance
   endif
   if(nargin < 4)
@@ -98,18 +98,18 @@ function [g, gmin, gmax] = hinfnorm (sys
     warning(["hinfnorm: setting Gmin=||D||=",num2str(Dnrm)]);
   endif
 
   if(nargin < 2)
     tol = 0.001;        # convergence measure for gmin, gmax
   endif
 
   ## check for scalar input arguments 2...5
-  if( ! (is_scalar(tol) && is_scalar(gmin)
-        && is_scalar(gmax) && is_scalar(ptol)) )
+  if( ! (isscalar(tol) && isscalar(gmin)
+        && isscalar(gmax) && isscalar(ptol)) )
     error("hinfnorm: tol, gmin, gmax, ptol must be scalars");
   endif
 
   In = eye(n+nz);
   Im = eye(m);
   Ip = eye(p);
   ## find the Hinf norm via binary search
   while((gmax/gmin - 1) > tol)
diff --git a/scripts/control/hinf/hinfsyn_ric.m b/scripts/control/hinf/hinfsyn_ric.m
--- a/scripts/control/hinf/hinfsyn_ric.m
+++ b/scripts/control/hinf/hinfsyn_ric.m
@@ -43,18 +43,18 @@
 ## @var{r} is singular
 ## @end table
 ## @end deftypefn
 
 function [Xinf, x_ha_err] = hinfsyn_ric (A, BB, C1, d1dot, R, ptol)
 
   x_ha_err = 0;        # assume success
   Xinf = [];                 # default return value
-  n = is_square(A);
-  nw = is_square(R);
+  n = issquare(A);
+  nw = issquare(R);
   if(rank(R) != nw)    x_ha_err = 6;
   else                 # build hamiltonian Ha for X_inf
     xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
     Ha = [A, 0*A; -C1'*C1, -A'] - xx;
     x_ha_err = 0;
     [d, Ha] = balance(Ha);
     [u, s] = schur(Ha, "A");
     rev = real(eig(s));
diff --git a/scripts/control/hinf/is_dgkf.m b/scripts/control/hinf/is_dgkf.m
--- a/scripts/control/hinf/is_dgkf.m
+++ b/scripts/control/hinf/is_dgkf.m
@@ -119,19 +119,19 @@
 ##
 ## This transformation together with the algorithm in [1] solves
 ## the general problem (see [2] for example).
 
 function [retval, dgkf_struct] = is_dgkf (Asys, nu, ny, tol)
 
   if (nargin < 3) | (nargin > 4)
     usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
-  elseif (! is_scalar(nu) | ! is_scalar(ny) )
+  elseif (! isscalar(nu) | ! isscalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
-  elseif (! is_struct(Asys) )
+  elseif (! isstruct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
   if(nargin < 4)
     tol = 200*eps;
   elseif( !is_sample(tol) )
     error("is_dgkf: tol must be a positive scalar")
   endif
 
diff --git a/scripts/control/obsolete/dlqg.m b/scripts/control/obsolete/dlqg.m
--- a/scripts/control/obsolete/dlqg.m
+++ b/scripts/control/obsolete/dlqg.m
@@ -49,17 +49,17 @@
 function [K, Q, P, Ee, Er] = dlqg (A, B, C, G, Sigw, Sigv, Q, R)
 
   warning("dlqg: obsolete. use lqg instead (system data structure format)");
 
   if (nargin == 5)
     ## system data structure format
 
     ## check that it really is system data structure
-    if(! is_struct(A) )
+    if(! isstruct(A) )
       error("dlqg: 5 arguments, first argument is not a system data structure structure")
     endif
 
     sys = sysupdate(sys,"ss");    # make sure in proper form
     [ncstates,ndstates,nin,nout] = sysdimensions(sys);
     if(ndstates == -1)
       error("this message should never appear: bad system dimensions");
     endif
@@ -101,17 +101,17 @@ function [K, Q, P, Ee, Er] = dlqg (A, B,
       error("dlqg: C, Sigv incompatibly dimensioned");
     elseif(m1 != columns(Sigw))
       error("dlqg: G, Sigw incompatibly dimensioned");
     endif
   else
     error ("dlqg: invalid number of arguments")
   endif
 
-  if (! (is_square(Sigw) && is_square(Sigv) ) )
+  if (! (issquare(Sigw) && issquare(Sigv) ) )
     error("dlqg: Sigw, Sigv must be square");
   endif
 
   ## now we can just do the design; call dlqr and dlqe, since all matrices
   ## are not given in Cholesky factor form (as in h2syn case)
   [Ks, P, Er] = dlqr(A,B,Q,R);
   [Ke, Q, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
   Ac = A - Ke*C - B*Ks;
diff --git a/scripts/control/obsolete/packsys.m b/scripts/control/obsolete/packsys.m
--- a/scripts/control/obsolete/packsys.m
+++ b/scripts/control/obsolete/packsys.m
@@ -37,17 +37,17 @@ function Asys = packsys (a, b, c, d, dfl
   warning("packsys is obsolete!  Use ss2sys instead.");
 
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
   ## check dflg
   if(nargin == 5)
-    if( !is_scalar(dflg))
+    if( !isscalar(dflg))
       [m,n] = size(dflg);
       error(["packsys: dflg (",num2str(m),",",num2str(n), ...
         ") must be a scalar."]);
     elseif( (dflg != 0) && (dflg != 1))
       error(["packsys: dflg=",num2str(dflg),"must be 0 or 1"]);
     endif
   else
     ## default condition
diff --git a/scripts/control/system/abcddim.m b/scripts/control/system/abcddim.m
--- a/scripts/control/system/abcddim.m
+++ b/scripts/control/system/abcddim.m
@@ -73,17 +73,17 @@ function [n, m, p] = abcddim (a, b, c, d
 
   n = m = p = -1;
 
   [a, an, am] = __abcddims__ (a);
   [b, bn, bm] = __abcddims__ (b);
   [c, cn, cm] = __abcddims__ (c);
   [d, dn, dm] = __abcddims__ (d);
 
-  if ( (!is_square(a)) & (!isempty(a)) )
+  if ( (!issquare(a)) & (!isempty(a)) )
     warning (["abcddim: a is not square (",num2str(an),"x",num2str(am),")"]);
     return
   endif
 
   if( (bm == 0) & (dm == 0) )
     warning("abcddim: no inputs");
   elseif (bn != am)
     warning (["abcddim: a(",num2str(an),"x",num2str(am), ...
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -129,34 +129,34 @@
 ## Created: April 1998
 
 function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
   if((nargin < 5) || (nargin > 12))
     usage("sys = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
   endif
   if (nargin >= 5)
-    if (!is_struct(s1))
+    if (!isstruct(s1))
       error("---> s1 must be a structed system.");
     endif
     s1 = sysupdate(s1, "ss");
     [n, nz, m, p] = sysdimensions(s1);
     if (!n && !nz)
       error("---> pure static system must not be the first in list.");
     endif
     if (n && nz)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     D_SYS = (nz > 0);
     [A,B,C,D,tsam] = sys2ss(s1);
     nt = n + nz;
   endif
   for ii = 6:nargin
     eval(["ss = s", num2str(ii-4), ";"]);
-    if (!is_struct(ss))
+    if (!isstruct(ss))
       error("---> Parameter must be a structed system.");
     endif
     ss = sysupdate(ss, "ss");
     [n1, nz1, m1, p1] = sysdimensions(ss);
     if (n1 && nz1)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     if (D_SYS)
@@ -192,29 +192,29 @@ function sys = buildssic (Clst, Ulst, Ol
     error("---> more rows in Clst than total number of inputs.");
   endif
   if (mx > p+1)
     error("---> more cols in Clst than total number of outputs.");
   endif
   ## empty vector Ulst is OK
   lul = length(Ulst);
   if (lul)
-    if (!is_vector(Ulst))
+    if (!isvector(Ulst))
       error("---> Input u list Ulst must be a vector.");
     endif
     if (lul > m)
       error("---> more values in Ulst than number of inputs.");
     endif
   endif
   if (!length(Olst))  Olst = [1:(p+lul)];  endif
   if (!length(Ilst))  Ilst = [1:m];        endif
-  if (!is_vector(Olst))
+  if (!isvector(Olst))
     error("---> Output list Olst must be a vector.");
   endif
-  if (!is_vector(Ilst))
+  if (!isvector(Ilst))
     error("---> Input list Ilst must be a vector.");
   endif
 
   ## build the feedback "K" from the interconnection data Clst
   K = zeros(m, p);
   inp_used = zeros(m,1);
   for ii = 1:nx
     xx = Clst(ii,:);
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -73,17 +73,17 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: October 1993
 ## Updated by John Ingram for system data structure August 1996
 
 function dsys = c2d (sys, opt, T)
   ## parse input arguments
   if(nargin < 1 | nargin > 3)
     usage("dsys=c2d(sys[,T])");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (nargin == 1)
     opt = "ex";
   elseif (nargin == 2 & !isstr(opt) )
     T = opt;
     opt = "ex";
   endif
 
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -59,17 +59,17 @@
 ## Updated by John Ingram for system data structure  August 1996
 
 function csys = d2c (sys, opt)
 
   ## SYS_INTERNAL accesses members of system data structure
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be in system data structure");
   elseif(nargin == 1)
     opt = "log";
     tol = 1e-12;
   elseif(isstr(opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
       error(["d2c: invalid opt passed=",opt]);
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -73,28 +73,28 @@
 ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
 function [dsys, fidx] = dmr2d (sys, idx, sprefix, Ts2, cuflg)
 
   ## parse input arguments
   if(nargin != 4 | nargout > 2)
     usage("[dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})");
 
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be in system data structure form");
 
   elseif(!is_digital(sys))
     error("sys must be discrete-time; continuous time passed");
   
   endif
 
   if(is_signal_list(idx) | isstr(idx))
     idx = sysidx(sys,"st",idx);
 
-  elseif (!(is_vector(idx) | isempty(idx)))
+  elseif (!(isvector(idx) | isempty(idx)))
     error(["idx(",num2str(rows(idx)),"x",num2str(columns(idx)), ...
       ") must be a vector"]);
 
   elseif (any(idx <= 0))
     idv = find(idx <= 0);
     ii = idv(1);
     error(["idx(",num2str(ii),")=",num2str(idx(ii)), ...
       "; entries of idx must be positive"]);
@@ -105,17 +105,17 @@ function [dsys, fidx] = dmr2d (sys, idx,
   elseif(!is_sample(Ts2))
     error(["Ts2=",num2str(Ts2),"; invalid sampling time"]);
 
   endif
 
   ## optional argument: cuflg
   if(nargin <= 4)
     cuflg = 1;          # default: constant inputs over Ts2 sampling interv.
-  elseif( !is_scalar(cuflg) )
+  elseif( !isscalar(cuflg) )
     error("cuflg must be a scalar")
   elseif( cuflg != 0 | cuflg != 1)
     error(["cuflg = ",num2str(cuflg),", should be 0 or 1"]);
   endif
 
   ## extract  state space information
   [da,db,dc,dd,Ts1,nc,nz,stname,inname,outname,yd] = sys2ss(sys);
 
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -48,31 +48,31 @@
 ## Krylov subspace
 ## @example
 ## span ([b,a*b,...,a^@{n-1@}*b]).
 ## @end example
 ## The Arnoldi iteration is executed with @code{krylov} if the system
 ## has a single input; otherwise a block Arnoldi iteration is performed
 ## with @code{krylovb}.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
 ## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
     usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b, tol})", ...
         "is_controllable(sys{,tol})");
-  elseif(is_struct(a))
+  elseif(isstruct(a))
     ## system structure passed.
     sys = sysupdate(a,"ss");
     [a,bs] = sys2ss(sys);
     if(nargin > 2)
       usage("[retval,U] = is_controllable(sys{,tol})");
     elseif(nargin == 2)
       tol = b;          % get tolerance
       deftol = 0;
@@ -86,25 +86,25 @@ function [retval, U] = is_controllable (
       deftol = 1;
     endif
   endif
 
   ## check for default tolerance
   if(deftol) tol = 1000*eps; endif
 
   ## check tol dimensions
-  if( !is_scalar(tol) )
+  if( !isscalar(tol) )
     error("is_controllable: tol(%dx%d) must be a scalar", ...
         rows(tol),columns(tol));
   elseif( !is_sample(tol) )
     error("is_controllable: tol=%e must be positive",tol);
   endif
 
   ## check dimensions compatibility
-  n = is_square (a);
+  n = issquare (a);
   [nr, nc] = size (b);
 
   if (n == 0 | n != nr | nc == 0)
     warning("is_controllable: a=(%dx%d), b(%dx%d)",rows(a),columns(a),nr,nc);
     retval = 0;
   else
     ## call block-krylov subspace routine to get an orthogonal basis
     ## of the controllable subspace.
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -26,28 +26,28 @@
 ## detectable, 0 if not.
 ##
 ## @strong{See} @code{is_stabilizable} for detailed description of
 ## arguments and computational method.
 ##
 ## Default: tol = 10*norm(a,'fro')*eps
 ##
 ## @end deftypefn
-## @seealso{is_stabilizable, size, rows, columns, length, is_matrix,
-## is_scalar, and is_vector}
+## @seealso{is_stabilizable, size, rows, columns, length, ismatrix,
+## isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol)
 
   if( nargin < 1)
     usage("[retval,U] = is_detectable(a , c {, tol})");
-  elseif(is_struct(a))
+  elseif(isstruct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_detectable(sys {, tol})");
     endif
     [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
diff --git a/scripts/control/system/is_observable.m b/scripts/control/system/is_observable.m
--- a/scripts/control/system/is_observable.m
+++ b/scripts/control/system/is_observable.m
@@ -24,27 +24,27 @@
 ## Default: tol = 10*norm(a,'fro')*eps
 ##
 ## Returns 1 if the system @var{sys} or the pair (@var{a},@var{c}) is
 ## observable, 0 if not.
 ##
 ## @strong{See} @code{is_controllable} for detailed description of arguments
 ## and default values.
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_matrix, is_scalar, and is_vector}
+## @seealso{size, rows, columns, length, ismatrix, isscalar, and isvector}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
   if( nargin < 1)
     usage("[retval,U] = is_observable(a , c {, tol})");
-  elseif(is_struct(a))
+  elseif(isstruct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
       usage("[retval,U] = is_observable(sys {, tol})");
     endif
     [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
diff --git a/scripts/control/system/is_sample.m b/scripts/control/system/is_sample.m
--- a/scripts/control/system/is_sample.m
+++ b/scripts/control/system/is_sample.m
@@ -22,11 +22,11 @@
 ## (real,scalar, > 0)
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 
 function out = is_sample (Ts)
 
-  out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
+  out = (isscalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/system/is_signal_list.m b/scripts/control/system/is_signal_list.m
--- a/scripts/control/system/is_signal_list.m
+++ b/scripts/control/system/is_signal_list.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_signal_list (@var{mylist})
 ## Return true if @var{mylist} is a list of individual strings.
 ## @end deftypefn
 
 function flg = is_signal_list(mylist)
 
-  flg = is_list(mylist);
+  flg = islist(mylist);
 
   if (flg)
     for ii = 1:length (mylist)
       if (! (isstr (nth (mylist,ii)) & rows (nth (mylist,ii)) == 1))
 	flg = 0;
       endif
     endfor
   endif
diff --git a/scripts/control/system/is_siso.m b/scripts/control/system/is_siso.m
--- a/scripts/control/system/is_siso.m
+++ b/scripts/control/system/is_siso.m
@@ -24,17 +24,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996, 1998
 
 function  SISO = is_siso (sys)
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
-  elseif( !is_struct(sys))
+  elseif( !isstruct(sys))
     error("input must be a system structure (see ss2sys, tf2sys, zp2sys)");
   endif
 
   [n,nz,m,p] = sysdimensions(sys);
 
   SISO = (m == 1 & p == 1);
 
 endfunction
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -32,28 +32,28 @@
 ## complete re-orthogonalization to obtain an orthogonal basis of the
 ## Krylov subspace.
 ## @example
 ##   span ([b,a*b,...,a^   b]).
 ## @end example
 ## tol is a roundoff paramter, set to 200*eps if omitted.
 ## @end deftypefn
 
-## See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
+## See also: size, rows, columns, length, ismatrix, isscalar, isvector
 ##     is_observable, is_stabilizable, is_detectable
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function [retval, U] = is_stabilizable (a, b, tol)
 
   if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
-  elseif(is_struct(a))
+  elseif(isstruct(a))
     ## sustem passed.
     if(nargin == 2)
       tol = b;          % get tolerance
     elseif(nargin > 2)
       usage("[retval,U] = is_stabilizable(sys{,tol})");
     endif
     [a,b] = sys2ss(a);
   else
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -32,44 +32,44 @@
 ## @item @var{dflg} != 0
 ## stable if eig(a) in unit circle
 ##
 ## @item @var{dflg} == 0
 ## stable if eig(a) in open LHP (default)
 ## @end table
 ## @end table
 ## @end deftypefn
-## @seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
+## @seealso{size, rows, columns, length, ismatrix, isscalar, isvector
 ## is_observable, is_stabilizable, is_detectable, krylov, and krylovb}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
   if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
-  elseif(is_struct(a))
+  elseif(isstruct(a))
     ## system was passed
     if(nargin < 3)                      disc = is_digital(a);
     elseif(disc != is_digital(a))
       warning("is_stable: disc =%d does not match system",disc)
     endif
     sys = sysupdate(a,"ss");
     a = sys2ss(sys);
   else
     if(nargin < 3)              disc = 0;               endif
-    if(is_square(a) == 0)
+    if(issquare(a) == 0)
       error("A(%dx%d) must be square",rows(A), columns(A));
     endif
   endif
 
   if(nargin < 2)                tol = 200*eps;
-  elseif( !is_scalar(tol) )
+  elseif( !isscalar(tol) )
     error("is_stable: tol(%dx%d) must be a scalar",rows(tol),columns(tol));
   endif
 
   l = eig(a);
   if(disc)      nbad = sum(abs(l)*(1+tol) > 1);
   else          nbad = sum(real(l)+tol > 0);            endif
   retval = (nbad == 0);
 
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -36,19 +36,19 @@
 ## completely rewritten Oct 1996 a s hodel
 ## SYS_INTERNAL accesses members of system structure
 
 function sysp = parallel (Asys, Bsys)
 
   if(nargin != 2)
     usage("sysp = parallel(Asys,Bsys)");
   endif
-  if(! is_struct(Asys) )
+  if(! isstruct(Asys) )
     error("1st input argument is not a system data structure")
-  elseif (! is_struct(Bsys) )
+  elseif (! isstruct(Bsys) )
     error("2nd input argument is not a system data structure")
   endif
   [Ann,Anz,mA] = sysdimensions(Asys);
   [Bnn,Bnz,mB] = sysdimensions(Bsys);
   if(mA != mB)
     error(["Asys has ",num2str(mA)," inputs, Bsys has ",num2str(mB)," inputs"]);
   endif
 
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -209,31 +209,31 @@ function retsys = ss2sys (a, b, c, d, ts
   if(nargin < 5) tsam = 0;
   elseif( !( is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be a nonnegative real scalar");
   endif
 
   ## check for continuous states
   if( (nargin < 6) & (tsam == 0) )               n = na;
   elseif(nargin < 6)                             n = 0;
-  elseif((!is_matrix(n)) | isstr(n))
+  elseif((!ismatrix(n)) | isstr(n))
     error("Parameter n is not a numerical value.");
-  elseif( (!is_scalar(n)) | (n < 0 ) | (n != round(n)) )
-    if(is_scalar(n))     error("invalid value of n=%d,%e",n,n);
+  elseif( (!isscalar(n)) | (n < 0 ) | (n != round(n)) )
+    if(isscalar(n))     error("invalid value of n=%d,%e",n,n);
     else                 error("invalid value of n=(%dx%d)", ...
                            rows(n), columns(n));                endif
   endif
 
   ## check for num discrete states
   if( (nargin < 7) & (tsam == 0))               nz = 0;
   elseif(nargin < 7)                            nz = na - n;
-  elseif((!is_matrix(nz)) | isstr(nz))
+  elseif((!ismatrix(nz)) | isstr(nz))
     error("Parameter nz is not a numerical value.");
-  elseif( (!is_scalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
-    if(is_scalar(nz))
+  elseif( (!isscalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
+    if(isscalar(nz))
       error(["invalid value of nz=",num2str(nz)]);
     else
       error(["invalid value of nz=(",num2str(rows(nz)),"x", ...
         num2str(columns(nz)),")"]);
     endif
   endif
 
   ## check for total number of states
diff --git a/scripts/control/system/starp.m b/scripts/control/system/starp.m
--- a/scripts/control/system/starp.m
+++ b/scripts/control/system/starp.m
@@ -50,20 +50,20 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: May 1998
 
 function sys = starp (P, K, ny, nu);
 
   if((nargin != 2) && (nargin != 4))
     usage("sys = starp(P, K, ny, nu)");
   endif
-  if (!is_struct(P))
+  if (!isstruct(P))
     error("---> P must be in system data structure");
   endif
-  if (!is_struct(K))
+  if (!isstruct(K))
     error("---> K must be in system data structure");
   endif
 
   P = sysupdate(P, "ss");
   [n, nz, mp, pp] = sysdimensions(P);
   np = n + nz;
   K = sysupdate(K, "ss");
   [n, nz, mk, pk] = sysdimensions(K);
diff --git a/scripts/control/system/sys2ss.m b/scripts/control/system/sys2ss.m
--- a/scripts/control/system/sys2ss.m
+++ b/scripts/control/system/sys2ss.m
@@ -78,17 +78,17 @@ function [a, b, c, d, tsam, n, nz, stnam
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
   if (nargout > 11)
     warning(["sys2ss: ",num2str(nargout)," out arguments exceeds max=11"])
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
-  if( ! is_struct(sys) )
+  if( ! isstruct(sys) )
     error("input argument must be a system data structure");
   endif
 
   sys = sysupdate(sys,"ss");        # make sure state space data is there
   [n,nz,m,p] = sysdimensions(sys);
   [stname,inname,outname,yd] = sysgetsignals(sys);
   tsam = sysgettsam(sys);
 
diff --git a/scripts/control/system/sys2tf.m b/scripts/control/system/sys2tf.m
--- a/scripts/control/system/sys2tf.m
+++ b/scripts/control/system/sys2tf.m
@@ -37,17 +37,17 @@
 ## modified again for updated system format by John Ingram July 1996
 
 function [num, den, tsam, inname, outname] = sys2tf (Asys)
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
-  if( !is_struct(Asys))
+  if( !isstruct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
   elseif (! is_siso(Asys) )
     [n, nz, m, p] = sysdimensions(Asys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
   endif
 
   Asys = sysupdate(Asys,"tf");          # just in case
diff --git a/scripts/control/system/sys2zp.m b/scripts/control/system/sys2zp.m
--- a/scripts/control/system/sys2zp.m
+++ b/scripts/control/system/sys2zp.m
@@ -37,17 +37,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 15, 1996
 
 function [zer, pol, k, tsam, inname, outname] = sys2zp (sys)
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
-  elseif( !is_struct(sys))
+  elseif( !isstruct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
   endif
 
   ## update zero-pole form
diff --git a/scripts/control/system/sysadd.m b/scripts/control/system/sysadd.m
--- a/scripts/control/system/sysadd.m
+++ b/scripts/control/system/sysadd.m
@@ -48,17 +48,17 @@ function sys = sysadd (varargin)
   if(nargin < 1)
     usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
   endif
 
   ## collect all arguments
   arglist = list();
   for kk=1:nargin
     arglist(kk) = varargin{kk};
-    if(!is_struct(nth(arglist,kk)))
+    if(!isstruct(nth(arglist,kk)))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -77,19 +77,19 @@
 
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   sav_empty_list_elements_ok = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;
 
   ## check input arguments
-  if ( (nargin < 2) | (nargin > 7) | (!is_struct(sys)))
+  if ( (nargin < 2) | (nargin > 7) | (!isstruct(sys)))
     usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
-  elseif(!is_struct(sys))
+  elseif(!isstruct(sys))
     error("sys must be a system data structure");
   endif
 
   ## default system type must be state space form
   [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
   [Ann,Anz,Am,Ap] = sysdimensions(sys);
 
   ## default c
@@ -144,17 +144,17 @@ function retsys = sysappend (sys, b, c, 
     else
       outname = __sysdefioname__(Bp,"y",(Ap+1));
     endif
     if(Ap)   Aout = append(Aout,outname);
     else     Aout = outname;                endif
 
     ## construct new yd entries
     if(nargin == 7)
-      if(!is_vector(yd))
+      if(!isvector(yd))
         error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
       elseif(rows(c) != length(yd) & rows(d) != length(yd))
         error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
           length(yd), rows(c), columns(c),rows(d),columns(d)));
       endif
     else
       ## default yd values
       yd = ones(1,Bp)*( (Ats > 0) & (Ann == 0)  & isempty(find(Ayd == 0)) ) ;
diff --git a/scripts/control/system/syschtsam.m b/scripts/control/system/syschtsam.m
--- a/scripts/control/system/syschtsam.m
+++ b/scripts/control/system/syschtsam.m
@@ -24,19 +24,19 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syschtsam (sys, tsam)
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be in system data structure form");
-  elseif(!is_scalar(tsam))
+  elseif(!isscalar(tsam))
     disp("syschtsam:")
     tsam
     error("tsam must be a scalar")
   elseif ( ! (is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be real, scalar, and greater than zero");
   elseif (sysgettsam(sys) == 0)
     [nc,nz,mm,pp] = sysdimensions(sys);
     warning("syschtsam: continuous system (nc=%d, nz=%d, mm=%d, pp=%d)", ...
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -111,17 +111,17 @@ function sys = sysconnect (sys, output_l
     if(is_duplicate_entry(output_list) | is_duplicate_entry(input_list) )
       error("duplicate entry in input_list and/or output_list");
     endif
   endif
 
   [nc,nz,mm,pp] = sysdimensions(sys);
   nn = nc+nz;
 
-  if( !is_struct(sys))
+  if( !isstruct(sys))
     error("sys must be in structured system form")
   elseif(pp < li)
     error(["length(output_list)=",num2str(li),", sys has only ", ...
         num2str(pp),"system outputs"])
   elseif(mm < li)
     error(["length(input_list)=",num2str(li),", sys has only ", ...
         num2str(mm),"system inputs"])
   endif
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -41,17 +41,17 @@
 
 function [csys, Acd, Ccd] = syscont (sys)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -64,17 +64,17 @@
 ## @end table
 ## @end deftypefn
 ## @seealso{sysgetsignals and sysgettsam}
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
     usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
-  elseif(!is_struct(sys))
+  elseif(!isstruct(sys))
     usage("[n,nz,m,p] = sysdimensions(sys)");
   elseif(nargin == 1)
     opt = "all";
   endif
 
   n = sys.n;
   nz = sys.nz;
   m = length(sysgetsignals(sys,"in"));
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -36,17 +36,17 @@
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -56,34 +56,34 @@
 ## modified by John Ingram July 1996
 
 function retsys = sysdup (Asys, output_list, input_list)
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
-  if( !is_struct(Asys))
+  if( !isstruct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   endif
 
   Asys = sysupdate(Asys,"ss");
   [nn,nz,mm,pp] = sysdimensions(Asys);
   [aa,bb,cc,dd] = sys2ss(Asys);
 
   ## check for signal names
   if(is_signal_list(input_list) | isstr(input_list))
     input_list = sysidx(Asys,"in",input_list);
   endif
   if(is_signal_list(output_list) | isstr(output_list))
     output_list = sysidx(Asys,"out",output_list);
   endif
 
   ## first duplicate inputs
-  if(is_vector(input_list))
+  if(isvector(input_list))
     for ii=1:length(input_list);
       bb(:,mm+ii) = bb(:,input_list(ii));
       dd(:,mm+ii) = dd(:,input_list(ii));
     end
   elseif(!isempty(input_list))
     error("input_list must be a vector or empty");
   endif
 
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -140,17 +140,17 @@
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss2sys
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
     usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
   elseif(nargin > 1 & nargout > 1)
     usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
-  elseif( ! is_struct(sys) )
+  elseif( ! isstruct(sys) )
     error("input argument must be a system data structure");
   endif
   if(nargin < 4)  strflg = 0; endif
   if(nargin == 1)
     sys = sysupdate(sys,"ss");          #make sure ss is up to date
     stname = sysgetsignals(sys,"st");
     inname = sysgetsignals(sys,"in");
     outname = sysgetsignals(sys,"out");
@@ -169,17 +169,17 @@ function [stname, inname, outname, yd] =
     if(nargin >= 3)
       if( is_signal_list(signum) | isstr(signum) )
         signum = listidx(stname,signum);
       end
       if(max(signum) > length(stname))
         error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
           sigid,signum, rows(stname)));
       else
-        if(!is_scalar(strflg))
+        if(!isscalar(strflg))
           error("strflg must be a scalar");
         endif
         switch(strflg)
         case(0),
           stname = stname(signum);
         case(1),
           if(length(signum) > 1)
             error("strflg=1, length(signum) = %d",length(signum));
diff --git a/scripts/control/system/sysgettsam.m b/scripts/control/system/sysgettsam.m
--- a/scripts/control/system/sysgettsam.m
+++ b/scripts/control/system/sysgettsam.m
@@ -18,15 +18,15 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sysgettsam (@var{sys})
 ## Return the sampling time of the system @var{sys}.
 ## @end deftypefn
 
 function T = sysgettsam (sys)
 
-  if(!is_struct(sys))
+  if(!isstruct(sys))
     usage("T = sysgettsam(sys)");
   endif
 
   T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/system/sysgettype.m b/scripts/control/system/sysgettype.m
--- a/scripts/control/system/sysgettype.m
+++ b/scripts/control/system/sysgettype.m
@@ -28,15 +28,15 @@
 ## constructed:
 ## values: @code{"ss"}, @code{"zp"}, or @code{"tf"}
 ##
 ## @strong{Note} FIR initialized systems return @code{systype="tf"}.
 ## @end deftypefn
 
 function systype = sysgettype (sys)
 
-  if(!is_struct(sys))
+  if(!isstruct(sys))
     error("sysgettype: input sys is not a structure");
   endif
 
   typestr = list("tf","zp","ss");
   systype = nth(typestr,sys.sys(1) + 1);
 endfunction
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -58,17 +58,17 @@ function sys = sysgroup (varargin)
   if(nargin < 1)
     usage("sys = sysgroup(Asys{,Bsys,...})");
   endif
 
   ## collect all arguments
   arglist = list();
   for kk=1:nargin
     arglist(kk) = varargin{kk};
-    if(!is_struct(nth(arglist,kk)))
+    if(!isstruct(nth(arglist,kk)))
       error("sysgroup: argument %d is not a data structure",kk);
     endif
   endfor
 
   if(nargin == 2)
     ## the usual case; group the two systems together
     Asys = nth(arglist,1);
     Bsys = nth(arglist,2);
diff --git a/scripts/control/system/sysidx.m b/scripts/control/system/sysidx.m
--- a/scripts/control/system/sysidx.m
+++ b/scripts/control/system/sysidx.m
@@ -23,17 +23,17 @@
 ## selected @var{sigtype} (@code{"in"}, @code{"out"}, @code{"st"}), and
 ## a list of desired signal names @var{signamelist}.
 ## @end deftypefn
 
 function idxvec = sysidx (sys, sigtype, signamelist)
 
   if (nargin != 3)
     usage ("idxvec = sysidx (sys, sigtype, signamelist)");
-  elseif (! is_struct (sys))
+  elseif (! isstruct (sys))
     error ("sys must be a system data structure");
   elseif (! isstr (sigtype))
     error ("sigtype must be a string");
   elseif (rows (sigtype) != 1)
     [nr, nc] = size (sigtype);
     error ("sigtype (%d x %d) must be a single string", nr, nc);
   endif
 
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -41,17 +41,17 @@ function sys = sysmult (varargin)
   if(nargin < 1)
     usage("sysmult: sys = sysmult(Asys{,Bsys,...})");
   endif
 
   ## collect all arguments
   arglist = list();
   for kk=1:nargin
     arglist(kk) = varargin{kk};
-    if(!is_struct(nth(arglist,kk)))
+    if(!isstruct(nth(arglist,kk)))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
diff --git a/scripts/control/system/sysout.m b/scripts/control/system/sysout.m
--- a/scripts/control/system/sysout.m
+++ b/scripts/control/system/sysout.m
@@ -49,17 +49,17 @@ function retsys = sysout (sys, opt)
   endif
 
   if(isempty(sys))
     retsys = sys;
     warning("sysout: empty system")
     return;
   endif
 
-  if(! is_struct(sys))
+  if(! isstruct(sys))
     disp("sysout: input must be a system structure")
   endif
 
   ## set up output type array
   if( nargin == 1 )
     opt = sysgettype(sys);
   else
     if( ! (strcmp(opt,"ss") + strcmp(opt,"tf") + ...
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -73,56 +73,56 @@ function sys = sysprune (sys, output_idx
   if(is_signal_list(output_idx) | isstr(output_idx))
     output_idx = sysidx(sys,"out",output_idx);
   endif
   if(is_signal_list(input_idx) | isstr(input_idx))
     input_idx = sysidx(sys,"in",input_idx);
   endif
 
   ## check dimensions
-  if( !(is_vector(output_idx) | isempty(output_idx) )  )
-    if(!is_matrix(output_idx))
+  if( !(isvector(output_idx) | isempty(output_idx) )  )
+    if(!ismatrix(output_idx))
       error("sysprune: bad argument passed for output_idx");
     else
       error("sysprune: output_idx (%d x %d) must be a vector or empty", ...
         rows(output_idx),columns(output_idx));
     endif
   elseif(is_duplicate_entry(output_idx))
      error("sysprune: duplicate entries found in output_idx");
   endif
 
-  if( !(is_vector(input_idx) | isempty(input_idx) )  )
-    if(!is_matrix(input_idx))
+  if( !(isvector(input_idx) | isempty(input_idx) )  )
+    if(!ismatrix(input_idx))
       error("sysprune: bad argument passed for input_idx");
     else
       error("sysprune: input_idx (%d x %d) must be a vector or empty", ...
         rows(input_idx),columns(input_idx));
     endif
   elseif(is_duplicate_entry(input_idx))
      error("sysprune: duplicate entries found in input_idx");
   endif
 
-  if( !(is_vector(state_idx) | isempty(state_idx) )  )
-    if(!is_matrix(state_idx))
+  if( !(isvector(state_idx) | isempty(state_idx) )  )
+    if(!ismatrix(state_idx))
       error("sysprune: bad argument passed for state_idx");
     else
       error("sysprune: state_idx (%d x %d) must be a vector or empty", ...
         rows(state_idx),columns(state_idx));
     endif
   elseif(nn+nz > 0)
     if(is_duplicate_entry(state_idx))
       error("sysprune: duplicate entries found in state_idx");
     endif
   endif
 
   lo = length(output_idx);
   li = length(input_idx);
   lst = length(state_idx);
 
-  if( !is_struct(sys))
+  if( !isstruct(sys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
   elseif(pp < lo)
     error([num2str(lo)," output_idx entries, system has only ", ...
         num2str(pp)," outputs"]);
   elseif(mm < li)
     error([num2str(li)," input_idx entries, system has only ", ...
         num2str(mm)," inputs"]);
   elseif(nn+nz < lst)
diff --git a/scripts/control/system/sysreorder.m b/scripts/control/system/sysreorder.m
--- a/scripts/control/system/sysreorder.m
+++ b/scripts/control/system/sysreorder.m
@@ -38,17 +38,17 @@ function pv = sysreorder (vlen, list)
   ## disp('sysreorder: entry')
 
   pv = 1:vlen;
   ## make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
   X = (A != B);
-  if(!is_vector(X))
+  if(!isvector(X))
     y = min(X');
   else
    y = X';
   endif
   z = find(y == 1);
   if(!isempty(z))
     pv = [z, list];
   else
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -44,17 +44,17 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram 7-15-96
 
 function sys = sysscale (sys, outscale, inscale, outname, inname)
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be a structured system");
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
 
   ## check for omitted scales
   if(isempty(outscale))    outscale = eye(pp);     endif
   if(isempty(inscale))     inscale = eye(mm);      endif
@@ -105,28 +105,28 @@ function sys = sysscale (sys, outscale, 
 
   [sysa,sysb,sysc,sysd,systsam, ...
     sysn,sysnz,sysstname,sysinname,sysoutname,oldyd] = sys2ss(sys);
 
   sysb = sysb*inscale;
   sysc = outscale*sysc;
   sysd = outscale*sysd*inscale;
 
-  if( !is_square(outscale) )
+  if( !issquare(outscale) )
     ## strip extra output names (if any)
     sysoutname = sysoutname(1:min(rows(outscale),columns(outscale)));
     if( nargin < 4)
       warning("sysscale: outscale not square, outname not specified");
       warning("sysscale:  using default output names");
       outname = __sysdefioname__(rows(sysc),"y");
     endif
   else
     outname = sysoutname;
   endif
-  if( !is_square(inscale) )
+  if( !issquare(inscale) )
     ## strip extra output names (if any)
     sysinname = sysinname(1:min(rows(inscale),columns(inscale)));
     if(nargin < 5)
       warning("sysscale: inscale not square, inname not specified");
       warning("sysscale:  using default input names");
       inname = __sysdefioname__(columns(sysb),"u");
     endif
   else
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -86,17 +86,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syssetsignals (sys, opt, names, sig_idx)
 
   if (nargin < 3 | nargin > 4)
     usage("retsys=syssetsignals(sys,opt,names{,sig_idx})");
-  elseif (!is_struct(sys))
+  elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (isempty(opt))
     opt = "out";
   elseif( ! isstr(opt)  )
     error("opt must be a string");
   elseif( ! (strcmp(opt,"out") + strcmp(opt,"yd") + ...
     strcmp(opt,"in") + strcmp(opt,"st") ) )
     error("opt must be one of [], ""out"", ""yd"", ""in"", or ""st""");
@@ -120,17 +120,17 @@ function retsys = syssetsignals (sys, op
 
   sig_vals = sysgetsignals(sys,opt);
 
   ## make sure it's in state space form if state names are given
   if(strcmp(opt,"st"))    sys = sysupdate(sys,"ss");    endif
 
   if(strcmp(opt,"yd") == 0)
     ## it's a signal name list we're changing
-    if(!is_list(names))
+    if(!islist(names))
       names = list(names);
     endif
     if(!is_signal_list(names))
       if(isstr(nth(names,1)))
         warning("syssetsignals(opt=%s): converting string matrix \"names\" to a list of strings",opt);
         tmpstr = nth(names,1);
         for ii=1:rows(tmpstr)
           names(ii) = deblank(tmpstr(ii,:));
@@ -174,17 +174,17 @@ function retsys = syssetsignals (sys, op
           yd,nout);
       endif
       if(!isempty(names))
         error("opt=%s, %d outputs, names is not empty");
       endif
       sigvals = [];
     else
       nsigs = length(sig_vals);
-      if(!is_vector(names))
+      if(!isvector(names))
         error("syssetsignals: opt=yd, names(%dx%d) must be a vector", ...
           rows(names), columns(names));
       endif
       if(nargin == 3)
         if(length(names) != nsigs)
           error("opt=yd, sig_idx omitted: names(%d) should be length(%d)", ...
             length(names), nsigs);
         endif
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -47,17 +47,17 @@ function sys = syssub (varargin)
   if(nargin < 1)
     usage("syssub: sys = syssub(Gsys{,Hsys,...})");
   endif
 
   ## collect all arguments
   arglist = list();
   for kk=1:nargin
     arglist(kk) = varargin{kk};
-    if(!is_struct(nth(arglist,kk)))
+    if(!isstruct(nth(arglist,kk)))
       error("syssub: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
   [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
   for kk=2:nargin
     [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -50,17 +50,17 @@
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
-  elseif(! is_struct(sys) )
+  elseif(! isstruct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
         strcmp(opt,"ss") + strcmp(opt,"all")) )
     error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
   ## check to make sure not trying to make a SISO system out of a MIMO sys
   if ( (strcmp(opt,"tf") + strcmp(opt,"zp") + strcmp(opt,"all")) ...
diff --git a/scripts/control/system/tf2ss.m b/scripts/control/system/tf2ss.m
--- a/scripts/control/system/tf2ss.m
+++ b/scripts/control/system/tf2ss.m
@@ -46,19 +46,19 @@
 ## Created: June 22, 1994
 ## mod A S Hodel July, Aug  1995
 
 function [a, b, c, d] = tf2ss (num, den)
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
-  elseif(!is_vector(num))
+  elseif(!isvector(num))
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
-  elseif(!is_vector(den))
+  elseif(!isvector(den))
     error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
   endif
 
   ## strip leading zeros from num, den
   nz = find(num != 0);
   if(isempty(nz)) num = 0;
   else num = num(nz(1):length(num));         endif
   nz = find(den != 0);
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -61,35 +61,35 @@ function outsys = tf2sys (num, den, tsam
 
   ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage ("outsys = tf2sys (num, den [, tsam, inname, outname])");
     return
   endif
 
   ## check input format
-  if( ! ( (is_vector(num) || is_scalar(num)) && ...
-        (is_vector(den) || is_scalar(den))) )
+  if( ! ( (isvector(num) || isscalar(num)) && ...
+        (isvector(den) || isscalar(den))) )
     error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
       ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
       ") must be vectors"])
   endif
 
   ## strip leading zero coefficients
   num = __tf2sysl__ (num);
   den = __tf2sysl__ (den);
 
   if (length(num) >  length(den))
     error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
   ## check sampling interval (if any)
   if(nargin <= 2)           tsam = 0;           # default
   elseif (isempty(tsam))    tsam = 0;           endif
-  if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
+  if ( (! (isscalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
     error("tsam must be a positive real scalar")
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   ## Set the system vector:  active = 0(tf), updated = [1 0 0];
   outsys.sys = [0, 1, 0, 0];
@@ -108,32 +108,32 @@ function outsys = tf2sys (num, den, tsam
   outsys.inname  = __sysdefioname__ (1, "u");
   outsys.outname = __sysdefioname__ (1, "y");
   outsys.stname  = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 3)
     ## make sure its a list of a single string
     if(!isempty(inname))
-      if(!is_list(inname))  inname = list(inname);  endif
+      if(!islist(inname))  inname = list(inname);  endif
       if( !is_signal_list(inname) )
         error("inname must be a string or list of strings");
       endif
       if(length(inname) > 1)
         warning("tf2sys: %d input names provided; first used",length(inname));
         inname = inname(1);
       endif
       outsys = syssetsignals(outsys,"in",inname);
     endif
   endif
 
   ## Set name of output
   if (nargin > 4)
     if(!isempty(outname))
-      if(!is_list(outname))  outname = list(outname);  endif
+      if(!islist(outname))  outname = list(outname);  endif
       if(!is_signal_list(outname))
         error("outname must be a string or a list of strings");
       endif
       if(length(outname) > 1)
         warning("tf2sys: %d output names provided; first used",length(outname));
         outname = outname(1);
       endif
       outsys = syssetsignals(outsys,"out",outname);
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -31,17 +31,17 @@ function tfout (num, denom, x)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
     usage("tfout(num,denom[,x])");
   endif
 
-  if ( (!is_vector(num)) | (!is_vector(denom)) )
+  if ( (!isvector(num)) | (!isvector(denom)) )
     error("tfout: first two argument must be vectors");
   endif
 
   if (nargin == 2)
     x = "s";
   elseif( ! isstr(x) )
     error("tfout: third argument must be a string");
   endif
diff --git a/scripts/control/system/zp2ss.m b/scripts/control/system/zp2ss.m
--- a/scripts/control/system/zp2ss.m
+++ b/scripts/control/system/zp2ss.m
@@ -53,23 +53,23 @@ function [a, b, c, d] = zp2ss (zer, pol,
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
   endif
 
-  if(! (is_vector(zer) | isempty(zer)) )
+  if(! (isvector(zer) | isempty(zer)) )
     error(["zer(",num2str(rows(zer)),",",num2str(columns(zer)), ...
         ") should be a vector"]);
-  elseif(! (is_vector(pol) | isempty(pol) ) )
+  elseif(! (isvector(pol) | isempty(pol) ) )
     error(["pol(",num2str(rows(pol)),",",num2str(columns(pol)), ...
         ") should be a vector"]);
-  elseif(! is_scalar(k))
+  elseif(! isscalar(k))
     error(["k(",num2str(rows(k)),",",num2str(columns(k)), ...
         ") should be a scalar"]);
   elseif( k != real(k))
     warning("zp2ss: k is complex")
   endif
 
   zpsys = ss2sys([],[],[],k);
 
diff --git a/scripts/control/system/zp2sys.m b/scripts/control/system/zp2sys.m
--- a/scripts/control/system/zp2sys.m
+++ b/scripts/control/system/zp2sys.m
@@ -58,31 +58,31 @@
 function outsys = zp2sys (zer, pol, k, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
 
   ## check input format
-  if( ! (is_vector(zer) | isempty(zer) ) )
+  if( ! (isvector(zer) | isempty(zer) ) )
     error("zer must be a vector or empty");
   endif
   if(!isempty(zer))
     zer = reshape(zer,1,length(zer));           # make it a row vector
   endif
 
-  if( ! (is_vector(pol) | isempty(pol)))
+  if( ! (isvector(pol) | isempty(pol)))
     error("pol must be a vector");
   endif
   if(!isempty(pol))
     pol = reshape(pol,1,length(pol));
   endif
 
-  if (! is_scalar(k))
+  if (! isscalar(k))
      error("k must be a scalar");
   endif
 
   ## Test proper numbers of poles and zeros.  The number of poles must be
   ## greater than or equal to the number of zeros.
   if (length(zer) >  length(pol))
     error(["number of poles (", num2str(length(pol)), ...
         ") < number of zeros (", num2str(length(zer)),")"]);
@@ -99,17 +99,17 @@ function outsys = zp2sys (zer, pol, k, t
   ## Set defaults
   outsys.tsam = 0;
   outsys.n = length(pol);
   outsys.nz = 0;
   outsys.yd = 0;        # assume (for now) continuous time outputs
 
   ## Set the type of system
   if (nargin > 3)
-    if( !is_scalar(tsam) )
+    if( !isscalar(tsam) )
       error("tsam must be a nonnegative scalar");
     endif
     if (tsam < 0)
       error("sampling time must be positve")
     elseif (tsam > 0)
       [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
       outsys.yd = 1;            # discrete-time output
     endif
@@ -120,28 +120,28 @@ function outsys = zp2sys (zer, pol, k, t
   outsys.inname = __sysdefioname__ (1, "u");
   outsys.outname = __sysdefioname__ (1, "y");
   outsys.stname = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 4)
     ## make sure its a string
     if(!isempty(inname))
-      if(!is_list(inname))  inname = list(inname); endif
+      if(!islist(inname))  inname = list(inname); endif
       if(!is_signal_list(inname))
         error("inname must be a single signal name");
       endif
       outsys.inname = inname(1);
     endif
   endif
 
   ## Set name of output
   if (nargin > 5)
     if(!isempty(outname))
-      if(!is_list(outname))        outname = list(outname);    endif
+      if(!islist(outname))        outname = list(outname);    endif
       if(!is_signal_list(outname))
         error("outname must be a single signal name");
       endif
       outsys.outname = outname(1);
     endif
   endif
 
 endfunction
diff --git a/scripts/control/system/zp2tf.m b/scripts/control/system/zp2tf.m
--- a/scripts/control/system/zp2tf.m
+++ b/scripts/control/system/zp2tf.m
@@ -38,19 +38,19 @@
 function [num, den] = zp2tf (zer, pol, k)
 
   ## Find out whether data was entered as a row or a column vector and
   ## convert to a column vector if necessary.
 
   [rp,cp] = size(pol);
   [rz,cz] = size(zer);
 
-  if(!(is_vector(zer) | isempty(zer)) )
+  if(!(isvector(zer) | isempty(zer)) )
     error(sprintf("zer(%dx%d) must be a vector",rz,cz));
-  elseif(!(is_vector(pol) | isempty(pol)) )
+  elseif(!(isvector(pol) | isempty(pol)) )
     error(sprintf("pol(%dx%d) must be a vector",rp,cp));
   elseif(length(zer) > length(pol))
     error(sprintf("zer(%dx%d) longer than pol(%dx%d)",rz,cz,rp,cp));
   endif
 
   ## initialize converted polynomials
 
   num = k;  den = 1;
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -31,21 +31,21 @@ function zpout (zer, pol, k, x)
 
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
     usage("zpout(zer,pol,k[,x])");
   endif
 
-  if( !(is_vector(zer) | isempty(zer)) | !(is_vector(pol) | isempty(pol)) )
+  if( !(isvector(zer) | isempty(zer)) | !(isvector(pol) | isempty(pol)) )
     error("zer, pol must be vectors or empty");
   endif
 
-  if(!is_scalar(k))
+  if(!isscalar(k))
     error("zpout: argument k must be a scalar.")
   endif
 
   if (nargin == 3)
     x = "s";
   elseif( ! isstr(x) )
     error("zpout: third argument must be a string");
   endif
diff --git a/scripts/control/util/__outlist__.m b/scripts/control/util/__outlist__.m
--- a/scripts/control/util/__outlist__.m
+++ b/scripts/control/util/__outlist__.m
@@ -61,17 +61,17 @@ function str_val = __outlist__ (name_lis
     tabchar = "";
   endif
 
   if(nargin < 3)             yd = zeros(1,m);
   elseif(isempty(yd))        yd = zeros(1,m);          endif
 
   str_val = "";
   dstr = list(""," (discrete)");
-  if((m >= 1) && (is_list(name_list)))
+  if((m >= 1) && (islist(name_list)))
     for ii=1:m
       str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
           nth(name_list,ii),nth(dstr,yd(ii)+1));
     endfor
   else
     str_val = sprintf("%sNone",tabchar);
   endif
 
diff --git a/scripts/control/util/__zgpbal__.m b/scripts/control/util/__zgpbal__.m
--- a/scripts/control/util/__zgpbal__.m
+++ b/scripts/control/util/__zgpbal__.m
@@ -38,17 +38,17 @@
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
 function retsys = __zgpbal__ (Asys)
 
-  if( (nargin != 1) | (!is_struct(Asys)))
+  if( (nargin != 1) | (!isstruct(Asys)))
     usage("retsys = __zgpbal__ (Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
   [nn,mm,pp] = abcddim(a,b,c,d);
 
diff --git a/scripts/control/util/sortcom.m b/scripts/control/util/sortcom.m
--- a/scripts/control/util/sortcom.m
+++ b/scripts/control/util/sortcom.m
@@ -35,17 +35,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function [yy, idx] = sortcom (xx, opt)
 
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
-  elseif( !(is_vector(xx) | isempty(xx) ))
+  elseif( !(isvector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
   else
     if (!isstr(opt))
       error("sortcom: second argument must be a string");
     endif
diff --git a/scripts/control/util/zgscal.m b/scripts/control/util/zgscal.m
--- a/scripts/control/util/zgscal.m
+++ b/scripts/control/util/zgscal.m
@@ -48,17 +48,17 @@ function x = zgscal (a, b, c, d, z, n, m
 
   ## construct balancing least squares problem
   F = eye(nmp);
   for kk=1:nmp
     F(1:nmp,kk) = zgfmul(a,b,c,d,F(:,kk));
   endfor
 
   [U,H,k1] = krylov(F,z,nmp,1e-12,1);
-  if(!is_square(H))
+  if(!issquare(H))
     if(columns(H) != k1)
       error("zgscal(tzero): k1=%d, columns(H)=%d",k1,columns(H));
     elseif(rows(H) != k1+1)
       error("zgscal: k1=%d, rows(H) = %d",k1,rows(H));
     elseif ( norm(H(k1+1,:)) > 1e-12*norm(H,"inf") )
       zgscal_last_row_of_H = H(k1+1,:)
       error("zgscal: last row of H nonzero (norm(H)=%e)",norm(H,"inf"))
     endif
diff --git a/scripts/control/util/zgshsr.m b/scripts/control/util/zgshsr.m
--- a/scripts/control/util/zgshsr.m
+++ b/scripts/control/util/zgshsr.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
 function x = zgshsr (y)
 
-  if(!is_vector(y))
+  if(!isvector(y))
     error(sprintf("y(%dx%d) must be a vector",rows(y),columns(y)));
   endif
   x = vec(y);
   m = length(x);
   if (m>1)
     beta = (1 + sqrt(m))*x(1) + sum(x(2:m));
     beta = beta/(m+sqrt(m));
     x(1) = x(1) - beta*(1.0d0+sqrt(m));
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -38,21 +38,21 @@
 ## Description: Future value of an investment
 
 function v = fv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("fv (r, n, p, l, method)");
   endif
 
-  if (! (is_scalar (r) && (r > -1)))
+  if (! (isscalar (r) && (r > -1)))
     error ("fv: r must be a scalar > -1");
-  elseif (! (is_scalar (n) && (n > 0)))
+  elseif (! (isscalar (n) && (n > 0)))
     error ("fv: n must be a positive scalar");
-  elseif (! is_scalar (p))
+  elseif (! isscalar (p))
     error ("fv: p must be a scalar");
   endif
 
   if (r != 0)
     v = p * ((1 + r)^n - 1) / r;
   else
     v = p * n;
   endif
@@ -66,17 +66,17 @@ function v = fv (r, n, p, l, m)
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if strcmp (m, "b")
       v = v * (1 + r);
     endif
-    if is_scalar (l)
+    if isscalar (l)
       v = v + fvl (r, n, l);
     else
       error ("fv: l must be a scalar");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/finance/fvl.m b/scripts/finance/fvl.m
--- a/scripts/finance/fvl.m
+++ b/scripts/finance/fvl.m
@@ -31,19 +31,19 @@
 ## Description: Future value of an initial lump sum investment
 
 function v = fvl (r, n, l)
 
   if (nargin != 3)
     usage ("fvl (r, n, l)");
   endif
 
-  if (! (is_scalar (r) && (r > -1)))
+  if (! (isscalar (r) && (r > -1)))
     error ("fvl: r has to be a scalar > -1");
-  elseif (! (is_scalar (n) && (n > 0)))
+  elseif (! (isscalar (n) && (n > 0)))
     error ("fvl: n has to be a positive scalar");
-  elseif (! is_scalar (l))
+  elseif (! isscalar (l))
     error ("fvl: l has to be a scalar");
   endif
 
   v = l * (1 + r)^n;
 
 endfunction
\ No newline at end of file
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -32,21 +32,21 @@
 function r = irr (p, i)
 
   if (nargin == 1)
     i = 0;
   elseif (! (nargin == 2))
     usage ("irr (p, i)");
   endif
 
-  if (! (is_vector (p)))
+  if (! (isvector (p)))
     error ("irr: p must be a vector");
   else
     p_string = strcat ("[", sprintf ("%.15f, ", p), "]");
   endif
 
-  if (! is_scalar (i))
+  if (! isscalar (i))
     error ("irr: i must be a scalar");
   endif
 
   r = fsolve (sprintf ("npv (x, %s) - %g", p_string, i), 0.01);
 
 endfunction
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -38,21 +38,21 @@
 ## Description: Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("nper (r, p, a, l, method)");
   endif
 
-  if (! (is_scalar (r) && (r > -1)))
+  if (! (isscalar (r) && (r > -1)))
     error ("nper: r must be a scalar > -1");
-  elseif (! is_scalar (p))
+  elseif (! isscalar (p))
     error ("nper: p must be a scalar");
-  elseif (! is_scalar (a))
+  elseif (! isscalar (a))
     error ("nper: a must be a scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
       error ("nper: `method' must be a string");
     endif
   elseif (nargin == 4)
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -37,36 +37,36 @@
 ## Description: Net present value of a series of payments
 
 function v = npv (r, p, i)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("npv (r, p, i");
   endif
 
-  if (! (is_vector (p)))
+  if (! (isvector (p)))
     error ("npv: p has to be a vector");
   else
     n = length (p);
     p = reshape (p, 1, n);
   endif
 
   if (any (any (r <= -1)))
     error ("npv: all interest rates must be > -1");
   endif
-  if (is_scalar (r))
+  if (isscalar (r))
     d = 1 ./ (1 + r) .^ (0 : n);
-  elseif (is_vector (r) && (length (r) == n))
+  elseif (isvector (r) && (length (r) == n))
     d = [1, (1 ./ cumprod (reshape (1 + r, 1, n)))];
   else
     error ("npv: r must be a scalar or a vector of the same length as p");
   endif
 
   if (nargin == 3)
-    if (! is_scalar (i))
+    if (! isscalar (i))
       error ("npv: I_0 must be a scalar");
     endif
   else
     i = 0;
   endif
 
   p = [i, p];
   v = sum (d .* p);
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -35,21 +35,21 @@
 ## Description: Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
 
   if (nargin < 3 || nargin > 5)
     usage ("pmt (r, n, a, l, method)");
   endif
 
-  if (! (is_scalar (r) && r > -1))
+  if (! (isscalar (r) && r > -1))
     error ("pmt: rate must be a scalar > -1");
-  elseif (! (is_scalar (n) && n > 0))
+  elseif (! (isscalar (n) && n > 0))
     error ("pmt: n must be a positive scalar");
-  elseif (! (is_scalar (a) && a > 0))
+  elseif (! (isscalar (a) && a > 0))
     error ("pmt: a must be a positive scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
       error ("pmt: `method' must be a string");
     endif
   elseif (nargin == 4)
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -38,21 +38,21 @@
 ## Description: Present value of an investment
 
 function v = pv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("pv (r, n, p, l, method)");
   endif
 
-  if (! (is_scalar (r) && (r > -1)))
+  if (! (isscalar (r) && (r > -1)))
     error ("pv: r must be a scalar > -1");
-  elseif (! (is_scalar (n) && (n > 0)))
+  elseif (! (isscalar (n) && (n > 0)))
     error ("pv: n must be a positive scalar");
-  elseif (! is_scalar (p))
+  elseif (! isscalar (p))
     error ("pv: p must be a scalar");
   endif
 
   if (r != 0)
     v = p * (1 - (1 + r)^(-n)) / r;
   else
     v = p * n;
   endif
@@ -66,17 +66,17 @@ function v = pv (r, n, p, l, m)
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if (strcmp (m, "b"))
       v = v * (1 + r);
     endif
-    if (is_scalar (l))
+    if (isscalar (l))
       v = v + pvl (r, n, l);
     else
       error ("pv: l must be a scalar");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/finance/pvl.m b/scripts/finance/pvl.m
--- a/scripts/finance/pvl.m
+++ b/scripts/finance/pvl.m
@@ -31,19 +31,19 @@
 ## Description: Present value of an investment that pays off at the end
 
 function v = pvl (r, n, p)
 
   if (nargin != 3)
     usage ("pvl (r, n, p)");
   endif
 
-  if (! (is_scalar (r) && (r > -1)))
+  if (! (isscalar (r) && (r > -1)))
     error ("pvl: r has to be a scalar > -1");
-  elseif (! (is_scalar (n) && (n > 0)))
+  elseif (! (isscalar (n) && (n > 0)))
     error ("pvl: n has to be a positive scalar");
-  elseif (! is_scalar (p))
+  elseif (! isscalar (p))
     error ("pvl: p has to be a scalar");
   endif
 
   v = p / (1 + r)^n;
 
 endfunction
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -35,21 +35,21 @@
 ## Description: Rate of return of an investment
 
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("rate (n, p, v, l, method)");
   endif
 
-  if (! (is_scalar (n) && (n > 0)))
+  if (! (isscalar (n) && (n > 0)))
     error ("rate: n must be a positive scalar");
-  elseif (! is_scalar (p))
+  elseif (! isscalar (p))
     error ("rate: p must be a scalar");
-  elseif (! is_scalar (v))
+  elseif (! isscalar (v))
     error ("rate: p must be a scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
       error ("rate: `method' must be a string");
     endif
   elseif (nargin == 4)
@@ -59,16 +59,16 @@ function r = rate (n, p, v, l, m)
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
 
-  if (! is_scalar (l))
+  if (! isscalar (l))
     error ("rate: l must be a scalar");
   endif
 
   [r, info] = fsolve (sprintf ("pv (x, %g, %g, %g, \"%s\") - %g",
 			       n, p, l, m, v), 0);
 
 endfunction
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -35,18 +35,18 @@ function [Theta, R, Z] = cart2pol (X, Y,
   if (nargin < 2 || nargin > 3)
     error ("cart2pol: number of arguments must be 2 or 3");
   endif
 
   if (nargin == 2 && nargout > 2)
     error ("cart2pol: number of output arguments must not be greater than number of input arguments");
   endif
 
-  if ((! (is_matrix (X) && is_matrix (Y)))
+  if ((! (ismatrix (X) && ismatrix (Y)))
       || (size (X) != size (Y))
-      || (nargin == 3 && (! (size (X) == size (Z) && is_matrix (Z)))))
+      || (nargin == 3 && (! (size (X) == size (Z) && ismatrix (Z)))))
     error ("cart2pol: arguments must be matrices of same size");
   endif
 
   Theta = atan2 (Y, X);
   R = sqrt (X .^ 2 + Y .^ 2);
 
 endfunction
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -31,17 +31,17 @@
 ## Adapted-by: jwe
 
 function [Theta, Phi, R] = cart2sph (X, Y, Z)
 
   if (nargin != 3)
     usage ("[Theta, Phi, R] = cart2sph (X, Y, Z)")
   endif
 
-  if ((! (is_matrix (X) && is_matrix (Y) && is_matrix (Z)))
+  if ((! (ismatrix (X) && ismatrix (Y) && ismatrix (Z)))
       || size (X) != size (Y)
       || size (X) != size (Z))
     error ("cart2sph: arguments must be matrices of same size");
   endif
 
   Theta = atan2 (Y, X);
   Phi = atan2 (Z, sqrt (X .^ 2 + Y .^ 2));
   R = sqrt (X .^ 2 + Y .^ 2 + Z .^ 2);
diff --git a/scripts/general/columns.m b/scripts/general/columns.m
--- a/scripts/general/columns.m
+++ b/scripts/general/columns.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} columns (@var{a})
 ## Return the number of columns of @var{a}.
 ## @end deftypefn
-## @seealso{size, rows, length, is_scalar, is_vector, and is_matrix}
+## @seealso{size, rows, length, isscalar, isvector, and ismatrix}
 
 ## Author: jwe
 
 function nc = columns (x)
 
   if (nargin != 1)
     usage ("columns (x)");
   endif
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -42,37 +42,37 @@
 ## Created: 2 February 1995
 ## Adapted-By: jwe
 
 function x = diff (x, k)
 
   if (nargin == 1)
     k = 1;
   elseif (nargin == 2)
-    if (! (is_scalar (k) && k == round (k) && k >= 0))
+    if (! (isscalar (k) && k == round (k) && k >= 0))
       error ("diff: k must be a nonnegative integer");
     elseif (k == 0)
       return;
     endif
   else
     usage ("diff (x, k");
   endif
 
   if (isstr (x))
     error ("diff: symbolic differentiation not (yet) supported");
-  elseif (is_vector (x))
+  elseif (isvector (x))
     n = length (x);
     if (n <= k)
       x = [];
     else
       for i = 1 : k
         x = x (2 : (n - i + 1)) - x (1 : (n - i));
       endfor
     endif
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     n = rows (x);
     if (n <= k)
       x = [];
     else
       for i = 1 : k
         x = x (2 : (n - i + 1), :) - x (1: (n - i), :);
       endfor
     endif
diff --git a/scripts/general/is_duplicate_entry.m b/scripts/general/is_duplicate_entry.m
--- a/scripts/general/is_duplicate_entry.m
+++ b/scripts/general/is_duplicate_entry.m
@@ -23,17 +23,17 @@
 ## another.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 
 function retval = is_duplicate_entry (x)
 
   if (nargin == 1)
-    if (is_matrix (x))
+    if (ismatrix (x))
       [m, n] = size (x);
       lx = m*n;
       lx1 = lx-1;
       x = sort (reshape (x, 1, lx));
       dx = x(1:lx1) - x(2:lx);
       retval = sum (dx == 0);
     else
       error ("is_duplicate_entry: expecting matrix argument");
diff --git a/scripts/general/mod.m b/scripts/general/mod.m
--- a/scripts/general/mod.m
+++ b/scripts/general/mod.m
@@ -39,34 +39,34 @@
 ## Adapted by: jwe
 
 function r = mod (x, y)
 
   if (nargin != 2)
     usage ("r = mod (x, y)");
   endif
 
-  if (any (size (x) != size (y)) && ! (is_scalar (x) || is_scalar (y)))
+  if (any (size (x) != size (y)) && ! (isscalar (x) || isscalar (y)))
     error ("mod: argument sizes must agree");
   endif
 
   ## Matlab allows complex arguments, but as far as I can tell, that's a
   ## bunch of hooey.
 
   if (isreal (x) && isreal (y))
     nz = y != 0.0;
     if (all (nz(:)))
       ## No elements of y are zero.
       r = x - y .* floor (x ./ y);
-    elseif (is_scalar (y))
+    elseif (isscalar (y))
       ## y must be zero.
       r = x;
     else
       ## Some elements of y are zero.
-      if (is_scalar (x))
+      if (isscalar (x))
 	r = x * ones (size (y));
       else
 	r = x;
 	x = x(nz);
       endif
       y = y(nz);
       r(nz) = x - y .* floor (x ./ y);
     endif
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -38,17 +38,17 @@
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
 
   if (nargin != 1)
     usage ("nextpow2 (x)");
   endif
 
-  if (! (is_scalar (x) || is_vector (x)))
+  if (! (isscalar (x) || isvector (x)))
     error ("nextpow2: x must be a scalar or a vector");
   endif
 
   t = length (x);
   if (t > 1)
     x = t;
   endif
 
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -35,18 +35,18 @@ function [X, Y, Z] = pol2cart (Theta, R,
   if (nargin < 2 || nargin > 3)
     error ("pol2cart: number of arguments must be 2 or 3");
   endif
 
   if (nargin == 2 && nargout > 2)
     error ("pol2cart: number of output arguments must not be greater than number of input arguments");
   endif
 
-  if ((! (is_matrix (Theta) && is_matrix (R)))
+  if ((! (ismatrix (Theta) && ismatrix (R)))
       || (size (Theta) != size (R))
-      || (nargin == 3 && (! (size (R) == size (Z) && is_matrix (Z)))))
+      || (nargin == 3 && (! (size (R) == size (Z) && ismatrix (Z)))))
     error ("pol2cart: arguments must be matrices of same size");
   endif
 
   X = cos (Theta) .* R;
   Y = sin (Theta) .* R;
 
 endfunction
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -28,19 +28,19 @@
 function y = postpad (x, l, c)
 
   if (nargin == 2)
     c = 0;
   elseif (nargin < 2 || nargin > 3)
     usage ("postpad (x, l) or postpad (x, l, c)");
   endif
 
-  if (! is_matrix (x))
+  if (! ismatrix (x))
     error ("first argument must be a vector or matrix");
-  elseif (! is_scalar (l))
+  elseif (! isscalar (l))
     error ("second argument must be a scaler");
   endif
 
   if (l < 0)
     error ("second argument must be non-negative");
   endif
 
   [nr, nc] = size (x);
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -37,19 +37,19 @@
 function y = prepad (x, l, c)
 
   if (nargin == 2)
     c = 0;
   elseif (nargin < 2 || nargin > 3)
     usage ("prepad (x, l) or prepad (x, l, c)");
   endif
 
-  if (! is_matrix (x))
+  if (! ismatrix (x))
     error ("first argument must be a vector or matrix");
-  elseif (! is_scalar (l))
+  elseif (! isscalar (l))
     error ("second argument must be a scaler");
   endif
 
   if (l < 0)
     error ("second argument must be non-negative");
   endif
 
   [nr, nc] = size (x);
diff --git a/scripts/general/randperm.m b/scripts/general/randperm.m
--- a/scripts/general/randperm.m
+++ b/scripts/general/randperm.m
@@ -23,17 +23,17 @@
 ## integers from 1 to @var{n}.
 ## @end deftypefn
 
 ## Author: "James R. Van Zandt" <jrv@vanzandt.mv.com>
 ## Adapted-By: jwe
 
 function retval = randperm (n)
 
-  if (nargin == 1 && is_scalar (n) && floor (n) == n)
+  if (nargin == 1 && isscalar (n) && floor (n) == n)
     if (n > 0)
       [junk, retval] = sort (rand (1, n));
     else
       error ("randperm: argument must be positive");
     endif
   else
     usage ("randperm (n)");
   endif
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -34,17 +34,17 @@
 ## Author: jwe
 
 function r = rem (x, y)
 
   if (nargin != 2)
     usage ("rem (x, y)");
   endif
 
-  if (any (size (x) != size (y)) && ! (is_scalar (x) || is_scalar (y)))
+  if (any (size (x) != size (y)) && ! (isscalar (x) || isscalar (y)))
     error ("rem: argument sizes must agree");
   endif
 
   ## Matlab allows complex arguments, but as far as I can tell, that's a
   ## bunch of hooey.
 
   if (isreal (x) && isreal (y))
     r = x - y .* fix (x ./ y);
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -30,19 +30,19 @@
 
 function x = repmat (a, m, n)
 
   if (nargin < 2 || nargin > 3)
     usage ("repmat (a, m, n)");
   endif
 
   if (nargin == 2)
-    if (is_scalar (m))
+    if (isscalar (m))
       n = m;
-    elseif (is_vector (m) && length (m) == 2)
+    elseif (isvector (m) && length (m) == 2)
       n = m(2);
       m = m(1);
     else
       error ("repmat: only builds 2D matrices")
     endif
   endif
 
   if (isstr (a))
diff --git a/scripts/general/rows.m b/scripts/general/rows.m
--- a/scripts/general/rows.m
+++ b/scripts/general/rows.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rows (@var{a})
 ## Return the number of rows of @var{a}.
 ## @end deftypefn
-## @seealso{size, columns, length, is_scalar, is_vector, and is_matrix}
+## @seealso{size, columns, length, isscalar, isvector, and ismatrix}
 
 ## Author: jwe
 
 function nr = rows (x)
 
   if (nargin != 1)
     usage ("rows (x)");
   endif
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -40,17 +40,17 @@ function y = shift (x, b)
   if (nr == 0 || nc == 0)
     error ("shift: x must not be empty");
   elseif (nr == 1)
     x = x.';
     nr = nc;
     nc = 0;
   endif
 
-  if (! (is_scalar (b) && b == round (b)))
+  if (! (isscalar (b) && b == round (b)))
     error ("shift: b must be an integer");
   endif
 
   if (b >= 0)
     b = rem (b, nr);
     t1 = x (nr-b+1:nr, :);
     t2 = x (1:nr-b, :);
     y = [t1; t2];
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -31,17 +31,17 @@
 ## Adapted-by: jwe
 
 function [X, Y, Z] = sph2cart (Theta, Phi, R)
 
   if (nargin != 3)
     usage ("[X, Y, Z] = sph2cart (Theta, Phi, R)");
   endif
 
-  if ((! (is_matrix (Theta) && is_matrix (Phi) && is_matrix (R)))
+  if ((! (ismatrix (Theta) && ismatrix (Phi) && ismatrix (R)))
       || size (Theta) != size (Phi)
       || size (Theta) != size (R))
     error ("sph2cart: arguments must be matrices of same size");
   endif
 
   X = R .* cos (Phi) .* cos (Theta);
   Y = R .* cos (Phi) .* sin (Theta);
   Z = R .* sin (Phi);
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -32,17 +32,17 @@ function msg = strerror (name, err)
   if (nargin != 2)
     usage ("strerror (name, err)");
   endif
 
   if (! isstr (name))
     error ("strerror: first argument must be a string");
   endif
 
-  if (! is_scalar (err))
+  if (! isscalar (err))
     error ("strerror: second argument must be a scalar");
   endif
 
   if (strcmp (name, "fsolve"))
 
     if (err == -2)
       msg = "input error\n";
     elseif (err == -1)
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -32,17 +32,17 @@ function rgb_map = hsv2rgb (hsv_map)
 ## x = (1-sat)*val+sat*val*f_x(hue)
 ## where f_x(hue) is a piecewise defined function for
 ## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3)
 
   if (nargin != 1)
     usage ("rgb_map = hsv2rgb (hsv_map)");
   endif
 
-  if (! is_matrix (hsv_map) || columns (hsv_map) != 3)
+  if (! ismatrix (hsv_map) || columns (hsv_map) != 3)
     error ("hsv2rgb: argument must be a matrix of size nx3");
   endif
 
   ## set values <0 to 0 and >1 to 1
   hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map \
       + (hsv_map < 0) .* 0 + (hsv_map > 1);
 
   ## fill rgb map with v*(1-s)
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -27,17 +27,17 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = ocean (number)
 
   if (nargin == 0)
     number = 64;
   elseif (nargin == 1)
-    if (! is_scalar (number))
+    if (! isscalar (number))
       error ("ocean: argument must be a scalar");
     endif
   else
     usage ("ocean (number)");
   endif
 
   cutin = fix (number/3);
 
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -34,17 +34,17 @@
 ## Adapted-by: jwe
 
 function hsval = rgb2hsv (rgb)
 
   if (nargin != 1)
     usage ("hsv_map = rgb2hsv (rgb_map)");
   endif
 
-  if (! is_matrix (rgb) || columns (rgb) != 3)
+  if (! ismatrix (rgb) || columns (rgb) != 3)
     error ("rgb2hsv: argument must be a matrix of size n x 3");
   endif
 
   ## get the max and min
   s = min (rgb')';
   v = max (rgb')';
 
   ## set hue to zero for undefined values (gray has no hue)
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -95,17 +95,17 @@ function saveimage (filename, img, img_f
   elseif (! isstr (img_form))
     error ("image format specification must be a string");
   elseif (! (strcmp (img_form, "img")
              || strcmp (img_form, "ppm")
              || strcmp (img_form, "ps")))
     error ("unsupported image format specification");
   endif
 
-  if (! is_matrix (img))
+  if (! ismatrix (img))
     warning ("image variable is not a matrix");
   endif
 
   if (! isstr (filename))
     error ("file name must be a string");
   endif
 
   ## If we just want Octave image format, save and return.
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -84,22 +84,22 @@
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
 
   if (nargin < 1 || nargin > 2)
     usage ("commutation_matrix (m, n)");
   else
-    if (! (is_scalar (m) && m == round (m) && m > 0))
+    if (! (isscalar (m) && m == round (m) && m > 0))
       error ("commutation_matrix: m must be a positive integer");
     endif
     if (nargin == 1)
       n = m;
-    elseif (! (is_scalar (n) && n == round (n) && n > 0))
+    elseif (! (isscalar (n) && n == round (n) && n > 0))
       error ("commutation_matrix: n must be a positive integer");
     endif
   endif
 
   ## It is clearly possible to make this a LOT faster!
   k = zeros (m * n, m * n);
   for i = 1 : m
     for j = 1 : n
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -25,17 +25,17 @@
 ## Author: jwe
 
 function z = dot (x, y)
 
   if (nargin != 2)
     usage ("dot (x, y)");
   endif
 
-  if (is_vector (x) && is_vector (y) && length (x) == length (y))
+  if (isvector (x) && isvector (y) && length (x) == length (y))
     [x_nr, x_nc] = size (x);
     [y_nr, y_nc] = size (y);
     if (x_nr == 1)
       if (y_nr == 1)
         z = x * y.';
       else
         z = x * y;
       endif
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -74,17 +74,17 @@
 ## Adapged-By: jwe
 
 function d = duplication_matrix (n)
 
   if (nargin != 1)
     usage ("duplication_matrix (n)");
   endif
 
-  if (! (is_scalar (n) && n == round (n) && n > 0))
+  if (! (isscalar (n) && n == round (n) && n > 0))
     error ("duplication_matrix: n must be a positive integer");
   endif
 
   d = zeros (n * n, n * (n + 1) / 2);
 
   ## It is clearly possible to make this a LOT faster!
   count = 0;
   for j = 1 : n
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -30,19 +30,19 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel
 ## Created: August 1995
 
 function [housv, beta, zer] = housh (x, j, z)
 
   ## check for valid inputs
-  if (!is_vector (x) && ! is_scalar (x))
+  if (!isvector (x) && ! isscalar (x))
     error ("housh: first input must be a vector")
-  elseif (! is_scalar(j))
+  elseif (! isscalar(j))
     error ("housh: second argment must be an integer scalar")
   else
     housv = x;
     m = max (abs (housv));
     if (m != 0.0)
       housv = housv / m;
       alpha = norm (housv);
       if (alpha > z)
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -56,28 +56,28 @@ function [Uret,H,nu] = krylov(A,V,k,eps1
   if(nargin < 4)
     eps1 = defeps;    # default tolerance parameter
   endif
 
   if (isempty (eps1))
     eps1 = defeps;
   endif
 
-  na = is_square (A);
+  na = issquare (A);
   if (! na)
     error ("A(%d x %d) must be square", rows (A), columns (A));
   endif
 
   [m, kb] = size(V);
   if (m != na)
     error("A(%d x %d), V(%d x %d): argument dimensions do not match",
 	  na, na, m, kb)
   endif
 
-  if (! is_scalar (k))
+  if (! isscalar (k))
     error ("krylov: third argument must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
 
   ## check for trivial solution
   if (Vnrm == 0)
     Uret = [];
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -32,17 +32,17 @@
 ## Adapted-By: jwe
 
 function v = vech (x)
 
   if (nargin != 1)
     usage ("vech (x)");
   endif
 
-  if (! is_square (x))
+  if (! issquare (x))
     error ("vech: x must be square");
   endif
 
   ## This should be quicker than having an inner `for' loop as well.
   ## Ideally, vech should be written in C++.
   n = rows (x);
   v = zeros ((n+1)*n/2, 1);
   count = 0;
diff --git a/scripts/miscellaneous/etime.m b/scripts/miscellaneous/etime.m
--- a/scripts/miscellaneous/etime.m
+++ b/scripts/miscellaneous/etime.m
@@ -37,17 +37,17 @@
 ## Author: jwe
 
 function secs = etime (t1, t0)
 
   if (nargin != 2)
     usage ("etime (t1, t0)");
   endif
 
-  if (is_vector (t1) && length (t1) == 6 && is_vector (t0) && length (t0) == 6)
+  if (isvector (t1) && length (t1) == 6 && isvector (t0) && length (t0) == 6)
 
     if (t1 (1) != t0 (1))
       error ("etime: can't handle timings over year boundaries yet");
     endif
 
     ## XXX FIXME XXX -- could check here to ensure that t1 and t0 really do
     ## make sense as vectors returned from clock().
 
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -33,17 +33,17 @@
 ## @end ifinfo
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = list_primes (n)
 
   if (nargin > 0)
-    if (! is_scalar (n))
+    if (! isscalar (n))
       error ("list_primes: argument must be a scalar");
     endif
   endif
 
   if (nargin == 0)
     n = 30;
   endif
 
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -59,17 +59,17 @@ function num = menu (t, varargin)
     while (1)
       for i = 1:nopt
         printf ("  [%2d] ", i);
         disp (varargin{i});
       endfor
       printf ("\n");
       s = input ("pick a number, any number: ", "s");
       eval (sprintf ("num = %s;", s), "num = [];");
-      if (! is_scalar (num) || num < 1 || num > nopt)
+      if (! isscalar (num) || num < 1 || num > nopt)
         printf ("\nerror: input invalid or out of range\n\n");
       else
         break;
       endif
     endwhile
 
   unwind_protect_cleanup
 
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -27,17 +27,17 @@
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function z = xor (x, y)
 
   if (nargin == 2)
-    if (is_scalar (x) || is_scalar (y) || size (x) == size (y))
+    if (isscalar (x) || isscalar (y) || size (x) == size (y))
       z = logical ((x | y) - (x & y));
     else
       error ("xor: x and y must be of common size or scalars");
     endif
   else
     usage ("xor (x, y)");
   endif
 
diff --git a/scripts/plot/__errcomm__.m b/scripts/plot/__errcomm__.m
--- a/scripts/plot/__errcomm__.m
+++ b/scripts/plot/__errcomm__.m
@@ -41,19 +41,19 @@ function __errcomm__ (caller, varargin)
     if (! ishold)
       clg
     endif
     hold on;
     k = 1;
     while (nargin)
       a = varargin{k++};
       nargin--;
-      if (is_vector (a))
+      if (isvector (a))
         a = a(:);
-      elseif (is_matrix (a))
+      elseif (ismatrix (a))
         ;
       else
         usage ("%s (...)", caller);
       endif
       sz = size (a);
       ndata = 1;
       arg1 = a;
       while (nargin)
@@ -62,19 +62,19 @@ function __errcomm__ (caller, varargin)
 	if (isstr (a))
 	  fmt = a;
 	  cmd = "__errplot__ (arg1";
 	  for i = 2:ndata,
 	    cmd = sprintf ("%s, arg%d", cmd, i);
 	  endfor
 	  eval (sprintf ("%s, fmt);", cmd));
 	  break;
-	elseif (is_vector (a))
+	elseif (isvector (a))
 	  a = a(:);
-	elseif (is_matrix (a))
+	elseif (ismatrix (a))
 	  ;
 	else
 	  error ("wrong argument types");
 	endif
 	if (size (a) != sz)
 	  error ("argument sizes do not match");
 	endif
 	ndata++;
diff --git a/scripts/plot/__plr2__.m b/scripts/plot/__plr2__.m
--- a/scripts/plot/__plr2__.m
+++ b/scripts/plot/__plr2__.m
@@ -32,37 +32,37 @@ function __plr2__ (theta, rho, fmt)
   if (any (imag (theta)))
     theta = real (theta);
   endif
 
   if (any (imag (rho)))
     rho = real (rho);
   endif
 
-  if (is_scalar (theta))
-    if (is_scalar (rho))
+  if (isscalar (theta))
+    if (isscalar (rho))
       x = rho * cos (theta);
       y = rho * sin (theta);
       __plt2ss__ (x, y, fmt);
     endif
-  elseif (is_vector (theta))
-    if (is_vector (rho))
+  elseif (isvector (theta))
+    if (isvector (rho))
       if (length (theta) != length (rho))
         error ("polar: vector lengths must match");
       endif
       if (rows (rho) == 1)
         rho = rho';
       endif
       if (rows (theta) == 1)
         theta = theta';
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       __plt2vv__ (x, y, fmt);
-    elseif (is_matrix (rho))
+    elseif (ismatrix (rho))
       [t_nr, t_nc] = size (theta);
       if (t_nr == 1)
         theta = theta';
         tmp = t_nr;
         t_nr = t_nc;
         t_nc = tmp;
       endif
       [r_nr, r_nc] = size (rho);
@@ -74,18 +74,18 @@ function __plr2__ (theta, rho, fmt)
       endif
       if (t_nr != r_nr)
         error ("polar: vector and matrix sizes must match");
       endif
       x = diag (cos (theta)) * rho;
       y = diag (sin (theta)) * rho;
       __plt2vm__ (x, y, fmt);
     endif
-  elseif (is_matrix (theta))
-    if (is_vector (rho))
+  elseif (ismatrix (theta))
+    if (isvector (rho))
       [r_nr, r_nc] = size (rho);
       if (r_nr == 1)
         rho = rho';
         tmp = r_nr;
         r_nr = r_nc;
         r_nc = tmp;
       endif
       [t_nr, t_nc] = size (theta);
@@ -97,17 +97,17 @@ function __plr2__ (theta, rho, fmt)
       endif
       if (r_nr != t_nr)
         error ("polar: vector and matrix sizes must match");
       endif
       diag_r = diag (rho);
       x = diag_r * cos (theta);
       y = diag_r * sin (theta);
       __plt2mv__ (x, y, fmt);
-    elseif (is_matrix (rho))
+    elseif (ismatrix (rho))
       if (size (rho) != size (theta))
         error ("polar: matrix dimensions must match");
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       __plt2mm__ (x, y, fmt);
     endif
   endif
diff --git a/scripts/plot/__plr__.m b/scripts/plot/__plr__.m
--- a/scripts/plot/__plr__.m
+++ b/scripts/plot/__plr__.m
@@ -45,37 +45,37 @@ function __plr__ (theta, rho, fmt)
 
   if (nargin <= 2)
     if (any (imag (theta)))
       theta = real (theta);
     endif
     if (any (imag (rho)))
       rho = real (rho);
     endif
-    if (is_scalar (theta))
-      if (is_scalar (rho))
+    if (isscalar (theta))
+      if (isscalar (rho))
         x = rho * cos (theta);
         y = rho * sin (theta);
         __plt2ss__ (x, y, fmt);
       endif
-    elseif (is_vector (theta))
-      if (is_vector (rho))
+    elseif (isvector (theta))
+      if (isvector (rho))
         if (length (theta) != length (rho))
           error ("polar: vector lengths must match");
         endif
         if (rows (rho) == 1)
           rho = rho.';
         endif
         if (rows (theta) == 1)
           theta = theta.';
         endif
         x = rho .* cos (theta);
         y = rho .* sin (theta);
         __plt2vv__ (x, y, fmt);
-      elseif (is_matrix (rho))
+      elseif (ismatrix (rho))
         [t_nr, t_nc] = size (theta);
         if (t_nr == 1)
           theta = theta.';
           tmp = t_nr;
           t_nr = t_nc;
           t_nc = tmp;
         endif
         [r_nr, r_nc] = size (rho);
@@ -87,18 +87,18 @@ function __plr__ (theta, rho, fmt)
         endif
         if (t_nr != r_nr)
           error ("polar: vector and matrix sizes must match");
         endif
         x = diag (cos (theta)) * rho;
         y = diag (sin (theta)) * rho;
         __plt2vm__ (x, y, fmt);
       endif
-    elseif (is_matrix (theta))
-      if (is_vector (rho))
+    elseif (ismatrix (theta))
+      if (isvector (rho))
         [r_nr, r_nc] = size (rho);
         if (r_nr == 1)
           rho = rho.';
           tmp = r_nr;
           r_nr = r_nc;
           r_nc = tmp;
         endif
         [t_nr, t_nc] = size (theta);
@@ -110,17 +110,17 @@ function __plr__ (theta, rho, fmt)
         endif
         if (r_nr != t_nr)
           error ("polar: vector and matrix sizes must match");
         endif
         diag_r = diag (r);
         x = diag_r * cos (theta);
         y = diag_r * sin (theta);
         __plt2mv__ (x, y, fmt);
-      elseif (is_matrix (rho))
+      elseif (ismatrix (rho))
         if (size (rho) != size (theta))
           error ("polar: matrix dimensions must match");
         endif
         x = rho .* cos (theta);
         y = rho .* sin (theta);
         __plt2mm__ (x, y, fmt);
       endif
     endif
diff --git a/scripts/plot/__plt2__.m b/scripts/plot/__plt2__.m
--- a/scripts/plot/__plt2__.m
+++ b/scripts/plot/__plt2__.m
@@ -38,27 +38,27 @@ function __plt2__ (x1, x2, fmt)
   endif
 
   if (any (any (imag (x1))))
     x1 = real (x1);
   endif
   if (any (any (imag (x2))))
     x2 = real (x2);
   endif
-  if (is_scalar (x1))
-    if (is_scalar (x2))
+  if (isscalar (x1))
+    if (isscalar (x2))
       __plt2ss__ (x1, x2, fmt);
     endif
-  elseif (is_vector (x1))
-    if (is_vector (x2))
+  elseif (isvector (x1))
+    if (isvector (x2))
       __plt2vv__ (x1, x2, fmt);
-    elseif (is_matrix (x2))
+    elseif (ismatrix (x2))
       __plt2vm__ (x1, x2, fmt);
     endif
-  elseif (is_matrix (x1))
-    if (is_vector (x2))
+  elseif (ismatrix (x1))
+    if (isvector (x2))
       __plt2mv__ (x1, x2, fmt);
-    elseif (is_matrix (x2))
+    elseif (ismatrix (x2))
       __plt2mm__ (x1, x2, fmt);
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -227,17 +227,17 @@ function curr_axis = axis (ax, varargin)
       else
 	gset format z "\\0";
       endif
 
     else
       warning (["unknown axis option '", ax, "'"]);
     endif
 
-  elseif (is_vector (ax))
+  elseif (isvector (ax))
 
     len = length (ax);
 
     if (len != 2 && len != 4 && len != 6)
       error ("axis: expecting vector with 2, 4, or 6 elements");
     endif
 
     __current_axis__ = reshape (ax, 1, len);
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -45,17 +45,17 @@
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
-    if (is_vector (x))
+    if (isvector (x))
       len = 3 * length (x) + 1;
       tmp_xb = tmp_yb = zeros (len, 1);
       tmp_xb(1) = 0.5;
       tmp_yb(1) = 0;
       k = 1;
       for i = 2:3:len
         tmp_xb(i) = k-0.5;
         tmp_xb(i+1) = k+0.5;
@@ -64,17 +64,17 @@ function [xb, yb] = bar (x, y)
         tmp_yb(i+1) = x(k);
         tmp_yb(i+2) = 0.0;
         k++;
       endfor
     else
       error ("bar: argument must be a vector");
     endif
   elseif (nargin == 2)
-    if (is_vector (x) && is_vector (y))
+    if (isvector (x) && isvector (y))
       xlen = length (x);
       ylen = length (y);
       if (xlen == ylen)
         len = 3 * xlen + 1;
         tmp_xb = tmp_yb = zeros (len, 1);
         cutoff = zeros (1, xlen-1);
         for i = 1:xlen-1
           cutoff(i) = (x(i) + x(i+1)) / 2.0;
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -37,23 +37,23 @@ function contour (x, y, z, n)
 
   if (nargin == 1 || nargin == 2)
     z = x;
     if (nargin == 1) 
       n = 10;
     else
       n = y; 
     endif
-    if (is_matrix (z))
+    if (ismatrix (z))
       gset nosurface;
       gset contour;
       gset cntrparam bspline;
-      if (is_scalar (n))
+      if (isscalar (n))
         command = sprintf ("gset cntrparam levels %d", n);
-      elseif (is_vector (n))
+      elseif (isvector (n))
         tmp = sprintf ("%f", n(1));
         for i = 2:length (n)
           tmp = sprintf ("%s, %f", tmp, n(i));
         endfor
         command = sprintf ("gset cntrparam levels discrete %s", tmp);
       endif
       eval (command);
       gset noparametric;
@@ -61,17 +61,17 @@ function contour (x, y, z, n)
       gsplot z w l 1;
     else
       error ("contour: argument must be a matrix");
     endif
   elseif (nargin == 3 || nargin == 4)
     if (nargin == 3)
       n = 10;
     endif
-    if (is_vector (x) && is_vector (y) && is_matrix (z))
+    if (isvector (x) && isvector (y) && ismatrix (z))
       xlen = length (x);
       ylen = length (y);
       if (xlen == rows (z) && ylen == columns (z))
         if (rows (x) == 1)
           x = x';
         endif
         len = 3 * ylen;
         zz = zeros (xlen, len);
@@ -80,19 +80,19 @@ function contour (x, y, z, n)
           zz(:,i)   = x;
           zz(:,i+1) = y(k) * ones (xlen, 1);
           zz(:,i+2) = z(:,k);
           k++;
         endfor
         gset nosurface;
         gset contour;
         gset cntrparam bspline;
-        if (is_scalar (n))
+        if (isscalar (n))
           command = sprintf ("gset cntrparam levels %d", n);
-        elseif (is_vector (n))
+        elseif (isvector (n))
           tmp = sprintf ("%f", n(1));
           for i = 2:length (n)
             tmp = sprintf ("%s, %f", tmp, n(i));
           endfor
           command = sprintf ("gset cntrparam levels discrete %s", tmp);
         endif
         eval (command);
         gset parametric;
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -44,39 +44,39 @@
 ## Author: jwe
 
 function [nn, xx] = hist (y, x, norm)
 
   if (nargin < 1 || nargin > 3)
     usage ("[nn, xx] = hist (y, x, norm)");
   endif
 
-  if (is_vector (y))
+  if (isvector (y))
     max_val = max (y);
     min_val = min (y);
   else
     error ("hist: first argument must be a vector");
   endif
 
   if (nargin == 1)
     n = 10;
     delta = (max_val - min_val) / n / 2;
     x = linspace (min_val+delta, max_val-delta, n);
     cutoff = x + delta;
   else
     ## nargin is either 2 or 3
-    if (is_scalar (x))
+    if (isscalar (x))
       n = x;
       if (n <= 0)
         error ("hist: number of bins must be positive");
       endif
       delta = (max_val - min_val) / n / 2;
       x = linspace (min_val+delta, max_val-delta, n);
       cutoff = x + delta;
-    elseif (is_vector (x))
+    elseif (isvector (x))
       tmp = sort (x);
       if (any (tmp != x))
         warning ("hist: bin values not sorted on input");
         x = tmp;
       endif
       n = length (x);
       cutoff = zeros (1, n-1);
       for i = 1:n-1
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -34,30 +34,30 @@
 function mesh (x, y, z)
 
   ## XXX FIXME XXX -- the plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   if (nargin == 1)
     z = x;
-    if (is_matrix (z))
+    if (ismatrix (z))
       gset hidden3d;
       gset data style lines;
       gset surface;
       gset nocontour;
       gset noparametric;
       gset nologscale;
       gset view 60, 30, 1, 1
       gsplot (z');
     else
       error ("mesh: argument must be a matrix");
     endif
   elseif (nargin == 3)
-    if (is_vector (x) && is_vector (y) && is_matrix (z))
+    if (isvector (x) && isvector (y) && ismatrix (z))
       xlen = length (x);
       ylen = length (y);
       if (xlen == columns (z) && ylen == rows (z))
         if (rows (y) == 1)
           y = y';
         endif
         len = 3 * xlen;
         zz = zeros (ylen, len);
@@ -77,17 +77,17 @@ function mesh (x, y, z)
         gset view 60, 30, 1, 1
         gsplot (zz);
         gset noparametric;
       else
         msg = "mesh: rows (z) must be the same as length (y) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (x)", msg);
         error (msg);
       endif
-    elseif (is_matrix (x) && is_matrix (y) && is_matrix (z))
+    elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       xlen = columns (z);
       ylen = rows (z);
       if (xlen == columns (x) && xlen == columns (y) &&
         ylen == rows (x) && ylen == rows(y))
         len = 3 * xlen;
         zz = zeros (ylen, len);
         k = 1;
         for i = 1:3:len
diff --git a/scripts/plot/meshdom.m b/scripts/plot/meshdom.m
--- a/scripts/plot/meshdom.m
+++ b/scripts/plot/meshdom.m
@@ -26,17 +26,17 @@
 ## of @sc{Matlab}.  You should use @code{meshgrid} instead.
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xx, yy] = meshdom (x, y)
 
   if (nargin == 2)
-    if (is_vector (x) && is_vector (y))
+    if (isvector (x) && isvector (y))
       xx = ones (length (y), 1) * x(:).';
       yy = flipud (y(:)) * ones (1, length (x));
     else
       error ("meshdom: arguments must be vectors");
     endif
   else
     usage ("[xx, yy] = meshdom (x, y)");
   endif
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -30,17 +30,17 @@
 ## Author: jwe
 
 function [xx, yy] = meshgrid (x, y)
 
   if (nargin == 1)
     y = x;
   endif
   if (nargin > 0 && nargin < 3)
-    if (is_vector (x) && is_vector (y))
+    if (isvector (x) && isvector (y))
       xx = ones (length (y), 1) * x(:).';
       yy = y(:) * ones (1, length (x));
     else
       error ("meshgrid: arguments must be vectors");
     endif
   else
     usage ("[xx, yy] = meshgrid (x, y)");
   endif
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -46,17 +46,17 @@ function multiplot (xn, yn)
   global __multiplot_yn__;
   global __multiplot_xi__;
   global __multiplot_yi__;
 
   if (nargin != 2)
     usage ("multiplot (xn, yn)");
   endif
 
-  if (! (is_scalar (xn) && is_scalar (yn)))
+  if (! (isscalar (xn) && isscalar (yn)))
     error ("multiplot: xn and yn have to be scalars");
   endif
 
   xn = round (xn);
   yn = round (yn);
 
   if (xn == 0 && yn == 0)
 
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -46,31 +46,31 @@
 ## bar, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
 
   if (nargin == 1)
-    if (is_vector (x))
+    if (isvector (x))
       len = 2 * length (x);
       tmp_xs = tmp_ys = zeros (len, 1);
       k = 0;
       for i = 1:2:len
         tmp_xs(i) = k++;
         tmp_ys(i) = x(k);
         tmp_ys(i+1) = x(k);
         tmp_xs(i+1) = k;
       endfor
     else
       error ("stairs: argument must be a vector");
     endif
   elseif (nargin == 2)
-    if (is_vector (x) && is_vector (y))
+    if (isvector (x) && isvector (y))
       xlen = length (x);
       ylen = length (y);
       if (xlen == ylen)
         len = 2 * xlen;
         tmp_xs = tmp_ys = zeros (len, 1);
         k = 1;
         len_m2 = len - 2;
         for i = 1:2:len_m2
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -89,28 +89,28 @@ function subplot (rows, columns, index)
   global __multiplot_yi__;
 
   if (nargin != 3 && nargin != 1)
     usage ("subplot (rows, columns, index) or subplot (rcn)");
   endif
 
   if (nargin == 1)
 
-    if (! (is_scalar (rows) && rows >= 0))
+    if (! (isscalar (rows) && rows >= 0))
       error ("subplot: input rcn has to be a positive scalar");
     endif
 
     tmp = rows;
     index = rem (tmp, 10);
     tmp = (tmp - index) / 10;
     columns = rem (tmp, 10);
     tmp = (tmp - columns) / 10;
     rows = rem (tmp, 10);
 
-  elseif (! (is_scalar (columns) && is_scalar (rows) && is_scalar (index)))
+  elseif (! (isscalar (columns) && isscalar (rows) && isscalar (index)))
     error ("subplot: columns, rows, and index have to be scalars");
   endif
 
   columns = round (columns);
   rows = round (rows);
   index = round (index);
 
   if (index > columns*rows)
diff --git a/scripts/plot/subwindow.m b/scripts/plot/subwindow.m
--- a/scripts/plot/subwindow.m
+++ b/scripts/plot/subwindow.m
@@ -46,17 +46,17 @@ function subwindow (xn, yn)
   ## check calling argument count
 
   if (nargin != 2)
     usage ("subwindow (xn, yn)");
   endif
 
   ## check for scalar inputs
 
-  if (! (is_scalar (xn) && is_scalar (yn)))
+  if (! (isscalar (xn) && isscalar (yn)))
     error ("subwindow: xn and yn have to be scalars");
   endif
 
   xn = round (xn);
   yn = round (yn);
 
   ## switch to multiplot mode if not already in, and use the args as the
   ## args to multiplot()
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -60,17 +60,17 @@
 ## Adapted-By: jwe
 
 function A = compan (c)
 
   if (nargin != 1)
     usage ("compan (vector)");
   endif
 
-  if (! is_vector (c))
+  if (! isvector (c))
     error ("compan: expecting a vector argument");
   endif
 
   ## Ensure that c is a row vector.
 
   if (rows (c) > 1)
     c = c.';
   endif
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -33,17 +33,17 @@
 ## Adapted-By: jwe
 
 function y = conv (a, b)
 
   if (nargin != 2)
     usage ("conv(a, b)");
   endif
 
-  if (! (is_vector (a) && is_vector (b)))
+  if (! (isvector (a) && isvector (b)))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   lb = length (b);
 
   ly = la + lb - 1;
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -35,17 +35,17 @@
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
     usage ("deconv (y, a)");
   endif
 
-  if (! (is_vector (y) && is_vector (a)))
+  if (! (isvector (y) && isvector (a)))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   ly = length (y);
 
   lb = ly - la + 1;
 
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -30,17 +30,17 @@
 ## Adapted-By: jwe
 
 function q = polyderiv (p)
 
   if (nargin != 1)
     usage ("polyderiv (vector)");
   endif
 
-  if (! is_vector (p))
+  if (! isvector (p))
     error ("polyderiv: argument must be a vector");
   endif
 
   lp = length (p);
   if (lp == 1)
     q = 0;
     return;
   elseif (lp == 0)
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -47,21 +47,21 @@
 
 function [p, yf] = polyfit (x, y, n)
 
 
   if (nargin != 3)
     usage ("polyfit (x, y, n)");
   endif
 
-  if (! (is_vector (x) && is_vector (y) && size (x) == size (y)))
+  if (! (isvector (x) && isvector (y) && size (x) == size (y)))
     error ("polyfit: x and y must be vectors of the same size");
   endif
 
-  if (! (is_scalar (n) && n >= 0 && ! isinf (n) && n == round (n)))
+  if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == round (n)))
     error ("polyfit: n must be a nonnegative integer");
   endif
 
   y_is_row_vector = (rows (y) == 1);
 
   l = length (x);
   x = reshape (x, l, 1);
   y = reshape (y, l, 1);
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -32,17 +32,17 @@
 ## Adapted-By: jwe
 
 function p = polyinteg (p)
 
   if(nargin != 1)
     usage ("polyinteg (vector)");
   endif
 
-  if (! (is_vector (p) || isempty (p)))
+  if (! (isvector (p) || isempty (p)))
     error ("argument must be a vector");
   endif
 
   lp = length (p);
 
   if (lp == 0)
     p = [];
     return;
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -34,17 +34,17 @@
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
   if (nargin < 1) || (nargin > 2) || (nargout < 0) || (nargout > 1)
     usage("polyout (c, x)");
   endif
 
-  if (! is_vector (c))
+  if (! isvector (c))
     error("polyout: first argument must be a vector");
   endif
 
   if (nargin == 1)
     x = "s";
   elseif (! isstr(x))
     error("polyout: second argument must be a string");
   endif
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -30,17 +30,17 @@
 ## Adapted-By: jwe
 
 function p = polyreduce (p)
 
   if (nargin != 1)
     usage ("polyreduce (p)");
   endif
 
-  if (! (is_vector (p) || isempty (p)))
+  if (! (isvector (p) || isempty (p)))
     error ("polyreduce: argument must be a vector");
   endif
 
   if (! isempty (p) )
 
     index = find (p != 0);
 
     if (isempty (index))
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -35,17 +35,17 @@
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
 
   if (nargin != 2)
     usage ("polyval (c, x)");
   endif
 
-  if (! (is_vector (c) || isempty (c)))
+  if (! (isvector (c) || isempty (c)))
     error ("polyval: first argument must be a vector");
   endif
 
   if (isempty (x))
     y = [];
     return;
   endif
 
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -35,30 +35,30 @@
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
     usage ("polyvalm (c, x)");
   endif
 
-  if (! (is_vector (c) || isempty (c)))
+  if (! (isvector (c) || isempty (c)))
     error ("polyvalm: first argument must be a vector");
   endif
 
-  if (! is_square (x))
+  if (! issquare (x))
     error ("polyvalm: second argument must be a square matrix");
   endif
 
   if (isempty (c))
     y = [];
     return;
   endif
 
   [v, d] = eig (x);
 
-  if (is_symmetric (x))
+  if (issymmetric (x))
     y = v * diag (polyval (c, diag (d))) * v';
   else
     y = v * (diag (polyval (c, diag (d))) / v);
   endif
 
 endfunction
diff --git a/scripts/quaternion/qtrans.m b/scripts/quaternion/qtrans.m
--- a/scripts/quaternion/qtrans.m
+++ b/scripts/quaternion/qtrans.m
@@ -23,17 +23,17 @@
 ## Returns @code{@var{v} = @var{q}*@var{v}/@var{q}}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function v = qtrans (v, q)
 
-  if (! is_vector (v) || length (v) != 4)
+  if (! isvector (v) || length (v) != 4)
     error ("qtrans: v(%d,%d) must be a quaternion", rows (v), columns (v));
-  elseif (! is_vector (q) || length (q) != 4)
+  elseif (! isvector (q) || length (q) != 4)
     error ("qtrans: q(%d,%d) must be a quaternion", rows (q), columns (q));
   endif
 
   v = qmult (q, qmult (v, qinv (q)));
 
 endfunction
diff --git a/scripts/quaternion/qtransv.m b/scripts/quaternion/qtransv.m
--- a/scripts/quaternion/qtransv.m
+++ b/scripts/quaternion/qtransv.m
@@ -31,19 +31,19 @@
 ## Where imag(q) is a column vector of length 3.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function vi = qtransv (vb, qib)
 
-  if (! is_vector (vb) || length (vb) != 3)
+  if (! isvector (vb) || length (vb) != 3)
     error ("qtransv: v(%d,%d) must be a 3-D vector", rows (vb), columns (vb));
-  elseif (! is_vector (qib) || length (qib) != 4)
+  elseif (! isvector (qib) || length (qib) != 4)
     error ("qtransv: q(%d,%d) must be a quaternion", rows (qib), columns (qib));
   elseif (max (abs (imag (vb))) + max (abs (imag (qib))) != 0)
     error ("qtransv: input values must be real");
   endif
 
   qr = qib(4);
   qimag = vec (qib(1:3));
   vb = vec (vb);
diff --git a/scripts/quaternion/qtransvmat.m b/scripts/quaternion/qtransvmat.m
--- a/scripts/quaternion/qtransvmat.m
+++ b/scripts/quaternion/qtransvmat.m
@@ -24,17 +24,17 @@
 ## @code{[@var{vv}, @var{th}] = quaternion (@var{qib})}.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Aib = qtransvmat (qib)
 
-  if (! is_vector(qib) || length (qib) != 4)
+  if (! isvector(qib) || length (qib) != 4)
     error ("qtransvmat: q(%d,%d) must be a quaternion", rows (qib), \
 	   columns (qib));
   elseif (max (abs (imag (qib))) != 0)
     error ("qtransvmat: input values must be real");
   endif
 
   Aib = [(2.*(qib(1)^2 + qib(4)^2) -1.),
 	 (2.*(qib(1)*qib(2)-qib(3)*qib(4))),
diff --git a/scripts/quaternion/quaternion.m b/scripts/quaternion/quaternion.m
--- a/scripts/quaternion/quaternion.m
+++ b/scripts/quaternion/quaternion.m
@@ -34,17 +34,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function [a, b, c, d] = quaternion (w, x, y, z)
 
   switch (nargin)
     case(1)
-      if (! (is_vector (w) && length (w) == 4))
+      if (! (isvector (w) && length (w) == 4))
 	error ("input vector must be of length 4)");
       endif
       ## extract data
       switch (nargout)
 	case(4)
 	  a = w(1);
 	  b = w(2);
 	  c = w(3);
@@ -75,19 +75,19 @@ function [a, b, c, d] = quaternion (w, x
 
   case(2)
     if (nargout != 1)
       usage ("w = quaterion (vv, theta)");
     endif
     vv = w;
     theta = x;
 
-    if (! is_vector (vv) || length (vv) != 3)
+    if (! isvector (vv) || length (vv) != 3)
       error ("vv must be a length three vector");
-    elseif (! is_scalar (theta))
+    elseif (! isscalar (theta))
       error ("theta must be a scalar");
     elseif (norm (vv) == 0)
       error ("quaternion: vv is zero");
     elseif (abs (norm (vv) - 1) > 1e-12)
       warning ("quaternion: ||vv|| != 1, normalizing")
       vv = vv / norm (vv);
     endif
 
@@ -98,17 +98,17 @@ function [a, b, c, d] = quaternion (w, x
     vv = vv * sin (theta / 2);
     d = cos (theta / 2);
     a = quaternion (vv(1), vv(2), vv(3), d);
 
   case(4)
     if (nargout != 1)
       usage ("w = quaterion (a, b, c, d)");
     endif
-    if (! (is_scalar (w) && is_scalar (x) && is_scalar (y) && is_scalar (z)))
+    if (! (isscalar (w) && isscalar (x) && isscalar (y) && isscalar (z)))
       error ("input values must be scalars");
     endif
     a = [w, x, y, z];
 
   otherwise
     usage ("[a, b, c, d] = quaternion (w) or a = quaternion (w, x, y, z)");
 
   endswitch
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -50,17 +50,17 @@
 ## Description: Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     usage ("arch_fit (y, X, p, ITER, gamma, a0, b0)");
   endif
 
-  if (! (is_vector (y)))
+  if (! (isvector (y)))
     error ("arch_test: y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -43,17 +43,17 @@ function y = arch_rnd (a, b, T)
 
   if (nargin != 3)
     usage ("arch_rnd (a, b, T)");
   endif
 
   if (! ((min (size (a)) == 1) && (min (size (b)) == 1)))
     error ("arch_rnd: a and b must both be scalars or vectors");
   endif
-  if (! (is_scalar (T) && (T > 0) && (rem (T, 1) == 0)))
+  if (! (isscalar (T) && (T > 0) && (rem (T, 1) == 0)))
     error ("arch_rnd: T must be a positive integer");
   endif
 
   if (! (a(1) > 0))
     error ("arch_rnd: a(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
 
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -67,28 +67,28 @@
 ## Description: Test for conditional heteroscedascity
 
 function [pval, lm] = arch_test (y, X, p)
 
   if (nargin != 3)
     error ("arch_test needs 3 input arguments");
   endif
 
-  if (! (is_vector (y)))
+  if (! (isvector (y)))
     error ("arch_test: y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
   elseif (! (rx == T))
     error ("arch_test: either rows(X) == length(y), or X is a scalar");
   endif
-  if (! (is_scalar(p) && (rem(p, 1) == 0) && (p > 0)))
+  if (! (isscalar(p) && (rem(p, 1) == 0) && (p > 0)))
     error ("arch_test: p must be a positive integer");
   endif
 
   [b, v_b, e] = ols (y, X);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -44,28 +44,28 @@ function x = arma_rnd (a, b, v, t, n)
 
   unwind_protect
     orig_listelemok = empty_list_elements_ok;
     empty_list_elements_ok = "true";
 
     if (nargin == 4)
       n = 100;
     elseif (nargin == 5)
-      if (!is_scalar (t))
+      if (!isscalar (t))
         error ("arma_rnd: n must be a scalar");
       endif
     else
       usage ("arma_rnd (a, b, v, t, n)");
     endif
 
     if ((min (size (a)) > 1) || (min (size (b)) > 1))
       error ("arma_rnd: a and b must not be matrices");
     endif
 
-    if (!is_scalar (t))
+    if (!isscalar (t))
       error ("arma_rnd: t must be a scalar");
     endif
 
     ar = length (a);
     br = length (b);
 
     a = reshape (a, ar, 1);
     b = reshape (b, br, 1);
diff --git a/scripts/signal/autocov.m b/scripts/signal/autocov.m
--- a/scripts/signal/autocov.m
+++ b/scripts/signal/autocov.m
@@ -27,17 +27,17 @@
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute autocovariances
 
 function retval = autocov (X, h)
 
   [n, c] = size (X);
 
-  if (is_vector (X))
+  if (isvector (X))
     n = length (X);
     c = 1;
     X = reshape (X, n, 1);
   endif
 
   X = center (X);
 
   if (nargin == 1)
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -31,17 +31,17 @@
 ## Description: Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
     usage ("autoreg_matrix (y, k)");
   endif
 
-  if (! (is_vector (y)))
+  if (! (isvector (y)))
     error ("autoreg_matrix: y must be a vector");
   endif
 
   T = length (y);
   y = reshape (y, T, 1);
   X = ones (T, k+1);
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -30,17 +30,17 @@
 ## Description: Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
 
   if (nargin != 1)
     usage ("bartlett (m)");
   endif
 
-  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+  if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("bartlett: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     n = fix (m / 2);
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -29,17 +29,17 @@
 ## Description: Coefficients of the Blackman window
 
 function c = blackman (m)
 
   if (nargin != 1)
     usage ("blackman (m)");
   endif
 
-  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+  if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("blackman: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     k = (0 : m)' / m;
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -33,17 +33,17 @@
 ## Created: 11 October 1994
 ## Adapted-By: jwe
 
 function y = detrend (x, p)
 
   if (nargin == 1)
     p = 1;
   elseif (nargin == 2)
-    if (! (is_scalar (p) && p == round (p) && p >= 0))
+    if (! (isscalar (p) && p == round (p) && p >= 0))
       error ("detrend: p must be a nonnegative integer");
     endif
   else
     usage ("detrend (x, p)");
   endif
 
   [m, n] = size (x);
   if (m == 1)
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -40,33 +40,33 @@
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the fractional differencing parameter
 
 function [d, D] = diffpara (X, a, b)
 
   if ((nargin < 1) || (nargin > 3))
     usage ("[d, D] = diffpara (X, a, b)");
   else
-    if (is_vector (X))
+    if (isvector (X))
       n = length (X);
       k = 1;
       X = reshape (X, n, 1);
     else
       [n, k] = size(X);
     endif
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
   endif
 
-  if (! (is_scalar (a) && is_scalar (b)))
+  if (! (isscalar (a) && isscalar (b)))
     error ("diffpara: a and b must be scalars");
   endif
 
   D = zeros (b - a + 1, k);
 
   for l = 1:k
 
     w = 2 * pi * (1 : n-1) / n;
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -33,30 +33,30 @@
 ## Adapted-By: jwe
 
 function c = fftconv (a, b, N)
 
   if (nargin < 2 || nargin > 3)
     usage ("fftconv (b, x, N)");
   endif
 
-  if (! (is_vector (a) && is_vector (b)))
+  if (! (isvector (a) && isvector (b)))
     error ("fftconv: both a and b should be vectors");
   endif
   la = length (a);
   lb = length (b);
   if ((la == 1) || (lb == 1))
     c = a * b;
   else
     lc = la + lb - 1;
     a(lc) = 0;
     b(lc) = 0;
     if (nargin == 2)
       c = fftfilt (a, b);
     else
-      if (! (is_scalar (N)))
+      if (! (isscalar (N)))
         error ("fftconv: N has to be a scalar");
       endif
       c = fftfilt (a, b, N);
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -64,17 +64,17 @@ function y = fftfilt (b, x, N)
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
     N = 2 ^ (ceil (log (r_x + l_b - 1) / log (2)));
     B = fft (b, N);
     y = ifft (fft (x, N) .* B(:,ones (1, c_x)));
   else
     ## Use overlap-add method ...
-    if (! (is_scalar (N)))
+    if (! (isscalar (N)))
       error ("fftfilt: N has to be a scalar");
     endif
     N = 2 ^ (ceil (log (max ([N, l_b])) / log (2)));
     L = N - l_b + 1;
     B = fft (b, N);
     B = B(:,ones (c_x,1));
     R = ceil (r_x / L);
     y = zeros (r_x, c_x);
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -41,21 +41,21 @@
 function retval = fftshift (V)
 
   retval = 0;
 
   if (nargin != 1)
     usage ("usage: fftshift (X)");
   endif
 
-  if (is_vector (V))
+  if (isvector (V))
     x = length (V);
     xx = ceil (x/2);
     retval = V([xx+1:x, 1:xx]);
-  elseif (is_matrix (V))
+  elseif (ismatrix (V))
     [x, y] = size (V);
     xx = ceil (x/2);
     yy = ceil (y/2);
     retval = V([xx+1:x, 1:xx], [yy+1:y, 1:yy]);
   else
     error ("fftshift: expecting vector or matrix argument");
   endif
 
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -25,21 +25,21 @@
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute fractional differences
 
 function retval = fractdiff (x, d)
 
   N = 100;
 
-  if (! is_vector (x))
+  if (! isvector (x))
     error ("fractdiff: x must be a vector")
   endif
 
-  if (! is_scalar (d))
+  if (! isscalar (d))
     error ("fractdiff: d must be a scalar")
   endif
 
 
   if (d >= 1)
     for k = 1 : d
       x = x(2 : length (x)) - x(1 : length (x) - 1);
     endfor
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -112,17 +112,17 @@ function [h_r, w_r] = freqz (b, a, n, re
   endif
 
   la = length (a);
   a = reshape (a, 1, la);
   lb = length (b);
   b = reshape (b, 1, lb);
   k = max ([la, lb]);
 
-  if (! is_scalar (n))
+  if (! isscalar (n))
     if (nargin == 4) ## Fs was specified
       w = 2*pi*n/Fs;
     else
       w = n;
     endif
     n = length (n);
     extent = 0;
   elseif (strcmp (region, "whole"))
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -29,17 +29,17 @@
 ## Description: Coefficients of the Hamming window
 
 function c = hamming (m)
 
   if (nargin != 1)
     usage ("hamming (m)");
   endif
 
-  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+  if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("hamming: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -29,17 +29,17 @@
 ## Description: Coefficients of the Hanning window
 
 function c = hanning (m)
 
   if (nargin != 1)
     usage ("hanning (m)");
   endif
 
-  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+  if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("hanning: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -28,19 +28,19 @@
 ## Description: Estimate the Hurst parameter
 
 function H = hurst (x)
 
   if (nargin != 1)
     usage ("hurst (x)");
   endif
 
-  if (is_scalar (x))
+  if (isscalar (x))
     error ("hurst: x must not be a scalar")
-  elseif (is_vector (x))
+  elseif (isvector (x))
     x = reshape (x, length (x), 1);
   end
 
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
   RS = (max(w) - min(w)) ./ s;
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -40,21 +40,21 @@ function retval = sinetone (f, r, s, a)
     a = 64;
   elseif (nargin == 3)
     a = 64;
   elseif ((nargin < 1) || (nargin > 4))
     usage ("sinetone (freq, rate, sec, ampl)");
   endif
 
   [err, f, a] = common_size (f, a);
-  if (err || ! is_vector (f))
+  if (err || ! isvector (f))
     error ("sinetone: freq and ampl must be vectors of common size");
   endif
 
-  if (! (is_scalar (r) && is_scalar (s)))
+  if (! (isscalar (r) && isscalar (s)))
     error ("sinetone: rate and sec must be scalars");
   endif
 
   n = length (f);
 
   retval = zeros (r * s, n);
   for k = 1:n
     retval (:, k) = a(k) * sin (2 * pi * (1:r*s) / r * f(k))';
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -32,17 +32,17 @@ function retval = spencer (X)
     usage ("spencer (X)");
   endif
 
   [xr, xc] = size(X);
 
   n = xr;
   c = xc;
 
-  if (is_vector(X))
+  if (isvector(X))
    n = length(X);
    c = 1;
    X = reshape(X, n, 1);
   endif
 
   W = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
 
   retval = fftfilt (W, X);
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -34,17 +34,17 @@
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
     usage ("sylvester_matrix (n)");
   endif
 
-  if (is_scalar (k))
+  if (isscalar (k))
     if (k < 1)
       retval = 1;
     else
       tmp = sylvester_matrix (k-1);
       retval = [tmp, tmp; tmp, -tmp];
     endif
   else
     error ("sylvester_matrix: expecting scalar argument");
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -52,17 +52,17 @@
 ## Author: jwe
 
 function retval = vander (c)
 
   if (nargin != 1)
     usage ("vander (c)");
   endif
 
-  if (is_vector (c))
+  if (isvector (c))
     n = length (c);
     retval = zeros (n, n);
     j = 1:n;
     for i = 1:n
       retval(i,:) = c(i) .^ (n - j);
     endfor
   else
     error ("vander: argument must be a vector");
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -27,19 +27,19 @@
 ## Description: Center by subtracting means
 
 function retval = center (x)
 
   if (nargin != 1)
     usage ("center (x)");
   endif
 
-  if (is_vector (x))
+  if (isvector (x))
     retval = x - mean (x);
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     retval = x - ones (rows (x), 1) * mean (x);
   elseif (isempty (x))
     retval = x;
   else
     error ("center: x must be a vector or a matrix");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/cut.m b/scripts/statistics/base/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/statistics/base/cut.m
@@ -36,23 +36,23 @@
 ## Description: Cut data into intervals
 
 function group = cut (X, BREAKS)
 
   if (nargin != 2)
     usage ("cut (X, BREAKS)");
   endif
 
-  if (! is_vector (X))
+  if (! isvector (X))
     error ("cut: X must be a vector");
   endif
-  if is_scalar (BREAKS)
+  if isscalar (BREAKS)
     BREAKS = linspace (min (X), max (X), BREAKS + 1);
     BREAKS(1) = BREAKS(1) - 1;
-  elseif is_vector (BREAKS)
+  elseif isvector (BREAKS)
     BREAKS = sort (BREAKS);
   else
     error ("cut: BREAKS must be a scalar or vector");
   endif
 
   group = NaN * ones (size (X));
   m = length (BREAKS);
   if any (k = find ((X >= min (BREAKS)) & (X <= max (BREAKS))))
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -44,24 +44,24 @@
 ## Adapted-By: jwe
 
 function retval = kurtosis (x)
 
   if (nargin != 1)
     usage ("kurtosis (x)");
   endif
 
-  if (is_vector (x))
+  if (isvector (x))
     x = x - mean (x);
     if (! any (x))
       retval = 0;
     else
       retval = sum (x .^ 4) / (length (x) * std (x) ^ 4) - 3;
     endif
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     [nr, nc] = size (x);
     x = x - ones (nr, 1) * mean (x);
     retval = zeros (1, nc);
     s      = std (x);
     ind    = find (s > 0);
     retval (ind) = sum (x (:, ind) .^ 4) ./ (nr * s (ind) .^ 4) - 3;
   else
     error ("kurtosis: x has to be a matrix or a vector");
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -44,17 +44,17 @@
 ## Description: Perform a PP-plot (probability plot)
 
 function [p, y] = ppplot (x, dist, varargin)
 
   if (nargin < 1)
     usage ("ppplot (x, dist, params)");
   endif
 
-  if (! is_vector (x))
+  if (! isvector (x))
     error ("ppplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
   p = ((1 : n)' - 0.5) / n;
   if (nargin == 1)
     F = "stdnormal_cdf";
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -46,17 +46,17 @@
 ## Description: Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, varargin)
 
   if (nargin < 1)
     usage ("qqplot (x, dist, params)");
   endif
 
-  if (! (is_vector(x)))
+  if (! (isvector(x)))
     error ("qqplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
   t = ((1 : n)' - .5) / n;
   if (nargin == 1)
     f = "stdnormal_inv";
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -44,24 +44,24 @@
 ## Adapted-By: jwe
 
 function retval = skewness (x)
 
   if (nargin != 1)
     usage ("skewness (x)");
   endif
 
-  if (is_vector (x))
+  if (isvector (x))
     x = x - mean (x);
     if (! any (x))
       retval = 0;
     else
       retval = sum (x .^ 3) / (length (x) * std (x) ^ 3);
     endif
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     [nr, nc] = size (x);
     x = x - ones (nr, 1) * mean (x);
     retval = zeros (1, nc);
     s      = std (x);
     ind    = find (s > 0);
     retval (ind) = sum (x (:, ind) .^ 3) ./ (nr * s (ind) .^ 3);
   else
     error ("skewness: x has to be a matrix or a vector");
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -31,17 +31,17 @@
 
 function S = statistics (X)
 
   if (nargin != 1)
     usage ("S = statistics (X)");
   endif
 
   if (prod (size (X)) > 1)
-    if (is_vector (X))
+    if (isvector (X))
       X = reshape (X, length (X), 1);
     endif
     for k=1:columns(X)
       S(:,k) = [(min (X(:,k)));
                 (empirical_inv ([0.25;0.5;0.75], X(:,k)));
                 (max (X(:,k)));
                 (mean (X(:,k)));
                 (std (X(:,k)));
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -29,23 +29,23 @@
 ## Description: Subtract mean and divide by standard deviation
 
 function t = studentize (x)
 
   if (nargin != 1)
     usage ("studentize (x)");
   endif
 
-  if is_vector (x)
+  if isvector (x)
     if (std (x) == 0)
       t = zeros (size (x));
     else
       t = (x - mean (x)) / std (x);
     endif
-  elseif is_matrix (x)
+  elseif ismatrix (x)
     l = ones (rows (x), 1);
     t = x - l * mean (x);
     t = t ./ (l * max ([(std (t)); (! any (t))]));
   else
     error ("studentize: x must be a vector or a matrix");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -27,25 +27,25 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Cross tabulation
 
 function [t, v, w] = table (x, y)
 
   if (nargin == 1)
-    if (! (is_vector (x)))
+    if (! (isvector (x)))
       error ("table: x must be a vector");
     endif
     v = values (x);
     for i = 1 : length (v)
       t(i) = sum (x == v(i) | isnan (v(i)) * isnan (x));
     endfor
   elseif (nargin == 2)
-    if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
+    if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
       error ("table: x and y must be vectors of the same length");
     endif
     v = values (x);
     w = values (y);
     for i = 1 : length (v)
       for j = 1 : length (w)
         t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
                       (y == w(j) | isnan (w(j)) * isnan (y)));
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -27,17 +27,17 @@
 ## Description: Extract unique elements
 
 function v = values (x)
 
   if (nargin != 1)
     usage ("values (x)");
   endif
 
-  if (! (is_vector (x)))
+  if (! (isvector (x)))
     error ("values: x must be a vector");
   endif
 
   i = any (isnan (x));
   x = x(find(!isnan (x)));      # HACK!
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
diff --git a/scripts/statistics/distributions/beta_rnd.m b/scripts/statistics/distributions/beta_rnd.m
--- a/scripts/statistics/distributions/beta_rnd.m
+++ b/scripts/statistics/distributions/beta_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Beta distribution
 
 function rnd = beta_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("beta_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("beta_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("beta_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/binomial_rnd.m b/scripts/statistics/distributions/binomial_rnd.m
--- a/scripts/statistics/distributions/binomial_rnd.m
+++ b/scripts/statistics/distributions/binomial_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binomial_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("binomial_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("binomial_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error ("binomial_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (l, scale, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("cauchy_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("cauchy_rnd: c must be a positive integer");
     endif
     [retval, l, scale] = common_size (l, scale, zeros (r, c));
     if (retval > 0)
       error ("cauchy_rnd: lambda and sigma must be scalar or of size %d by %d",
 	     r, c); 
     endif
   elseif (nargin == 2)
diff --git a/scripts/statistics/distributions/chisquare_rnd.m b/scripts/statistics/distributions/chisquare_rnd.m
--- a/scripts/statistics/distributions/chisquare_rnd.m
+++ b/scripts/statistics/distributions/chisquare_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the chi-square distribution
 
 function rnd = chisquare_rnd (n, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("chisquare_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("chisquare_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error ("chisquare_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("chisquare_rnd (n, r, c)");
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -30,19 +30,19 @@
 function cdf = discrete_cdf (x, v, p)
 
   if (nargin != 3)
     usage ("discrete_cdf (x, v, p)");
   endif
 
   [r, c] = size (x);
 
-  if (! is_vector (v))
+  if (! isvector (v))
     error ("discrete_cdf: v must be a vector");
-  elseif (! is_vector (p) || (length (p) != length (v)))
+  elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_cdf: p must be a vector with length (v) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_cdf: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
   m = length (v);
   x = reshape (x, n, 1);
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -30,19 +30,19 @@
 function inv = discrete_inv (x, v, p)
 
   if (nargin != 3)
     usage ("discrete_inv (x, v, p)");
   endif
 
   [r, c] = size (x);
 
-  if (! is_vector (v))
+  if (! isvector (v))
     error ("discrete_inv: v must be a vector");
-  elseif (! is_vector (p) || (length (p) != length (v)))
+  elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_inv: p must be a vector with length (v) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_inv: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
   x = reshape (x, 1, n);
   m = length (v);
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -30,19 +30,19 @@
 function pdf = discrete_pdf (x, v, p)
 
   if (nargin != 3)
     usage ("discrete_pdf (x, v, p)");
   endif
 
   [r, c] = size (x);
 
-  if (! is_vector (v))
+  if (! isvector (v))
     error ("discrete_pdf: v must be a vector");
-  elseif (! is_vector (p) || (length (p) != length (v)))
+  elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_pdf: p must be a vector with length (v) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_pdf: p must be a nonzero, nonnegative vector");
   endif
 
   n = r * c;
   m = length (v);
   x = reshape (x, n, 1);
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -30,23 +30,23 @@
 ## Description: Random deviates from a discrete distribution
 
 function rnd = discrete_rnd (n, v, p)
 
   if (nargin != 3)
     usage ("discrete_rnd (n, v, p)");
   endif
 
-  if (! is_scalar (n))
+  if (! isscalar (n))
     error ("discrete_rnd: n must be a scalar");
   endif
 
-  if (! is_vector (v))
+  if (! isvector (v))
     error ("discrete_rnd: v must be a vector");
-  elseif (! is_vector (p) || (length (p) != length (v)))
+  elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_rnd: p must be a vector with length (v) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_rnd: p must be a nonzero, nonnegative vector");
   endif
 
   u = rand (1, n);
   m = length (p);
   s = reshape (cumsum (p / sum (p)), m, 1);
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -24,15 +24,15 @@
 ## the univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: CDF of the empirical distribution
 
 function cdf = empirical_cdf (x, data)
 
-  if (! is_vector (data))
+  if (! isvector (data))
     error ("empirical_cdf: data must be a vector");
   endif
 
   cdf = discrete_cdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -24,15 +24,15 @@
 ## univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Quantile function of the empirical distribution
 
 function inv = empirical_inv (x, data)
 
-  if (! is_vector (data))
+  if (! isvector (data))
     error ("empirical_inv: data must be a vector");
   endif
 
   inv = discrete_inv (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -24,15 +24,15 @@
 ## univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: PDF of the empirical distribution
 
 function pdf = empirical_pdf (x, data)
 
-  if (! is_vector (data))
+  if (! isvector (data))
     error ("empirical_pdf: data must be a vector");
   endif
 
   pdf = discrete_pdf (x, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -23,15 +23,15 @@
 ## distribution obtained from the univariate sample @var{data}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Bootstrap samples from the empirical distribution
 
 function rnd = empirical_rnd (n, data)
 
-  if (! is_vector (data))
+  if (! isvector (data))
     error ("empirical_rnd: data must be a vector");
   endif
 
   rnd = discrete_rnd (n, data, ones (size (data)) / length (data));
 
 endfunction
diff --git a/scripts/statistics/distributions/exponential_rnd.m b/scripts/statistics/distributions/exponential_rnd.m
--- a/scripts/statistics/distributions/exponential_rnd.m
+++ b/scripts/statistics/distributions/exponential_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the exponential distribution
 
 function rnd = exponential_rnd (l, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("exponential_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("exponential_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error ("exponential_rnd: lambda must be scalar or of size %d by %d",
 	     r, c);
     endif
   elseif (nargin != 1)
diff --git a/scripts/statistics/distributions/f_rnd.m b/scripts/statistics/distributions/f_rnd.m
--- a/scripts/statistics/distributions/f_rnd.m
+++ b/scripts/statistics/distributions/f_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the F distribution
 
 function rnd = f_rnd (m, n, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("f_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("f_rnd: c must be a positive integer");
     endif
     [retval, m, n] = common_size (m, n, zeros (r, c));
     if (retval > 0)
       error ("f_rnd: m and n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, n] = common_size (m, n);
diff --git a/scripts/statistics/distributions/gamma_rnd.m b/scripts/statistics/distributions/gamma_rnd.m
--- a/scripts/statistics/distributions/gamma_rnd.m
+++ b/scripts/statistics/distributions/gamma_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamma_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("gamma_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("gamma_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("gamma_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/geometric_rnd.m b/scripts/statistics/distributions/geometric_rnd.m
--- a/scripts/statistics/distributions/geometric_rnd.m
+++ b/scripts/statistics/distributions/geometric_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 function rnd = geometric_rnd (p, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("geometric_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("geometric_rnd: c must be a positive integer");
     endif
     [retval, p] = common_size (p, zeros (r, c));
     if (retval > 0)
       error ("geometric_rnd: p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("geometric_rnd (p, r, c)");
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -47,17 +47,17 @@ function cdf = kolmogorov_smirnov_cdf (x
 
   if (nargin < 1 || nargin > 2)
     usage ("kolmogorov_smirnov_cdf (x, tol)");
   endif
 
   if (nargin == 1)
     tol = eps;
   else
-    if (! is_scalar (tol) || ! (tol > 0))
+    if (! isscalar (tol) || ! (tol > 0))
       error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
     endif
   endif
 
   [nr, nc] = size (x);
   if (min (nr, nc) == 0)
     error ("kolmogorov_smirnov_cdf: x must not be empty");
   endif
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -27,20 +27,20 @@
 ## Description: Random deviates from the Laplace distribution
 
 function rnd = laplace_rnd (r, c)
 
   if (nargin != 2)
     usage ("laplace_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+  if (! (isscalar (r) && (r > 0) && (r == round (r))))
     error ("laplace_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+  if (! (isscalar (c) && (c > 0) && (c == round (c))))
     error ("laplace_rnd: c must be a positive integer");
   endif
 
   tmp = rand (r, c);
   rnd = ((tmp < 1/2) .* log (2 * tmp)
          - (tmp > 1/2) .* log (2 * (1 - tmp)));
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -27,18 +27,18 @@
 ## Description: Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
 
   if (nargin != 2)
     usage ("logistic_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+  if (! (isscalar (r) && (r > 0) && (r == round (r))))
     error ("logistic_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+  if (! (isscalar (c) && (c > 0) && (c == round (c))))
     error ("logistic_rnd: c must be a positive integer");
   endif
 
   rnd = - log (1 ./ rand (r, c) - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_rnd.m b/scripts/statistics/distributions/lognormal_rnd.m
--- a/scripts/statistics/distributions/lognormal_rnd.m
+++ b/scripts/statistics/distributions/lognormal_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognormal_rnd (a, v, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("lognormal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("lognormal_rnd: c must be a positive integer");
     endif
     [retval, a, v] = common_size (a, v, zeros (r, c));
     if (retval > 0)
       error ("lognormal_rnd: a and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, v] = common_size (a, v);
diff --git a/scripts/statistics/distributions/normal_rnd.m b/scripts/statistics/distributions/normal_rnd.m
--- a/scripts/statistics/distributions/normal_rnd.m
+++ b/scripts/statistics/distributions/normal_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the normal distribution
 
 function rnd = normal_rnd (m, v, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("normal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("normal_rnd: c must be a positive integer");
     endif
     [retval, m, v] = common_size (m, v, zeros (r, c));
     if (retval > 0)
       error ("normal_rnd: m and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, v] = common_size (m, v);
diff --git a/scripts/statistics/distributions/pascal_rnd.m b/scripts/statistics/distributions/pascal_rnd.m
--- a/scripts/statistics/distributions/pascal_rnd.m
+++ b/scripts/statistics/distributions/pascal_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = pascal_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("pascal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("pascal_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error ("pascal_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
diff --git a/scripts/statistics/distributions/poisson_rnd.m b/scripts/statistics/distributions/poisson_rnd.m
--- a/scripts/statistics/distributions/poisson_rnd.m
+++ b/scripts/statistics/distributions/poisson_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Poisson distribution
 
 function rnd = poisson_rnd (l, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("poisson_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("poisson_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error ("poisson_rnd: lambda must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("poisson_rnd (lambda, r, c)");
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -27,18 +27,18 @@
 ## Description: Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
 
   if (nargin != 2)
     usage ("stdnormal_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+  if (! (isscalar (r) && (r > 0) && (r == round (r))))
     error ("stdnormal_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+  if (! (isscalar (c) && (c > 0) && (c == round (c))))
     error ("stdnormal_rnd: c must be a positive integer");
   endif
 
   rnd = randn (r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_rnd.m b/scripts/statistics/distributions/t_rnd.m
--- a/scripts/statistics/distributions/t_rnd.m
+++ b/scripts/statistics/distributions/t_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the t distribution
 
 function rnd = t_rnd (n, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("t_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("t_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error ("t_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("t_rnd (n, r, c)");
diff --git a/scripts/statistics/distributions/uniform_rnd.m b/scripts/statistics/distributions/uniform_rnd.m
--- a/scripts/statistics/distributions/uniform_rnd.m
+++ b/scripts/statistics/distributions/uniform_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the uniform distribution
 
 function rnd = uniform_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("uniform_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("uniform_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("uniform_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/weibull_rnd.m b/scripts/statistics/distributions/weibull_rnd.m
--- a/scripts/statistics/distributions/weibull_rnd.m
+++ b/scripts/statistics/distributions/weibull_rnd.m
@@ -28,20 +28,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = weibull_rnd (shape, scale, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
+    if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("weibull_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
+    if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("weibull_rnd: c must be a positive integer");
     endif
     [retval, shape, scale] = common_size (shape, scale, zeros (r, c));
     if (retval > 0)
       error ("weibull_rnd: alpha and sigma must be scalar or of size %d by %d",
 	     r, c);
     endif
   elseif (nargin == 2)
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -45,28 +45,28 @@
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
     usage ("anova (y, g)");
   elseif (nargin == 1)
-    if (is_vector (y))
+    if (isvector (y))
       error ("anova: for `anova (y)', y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
-    if (! is_vector (y))
+    if (! isvector (y))
       error ("anova: for `anova (y, g)', y must be a vector");
     endif
     n = length (y);
-    if (! is_vector (g) || (length (g) != n))
+    if (! isvector (g) || (length (g) != n))
       error ("anova: g must be a vector of the same length as y");
     endif
     s = sort (g);
     i = find (s (2 : n) > s(1 : (n-1)));
     k = length (i) + 1;
     if (k == 1)
       error ("anova: there should be at least 2 groups");
     else
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -42,17 +42,17 @@ function [pval, chisq, df] = bartlett_te
     usage ("[pval, chisq, df] = bartlett_test (x1, ...)");
   endif
 
   f = zeros (k, 1);
   v = zeros (k, 1);
 
   for i = 1 : k;
     x = varargin{i};
-    if (! is_vector (x))
+    if (! isvector (x))
       error ("bartlett_test: all arguments must be vectors");
     endif
     f(i) = length (x) - 1;
     v(i) = var (x);
   endfor
 
   f_tot = sum (f);
   v_tot = sum (f .* v) / f_tot;
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -38,17 +38,17 @@
 ## Description: Chi-square test for homogeneity
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 
   if (nargin != 3)
     usage ("[pval, chisq, df] = chisquare_test_homogeneity (x, y, c)");
   endif
 
-  if (! (is_vector(x) && is_vector(y) && is_vector(c)))
+  if (! (isvector(x) && isvector(y) && isvector(c)))
     error ("chisquare_test_homogeneity: x, y and c must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
     error ("chisquare_test_homogeneity: c must be increasing");
   endif
 
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -62,17 +62,17 @@
 ## Description: Test for zero correlation
 
 function t = cor_test (X, Y, ALTERNATIVE, METHOD)
 
   if ((nargin < 2) || (nargin > 4))
     usage ("cor_test (X, Y, ALTERNATIVE, METHOD)")
   endif
 
-  if (!is_vector (X) || !is_vector (Y) || length (X) != length (Y))
+  if (!isvector (X) || !isvector (Y) || length (X) != length (Y))
     error ("cor_test: X and Y must be vectors of the same length")
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
   elseif (! isstr (ALTERNATIVE))
     error ("cor_test: ALTERNATIVE must be a string");
   endif
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -38,17 +38,17 @@
 
 function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
 
   if (nargin < 3 || nargin > 4)
     usage ("[pval, f, df_num, df_den] = f_test_regression (y, X, R, r)");
   endif
 
   [T, k] = size (X);
-  if (! (is_vector (y) && (length (y) == T)))
+  if (! (isvector (y) && (length (y) == T)))
     error ("f_test_regression: y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
   [q, c_R ] = size (R);
   if (c_R != k)
     error ("f_test_regression: R must have as many columns as X");
   endif
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -37,28 +37,28 @@
 ## Description: Test for mean of a multivariate normal
 
 function [pval, Tsq] = hotelling_test (x, m)
 
   if (nargin != 2)
     usage ("hotelling_test (x, m)");
   endif
 
-  if (is_vector (x))
-    if (! is_scalar (m))
+  if (isvector (x))
+    if (! isscalar (m))
       error ("hotelling_test: if x is a vector, m must be a scalar");
     endif
     n = length (x);
     p = 1;
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     [n, p] = size (x);
     if (n <= p)
       error ("hotelling_test: x must have more rows than columns");
     endif
-    if (is_vector (m) && length (m) == p)
+    if (isvector (m) && length (m) == p)
       m = reshape (m, 1, p);
     else
       error ("hotelling_test: if x is a matrix, m must be a vector of length columns (x)");
     endif
   else
     error ("hotelling_test: x must be a matrix or vector");
   endif
 
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -44,25 +44,25 @@
 ## Description: Compare means of two multivariate normals
 
 function [pval, Tsq] = hotelling_test_2 (x, y)
 
   if (nargin != 2)
     usage ("hotelling_test_2 (x, y)");
   endif
 
-  if (is_vector (x))
+  if (isvector (x))
     n_x = length (x);
-    if (! is_vector (y))
+    if (! isvector (y))
       error ("hotelling_test_2: if x is a vector, y must also be a vector");
     else
       n_y = length (y);
       p   = 1;
     endif
-  elseif (is_matrix (x))
+  elseif (ismatrix (x))
     [n_x, p] = size (x);
     [n_y, q] = size (y);
     if (p != q)
       error ("hotelling_test_2: x and y must have the same number of columns");
     endif
   else
     error ("hotelling_test_2: x and y must be matrices (or vectors)");
   endif
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -51,17 +51,17 @@
 ## Description: One-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, varargin)
 
   if (nargin < 2)
     usage ("[pval, ks] = kolmogorov_smirnov_test (x, dist,, params, alt)");
   endif
 
-  if (! is_vector (x))
+  if (! isvector (x))
     error ("kolmogorov_smirnov_test: x must be a vector");
   endif
 
   n = length (x);
   s = sort (x);
   f = sprintf ("%s_cdf", dist);
 
   alt  = "!=";
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -47,17 +47,17 @@
 ## Description: Two-sample Kolmogorov-Smirnov test
 
 function [pval, ks, d] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
     usage ("[pval, ks] = kolmogorov_smirnov_test_2 (x, y, tol)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error ("kolmogorov_smirnov_test_2: both x and y must be vectors");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
     if (! isstr (alt))
       error ("kolmogorov_smirnov_test_2: alt must be a string");
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -45,17 +45,17 @@ function [pval, k, df] = kruskal_wallis_
     usage ("[pval, k, df] = kruskal_wallis_test (x1, ...)");
   endif
 
   n = [];
   p = [];
 
   for i = 1 : m;
     x = varargin{i};
-    if (! is_vector (x))
+    if (! isvector (x))
       error ("kruskal_wallis_test: all arguments must be vectors");
     endif
     l = length (x);
     n = [n, l];
     p = [p, (reshape (x, 1, l))];
   endfor
 
   r = ranks (p);
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -42,23 +42,23 @@
 ## Description: One-way multivariate analysis of variance (MANOVA)
 
 function manova (Y, g)
 
   if (nargin != 2)
     usage ("manova (Y, g)");
   endif
 
-  if (is_vector (Y))
+  if (isvector (Y))
     error ("manova: Y must not be a vector");
   endif
 
   [n, p] = size (Y);
 
-  if (!is_vector (g) || (length (g) != n))
+  if (!isvector (g) || (length (g) != n))
     error ("manova: g must be a vector of length rows (Y)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
 
   if (k == 1)
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -36,17 +36,17 @@
 ## Description: McNemar's test for symmetry
 
 function [pval, chisq, df] = mcnemar_test (x)
 
   if (nargin != 1)
     usage ("mcnemar_test (x)");
   endif
 
-  if (! (min (size (x)) > 1) && is_square (x))
+  if (! (min (size (x)) > 1) && issquare (x))
     error ("mcnemar_test: x must be a square matrix of size > 1");
   elseif (! (all (all (x >= 0)) && all (all (x == round (x)))))
     error ("mcnemar_test: all entries of x must be nonnegative integers");
   endif
 
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -44,17 +44,17 @@
 ## Description: Sign test
 
 function [pval, b, n] = sign_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, b, n] = sign_test (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
+  if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("sign_test: x and y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
   y   = reshape (y, 1, n);
   n   = sum (x != y);
   b   = sum (x > y);
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -43,20 +43,20 @@
 ## Description: Student's one-sample t test
 
 function [pval, t, df] = t_test (x, m, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, t, df] = t_test (x, m, alt)");
   endif
 
-  if (! is_vector (x))
+  if (! isvector (x))
     error ("t_test: x must be a vector");
   endif
-  if (! is_scalar (m))
+  if (! isscalar (m))
     error ("t_test: m must be a scalar");
   endif
 
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = t_cdf (t, df);
 
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -43,17 +43,17 @@
 ## Description: Student's two-sample t test
 
 function [pval, t, df] = t_test_2 (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
         usage ("[pval, t, df] = t_test_2 (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error ("t_test_2: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   df   = n_x + n_y - 2;
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -53,24 +53,24 @@ function [pval, t, df] = t_test_regressi
       r   = 0;
     else
       alt = "!=";
     endif
   elseif (! (nargin == 5))
     usage ("[pval, t, df] = t_test_regression (y, X, R, r, alt)");
   endif
 
-  if (! is_scalar (r))
+  if (! isscalar (r))
     error ("t_test_regression: r must be a scalar");
   elseif (! isstr (alt))
     error ("t_test_regression: alt must be a string");
   endif
 
   [T, k] = size (X);
-  if (! (is_vector (y) && (length (y) == T)))
+  if (! (isvector (y) && (length (y) == T)))
     error ("t_test_regression: y must be a vector of length rows (X)");
   endif
   s      = size (R);
   if (! ((max (s) == k) && (min (s) == 1)))
     error ("t_test_regression: R must be a vector of length columns (X)");
   endif
 
   R      = reshape (R, 1, k);
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -45,17 +45,17 @@
 ## Description: Mann-Whitney U-test
 
 function [pval, z] = u_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, z] = u_test (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error ("u_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   r    = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
   z    = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
            / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -42,17 +42,17 @@
 ## Description: F test to compare two variances
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, f, df_num, df_den] = var_test (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error ("var_test: both x and y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = f_cdf (f, df_num, df_den);
 
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -42,17 +42,17 @@
 ## Description: Welch two-sample t test
 
 function [pval, t, df] = welch_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, t, df] = welch_test (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error ("welch_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -41,17 +41,17 @@
 ## Description: Wilcoxon signed-rank test
 
 function [pval, z] = wilcoxon_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, z] = wilcoxon_test (x, y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
+  if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("wilcoxon_test: x and y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
   y = reshape (y, 1, n);
   d = x - y;
   d = d (find (d != 0));
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -43,23 +43,23 @@
 ## Description: Test for mean of a normal sample with known variance
 
 function [pval, z] = z_test (x, m, v, alt)
 
   if ((nargin < 3) || (nargin > 4))
     usage ("[pval, z] = z_test (x, m, v, alt)");
   endif
 
-  if (! is_vector (x))
+  if (! isvector (x))
     error ("z_test: x must be a vector");
   endif
-  if (! is_scalar (m))
+  if (! isscalar (m))
     error ("z_test: m must be a scalar");
   endif
-  if (! (is_scalar (v) && (v > 0)))
+  if (! (isscalar (v) && (v > 0)))
     error ("z_test: v must be a positive scalar");
   endif
 
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
 
   if (nargin == 3)
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -43,20 +43,20 @@
 ## Description: Compare means of two normal samples with known variances
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
   if ((nargin < 4) || (nargin > 5))
     usage ("[pval, z] = z_test_2 (x, y, v_x, v_y, alt)");
   endif
 
-  if (! (is_vector (x) && is_vector (y)))
+  if (! (isvector (x) && isvector (y)))
     error("z_test_2: both x and y must be vectors");
-  elseif (! (is_scalar (v_x) && (v_x > 0)
-             && is_scalar (v_y) && (v_y > 0)))
+  elseif (! (isscalar (v_x) && (v_x > 0)
+             && isscalar (v_y) && (v_y > 0)))
     error ("z_test_2: both v_x and v_y must be positive scalars");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -55,17 +55,17 @@ function out = base2dec (d, base)
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   if (isstr (base))
     symbols = base;
     base = length (symbols);
     if (any (diff (sort (toascii (symbols))) == 0))
       error ("base2dec: symbols representing digits must be unique.");
     endif
-  elseif (! is_scalar (base))
+  elseif (! isscalar (base))
     error ("base2dec: cannot convert from several bases at once.");
   elseif (base < 2 || base > length (symbols))
     error ("base2dec: base must be between 2 and 36 or a string of symbols");
   else
     d = toupper (d);
   endif
 
   ## Right justify the values before anything else.
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -26,15 +26,15 @@
 ## Adapted-By: jwe
 
 function s = blanks (n)
 
   if (nargin != 1)
     usage ("blanks (n)");
   endif
 
-  if (is_scalar (n) && n == round (n) && (treat_neg_dim_as_zero || n >= 0))
+  if (isscalar (n) && n == round (n) && (treat_neg_dim_as_zero || n >= 0))
     s = setstr (ones (1, n) * toascii (" "));
   else
     error ("blanks: n must be a non-negative integer");
   endif
 
 endfunction
diff --git a/scripts/strings/com2str.m b/scripts/strings/com2str.m
--- a/scripts/strings/com2str.m
+++ b/scripts/strings/com2str.m
@@ -35,17 +35,17 @@ function retval = com2str (zz, flg)
 
   if (nargin < 1 || nargin > 2)
     usage ("com2str (zz, flg)");
   endif
   if (nargin == 1)
     flg = 0;
   endif
 
-  if (! (is_scalar (zz) && is_scalar (flg)))
+  if (! (isscalar (zz) && isscalar (flg)))
     error ("com2str: arguments must be a scalar");
   endif
 
   if (flg != 0 && flg != 1)
     error ("invalid flg value: %d", flg);
   endif
 
   sgns = "+-";
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -59,17 +59,17 @@ function out = dec2base (d, base)
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   if (isstr (base))
     symbols = base;
     base = length (symbols);
     if any (diff (sort (toascii (symbols))) == 0)
       error ("dec2base: symbols representing digits must be unique.");
     endif
-  elseif (! is_scalar (base))
+  elseif (! isscalar (base))
     error ("dec2base: cannot convert from several bases at once.");
   elseif (base < 2 || base > length (symbols))
     error ("dec2base: base must be between 2 and 36 or a string of symbols");
   endif
   
   ## determine number of digits required to handle all numbers
   maxLen = floor (log (max (max (d), 1)) ./ log (base)) + 1;
   
diff --git a/test/octave.test/linalg/qr-7.m b/test/octave.test/linalg/qr-7.m
--- a/test/octave.test/linalg/qr-7.m
+++ b/test/octave.test/linalg/qr-7.m
@@ -3,17 +3,17 @@ function retval = testqr (q, r, a, p)
   retval = 0;
   if (nargin == 3)
     n1 = norm (q*r-a)
     n2 = norm (q'*q-eye(columns(q)))
     retval = (n1 < tol && n2 < tol)
   else
     n1 = norm (q'*q-eye(columns(q)))
     retval = (n1 < tol);
-    if (is_vector (p))
+    if (isvector (p))
       n2 = norm (q*r-a(:,p))
       retval = (retval && n2 < tol);
     else
       n2 = norm (q*r - a*p)
       retval = (retval && n2 < tol);
     endif
   endif
 endfunction
diff --git a/test/octave.test/number/is_matrix-1.m b/test/octave.test/number/is_matrix-1.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_matrix (1)
diff --git a/test/octave.test/number/is_matrix-10.m b/test/octave.test/number/is_matrix-10.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_matrix ([1, 2; 3, 4], 2)
diff --git a/test/octave.test/number/is_matrix-2.m b/test/octave.test/number/is_matrix-2.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_matrix ([1, 2, 3])
diff --git a/test/octave.test/number/is_matrix-3.m b/test/octave.test/number/is_matrix-3.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-3.m
+++ /dev/null
@@ -1,3 +0,0 @@
-## Yes, this is right, is_matrix() checks for non-empty matrices.
-
-is_matrix ([]) == 0
diff --git a/test/octave.test/number/is_matrix-4.m b/test/octave.test/number/is_matrix-4.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_matrix ([1, 2; 3, 4])
diff --git a/test/octave.test/number/is_matrix-5.m b/test/octave.test/number/is_matrix-5.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-5.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_matrix ("t");
-implicit_str_to_num_ok = 1;
-t2 = is_matrix ("t");
-t1 && t2
diff --git a/test/octave.test/number/is_matrix-6.m b/test/octave.test/number/is_matrix-6.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-6.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_matrix ("test");
-implicit_str_to_num_ok = 1;
-t2 = is_matrix ("test");
-t1 && t2
diff --git a/test/octave.test/number/is_matrix-7.m b/test/octave.test/number/is_matrix-7.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-7.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_matrix (["test"; "ing"]);
-implicit_str_to_num_ok = 1;
-t2 = is_matrix (["test"; "ing"]);
-t1 && t2
diff --git a/test/octave.test/number/is_matrix-8.m b/test/octave.test/number/is_matrix-8.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_matrix (s)
diff --git a/test/octave.test/number/is_matrix-9.m b/test/octave.test/number/is_matrix-9.m
deleted file mode 100644
--- a/test/octave.test/number/is_matrix-9.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_matrix ()
diff --git a/test/octave.test/number/is_scalar-1.m b/test/octave.test/number/is_scalar-1.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar (1)
diff --git a/test/octave.test/number/is_scalar-10.m b/test/octave.test/number/is_scalar-10.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar (1, 2)
diff --git a/test/octave.test/number/is_scalar-2.m b/test/octave.test/number/is_scalar-2.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar ([1, 2])
diff --git a/test/octave.test/number/is_scalar-3.m b/test/octave.test/number/is_scalar-3.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-3.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar ([])
diff --git a/test/octave.test/number/is_scalar-4.m b/test/octave.test/number/is_scalar-4.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar ([1, 2; 3, 4])
diff --git a/test/octave.test/number/is_scalar-5.m b/test/octave.test/number/is_scalar-5.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-5.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_scalar ("t");
-implicit_str_to_num_ok = 1;
-t2 = is_scalar ("t");
-t1 && t2
diff --git a/test/octave.test/number/is_scalar-6.m b/test/octave.test/number/is_scalar-6.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-6.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar ("test")
diff --git a/test/octave.test/number/is_scalar-7.m b/test/octave.test/number/is_scalar-7.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-7.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar (["test"; "ing"])
diff --git a/test/octave.test/number/is_scalar-8.m b/test/octave.test/number/is_scalar-8.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_scalar (s)
diff --git a/test/octave.test/number/is_scalar-9.m b/test/octave.test/number/is_scalar-9.m
deleted file mode 100644
--- a/test/octave.test/number/is_scalar-9.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_scalar ()
diff --git a/test/octave.test/number/is_square-1.m b/test/octave.test/number/is_square-1.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square (1)
diff --git a/test/octave.test/number/is_square-10.m b/test/octave.test/number/is_square-10.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ()
diff --git a/test/octave.test/number/is_square-11.m b/test/octave.test/number/is_square-11.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-11.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ([1, 2; 3, 4], 2)
diff --git a/test/octave.test/number/is_square-2.m b/test/octave.test/number/is_square-2.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ([1, 2])
diff --git a/test/octave.test/number/is_square-3.m b/test/octave.test/number/is_square-3.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-3.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ([])
diff --git a/test/octave.test/number/is_square-4.m b/test/octave.test/number/is_square-4.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ([1, 2; 3, 4]) == 2
diff --git a/test/octave.test/number/is_square-5.m b/test/octave.test/number/is_square-5.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-5.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_square ("t");
-implicit_str_to_num_ok = 1;
-t2 = (is_square ("t") == 1);
-t1 && t2
diff --git a/test/octave.test/number/is_square-6.m b/test/octave.test/number/is_square-6.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-6.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ("test")
diff --git a/test/octave.test/number/is_square-7.m b/test/octave.test/number/is_square-7.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-7.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_square (["test"; "ing"; "1"; "2"]);
-implicit_str_to_num_ok = 1;
-t2 = (is_square (["test"; "ing"; "1"; "2"]) == 4);
-t1 && t2
diff --git a/test/octave.test/number/is_square-8.m b/test/octave.test/number/is_square-8.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_square (s)
diff --git a/test/octave.test/number/is_square-9.m b/test/octave.test/number/is_square-9.m
deleted file mode 100644
--- a/test/octave.test/number/is_square-9.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_square ([1, 2; 3, 4; 5, 6])
diff --git a/test/octave.test/number/is_symmetric-1.m b/test/octave.test/number/is_symmetric-1.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric (1)
diff --git a/test/octave.test/number/is_symmetric-10.m b/test/octave.test/number/is_symmetric-10.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ([1, 2; 2, 1], 0, 0)
diff --git a/test/octave.test/number/is_symmetric-11.m b/test/octave.test/number/is_symmetric-11.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-11.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ()
diff --git a/test/octave.test/number/is_symmetric-2.m b/test/octave.test/number/is_symmetric-2.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ([1, 2])
diff --git a/test/octave.test/number/is_symmetric-3.m b/test/octave.test/number/is_symmetric-3.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-3.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ([])
diff --git a/test/octave.test/number/is_symmetric-4.m b/test/octave.test/number/is_symmetric-4.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ([1, 2; 2, 1]) == 2
diff --git a/test/octave.test/number/is_symmetric-5.m b/test/octave.test/number/is_symmetric-5.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-5.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_symmetric ("t");
-implicit_str_to_num_ok = 1;
-t2 = (is_symmetric ("t") == 1);
-t1 && t2
diff --git a/test/octave.test/number/is_symmetric-6.m b/test/octave.test/number/is_symmetric-6.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-6.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ("test")
diff --git a/test/octave.test/number/is_symmetric-7.m b/test/octave.test/number/is_symmetric-7.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-7.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_symmetric (["te"; "et"]);
-implicit_str_to_num_ok = 1;
-t2 = (is_symmetric (["te"; "et"]) == 2);
-t1 && t2
diff --git a/test/octave.test/number/is_symmetric-8.m b/test/octave.test/number/is_symmetric-8.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_symmetric (s)
diff --git a/test/octave.test/number/is_symmetric-9.m b/test/octave.test/number/is_symmetric-9.m
deleted file mode 100644
--- a/test/octave.test/number/is_symmetric-9.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_symmetric ([1, 2.1; 2, 1.1], 0.2) == 2
diff --git a/test/octave.test/number/is_vector-1.m b/test/octave.test/number/is_vector-1.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector (1)
diff --git a/test/octave.test/number/is_vector-10.m b/test/octave.test/number/is_vector-10.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector ([1, 2], 2)
diff --git a/test/octave.test/number/is_vector-2.m b/test/octave.test/number/is_vector-2.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector ([1; 2; 3])
diff --git a/test/octave.test/number/is_vector-3.m b/test/octave.test/number/is_vector-3.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-3.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector ([])
diff --git a/test/octave.test/number/is_vector-4.m b/test/octave.test/number/is_vector-4.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector ([1, 2; 3, 4])
diff --git a/test/octave.test/number/is_vector-5.m b/test/octave.test/number/is_vector-5.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-5.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_vector ("t");
-implicit_str_to_num_ok = 1;
-t2 = is_vector ("t");
-t1 && t2
diff --git a/test/octave.test/number/is_vector-6.m b/test/octave.test/number/is_vector-6.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-6.m
+++ /dev/null
@@ -1,5 +0,0 @@
-implicit_str_to_num_ok = 0;
-t1 = ! is_vector ("test");
-implicit_str_to_num_ok = 1;
-t2 = is_vector ("test");
-t1 && t2
diff --git a/test/octave.test/number/is_vector-7.m b/test/octave.test/number/is_vector-7.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-7.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector (["test"; "ing"])
diff --git a/test/octave.test/number/is_vector-8.m b/test/octave.test/number/is_vector-8.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_vector (s)
diff --git a/test/octave.test/number/is_vector-9.m b/test/octave.test/number/is_vector-9.m
deleted file mode 100644
--- a/test/octave.test/number/is_vector-9.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_vector ()
diff --git a/test/octave.test/number/ismatrix-1.m b/test/octave.test/number/ismatrix-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-1.m
@@ -0,0 +1,1 @@
+ismatrix (1)
diff --git a/test/octave.test/number/ismatrix-10.m b/test/octave.test/number/ismatrix-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-10.m
@@ -0,0 +1,1 @@
+ismatrix ([1, 2; 3, 4], 2)
diff --git a/test/octave.test/number/ismatrix-2.m b/test/octave.test/number/ismatrix-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-2.m
@@ -0,0 +1,1 @@
+ismatrix ([1, 2, 3])
diff --git a/test/octave.test/number/ismatrix-3.m b/test/octave.test/number/ismatrix-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-3.m
@@ -0,0 +1,3 @@
+## Yes, this is right, ismatrix() checks for non-empty matrices.
+
+ismatrix ([]) == 0
diff --git a/test/octave.test/number/ismatrix-4.m b/test/octave.test/number/ismatrix-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-4.m
@@ -0,0 +1,1 @@
+ismatrix ([1, 2; 3, 4])
diff --git a/test/octave.test/number/ismatrix-5.m b/test/octave.test/number/ismatrix-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-5.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! ismatrix ("t");
+implicit_str_to_num_ok = 1;
+t2 = ismatrix ("t");
+t1 && t2
diff --git a/test/octave.test/number/ismatrix-6.m b/test/octave.test/number/ismatrix-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-6.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! ismatrix ("test");
+implicit_str_to_num_ok = 1;
+t2 = ismatrix ("test");
+t1 && t2
diff --git a/test/octave.test/number/ismatrix-7.m b/test/octave.test/number/ismatrix-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-7.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! ismatrix (["test"; "ing"]);
+implicit_str_to_num_ok = 1;
+t2 = ismatrix (["test"; "ing"]);
+t1 && t2
diff --git a/test/octave.test/number/ismatrix-8.m b/test/octave.test/number/ismatrix-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+ismatrix (s)
diff --git a/test/octave.test/number/ismatrix-9.m b/test/octave.test/number/ismatrix-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/ismatrix-9.m
@@ -0,0 +1,1 @@
+ismatrix ()
diff --git a/test/octave.test/number/isscalar-1.m b/test/octave.test/number/isscalar-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-1.m
@@ -0,0 +1,1 @@
+isscalar (1)
diff --git a/test/octave.test/number/isscalar-10.m b/test/octave.test/number/isscalar-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-10.m
@@ -0,0 +1,1 @@
+isscalar (1, 2)
diff --git a/test/octave.test/number/isscalar-2.m b/test/octave.test/number/isscalar-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-2.m
@@ -0,0 +1,1 @@
+isscalar ([1, 2])
diff --git a/test/octave.test/number/isscalar-3.m b/test/octave.test/number/isscalar-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-3.m
@@ -0,0 +1,1 @@
+isscalar ([])
diff --git a/test/octave.test/number/isscalar-4.m b/test/octave.test/number/isscalar-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-4.m
@@ -0,0 +1,1 @@
+isscalar ([1, 2; 3, 4])
diff --git a/test/octave.test/number/isscalar-5.m b/test/octave.test/number/isscalar-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-5.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! isscalar ("t");
+implicit_str_to_num_ok = 1;
+t2 = isscalar ("t");
+t1 && t2
diff --git a/test/octave.test/number/isscalar-6.m b/test/octave.test/number/isscalar-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-6.m
@@ -0,0 +1,1 @@
+isscalar ("test")
diff --git a/test/octave.test/number/isscalar-7.m b/test/octave.test/number/isscalar-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-7.m
@@ -0,0 +1,1 @@
+isscalar (["test"; "ing"])
diff --git a/test/octave.test/number/isscalar-8.m b/test/octave.test/number/isscalar-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+isscalar (s)
diff --git a/test/octave.test/number/isscalar-9.m b/test/octave.test/number/isscalar-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isscalar-9.m
@@ -0,0 +1,1 @@
+isscalar ()
diff --git a/test/octave.test/number/issquare-1.m b/test/octave.test/number/issquare-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-1.m
@@ -0,0 +1,1 @@
+issquare (1)
diff --git a/test/octave.test/number/issquare-10.m b/test/octave.test/number/issquare-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-10.m
@@ -0,0 +1,1 @@
+issquare ()
diff --git a/test/octave.test/number/issquare-11.m b/test/octave.test/number/issquare-11.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-11.m
@@ -0,0 +1,1 @@
+issquare ([1, 2; 3, 4], 2)
diff --git a/test/octave.test/number/issquare-2.m b/test/octave.test/number/issquare-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-2.m
@@ -0,0 +1,1 @@
+issquare ([1, 2])
diff --git a/test/octave.test/number/issquare-3.m b/test/octave.test/number/issquare-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-3.m
@@ -0,0 +1,1 @@
+issquare ([])
diff --git a/test/octave.test/number/issquare-4.m b/test/octave.test/number/issquare-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-4.m
@@ -0,0 +1,1 @@
+issquare ([1, 2; 3, 4]) == 2
diff --git a/test/octave.test/number/issquare-5.m b/test/octave.test/number/issquare-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-5.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! issquare ("t");
+implicit_str_to_num_ok = 1;
+t2 = (issquare ("t") == 1);
+t1 && t2
diff --git a/test/octave.test/number/issquare-6.m b/test/octave.test/number/issquare-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-6.m
@@ -0,0 +1,1 @@
+issquare ("test")
diff --git a/test/octave.test/number/issquare-7.m b/test/octave.test/number/issquare-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-7.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! issquare (["test"; "ing"; "1"; "2"]);
+implicit_str_to_num_ok = 1;
+t2 = (issquare (["test"; "ing"; "1"; "2"]) == 4);
+t1 && t2
diff --git a/test/octave.test/number/issquare-8.m b/test/octave.test/number/issquare-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+issquare (s)
diff --git a/test/octave.test/number/issquare-9.m b/test/octave.test/number/issquare-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issquare-9.m
@@ -0,0 +1,1 @@
+issquare ([1, 2; 3, 4; 5, 6])
diff --git a/test/octave.test/number/issymmetric-1.m b/test/octave.test/number/issymmetric-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-1.m
@@ -0,0 +1,1 @@
+issymmetric (1)
diff --git a/test/octave.test/number/issymmetric-10.m b/test/octave.test/number/issymmetric-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-10.m
@@ -0,0 +1,1 @@
+issymmetric ([1, 2; 2, 1], 0, 0)
diff --git a/test/octave.test/number/issymmetric-11.m b/test/octave.test/number/issymmetric-11.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-11.m
@@ -0,0 +1,1 @@
+issymmetric ()
diff --git a/test/octave.test/number/issymmetric-2.m b/test/octave.test/number/issymmetric-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-2.m
@@ -0,0 +1,1 @@
+issymmetric ([1, 2])
diff --git a/test/octave.test/number/issymmetric-3.m b/test/octave.test/number/issymmetric-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-3.m
@@ -0,0 +1,1 @@
+issymmetric ([])
diff --git a/test/octave.test/number/issymmetric-4.m b/test/octave.test/number/issymmetric-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-4.m
@@ -0,0 +1,1 @@
+issymmetric ([1, 2; 2, 1]) == 2
diff --git a/test/octave.test/number/issymmetric-5.m b/test/octave.test/number/issymmetric-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-5.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! issymmetric ("t");
+implicit_str_to_num_ok = 1;
+t2 = (issymmetric ("t") == 1);
+t1 && t2
diff --git a/test/octave.test/number/issymmetric-6.m b/test/octave.test/number/issymmetric-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-6.m
@@ -0,0 +1,1 @@
+issymmetric ("test")
diff --git a/test/octave.test/number/issymmetric-7.m b/test/octave.test/number/issymmetric-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-7.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! issymmetric (["te"; "et"]);
+implicit_str_to_num_ok = 1;
+t2 = (issymmetric (["te"; "et"]) == 2);
+t1 && t2
diff --git a/test/octave.test/number/issymmetric-8.m b/test/octave.test/number/issymmetric-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+issymmetric (s)
diff --git a/test/octave.test/number/issymmetric-9.m b/test/octave.test/number/issymmetric-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/issymmetric-9.m
@@ -0,0 +1,1 @@
+issymmetric ([1, 2.1; 2, 1.1], 0.2) == 2
diff --git a/test/octave.test/number/isvector-1.m b/test/octave.test/number/isvector-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-1.m
@@ -0,0 +1,1 @@
+isvector (1)
diff --git a/test/octave.test/number/isvector-10.m b/test/octave.test/number/isvector-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-10.m
@@ -0,0 +1,1 @@
+isvector ([1, 2], 2)
diff --git a/test/octave.test/number/isvector-2.m b/test/octave.test/number/isvector-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-2.m
@@ -0,0 +1,1 @@
+isvector ([1; 2; 3])
diff --git a/test/octave.test/number/isvector-3.m b/test/octave.test/number/isvector-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-3.m
@@ -0,0 +1,1 @@
+isvector ([])
diff --git a/test/octave.test/number/isvector-4.m b/test/octave.test/number/isvector-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-4.m
@@ -0,0 +1,1 @@
+isvector ([1, 2; 3, 4])
diff --git a/test/octave.test/number/isvector-5.m b/test/octave.test/number/isvector-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-5.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! isvector ("t");
+implicit_str_to_num_ok = 1;
+t2 = isvector ("t");
+t1 && t2
diff --git a/test/octave.test/number/isvector-6.m b/test/octave.test/number/isvector-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-6.m
@@ -0,0 +1,5 @@
+implicit_str_to_num_ok = 0;
+t1 = ! isvector ("test");
+implicit_str_to_num_ok = 1;
+t2 = isvector ("test");
+t1 && t2
diff --git a/test/octave.test/number/isvector-7.m b/test/octave.test/number/isvector-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-7.m
@@ -0,0 +1,1 @@
+isvector (["test"; "ing"])
diff --git a/test/octave.test/number/isvector-8.m b/test/octave.test/number/isvector-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+isvector (s)
diff --git a/test/octave.test/number/isvector-9.m b/test/octave.test/number/isvector-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/number/isvector-9.m
@@ -0,0 +1,1 @@
+isvector ()
diff --git a/test/octave.test/struct/is_struct-1.m b/test/octave.test/struct/is_struct-1.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-1.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct (1)
diff --git a/test/octave.test/struct/is_struct-10.m b/test/octave.test/struct/is_struct-10.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-10.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ()
diff --git a/test/octave.test/struct/is_struct-11.m b/test/octave.test/struct/is_struct-11.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-11.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_struct (s, 1)
diff --git a/test/octave.test/struct/is_struct-2.m b/test/octave.test/struct/is_struct-2.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-2.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ([1, 2])
diff --git a/test/octave.test/struct/is_struct-3.m b/test/octave.test/struct/is_struct-3.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-3.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ([])
diff --git a/test/octave.test/struct/is_struct-4.m b/test/octave.test/struct/is_struct-4.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-4.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ([1, 2; 3, 4])
diff --git a/test/octave.test/struct/is_struct-5.m b/test/octave.test/struct/is_struct-5.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-5.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ("t")
diff --git a/test/octave.test/struct/is_struct-6.m b/test/octave.test/struct/is_struct-6.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-6.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct ("test")
diff --git a/test/octave.test/struct/is_struct-7.m b/test/octave.test/struct/is_struct-7.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-7.m
+++ /dev/null
@@ -1,1 +0,0 @@
-is_struct (["test"; "ing"])
diff --git a/test/octave.test/struct/is_struct-8.m b/test/octave.test/struct/is_struct-8.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-8.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a = 1;
-is_struct (s)
diff --git a/test/octave.test/struct/is_struct-9.m b/test/octave.test/struct/is_struct-9.m
deleted file mode 100644
--- a/test/octave.test/struct/is_struct-9.m
+++ /dev/null
@@ -1,2 +0,0 @@
-s.a.b = 1;
-is_struct (s.a)
diff --git a/test/octave.test/struct/isstruct-1.m b/test/octave.test/struct/isstruct-1.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-1.m
@@ -0,0 +1,1 @@
+isstruct (1)
diff --git a/test/octave.test/struct/isstruct-10.m b/test/octave.test/struct/isstruct-10.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-10.m
@@ -0,0 +1,1 @@
+isstruct ()
diff --git a/test/octave.test/struct/isstruct-11.m b/test/octave.test/struct/isstruct-11.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-11.m
@@ -0,0 +1,2 @@
+s.a = 1;
+isstruct (s, 1)
diff --git a/test/octave.test/struct/isstruct-2.m b/test/octave.test/struct/isstruct-2.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-2.m
@@ -0,0 +1,1 @@
+isstruct ([1, 2])
diff --git a/test/octave.test/struct/isstruct-3.m b/test/octave.test/struct/isstruct-3.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-3.m
@@ -0,0 +1,1 @@
+isstruct ([])
diff --git a/test/octave.test/struct/isstruct-4.m b/test/octave.test/struct/isstruct-4.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-4.m
@@ -0,0 +1,1 @@
+isstruct ([1, 2; 3, 4])
diff --git a/test/octave.test/struct/isstruct-5.m b/test/octave.test/struct/isstruct-5.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-5.m
@@ -0,0 +1,1 @@
+isstruct ("t")
diff --git a/test/octave.test/struct/isstruct-6.m b/test/octave.test/struct/isstruct-6.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-6.m
@@ -0,0 +1,1 @@
+isstruct ("test")
diff --git a/test/octave.test/struct/isstruct-7.m b/test/octave.test/struct/isstruct-7.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-7.m
@@ -0,0 +1,1 @@
+isstruct (["test"; "ing"])
diff --git a/test/octave.test/struct/isstruct-8.m b/test/octave.test/struct/isstruct-8.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-8.m
@@ -0,0 +1,2 @@
+s.a = 1;
+isstruct (s)
diff --git a/test/octave.test/struct/isstruct-9.m b/test/octave.test/struct/isstruct-9.m
new file mode 100644
--- /dev/null
+++ b/test/octave.test/struct/isstruct-9.m
@@ -0,0 +1,2 @@
+s.a.b = 1;
+isstruct (s.a)
diff --git a/test/octave.test/system/getgrent-1.m b/test/octave.test/system/getgrent-1.m
--- a/test/octave.test/system/getgrent-1.m
+++ b/test/octave.test/system/getgrent-1.m
@@ -1,6 +1,6 @@
 x = getgrent ();
-(is_struct (x)
+(isstruct (x)
  && struct_contains (x, "name")
  && struct_contains (x, "passwd")
  && struct_contains (x, "gid")
  && struct_contains (x, "mem"))
diff --git a/test/octave.test/system/getpwent-1.m b/test/octave.test/system/getpwent-1.m
--- a/test/octave.test/system/getpwent-1.m
+++ b/test/octave.test/system/getpwent-1.m
@@ -1,9 +1,9 @@
 s = getpwent ();
-(is_struct (s)
+(isstruct (s)
  && struct_contains (s, "name")
  && struct_contains (s, "passwd")
  && struct_contains (s, "uid")
  && struct_contains (s, "gid")
  && struct_contains (s, "gecos")
  && struct_contains (s, "dir")
  && struct_contains (s, "shell"))
diff --git a/test/octave.test/system/getrusage-1.m b/test/octave.test/system/getrusage-1.m
--- a/test/octave.test/system/getrusage-1.m
+++ b/test/octave.test/system/getrusage-1.m
@@ -1,1 +1,1 @@
-is_struct (getrusage ())
+isstruct (getrusage ())
diff --git a/test/octave.test/system/gmtime-1.m b/test/octave.test/system/gmtime-1.m
--- a/test/octave.test/system/gmtime-1.m
+++ b/test/octave.test/system/gmtime-1.m
@@ -1,10 +1,10 @@
 ts = gmtime (time ());
-(is_struct (ts)
+(isstruct (ts)
  && struct_contains (ts, "usec")
  && struct_contains (ts, "year")
  && struct_contains (ts, "mon")
  && struct_contains (ts, "mday")
  && struct_contains (ts, "sec")
  && struct_contains (ts, "min")
  && struct_contains (ts, "wday")
  && struct_contains (ts, "hour")
diff --git a/test/octave.test/system/localtime-1.m b/test/octave.test/system/localtime-1.m
--- a/test/octave.test/system/localtime-1.m
+++ b/test/octave.test/system/localtime-1.m
@@ -1,10 +1,10 @@
 ts = localtime (time ())
-(is_struct (ts)
+(isstruct (ts)
  && struct_contains (ts, "usec")
  && struct_contains (ts, "year")
  && struct_contains (ts, "mon")
  && struct_contains (ts, "mday")
  && struct_contains (ts, "sec")
  && struct_contains (ts, "min")
  && struct_contains (ts, "wday")
  && struct_contains (ts, "hour")
diff --git a/test/octave.test/system/lstat-1.m b/test/octave.test/system/lstat-1.m
--- a/test/octave.test/system/lstat-1.m
+++ b/test/octave.test/system/lstat-1.m
@@ -1,11 +1,11 @@
 [s, err, msg] = lstat ("/");
 (err == 0
- && is_struct (s)
+ && isstruct (s)
  && struct_contains (s, "dev")
  && struct_contains (s, "ino")
  && struct_contains (s, "modestr")
  && struct_contains (s, "nlink")
  && struct_contains (s, "uid")
  && struct_contains (s, "gid")
  && struct_contains (s, "size")
  && struct_contains (s, "atime")
diff --git a/test/octave.test/system/octave_config_info-1.m b/test/octave.test/system/octave_config_info-1.m
--- a/test/octave.test/system/octave_config_info-1.m
+++ b/test/octave.test/system/octave_config_info-1.m
@@ -1,1 +1,1 @@
-is_struct (octave_config_info ())
+isstruct (octave_config_info ())
diff --git a/test/octave.test/system/stat-1.m b/test/octave.test/system/stat-1.m
--- a/test/octave.test/system/stat-1.m
+++ b/test/octave.test/system/stat-1.m
@@ -1,11 +1,11 @@
 [s, err, msg] = stat ("/");
 (err == 0
- && is_struct (s)
+ && isstruct (s)
  && struct_contains (s, "dev")
  && struct_contains (s, "ino")
  && struct_contains (s, "modestr")
  && struct_contains (s, "nlink")
  && struct_contains (s, "uid")
  && struct_contains (s, "gid")
  && struct_contains (s, "size")
  && struct_contains (s, "atime")
