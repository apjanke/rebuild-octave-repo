# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1420222167 18000
#      Fri Jan 02 13:09:27 2015 -0500
# Node ID e616c28304131f356d58f93137f2041ee44a29fa
# Parent  572b9bd43e922ea58a24113840ef060413995c49
various style fixes for audio code

* audiodevinfo.cc, audioread.cc: Style fixes.

diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -89,43 +89,49 @@ Given a sampling rate, bits per sample, 
 an input or output device, return the ID of the first device that\n\
 supports playback or recording using the specified parameters.\n\
 \n\
 If also given a device ID, return true if the device supports playback\n\
 or recording using those parameters.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   int nargin = args.length ();
-  PaError err;
+
   octave_scalar_map devinfo;
   octave_value_list input;
   octave_value_list output;
 
-  err = Pa_Initialize ();
+  PaError err = Pa_Initialize ();
+
   if (err != paNoError)
     {
-      error ("audiodevinfo: cannot initialize PortAudio");
+      error ("audiodevinfo: PortAudio initialization failed");
       return retval;
     }
 
   int num_devices = Pa_GetDeviceCount ();
+
   if (num_devices < 0)
     {
       error ("audiodevinfo: no audio device found");
       return retval;
     }
 
   octave_idx_type numinput = 0, numoutput = 0;
   for (int i = 0; i < num_devices; i++)
     {
       const PaDeviceInfo *device_info = Pa_GetDeviceInfo (i);
+
       if (device_info->maxInputChannels != 0)
         numinput++;
+
       if (device_info->maxOutputChannels != 0)
         numoutput++;
     }
 
   Cell input_name (dim_vector (1, numinput));
   Cell input_driver_version (dim_vector (1, numinput));
   Cell input_id (dim_vector (1, numinput));
   Cell output_name (dim_vector (1, numoutput));
@@ -171,19 +177,19 @@ or recording using those parameters.\n\
   // Return information about input and output audio devices and
   // their properties.
   if (nargin == 0)
     retval = devinfo;
   // Return the number of input or output devices
   else if (nargin == 1)
     {
       if (args(0).int_value () == 0)
-        retval = octave_value (numoutput);
+        retval = numoutput;
       else if (args(0).int_value () == 1)
-        retval = octave_value (numinput);
+        retval = numinput;
       else
         {
           error ("audiodevinfo: please specify 0 for output and 1 for input devices");
           return retval;
         }
     }
   // Return device name when given id or id when given device name.
   else if (nargin == 2)
@@ -254,47 +260,52 @@ or recording using those parameters.\n\
               return retval;
             }
         }
       if (not found)
         error ("audiodevinfo: no device meeting the specified criteria found");
     }
   else if (nargin == 3)
     {
-      //
+      // FIXME: what was supposed to happen here?
     }
   // Return the id of the first device meeting specified criteria.
   else if (nargin == 4)
     {
       int io = args(0).int_value ();
       int rate = args(1).int_value ();
       int bits = args(2).int_value ();
       int chans = args(3).int_value ();
+
       for (int i = 0; i < num_devices; i++)
         {
           PaStreamParameters stream_parameters;
           stream_parameters.device = i;
           stream_parameters.channelCount = chans;
           PaSampleFormat format = bits_to_format (bits);
+
           if (format != 0)
             stream_parameters.sampleFormat = format;
           else
             {
               error ("audiodevinfo: no such bits per sample format");
               return retval;
             }
-          stream_parameters.suggestedLatency =
-              Pa_GetDeviceInfo (i)->defaultLowInputLatency;
+
+          stream_parameters.suggestedLatency
+            = Pa_GetDeviceInfo (i)->defaultLowInputLatency;
           stream_parameters.hostApiSpecificStreamInfo = 0;
+
           if (io == 0)
             {
               if (Pa_GetDeviceInfo (i)->maxOutputChannels < chans)
                 continue;
 
               err = Pa_IsFormatSupported (0, &stream_parameters, rate);
+
               if (err == paFormatIsSupported)
                 {
                   retval = i;
                   return retval;
                 }
             }
           else if (io == 1)
             {
@@ -369,18 +380,21 @@ or recording using those parameters.\n\
       retval = 0;
     }
   else
     {
       error ("audiodevinfo: wrong number of arguments");
       return retval;
     }
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 /*
 %!test
 %! devinfo = audiodevinfo;
 %! assert (rows (devinfo.input), 1);
 %! assert (rows (devinfo.output), 1);
@@ -672,76 +686,65 @@ void
 audioplayer::print_raw (std::ostream& os, bool) const
 {
   os << 0;
 }
 
 void
 audioplayer::init_fn (void)
 {
-  PaError err;
-  int device;
-
-  err = Pa_Initialize ();
-  if (err != paNoError)
+  if (Pa_Initialize () != paNoError)
     {
-      error ("audioplayer: Initialization error!");
+      error ("audioplayer: initialization error!");
       return;
     }
 
-  int numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0)
+  if (Pa_GetDeviceCount () < 0)
     {
-      error ("audioplayer: No audio devices found!");
+      error ("audioplayer: no audio devices found!");
       return;
     }
 
-  if (get_id () == -1)
+  int device = get_id ();
+
+  if (device == -1)
     device = Pa_GetDefaultOutputDevice ();
-  else
-    device = get_id ();
 
   output_parameters.device = device;
   output_parameters.channelCount = 2;
   output_parameters.sampleFormat = bits_to_format (get_nbits ());
   output_parameters.suggestedLatency = Pa_GetDeviceInfo (device)->defaultHighOutputLatency;
   output_parameters.hostApiSpecificStreamInfo = 0;
 }
 
 void
 audioplayer::init (void)
 {
-  PaError err;
-
   // Both of these variables are unused.  Should they be
   // eliminated or is something not yet implemented?
   //
   // int channels = y.rows ();
   // RowVector *sound_l = get_left ();
 
-  int device;
-
-  err = Pa_Initialize ();
-  if (err != paNoError)
+  if (Pa_Initialize () != paNoError)
     {
-      error ("audioplayer: Initialization error!");
+      error ("audioplayer: initialization error!");
       return;
     }
 
-  int numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0)
+  if (Pa_GetDeviceCount () < 0)
     {
-      error ("audioplayer: No audio devices found!");
+      error ("audioplayer: no audio devices found!");
       return;
     }
 
-  if (get_id () == -1)
+  int device = get_id ();
+
+  if (device == -1)
     device = Pa_GetDefaultOutputDevice ();
-  else
-    device = get_id ();
 
   output_parameters.device = device;
   output_parameters.channelCount = 2;
 
   if (type == DOUBLE)
     output_parameters.sampleFormat = bits_to_format (get_nbits ());
   else if (type == INT8)
     output_parameters.sampleFormat = paInt8;
@@ -918,27 +921,27 @@ void
 audioplayer::playblocking (void)
 {
   if (get_stream ())
     stop ();
 
   PaError err;
   uint32_t buffer[BUFFER_SIZE * 2];
   err = Pa_OpenStream (&stream, 0, &(output_parameters), get_fs (),
-                       BUFFER_SIZE, paClipOff, 0, 0);
+                               BUFFER_SIZE, paClipOff, 0, 0);
   if (err != paNoError)
     {
-      error ("audioplayer: Error opening audio playback stream");
+      error ("audioplayer: unable to open audio playback stream");
       return;
     }
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     {
-      error ("audioplayer: Error starting audio playback stream");
+      error ("audioplayer: unable to start start audio playback stream");
       return;
     }
 
   unsigned int start, end;
   start = get_sample_number ();
   end = get_end_sample ();
   for (unsigned int i = start; i < end; i += BUFFER_SIZE)
     {
@@ -1188,38 +1191,44 @@ octave_record_callback (const void *inpu
           sound(i, 0) = sample_l;
           sound(i, 1) = sample_r;
         }
     }
   else if (recorder->get_nbits () == 24)
     {
       // FIXME: Is there a better way?
       const uint8_t *input24 = static_cast<const uint8_t *> (input);
-      int32_t sample_l32, sample_r32;
+
+      int32_t sample_l32 = 0, sample_r32 = 0;
       uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
       uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
+
       for (unsigned long i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
-               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
+              _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
+
           if (sample_l32 & 0x00800000)
             sample_l32 |= 0xff000000;
+
           if (sample_r32 & 0x00800000)
             sample_r32 |= 0xff000000;
+
           sound(i, 0) = sample_l32 / pow (2.0, 23);
           sound(i, 1) = sample_r32 / pow (2.0, 23);
         }
     }
 
   octave_value_list args, retval;
   args(0) = sound;
   retval = feval (recorder->octave_callback_function, args, 1);
+
   return retval(0).int_value ();
 }
 
 static int
 portaudio_record_callback (const void *input, void *, unsigned long frames,
                            const PaStreamCallbackTimeInfo *,
                            PaStreamCallbackFlags, void *data)
 {
@@ -1245,30 +1254,35 @@ portaudio_record_callback (const void *i
           sample_r = input16[i * channels + (channels - 1)] / (pow (2.0, 15) - 1.0);
           recorder->append (sample_l, sample_r);
         }
     }
   else if (recorder->get_nbits () == 24)
     {
       // FIXME: Is there a better way?
       const uint8_t *input24 = static_cast<const uint8_t *> (input);
-      int32_t sample_l32, sample_r32;
+
+      int32_t sample_l32 = 0, sample_r32 = 0;
       uint8_t *_sample_l = reinterpret_cast<uint8_t *> (&sample_l);
       uint8_t *_sample_r = reinterpret_cast<uint8_t *> (&sample_r);
+
       for (unsigned long i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
+
           if (sample_l32 & 0x00800000)
             sample_l32 |= 0xff000000;
+
           if (sample_r32 & 0x00800000)
             sample_r32 |= 0xff000000;
+
           recorder->append (sample_l32 / pow (2.0, 23), sample_r32 / pow (2.0, 23));
         }
     }
 
   if (recorder->get_sample_number () > recorder->get_end_sample ())
     return paComplete;
 
   return paContinue;
@@ -1292,36 +1306,32 @@ void
 audiorecorder::print_raw (std::ostream& os, bool) const
 {
   os << 0;
 }
 
 void
 audiorecorder::init (void)
 {
-  PaError err;
-  int device;
-  err = Pa_Initialize ();
-  if (err != paNoError)
+  if (Pa_Initialize () != paNoError)
     {
-      error ("audiorecorder: Initialization error!");
+      error ("audiorecorder: initialization error!");
       return;
     }
 
-  int numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0)
+  if (Pa_GetDeviceCount () < 0)
     {
-      error ("audiorecorder: No audio devices found!");
+      error ("audiorecorder: no audio devices found!");
       return;
     }
 
-  if (get_id () == -1)
+  int device = get_id ();
+
+  if (device == -1)
     device = Pa_GetDefaultInputDevice ();
-  else
-    device = get_id ();
 
   input_parameters.device = device;
   input_parameters.channelCount = get_channels ();
   input_parameters.sampleFormat = bits_to_format (get_nbits ());
   input_parameters.suggestedLatency = Pa_GetDeviceInfo (device)->defaultHighInputLatency;
   input_parameters.hostApiSpecificStreamInfo = 0;
 }
 
@@ -1439,46 +1449,50 @@ audiorecorder::get_userdata (void)
 {
   return userdata;
 }
 
 octave_value
 audiorecorder::getaudiodata (void)
 {
   Matrix audio (2, left.size ());
+
   for (unsigned int i = 0; i < left.size (); i++)
     {
       audio(0, i) = left[i];
       audio(1, i) = right[i];
     }
-  return octave_value (audio);
+
+  return audio;
 }
 
 audioplayer *
 audiorecorder::getplayer (void)
 {
   audioplayer *player = new audioplayer ();
+
   player->set_y (getaudiodata ());
   player->set_fs (get_fs ());
   player->set_nbits (get_nbits ());
   player->init ();
+
   return player;
 }
 
 bool
 audiorecorder::isrecording (void)
 {
   if (get_stream () == 0)
     return false;
 
   PaError err;
   err = Pa_IsStreamActive (stream);
   if (err != 0 && err != 1)
     {
-      error ("audiorecorder: Error checking stream activity status");
+      error ("audiorecorder: unable to check stream activity status");
       return false;
     }
 
   return (err == 1);
 }
 
 void
 audiorecorder::record (void)
@@ -1498,23 +1512,23 @@ audiorecorder::record (void)
   else
     {
       err = Pa_OpenStream (&stream, &(input_parameters), 0,
                            get_fs (), BUFFER_SIZE, paClipOff,
                            portaudio_record_callback, this);
     }
   if (err != paNoError)
     {
-      error ("audiorecorder: Error opening audio recording stream");
+      error ("audiorecorder: unable to open audio recording stream");
       return;
     }
   err = Pa_StartStream (stream);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error starting audio recording stream");
+      error ("audiorecorder: unable to start audio recording stream");
       return;
     }
 }
 
 void
 audiorecorder::recordblocking (float seconds)
 {
   if (get_stream ())
@@ -1523,24 +1537,24 @@ audiorecorder::recordblocking (float sec
   left.clear ();
   right.clear ();
 
   PaError err;
   err = Pa_OpenStream (&stream, &(input_parameters), 0,
                        get_fs (), BUFFER_SIZE, paClipOff, 0, this);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error opening audio recording stream");
+      error ("audiorecorder: unable to open audio recording stream");
       return;
     }
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error starting audio recording stream");
+      error ("audiorecorder: unable to start audio recording stream");
       return;
     }
 
   unsigned int frames = seconds * get_fs ();
   uint8_t buffer[BUFFER_SIZE * 2 * 3];
   for (unsigned long i = 0; i < frames / BUFFER_SIZE; i++)
     {
       Pa_ReadStream (get_stream (), buffer, BUFFER_SIZE);
@@ -1556,57 +1570,57 @@ audiorecorder::pause (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StopStream (stream);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error stoping audio recording stream");
+      error ("audiorecorder: unable to stop audio recording stream");
       return;
     }
 }
 
 void
 audiorecorder::resume (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   err = Pa_StartStream (stream);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error starting audio recording stream");
+      error ("audiorecorder: unable to start audio recording stream");
       return;
     }
 }
 
 void
 audiorecorder::stop (void)
 {
   if (get_stream () == 0)
     return;
 
   PaError err;
   if (not Pa_IsStreamStopped (get_stream ()))
     {
       err = Pa_AbortStream (get_stream ());
       if (err != paNoError)
         {
-          error ("audioplayer: Error stopping audio playback stream");
+          error ("audioplayer: unable to stop audio playback stream");
           return;
         }
     }
 
   err = Pa_CloseStream (stream);
   if (err != paNoError)
     {
-      error ("audiorecorder: Error closing audio recording stream");
+      error ("audiorecorder: unable to close audio recording stream");
       return;
     }
 
   set_sample_number (0);
   reset_end_sample ();
   stream = 0;
 }
 
@@ -1627,50 +1641,64 @@ audiorecorder::get_stream (void)
 DEFUN_DLD (__recorder_audiorecorder__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels})\n\
 @deftypefnx {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels}, @var{id})\n\
 @deftypefnx {Loadable Function} {@var{recorder} =} __recorder_audiorecorder__ (@var{fcn}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   int nargin = args.length ();
-  audiorecorder* retval = new audiorecorder ();
+
+  audiorecorder* recorder = new audiorecorder ();
+
   int offset = 0;
+
   if (nargin > 0)
     {
       bool is_function = args(0).is_string () || args(0).is_function_handle () || args(0).is_inline_function ();
+
       if (is_function)
         {
-          retval->octave_callback_function = args(0).function_value ();
+          recorder->octave_callback_function = args(0).function_value ();
           offset = 1;
         }
     }
+
   switch (nargin - offset)
-     {
-      case 3:
-        retval->set_fs (args(0 + offset).int_value ());
-        retval->set_nbits (args(1 + offset).int_value ());
-        retval->set_channels (args(2 + offset).int_value ());
-        break;
-      case 4:
-        retval->set_fs (args(0 + offset).int_value ());
-        retval->set_nbits (args(1 + offset).int_value ());
-        retval->set_channels (args(2 + offset).int_value ());
-        retval->set_id (args(3 + offset).int_value ());
-        break;
+    {
+    case 3:
+      recorder->set_fs (args(0 + offset).int_value ());
+      recorder->set_nbits (args(1 + offset).int_value ());
+      recorder->set_channels (args(2 + offset).int_value ());
+      break;
+
+    case 4:
+      recorder->set_fs (args(0 + offset).int_value ());
+      recorder->set_nbits (args(1 + offset).int_value ());
+      recorder->set_channels (args(2 + offset).int_value ());
+      recorder->set_id (args(3 + offset).int_value ());
+      break;
     }
-  retval->init ();
-  return octave_value (retval);
+
+  recorder->init ();
+
+  retval = recorder;
+
 #else
-  octave_value retval;
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
+#endif
+
   return retval;
-#endif
 }
 
 static audiorecorder *
 get_recorder (const octave_value& ov)
 {
   const octave_base_value& rep = ov.get_rep ();
 
   octave_base_value *ncrep = const_cast<octave_base_value *> (&rep);
@@ -1680,406 +1708,507 @@ get_recorder (const octave_value& ov)
 
 DEFUN_DLD (__recorder_getaudiodata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   audiorecorder *recorder = get_recorder (args(0));
-  retval = octave_value (recorder->getaudiodata ());
+  retval = recorder->getaudiodata ();
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_channels__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __recorder_get_channels__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_channels ());
+      retval = recorder->get_channels ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_fs__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{fs} =} __recorder_get_fs__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_fs ());
+      retval = recorder->get_fs ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_id__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{id} =} __recorder_get_id__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_id ());
+      retval = recorder->get_id ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_nbits__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{nbits} =} __recorder_get_nbits__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_nbits ());
+      retval = recorder->get_nbits ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_sample_number__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __recorder_get_sample_number__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_sample_number ());
+      retval = recorder->get_sample_number ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_tag__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{tag} =} __recorder_get_tag__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_tag ());
+      retval = recorder->get_tag ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_total_samples__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __recorder_get_total_samples__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      retval = octave_value (recorder->get_total_samples ());
+      retval = recorder->get_total_samples ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_userdata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{data} =} __recorder_get_userdata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
       retval = recorder->get_userdata ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_isrecording__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_isrecording__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
-      if (recorder->isrecording ())
-        return octave_value (1);
-      else
-        return octave_value (0);
+      retval = recorder->isrecording () ? true : false;
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_pause__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_pause__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
       recorder->pause ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_recordblocking__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   audiorecorder *recorder = get_recorder (args(0));
   recorder->recordblocking (args(1).float_value ());
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_record__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} __recorder_record__ (@var{recorder})\n\
 @deftypefnx {Loadable Function} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   audiorecorder *recorder = get_recorder (args(0));
+
   if (args.length () == 1)
-    {
-      recorder->record ();
-    }
+    recorder->record ();
   else if (args.length () == 2)
     {
       recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
       recorder->record ();
     }
   else
-    {
-      error ("audiorecorder: wrong number of arguments passed to record");
-    }
+    error ("audiorecorder: wrong number of arguments passed to record");
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_resume__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_resume__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audiorecorder *recorder = get_recorder (args(0));
       recorder->resume ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_fs__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_set_fs__ (@var{recorder}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
       recorder->set_fs (args(1).int_value ());
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_tag__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_set_tag__ (@var{recorder}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
       recorder->set_tag (args(1).char_matrix_value ());
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_set_userdata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_set_userdata__ (@var{recorder}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audiorecorder *recorder = get_recorder (args(0));
       recorder->set_userdata (args(1));
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__recorder_stop__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __recorder_stop__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   audiorecorder *recorder = get_recorder (args(0));
   recorder->stop ();
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_audioplayer__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs})\n\
 @deftypefnx {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits})\n\
 @deftypefnx {Loadable Function} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits}, @var{id})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
+
   int nargin = args.length ();
-  audioplayer* retval = new audioplayer ();
+
+  audioplayer* recorder = new audioplayer ();
+
   bool is_function = args(0).is_string () || args(0).is_function_handle () || args(0).is_inline_function ();
+
   if (is_function)
-    retval->set_y (args(0).function_value ());
+    recorder->set_y (args(0).function_value ());
   else
-    retval->set_y (args(0));
-  retval->set_fs (args(1).int_value ());
+    recorder->set_y (args(0));
+
+  recorder->set_fs (args(1).int_value ());
+
   switch (nargin)
     {
-      case 3:
-        retval->set_nbits (args(2).int_value ());
-        break;
-      case 4:
-        retval->set_nbits (args(2).int_value ());
-        retval->set_id (args(3).int_value ());
-        break;
+    case 3:
+      recorder->set_nbits (args(2).int_value ());
+      break;
+    case 4:
+      recorder->set_nbits (args(2).int_value ());
+      recorder->set_id (args(3).int_value ());
+      break;
     }
+
   if (is_function)
-    retval->init_fn ();
+    recorder->init_fn ();
   else
-    retval->init ();
-  return octave_value (retval);
+    recorder->init ();
+
+  retval = recorder;
+
 #else
-  octave_value retval;
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
+#endif
+
   return retval;
-#endif
 }
 
 static audioplayer *
 get_player (const octave_value& ov)
 {
   const octave_base_value& rep = ov.get_rep ();
 
   octave_base_value *ncrep = const_cast<octave_base_value *> (&rep);
@@ -2089,397 +2218,500 @@ get_player (const octave_value& ov)
 
 DEFUN_DLD (__player_get_channels__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __player_get_channels__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_channels ());
+      retval = player->get_channels ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_fs__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{fs} =} __player_get_fs__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_fs ());
+      retval = player->get_fs ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_id__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{id} =} __player_get_id__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_id ());
+      retval = player->get_id ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_nbits__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{nbits} =} __player_get_nbits__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_nbits ());
+      retval = player->get_nbits ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_sample_number__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __player_get_sample_number__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_sample_number ());
+      retval = player->get_sample_number ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_tag__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{tag} =} __player_get_tag__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_tag ());
+      retval = player->get_tag ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_total_samples__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} __player_get_total_samples__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      retval = octave_value (player->get_total_samples ());
+      retval = player->get_total_samples ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_get_userdata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{data} =} __player_get_userdata__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
       retval = player->get_userdata ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_isplaying__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_isplaying__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
-      if (player->isplaying ())
-        return octave_value (1);
-      else
-        return octave_value (0);
+      retval = player->isplaying () ? true : false;
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_pause__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_pause__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
       player->pause ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_playblocking__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} __player_playblocking__ (@var{player})\n\
 @deftypefnx {Loadable Function} {} __player_playblocking__ (@var{player}, @var{start})\n\
 @deftypefnx {Loadable Function} {} __player_playblocking__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
       player->playblocking ();
     }
   else
     {
       audioplayer *player = get_player (args(0));
       if (args(1).is_matrix_type ())
         {
-          unsigned int start, end;
           RowVector range = args(1).row_vector_value ();
-          start = range.elem (0) - 1;
-          end = range.elem (1) - 1;
+
+          unsigned int start = range.elem (0) - 1;
+          unsigned int end = range.elem (1) - 1;
+
           if (start > player->get_total_samples ()
               || start > end || end > player->get_total_samples ())
-            error ("audioplayer: invalid range specified for playback");
+            {
+              error ("audioplayer: invalid range specified for playback");
+              return retval;
+            }
+
           player->set_sample_number (start);
           player->set_end_sample (end);
         }
       else
         {
-          unsigned int start;
-          start = args(1).int_value () - 1;
+          unsigned int start = args(1).int_value () - 1;
+
           if (start > player->get_total_samples ())
-            error ("audioplayer: invalid range specified for playback");
+            {
+              error ("audioplayer: invalid range specified for playback");
+              return retval;
+            }
+
           player->set_sample_number (start);
         }
+
       player->playblocking ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_play__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} __player_play__ (@var{player})\n\
 @deftypefnx {Loadable Function} {} __player_play__ (@var{player}, @var{start})\n\
 @deftypefnx {Loadable Function} {} __player_play__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
       player->play ();
     }
   else
     {
       audioplayer *player = get_player (args(0));
+
       if (args(1).is_matrix_type ())
         {
-          unsigned int start, end;
           RowVector range = args(1).row_vector_value ();
-          start = range.elem (0) - 1;
-          end = range.elem (1) - 1;
+
+          unsigned int start = range.elem (0) - 1;
+          unsigned int end = range.elem (1) - 1;
+
           if (start > player->get_total_samples ()
               || start > end || end > player->get_total_samples ())
-            error ("audioplayer: invalid range specified for playback");
+            {
+              error ("audioplayer: invalid range specified for playback");
+              return retval;
+            }
+
           player->set_sample_number (start);
           player->set_end_sample (end);
         }
       else
         {
-          unsigned int start;
-          start = args(1).int_value () - 1;
+          unsigned int start = args(1).int_value () - 1;
+
           if (start > player->get_total_samples ())
-            error ("audioplayer: invalid range specified for playback");
+            {
+              error ("audioplayer: invalid range specified for playback");
+              return retval;
+            }
+
           player->set_sample_number (start);
         }
+
       player->play ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_resume__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_resume__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args(0));
       player->resume ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_set_fs__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_set_fs__ (@var{player}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
       player->set_fs (args(1).int_value ());
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_set_tag__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_set_tag__ (@var{player}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
       player->set_tag (args(1).char_matrix_value ());
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_set_userdata__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_set_userdata__ (@var{player}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 2)
+
+  if (args.length () == 2)
     {
       audioplayer *player = get_player (args(0));
       player->set_userdata (args(1));
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
 
 DEFUN_DLD (__player_stop__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __player_stop__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
+
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
+
+  if (args.length () == 1)
     {
       audioplayer *player = get_player (args (0));
       player->stop ();
     }
+
 #else
+
   error ("portaudio not found on your system and thus audio functionality is not present");
+
 #endif
+
   return retval;
 }
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -58,78 +58,103 @@ The optional argument @var{datatype} spe
 If it is @qcode{\"native\"}, then the type of data depends on how the\n\
 data is stored in the audio file.\n\
 \n\
 Read a file and return a specified range of frames in an array of specified type.\n\
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
+
 #ifdef HAVE_SNDFILE
-  Matrix audio;
-  octave_value ret_audio;
-  SNDFILE *file;
+
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 3)
+    {
+      print_usage ();
+      return retval;
+    }
+
+  std::string filename = args(0).string_value ();
+
+  if (error_state)
+    return retval;
+  
   SF_INFO info;
   info.format = 0;
-  int start, end;
-  file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
-  start = 0;
-  end = info.frames;
+  SNDFILE *file = sf_open (filename.c_str (), SFM_READ, &info);
+  int start = 0;
+  int end = info.frames;
   OCTAVE_LOCAL_BUFFER (float, data, info.frames * info.channels);
   sf_read_float (file, data, info.frames * info.channels);
-  if (args.length () == 2 && !args(1).is_string () || args.length () == 3)
+
+  if ((nargin == 2 && ! args(1).is_string ()) || nargin == 3)
     {
       RowVector range = args(1).row_vector_value ();
+
+      if (error_state)
+        return retval;
+
       start = range(0);
       end = range(1);
     }
-  audio.resize (end - start, info.channels);
+
+  Matrix audio (end - start, info.channels);
+
   for (int i = start; i < end; i++)
     {
       for (int channel = 0; channel < info.channels; channel++)
-        {
-          audio(i - start, channel) = data[i * info.channels + channel];
-        }
+        audio(i - start, channel) = data[i * info.channels + channel];
     }
 
-  if (args.length () == 2 && args(1).is_string () || args.length () == 3)
+  octave_value ret_audio;
+
+  if ((nargin == 2 && args(1).is_string ()) || nargin == 3)
     {
       std::string type;
-      if (args.length () == 3)
+      if (nargin == 3)
         type = args(2).string_value ();
       else
         type = args(1).string_value ();
 
+      if (error_state)
+        return retval;
+
       if (type == "native")
         {
           if (info.format & SF_FORMAT_PCM_S8)
-            ret_audio = octave_value ((audio * 127)).int8_array_value ();
+            ret_audio = int8NDArray (audio * 127);
           else if (info.format & SF_FORMAT_PCM_U8)
-            ret_audio = octave_value ((audio * 127 + 127)).uint8_array_value ();
+            ret_audio = uint8NDArray (audio * 127 + 127);
           else if (info.format & SF_FORMAT_PCM_16)
-            ret_audio = octave_value ((audio * 32767)).int16_array_value ();
+            ret_audio = int16NDArray (audio * 32767);
           else if (info.format & SF_FORMAT_PCM_24)
-            ret_audio = octave_value ((audio * 8388608)).int32_array_value ();
+            ret_audio = int32NDArray (audio * 8388608);
           else if (info.format & SF_FORMAT_PCM_32)
-            ret_audio = octave_value ((audio * 2147483648)).int32_array_value ();
+            ret_audio = int32NDArray (audio * 2147483648);
           else
-            ret_audio = octave_value (audio);
+            ret_audio = audio;
         }
       else
-        ret_audio = octave_value (audio);
+        ret_audio = audio;
     }
   else
-    ret_audio = octave_value (audio);
+    ret_audio = audio;
 
-  retval(0) = ret_audio;
   retval(1) = info.samplerate;
+  retval(0) = ret_audio;
+
 #else
+
   error ("sndfile not found on your system and thus audioread is not functional");
+
 #endif
-  return octave_value (retval);
+
+  return retval;
 }
 
 #ifdef HAVE_SNDFILE
 static void
 fill_extension_table (std::map<std::string, int> &table)
 {
   table["wav"] = SF_FORMAT_WAV;
   table["aiff"] = SF_FORMAT_AIFF;
@@ -181,140 +206,188 @@ Quality setting for the Ogg Vorbis compr
 Title for the audio file.\n\
 @item Artist\n\
 Artist name.\n\
 @item Comment\n\
 Comment.\n\
 @end table\n\
 @end deftypefn")
 {
-  octave_scalar_map retval;
+  // FIXME: shouldn't we return something to indicate whether the file
+  // was written successfully?
+
+  octave_value retval;
+
 #ifdef HAVE_SNDFILE
+
+  int nargin = args.length ();
+
+  if (nargin < 3)
+    {
+      print_usage ();
+      return retval;
+    }
+
+  std::string filename = args(0).string_value ();
+
+  if (error_state)
+    return retval;
+
   std::map<std::string, int> extension_to_format;
   fill_extension_table (extension_to_format);
-  std::string filename = args(0).string_value ();
+
   std::string extension = filename.substr (filename.find_last_of (".") + 1);
   std::transform (extension.begin (), extension.end (), extension.begin (), ::tolower);
+
   Matrix audio = args(1).matrix_value ();
+
+  if (error_state)
+    return retval;
+
   SNDFILE *file;
   SF_INFO info;
+
   OCTAVE_LOCAL_BUFFER (float, data, audio.rows () * audio.cols ());
 
   for (int i = 0; i < audio.cols (); i++)
     {
       for (int j = 0; j < audio.rows (); j++)
-        {
-          data[j * audio.cols () + i] = audio(j, i);
-        }
+        data[j * audio.cols () + i] = audio(j, i);
     }
 
   if (extension == "ogg")
     info.format = SF_FORMAT_VORBIS;
   else
     info.format = SF_FORMAT_PCM_16;
 
   std::string title = "";
   std::string artist = "";
   std::string comment = "";
   // Quality is currently unused?
   //
   // float quality = 0.75;
-  for (int i = 3; i < args.length (); i += 2)
+  for (int i = 3; i < nargin; i += 2)
     {
       if (args(i).string_value () == "BitsPerSample")
         {
           int bits = args(i + 1).int_value ();
           if (bits == 8)
             info.format |= SF_FORMAT_PCM_S8;
           else if (bits == 16)
             info.format |= SF_FORMAT_PCM_16;
           else if (bits == 24)
             info.format |= SF_FORMAT_PCM_24;
           else if (bits == 32)
             info.format |= SF_FORMAT_PCM_32;
           else
-            error ("audiowrite: wrong number of bits specified");
+            {
+              error ("audiowrite: wrong number of bits specified");
+              return retval;
+            }
         }
       else if (args(i).string_value () == "BitRate")
         ;
       // Quality is currently unused?
       //
       // else if (args(i).string_value () == "Quality")
       //   quality = args(i + 1).int_value () * 0.01;
       else if (args(i).string_value () == "Title")
         title = args(i + 1).string_value ();
       else if (args(i).string_value () == "Artist")
         artist = args(i + 1).string_value ();
       else if (args(i).string_value () == "Comment")
         comment = args(i + 1).string_value ();
       else
-        error ("audiowrite: wrong argument name");
+        {
+          error ("audiowrite: wrong argument name");
+          return retval;
+        }
     }
+
   info.samplerate = args(2).int_value ();
   info.channels = audio.cols ();
   info.format |= extension_to_format[extension];
+
   file = sf_open (filename.c_str (), SFM_WRITE, &info);
+
   if (title != "")
     sf_set_string (file, SF_STR_TITLE, title.c_str ());
+
   if (artist != "")
     sf_set_string (file, SF_STR_ARTIST, artist.c_str ());
+
   if (comment != "")
     sf_set_string (file, SF_STR_COMMENT, comment.c_str ());
+
   sf_write_float (file, data, audio.rows () * audio.cols ());
   sf_close (file);
-  free (data);
+
 #else
+
   error ("sndfile not found on your system and thus audiowrite is not functional");
+
 #endif
-  return octave_value (retval);
+
+  return retval;
 }
 
 DEFUN_DLD (audioinfo, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{info} =} audioinfo (@var{filename})\n\
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
 {
-  octave_scalar_map retval;
-  if (args.length () != 1 || not args(0).is_string ())
+  octave_value retval;
+
+  if (args.length () != 1)
     {
       print_usage ();
-      return octave_value (retval);
+      return retval;
     }
+
 #ifdef HAVE_SNDFILE
-  Matrix audio;
-  SNDFILE *file;
+
   SF_INFO info;
   info.format = 0;
-  file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
-  retval.assign ("Filename", args(0).string_value ());
-  retval.assign ("CompressionMethod", "");
-  retval.assign ("NumChannels", info.channels);
-  retval.assign ("SampleRate", info.samplerate);
-  retval.assign ("TotalSamples", info.frames);
+  SNDFILE *file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
+
+  octave_scalar_map result;
+
+  result.assign ("Filename", args(0).string_value ());
+  result.assign ("CompressionMethod", "");
+  result.assign ("NumChannels", info.channels);
+  result.assign ("SampleRate", info.samplerate);
+  result.assign ("TotalSamples", info.frames);
+
   double dframes = info.frames;
   double drate = info.samplerate;
-  retval.assign ("Duration", dframes / drate);
+  result.assign ("Duration", dframes / drate);
 
   int bits;
   if (info.format & SF_FORMAT_PCM_S8)
     bits = 8;
   else if (info.format & SF_FORMAT_PCM_U8)
     bits = 8;
   else if (info.format & SF_FORMAT_PCM_16)
     bits = 16;
   else if (info.format & SF_FORMAT_PCM_24)
     bits = 24;
   else if (info.format & SF_FORMAT_PCM_32)
     bits = 32;
   else
     bits = -1;
 
-  retval.assign ("BitsPerSample", bits);
-  retval.assign ("BitRate", -1);
-  retval.assign ("Title", sf_get_string (file, SF_STR_TITLE));
-  retval.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
-  retval.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
+  result.assign ("BitsPerSample", bits);
+  result.assign ("BitRate", -1);
+  result.assign ("Title", sf_get_string (file, SF_STR_TITLE));
+  result.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
+  result.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
+
+  retval = result;
+
 #else
+
   error ("sndfile not found on your system and thus audioinfo is not functional");
+
 #endif
-  return octave_value (retval);
+
+  return retval;
 }
