# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1210067477 14400
#      Tue May 06 05:51:17 2008 -0400
# Node ID 5adeea5de26cd7f8296373403decd50ced80c23b
# Parent  f5268d7045d7eda2ea26029a2d1c30dbf6e999b8
symbol table reporting functions

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,79 @@
 2008-05-06  John W. Eaton  <jwe@octave.org>
 
+	* symtab.h (symbol_table::scope_id_cache): New class.  Use it to
+	replace scope_ids_in_use and scope_ids_free_list.
+	(symbol_table::erase_scope): Call free_scope.
+	(symbol_table::free_scope): Call scope_id_cache::free.
+
+	* ov-fcn.h (octave_function::lock_subfunctions,
+	octave_function::unlock_subfunctions): New virtual functions.
+	(octave_function::lock_subfunctions): Call lock_subfunctions here.
+	(octave_function::unlock_subfunctions): Call unlock_subfunctions here.
+	* ov-usr-fcn.h (octave_user_function::lock_subfunctions,
+	octave_user_function::unlock_subfunctions): New functions.
+
+	* symtab.h (symbol_table::lock_subfunctions,
+	symbol_table::lock_subfunctions,
+	symbol_table::fcn_info::lock_subfunction,
+	symbol_table::fcn_info::unlock_subfunction,
+	symbol_table::fcn_info::fcn_info_rep::lock_subfunction, 
+	symbol_table::fcn_info::fcn_info_rep::unlock_subfunction):	
+	New functions.
+
+	* symtab.h (symbol_table::set_scope, symbol_table::get_instance):
+	Don't set instance unless allocation succeeds.
+	(symbol_table::print_scope, symbol_table::do_print_scope): Delete.
+	(symbol_table::free_scope): Avoid using invalid iterator.
+	(symbol_table::erase_scope): Call free_scope here.
+
+	* ov-fcn-handle.cc (octave_fcn_handle::load_ascii,
+	octave_fcn_handle::load_binary, octave_fcn_handle::load_hdf5):
+	Cache anonymous name here.
+	(octave_fcn_handle::octave_fcn_handle): Move here from
+	ov-fcn-handle.h.  Cache name if function is user-defined.
+
+	* pt-id.cc (tree_identifier::dup): Avoid shadow warning.
+
+	* symtab.h (symbol_table::cache_name, symbol_table::do_cache_name):
+	New functions.
+	(symbol_table::get_instance): Cache top-level name here.
+	* parse.y (finish_function): Call symbol_table::cache_name here.
+
+	* symtab.cc (F__dump_symtab_info__): New function.
+	
+	* symtab.cc (symbol_table::dump, symbol_table::dump_global,
+	symbol_table::dump_functions, symbol_table::do_dump,
+	symbol_table::symbol_record::symbol_record_rep::dump,
+	symobl_table::fcn_info::fcn_info_rep::dump): New functions.
+	* symtab.h: Provide decls.
+	(symtab::scopes, symbol_table::symbol_record::dump,
+	symbol_table::fcn_info::dump): New functions.
+	(symtab::get_instance): New arg, create; if false throw error if
+	instance for given scope is not found.
+
+	* ov-base.cc (octave_base_value::dump): New virtual function.
+	* ov-base.h: Proivde decl.
+	* ov.h (octave_value::dump): New function.
+
+	* ov.h, ov.c (octave_value::function_value): New const version.
+	* ov-base.h, ov-base.cc (octave_base_value::function_value): Likewise.
+	* ov-builtin.h (octave_builtin::function_value): Likewise.
+	* ov-fcn-handle.h (octave_fcn_handle::function_value): Likewise.
+	* ov-mex-fcn.h (octave_mex_function::function_value): Likewise.
+	* ov-usr-fcn.h (octave_user_script::function_value,
+	octave_user_function): Likewise.
+	
+	* symtab.h, symtab.cc: Use consistent naming scheme for iterator
+	typedefs.  Change all uses.
+
+	* variables.cc (F__print_symtab_info__, F__print_symbol_info__):
+	Delete.
+
 	* ov-cell.cc (Fstruct2cell): Handle structure arrays properly.
 
 2008-05-05  David Bateman  <dbateman@free.fr>
 
 	* sysdep.cc (Fputenv): Allow single arg. Alias to setenv.
 
 2008-05-05  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -887,18 +887,19 @@ read_mat5_binary_element (std::istream& 
 	    int parse_status;
 	    octave_value anon_fcn_handle = 
 	      eval_string (fname.substr (4), true, parse_status);
 
 	    if (parse_status == 0)
 	      {
 		octave_fcn_handle *fh = 
 		  anon_fcn_handle.fcn_handle_value ();
+
 		if (fh)
-		  tc = new octave_fcn_handle (fh->fcn_val(), "@<anonymous>");
+		  tc = new octave_fcn_handle (fh->fcn_val (), "@<anonymous>");
 		else
 		  {
 		    error ("load: failed to load anonymous function handle");
 		    goto skip_ahead;
 		  }
 	      }
 	    else
 	      {
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -766,16 +766,27 @@ octave_base_value::function_value (bool 
   octave_function *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::function_value()",
 			  type_name ());
   return retval;
 }
 
+const octave_function *
+octave_base_value::function_value (bool silent) const
+{
+  const octave_function *retval = 0;
+
+  if (! silent)
+    gripe_wrong_type_arg ("octave_base_value::function_value()",
+			  type_name ());
+  return retval;
+}
+
 octave_user_function *
 octave_base_value::user_function_value (bool silent)
 {
   octave_user_function *retval = 0;
 
   if (! silent)
     gripe_wrong_type_arg ("octave_base_value::user_function_value()",
 			  type_name ());
@@ -1006,16 +1017,26 @@ octave_base_value::lock (void)
 }
 
 void
 octave_base_value::unlock (void)
 {
   gripe_wrong_type_arg ("octave_base_value::unlock ()", type_name ());
 }
 
+void
+octave_base_value::dump (std::ostream& os) const
+{
+  dim_vector dv = this->dims ();
+
+  os << "class: " << this->class_name ()
+     << " type: " << this->type_name ()
+     << " dims: " << dv.str ();
+}
+
 static void
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of `%s' to indexed `%s' not implemented",
 	 tn2.c_str (), tn1.c_str ());
 }
 
 static void
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -396,16 +396,18 @@ public:
   virtual string_vector map_keys (void) const;
 
   virtual std::streamoff streamoff_value (void) const;
 
   virtual streamoff_array streamoff_array_value (void) const;
 
   virtual octave_function *function_value (bool silent = false);
 
+  virtual const octave_function *function_value (bool silent = false) const;
+
   virtual octave_user_function *user_function_value (bool silent = false);
 
   virtual octave_user_script *user_script_value (bool silent = false);
 
   virtual octave_user_code *user_code_value (bool silent = false);
 
   virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
 
@@ -475,16 +477,18 @@ public:
 			     sortmode mode = ASCENDING) const;
 
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
+  virtual void dump (std::ostream& os) const;
+
   virtual octave_value abs (void) const;
   virtual octave_value acos (void) const;
   virtual octave_value acosh (void) const;
   virtual octave_value angle (void) const;
   virtual octave_value arg (void) const;
   virtual octave_value asin (void) const;
   virtual octave_value asinh (void) const;
   virtual octave_value atan (void) const;
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -58,16 +58,18 @@ public:
     }
 
   octave_value_list subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
+  const octave_function *function_value (bool = false) const { return this; }
+
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
 protected:
 
   // A pointer to the actual function.
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -60,16 +60,26 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_fcn_handle);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_fcn_handle,
 				     "function handle",
 				     "function_handle");
 
+octave_fcn_handle::octave_fcn_handle (const octave_value& f,
+				      const std::string& n)
+  : warn_reload (true), fcn (f), nm (n)
+{
+  octave_user_function *uf = fcn.user_function_value (true);
+
+  if (uf)
+    symbol_table::cache_name (uf->scope (), nm);
+}
+
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
 			    const std::list<octave_value_list>& idx,
 			    int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
@@ -353,18 +363,26 @@ octave_fcn_handle::load_ascii (std::istr
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (buf.str (), true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = 
 		anon_fcn_handle.fcn_handle_value ();
+
 	      if (fh)
-		fcn = fh->fcn;
+		{
+		  fcn = fh->fcn;
+
+		  octave_user_function *uf = fcn.user_function_value (true);
+
+		  if (uf)
+		    symbol_table::cache_name (uf->scope (), nm);
+		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_ascii_load");
 	}
@@ -514,18 +532,26 @@ octave_fcn_handle::load_binary (std::ist
 
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (ctmp2, true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
+
 	      if (fh)
-		fcn = fh->fcn;
+		{
+		  fcn = fh->fcn;
+
+		  octave_user_function *uf = fcn.user_function_value (true);
+
+		  if (uf)
+		    symbol_table::cache_name (uf->scope (), nm);
+		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_binary_load");
 	}
@@ -963,18 +989,26 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 
 	  int parse_status;
 	  octave_value anon_fcn_handle = 
 	    eval_string (fcn_tmp, true, parse_status);
 
 	  if (parse_status == 0)
 	    {
 	      octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
+
 	      if (fh)
-		fcn = fh->fcn;
+		{
+		  fcn = fh->fcn;
+
+		  octave_user_function *uf = fcn.user_function_value (true);
+
+		  if (uf)
+		    symbol_table::cache_name (uf->scope (), nm);
+		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 
 	  unwind_protect::run_frame ("anon_hdf5_load");
 	}
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -40,18 +40,17 @@ octave_fcn_handle : public octave_base_v
 {
 public:
   octave_fcn_handle (void)
     : warn_reload (true), fcn (), nm () { }
 
   octave_fcn_handle (const std::string& n)
     : warn_reload (true), fcn (), nm (n) { }
 
-  octave_fcn_handle (const octave_value& f,  const std::string& n)
-    : warn_reload (true), fcn (f), nm (n) { }
+  octave_fcn_handle (const octave_value& f,  const std::string& n);
 
   octave_fcn_handle (const octave_fcn_handle& fh)
     : octave_base_value (fh), warn_reload (fh.warn_reload),
       fcn (fh.fcn), nm (fh.nm) { }
 
   ~octave_fcn_handle (void) { }
 
   octave_base_value *clone (void) const { return new octave_fcn_handle (*this); }
@@ -72,16 +71,19 @@ public:
 
   bool is_function_handle (void) const { return true; }
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   octave_function *function_value (bool = false)
     { return fcn.function_value (); }
 
+  const octave_function *function_value (bool = false) const
+    { return fcn.function_value (); }
+
   octave_user_function *user_function_value (bool = false)
     { return fcn.user_function_value (); }
 
   octave_fcn_handle *fcn_handle_value (bool = false) { return this; }
 
   octave_value fcn_val (void) const { return fcn; }
 
   std::string fcn_name (void) const { return nm; }
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -83,22 +83,34 @@ public:
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
   std::string dir_name (void) const { return my_dir_name; }
 
   void stash_dir_name (const std::string& dir) { my_dir_name = dir; }
 
-  void lock (void) { locked = true; }
+  void lock (void)
+  {
+    this->lock_subfunctions ();
+    locked = true;
+  }
 
-  void unlock (void) { locked = false; }
+  void unlock (void)
+  {
+    this->unlock_subfunctions ();
+    locked = false;
+  }
 
   bool islocked (void) const { return locked; }
 
+  virtual void lock_subfunctions (void) { }
+
+  virtual void unlock_subfunctions (void) { }
+
   void mark_relative (void) { relative = true; }
 
   bool is_relative (void) const { return relative; }
 
   std::string name (void) const { return my_name; }
 
   void document (const std::string& ds) { doc = ds; }
 
diff --git a/src/ov-mex-fcn.h b/src/ov-mex-fcn.h
--- a/src/ov-mex-fcn.h
+++ b/src/ov-mex-fcn.h
@@ -58,16 +58,18 @@ public:
     }
 
   octave_value_list subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
+  const octave_function *function_value (bool = false) const { return this; }
+
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
   octave_time time_parsed (void) const;
 
   octave_time time_checked (void) const { return t_checked; }
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -267,16 +267,28 @@ octave_user_function::takes_varargs (voi
 }
 
 bool
 octave_user_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
 }
 
+void
+octave_user_function::lock_subfunctions (void)
+{
+  symbol_table::lock_subfunctions (local_scope);
+}
+
+void
+octave_user_function::unlock_subfunctions (void)
+{
+  symbol_table::unlock_subfunctions (local_scope);
+}
+
 octave_value_list
 octave_user_function::octave_all_va_args (void)
 {
   octave_value_list retval;
 
   int n = num_args_passed - num_named_args;
 
   if (n > 0)
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -86,16 +86,18 @@ public:
 
   octave_user_script (const std::string& fnm, const std::string& nm,
 		      const std::string& ds = std::string ());
 
   ~octave_user_script (void);
 
   octave_function *function_value (bool = false) { return this; }
 
+  const octave_function *function_value (bool = false) const { return this; }
+
   octave_user_script *user_script_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
 
   // Scripts and user functions are both considered "scripts" because
   // they are written in Octave's scripting language.
 
   bool is_user_script (void) const { return true; }
@@ -176,16 +178,18 @@ public:
 			tree_parameter_list *pl = 0,
 			tree_parameter_list *rl = 0,
 			tree_statement_list *cl = 0);
 
   ~octave_user_function (void);
 
   octave_function *function_value (bool = false) { return this; }
 
+  const octave_function *function_value (bool = false) const { return this; }
+
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
@@ -220,16 +224,20 @@ public:
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_user_function (void) const { return true; }
 
   bool takes_varargs (void) const;
 
   bool takes_var_return (void) const;
 
+  void lock_subfunctions (void);
+
+  void unlock_subfunctions (void);
+
   octave_value_list octave_all_va_args (void);
 
   void stash_function_name (const std::string& s) { my_name = s; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
   bool is_nested_function (void) const { return nested_function; }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1140,16 +1140,22 @@ octave_value::streamoff_array_value (voi
 }
 
 octave_function *
 octave_value::function_value (bool silent)
 {
   return rep->function_value (silent);
 }
 
+const octave_function *
+octave_value::function_value (bool silent) const
+{
+  return rep->function_value (silent);
+}
+
 octave_user_function *
 octave_value::user_function_value (bool silent)
 {
   return rep->user_function_value (silent);
 }
 
 octave_user_script *
 octave_value::user_script_value (bool silent)
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -735,16 +735,18 @@ public:
     { return rep->map_keys (); }
 
   std::streamoff streamoff_value (void) const;
 
   streamoff_array streamoff_array_value (void) const;
 
   octave_function *function_value (bool silent = false);
 
+  const octave_function *function_value (bool silent = false) const;
+
   octave_user_function *user_function_value (bool silent = false);
 
   octave_user_script *user_script_value (bool silent = false);
 
   octave_user_code *user_code_value (bool silent = false);
 
   octave_fcn_handle *fcn_handle_value (bool silent = false);
 
@@ -885,16 +887,18 @@ public:
     { return rep->sort (sidx, dim, mode); } 
 
   void lock (void) { rep->lock (); }
 
   void unlock (void) { rep->unlock (); }
 
   bool islocked (void) const { return rep->islocked (); }
 
+  void dump (std::ostream& os) const { rep->dump (os); }
+
 #define MAPPER_FORWARD(F) \
   octave_value F (void) const { return rep->F (); }
 
   MAPPER_FORWARD (abs)
   MAPPER_FORWARD (acos)
   MAPPER_FORWARD (acosh)
   MAPPER_FORWARD (angle)
   MAPPER_FORWARD (arg)
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -2543,25 +2543,32 @@ finish_function (tree_parameter_list *re
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
+      std::string nm = fcn->name ();
+      std::string file = fcn->fcn_file_name ();
+
+      std::string tmp = nm;
+      if (! file.empty ())
+	tmp += ": " + file;
+
+      symbol_table::cache_name (fcn->scope (), tmp);
+
       if (lc)
 	fcn->stash_leading_comment (lc);
 
       fcn->define_ret_list (ret_list);
 
       if (lexer_flags.parsing_nested_function)
 	{
-	  std::string nm = fcn->name ();
-
 	  fcn->mark_as_nested_function ();
 
 	  symbol_table::install_subfunction (nm, octave_value (fcn));
 
 	  if (lexer_flags.parsing_nested_function < 0)
 	    {
 	      lexer_flags.parsing_nested_function = 0;
 	      symbol_table::reset_parent_scope ();
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -118,24 +118,24 @@ octave_lvalue
 tree_identifier::lvalue (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   return octave_lvalue (&(xsym().varref ()));
 }
 
 tree_identifier *
-tree_identifier::dup (symbol_table::scope_id scope)
+tree_identifier::dup (symbol_table::scope_id sc)
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
 
   // FIXME -- is this the best way?
   symbol_table::symbol_record new_sym
-    = symbol_table::find_symbol (xsym().name (), scope);
+    = symbol_table::find_symbol (xsym().name (), sc);
 
   tree_identifier *new_id
     = new tree_identifier (new_sym, line (), column ());
 
   new_id->copy_base (*this);
 
   return new_id;
 }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -40,42 +40,65 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "pt-arg-list.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 symbol_table *symbol_table::instance = 0;
 
+symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
+
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
 
 std::map<std::string, symbol_table::fcn_info> symbol_table::fcn_table;
 
 const symbol_table::scope_id symbol_table::xglobal_scope = 0;
 const symbol_table::scope_id symbol_table::xtop_scope = 1;
 
 symbol_table::scope_id symbol_table::xcurrent_scope = 1;
 symbol_table::scope_id symbol_table::xcurrent_caller_scope = -1;
 
 symbol_table::scope_id symbol_table::xparent_scope = -1;
 
 std::deque<symbol_table::scope_id> symbol_table::scope_stack;
 
-symbol_table::scope_id symbol_table::next_available_scope = 2;
-std::set<symbol_table::scope_id> symbol_table::scope_ids_in_use;
-std::set<symbol_table::scope_id> symbol_table::scope_ids_free_list;
-
 symbol_table::context_id symbol_table::xcurrent_context = 0;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
+void
+symbol_table::symbol_record::symbol_record_rep::dump
+  (std::ostream& os, const std::string& prefix) const
+{
+  octave_value val = varval ();
+
+  os << prefix << name;
+
+  if (val.is_defined ())
+    {
+      os << " ["
+	 << (is_local () ? "l" : "")
+	 << (is_automatic () ? "a" : "")
+	 << (is_formal () ? "f" : "")
+	 << (is_hidden () ? "h" : "")
+	 << (is_inherited () ? "i" : "")
+	 << (is_global () ? "g" : "")
+	 << (is_persistent () ? "p" : "")
+	 << "] ";
+      val.dump (os);
+    }
+
+  os << "\n";
+}
+
 octave_value
 symbol_table::symbol_record::find (tree_argument_list *args,
 				   const string_vector& arg_names,
 				   octave_value_list& evaluated_args,
 				   bool& args_evaluated) const
 {
   octave_value retval;
 
@@ -304,17 +327,17 @@ void
 symbol_table::fcn_info::fcn_info_rep::print_dispatch (std::ostream& os) const
 {
   if (dispatch_map.empty ())
     os << "dispatch: " << name << " is not overloaded" << std::endl;
   else
     {
       os << "Overloaded function " << name << ":\n\n";
 
-      for (const_dispatch_map_iterator p = dispatch_map.begin ();
+      for (dispatch_map_const_iterator p = dispatch_map.begin ();
 	   p != dispatch_map.end (); p++)
 	os << "  " << name << " (" << p->first << ", ...) -> " 
 	   << p->second << " (" << p->first << ", ...)\n";
 
       os << std::endl;
     }
 }
 
@@ -322,17 +345,17 @@ std::string
 symbol_table::fcn_info::fcn_info_rep::help_for_dispatch (void) const
 {
   std::string retval;
 
   if (! dispatch_map.empty ())
     {
       retval = "Overloaded function:\n\n";
 
-      for (const_dispatch_map_iterator p = dispatch_map.begin ();
+      for (dispatch_map_const_iterator p = dispatch_map.begin ();
 	   p != dispatch_map.end (); p++)
 	retval += "  " + p->second + " (" + p->first + ", ...)\n\n";
     }
 
   return retval;
 }
 
 // Find the definition of NAME according to the following precedence
@@ -666,16 +689,85 @@ symbol_table::fcn_info::fcn_info_rep::fi
 	  if (fcn)
 	    function_on_path = octave_value (fcn);
 	}
     }
 
   return function_on_path;
 }
 
+static std::string
+fcn_file_name (const octave_value& fcn)
+{
+  const octave_function *f = fcn.function_value ();
+
+  return f ? f->fcn_file_name () : std::string ();
+}
+
+void
+symbol_table::fcn_info::fcn_info_rep::dump
+  (std::ostream& os, const std::string& prefix) const
+{
+  os << prefix << name
+     << " ["
+     << (cmdline_function.is_defined () ? "c" : "")
+     << (built_in_function.is_defined () ? "b" : "")
+     << "]\n";
+
+  std::string tprefix = prefix + "  ";
+
+  if (autoload_function.is_defined ())
+    os << tprefix << "autoload: "
+       << fcn_file_name (autoload_function) << "\n";
+
+  if (function_on_path.is_defined ())
+    os << tprefix << "function from path: "
+       << fcn_file_name (function_on_path) << "\n";
+
+  if (! subfunctions.empty ())
+    {
+      for (scope_val_const_iterator p = subfunctions.begin ();
+	   p != subfunctions.end (); p++)
+	os << tprefix << "subfunction: " << fcn_file_name (p->second)
+	   << " [" << p->first << "]\n";
+    }
+
+  if (! private_functions.empty ())
+    {
+      for (str_val_const_iterator p = private_functions.begin ();
+	   p != private_functions.end (); p++)
+	os << tprefix << "private: " << fcn_file_name (p->second)
+	   << " [" << p->first << "]\n";
+    }
+
+  if (! class_constructors.empty ())
+    {
+      for (str_val_const_iterator p = class_constructors.begin ();
+	   p != class_constructors.end (); p++)
+	os << tprefix << "constructor: " << fcn_file_name (p->second)
+	   << " [" << p->first << "]\n";
+    }
+
+  if (! class_methods.empty ())
+    {
+      for (str_val_const_iterator p = class_methods.begin ();
+	   p != class_methods.end (); p++)
+	os << tprefix << "method: " << fcn_file_name (p->second)
+	   << " [" << p->first << "]\n";
+    }
+
+  if (! dispatch_map.empty ())
+    {
+      for (dispatch_map_const_iterator p = dispatch_map.begin ();
+	   p != dispatch_map.end (); p++)
+	os << tprefix << "dispatch: " << fcn_file_name (p->second)
+	   << " [" << p->first << "]\n";
+    }
+}
+
 octave_value
 symbol_table::fcn_info::find (tree_argument_list *args,
 			      const string_vector& arg_names,
 			      octave_value_list& evaluated_args,
 			      bool& args_evaluated)
 {
   return rep->find (args, arg_names, evaluated_args, args_evaluated);
 }
@@ -698,33 +790,103 @@ octave_value
 symbol_table::find_function (const std::string& name, tree_argument_list *args,
 			     const string_vector& arg_names,
 			     octave_value_list& evaluated_args,
 			     bool& args_evaluated)
 {
   return find (name, args, arg_names, evaluated_args, args_evaluated, true);
 }
 
+void
+symbol_table::dump (std::ostream& os, scope_id scope)
+{
+  if (scope == xglobal_scope)
+    dump_global (os);
+  else
+    {
+      symbol_table *inst = get_instance (scope, false);
+
+      if (inst)
+	{
+	  os << "*** dumping symbol table scope " << scope
+	     << " (" << inst->table_name << ")\n\n";
+
+	  std::map<std::string, octave_value> sfuns
+	    = symbol_table::subfunctions_defined_in_scope (scope);
+
+	  if (! sfuns.empty ())
+	    {
+	      os << "  subfunctions defined in this scope:\n";
+
+	      for (std::map<std::string, octave_value>::const_iterator p = sfuns.begin ();
+		   p != sfuns.end (); p++)
+		os << "    " << p->first << "\n";
+
+	      os << "\n";
+	    }
+
+
+	  inst->do_dump (os);
+	}
+    }
+}
+
+void
+symbol_table::dump_global (std::ostream& os)
+{
+  if (! global_table.empty ())
+    {
+      os << "*** dumping global symbol table\n\n";
+
+      for (global_table_const_iterator p = global_table.begin ();
+	   p != global_table.end (); p++)
+	{
+	  std::string nm = p->first;
+	  octave_value val = p->second;
+
+	  os << "  " << nm << " ";
+	  val.dump (os);
+	  os << "\n";
+	}
+    }
+}
+
+void
+symbol_table::dump_functions (std::ostream& os)
+{
+  if (! fcn_table.empty ())
+    {
+      os << "*** dumping globally visible functions from symbol table\n"
+	 << "    (c=commandline, b=built-in)\n\n";
+
+      for (fcn_table_const_iterator p = fcn_table.begin ();
+	   p != fcn_table.end (); p++)
+	p->second.dump (os, "  ");
+
+      os << "\n";
+    }
+}
+
 octave_value
 symbol_table::do_find (const std::string& name, tree_argument_list *args,
 		       const string_vector& arg_names,
 		       octave_value_list& evaluated_args,
 		       bool& args_evaluated, bool skip_variables)
 {
   octave_value retval;
 
   // Variable.
 
   if (! skip_variables)
     {
       table_iterator p = table.find (name);
 
       if (p != table.end ())
 	{
-	  symbol_record& sr = p->second;
+	  symbol_record sr = p->second;
 
 	  // FIXME -- should we be using something other than varref here?
 
 	  if (sr.is_global ())
 	    return symbol_table::global_varref (name);
 	  else
 	    {
 	      octave_value& val = sr.varref ();
@@ -755,16 +917,49 @@ symbol_table::do_find (const std::string
 	fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
+void
+symbol_table::do_dump (std::ostream& os)
+{
+  if (! persistent_table.empty ())
+    {
+      os << "  persistent variables in this scope:\n\n";
+
+      for (persistent_table_const_iterator p = persistent_table.begin ();
+	   p != persistent_table.end (); p++)
+	{
+	  std::string nm = p->first;
+	  octave_value val = p->second;
+
+	  os << "    " << nm << " ";
+	  val.dump (os);
+	  os << "\n";
+	}
+
+      os << "\n";
+    }
+
+  if (! table.empty ())
+    {
+      os << "  other symbols in this scope (l=local; a=auto; f=formal\n"
+	 << "    h=hidden; i=inherited; g=global; p=persistent)\n\n";
+
+      for (table_const_iterator p = table.begin (); p != table.end (); p++)
+	p->second.dump (os, "    ");
+
+      os << "\n";
+    }
+}
+
 DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave checks\n\
 the time stamp on files each time it looks up functions defined in\n\
 function files.  If the internal variable is set to @code{\"system\"},\n\
 Octave will not automatically recompile function files in subdirectories of\n\
@@ -818,16 +1013,100 @@ need to recompiled.\n\
 	error ("ignore_function_time_stamp: expecting argument to be character string");
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
+DEFUN (__current_scope__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __dump_symtab_info__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+
+  retval(1) = symbol_table::current_context ();
+  retval(0) = symbol_table::current_scope ();
+
+  return retval;
+}
+
+DEFUN (__dump_symtab_info__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __dump_symtab_info__ ()\n\
+@deftypefnx {Built-in Function} {} __dump_symtab_info__ (@var{scope})\n\
+@deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"scopes\")\n\
+@deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"functions\")\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
+      symbol_table::dump_functions (octave_stdout);
+
+      symbol_table::dump_global (octave_stdout);
+
+      std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
+
+      for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
+	   p != lst.end (); p++)
+	symbol_table::dump (octave_stdout, *p);
+    }
+  else if (nargin == 1)
+    {
+      octave_value arg = args(0);
+
+      if (arg.is_string ())
+	{
+	  std::string s_arg = arg.string_value ();
+
+	  if (s_arg == "scopes")
+	    {
+	      std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
+
+	      RowVector v (lst.size ());
+
+	      octave_idx_type k = 0;
+
+	      for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
+		   p != lst.end (); p++)
+		v.xelem (k++) = *p;
+
+	      retval = v;
+	    }
+	  else if (s_arg == "functions")
+	    {
+	      symbol_table::dump_functions (octave_stdout);
+	    }
+	  else
+	    error ("__dump_symtab_info__: expecting \"functions\" or \"scopes\"");
+	}
+      else
+	{
+	  int s = arg.int_value ();
+
+	  if (! error_state)
+	    symbol_table::dump (octave_stdout, s);
+	  else
+	    error ("__dump_symtab_info__: expecting string or scope id");
+	}
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
 #if 0
 
 // FIXME -- should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
   octave_value retval;
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -42,16 +42,124 @@ OCTINTERP_API
 symbol_table
 {
 public:
 
   typedef int scope_id;
   typedef size_t context_id;
 
   class
+  scope_id_cache
+  {
+  protected:
+
+    typedef std::set<scope_id>::iterator set_iterator;
+    typedef std::set<scope_id>::const_iterator set_const_iterator;
+
+    // We start with 2 because we allocate 0 for the global symbols
+    // and 1 for the top-level workspace.
+
+    scope_id_cache (void) : next_available (2), in_use (), free_list () { }
+
+  public:
+
+    ~scope_id_cache (void) { }
+
+    static scope_id alloc (void)
+    {
+      return instance_ok () ? instance->do_alloc () : -1;
+    }
+
+    static void free (scope_id scope)
+    {
+      if (instance_ok ())
+	return instance->do_free (scope);
+    }
+
+    static std::list<scope_id> scopes (void)
+    {
+      return instance_ok () ? instance->do_scopes () : std::list<scope_id> ();
+    }
+
+    static bool instance_ok (void)
+    {
+      bool retval = true;
+
+      if (! instance)
+	instance = new scope_id_cache ();
+
+      if (! instance)
+	{
+	  ::error ("unable to create scope_id_cache object!");
+
+	  retval = false;
+	}
+
+      return retval;
+    }
+
+  private:
+
+    static scope_id_cache *instance;
+
+    // The next available scope not in the free list.
+    scope_id next_available;
+
+    // The set of scope IDs that are currently allocated.
+    std::set<scope_id> in_use;
+
+    // The set of scope IDs that are currently available.
+    std::set<scope_id> free_list;
+
+    scope_id do_alloc (void)
+    {
+      scope_id retval;
+
+      set_iterator p = free_list.begin ();
+
+      if (p != free_list.end ())
+	{
+	  retval = *p;
+	  free_list.erase (p);
+	}
+      else
+	retval = next_available++;
+
+      in_use.insert (retval);
+
+      return retval;
+    }
+
+    void do_free (scope_id scope)
+    {
+      set_iterator p = in_use.find (scope);
+
+      if (p != in_use.end ())
+	{
+	  in_use.erase (p);
+	  free_list.insert (scope);
+	}
+      else
+	error ("free_scope: scope %d not found!", scope);
+    }
+
+    std::list<scope_id> do_scopes (void) const
+    {
+      std::list<scope_id> retval;
+
+      for (set_const_iterator p = in_use.begin (); p != in_use.end (); p++)
+	retval.push_back (*p);
+
+      retval.sort ();
+
+      return retval;
+    }
+  };
+
+  class
   symbol_record
   {
   public:
 
     // generic variable
     static const unsigned int local = 1;
 
     // varargin, argn, .nargin., .nargout.
@@ -230,16 +338,18 @@ public:
 	symbol_table::erase_persistent (name);
       }
 
       symbol_record_rep *dup (void)
       {
 	return new symbol_record_rep (name, varval (), storage_class);
       }
 
+      void dump (std::ostream& os, const std::string& prefix) const;
+
       std::string name;
 
       std::deque<octave_value> value_stack;
 
       unsigned int storage_class;
 
       size_t count;
 
@@ -328,37 +438,43 @@ public:
     void unmark_persistent (void) { rep->unmark_persistent (); }
 
     void init_persistent (void) { rep->init_persistent (); }
 
     void erase_persistent (void) { rep->erase_persistent (); }
 
     unsigned int xstorage_class (void) const { return rep->storage_class; }
 
+    void
+    dump (std::ostream& os, const std::string& prefix = std::string ()) const
+    {
+      rep->dump (os, prefix);
+    }
+
   private:
 
     symbol_record_rep *rep;
 
     symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
   };
 
   class
   fcn_info
   {
   public:
 
     typedef std::map<std::string, std::string> dispatch_map_type;
 
-    typedef std::map<scope_id, octave_value>::const_iterator const_scope_val_iterator;
+    typedef std::map<scope_id, octave_value>::const_iterator scope_val_const_iterator;
     typedef std::map<scope_id, octave_value>::iterator scope_val_iterator;
 
-    typedef std::map<std::string, octave_value>::const_iterator const_str_val_iterator;
+    typedef std::map<std::string, octave_value>::const_iterator str_val_const_iterator;
     typedef std::map<std::string, octave_value>::iterator str_val_iterator;
 
-    typedef dispatch_map_type::const_iterator const_dispatch_map_iterator;
+    typedef dispatch_map_type::const_iterator dispatch_map_const_iterator;
     typedef dispatch_map_type::iterator dispatch_map_iterator;
 
   private:
 
     class
     fcn_info_rep
     {
     public:
@@ -401,16 +517,42 @@ public:
       {
 	string_vector arg_names;
 	octave_value_list evaluated_args = args;
 	bool args_evaluated = false;
 
 	return find (0, arg_names, evaluated_args, args_evaluated);
       }
 
+      void lock_subfunction (scope_id scope)
+      {
+	scope_val_iterator p = subfunctions.find (scope);
+
+	if (p != subfunctions.end ())
+	  p->second.lock ();
+      }
+
+      void unlock_subfunction (scope_id scope)
+      {
+	scope_val_iterator p = subfunctions.find (scope);
+
+	if (p != subfunctions.end ())
+	  p->second.unlock ();
+      }
+
+      std::pair<std::string, octave_value>
+      subfunction_defined_in_scope (scope_id scope) const
+      {
+	scope_val_const_iterator p = subfunctions.find (scope);
+
+	return p == subfunctions.end ()
+	  ? std::pair<std::string, octave_value> ()
+	  : std::pair<std::string, octave_value> (name, p->second);
+      }	     
+
       void install_cmdline_function (const octave_value& f)
       {
 	cmdline_function = f;
       }
 
       void install_subfunction (const octave_value& f, scope_id scope)
       {
 	subfunctions[scope] = f;
@@ -492,16 +634,18 @@ public:
       }
 
       void print_dispatch (std::ostream& os) const;
 
       std::string help_for_dispatch (void) const;
 
       dispatch_map_type get_dispatch (void) const { return dispatch_map; }
 
+      void dump (std::ostream& os, const std::string& prefix) const;
+
       std::string name;
 
       // Scope id to function object.
       std::map<scope_id, octave_value> subfunctions;
 
       // Directory name to function object.
       std::map<std::string, octave_value> private_functions;
 
@@ -594,16 +738,32 @@ public:
       return rep->find_function ();
     }
 
     octave_value find_function (const octave_value_list& args)
     {
       return rep->find_function (args);
     }
 
+    void lock_subfunction (scope_id scope)
+    {
+      rep->lock_subfunction (scope);
+    }
+
+    void unlock_subfunction (scope_id scope)
+    {
+      rep->unlock_subfunction (scope);
+    }
+
+    std::pair<std::string, octave_value>
+    subfunction_defined_in_scope (scope_id scope = xcurrent_scope) const
+    {
+      return rep->subfunction_defined_in_scope (scope);
+    }	     
+
     void install_cmdline_function (const octave_value& f)
     {
       rep->install_cmdline_function (f);
     }
 
     void install_subfunction (const octave_value& f, scope_id scope)
     {
       rep->install_subfunction (f, scope);
@@ -642,64 +802,54 @@ public:
 
     std::string help_for_dispatch (void) const { return rep->help_for_dispatch (); }
 
     dispatch_map_type get_dispatch (void) const
     {
       return rep->get_dispatch ();
     }
 
+    void
+    dump (std::ostream& os, const std::string& prefix = std::string ()) const
+    {
+      rep->dump (os, prefix);
+    }
+
   private:
 
     fcn_info_rep *rep;
   };
 
   static scope_id global_scope (void) { return xglobal_scope; }
   static scope_id top_scope (void) { return xtop_scope; }
 
   static scope_id current_scope (void) { return xcurrent_scope; }
   static scope_id current_caller_scope (void) { return xcurrent_caller_scope; }
 
   static context_id current_context (void) { return xcurrent_context; }
 
   // We use parent_scope to handle parsing subfunctions.
   static scope_id parent_scope (void) { return xparent_scope; }
 
-  static scope_id alloc_scope (void)
-  {
-    scope_id retval;
-
-    scope_ids_free_list_iterator p = scope_ids_free_list.begin ();
-
-    if (p != scope_ids_free_list.end ())
-      {
-	retval = *p;
-	scope_ids_free_list.erase (p);
-      }
-    else
-      retval = next_available_scope++;
-
-    scope_ids_in_use.insert (retval);
-
-    return retval;
-  }
+  static scope_id alloc_scope (void) { return scope_id_cache::alloc (); }
 
   static void set_scope (scope_id scope)
   {
     if (scope == xglobal_scope)
       error ("can't set scope to global");
     else if (scope != xcurrent_scope)
       {
 	all_instances_iterator p = all_instances.find (scope);
 
 	if (p == all_instances.end ())
 	  {
-	    instance = new symbol_table ();
-
-	    all_instances[scope] = instance;
+	    symbol_table *inst = new symbol_table ();
+
+	    if (inst)
+	      all_instances[scope] = instance = inst;
 	  }
 	else
 	  instance = p->second;
 
 	xcurrent_scope = scope;
 	xcurrent_context = instance->xcurrent_context_this_table;
       }
   }
@@ -775,19 +925,23 @@ public:
 
   static void erase_scope (scope_id scope)
   {
     assert (scope != xglobal_scope);
 
     all_instances_iterator p = all_instances.find (scope);
 
     if (p != all_instances.end ())
-      all_instances.erase (p);
-
-    // free_scope (scope);
+      {
+	delete p->second;
+
+	all_instances.erase (p);
+
+	free_scope (scope);
+      }
   }
 
   static scope_id dup_scope (scope_id scope)
   {
     scope_id retval = -1;
 
     symbol_table *inst = get_instance (scope);
 
@@ -805,40 +959,20 @@ public:
 
 	    retval = new_scope;
 	  }
       }
 
     return retval;
   }
 
-#if 0
-  static void print_scope (const std::string& tag)
-  {
-    symbol_table *inst = get_instance (xcurrent_scope);
-
-    if (inst)
-      inst->do_print_scope (std::cerr);
-  }
-
-  void do_print_scope (std::ostream& os) const
+  static std::list<scope_id> scopes (void)
   {
-    for (const_table_iterator p = table.begin (); p != table.end (); p++)
-      {
-	symbol_record sr = p->second;
-
-	octave_value val = sr.varval ();
-
-	if (val.is_defined ())
-	  sr.varval ().print_with_name (os, sr.name ());
-	else
-	  os << sr.name () << " is not defined" << std::endl;
-      }
+    return scope_id_cache::scopes ();
   }
-#endif
 
   static symbol_record
   find_symbol (const std::string& name, scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_find_symbol (name) : symbol_record ();
   }
@@ -894,17 +1028,17 @@ public:
     global_table_iterator p = global_table.find (name);
 
     return (p == global_table.end ()) ? global_table[name] : p->second;
   }
 
   static octave_value
   global_varval (const std::string& name)
   {
-    const_global_table_iterator p = global_table.find (name);
+    global_table_const_iterator p = global_table.find (name);
 
     return (p != global_table.end ()) ? p->second : octave_value ();
   }
 
   static octave_value& persistent_varref (const std::string& name)
   {
     static octave_value foobar;
 
@@ -941,17 +1075,17 @@ public:
     octave_value val = find_built_in_function (name);
 
     return val.is_defined ();
   }
 
   static octave_value
   find_method (const std::string& name, const std::string& dispatch_type)
   {
-    const_fcn_table_iterator p = fcn_table.find (name);
+    fcn_table_const_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       return p->second.find_method (dispatch_type);
     else
       {
 	fcn_info finfo (name);
 
 	octave_value fcn = finfo.find_method (dispatch_type);
@@ -961,17 +1095,17 @@ public:
 
 	return fcn;
       }
   }
 
   static octave_value
   find_built_in_function (const std::string& name)
   {
-    const_fcn_table_iterator p = fcn_table.find (name);
+    fcn_table_const_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
       ? p->second.find_built_in_function () : octave_value ();
   }
 
   static octave_value
   find_autoload (const std::string& name)
   {
@@ -1378,17 +1512,17 @@ public:
 
   static std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
-    for (const_global_table_iterator p = global_table.begin ();
+    for (global_table_const_iterator p = global_table.begin ();
 	 p != global_table.end (); p++)
       {
 	// We generate a list of symbol_record objects so that
 	// the results from glob_variables and glob_global_variables
 	// may be handled the same way.
 
 	if (pat.match (p->first))
 	  retval.push_back (symbol_record (p->first, p->second,
@@ -1430,17 +1564,17 @@ public:
 
     return retval;
   }
 
   static std::list<std::string> global_variable_names (void)
   {
     std::list<std::string> retval;
 
-    for (const_global_table_iterator p = global_table.begin ();
+    for (global_table_const_iterator p = global_table.begin ();
 	 p != global_table.end (); p++)
       retval.push_back (p->first);
 
     retval.sort ();
 
     return retval;
   }
 
@@ -1457,17 +1591,17 @@ public:
 
     return inst ? inst->do_variable_names () : std::list<std::string> ();
   }
 
   static std::list<std::string> built_in_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (const_fcn_table_iterator p = fcn_table.begin ();
+    for (fcn_table_const_iterator p = fcn_table.begin ();
 	 p != fcn_table.end (); p++)
       {
 	octave_value fcn = p->second.find_built_in_function ();
 
 	if (fcn.is_defined ())
 	  retval.push_back (p->first);
       }
 
@@ -1496,38 +1630,72 @@ public:
     else
       {
 	symbol_table *inst = get_instance (xcurrent_scope);
 
 	return inst ? inst->do_is_global (name) : false;
       }
   }
 
+  static void dump (std::ostream& os, scope_id scope = xcurrent_scope);
+
+  static void dump_global (std::ostream& os);
+
+  static void dump_functions (std::ostream& os);
+
+  static void cache_name (scope_id scope, const std::string& name)
+  {
+    symbol_table *inst = get_instance (scope, false);
+
+    if (inst)
+      inst->do_cache_name (name);
+  }
+
+  static void lock_subfunctions (scope_id scope = xcurrent_scope)
+  {
+    for (fcn_table_iterator p = fcn_table.begin ();
+	 p != fcn_table.end (); p++)
+      p->second.lock_subfunction (scope);
+  }    
+
+  static void unlock_subfunctions (scope_id scope = xcurrent_scope)
+  {
+    for (fcn_table_iterator p = fcn_table.begin ();
+	 p != fcn_table.end (); p++)
+      p->second.unlock_subfunction (scope);
+  }    
+
+  static void free_scope (scope_id scope)
+  {
+    if (scope == xglobal_scope || scope == xtop_scope)
+      error ("can't free global or top-level scopes!");
+    else
+      symbol_table::scope_id_cache::free (scope);
+  }
+
 private:
 
-  typedef std::map<std::string, symbol_record>::const_iterator const_table_iterator;
+  typedef std::map<std::string, symbol_record>::const_iterator table_const_iterator;
   typedef std::map<std::string, symbol_record>::iterator table_iterator;
 
-  typedef std::map<std::string, octave_value>::const_iterator const_global_table_iterator;
+  typedef std::map<std::string, octave_value>::const_iterator global_table_const_iterator;
   typedef std::map<std::string, octave_value>::iterator global_table_iterator;
 
-  typedef std::map<std::string, octave_value>::const_iterator const_persistent_table_iterator;
+  typedef std::map<std::string, octave_value>::const_iterator persistent_table_const_iterator;
   typedef std::map<std::string, octave_value>::iterator persistent_table_iterator;
 
   typedef std::map<scope_id, symbol_table*>::const_iterator all_instances_const_iterator;
   typedef std::map<scope_id, symbol_table*>::iterator all_instances_iterator;
 
-  typedef std::map<std::string, fcn_info>::const_iterator const_fcn_table_iterator;
+  typedef std::map<std::string, fcn_info>::const_iterator fcn_table_const_iterator;
   typedef std::map<std::string, fcn_info>::iterator fcn_table_iterator;
 
-  typedef std::set<scope_id>::const_iterator scope_ids_free_list_const_iterator;
-  typedef std::set<scope_id>::iterator scope_ids_free_list_iterator;
-
-  typedef std::set<scope_id>::const_iterator scope_ids_in_use_const_iterator;
-  typedef std::set<scope_id>::iterator scope_ids_in_use_iterator;
+  // Name for this table (usually the file name of the function
+  // corresponding to the scope);
+  std::string table_name;
 
   // Map from symbol names to symbol info.
   std::map<std::string, symbol_record> table;
 
   // Map from names of global variables to values.
   static std::map<std::string, octave_value> global_table;
 
   // Map from names of persistent variables to values.
@@ -1553,94 +1721,88 @@ private:
   static scope_id xparent_scope;
 
   // Used to handle recursive calls.
   context_id xcurrent_context_this_table;
   static context_id xcurrent_context;
 
   static std::deque<scope_id> scope_stack;
 
-  // The next available scope ID.
-  static scope_id next_available_scope;
-
-  // The set of scope IDs that are currently allocated.
-  static std::set<scope_id> scope_ids_in_use;
-
-  // The set of scope IDs that are currently available.
-  static std::set<scope_id> scope_ids_free_list;
-
-  symbol_table (void) : table (), xcurrent_context_this_table () { }
+  symbol_table (void)
+    : table_name (), table (), xcurrent_context_this_table () { }
 
   ~symbol_table (void) { }
 
-  static void free_scope (scope_id scope)
-  {
-    if (scope == xglobal_scope || scope == xtop_scope)
-      error ("can't free global or top-level scopes!");
-    else
-      {
-	scope_ids_in_use_iterator p = scope_ids_in_use.find (scope);
-
-	if (p != scope_ids_in_use.end ())
-	  {
-	    scope_ids_in_use.erase (p);
-	    scope_ids_free_list.insert (*p);
-	  }
-	else
-	  error ("scope id = %ld not found!", scope);
-      }
-  }
-
-  static symbol_table *get_instance (scope_id scope)
+  static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
+    bool ok = true;
+
     if (scope != xglobal_scope)
       {
 	if (scope == xcurrent_scope)
 	  {
-	    if (! instance)
+	    if (! instance && create)
 	      {
-		instance = new symbol_table ();
-
-		all_instances[scope] = instance;
+		symbol_table *inst = new symbol_table ();
+
+		if (inst)
+		  {
+		    all_instances[scope] = instance = inst;
+
+		    if (scope == xtop_scope)
+		      instance->do_cache_name ("top-level");
+		  }
 	      }
 
 	    if (! instance)
-	      error ("unable to create symbol_table object!");
+	      ok = false;
 
 	    retval = instance;
 	  }
 	else
 	  {
 	    all_instances_iterator p = all_instances.find (scope);
 
 	    if (p == all_instances.end ())
 	      {
-		retval = new symbol_table ();
-
-		all_instances[scope] = retval;
+		if (create)
+		  {
+		    retval = new symbol_table ();
+
+		    if (retval)
+		      all_instances[scope] = retval;
+		    else
+		      ok = false;
+		  }
+		else
+		  ok = false;
 	      }
 	    else
 	      retval = p->second;
 	  }
       }
 
+    if (! ok)
+      error ("unable to %s symbol_table object for scope %d!",
+	     create ? "create" : "find", scope);
+
     return retval;
   }
 
   void insert_symbol_record (const symbol_record& sr)
   {
     table[sr.name ()] = sr;
   }
 
   void
   do_dup_scope (symbol_table& new_symbol_table) const
   {
-    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+    for (table_const_iterator p = table.begin (); p != table.end (); p++)
       new_symbol_table.insert_symbol_record (p->second.dup ());
   }
 
   symbol_record do_find_symbol (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
@@ -1696,49 +1858,49 @@ private:
 	return sr.varref ();
       }
     else
       return p->second.varref ();
   }
 
   octave_value do_varval (const std::string& name) const
   {
-    const_table_iterator p = table.find (name);
+    table_const_iterator p = table.find (name);
 
     return (p != table.end ()) ? p->second.varval () : octave_value ();
   }
 
   octave_value& do_persistent_varref (const std::string& name)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     return (p == persistent_table.end ())
       ? persistent_table[name] : p->second;
   }
 
   octave_value do_persistent_varval (const std::string& name)
   {
-    const_persistent_table_iterator p = persistent_table.find (name);
+    persistent_table_const_iterator p = persistent_table.find (name);
 
     return (p != persistent_table.end ()) ? p->second : octave_value ();
   }
 
   void do_erase_persistent (const std::string& name)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     if (p != persistent_table.end ())
       persistent_table.erase (p);
   }
 
   bool do_is_variable (const std::string& name) const
   {
     bool retval = false;
 
-    const_table_iterator p = table.find (name);
+    table_const_iterator p = table.find (name);
 
     if (p != table.end ())
       {
 	const symbol_record& sr = p->second;
 
 	retval = sr.is_variable ();
       }
 
@@ -1854,17 +2016,17 @@ private:
     if (p != table.end ())
       p->second.mark_global ();
   }
 
   std::list<symbol_record> do_all_variables (bool defined_only) const
   {
     std::list<symbol_record> retval;
 
-    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+    for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
 	const symbol_record& sr = p->second;
 
 	if (defined_only && ! sr.is_defined ())
 	  continue;
 
 	retval.push_back (sr);
       }
@@ -1874,17 +2036,17 @@ private:
 
   std::list<symbol_record> do_glob (const std::string& pattern,
 				    bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
-    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+    for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
 	if (pat.match (p->first))
 	  {
 	    const symbol_record& sr = p->second;
 
 	    if (vars_only && ! sr.is_variable ())
 	      continue;
 
@@ -1894,39 +2056,63 @@ private:
 
     return retval;
   }
 
   std::list<std::string> do_variable_names (void)
   {
     std::list<std::string> retval;
 
-    for (const_table_iterator p = table.begin (); p != table.end (); p++)
+    for (table_const_iterator p = table.begin (); p != table.end (); p++)
       retval.push_back (p->first);
 
     retval.sort ();
 
     return retval;
   }
 
+  static std::map<std::string, octave_value>
+  subfunctions_defined_in_scope (scope_id scope = xcurrent_scope)
+  {
+    std::map<std::string, octave_value> retval;
+
+    for (fcn_table_const_iterator p = fcn_table.begin ();
+	 p != fcn_table.end (); p++)
+      {
+	std::pair<std::string, octave_value> tmp
+	  = p->second.subfunction_defined_in_scope (scope);
+
+	std::string nm = tmp.first;
+
+	if (! nm.empty ())
+	  retval[nm] = tmp.second;
+      }
+
+    return retval;
+  }
+
   bool do_is_local_variable (const std::string& name) const
   {
-    const_table_iterator p = table.find (name);
+    table_const_iterator p = table.find (name);
 
     return (p != table.end ()
 	    && ! p->second.is_global ()
 	    && p->second.is_defined ());
   }
 
   bool do_is_global (const std::string& name) const
   {
-    const_table_iterator p = table.find (name);
+    table_const_iterator p = table.find (name);
 
     return p != table.end () && p->second.is_global ();
   }
+
+  void do_dump (std::ostream& os);
+
+  void do_cache_name (const std::string& name) { table_name = name; }
 };
 
 extern bool out_of_date_check (octave_value& function);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -2370,44 +2370,16 @@ without the dash as well.\n\
 		}
 	    }
 	}
     }
 
   return retval;
 }
 
-DEFUN (__print_symtab_info__, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __print_symtab_info__ ()\n\
-Undocumented internal function.\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  // FIXME -- what should this function do now?  Print a summary for
-  // each scope?  Print the entire symbol table?  Accept a scope
-  // argument?
-
-  return retval;
-}
-
-DEFUN (__print_symbol_info__, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __dump_symbol_info__ (@var{name})\n\
-Undocumented internal function.\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  // FIXME -- what should this function do now?
-
-  return retval;
-}
-
 DEFUN (whos_line_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} whos_line_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
 Query or set the format string used by the @code{whos}.\n\
 \n\
 The following escape sequences may be used in the format:\n\
 @table @code\n\
