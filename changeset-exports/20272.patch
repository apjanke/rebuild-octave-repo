# HG changeset patch
# User Rik <rik@octave.org>
# Date 1435016439 25200
#      Mon Jun 22 16:40:39 2015 -0700
# Node ID c2206fda3986c552a41b62e9e53d7e54c9258199
# Parent  ae68b331d6e493d7bd98550a280b0ed396551eb5
graphics.cc: Clean up variable names, line wrapping, comments, etc.
Try to use meaningful, and consistent variables names.

* graphics.cc: Clean up variable names, line wrapping, comments, etc.

diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -139,22 +139,20 @@ jet_colormap (void)
   Matrix cmap (64, 3, 0.0);
 
   // Produce X in the same manner as linspace so that
   // jet_colormap and jet.m produce *exactly* the same result.
   double delta = 1.0 / 63.0;
 
   for (octave_idx_type i = 0; i < 64; i++)
     {
-      // This is the jet colormap.  It would be nice to be able
-      // to feval the jet function but since there is a static
-      // property object that includes a colormap_property
-      // object, we need to initialize this before main is even
-      // called, so calling an interpreted function is not
-      // possible.
+      // This is the jet colormap.  It would be nice to be able to feval the
+      // jet function but since there is a static property object that includes
+      // a colormap_property object, we need to initialize this before main is
+      // even called, so calling an interpreted function is not possible.
 
       double x = i*delta;
 
       if (x >= 3.0/8.0 && x < 5.0/8.0)
         cmap(i,0) = 4.0 * x - 3.0/2.0;
       else if (x >= 5.0/8.0 && x < 7.0/8.0)
         cmap(i,0) = 1.0;
       else if (x >= 7.0/8.0)
@@ -182,18 +180,20 @@ static double
 default_screendepth (void)
 {
   return display_info::depth ();
 }
 
 static Matrix
 default_screensize (void)
 {
-  Matrix retval (1, 4, 1.0);
-
+  Matrix retval (1, 4);
+
+  retval(0) = 1.0;
+  retval(1) = 1.0;
   retval(2) = display_info::width ();
   retval(3) = display_info::height ();
 
   return retval;
 }
 
 static double
 default_screenpixelsperinch (void)
@@ -226,25 +226,28 @@ default_colororder (void)
   retval(6,2) = 0.25;
 
   return retval;
 }
 
 static Matrix
 default_lim (bool logscale = false)
 {
-  Matrix m (1, 2, 0);
+  Matrix m (1, 2);
 
   if (logscale)
     {
       m(0) = 0.1;
       m(1) = 1.0;
     }
   else
-    m(1) = 1;
+    {
+      m(0) = 0.0;
+      m(1) = 1.0;
+    }
 
   return m;
 }
 
 static Matrix
 default_data (void)
 {
   Matrix retval (1, 2);
@@ -253,208 +256,242 @@ default_data (void)
   retval(1) = 1;
 
   return retval;
 }
 
 static Matrix
 default_image_cdata (void)
 {
-  Matrix m (64, 64, 0.0);
+  Matrix m (64, 64);
+
   int i = 0;
   for (int col = 0; col < 64; col++)
     for (int row = 0; row < 64; row++)
       {
         m(col,row) = static_cast<double> (default_im_data[i]);
         i++;
       }
 
   return m;
 }
 
 static Matrix
 default_surface_xdata (void)
 {
-  Matrix m (3, 3, 0.0);
+  Matrix m (3, 3);
+
   for (int col = 0; col < 3; col++)
     for (int row = 0; row < 3; row++)
       m(row,col) = col+1;
 
   return m;
 }
 
 static Matrix
 default_surface_ydata (void)
 {
-  Matrix m (3, 3, 0.0);
+  Matrix m (3, 3);
+
   for (int row = 0; row < 3; row++)
     for (int col = 0; col < 3; col++)
       m(row,col) = row+1;
 
   return m;
 }
 
 static Matrix
 default_surface_zdata (void)
 {
   Matrix m (3, 3, 0.0);
+
   for (int row = 0; row < 3; row++)
     m(row,row) = 1.0;
+
   return m;
 }
 
 static Matrix
 default_surface_cdata (void)
 {
   return default_surface_zdata ();
 }
 
 static Matrix
 default_patch_faces (void)
 {
-  Matrix m (1, 3, 1.0);
+  Matrix m (1, 3);
+
+  m(0) = 1.0;
   m(1) = 2.0;
   m(2) = 3.0;
+
   return m;
 }
 
 static Matrix
 default_patch_vertices (void)
 {
-  Matrix m (3, 2, 0);
+  Matrix m (3, 2, 0.0);
+
   m(1) = 1.0;
   m(3) = 1.0;
   m(4) = 1.0;
+
   return m;
 }
 
 static Matrix
 default_patch_xdata (void)
 {
   Matrix m (3, 1, 0.0);
+
   m(1) = 1.0;
+
   return m;
 }
 
 static Matrix
 default_patch_ydata (void)
 {
   Matrix m (3, 1, 1.0);
+
   m(2) = 0.0;
+
   return m;
 }
 
 static Matrix
 default_axes_position (void)
 {
-  Matrix m (1, 4, 0.0);
+  Matrix m (1, 4);
+
   m(0) = 0.13;
   m(1) = 0.11;
   m(2) = 0.775;
   m(3) = 0.815;
+
   return m;
 }
 
 static Matrix
 default_axes_outerposition (void)
 {
-  Matrix m (1, 4, 0.0);
-  m(2) = m(3) = 1.0;
+  Matrix m (1, 4);
+
+  m(0) = 0.0;
+  m(1) = 0.0;
+  m(2) = 1.0;
+  m(3) = 1.0;
+
   return m;
 }
 
 static Matrix
 default_axes_view (void)
 {
-  Matrix m (1, 2, 0.0);
+  Matrix m (1, 2);
+
+  m(0) = 0.0;
   m(1) = 90.0;
+
   return m;
 }
 
 static Matrix
 default_axes_tick (void)
 {
-  Matrix m (1, 6, 0.0);
+  Matrix m (1, 6);
+
   m(0) = 0.0;
   m(1) = 0.2;
   m(2) = 0.4;
   m(3) = 0.6;
   m(4) = 0.8;
   m(5) = 1.0;
+
   return m;
 }
 
 static Matrix
 default_axes_ticklength (void)
 {
-  Matrix m (1, 2, 0.0);
+  Matrix m (1, 2);
+
   m(0) = 0.01;
   m(1) = 0.025;
+
   return m;
 }
 
 static Matrix
 default_figure_position (void)
 {
-  Matrix m (1, 4, 0.0);
+  Matrix m (1, 4);
+
   m(0) = 300;
   m(1) = 200;
   m(2) = 560;
   m(3) = 420;
+
   return m;
 }
 
 static Matrix
 default_figure_papersize (void)
 {
-  Matrix m (1, 2, 0.0);
+  Matrix m (1, 2);
+
   m(0) = 8.5;
   m(1) = 11.0;
+
   return m;
 }
 
 static Matrix
 default_figure_paperposition (void)
 {
-  Matrix m (1, 4, 0.0);
+  Matrix m (1, 4);
+
   m(0) = 0.25;
   m(1) = 2.50;
   m(2) = 8.00;
   m(3) = 6.00;
+
   return m;
 }
 
 static Matrix
 default_control_position (void)
 {
-  Matrix retval (1, 4, 0.0);
+  Matrix retval (1, 4);
 
   retval(0) = 0;
   retval(1) = 0;
   retval(2) = 80;
   retval(3) = 30;
 
   return retval;
 }
 
 static Matrix
 default_control_sliderstep (void)
 {
-  Matrix retval (1, 2, 0.0);
+  Matrix retval (1, 2);
 
   retval(0) = 0.01;
   retval(1) = 0.1;
 
   return retval;
 }
 
 static Matrix
 default_panel_position (void)
 {
-  Matrix retval (1, 4, 0.0);
+  Matrix retval (1, 4);
 
   retval(0) = 0;
   retval(1) = 0;
   retval(2) = 1;
   retval(3) = 1;
 
   return retval;
 }
@@ -543,17 +580,17 @@ convert_position (const Matrix& pos, con
   else if (from_units.compare ("characters"))
     {
       if (res <= 0)
         res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
 
       // FIXME: this assumes the system font is Helvetica 10pt
-      //          (for which "x" requires 6x12 pixels at 74.951 pixels/inch)
+      //        (for which "x" requires 6x12 pixels at 74.951 pixels/inch)
       f = 12.0 * res / 74.951;
 
       if (f > 0)
         {
           retval(0) = 0.5 * pos(0) * f;
           retval(1) = pos(1) * f;
           if (is_rectangle)
             {
@@ -1042,17 +1079,16 @@ make_graphics_object_from_type (const ca
 
 // ---------------------------------------------------------------------
 
 bool
 base_property::set (const octave_value& v, bool do_run, bool do_notify_toolkit)
 {
   if (do_set (v))
     {
-
       // Notify graphics toolkit.
       if (id >= 0 && do_notify_toolkit)
         {
           graphics_object go = gh_manager::get_object (parent);
           if (go)
             go.update (id);
         }
 
@@ -1554,50 +1590,47 @@ children_property::do_delete_children (b
 {
   for (children_list_iterator p = children_list.begin ();
        p != children_list.end (); p++)
     {
       graphics_object go = gh_manager::get_object (*p);
 
       if (go.valid_object ())
         gh_manager::free (*p);
-
     }
 
   if (clear)
     children_list.clear ();
 }
 
 bool
 callback_property::validate (const octave_value& v) const
 {
-  // case 1: function handle
-  // case 2: cell array with first element being a function handle
+  // case 1: empty matrix
+  // case 2: function handle
   // case 3: string corresponding to known function name
-  // case 4: evaluatable string
-  // case 5: empty matrix
-
-  if (v.is_function_handle ())
+  // case 4: string that can be eval()'ed
+  // case 5: cell array with first element being a function handle
+
+  if (v.is_empty ())
+    return true;
+  else if (v.is_function_handle ())
     return true;
   else if (v.is_string ())
     // complete validation will be done at execution-time
     return true;
-  else if (v.is_cell () && v.length () > 0
-           && (v.rows () == 1 || v.columns () == 1)
+  else if (v.is_cell () && (v.rows () == 1 || v.columns () == 1)
            && v.cell_value ()(0).is_function_handle ())
     return true;
-  else if (v.is_empty ())
-    return true;
 
   return false;
 }
 
-// If TRUE, we are executing any callback function, or the functions it
-// calls.  Used to determine handle visibility inside callback
-// functions.
+// If TRUE, we are executing any callback function, or the functions it calls.
+// Used to determine handle visibility inside callback functions.
 static bool executing_callback = false;
 
 void
 callback_property::execute (const octave_value& data) const
 {
   unwind_protect frame;
 
   // We are executing the callback function associated with this
@@ -1614,73 +1647,73 @@ callback_property::execute (const octave
       executing = true;
       executing_callback = true;
 
       if (callback.is_defined () && ! callback.is_empty ())
         gh_manager::execute_callback (get_parent (), callback, data);
     }
 }
 
-// Used to cache dummy graphics objects from which dynamic
-// properties can be cloned.
+// Used to cache dummy graphics objects from which dynamic properties can be
+// cloned.
 static std::map<caseless_str, graphics_object> dprop_obj_map;
 
 property
 property::create (const std::string& name, const graphics_handle& h,
                   const caseless_str& type, const octave_value_list& args)
 {
   property retval;
 
   if (type.compare ("string"))
     {
-      std::string val = (args.length () > 0 ? args(0).string_value () : "");
+      std::string sv = (args.length () > 0 ? args(0).string_value () : "");
 
       if (! error_state)
-        retval = property (new string_property (name, h, val));
+        retval = property (new string_property (name, h, sv));
     }
   else if (type.compare ("any"))
     {
-      octave_value val = args.length () > 0 ? args(0)
-                                            : octave_value (Matrix ());
-
-      retval = property (new any_property (name, h, val));
+      octave_value ov = args.length () > 0 ? args(0)
+                                           : octave_value (Matrix ());
+
+      retval = property (new any_property (name, h, ov));
     }
   else if (type.compare ("radio"))
     {
-      if (args.length () > 0)
-        {
-          std::string vals = args(0).string_value ();
+      if (args.length () < 1)
+        error ("addproperty: missing possible values for radio property");
+      else
+        {
+          std::string sv = args(0).string_value ();
 
           if (! error_state)
             {
-              retval = property (new radio_property (name, h, vals));
+              retval = property (new radio_property (name, h, sv));
 
               if (args.length () > 1)
                 retval.set (args(1));
             }
           else
             error ("addproperty: invalid argument for radio property, expected a string value");
         }
-      else
-        error ("addproperty: missing possible values for radio property");
     }
   else if (type.compare ("double"))
     {
-      double d = (args.length () > 0 ? args(0).double_value () : 0);
+      double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
       if (! error_state)
-        retval = property (new double_property (name, h, d));
+        retval = property (new double_property (name, h, dv));
     }
   else if (type.compare ("handle"))
     {
-      double hh = (args.length () > 0 ? args(0).double_value () : octave_NaN);
+      double hv = (args.length () > 0 ? args(0).double_value () : octave_NaN);
 
       if (! error_state)
         {
-          graphics_handle gh (hh);
+          graphics_handle gh (hv);
 
           retval = property (new handle_property (name, h, gh));
         }
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
 
@@ -1689,17 +1722,16 @@ property::create (const std::string& nam
     }
   else if (type.compare ("data"))
     {
       retval = property (new array_property (name, h, Matrix ()));
 
       if (args.length () > 0)
         {
           retval.set (args(0));
-
           // FIXME: additional argument could define constraints,
           //        but is this really useful?
         }
     }
   else if (type.compare ("color"))
     {
       color_values cv (0, 0, 0);
       radio_values rv;
@@ -1958,26 +1990,26 @@ property_list::set (const caseless_str& 
 
           std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
           std::transform (pname.begin (), pname.end (), pname.begin (),
                           tolower);
 
           bool has_property = false;
           if (pfx == "axes")
             has_property = axes::properties::has_core_property (pname);
+          else if (pfx == "figure")
+            has_property = figure::properties::has_core_property (pname);
           else if (pfx == "line")
             has_property = line::properties::has_core_property (pname);
           else if (pfx == "text")
             has_property = text::properties::has_core_property (pname);
           else if (pfx == "image")
             has_property = image::properties::has_core_property (pname);
           else if (pfx == "patch")
             has_property = patch::properties::has_core_property (pname);
-          else if (pfx == "figure")
-            has_property = figure::properties::has_core_property (pname);
           else if (pfx == "surface")
             has_property = surface::properties::has_core_property (pname);
           else if (pfx == "hggroup")
             has_property = hggroup::properties::has_core_property (pname);
           else if (pfx == "uimenu")
             has_property = uimenu::properties::has_core_property (pname);
           else if (pfx == "uicontrol")
             has_property = uicontrol::properties::has_core_property (pname);
@@ -1990,19 +2022,19 @@ property_list::set (const caseless_str& 
           else if (pfx == "uipushtool")
             has_property = uipushtool::properties::has_core_property (pname);
 
           if (has_property)
             {
               bool remove = false;
               if (val.is_string ())
                 {
-                  std::string tval = val.string_value ();
-
-                  remove = (tval.compare ("remove") == 0);
+                  std::string sval = val.string_value ();
+
+                  remove = (sval.compare ("remove") == 0);
                 }
 
               pval_map_type& pval_map = plist_map[pfx];
 
               if (remove)
                 {
                   pval_map_iterator p = pval_map.find (pname);
 
@@ -2138,37 +2170,37 @@ property_list::as_struct (const std::str
 
 void
 graphics_object::set (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   if (nargin == 0)
     error ("graphics_object::set: Nothing to set");
-  else if (nargin % 2 == 0)
+  else if (nargin % 2 != 0)
+    error ("set: invalid number of arguments");
+  else
     {
       for (int i = 0; i < nargin; i += 2)
         {
-          caseless_str name = args(i).string_value ();
+          caseless_str pname = args(i).string_value ();
 
           if (! error_state)
             {
               octave_value val = args(i+1);
 
-              set_value_or_default (name, val);
+              set_value_or_default (pname, val);
 
               if (error_state)
                 break;
             }
           else
             error ("set: expecting argument %d to be a property name", i);
         }
     }
-  else
-    error ("set: invalid number of arguments");
 }
 
 /*
 ## test set with name, value pairs
 %!test
 %! hf = figure ("visible", "off");
 %! h = plot (1:10, 10:-1:1);
 %! set (h, "linewidth", 10, "marker", "x");
@@ -2176,33 +2208,33 @@ graphics_object::set (const octave_value
 %! mk = get (h, "marker");
 %! close (hf);
 %! assert (lw, 10);
 %! assert (mk, "x");
 */
 
 // Set properties given in two cell arrays containing names and values.
 void
-graphics_object::set (const Array<std::string>& names,
+graphics_object::set (const Array<std::string>& pnames,
                       const Cell& values, octave_idx_type row)
 {
-  if (names.numel () != values.columns ())
+  if (pnames.numel () != values.columns ())
     {
       error ("set: number of names must match number of value columns (%d != %d)",
-             names.numel (), values.columns ());
-    }
-
-  octave_idx_type k = names.columns ();
+             pnames.numel (), values.columns ());
+    }
+
+  octave_idx_type k = pnames.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
-      caseless_str name = names(column);
+      caseless_str pname = pnames(column);
       octave_value val  = values(row, column);
 
-      set_value_or_default (name, val);
+      set_value_or_default (pname, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
 ## test set with cell array arguments
@@ -2251,21 +2283,23 @@ graphics_object::set (const Array<std::s
 */
 
 // Set properties given in a struct array
 void
 graphics_object::set (const octave_map& m)
 {
   for (octave_idx_type p = 0; p < m.nfields (); p++)
     {
-      caseless_str name  = m.keys ()[p];
-
-      octave_value val = octave_value (m.contents (name).elem (m.numel () - 1));
-
-      set_value_or_default (name, val);
+      // FIXME: Would it be better to extract all the keys at once rather than
+      //        repeatedly call keys() inside a for loop? 
+      caseless_str pname = m.keys ()[p];
+
+      octave_value val = octave_value (m.contents (pname).elem (m.numel () - 1));
+
+      set_value_or_default (pname, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
 ## test set ticklabels for compatibility
@@ -2346,56 +2380,56 @@ graphics_object::set (const octave_map& 
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 // Set a property to a value or to its (factory) default value.
 
 void
-graphics_object::set_value_or_default (const caseless_str& name,
+graphics_object::set_value_or_default (const caseless_str& pname,
                                        const octave_value& val)
 {
   if (val.is_string ())
     {
-      std::string tval = val.string_value ();
+      std::string sval = val.string_value ();
 
       octave_value default_val;
 
-      if (tval.compare ("default") == 0)
-        {
-          default_val = get_default (name);
+      if (sval.compare ("default") == 0)
+        {
+          default_val = get_default (pname);
 
           if (error_state)
             return;
 
-          rep->set (name, default_val);
-        }
-      else if (tval.compare ("factory") == 0)
-        {
-          default_val = get_factory_default (name);
+          rep->set (pname, default_val);
+        }
+      else if (sval.compare ("factory") == 0)
+        {
+          default_val = get_factory_default (pname);
 
           if (error_state)
             return;
 
-          rep->set (name, default_val);
+          rep->set (pname, default_val);
         }
       else
         {
           // Matlab specifically uses "\default" to escape string setting
-          if (tval.compare ("\\default") == 0)
-            rep->set (name, "default");
-          else if (tval.compare ("\\factory") == 0)
-            rep->set (name, "factory");
+          if (sval.compare ("\\default") == 0)
+            rep->set (pname, "default");
+          else if (sval.compare ("\\factory") == 0)
+            rep->set (pname, "factory");
           else
-            rep->set (name, val);
-        }
-    }
-  else
-    rep->set (name, val);
+            rep->set (pname, val);
+        }
+    }
+  else
+    rep->set (pname, val);
 }
 
 /*
 ## test setting of default values
 %!test
 %! old_lw = get (0, "defaultlinelinewidth");
 %! unwind_protect
 %!   hf = figure ("visible", "off");
@@ -2421,32 +2455,31 @@ make_handle_fraction (void)
 
 graphics_handle
 gh_manager::do_get_handle (bool integer_figure_handle)
 {
   graphics_handle retval;
 
   if (integer_figure_handle)
     {
-      // Figure handles are positive integers corresponding to the
-      // figure number.
+      // Figure handles are positive integers corresponding
+      // to the figure number.
 
       // We always want the lowest unused figure number.
 
       retval = 1;
 
       while (handle_map.find (retval) != handle_map.end ())
         retval++;
     }
   else
     {
       // Other graphics handles are negative integers plus some random
-      // fractional part.  To avoid running out of integers, we
-      // recycle the integer part but tack on a new random part each
-      // time.
+      // fractional part.  To avoid running out of integers, we recycle the
+      // integer part but tack on a new random part each time.
 
       free_list_iterator p = handle_free_list.begin ();
 
       if (p != handle_free_list.end ())
         {
           retval = *p;
           handle_free_list.erase (p);
         }
@@ -2480,18 +2513,18 @@ gh_manager::do_free (const graphics_hand
 
               octave_value val = bp.get_deletefcn ();
 
               bp.execute_deletefcn ();
 
               // Notify graphics toolkit.
               p->second.finalize ();
 
-              // Note: this will be valid only for first explicitly
-              // deleted object.  All its children will then have an
+              // Note: this will be valid only for first explicitly deleted
+              // object.  All its children will then have an
               // unknown graphics toolkit.
 
               // Graphics handles for non-figure objects are negative
               // integers plus some random fractional part.  To avoid
               // running out of integers, we recycle the integer part
               // but tack on a new random part each time.
 
               handle_map.erase (p);
@@ -2538,75 +2571,75 @@ gh_manager::do_renumber_figure (const gr
           break;
         }
     }
 }
 
 gh_manager *gh_manager::instance = 0;
 
 static void
-xset (const graphics_handle& h, const caseless_str& name,
+xset (const graphics_handle& h, const caseless_str& pname,
       const octave_value& val)
 {
-  graphics_object obj = gh_manager::get_object (h);
-  obj.set (name, val);
+  graphics_object go = gh_manager::get_object (h);
+  go.set (pname, val);
 }
 
 static void
 xset (const graphics_handle& h, const octave_value_list& args)
 {
   if (args.length () > 0)
     {
-      graphics_object obj = gh_manager::get_object (h);
-      obj.set (args);
+      graphics_object go = gh_manager::get_object (h);
+      go.set (args);
     }
 }
 
 static octave_value
-xget (const graphics_handle& h, const caseless_str& name)
-{
-  graphics_object obj = gh_manager::get_object (h);
-  return obj.get (name);
+xget (const graphics_handle& h, const caseless_str& pname)
+{
+  graphics_object go = gh_manager::get_object (h);
+  return go.get (pname);
 }
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
-          const std::string& property, const graphics_handle& new_parent,
+          const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
   graphics_handle h = octave_NaN;
 
-  double val = ov.double_value ();
+  double hv = ov.double_value ();
 
   if (! error_state)
     {
-      h = gh_manager::lookup (val);
+      h = gh_manager::lookup (hv);
 
       if (h.ok ())
         {
-          graphics_object obj = gh_manager::get_object (h);
-
-          graphics_handle parent_h = obj.get_parent ();
-
-          graphics_object parent_obj = gh_manager::get_object (parent_h);
-
-          parent_obj.remove_child (h);
+          graphics_object go = gh_manager::get_object (h);
+
+          graphics_handle parent_h = go.get_parent ();
+
+          graphics_object parent_go = gh_manager::get_object (parent_h);
+
+          parent_go.remove_child (h);
 
           if (adopt)
-            obj.set ("parent", new_parent.value ());
+            go.set ("parent", new_parent.value ());
           else
-            obj.reparent (new_parent);
+            go.reparent (new_parent);
         }
       else
         error ("%s: invalid graphics handle (= %g) for %s",
-               who.c_str (), val, property.c_str ());
+               who.c_str (), hv, pname.c_str ());
     }
   else
     error ("%s: expecting %s to be a graphics handle",
-           who.c_str (), property.c_str ());
+           who.c_str (), pname.c_str ());
 
   return h;
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
@@ -2624,37 +2657,34 @@ gca (void)
   return val.is_empty () ? octave_NaN : val.double_value ();
 }
 
 static void
 delete_graphics_object (const graphics_handle& h)
 {
   if (h.ok ())
     {
-      graphics_object obj = gh_manager::get_object (h);
+      graphics_object go = gh_manager::get_object (h);
 
       // Don't do recursive deleting, due to callbacks
-      if (! obj.get_properties ().is_beingdeleted ())
-        {
-          graphics_handle parent_h = obj.get_parent ();
-
-          graphics_object parent_obj =
-            gh_manager::get_object (parent_h);
-
-          // NOTE: free the handle before removing it from its
-          //       parent's children, such that the object's
-          //       state is correct when the deletefcn callback
-          //       is executed
+      if (! go.get_properties ().is_beingdeleted ())
+        {
+          graphics_handle parent_h = go.get_parent ();
+
+          graphics_object parent_go = gh_manager::get_object (parent_h);
+
+          // NOTE: free the handle before removing it from its parent's
+          //       children, such that the object's state is correct when the
+          //       deletefcn callback is executed
 
           gh_manager::free (h);
 
-          // A callback function might have already deleted
-          // the parent
-          if (parent_obj.valid_object ())
-            parent_obj.remove_child (h);
+          // A callback function might have already deleted the parent
+          if (parent_go.valid_object ())
+            parent_go.remove_child (h);
 
           Vdrawnow_requested = true;
         }
     }
 }
 
 static void
 delete_graphics_object (double val)
@@ -2665,33 +2695,33 @@ delete_graphics_object (double val)
 static void
 delete_graphics_objects (const NDArray vals)
 {
   for (octave_idx_type i = 0; i < vals.numel (); i++)
     delete_graphics_object (vals.elem (i));
 }
 
 static void
-close_figure (const graphics_handle& handle)
-{
-  octave_value closerequestfcn = xget (handle, "closerequestfcn");
-
-  OCTAVE_SAFE_CALL (gh_manager::execute_callback, (handle, closerequestfcn));
+close_figure (const graphics_handle& h)
+{
+  octave_value closerequestfcn = xget (h, "closerequestfcn");
+
+  OCTAVE_SAFE_CALL (gh_manager::execute_callback, (h, closerequestfcn));
 }
 
 static void
-force_close_figure (const graphics_handle& handle)
-{
-  // Remove the deletefcn and closerequestfcn callbacks and delete the
-  // object directly.
-
-  xset (handle, "deletefcn", Matrix ());
-  xset (handle, "closerequestfcn", Matrix ());
-
-  delete_graphics_object (handle);
+force_close_figure (const graphics_handle& h)
+{
+  // Remove the deletefcn and closerequestfcn callbacks
+  // and delete the object directly.
+
+  xset (h, "deletefcn", Matrix ());
+  xset (h, "closerequestfcn", Matrix ());
+
+  delete_graphics_object (h);
 }
 
 void
 gh_manager::do_close_all_figures (void)
 {
   // FIXME: should we process or discard pending events?
 
   event_queue.clear ();
@@ -2728,20 +2758,20 @@ gh_manager::do_close_all_figures (void)
   assert (hlist.numel () == 0);
 
   // Clear all callback objects from our list.
 
   callback_objects.clear ();
 }
 
 static void
-adopt (const graphics_handle& p, const graphics_handle& h)
-{
-  graphics_object parent_obj = gh_manager::get_object (p);
-  parent_obj.adopt (h);
+adopt (const graphics_handle& parent_h, const graphics_handle& h)
+{
+  graphics_object parent_go = gh_manager::get_object (parent_h);
+  parent_go.adopt (h);
 }
 
 static bool
 is_handle (const graphics_handle& h)
 {
   return h.ok ();
 }
 
@@ -2764,38 +2794,38 @@ is_handle (const octave_value& val)
     {
       const NDArray handles = val.array_value ();
 
       if (! error_state)
         {
           boolNDArray result (handles.dims ());
 
           for (octave_idx_type i = 0; i < handles.numel (); i++)
-            result.xelem (i) = is_handle (handles (i));
+            result.xelem (i) = is_handle (handles(i));
 
           retval = result;
         }
     }
 
   return retval;
 }
 
 static bool
 is_figure (double val)
 {
-  graphics_object obj = gh_manager::get_object (val);
-
-  return obj && obj.isa ("figure");
+  graphics_object go = gh_manager::get_object (val);
+
+  return go && go.isa ("figure");
 }
 
 static void
 xcreatefcn (const graphics_handle& h)
 {
-  graphics_object obj = gh_manager::get_object (h);
-  obj.get_properties ().execute_createfcn  ();
+  graphics_object go = gh_manager::get_object (h);
+  go.get_properties ().execute_createfcn  ();
 }
 
 static void
 xinitialize (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (h);
 
   if (go)
@@ -2824,79 +2854,78 @@ void
 base_graphics_toolkit::finalize (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (h);
 
   finalize (go);
 }
 
 static void
-xreset_default_properties (graphics_handle gh,
+xreset_default_properties (graphics_handle h,
                            property_list::pval_map_type factory_pval)
 {
-  graphics_object obj = gh_manager::get_object (gh);
+  graphics_object go = gh_manager::get_object (h);
 
   // Replace factory defaults by user defined ones
-  std::string go_name = obj.get_properties ().graphics_object_name ();
+  std::string go_name = go.get_properties ().graphics_object_name ();
   property_list::pval_map_type pval;
-  obj.build_user_defaults_map (pval, go_name);
+  go.build_user_defaults_map (pval, go_name);
 
   for (property_list::pval_map_const_iterator p = pval.begin ();
        p != pval.end (); p++)
     {
       factory_pval[p->first] = p->second;
     }
 
-
   // Reset defaults
   for (property_list::pval_map_const_iterator it = factory_pval.begin ();
        it != factory_pval.end (); it++)
     {
       std::string pname = it->first;
 
       // Don't reset internal properties and handle_properties
-      if (! obj.has_readonly_property (pname)
+      if (! go.has_readonly_property (pname)
           && pname.find ("__") != 0 && pname.find ("current") != 0
           && pname != "uicontextmenu" && pname != "parent")
         {
           // Store *mode prop/val in order to set them last
           if (pname.find ("mode") == (pname.length () - 4))
             pval[pname] = it->second;
           else
-            obj.set (pname, it->second);
+            go.set (pname, it->second);
         }
     }
 
   // set *mode properties
   for (property_list::pval_map_const_iterator it = pval.begin ();
        it != pval.end (); it++)
-    obj.set (it->first, it->second);
+    go.set (it->first, it->second);
 }
 
 // ---------------------------------------------------------------------
 
 void
-base_properties::set_from_list (base_graphics_object& obj,
+base_properties::set_from_list (base_graphics_object& bgo,
                                 property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
   property_list::plist_map_const_iterator p = defaults.find (go_name);
 
   if (p != defaults.end ())
     {
       const property_list::pval_map_type pval_map = p->second;
 
       for (property_list::pval_map_const_iterator q = pval_map.begin ();
            q != pval_map.end ();
            q++)
         {
           std::string pname = q->first;
 
-          obj.set (pname, q->second);
+          bgo.set (pname, q->second);
 
           if (error_state)
             {
               error ("error setting default property %s", pname.c_str ());
               break;
             }
         }
     }
@@ -2914,27 +2943,27 @@ base_properties::set_from_list (base_gra
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   set(0, "defaultfigureunits", "remove");
 %!   set(0, "defaultfigureposition", "remove");
 %! end_unwind_protect
 */
 
 octave_value
-base_properties::get_dynamic (const caseless_str& name) const
+base_properties::get_dynamic (const caseless_str& pname) const
 {
   octave_value retval;
 
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
-    all_props.find (name);
+    all_props.find (pname);
 
   if (it != all_props.end ())
     retval = it->second.get ();
   else
-    error ("get: unknown property \"%s\"", name.c_str ());
+    error ("get: unknown property \"%s\"", pname.c_str ());
 
   return retval;
 }
 
 octave_value
 base_properties::get_dynamic (bool all) const
 {
   octave_scalar_map m;
@@ -2980,73 +3009,71 @@ base_properties::set_dynamic (const case
     {
       dynamic_properties.insert (pname);
 
       mark_modified ();
     }
 }
 
 property
-base_properties::get_property_dynamic (const caseless_str& name)
+base_properties::get_property_dynamic (const caseless_str& pname)
 {
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
-    all_props.find (name);
+    all_props.find (pname);
 
   if (it == all_props.end ())
     {
-      error ("get_property: unknown property \"%s\"", name.c_str ());
+      error ("get_property: unknown property \"%s\"", pname.c_str ());
       return property ();
     }
   else
     return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
-  double hnp = val.double_value ();
+  double hp = val.double_value ();
 
   graphics_handle new_parent = octave_NaN;
 
   if (! error_state)
     {
-      if (hnp == __myhandle__)
+      if (hp == __myhandle__)
         error ("set: can not set object parent to be object itself");
       else
         {
-          new_parent = gh_manager::lookup (hnp);
+          new_parent = gh_manager::lookup (hp);
 
           if (new_parent.ok ())
             {
               // Remove child from current parent
-              graphics_object old_parent_obj;
-              old_parent_obj = gh_manager::get_object (get_parent ());
-
-
-              if (old_parent_obj.get_handle () != hnp)
-                old_parent_obj.remove_child (__myhandle__);
+              graphics_object old_parent_go;
+              old_parent_go = gh_manager::get_object (get_parent ());
+
+              if (old_parent_go.get_handle () != hp)
+                old_parent_go.remove_child (__myhandle__);
               else
-                // Do nothing more
-                return;
+                return;  // Do nothing more
 
               // Check new parent's parent is not this child to avoid recursion
-              graphics_object new_parent_obj;
-              new_parent_obj = gh_manager::get_object (new_parent);
-              if (new_parent_obj.get_parent () == __myhandle__)
+              graphics_object new_parent_go;
+              new_parent_go = gh_manager::get_object (new_parent);
+              if (new_parent_go.get_parent () == __myhandle__)
                 {
                   // new parent's parent gets child's original parent
-                  new_parent_obj.get_properties ().set_parent (get_parent ().as_octave_value ());
+                  new_parent_go.get_properties ().set_parent (get_parent ().as_octave_value ());
                 }
 
               // Set parent property to new_parent and do adoption
               parent = new_parent.as_octave_value ();
               ::adopt (parent.handle_value (), __myhandle__);
             }
           else
-            error ("set: invalid graphics handle (= %g) for parent", hnp);
+            error ("set: invalid graphics handle (= %g) for parent", hp);
         }
     }
   else
     error ("set: expecting parent to be a graphics handle");
 }
 
 /*
 %!test
@@ -3058,61 +3085,63 @@ base_properties::set_parent (const octav
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
 base_properties::mark_modified (void)
 {
-  __modified__ = "on";
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-  if (parent_obj)
-    parent_obj.mark_modified ();
+  // Mark existing object as modified
+  __modified__ = "on";  
+  // Attempt to mark parent object as modified if it exists
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  if (parent_go)
+    parent_go.mark_modified ();
 }
 
 void
 base_properties::override_defaults (base_graphics_object& obj)
 {
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-  if (parent_obj)
-    parent_obj.override_defaults (obj);
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+  if (parent_go)
+    parent_go.override_defaults (obj);
 }
 
 void
 base_properties::update_axis_limits (const std::string& axis_type) const
 {
-  graphics_object obj = gh_manager::get_object (__myhandle__);
-
-  if (obj)
-    obj.update_axis_limits (axis_type);
+  graphics_object go = gh_manager::get_object (__myhandle__);
+
+  if (go)
+    go.update_axis_limits (axis_type);
 }
 
 void
 base_properties::update_axis_limits (const std::string& axis_type,
                                      const graphics_handle& h) const
 {
-  graphics_object obj = gh_manager::get_object (__myhandle__);
-
-  if (obj)
-    obj.update_axis_limits (axis_type, h);
+  graphics_object go = gh_manager::get_object (__myhandle__);
+
+  if (go)
+    go.update_axis_limits (axis_type, h);
 }
 
 void
 base_properties::update_uicontextmenu (void) const
 {
   if (uicontextmenu.get ().is_empty ())
     return;
 
-  graphics_object obj = gh_manager::get_object (uicontextmenu.get ());
-  if (obj && obj.isa ("uicontextmenu"))
+  graphics_object go = gh_manager::get_object (uicontextmenu.get ());
+  if (go && go.isa ("uicontextmenu"))
     {
       uicontextmenu::properties& props =
-        reinterpret_cast<uicontextmenu::properties&> (obj.get_properties ());
+        reinterpret_cast<uicontextmenu::properties&> (go.get_properties ());
       props.add_dependent_obj (__myhandle__);
     }
 }
 
 bool
 base_properties::is_handle_visible (void) const
 {
   return (handlevisibility.is ("on")
@@ -3142,71 +3171,73 @@ base_properties::update_boundingbox (voi
       if (go.valid_object ())
         go.get_properties ().update_boundingbox ();
     }
 }
 
 void
 base_properties::update_autopos (const std::string& elem_type)
 {
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-  if (parent_obj.valid_object ())
-    parent_obj.get_properties ().update_autopos (elem_type);
-}
-
-void
-base_properties::add_listener (const caseless_str& nm, const octave_value& v,
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+  if (parent_go.valid_object ())
+    parent_go.get_properties ().update_autopos (elem_type);
+}
+
+void
+base_properties::add_listener (const caseless_str& pname,
+                               const octave_value& val,
                                listener_mode mode)
 {
-  property p = get_property (nm);
+  property p = get_property (pname);
 
   if (! error_state && p.ok ())
-    p.add_listener (v, mode);
-}
-
-void
-base_properties::delete_listener (const caseless_str& nm,
-                                  const octave_value& v, listener_mode mode)
-{
-  property p = get_property (nm);
+    p.add_listener (val, mode);
+}
+
+void
+base_properties::delete_listener (const caseless_str& pname,
+                                  const octave_value& val,
+                                  listener_mode mode)
+{
+  property p = get_property (pname);
 
   if (! error_state && p.ok ())
-    p.delete_listener (v, mode);
+    p.delete_listener (val, mode);
 }
 
 // ---------------------------------------------------------------------
 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type)
 {
   if (valid_object ())
     {
-      graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-      if (parent_obj)
-        parent_obj.update_axis_limits (axis_type);
+      graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+      if (parent_go)
+        parent_go.update_axis_limits (axis_type);
     }
   else
     error ("base_graphics_object::update_axis_limits: invalid graphics object");
 }
 
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type,
                                           const graphics_handle& h)
 {
-  if (valid_object ())
-    {
-      graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-      if (parent_obj)
-        parent_obj.update_axis_limits (axis_type, h);
-    }
-  else
+  if (! valid_object ())
     error ("base_graphics_object::update_axis_limits: invalid graphics object");
+  else
+    {
+      graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+      if (parent_go)
+        parent_go.update_axis_limits (axis_type, h);
+    }
 }
 
 void
 base_graphics_object::remove_all_listeners (void)
 {
   octave_map m = get (true).map_value ();
 
   for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
@@ -3247,21 +3278,20 @@ base_graphics_object::build_user_default
            q != pval.end (); q++)
         {
           std::string pname = q->first;
           if (def.find (pname) == def.end ())
             def[pname] = q->second;
         }
     }
 
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-
-  if (parent_obj)
-    parent_obj.build_user_defaults_map (def, go_name);
-
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+
+  if (parent_go)
+    parent_go.build_user_defaults_map (def, go_name);
 }
 
 void
 base_graphics_object::reset_default_properties (void)
 {
   if (valid_object ())
     {
       property_list::pval_map_type factory_pval =
@@ -3272,105 +3302,104 @@ base_graphics_object::reset_default_prop
     }
 }
 
 std::string
 base_graphics_object::values_as_string (void)
 {
   std::string retval;
 
-  if (valid_object ())
+  if (! valid_object ())
+    error ("base_graphics_object::values_as_string: invalid graphics object");
+  else
     {
       octave_map m = get ().map_value ();
-      graphics_object obj = gh_manager::get_object (get_handle ());
+      graphics_object go = gh_manager::get_object (get_handle ());
 
       for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
         {
-          if (pa->first != "children"
-              && ! obj.has_readonly_property (pa->first))
+          if (pa->first != "children" && ! go.has_readonly_property (pa->first))
             {
               property p = get_properties ().get_property (pa->first);
 
               if (p.ok () && ! p.is_hidden ())
                 {
                   retval += "\n\t" + std::string (pa->first) + ":  ";
                   if (p.is_radio ())
                     retval += p.values_as_string ();
                 }
             }
         }
 
       if (! retval.empty ())
         retval += "\n";
     }
-  else
-    error ("base_graphics_object::values_as_string: invalid graphics object");
 
   return retval;
 }
 
 std::string
 base_graphics_object::value_as_string (const std::string& prop)
 {
   std::string retval;
 
-  if (valid_object ())
-    {
-      graphics_object obj = gh_manager::get_object (get_handle ());
-
-      if (prop != "children" && ! obj.has_readonly_property (prop))
+  if (! valid_object ())
+    error ("base_graphics_object::value_as_string: invalid graphics object");
+  else
+    {
+      graphics_object go = gh_manager::get_object (get_handle ());
+
+      if (prop != "children" && ! go.has_readonly_property (prop))
         {
           property p = get_properties ().get_property (prop);
 
           if (p.ok () && ! p.is_hidden ())
             {
               if (p.is_radio ())
                 retval += p.values_as_string ();
             }
         }
 
       if (! retval.empty ())
         retval += "\n";
     }
-  else
-    error ("base_graphics_object::value_as_string: invalid graphics object");
 
   return retval;
 }
 
 octave_scalar_map
 base_graphics_object::values_as_struct (void)
 {
   octave_scalar_map retval;
 
-  if (valid_object ())
+  if (! valid_object ())
+    error ("base_graphics_object::values_as_struct: invalid graphics object");
+  else
     {
       octave_scalar_map m = get ().scalar_map_value ();
-      graphics_object obj = gh_manager::get_object (get_handle ());
+      graphics_object go = gh_manager::get_object (get_handle ());
 
       for (octave_scalar_map::const_iterator pa = m.begin ();
            pa != m.end (); pa++)
         {
           if (pa->first != "children"
-              && ! obj.has_readonly_property (pa->first))
+              && ! go.has_readonly_property (pa->first))
             {
               property p = get_properties ().get_property (pa->first);
 
               if (p.ok () && ! p.is_hidden ())
                 {
                   if (p.is_radio ())
                     retval.assign (p.get_name (), p.values_as_cell ());
                   else
                     retval.assign (p.get_name (), Cell ());
                 }
             }
         }
     }
-  else
-    error ("base_graphics_object::values_as_struct: invalid graphics object");
 
   return retval;
 }
 
 /*
 %!test
 %! hfig = figure ("visible", "off");
 %! unwind_protect
@@ -3592,17 +3621,16 @@ root_figure::properties::set_formatspaci
           else
             F__compactformat__ (ovl (false));
 
           formatspacing.run_listeners ();
         }
     }
 }
 
-
 double
 root_figure::properties::get_recursionlimit (void) const
 {
   return Fmax_recursion_depth ()(0).double_value ();
 }
 
 void
 root_figure::properties::set_recursionlimit (const octave_value& val)
@@ -3662,66 +3690,67 @@ figure::properties::set_integerhandle (c
 
           this_go.update (integerhandle.get_id ());
 
           mark_modified ();
         }
     }
 }
 
-// FIXME: This should update monitorpositions and pointerlocation, but
-// as these properties are yet used, and so it doesn't matter that they
-// aren't set yet.
+// FIXME: This should update monitorpositions and pointerlocation, but as these
+// properties aren't yet used, it doesn't matter that they aren't set either.
 void
 root_figure::properties::update_units (void)
 {
   caseless_str xunits = get_units ();
 
-  Matrix ss = default_screensize ();
+  Matrix scrn_sz = default_screensize ();
 
   double dpi = get_screenpixelsperinch ();
 
   if (xunits.compare ("inches"))
     {
-      ss(0) = 0;
-      ss(1) = 0;
-      ss(2) /= dpi;
-      ss(3) /= dpi;
+      scrn_sz(0) = 0;
+      scrn_sz(1) = 0;
+      scrn_sz(2) /= dpi;
+      scrn_sz(3) /= dpi;
     }
   else if (xunits.compare ("centimeters"))
     {
-      ss(0) = 0;
-      ss(1) = 0;
-      ss(2) *= 2.54 / dpi;
-      ss(3) *= 2.54 / dpi;
+      scrn_sz(0) = 0;
+      scrn_sz(1) = 0;
+      scrn_sz(2) *= 2.54 / dpi;
+      scrn_sz(3) *= 2.54 / dpi;
     }
   else if (xunits.compare ("normalized"))
     {
-      ss = Matrix (1, 4, 1.0);
-      ss(0) = 0;
-      ss(1) = 0;
+      scrn_sz = Matrix (1, 4, 1.0);
+      scrn_sz(0) = 0;
+      scrn_sz(1) = 0;
     }
   else if (xunits.compare ("points"))
     {
-      ss(0) = 0;
-      ss(1) = 0;
-      ss(2) *= 72 / dpi;
-      ss(3) *= 72 / dpi;
-    }
-
-  set_screensize (ss);
+      scrn_sz(0) = 0;
+      scrn_sz(1) = 0;
+      scrn_sz(2) *= 72 / dpi;
+      scrn_sz(3) *= 72 / dpi;
+    }
+
+  set_screensize (scrn_sz);
 }
 
 Matrix
 root_figure::properties::get_boundingbox (bool, const Matrix&) const
 {
   Matrix screen_size = screen_size_pixels ();
-  Matrix pos = Matrix (1, 4, 0);
+  Matrix pos = Matrix (1, 4, 0.0);
+
   pos(2) = screen_size(0);
   pos(3) = screen_size(1);
+
   return pos;
 }
 
 /*
 %!test
 %! old_units = get (0, "units");
 %! unwind_protect
 %!   set (0, "units", "pixels");
@@ -3738,25 +3767,25 @@ root_figure::properties::get_boundingbox
 %!   set (0, "units", "pixels");
 %!   assert (get (0, "screensize"), sz + [1, 1, 0, 0]);
 %! unwind_protect_cleanup
 %!   set (0, "units", old_units);
 %! end_unwind_protect
 */
 
 void
-root_figure::properties::remove_child (const graphics_handle& gh)
-{
-  gh_manager::pop_figure (gh);
+root_figure::properties::remove_child (const graphics_handle& h)
+{
+  gh_manager::pop_figure (h);
 
   graphics_handle cf = gh_manager::current_figure ();
 
   xset (0, "currentfigure", cf.value ());
 
-  base_properties::remove_child (gh);
+  base_properties::remove_child (h);
 }
 
 property_list
 root_figure::factory_properties = root_figure::init_factory_properties ();
 
 void
 root_figure::reset_default_properties (void)
 {
@@ -3765,35 +3794,35 @@ root_figure::reset_default_properties (v
 
   xreset_default_properties (get_handle (),
                              xproperties.factory_defaults ());
 }
 
 // ---------------------------------------------------------------------
 
 void
-figure::properties::set_currentaxes (const octave_value& v)
-{
-  graphics_handle val (v);
+figure::properties::set_currentaxes (const octave_value& val)
+{
+  graphics_handle hax (val);
 
   if (error_state)
     return;
 
-  if (xisnan (val.value ()) || is_handle (val))
-    currentaxes = val;
+  if (xisnan (hax.value ()) || is_handle (hax))
+    currentaxes = hax;
   else
     gripe_set_invalid ("currentaxes");
 }
 
 void
-figure::properties::remove_child (const graphics_handle& gh)
-{
-  base_properties::remove_child (gh);
-
-  if (gh == currentaxes.handle_value ())
+figure::properties::remove_child (const graphics_handle& h)
+{
+  base_properties::remove_child (h);
+
+  if (h == currentaxes.handle_value ())
     {
       graphics_handle new_currentaxes;
 
       Matrix kids = get_children ();
 
       for (octave_idx_type i = 0; i < kids.numel (); i++)
         {
           graphics_handle kid = kids(i);
@@ -3841,21 +3870,21 @@ figure::properties::adopt (const graphic
 %!   close (hf1);
 %!   close (hf2);
 %! end_unwind_protect
 */
 
 void
 figure::properties::set_visible (const octave_value& val)
 {
-  std::string s = val.string_value ();
+  std::string sval = val.string_value ();
 
   if (! error_state)
     {
-      if (s == "on")
+      if (sval == "on")
         xset (0, "currentfigure", __myhandle__.value ());
 
       visible = val;
     }
 }
 
 Matrix
 figure::properties::get_boundingbox (bool internal, const Matrix&) const
@@ -3891,34 +3920,34 @@ figure::properties::set_boundingbox (con
   else
     set_outerposition (pos, do_notify_toolkit);
 }
 
 Matrix
 figure::properties::map_from_boundingbox (double x, double y) const
 {
   Matrix bb = get_boundingbox (true);
-  Matrix pos (1, 2, 0);
+  Matrix pos (1, 2, 0.0);
 
   pos(0) = x;
   pos(1) = y;
 
   pos(1) = bb(3) - pos(1);
   pos(0)++;
   pos = convert_position (pos, "pixels", get_units (),
                           bb.extract_n (0, 2, 1, 2));
 
   return pos;
 }
 
 Matrix
 figure::properties::map_to_boundingbox (double x, double y) const
 {
   Matrix bb = get_boundingbox (true);
-  Matrix pos (1, 2, 0);
+  Matrix pos (1, 2, 0.0);
 
   pos(0) = x;
   pos(1) = y;
 
   pos = convert_position (pos, get_units (), "pixels",
                           bb.extract_n (0, 2, 1, 2));
   pos(0)--;
   pos(1) = bb(3) - pos(1);
@@ -3968,66 +3997,66 @@ figure::properties::set_outerposition (c
       if (outerposition.set (v, true, do_notify_toolkit))
         {
           mark_modified ();
         }
     }
 }
 
 void
-figure::properties::set_paperunits (const octave_value& v)
+figure::properties::set_paperunits (const octave_value& val)
 {
   if (! error_state)
     {
-      caseless_str typ = get_papertype ();
-      caseless_str punits = v.string_value ();
+      caseless_str punits = val.string_value ();
+      caseless_str ptype = get_papertype ();
       if (! error_state)
         {
-          if (punits.compare ("normalized") && typ.compare ("<custom>"))
-            error ("set: can't set the paperunits to normalized when the papertype is custom");
+          if (punits.compare ("normalized") && ptype.compare ("<custom>"))
+            error ("set: can't set paperunits to normalized when papertype is custom");
           else
             {
               caseless_str old_paperunits = get_paperunits ();
-              if (paperunits.set (v, true))
+              if (paperunits.set (val, true))
                 {
                   update_paperunits (old_paperunits);
                   mark_modified ();
                 }
             }
         }
     }
 }
 
 void
-figure::properties::set_papertype (const octave_value& v)
+figure::properties::set_papertype (const octave_value& val)
 {
   if (! error_state)
     {
-      caseless_str typ = v.string_value ();
+      caseless_str ptype = val.string_value ();
       caseless_str punits = get_paperunits ();
       if (! error_state)
         {
-          if (punits.compare ("normalized") && typ.compare ("<custom>"))
-            error ("set: can't set the paperunits to normalized when the papertype is custom");
+          if (punits.compare ("normalized") && ptype.compare ("<custom>"))
+            error ("set: can't set paperunits to normalized when papertype is custom");
           else
             {
-              if (papertype.set (v, true))
+              if (papertype.set (val, true))
                 {
                   update_papertype ();
                   mark_modified ();
                 }
             }
         }
     }
 }
 
 static Matrix
-papersize_from_type (const caseless_str punits, const caseless_str typ)
-{
-  Matrix ret (1, 2, 1.0);
+papersize_from_type (const caseless_str punits, const caseless_str ptype)
+{
+  Matrix retval (1, 2, 1.0);
 
   if (! punits.compare ("normalized"))
     {
       double in2units;
       double mm2units;
 
       if (punits.compare ("inches"))
         {
@@ -4040,144 +4069,144 @@ papersize_from_type (const caseless_str 
           mm2units = 1 / 10.0;
         }
       else // points
         {
           in2units = 72.0;
           mm2units = 72.0 / 25.4;
         }
 
-      if (typ.compare ("usletter"))
-        {
-          ret (0) = 8.5 * in2units;
-          ret (1) = 11.0 * in2units;
-        }
-      else if (typ.compare ("uslegal"))
-        {
-          ret (0) = 8.5 * in2units;
-          ret (1) = 14.0 * in2units;
-        }
-      else if (typ.compare ("tabloid"))
-        {
-          ret (0) = 11.0 * in2units;
-          ret (1) = 17.0 * in2units;
-        }
-      else if (typ.compare ("a0"))
-        {
-          ret (0) = 841.0 * mm2units;
-          ret (1) = 1189.0 * mm2units;
-        }
-      else if (typ.compare ("a1"))
-        {
-          ret (0) = 594.0 * mm2units;
-          ret (1) = 841.0 * mm2units;
-        }
-      else if (typ.compare ("a2"))
-        {
-          ret (0) = 420.0 * mm2units;
-          ret (1) = 594.0 * mm2units;
-        }
-      else if (typ.compare ("a3"))
-        {
-          ret (0) = 297.0 * mm2units;
-          ret (1) = 420.0 * mm2units;
-        }
-      else if (typ.compare ("a4"))
-        {
-          ret (0) = 210.0 * mm2units;
-          ret (1) = 297.0 * mm2units;
-        }
-      else if (typ.compare ("a5"))
-        {
-          ret (0) = 148.0 * mm2units;
-          ret (1) = 210.0 * mm2units;
-        }
-      else if (typ.compare ("b0"))
-        {
-          ret (0) = 1029.0 * mm2units;
-          ret (1) = 1456.0 * mm2units;
-        }
-      else if (typ.compare ("b1"))
-        {
-          ret (0) = 728.0 * mm2units;
-          ret (1) = 1028.0 * mm2units;
-        }
-      else if (typ.compare ("b2"))
-        {
-          ret (0) = 514.0 * mm2units;
-          ret (1) = 728.0 * mm2units;
-        }
-      else if (typ.compare ("b3"))
-        {
-          ret (0) = 364.0 * mm2units;
-          ret (1) = 514.0 * mm2units;
-        }
-      else if (typ.compare ("b4"))
-        {
-          ret (0) = 257.0 * mm2units;
-          ret (1) = 364.0 * mm2units;
-        }
-      else if (typ.compare ("b5"))
-        {
-          ret (0) = 182.0 * mm2units;
-          ret (1) = 257.0 * mm2units;
-        }
-      else if (typ.compare ("arch-a"))
-        {
-          ret (0) = 9.0 * in2units;
-          ret (1) = 12.0 * in2units;
-        }
-      else if (typ.compare ("arch-b"))
-        {
-          ret (0) = 12.0 * in2units;
-          ret (1) = 18.0 * in2units;
-        }
-      else if (typ.compare ("arch-c"))
-        {
-          ret (0) = 18.0 * in2units;
-          ret (1) = 24.0 * in2units;
-        }
-      else if (typ.compare ("arch-d"))
-        {
-          ret (0) = 24.0 * in2units;
-          ret (1) = 36.0 * in2units;
-        }
-      else if (typ.compare ("arch-e"))
-        {
-          ret (0) = 36.0 * in2units;
-          ret (1) = 48.0 * in2units;
-        }
-      else if (typ.compare ("a"))
-        {
-          ret (0) = 8.5 * in2units;
-          ret (1) = 11.0 * in2units;
-        }
-      else if (typ.compare ("b"))
-        {
-          ret (0) = 11.0 * in2units;
-          ret (1) = 17.0 * in2units;
-        }
-      else if (typ.compare ("c"))
-        {
-          ret (0) = 17.0 * in2units;
-          ret (1) = 22.0 * in2units;
-        }
-      else if (typ.compare ("d"))
-        {
-          ret (0) = 22.0 * in2units;
-          ret (1) = 34.0 * in2units;
-        }
-      else if (typ.compare ("e"))
-        {
-          ret (0) = 34.0 * in2units;
-          ret (1) = 43.0 * in2units;
-        }
-    }
-
-  return ret;
+      if (ptype.compare ("usletter"))
+        {
+          retval(0) = 8.5 * in2units;
+          retval(1) = 11.0 * in2units;
+        }
+      else if (ptype.compare ("uslegal"))
+        {
+          retval(0) = 8.5 * in2units;
+          retval(1) = 14.0 * in2units;
+        }
+      else if (ptype.compare ("tabloid"))
+        {
+          retval(0) = 11.0 * in2units;
+          retval(1) = 17.0 * in2units;
+        }
+      else if (ptype.compare ("a0"))
+        {
+          retval(0) = 841.0 * mm2units;
+          retval(1) = 1189.0 * mm2units;
+        }
+      else if (ptype.compare ("a1"))
+        {
+          retval(0) = 594.0 * mm2units;
+          retval(1) = 841.0 * mm2units;
+        }
+      else if (ptype.compare ("a2"))
+        {
+          retval(0) = 420.0 * mm2units;
+          retval(1) = 594.0 * mm2units;
+        }
+      else if (ptype.compare ("a3"))
+        {
+          retval(0) = 297.0 * mm2units;
+          retval(1) = 420.0 * mm2units;
+        }
+      else if (ptype.compare ("a4"))
+        {
+          retval(0) = 210.0 * mm2units;
+          retval(1) = 297.0 * mm2units;
+        }
+      else if (ptype.compare ("a5"))
+        {
+          retval(0) = 148.0 * mm2units;
+          retval(1) = 210.0 * mm2units;
+        }
+      else if (ptype.compare ("b0"))
+        {
+          retval(0) = 1029.0 * mm2units;
+          retval(1) = 1456.0 * mm2units;
+        }
+      else if (ptype.compare ("b1"))
+        {
+          retval(0) = 728.0 * mm2units;
+          retval(1) = 1028.0 * mm2units;
+        }
+      else if (ptype.compare ("b2"))
+        {
+          retval(0) = 514.0 * mm2units;
+          retval(1) = 728.0 * mm2units;
+        }
+      else if (ptype.compare ("b3"))
+        {
+          retval(0) = 364.0 * mm2units;
+          retval(1) = 514.0 * mm2units;
+        }
+      else if (ptype.compare ("b4"))
+        {
+          retval(0) = 257.0 * mm2units;
+          retval(1) = 364.0 * mm2units;
+        }
+      else if (ptype.compare ("b5"))
+        {
+          retval(0) = 182.0 * mm2units;
+          retval(1) = 257.0 * mm2units;
+        }
+      else if (ptype.compare ("arch-a"))
+        {
+          retval(0) = 9.0 * in2units;
+          retval(1) = 12.0 * in2units;
+        }
+      else if (ptype.compare ("arch-b"))
+        {
+          retval(0) = 12.0 * in2units;
+          retval(1) = 18.0 * in2units;
+        }
+      else if (ptype.compare ("arch-c"))
+        {
+          retval(0) = 18.0 * in2units;
+          retval(1) = 24.0 * in2units;
+        }
+      else if (ptype.compare ("arch-d"))
+        {
+          retval(0) = 24.0 * in2units;
+          retval(1) = 36.0 * in2units;
+        }
+      else if (ptype.compare ("arch-e"))
+        {
+          retval(0) = 36.0 * in2units;
+          retval(1) = 48.0 * in2units;
+        }
+      else if (ptype.compare ("a"))
+        {
+          retval(0) = 8.5 * in2units;
+          retval(1) = 11.0 * in2units;
+        }
+      else if (ptype.compare ("b"))
+        {
+          retval(0) = 11.0 * in2units;
+          retval(1) = 17.0 * in2units;
+        }
+      else if (ptype.compare ("c"))
+        {
+          retval(0) = 17.0 * in2units;
+          retval(1) = 22.0 * in2units;
+        }
+      else if (ptype.compare ("d"))
+        {
+          retval(0) = 22.0 * in2units;
+          retval(1) = 34.0 * in2units;
+        }
+      else if (ptype.compare ("e"))
+        {
+          retval(0) = 34.0 * in2units;
+          retval(1) = 43.0 * in2units;
+        }
+    }
+
+  return retval;
 }
 
 
 Matrix
 figure::properties::get_auto_paperposition (void)
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix sz;
@@ -4299,19 +4328,19 @@ figure::properties::update_paperunits (c
 
   pos(0) /= sz(0);
   pos(1) /= sz(1);
   pos(2) /= sz(0);
   pos(3) /= sz(1);
 
   std::string porient = get_paperorientation ();
   caseless_str punits = get_paperunits ();
-  caseless_str typ = get_papertype ();
-
-  if (typ.compare ("<custom>"))
+  caseless_str ptype = get_papertype ();
+
+  if (ptype.compare ("<custom>"))
     {
       if (old_paperunits.compare ("centimeters"))
         {
           sz(0) /= 2.54;
           sz(1) /= 2.54;
         }
       else if (old_paperunits.compare ("points"))
         {
@@ -4327,17 +4356,17 @@ figure::properties::update_paperunits (c
       else if (punits.compare ("points"))
         {
           sz(0) *= 72.0;
           sz(1) *= 72.0;
         }
     }
   else
     {
-      sz = papersize_from_type (punits, typ);
+      sz = papersize_from_type (punits, ptype);
       if (porient == "landscape")
         std::swap (sz(0), sz(1));
     }
 
   pos(0) *= sz(0);
   pos(1) *= sz(1);
   pos(2) *= sz(0);
   pos(3) *= sz(1);
@@ -4351,17 +4380,17 @@ figure::properties::update_papertype (vo
 {
   caseless_str typ = get_papertype ();
   if (! typ.compare ("<custom>"))
     {
       Matrix sz = papersize_from_type (get_paperunits (), typ);
       if (get_paperorientation () == "landscape")
         std::swap (sz(0), sz(1));
       // Call papersize.set rather than set_papersize to avoid loops
-      // between update_papersize and update_papertype
+      // between update_papersize and update_papertype.
       papersize.set (octave_value (sz));
     }
 
   if (paperpositionmode.is ("auto"))
     paperposition.set (get_auto_paperposition ());
 }
 
 void
@@ -4373,116 +4402,117 @@ figure::properties::update_papersize (vo
       std::swap (sz(0), sz(1));
       papersize.set (octave_value (sz));
       paperorientation.set (octave_value ("landscape"));
     }
   else
     {
       paperorientation.set ("portrait");
     }
+
   std::string punits = get_paperunits ();
   if (punits == "centimeters")
     {
       sz(0) /= 2.54;
       sz(1) /= 2.54;
     }
   else if (punits == "points")
     {
       sz(0) /= 72.0;
       sz(1) /= 72.0;
     }
   if (punits == "normalized")
     {
-      caseless_str typ = get_papertype ();
       if (get_papertype () == "<custom>")
         error ("set: can't set the papertype to <custom> when the paperunits is normalized");
     }
   else
     {
-      // TODO - the papersizes info is also in papersize_from_type().
-      // Both should be rewritten to avoid the duplication.
-      std::string typ = "<custom>";
+      // FIXME: The papersizes info is also in papersize_from_type().
+      //        Both should be rewritten to avoid the duplication.
+      //        Don't Repeat Yourself (DRY) principle.
+      std::string ptype = "<custom>";
       const double mm2in = 1.0 / 25.4;
       const double tol = 0.01;
 
       if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 11.0) < tol)
-        typ = "usletter";
+        ptype = "usletter";
       else if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 14.0) < tol)
-        typ = "uslegal";
+        ptype = "uslegal";
       else if (std::abs (sz(0) - 11.0) + std::abs (sz(1) - 17.0) < tol)
-        typ = "tabloid";
+        ptype = "tabloid";
       else if (std::abs (sz(0) - 841.0 * mm2in)
                + std::abs (sz(1) - 1198.0 * mm2in) < tol)
-        typ = "a0";
+        ptype = "a0";
       else if (std::abs (sz(0) - 594.0 * mm2in)
                + std::abs (sz(1) - 841.0 * mm2in) < tol)
-        typ = "a1";
+        ptype = "a1";
       else if (std::abs (sz(0) - 420.0 * mm2in)
                + std::abs (sz(1) - 594.0 * mm2in) < tol)
-        typ = "a2";
+        ptype = "a2";
       else if (std::abs (sz(0) - 297.0 * mm2in)
                + std::abs (sz(1) - 420.0 * mm2in) < tol)
-        typ = "a3";
+        ptype = "a3";
       else if (std::abs (sz(0) - 210.0 * mm2in)
                + std::abs (sz(1) - 297.0 * mm2in) < tol)
-        typ = "a4";
+        ptype = "a4";
       else if (std::abs (sz(0) - 148.0 * mm2in)
                + std::abs (sz(1) - 210.0 * mm2in) < tol)
-        typ = "a5";
+        ptype = "a5";
       else if (std::abs (sz(0) - 1029.0 * mm2in)
                + std::abs (sz(1) - 1456.0 * mm2in) < tol)
-        typ = "b0";
+        ptype = "b0";
       else if (std::abs (sz(0) - 728.0 * mm2in)
                + std::abs (sz(1) - 1028.0 * mm2in) < tol)
-        typ = "b1";
+        ptype = "b1";
       else if (std::abs (sz(0) - 514.0 * mm2in)
                + std::abs (sz(1) - 728.0 * mm2in) < tol)
-        typ = "b2";
+        ptype = "b2";
       else if (std::abs (sz(0) - 364.0 * mm2in)
                + std::abs (sz(1) - 514.0 * mm2in) < tol)
-        typ = "b3";
+        ptype = "b3";
       else if (std::abs (sz(0) - 257.0 * mm2in)
                + std::abs (sz(1) - 364.0 * mm2in) < tol)
-        typ = "b4";
+        ptype = "b4";
       else if (std::abs (sz(0) - 182.0 * mm2in)
                + std::abs (sz(1) - 257.0 * mm2in) < tol)
-        typ = "b5";
+        ptype = "b5";
       else if (std::abs (sz(0) - 9.0)
                + std::abs (sz(1) - 12.0) < tol)
-        typ = "arch-a";
+        ptype = "arch-a";
       else if (std::abs (sz(0) - 12.0)
                + std::abs (sz(1) - 18.0) < tol)
-        typ = "arch-b";
+        ptype = "arch-b";
       else if (std::abs (sz(0) - 18.0)
                + std::abs (sz(1) - 24.0) < tol)
-        typ = "arch-c";
+        ptype = "arch-c";
       else if (std::abs (sz(0) - 24.0)
                + std::abs (sz(1) - 36.0) < tol)
-        typ = "arch-d";
+        ptype = "arch-d";
       else if (std::abs (sz(0) - 36.0)
                + std::abs (sz(1) - 48.0) < tol)
-        typ = "arch-e";
+        ptype = "arch-e";
       else if (std::abs (sz(0) - 8.5)
                + std::abs (sz(1) - 11.0) < tol)
-        typ = "a";
+        ptype = "a";
       else if (std::abs (sz(0) - 11.0)
                + std::abs (sz(1) - 17.0) < tol)
-        typ = "b";
+        ptype = "b";
       else if (std::abs (sz(0) - 17.0)
                + std::abs (sz(1) - 22.0) < tol)
-        typ = "c";
+        ptype = "c";
       else if (std::abs (sz(0) - 22.0)
                + std::abs (sz(1) - 34.0) < tol)
-        typ = "d";
+        ptype = "d";
       else if (std::abs (sz(0) - 34.0)
                + std::abs (sz(1) - 43.0) < tol)
-        typ = "e";
+        ptype = "e";
       // Call papertype.set rather than set_papertype to avoid loops between
       // update_papersize and update_papertype
-      papertype.set (typ);
+      papertype.set (ptype);
     }
   if (punits == "centimeters")
     {
       sz(0) *= 2.54;
       sz(1) *= 2.54;
     }
   else if (punits == "points")
     {
@@ -4576,22 +4606,22 @@ figure::properties::update_paperorientat
 %!   assert (get (hf, "papertype"), "usletter");
 %!   assert (get (hf, "paperorientation"), "landscape");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 */
 
 void
-figure::properties::set_units (const octave_value& v)
+figure::properties::set_units (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
-      if (units.set (v, true))
+      if (units.set (val, true))
         {
           update_units (old_units);
           mark_modified ();
         }
     }
 }
 
 void
@@ -4639,20 +4669,20 @@ figure::properties::get_title (void) con
 
 octave_value
 figure::get_default (const caseless_str& name) const
 {
   octave_value retval = default_properties.lookup (name);
 
   if (retval.is_undefined ())
     {
-      graphics_handle parent = get_parent ();
-      graphics_object parent_obj = gh_manager::get_object (parent);
-
-      retval = parent_obj.get_default (name);
+      graphics_handle parent_h = get_parent ();
+      graphics_object parent_go = gh_manager::get_object (parent_h);
+
+      retval = parent_go.get_default (name);
     }
 
   return retval;
 }
 
 void
 figure::reset_default_properties (void)
 {
@@ -4677,16 +4707,18 @@ axes::properties::init (void)
 {
   position.add_constraint (dim_vector (1, 4));
   outerposition.add_constraint (dim_vector (1, 4));
   tightinset.add_constraint (dim_vector (1, 4));
   looseinset.add_constraint (dim_vector (1, 4));
   colororder.add_constraint (dim_vector (-1, 3));
   dataaspectratio.add_constraint (dim_vector (1, 3));
   plotboxaspectratio.add_constraint (dim_vector (1, 3));
+  // FIXME: Should these use dimension vectors?  Currently can set 'xlim' to
+  // any matrix size, but only first two elements are used.
   alim.add_constraint (2);
   clim.add_constraint (2);
   xlim.add_constraint (2);
   ylim.add_constraint (2);
   zlim.add_constraint (2);
   xtick.add_constraint (dim_vector (1, -1));
   ytick.add_constraint (dim_vector (1, -1));
   ztick.add_constraint (dim_vector (1, -1));
@@ -4761,18 +4793,18 @@ axes::properties::init (void)
   tlooseinset(3) = 1-tlooseinset(1)-tlooseinset(3);
   looseinset = tlooseinset;
 }
 
 Matrix
 axes::properties::calc_tightbox (const Matrix& init_pos)
 {
   Matrix pos = init_pos;
-  graphics_object obj = gh_manager::get_object (get_parent ());
-  Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+  graphics_object go = gh_manager::get_object (get_parent ());
+  Matrix parent_bb = go.get_properties ().get_boundingbox (true);
   Matrix ext = get_extent (true, true);
   ext(1) = parent_bb(3) - ext(1) - ext(3);
   ext(0)++;
   ext(1)++;
   ext = convert_position (ext, "pixels", get_units (),
                           parent_bb.extract_n (0, 2, 1, 2));
   if (ext(0) < pos(0))
     {
@@ -4784,16 +4816,17 @@ axes::properties::calc_tightbox (const M
 
   if (ext(1) < pos(1))
     {
       pos(3) += pos(1)-ext(1);
       pos(1) = ext(1);
     }
   if (ext(1)+ext(3) > pos(1)+pos(3))
     pos(3) = ext(1)+ext(3)-pos(1);
+
   return pos;
 }
 
 void
 axes::properties::sync_positions (void)
 {
   // First part is equivalent to `update_tightinset ()'
   if (activepositionproperty.is ("position"))
@@ -4970,37 +5003,36 @@ axes::properties::set_title (const octav
   xset (title.handle_value (), "verticalalignment", "bottom");
   xset (title.handle_value (), "verticalalignmentmode", "auto");
   xset (title.handle_value (), "clipping", "off");
   xset (title.handle_value (), "autopos_tag", "title");
   update_title_position ();
 }
 
 void
-axes::properties::set_defaults (base_graphics_object& obj,
+axes::properties::set_defaults (base_graphics_object& bgo,
                                 const std::string& mode)
 {
   box = "on";
   colororder = default_colororder ();
   // Note: dataspectratio will be set through update_aspectratios
   dataaspectratiomode = "auto";
   layer = "bottom";
 
   Matrix tlim (1, 2, 0.0);
   tlim(1) = 1;
+  alim = tlim;
   xlim = tlim;
   ylim = tlim;
   zlim = tlim;
 
-  Matrix cl (1, 2, 0);
+  Matrix cl (1, 2, 0.0);
   cl(1) = 1;
   clim = cl;
 
-  alim = tlim;
-
   xlimmode = "auto";
   ylimmode = "auto";
   zlimmode = "auto";
   climmode = "auto";
   alimmode = "auto";
 
   xgrid = "off";
   ygrid = "off";
@@ -5164,17 +5196,17 @@ axes::properties::set_defaults (base_gra
 
   xset (xlabel.handle_value (), "autopos_tag", "xlabel");
   xset (ylabel.handle_value (), "autopos_tag", "ylabel");
   xset (zlabel.handle_value (), "autopos_tag", "zlabel");
   xset (title.handle_value (), "autopos_tag", "title");
 
   update_transform ();
   sync_positions ();
-  override_defaults (obj);
+  override_defaults (bgo);
 }
 
 void
 axes::properties::delete_text_child (handle_property& hp)
 {
   graphics_handle h = hp.handle_value ();
 
   if (h.ok ())
@@ -5229,56 +5261,74 @@ axes::properties::remove_child (const gr
   else
     base_properties::remove_child (h);
 }
 
 inline Matrix
 xform_matrix (void)
 {
   Matrix m (4, 4, 0.0);
+
   for (int i = 0; i < 4; i++)
     m(i,i) = 1;
+
   return m;
 }
 
 inline ColumnVector
 xform_vector (void)
 {
   ColumnVector v (4, 0.0);
+
   v(3) = 1;
+
   return v;
 }
 
 inline ColumnVector
 xform_vector (double x, double y, double z)
 {
   ColumnVector v (4, 1.0);
-  v(0) = x; v(1) = y; v(2) = z;
+
+  v(0) = x;
+  v(1) = y;
+  v(2) = z;
+
   return v;
 }
 
 inline ColumnVector
 transform (const Matrix& m, double x, double y, double z)
 {
   return (m * xform_vector (x, y, z));
 }
 
 inline Matrix
 xform_scale (double x, double y, double z)
 {
   Matrix m (4, 4, 0.0);
-  m(0,0) = x; m(1,1) = y; m(2,2) = z; m(3,3) = 1;
+
+  m(0,0) = x;
+  m(1,1) = y;
+  m(2,2) = z;
+  m(3,3) = 1;
+
   return m;
 }
 
 inline Matrix
 xform_translate (double x, double y, double z)
 {
   Matrix m = xform_matrix ();
-  m(0,3) = x; m(1,3) = y; m(2,3) = z; m(3,3) = 1;
+
+  m(0,3) = x;
+  m(1,3) = y;
+  m(2,3) = z;
+  m(3,3) = 1;
+
   return m;
 }
 
 inline void
 scale (Matrix& m, double x, double y, double z)
 {
   m = m * xform_scale (x, y, z);
 }
@@ -5287,17 +5337,17 @@ inline void
 translate (Matrix& m, double x, double y, double z)
 {
   m = m * xform_translate (x, y, z);
 }
 
 inline void
 xform (ColumnVector& v, const Matrix& m)
 {
-  v = m*v;
+  v = m * v;
 }
 
 inline void
 scale (ColumnVector& v, double x, double y, double z)
 {
   v(0) *= x;
   v(1) *= y;
   v(2) *= z;
@@ -5329,19 +5379,21 @@ norm (const ColumnVector& v)
 {
   return sqrt (dot (v, v));
 }
 
 inline ColumnVector
 cross (const ColumnVector& v1, const ColumnVector& v2)
 {
   ColumnVector r = xform_vector ();
-  r(0) = v1(1)*v2(2)-v1(2)*v2(1);
-  r(1) = v1(2)*v2(0)-v1(0)*v2(2);
-  r(2) = v1(0)*v2(1)-v1(1)*v2(0);
+
+  r(0) = v1(1)*v2(2) - v1(2)*v2(1);
+  r(1) = v1(2)*v2(0) - v1(0)*v2(2);
+  r(2) = v1(0)*v2(1) - v1(1)*v2(0);
+
   return r;
 }
 
 inline Matrix
 unit_cube (void)
 {
   static double data[32] =
   {
@@ -5350,25 +5402,29 @@ unit_cube (void)
     0,1,0,1,
     0,0,1,1,
     1,1,0,1,
     1,0,1,1,
     0,1,1,1,
     1,1,1,1
   };
   Matrix m (4, 8);
+
   memcpy (m.fortran_vec (), data, sizeof (double)*32);
+
   return m;
 }
 
 inline ColumnVector
 cam2xform (const Array<double>& m)
 {
   ColumnVector retval (4, 1.0);
+
   memcpy (retval.fortran_vec (), m.fortran_vec (), sizeof (double)*3);
+
   return retval;
 }
 
 inline RowVector
 xform2cam (const ColumnVector& v)
 {
   return v.extract_n (0, 3).transpose ();
 }
@@ -5398,31 +5454,31 @@ axes::properties::update_camera (void)
                  && plotboxaspectratiomode_is ("auto"));
 
   ColumnVector c_eye (xform_vector ());
   ColumnVector c_center (xform_vector ());
   ColumnVector c_upv (xform_vector ());
 
   if (cameratargetmode_is ("auto"))
     {
-      c_center(0) = (xlimits(0)+xlimits(1))/2;
-      c_center(1) = (ylimits(0)+ylimits(1))/2;
-      c_center(2) = (zlimits(0)+zlimits(1))/2;
+      c_center(0) = (xlimits(0) + xlimits(1)) / 2;
+      c_center(1) = (ylimits(0) + ylimits(1)) / 2;
+      c_center(2) = (zlimits(0) + zlimits(1)) / 2;
 
       cameratarget = xform2cam (c_center);
     }
   else
     c_center = cam2xform (get_cameratarget ().matrix_value ());
 
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0);
       double el = tview(1);
-      double d = 5 * sqrt (pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
+      double d = 5 * sqrt (pb(0)*pb(0) + pb(1)*pb(1) + pb(2)*pb(2));
 
       if (el == 90 || el == -90)
         c_eye(2) = d*signum (el);
       else
         {
           az *= M_PI/180.0;
           el *= M_PI/180.0;
           c_eye(0) = d * cos (el) * sin (az);
@@ -5481,17 +5537,17 @@ axes::properties::update_camera (void)
   translate (c_center, -c_eye(0), -c_eye(1), -c_eye(2));
 
   ColumnVector F (c_center), f (F), UP (c_upv);
   normalize (f);
   normalize (UP);
 
   if (std::abs (dot (f, UP)) > 1e-15)
     {
-      double fa = 1 / sqrt(1-f(2)*f(2));
+      double fa = 1 / sqrt (1 - f(2)*f(2));
       scale (UP, fa, fa, fa);
     }
 
   ColumnVector s = cross (f, UP);
   ColumnVector u = cross (s, f);
 
   scale (x_view, 1, 1, -1);
   Matrix l = xform_matrix ();
@@ -5501,18 +5557,18 @@ axes::properties::update_camera (void)
   x_view = x_view * l;
   translate (x_view, -c_eye(0), -c_eye(1), -c_eye(2));
   scale (x_view, pb(0), pb(1), pb(2));
   translate (x_view, -0.5, -0.5, -0.5);
 
   Matrix x_cube = x_view * unit_cube ();
   ColumnVector cmin = x_cube.row_min ();
   ColumnVector cmax = x_cube.row_max ();
-  double xM = cmax(0)-cmin(0);
-  double yM = cmax(1)-cmin(1);
+  double xM = cmax(0) - cmin(0);
+  double yM = cmax(1) - cmin(1);
 
   Matrix bb = get_boundingbox (true);
 
   double v_angle;
 
   if (cameraviewanglemode_is ("auto"))
     {
       double af;
@@ -5579,19 +5635,18 @@ axes::properties::update_camera (void)
   x_viewtransform = x_view;
   x_projectiontransform = x_projection;
   x_viewporttransform = x_viewport;
   x_normrendertransform = x_normrender;
   x_rendertransform = x_render;
 
   x_render_inv = x_render.inverse ();
 
-  // Note: these matrices are a slight modified version of the regular
-  // matrices, more suited for OpenGL rendering (x_gl_mat1 => light
-  // => x_gl_mat2)
+  // Note: these matrices are a slight modified version of the regular matrices,
+  // more suited for OpenGL rendering (x_gl_mat1 => light => x_gl_mat2)
   x_gl_mat1 = x_view;
   scale (x_gl_mat1, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
          zd/(zlimits(1)-zlimits(0)));
   translate (x_gl_mat1, -xo, -yo, -zo);
   x_gl_mat2 = x_viewport * x_projection;
 }
 
 static bool updating_axes_layout = false;
@@ -5618,19 +5673,19 @@ axes::properties::update_axes_layout (vo
   z_min = zlims(0), z_max = zlims(1);
 
   ColumnVector p1, p2, dir (3);
 
   xstate = ystate = zstate = AXE_ANY_DIR;
 
   p1 = xform.transform (x_min, (y_min+y_max)/2, (z_min+z_max)/2, false);
   p2 = xform.transform (x_max, (y_min+y_max)/2, (z_min+z_max)/2, false);
-  dir(0) = xround (p2(0)-p1(0));
-  dir(1) = xround (p2(1)-p1(1));
-  dir(2) = (p2(2)-p1(2));
+  dir(0) = xround (p2(0) - p1(0));
+  dir(1) = xround (p2(1) - p1(1));
+  dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     xstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         xstate = AXE_VERT_DIR;
       else if (dir(1) == 0)
         xstate = AXE_HORZ_DIR;
@@ -5642,23 +5697,23 @@ axes::properties::update_axes_layout (vo
         xPlane = (dir(0) > 0 ? x_max : x_min);
       else
         xPlane = (dir(1) < 0 ? x_max : x_min);
     }
   else
     xPlane = (dir(2) < 0 ? x_min : x_max);
 
   xPlaneN = (xPlane == x_min ? x_max : x_min);
-  fx = (x_max-x_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
-
-  p1 = xform.transform ((x_min+x_max)/2, y_min, (z_min+z_max)/2, false);
-  p2 = xform.transform ((x_min+x_max)/2, y_max, (z_min+z_max)/2, false);
-  dir(0) = xround (p2(0)-p1(0));
-  dir(1) = xround (p2(1)-p1(1));
-  dir(2) = (p2(2)-p1(2));
+  fx = (x_max - x_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
+
+  p1 = xform.transform ((x_min + x_max)/2, y_min, (z_min + z_max)/2, false);
+  p2 = xform.transform ((x_min + x_max)/2, y_max, (z_min + z_max)/2, false);
+  dir(0) = xround (p2(0) - p1(0));
+  dir(1) = xround (p2(1) - p1(1));
+  dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     ystate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         ystate = AXE_VERT_DIR;
       else if (dir(1) == 0)
         ystate = AXE_HORZ_DIR;
@@ -5670,23 +5725,23 @@ axes::properties::update_axes_layout (vo
         yPlane = (dir(0) > 0 ? y_max : y_min);
       else
         yPlane = (dir(1) < 0 ? y_max : y_min);
     }
   else
     yPlane = (dir(2) < 0 ? y_min : y_max);
 
   yPlaneN = (yPlane == y_min ? y_max : y_min);
-  fy = (y_max-y_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
-
-  p1 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_min, false);
-  p2 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_max, false);
-  dir(0) = xround (p2(0)-p1(0));
-  dir(1) = xround (p2(1)-p1(1));
-  dir(2) = (p2(2)-p1(2));
+  fy = (y_max - y_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
+
+  p1 = xform.transform ((x_min + x_max)/2, (y_min + y_max)/2, z_min, false);
+  p2 = xform.transform ((x_min + x_max)/2, (y_min + y_max)/2, z_max, false);
+  dir(0) = xround (p2(0) - p1(0));
+  dir(1) = xround (p2(1) - p1(1));
+  dir(2) = (p2(2) - p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     zstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         zstate = AXE_VERT_DIR;
       else if (dir(1) == 0)
         zstate = AXE_HORZ_DIR;
@@ -5698,17 +5753,17 @@ axes::properties::update_axes_layout (vo
         zPlane = (dir(0) > 0 ? z_min : z_max);
       else
         zPlane = (dir(1) < 0 ? z_min : z_max);
     }
   else
     zPlane = (dir(2) < 0 ? z_min : z_max);
 
   zPlaneN = (zPlane == z_min ? z_max : z_min);
-  fz = (z_max-z_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
+  fz = (z_max - z_min) / sqrt (dir(0)*dir(0) + dir(1)*dir(1));
 
   unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
   xyzSym = zSign ? xySym : !xySym;
@@ -5764,18 +5819,18 @@ axes::properties::update_ticklength (voi
 
   if (tickdirmode_is ("auto"))
     tickdir.set (mode2d ? "in" : "out", true);
 
   double ticksign = (tickdir_is ("in") ? -1 : 1);
 
   Matrix bbox = get_boundingbox (true);
   Matrix ticklen = get_ticklength ().matrix_value ();
-  ticklen(0) = ticklen(0) * std::max (bbox(2), bbox(3));
-  ticklen(1) = ticklen(1) * std::max (bbox(2), bbox(3));
+  ticklen(0) *= std::max (bbox(2), bbox(3));
+  ticklen(1) *= std::max (bbox(2), bbox(3));
 
   xticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
   yticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
   zticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
 
   xtickoffset = (mode2d ? std::max (0., xticklen) : std::abs (xticklen)) + 5;
   ytickoffset = (mode2d ? std::max (0., yticklen) : std::abs (yticklen)) + 5;
   ztickoffset = (mode2d ? std::max (0., zticklen) : std::abs (zticklen)) + 5;
@@ -5836,37 +5891,36 @@ convert_label_position (const ColumnVect
 static bool updating_xlabel_position = false;
 
 void
 axes::properties::update_xlabel_position (void)
 {
   if (updating_xlabel_position)
     return;
 
-  graphics_object obj = gh_manager::get_object (get_xlabel ());
-
-  if (! obj.valid_object ())
+  graphics_object go = gh_manager::get_object (get_xlabel ());
+
+  if (! go.valid_object ())
     return;
 
   text::properties& xlabel_props
-    = reinterpret_cast<text::properties&> (obj.get_properties ());
+    = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool is_empty = xlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_xlabel_position);
   updating_xlabel_position = true;
 
   if (! is_empty)
     {
       if (xlabel_props.horizontalalignmentmode_is ("auto"))
         {
           xlabel_props.set_horizontalalignment
-            (xstate > AXE_DEPTH_DIR
-             ? "center" : (xyzSym ? "left" : "right"));
+            (xstate > AXE_DEPTH_DIR ? "center" : (xyzSym ? "left" : "right"));
 
           xlabel_props.set_horizontalalignmentmode ("auto");
         }
 
       if (xlabel_props.verticalalignmentmode_is ("auto"))
         {
           xlabel_props.set_verticalalignment
             (xstate == AXE_VERT_DIR || x2Dtop ? "bottom" : "top");
@@ -5882,25 +5936,25 @@ axes::properties::update_xlabel_position
 
       Matrix ext (1, 2, 0.0);
       ext = get_ticklabel_extents (get_xtick ().matrix_value (),
                                    get_xticklabel ().all_strings (),
                                    get_xlim ().matrix_value ());
 
       double wmax = ext(0);
       double hmax = ext(1);
-      double angle = 0;
+      double angle = 0.0;
       ColumnVector p =
-        graphics_xform::xform_vector ((xpTickN+xpTick)/2, ypTick, zpTick);
+        graphics_xform::xform_vector ((xpTickN + xpTick)/2, ypTick, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fy);
       if (tick_along_z)
-        p(2) += (signum (zpTick-zpTickN)*fz*xtickoffset);
+        p(2) += (signum (zpTick - zpTickN) * fz * xtickoffset);
       else
-        p(1) += (signum (ypTick-ypTickN)*fy*xtickoffset);
+        p(1) += (signum (ypTick - ypTickN) * fy * xtickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (xstate)
         {
         case AXE_ANY_DIR:
           p(0) += (xyzSym ? wmax : -wmax);
           p(1) += hmax;
@@ -5938,37 +5992,36 @@ axes::properties::update_xlabel_position
 static bool updating_ylabel_position = false;
 
 void
 axes::properties::update_ylabel_position (void)
 {
   if (updating_ylabel_position)
     return;
 
-  graphics_object obj = gh_manager::get_object (get_ylabel ());
-
-  if (! obj.valid_object ())
+  graphics_object go = gh_manager::get_object (get_ylabel ());
+
+  if (! go.valid_object ())
     return;
 
   text::properties& ylabel_props
-    = reinterpret_cast<text::properties&> (obj.get_properties ());
+    = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool is_empty = ylabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
   if (! is_empty)
     {
       if (ylabel_props.horizontalalignmentmode_is ("auto"))
         {
           ylabel_props.set_horizontalalignment
-            (ystate > AXE_DEPTH_DIR
-             ? "center" : (!xyzSym ? "left" : "right"));
+            (ystate > AXE_DEPTH_DIR ? "center" : (!xyzSym ? "left" : "right"));
 
           ylabel_props.set_horizontalalignmentmode ("auto");
         }
 
       if (ylabel_props.verticalalignmentmode_is ("auto"))
         {
           ylabel_props.set_verticalalignment
             (ystate == AXE_VERT_DIR && !y2Dright ? "bottom" : "top");
@@ -5993,25 +6046,25 @@ axes::properties::update_ylabel_position
       // ALWAYS use an even number for padding or horizontal alignment
       // will be off.
       ext = get_ticklabel_extents (get_ytick ().matrix_value (),
                                    get_yticklabel ().all_strings (),
                                    get_ylim ().matrix_value ());
 
       double wmax = ext(0)+4;
       double hmax = ext(1);
-      double angle = 0;
+      double angle = 0.0;
       ColumnVector p =
-        graphics_xform::xform_vector (xpTick, (ypTickN+ypTick)/2, zpTick);
+        graphics_xform::xform_vector (xpTick, (ypTickN + ypTick)/2, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fx);
       if (tick_along_z)
-        p(2) += (signum (zpTick-zpTickN)*fz*ytickoffset);
+        p(2) += (signum (zpTick - zpTickN) * fz * ytickoffset);
       else
-        p(0) += (signum (xpTick-xpTickN)*fx*ytickoffset);
+        p(0) += (signum (xpTick - xpTickN) * fx * ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
         case AXE_ANY_DIR:
           p(0) += (!xyzSym ? wmax : -wmax);
           p(1) += hmax;
@@ -6049,23 +6102,23 @@ axes::properties::update_ylabel_position
 static bool updating_zlabel_position = false;
 
 void
 axes::properties::update_zlabel_position (void)
 {
   if (updating_zlabel_position)
     return;
 
-  graphics_object obj = gh_manager::get_object (get_zlabel ());
-
-  if (! obj.valid_object ())
+  graphics_object go = gh_manager::get_object (get_zlabel ());
+
+  if (! go.valid_object ())
     return;
 
   text::properties& zlabel_props
-    = reinterpret_cast<text::properties&> (obj.get_properties ());
+    = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool camAuto = cameraupvectormode_is ("auto");
   bool is_empty = zlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_zlabel_position);
   updating_zlabel_position = true;
 
@@ -6096,36 +6149,36 @@ axes::properties::update_zlabel_position
 
       Matrix ext (1, 2, 0.0);
       ext = get_ticklabel_extents (get_ztick ().matrix_value (),
                                    get_zticklabel ().all_strings (),
                                    get_zlim ().matrix_value ());
 
       double wmax = ext(0);
       double hmax = ext(1);
-      double angle = 0;
+      double angle = 0.0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
-                                            (zpTickN+zpTick)/2);
+                                            (zpTickN + zpTick)/2);
           if (xisinf (fy))
-            p(0) += (signum (xPlaneN-xPlane)*fx*ztickoffset);
+            p(0) += (signum (xPlaneN - xPlane) * fx * ztickoffset);
           else
-            p(1) += (signum (yPlane-yPlaneN)*fy*ztickoffset);
+            p(1) += (signum (yPlane - yPlaneN) * fy * ztickoffset);
         }
       else
         {
           p = graphics_xform::xform_vector (xPlane, yPlaneN,
-                                            (zpTickN+zpTick)/2);
+                                            (zpTickN + zpTick)/2);
           if (xisinf (fx))
-            p(1) += (signum (yPlaneN-yPlane)*fy*ztickoffset);
+            p(1) += (signum (yPlaneN - yPlane) * fy * ztickoffset);
           else
-            p(0) += (signum (xPlane-xPlaneN)*fx*ztickoffset);
+            p(0) += (signum (xPlane - xPlaneN) * fx * ztickoffset);
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
         case AXE_ANY_DIR:
           if (camAuto)
@@ -6173,39 +6226,39 @@ axes::properties::update_zlabel_position
 static bool updating_title_position = false;
 
 void
 axes::properties::update_title_position (void)
 {
   if (updating_title_position)
     return;
 
-  graphics_object obj = gh_manager::get_object (get_title ());
-
-  if (! obj.valid_object ())
+  graphics_object go = gh_manager::get_object (get_title ());
+
+  if (! go.valid_object ())
     return;
 
   text::properties& title_props
-    = reinterpret_cast<text::properties&> (obj.get_properties ());
+    = reinterpret_cast<text::properties&> (go.get_properties ());
 
   unwind_protect frame;
   frame.protect_var (updating_title_position);
   updating_title_position = true;
 
   if (title_props.positionmode_is ("auto"))
     {
       graphics_xform xform = get_transform ();
 
       // FIXME: bbox should be stored in axes::properties
       Matrix bbox = get_extent (false);
 
       ColumnVector p =
-        graphics_xform::xform_vector (bbox(0)+bbox(2)/2,
-                                      bbox(1)-10,
-                                      (x_zlim(0)+x_zlim(1))/2);
+        graphics_xform::xform_vector (bbox(0) + bbox(2)/2,
+                                      bbox(1) - 10,
+                                      (x_zlim(0) + x_zlim(1))/2);
 
       if (x2Dtop)
         {
           Matrix ext (1, 2, 0.0);
           ext = get_ticklabel_extents (get_xtick ().matrix_value (),
                                        get_xticklabel ().all_strings (),
                                        get_xlim ().matrix_value ());
           p(1) -= ext(1);
@@ -6234,25 +6287,25 @@ axes::properties::update_autopos (const 
   else if (elem_type == "sync")
     sync_positions ();
 }
 
 static void
 normalized_aspectratios (Matrix& aspectratios, const Matrix& scalefactors,
                          double xlength, double ylength, double zlength)
 {
-  double xval = xlength/scalefactors(0);
-  double yval = ylength/scalefactors(1);
-  double zval = zlength/scalefactors(2);
+  double xval = xlength / scalefactors(0);
+  double yval = ylength / scalefactors(1);
+  double zval = zlength / scalefactors(2);
 
   double minval = xmin (xmin (xval, yval), zval);
 
-  aspectratios(0) = xval/minval;
-  aspectratios(1) = yval/minval;
-  aspectratios(2) = zval/minval;
+  aspectratios(0) = xval / minval;
+  aspectratios(1) = yval / minval;
+  aspectratios(2) = zval / minval;
 }
 
 static void
 max_axes_scale (double& s, Matrix& limits, const Matrix& kids,
                 double pbfactor, double dafactor, char limit_type, bool tight)
 {
   if (tight)
     {
@@ -6260,39 +6313,39 @@ max_axes_scale (double& s, Matrix& limit
       double maxval = -octave_Inf;
       double min_pos = octave_Inf;
       double max_neg = -octave_Inf;
       get_children_limits (minval, maxval, min_pos, max_neg, kids, limit_type);
       if (xfinite (minval) && xfinite (maxval))
         {
           limits(0) = minval;
           limits(1) = maxval;
-          s = xmax(s, (maxval - minval) / (pbfactor * dafactor));
-        }
-    }
-  else
-    s = xmax(s, (limits(1) - limits(0)) / (pbfactor * dafactor));
+          s = xmax (s, (maxval - minval) / (pbfactor * dafactor));
+        }
+    }
+  else
+    s = xmax (s, (limits(1) - limits(0)) / (pbfactor * dafactor));
 }
 
 static std::set<double> updating_aspectratios;
 
 void
 axes::properties::update_aspectratios (void)
 {
   if (updating_aspectratios.find (get___myhandle__ ().value ())
       != updating_aspectratios.end ())
     return;
 
   Matrix xlimits = get_xlim ().matrix_value ();
   Matrix ylimits = get_ylim ().matrix_value ();
   Matrix zlimits = get_zlim ().matrix_value ();
 
-  double dx = (xlimits(1)-xlimits(0));
-  double dy = (ylimits(1)-ylimits(0));
-  double dz = (zlimits(1)-zlimits(0));
+  double dx = (xlimits(1) - xlimits(0));
+  double dy = (ylimits(1) - ylimits(0));
+  double dz = (zlimits(1) - zlimits(0));
 
   Matrix da = get_dataaspectratio ().matrix_value ();
   Matrix pba = get_plotboxaspectratio ().matrix_value ();
 
   if (dataaspectratiomode_is ("auto"))
     {
       if (plotboxaspectratiomode_is ("auto"))
         {
@@ -6335,25 +6388,24 @@ axes::properties::update_aspectratios (v
       else if (zlimmode_is ("auto") && xlimmode_is ("auto"))
         {
           modified_limits = true;
           max_axes_scale (s, ylimits, kids, pba(1), da(1), 'y', false);
         }
 
       if (modified_limits)
         {
-
           unwind_protect frame;
           frame.protect_var (updating_aspectratios);
 
           updating_aspectratios.insert (get___myhandle__ ().value ());
 
-          dx = pba(0) *da(0);
-          dy = pba(1) *da(1);
-          dz = pba(2) *da(2);
+          dx = pba(0) * da(0);
+          dy = pba(1) * da(1);
+          dz = pba(2) * da(2);
           if (xisinf (s))
             s = 1 / xmin (xmin (dx, dy), dz);
 
           if (xlimmode_is ("auto"))
             {
               dx = s * dx;
               xlimits(0) = 0.5 * (xlimits(0) + xlimits(1) - dx);
               xlimits(1) = xlimits(0) + dx;
@@ -6405,23 +6457,23 @@ axes::properties::update_font (void)
 Matrix
 axes::properties::get_boundingbox (bool internal,
                                    const Matrix& parent_pix_size) const
 {
   Matrix pos = internal ? get_position ().matrix_value ()
                         : get_outerposition ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.numel () == 0)
-    {
-      graphics_object obj = gh_manager::get_object (get_parent ());
-
-      if (obj.valid_object ())
+  if (parent_size.is_empty ())
+    {
+      graphics_object go = gh_manager::get_object (get_parent ());
+
+      if (go.valid_object ())
         parent_size =
-          obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+          go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
       else
         parent_size = default_figure_position ();
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
@@ -6431,20 +6483,18 @@ axes::properties::get_boundingbox (bool 
 }
 
 Matrix
 axes::properties::get_extent (bool with_text, bool only_text_height) const
 {
   graphics_xform xform = get_transform ();
 
   Matrix ext (1, 4, 0.0);
-  ext(0) = octave_Inf;
-  ext(1) = octave_Inf;
-  ext(2) = -octave_Inf;
-  ext(3) = -octave_Inf;
+  ext(0) = ext(1) = octave_Inf;
+  ext(2) = ext(3) = -octave_Inf;
   for (int i = 0; i <= 1; i++)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
         {
           ColumnVector p = xform.transform (i ? xPlaneN : xPlane,
                                             j ? yPlaneN : yPlane,
                                             k ? zPlaneN : zPlane, false);
           ext(0) = std::min (ext(0), p(0));
@@ -6452,29 +6502,29 @@ axes::properties::get_extent (bool with_
           ext(2) = std::max (ext(2), p(0));
           ext(3) = std::max (ext(3), p(1));
         }
 
   if (with_text)
     {
       for (int i = 0; i < 4; i++)
         {
-          graphics_handle text_handle;
+          graphics_handle htext;
           if (i == 0)
-            text_handle = get_title ();
+            htext = get_title ();
           else if (i == 1)
-            text_handle = get_xlabel ();
+            htext = get_xlabel ();
           else if (i == 2)
-            text_handle = get_ylabel ();
+            htext = get_ylabel ();
           else if (i == 3)
-            text_handle = get_zlabel ();
+            htext = get_zlabel ();
 
           text::properties& text_props
             = reinterpret_cast<text::properties&>
-                (gh_manager::get_object (text_handle).get_properties ());
+                (gh_manager::get_object (htext).get_properties ());
 
           Matrix text_pos = text_props.get_data_position ();
           text_pos = xform.transform (text_pos(0), text_pos(1), text_pos(2));
           if (text_props.get_string ().is_empty ())
             {
               ext(0) = std::min (ext(0), text_pos(0));
               ext(1) = std::min (ext(1), text_pos(1));
               ext(2) = std::max (ext(2), text_pos(0));
@@ -6507,30 +6557,30 @@ axes::properties::get_extent (bool with_
                   ext(1) = std::min (ext(1),
                                      text_pos(1)-text_ext(1)-text_ext(3));
                   ext(3) = std::max (ext(3), text_pos(1)-text_ext(1));
                 }
             }
         }
     }
 
-  ext(2) = ext(2)-ext(0);
-  ext(3) = ext(3)-ext(1);
+  ext(2) = ext(2) - ext(0);
+  ext(3) = ext(3) - ext(1);
 
   return ext;
 }
 
 static octave_value
 convert_ticklabel_string (const octave_value& val)
 {
   octave_value retval = val;
 
   if (val.is_cellstr ())
     {
-      // Always return a column vector for Matlab Compatibility
+      // Always return a column vector for Matlab compatibility
       if (val.columns () > 1)
         retval = val.reshape (dim_vector (val.numel (), 1));
     }
   else
     {
       string_vector sv;
       if (val.is_numeric_type ())
         {
@@ -6565,57 +6615,57 @@ convert_ticklabel_string (const octave_v
 
       retval = octave_value (chmat);
     }
 
   return retval;
 }
 
 void
-axes::properties::set_xticklabel (const octave_value& v)
-{
-  if (!error_state)
-    {
-      if (xticklabel.set (convert_ticklabel_string (v), false))
+axes::properties::set_xticklabel (const octave_value& val)
+{
+  if (! error_state)
+    {
+      if (xticklabel.set (convert_ticklabel_string (val), false))
         {
           set_xticklabelmode ("manual");
           xticklabel.run_listeners (POSTSET);
           mark_modified ();
         }
       else
         set_xticklabelmode ("manual");
 
       sync_positions ();
     }
 }
 
 void
-axes::properties::set_yticklabel (const octave_value& v)
-{
-  if (!error_state)
-    {
-      if (yticklabel.set (convert_ticklabel_string (v), false))
+axes::properties::set_yticklabel (const octave_value& val)
+{
+  if (! error_state)
+    {
+      if (yticklabel.set (convert_ticklabel_string (val), false))
         {
           set_yticklabelmode ("manual");
           yticklabel.run_listeners (POSTSET);
           mark_modified ();
         }
       else
         set_yticklabelmode ("manual");
 
       sync_positions ();
     }
 }
 
 void
-axes::properties::set_zticklabel (const octave_value& v)
-{
-  if (!error_state)
-    {
-      if (zticklabel.set (convert_ticklabel_string (v), false))
+axes::properties::set_zticklabel (const octave_value& val)
+{
+  if (! error_state)
+    {
+      if (zticklabel.set (convert_ticklabel_string (val), false))
         {
           set_zticklabelmode ("manual");
           zticklabel.run_listeners (POSTSET);
           mark_modified ();
         }
       else
         set_zticklabelmode ("manual");
 
@@ -6660,44 +6710,44 @@ convert_linestyleorder_string (const oct
 
       retval = octave_value (chmat);
     }
 
   return retval;
 }
 
 void
-axes::properties::set_linestyleorder (const octave_value& v)
-{
-  if (!error_state)
-    {
-      linestyleorder.set (convert_linestyleorder_string (v), false);
-    }
-}
-
-void
-axes::properties::set_units (const octave_value& v)
+axes::properties::set_linestyleorder (const octave_value& val)
+{
+  if (! error_state)
+    {
+      linestyleorder.set (convert_linestyleorder_string (val), false);
+    }
+}
+
+void
+axes::properties::set_units (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
-      if (units.set (v, true))
+      if (units.set (val, true))
         {
           update_units (old_units);
           mark_modified ();
         }
     }
 }
 
 void
 axes::properties::update_units (const caseless_str& old_units)
 {
-  graphics_object obj = gh_manager::get_object (get_parent ());
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
   Matrix parent_bb
-    = obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    = parent_go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
   caseless_str new_units = get_units ();
   position.set (octave_value (convert_position (get_position ().matrix_value (),
                                                 old_units, new_units,
                                                 parent_bb)),
                                                 false);
   outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (),
                                                 old_units, new_units,
                                                 parent_bb)),
@@ -6708,68 +6758,67 @@ axes::properties::update_units (const ca
                                                 false);
   looseinset.set (octave_value (convert_position (get_looseinset ().matrix_value (),
                                                 old_units, new_units,
                                                 parent_bb)),
                                                 false);
 }
 
 void
-axes::properties::set_fontunits (const octave_value& v)
+axes::properties::set_fontunits (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (v, true))
+      if (fontunits.set (val, true))
         {
           update_fontunits (old_fontunits);
           mark_modified ();
         }
     }
 }
 
 void
 axes::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (true).elem (3);
-  double fsz = get_fontsize ();
-
-  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
-
-  set_fontsize (octave_value (fsz));
+  double fontsz = get_fontsize ();
+
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fontsz));
 }
 
 double
 axes::properties::get_fontsize_points (double box_pix_height) const
 {
-  double fs = get_fontsize ();
+  double fontsz = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     parent_height = get_boundingbox (true).elem (3);
 
-  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 ColumnVector
 graphics_xform::xform_vector (double x, double y, double z)
 {
   return ::xform_vector (x, y, z);
 }
 
 Matrix
 graphics_xform::xform_eye (void)
 {
   return ::xform_matrix ();
 }
 
 ColumnVector
-graphics_xform::transform (double x, double y, double z,
-                           bool use_scale) const
+graphics_xform::transform (double x, double y, double z, bool use_scale) const
 {
   if (use_scale)
     {
       x = sx.scale (x);
       y = sy.scale (y);
       z = sz.scale (z);
     }
 
@@ -6788,26 +6837,26 @@ graphics_xform::untransform (double x, d
       v(1) = sy.unscale (v(1));
       v(2) = sz.unscale (v(2));
     }
 
   return v;
 }
 
 octave_value
-axes::get_default (const caseless_str& name) const
-{
-  octave_value retval = default_properties.lookup (name);
+axes::get_default (const caseless_str& pname) const
+{
+  octave_value retval = default_properties.lookup (pname);
 
   if (retval.is_undefined ())
     {
-      graphics_handle parent = get_parent ();
-      graphics_object parent_obj = gh_manager::get_object (parent);
-
-      retval = parent_obj.get_default (name);
+      graphics_handle parent_h = get_parent ();
+      graphics_object parent_go = gh_manager::get_object (parent_h);
+
+      retval = parent_go.get_default (pname);
     }
 
   return retval;
 }
 
 // FIXME: remove.
 // FIXME: maybe this should go into array_property class?
 /*
@@ -6858,18 +6907,18 @@ check_limit_vals (double& min_val, doubl
 
           val = m(3);
           if (xfinite (val) && val < 0 && val > max_neg)
             max_neg = val;
         }
     }
 }
 
-// magform(x) Returns (a, b), where x = a * 10^b, abs (a) >= 1., and b is
-// integer.
+// magform(x) Returns (a, b),
+// where x = a * 10^b, abs (a) >= 1., and b is integer.
 
 static void
 magform (double x, double& a, int& b)
 {
   if (x == 0)
     {
       a = 0;
       b = 0;
@@ -6885,46 +6934,44 @@ magform (double x, double& a, int& b)
 // http://kurage.nimh.nih.gov/tomh/tics.py
 // FIXME: add log ticks
 
 double
 axes::properties::calc_tick_sep (double lo, double hi)
 {
   int ticint = 5;
 
-  // Reference: Lewart, C. R., "Algorithms SCALE1, SCALE2, and
-  // SCALE3 for Determination of Scales on Computer Generated
-  // Plots", Communications of the ACM, 10 (1973), 639-640.
+  // Reference: Lewart, C. R., "Algorithms SCALE1, SCALE2, and SCALE3 for
+  // Determination of Scales on Computer Generated Plots", Communications of
+  // the ACM, 10 (1973), 639-640.
   // Also cited as ACM Algorithm 463.
 
   double a;
   int b, x;
 
-  magform ((hi-lo)/ticint, a, b);
+  magform ((hi - lo) / ticint, a, b);
 
   static const double sqrt_2 = sqrt (2.0);
   static const double sqrt_10 = sqrt (10.0);
   static const double sqrt_50 = sqrt (50.0);
 
   if (a < sqrt_2)
     x = 1;
   else if (a < sqrt_10)
     x = 2;
   else if (a < sqrt_50)
     x = 5;
   else
     x = 10;
 
   return x * std::pow (10., b);
-
-}
-
-// Attempt to make "nice" limits from the actual max and min of the
-// data.  For log plots, we will also use the smallest strictly positive
-// value.
+}
+
+// Attempt to make "nice" limits from the actual max and min of the data.
+// For log plots, we will also use the smallest strictly positive value.
 
 Matrix
 axes::properties::get_axis_limits (double xmin, double xmax,
                                    double min_pos, double max_neg,
                                    bool logscale)
 {
   Matrix retval;
 
@@ -6937,25 +6984,25 @@ axes::properties::get_axis_limits (doubl
       return retval;
     }
   else if (! (xisinf (min_val) || xisinf (max_val)))
     {
       if (logscale)
         {
           if (xisinf (min_pos) && xisinf (max_neg))
             {
-              // TODO -- max_neg is needed for "loglog ([0 -Inf])"
-              //         This is the only place where max_neg is needed.
-              //         Is there another way?
+              // FIXME: max_neg is needed for "loglog ([0 -Inf])"
+              //        This is the *only* place where max_neg is needed.
+              //        Is there another way?
               retval = default_lim ();
               retval(0) = pow (10., retval(0));
               retval(1) = pow (10., retval(1));
               return retval;
             }
-          if ((min_val <= 0 && max_val > 0))
+          if (min_val <= 0 && max_val > 0)
             {
               warning ("axis: omitting non-positive data in log plot");
               min_val = min_pos;
             }
           // FIXME: maybe this test should also be relative?
           if (std::abs (min_val - max_val)
               < sqrt (std::numeric_limits<double>::epsilon ()))
             {
@@ -6994,17 +7041,17 @@ axes::properties::get_axis_limits (doubl
           // FIXME: maybe this test should also be relative?
           else if (std::abs (min_val - max_val)
                    < sqrt (std::numeric_limits<double>::epsilon ()))
             {
               min_val -= 0.1 * std::abs (min_val);
               max_val += 0.1 * std::abs (max_val);
             }
 
-          double tick_sep = calc_tick_sep (min_val , max_val);
+          double tick_sep = calc_tick_sep (min_val, max_val);
           double min_tick = gnulib::floor (min_val / tick_sep);
           double max_tick = std::ceil (max_val / tick_sep);
           // Prevent round-off from cropping ticks
           min_val = std::min (min_val, tick_sep * min_tick);
           max_val = std::max (max_val, tick_sep * max_tick);
         }
     }
 
@@ -7022,18 +7069,18 @@ axes::properties::calc_ticks_and_lims (a
                                        array_property& mticks,
                                        bool limmode_is_auto, bool is_logscale)
 {
   // FIXME: add log ticks and lims
 
   if (lims.get ().is_empty ())
     return;
 
-  double lo = (lims.get ().matrix_value ()) (0);
-  double hi = (lims.get ().matrix_value ()) (1);
+  double lo = (lims.get ().matrix_value ())(0);
+  double hi = (lims.get ().matrix_value ())(1);
   bool is_negative = lo < 0 && hi < 0;
   double tmp;
   // FIXME: should this be checked for somewhere else? (i.e. set{x,y,z}lim)
   if (hi < lo)
     std::swap (hi, lo);
 
   if (is_logscale)
     {
@@ -7055,32 +7102,32 @@ axes::properties::calc_ticks_and_lims (a
   if (is_logscale)
     {
       if (! (xisinf (hi) || xisinf (lo)))
         tick_sep = 1;  // Tick is every order of magnitude (bug #39449)
       else
         tick_sep = 0;
     }
   else
-    tick_sep = calc_tick_sep (lo , hi);
+    tick_sep = calc_tick_sep (lo, hi);
 
   int i1 = static_cast<int> (gnulib::floor (lo / tick_sep));
   int i2 = static_cast<int> (std::ceil (hi / tick_sep));
 
   if (limmode_is_auto)
     {
-      // adjust limits to include min and max tics
+      // Adjust limits to include min and max tics
       Matrix tmp_lims (1,2);
       tmp_lims(0) = std::min (tick_sep * i1, lo);
       tmp_lims(1) = std::max (tick_sep * i2, hi);
 
       if (is_logscale)
         {
-          tmp_lims(0) = std::pow (10.,tmp_lims(0));
-          tmp_lims(1) = std::pow (10.,tmp_lims(1));
+          tmp_lims(0) = std::pow (10., tmp_lims(0));
+          tmp_lims(1) = std::pow (10., tmp_lims(1));
           if (tmp_lims(0) <= 0)
             tmp_lims(0) = std::pow (10., lo);
           if (is_negative)
             {
               tmp = tmp_lims(0);
               tmp_lims(0) = -tmp_lims(1);
               tmp_lims(1) = -tmp;
             }
@@ -7094,39 +7141,39 @@ axes::properties::calc_ticks_and_lims (a
         i1++;
       if (i2*tick_sep > hi)
         i2--;
     }
 
   Matrix tmp_ticks (1, i2-i1+1);
   for (int i = 0; i <= i2-i1; i++)
     {
-      tmp_ticks (i) = tick_sep * (i+i1);
+      tmp_ticks(i) = tick_sep * (i+i1);
       if (is_logscale)
-        tmp_ticks (i) = std::pow (10., tmp_ticks (i));
+        tmp_ticks(i) = std::pow (10., tmp_ticks(i));
     }
   if (is_logscale && is_negative)
     {
       Matrix rev_ticks (1, i2-i1+1);
       rev_ticks = -tmp_ticks;
       for (int i = 0; i <= i2-i1; i++)
-        tmp_ticks (i) = rev_ticks (i2-i1-i);
+        tmp_ticks(i) = rev_ticks(i2-i1-i);
     }
 
   ticks = tmp_ticks;
 
   int n = is_logscale ? 8 : 4;
   Matrix tmp_mticks (1, n * (tmp_ticks.numel () - 1));
 
   for (int i = 0; i < tmp_ticks.numel ()-1; i++)
     {
-      double d = (tmp_ticks (i+1) - tmp_ticks (i)) / (n+1);
+      double d = (tmp_ticks(i+1) - tmp_ticks(i)) / (n + 1);
       for (int j = 0; j < n; j++)
         {
-          tmp_mticks (n*i+j) = tmp_ticks (i) + d * (j+1);
+          tmp_mticks(n*i+j) = tmp_ticks(i) + d * (j+1);
         }
     }
   mticks = tmp_mticks;
 }
 
 /*
 %!test  # Bug #45356
 %! hf = figure ("visible", "off");
@@ -7147,35 +7194,35 @@ axes::properties::calc_ticklabels (const
   Matrix values = ticks.get ().matrix_value ();
   Cell c (values.dims ());
   std::ostringstream os;
 
   if (logscale)
     {
       double significand;
       double exponent;
-      double exp_max = 0.;
-      double exp_min = 0.;
+      double exp_max = 0.0;
+      double exp_min = 0.0;
 
       for (int i = 0; i < values.numel (); i++)
         {
           exp_max = std::max (exp_max, std::log10 (values(i)));
           exp_min = std::max (exp_min, std::log10 (values(i)));
         }
 
       for (int i = 0; i < values.numel (); i++)
         {
-          if (values(i) < 0.)
+          if (values(i) < 0.0)
             exponent = gnulib::floor (std::log10 (-values(i)));
           else
             exponent = gnulib::floor (std::log10 (values(i)));
           significand = values(i) * std::pow (10., -exponent);
           os.str (std::string ());
           os << significand;
-          if (exponent < 0.)
+          if (exponent < 0.0)
             {
               os << "e-";
               exponent = -exponent;
             }
           else
             os << "e+";
           if (exponent < 10. && (exp_max > 9 || exp_min < -9))
             os << "0";
@@ -7202,17 +7249,17 @@ axes::properties::get_ticklabel_extents 
                                          const Matrix& limits)
 {
 #ifndef HAVE_FREETYPE
   double fontsize = get ("fontsize").double_value ();
 #endif
 
   Matrix ext (1, 2, 0.0);
   double wmax, hmax;
-  wmax = hmax = 0.;
+  wmax = hmax = 0.0;
   int n = std::min (ticklabels.numel (), ticks.numel ());
   for (int i = 0; i < n; i++)
     {
       double val = ticks(i);
       if (limits(0) <= val && val <= limits(1))
         {
           std::string label (ticklabels(i));
           label.erase (0, label.find_first_not_of (" "));
@@ -7242,77 +7289,77 @@ get_children_limits (double& min_val, do
 {
   octave_idx_type n = kids.numel ();
 
   switch (limit_type)
     {
     case 'x':
       for (octave_idx_type i = 0; i < n; i++)
         {
-          graphics_object obj = gh_manager::get_object (kids(i));
-
-          if (obj.is_xliminclude ())
-            {
-              octave_value lim = obj.get_xlim ();
+          graphics_object go = gh_manager::get_object (kids(i));
+
+          if (go.is_xliminclude ())
+            {
+              octave_value lim = go.get_xlim ();
 
               check_limit_vals (min_val, max_val, min_pos, max_neg, lim);
             }
         }
       break;
 
     case 'y':
       for (octave_idx_type i = 0; i < n; i++)
         {
-          graphics_object obj = gh_manager::get_object (kids(i));
-
-          if (obj.is_yliminclude ())
-            {
-              octave_value lim = obj.get_ylim ();
+          graphics_object go = gh_manager::get_object (kids(i));
+
+          if (go.is_yliminclude ())
+            {
+              octave_value lim = go.get_ylim ();
 
               check_limit_vals (min_val, max_val, min_pos, max_neg, lim);
             }
         }
       break;
 
     case 'z':
       for (octave_idx_type i = 0; i < n; i++)
         {
-          graphics_object obj = gh_manager::get_object (kids(i));
-
-          if (obj.is_zliminclude ())
-            {
-              octave_value lim = obj.get_zlim ();
+          graphics_object go = gh_manager::get_object (kids(i));
+
+          if (go.is_zliminclude ())
+            {
+              octave_value lim = go.get_zlim ();
 
               check_limit_vals (min_val, max_val, min_pos, max_neg, lim);
             }
         }
       break;
 
     case 'c':
       for (octave_idx_type i = 0; i < n; i++)
         {
-          graphics_object obj = gh_manager::get_object (kids(i));
-
-          if (obj.is_climinclude ())
-            {
-              octave_value lim = obj.get_clim ();
+          graphics_object go = gh_manager::get_object (kids(i));
+
+          if (go.is_climinclude ())
+            {
+              octave_value lim = go.get_clim ();
 
               check_limit_vals (min_val, max_val, min_pos, max_neg, lim);
             }
         }
       break;
 
     case 'a':
       for (octave_idx_type i = 0; i < n; i++)
         {
-          graphics_object obj = gh_manager::get_object (kids(i));
-
-          if (obj.is_aliminclude ())
-            {
-              octave_value lim = obj.get_alim ();
+          graphics_object go = gh_manager::get_object (kids(i));
+
+          if (go.is_aliminclude ())
+            {
+              octave_value lim = go.get_alim ();
 
               check_limit_vals (min_val, max_val, min_pos, max_neg, lim);
             }
         }
       break;
 
     default:
       break;
@@ -7517,17 +7564,16 @@ axes::update_axis_limits (const std::str
       xproperties.set_alimmode ("auto");
       break;
 
     default:
       break;
     }
 
   xproperties.update_transform ();
-
 }
 
 void
 axes::update_axis_limits (const std::string& axis_type)
 {
   if ((updating_axis_limits.find (get_handle ().value ())
        != updating_axis_limits.end ())
       || (updating_aspectratios.find (get_handle ().value ())
@@ -7960,30 +8006,28 @@ axes::properties::rotate3d (double x0, d
   new_view(1) = std::min (new_view(1), 90.0);
   new_view(1) = std::max (new_view(1), -90.0);
   if (new_view(0) > 180.0)
     new_view(0) -= 360.0;
   else if (new_view(0) < -180.0)
     new_view(0) += 360.0;
 
   // Snapping
-  double snapMargin = 1.0;
+  double snapmargin = 1.0;
   for (int a = -90; a <= 90; a += 90)
     {
-      if ((a - snapMargin) < new_view(1)
-          && new_view(1) < (a + snapMargin))
+      if ((a - snapmargin) < new_view(1) && new_view(1) < (a + snapmargin))
         {
           new_view(1) = a;
           break;
         }
     }
 
   for (int a = -180; a <= 180; a += 180)
-    if ((a - snapMargin) < new_view(0)
-        && new_view(0) < (a + snapMargin))
+    if ((a - snapmargin) < new_view(0) && new_view(0) < (a + snapmargin))
       {
         if (a == 180)
           new_view(0) = -180;
         else
           new_view(0) = a;
         break;
       }
 
@@ -8144,47 +8188,47 @@ text::properties::get_extent (void) cons
 
   m(0) += p(0);
   m(1) += p(1);
 
   return convert_text_position (m, *this, "pixels", get_units ());
 }
 
 void
-text::properties::set_fontunits (const octave_value& v)
+text::properties::set_fontunits (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (v, true))
+      if (fontunits.set (val, true))
         {
           update_fontunits (old_fontunits);
           mark_modified ();
         }
     }
 }
 
 void
 text::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = 0;
-  double fsz = get_fontsize ();
+  double fontsz = get_fontsize ();
 
   if (new_units == "normalized")
     {
       graphics_object go (gh_manager::get_object (get___myhandle__ ()));
       graphics_object ax (go.get_ancestor ("axes"));
 
       parent_height = ax.get_properties ().get_boundingbox (true).elem (3);
     }
 
-  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
-
-  set_fontsize (octave_value (fsz));
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fontsz));
 }
 
 void
 text::properties::update_font (void)
 {
 #ifdef HAVE_FREETYPE
 #ifdef HAVE_FONTCONFIG
   renderer.set_font (get ("fontname").string_value (),
@@ -8259,19 +8303,18 @@ text::properties::update_units (void)
       set_yliminclude ("off");
       set_zliminclude ("off");
     }
 
   Matrix pos = get_position ().matrix_value ();
 
   pos = convert_text_position (pos, *this, cached_units, get_units ());
 
-  // FIXME: if the current axes view is 2D, then one should
-  // probably drop the z-component of "pos" and leave "zliminclude"
-  // to "off".
+  // FIXME: if the current axes view is 2D, then one should probably drop
+  // the z-component of "pos" and leave "zliminclude" to "off".
 
   bool autopos = positionmode_is ("auto");
 
   set_position (pos);
 
   if (autopos)
     set_positionmode ("auto");
 
@@ -8284,37 +8327,36 @@ text::properties::update_units (void)
     }
 
   cached_units = get_units ();
 }
 
 double
 text::properties::get_fontsize_points (double box_pix_height) const
 {
-  double fs = get_fontsize ();
+  double fontsz = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     {
       graphics_object go (gh_manager::get_object (get___myhandle__ ()));
       graphics_object ax (go.get_ancestor ("axes"));
 
       parent_height = ax.get_properties ().get_boundingbox (true).elem (3);
     }
 
-  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 image::properties::get_color_data (void) const
 {
-  return convert_cdata (*this, get_cdata (),
-                        cdatamapping_is ("scaled"), 3);
+  return convert_cdata (*this, get_cdata (), cdatamapping_is ("scaled"), 3);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 patch::properties::get_color_data (void) const
 {
   octave_value fvc = get_facevertexcdata ();
@@ -8336,17 +8378,17 @@ patch::properties::update_fvc (void)
   Matrix yd = get_ydata ().matrix_value ();
   Matrix zd = get_zdata ().matrix_value ();
   NDArray cd = get_cdata ().array_value ();
 
   bad_data_msg = std::string ();
   if (xd.dims () != yd.dims ()
       || (xd.dims () != zd.dims () && ! zd.is_empty ()))
     {
-      bad_data_msg = "x/y/zdata should have the same dimensions";
+      bad_data_msg = "x/y/zdata must have the same dimensions";
       return;
     }
 
   // Faces and Vertices
   dim_vector dv;
   bool is3D = false;
   octave_idx_type nr = xd.rows ();
   octave_idx_type nc = xd.columns ();
@@ -8481,17 +8523,16 @@ patch::properties::update_data (void)
   Matrix zd;
   bool has_zd = false;
   if (vert.columns () > 2)
     {
       zd = Matrix (idx.dims ());
       has_zd = true;
     }
 
-
   for (octave_idx_type jj = 0; jj < nfaces; jj++)
     {
       for (octave_idx_type ii = 0; ii < idx.rows (); ii++)
         {
           octave_idx_type row = static_cast<octave_idx_type> (idx(ii,jj)-1);
           xd(ii,jj) = vert(row,0);
           yd(ii,jj) = vert(row,1);
 
@@ -8624,40 +8665,40 @@ surface::properties::update_normals (voi
     }
 }
 
 // ---------------------------------------------------------------------
 
 void
 hggroup::properties::update_limits (void) const
 {
-  graphics_object obj = gh_manager::get_object (__myhandle__);
-
-  if (obj)
-    {
-      obj.update_axis_limits ("xlim");
-      obj.update_axis_limits ("ylim");
-      obj.update_axis_limits ("zlim");
-      obj.update_axis_limits ("clim");
-      obj.update_axis_limits ("alim");
+  graphics_object go = gh_manager::get_object (__myhandle__);
+
+  if (go)
+    {
+      go.update_axis_limits ("xlim");
+      go.update_axis_limits ("ylim");
+      go.update_axis_limits ("zlim");
+      go.update_axis_limits ("clim");
+      go.update_axis_limits ("alim");
     }
 }
 
 void
 hggroup::properties::update_limits (const graphics_handle& h) const
 {
-  graphics_object obj = gh_manager::get_object (__myhandle__);
-
-  if (obj)
-    {
-      obj.update_axis_limits ("xlim", h);
-      obj.update_axis_limits ("ylim", h);
-      obj.update_axis_limits ("zlim", h);
-      obj.update_axis_limits ("clim", h);
-      obj.update_axis_limits ("alim", h);
+  graphics_object go = gh_manager::get_object (__myhandle__);
+
+  if (go)
+    {
+      go.update_axis_limits ("xlim", h);
+      go.update_axis_limits ("ylim", h);
+      go.update_axis_limits ("zlim", h);
+      go.update_axis_limits ("clim", h);
+      go.update_axis_limits ("alim", h);
     }
 }
 
 static bool updating_hggroup_limits = false;
 
 void
 hggroup::update_axis_limits (const std::string& axis_type,
                              const graphics_handle& h)
@@ -8715,17 +8756,17 @@ hggroup::update_axis_limits (const std::
       if (xfinite (val))
         min_pos = val;
       val = limits(3);
       if (xfinite (val))
         max_neg = val;
     }
   else
     {
-      limits.resize (4,1);
+      limits.resize (4, 1);
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
       limits(3) = max_neg;
     }
 
   get_children_limits (min_val, max_val, min_pos, max_neg, kids, update_type);
 
@@ -8897,29 +8938,28 @@ uicontextmenu::~uicontextmenu (void)
 %!   set (hf, "uicontextmenu", hctx1);
 %!   assert (get (hf, "uicontextmenu"), hctx1);
 %!   set (hf, "uicontextmenu", []);
 %!   assert (get (hf, "uicontextmenu"), []);
 %!   assert (get (hf, "children"), [hctx1; hax]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect;
- */
+*/
 
 // ---------------------------------------------------------------------
 
 octave_value
 uicontrol::properties::get_extent (void) const
 {
   Matrix m = extent.get ().matrix_value ();
 
-  graphics_object parent_obj =
-    gh_manager::get_object (get_parent ());
-  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
-         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+  Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
 
   return convert_position (m, "pixels", get_units (), parent_size);
 }
 
 void
 uicontrol::properties::update_text_extent (void)
 {
 #ifdef HAVE_FREETYPE
@@ -8936,17 +8976,17 @@ uicontrol::properties::update_text_exten
   text_renderer.set_font (get_fontname (),
                           get_fontweight (),
                           get_fontangle (),
                           get_fontsize ());
 #endif
   box = text_renderer.get_extent (elt, 0);
   delete elt;
 
-  Matrix ext (1, 4, 0.0);
+  Matrix ext (1, 4);
 
   // FIXME: also handle left and bottom components
 
   ext(0) = ext(1) = 1;
   ext(2) = box(0);
   ext(3) = box(1);
 
   set_extent (ext);
@@ -8954,19 +8994,19 @@ uicontrol::properties::update_text_exten
 #endif
 }
 
 void
 uicontrol::properties::update_units (void)
 {
   Matrix pos = get_position ().matrix_value ();
 
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
-         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+  Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
 
   pos = convert_position (pos, cached_units, get_units (), parent_size);
   set_position (pos);
 
   cached_units = get_units ();
 }
 
 void
@@ -8980,89 +9020,89 @@ uicontrol::properties::set_style (const 
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.numel () == 0)
-    {
-      graphics_object obj = gh_manager::get_object (get_parent ());
-
-      if (obj.valid_object ())
+  if (parent_size.is_empty ())
+    {
+      graphics_object go = gh_manager::get_object (get_parent ());
+
+      if (go.valid_object ())
         parent_size =
-          obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+          go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
       else
         parent_size = default_figure_position ();
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
   return pos;
 }
 
 void
-uicontrol::properties::set_fontunits (const octave_value& v)
+uicontrol::properties::set_fontunits (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (v, true))
+      if (fontunits.set (val, true))
         {
           update_fontunits (old_fontunits);
           mark_modified ();
         }
     }
 }
 
 void
 uicontrol::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (false).elem (3);
-  double fsz = get_fontsize ();
-
-  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
-
-  fontsize.set (octave_value (fsz), true);
+  double fontsz = get_fontsize ();
+
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  fontsize.set (octave_value (fontsz), true);
 }
 
 double
 uicontrol::properties::get_fontsize_points (double box_pix_height) const
 {
-  double fs = get_fontsize ();
+  double fontsz = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     parent_height = get_boundingbox (false).elem (3);
 
-  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 Matrix
 uipanel::properties::get_boundingbox (bool internal,
                                       const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.numel () == 0)
-    {
-      graphics_object obj = gh_manager::get_object (get_parent ());
+  if (parent_size.is_empty ())
+    {
+      graphics_object go = gh_manager::get_object (get_parent ());
 
       parent_size =
-        obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+        go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
@@ -9083,152 +9123,151 @@ uipanel::properties::get_boundingbox (bo
           pos(0) += mul * bw;
           pos(1) += mul * bw;
           pos(2) -= 2 * mul * bw;
           pos(3) -= 2 * mul * bw;
         }
 
       if (! get_title ().empty ())
         {
-          double fs = get_fontsize ();
+          double fontsz = get_fontsize ();
 
           if (! fontunits_is ("pixels"))
             {
               double res = xget (0, "screenpixelsperinch").double_value ();
 
               if (fontunits_is ("points"))
-                fs *= (res / 72.0);
+                fontsz *= (res / 72.0);
               else if (fontunits_is ("inches"))
-                fs *= res;
+                fontsz *= res;
               else if (fontunits_is ("centimeters"))
-                fs *= (res / 2.54);
+                fontsz *= (res / 2.54);
               else if (fontunits_is ("normalized"))
-                fs *= outer_height;
+                fontsz *= outer_height;
             }
 
           if (titleposition_is ("lefttop") || titleposition_is ("centertop")
               || titleposition_is ("righttop"))
-            pos(1) += (fs / 2);
-          pos(3) -= (fs / 2);
+            pos(1) += (fontsz / 2);
+          pos(3) -= (fontsz / 2);
         }
     }
 
   return pos;
 }
 
 void
-uipanel::properties::set_units (const octave_value& v)
+uipanel::properties::set_units (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
-      if (units.set (v, true))
+      if (units.set (val, true))
         {
           update_units (old_units);
           mark_modified ();
         }
     }
 }
 
 void
 uipanel::properties::update_units (const caseless_str& old_units)
 {
   Matrix pos = get_position ().matrix_value ();
 
-  graphics_object parent_obj = gh_manager::get_object (get_parent ());
-  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
-         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+  Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
 
   pos = convert_position (pos, old_units, get_units (), parent_size);
   set_position (pos);
 }
 
 void
-uipanel::properties::set_fontunits (const octave_value& v)
+uipanel::properties::set_fontunits (const octave_value& val)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
-      if (fontunits.set (v, true))
+      if (fontunits.set (val, true))
         {
           update_fontunits (old_fontunits);
           mark_modified ();
         }
     }
 }
 
 void
 uipanel::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
   double parent_height = get_boundingbox (false).elem (3);
-  double fsz = get_fontsize ();
-
-  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
-
-  set_fontsize (octave_value (fsz));
+  double fontsz = get_fontsize ();
+
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fontsz));
 }
 
 double
 uipanel::properties::get_fontsize_points (double box_pix_height) const
 {
-  double fs = get_fontsize ();
+  double fontsz = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     parent_height = get_boundingbox (false).elem (3);
 
-  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
-uitoolbar::get_default (const caseless_str& name) const
-{
-  octave_value retval = default_properties.lookup (name);
+uitoolbar::get_default (const caseless_str& pname) const
+{
+  octave_value retval = default_properties.lookup (pname);
 
   if (retval.is_undefined ())
     {
-      graphics_handle parent = get_parent ();
-      graphics_object parent_obj = gh_manager::get_object (parent);
-
-      retval = parent_obj.get_default (name);
+      graphics_handle parent_h = get_parent ();
+      graphics_object parent_go = gh_manager::get_object (parent_h);
+
+      retval = parent_go.get_default (pname);
     }
 
   return retval;
 }
 
 void
 uitoolbar::reset_default_properties (void)
 {
   // empty list of local defaults
   default_properties = property_list ();
 
-  xreset_default_properties (get_handle (),
-                             xproperties.factory_defaults ());
+  xreset_default_properties (get_handle (), xproperties.factory_defaults ());
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
-base_graphics_object::get_default (const caseless_str& name) const
-{
-  graphics_handle parent = get_parent ();
-  graphics_object parent_obj = gh_manager::get_object (parent);
-
-  return parent_obj.get_default (type () + name);
+base_graphics_object::get_default (const caseless_str& pname) const
+{
+  graphics_handle parent_h = get_parent ();
+  graphics_object parent_go = gh_manager::get_object (parent_h);
+
+  return parent_go.get_default (type () + pname);
 }
 
 octave_value
 base_graphics_object::get_factory_default (const caseless_str& name) const
 {
-  graphics_object parent_obj = gh_manager::get_object (0);
-
-  return parent_obj.get_factory_default (type () + name);
+  graphics_object parent_go = gh_manager::get_object (0);
+
+  return parent_go.get_factory_default (type () + name);
 }
 
 // We use a random value for the handle to avoid issues with plots and
 // scalar values for the first argument.
 gh_manager::gh_manager (void)
   : handle_map (), handle_free_list (),
     next_handle (-1.0 - (rand () + 1.0) / (RAND_MAX + 2.0)),
     figure_list (), graphics_lock (),  event_queue (),
@@ -9253,38 +9292,38 @@ graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
                                      const graphics_handle& p,
                                      bool integer_figure_handle,
                                      bool do_createfcn,
                                      bool do_notify_toolkit)
 {
   graphics_handle h = get_handle (integer_figure_handle);
 
-  base_graphics_object *go = 0;
-
-  go = make_graphics_object_from_type (go_name, h, p);
-
-  if (go)
-    {
-      graphics_object obj (go);
-
-      handle_map[h] = obj;
+  base_graphics_object *bgo = 0;
+
+  bgo = make_graphics_object_from_type (go_name, h, p);
+
+  if (bgo)
+    {
+      graphics_object go (bgo);
+
+      handle_map[h] = go;
 
       // Overriding defaults will work now because the handle is valid
       // and we can find parent objects (not just handles).
-      obj.override_defaults ();
+      go.override_defaults ();
 
       if (go_name == "axes")
         {
           // Handle defaults for labels since overriding defaults for
           // them can't work before the axes object is fully
           // constructed.
 
           axes::properties& props =
-            dynamic_cast<axes::properties&> (obj.get_properties ());
+            dynamic_cast<axes::properties&> (go.get_properties ());
 
           graphics_object tgo;
 
           tgo = gh_manager::get_object (props.get_xlabel ());
           tgo.override_defaults ();
 
           tgo = gh_manager::get_object (props.get_ylabel ());
           tgo.override_defaults ();
@@ -9292,44 +9331,44 @@ gh_manager::do_make_graphics_handle (con
           tgo = gh_manager::get_object (props.get_zlabel ());
           tgo.override_defaults ();
 
           tgo = gh_manager::get_object (props.get_title ());
           tgo.override_defaults ();
         }
 
       if (do_createfcn)
-        go->get_properties ().execute_createfcn ();
+        bgo->get_properties ().execute_createfcn ();
 
       // Notify graphics toolkit.
       if (do_notify_toolkit)
-        obj.initialize ();
+        go.initialize ();
     }
   else
     error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
   return h;
 }
 
 graphics_handle
 gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
   graphics_handle h = val;
 
-  base_graphics_object* go = new figure (h, 0);
-  graphics_object obj (go);
-
-  handle_map[h] = obj;
+  base_graphics_object* bgo = new figure (h, 0);
+  graphics_object go (bgo);
+
+  handle_map[h] = go;
 
   // Notify graphics toolkit.
   if (do_notify_toolkit)
-    obj.initialize ();
-
-  obj.override_defaults ();
+    go.initialize ();
+
+  go.override_defaults ();
 
   return h;
 }
 
 void
 gh_manager::do_push_figure (const graphics_handle& h)
 {
   do_pop_figure (h);
@@ -9512,18 +9551,17 @@ xset_gcbo (const graphics_handle& h)
 void
 gh_manager::do_restore_gcbo (void)
 {
   gh_manager::auto_lock guard;
 
   callback_objects.pop_front ();
 
   xset_gcbo (callback_objects.empty ()
-             ? graphics_handle ()
-             : callback_objects.front ().get_handle ());
+             ? graphics_handle () : callback_objects.front ().get_handle ());
 }
 
 void
 gh_manager::do_execute_listener (const graphics_handle& h,
                                  const octave_value& l)
 {
   if (octave_thread::is_octave_thread ())
     gh_manager::execute_callback (h, l, octave_value ());
@@ -9829,17 +9867,17 @@ is_handle_visible (const octave_value& v
     {
       const NDArray handles = val.array_value ();
 
       if (! error_state)
         {
           boolNDArray result (handles.dims ());
 
           for (octave_idx_type i = 0; i < handles.numel (); i++)
-            result.xelem (i) = is_handle_visible (handles (i));
+            result.xelem (i) = is_handle_visible (handles(i));
 
           retval = result;
         }
     }
 
   return retval;
 }
 
@@ -10098,88 +10136,88 @@ being @qcode{\"portrait\"}.\n\
 
       if (! error_state)
         {
           bool request_drawnow = false;
 
           // loop over graphics objects
           for (octave_idx_type n = 0; n < hcv.numel (); n++)
             {
-              graphics_object obj = gh_manager::get_object (hcv(n));
-
-              if (obj)
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
                 {
-                  if (nargin == 3 && args(1).is_cellstr ()
-                      && args(2).is_cell ())
+                  if (nargin == 3
+                      && args(1).is_cellstr () && args(2).is_cell ())
                     {
                       if (args(2).cell_value ().rows () == 1)
                         {
-                          obj.set (args(1).cellstr_value (),
-                                   args(2).cell_value (), 0);
+                          go.set (args(1).cellstr_value (),
+                                  args(2).cell_value (), 0);
                         }
                       else if (hcv.numel () == args(2).cell_value ().rows ())
                         {
-                          obj.set (args(1).cellstr_value (),
-                                   args(2).cell_value (), n);
+                          go.set (args(1).cellstr_value (),
+                                  args(2).cell_value (), n);
                         }
                       else
                         {
                           error ("set: number of graphics handles must match number of value rows (%d != %d)",
                                  hcv.numel (), args(2).cell_value ().rows ());
                           break;
 
                         }
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
-                      obj.set (args(1).map_value ());
+                      go.set (args(1).map_value ());
                     }
                   else if (nargin == 2 && args(1).is_string ())
                     {
                       std::string property = args(1).string_value ();
 
-                      octave_map pmap = obj.values_as_struct ();
-
-                      if (obj.has_readonly_property (property))
+                      octave_map pmap = go.values_as_struct ();
+
+                      if (go.has_readonly_property (property))
                         if (nargout != 0)
                           retval = Matrix ();
                         else
                           octave_stdout << "set: " << property
                                         <<" is read-only" << std::endl;
                       else if (pmap.isfield (property))
                         {
                           if (nargout != 0)
                             retval = pmap.getfield (property)(0);
                           else
                             {
-                              std::string s = obj.value_as_string (property);
+                              std::string s = go.value_as_string (property);
                               if (! error_state)
                                 octave_stdout << s;
                             }
                         }
                       else
                         {
                           error ("set: unknown property");
                           break;
                         }
                     }
                   else if (nargin == 1)
                     {
                       if (nargout != 0)
-                        retval = obj.values_as_struct ();
+                        retval = go.values_as_struct ();
                       else
                         {
-                          std::string s = obj.values_as_string ();
+                          std::string s = go.values_as_string ();
                           if (! error_state)
                             octave_stdout << s;
                         }
                     }
                   else
                     {
-                      obj.set (args.splice (0, 1));
+                      go.set (args.splice (0, 1));
                       request_drawnow = true;
                     }
                 }
               else
                 {
                   error ("set: invalid handle (= %g)", hcv(n));
                   break;
                 }
@@ -10202,20 +10240,20 @@ being @qcode{\"portrait\"}.\n\
   return retval;
 }
 
 static std::string
 get_graphics_object_type (double val)
 {
   std::string retval;
 
-  graphics_object obj = gh_manager::get_object (val);
-
-  if (obj)
-    retval = obj.type ();
+  graphics_object go = gh_manager::get_object (val);
+
+  if (go)
+    retval = go.type ();
   else
     error ("get: invalid handle (= %g)", val);
 
   return retval;
 }
 
 DEFUN (get, args, ,
        "-*- texinfo -*-\n\
@@ -10252,28 +10290,28 @@ lists respectively.\n\
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           octave_idx_type len = hcv.numel ();
 
           if (nargin == 1 && len > 1)
             {
-              std::string t0 = get_graphics_object_type (hcv(0));
+              std::string typ0 = get_graphics_object_type (hcv(0));
 
               if (! error_state)
                 {
                   for (octave_idx_type n = 1; n < len; n++)
                     {
-                      std::string t = get_graphics_object_type (hcv(n));
+                      std::string typ = get_graphics_object_type (hcv(n));
 
                       if (error_state)
                         break;
 
-                      if (t != t0)
+                      if (typ != typ0)
                         {
                           error ("get: vector of handles must all have same type");
                           break;
                         }
                     }
 
                 }
             }
@@ -10289,27 +10327,27 @@ lists respectively.\n\
                       octave_idx_type plen = plist.numel ();
 
                       use_cell_format = true;
 
                       vals.resize (dim_vector (len, plen));
 
                       for (octave_idx_type n = 0; ! error_state && n < len; n++)
                         {
-                          graphics_object obj = gh_manager::get_object (hcv(n));
-
-                          if (obj)
+                          graphics_object go = gh_manager::get_object (hcv(n));
+
+                          if (go)
                             {
                               for (octave_idx_type m = 0;
                                    ! error_state && m < plen;
                                    m++)
                                 {
                                   caseless_str property = plist(m);
 
-                                  vals(n, m) = obj.get (property);
+                                  vals(n, m) = go.get (property);
                                 }
                             }
                           else
                             {
                               error ("get: invalid handle (= %g)", hcv(n));
                               break;
                             }
                         }
@@ -10330,24 +10368,24 @@ lists respectively.\n\
                     }
 
                   vals.resize (dim_vector (len, 1));
 
                   if (! error_state)
                     {
                       for (octave_idx_type n = 0; ! error_state && n < len; n++)
                         {
-                          graphics_object obj = gh_manager::get_object (hcv(n));
-
-                          if (obj)
+                          graphics_object go = gh_manager::get_object (hcv(n));
+
+                          if (go)
                             {
                               if (nargin == 1)
-                                vals(n) = obj.get ();
+                                vals(n) = go.get ();
                               else
-                                vals(n) = obj.get (property);
+                                vals(n) = go.get (property);
                             }
                           else
                             {
                               error ("get: invalid handle (= %g)", hcv(n));
                               break;
                             }
                         }
                     }
@@ -10418,20 +10456,20 @@ Undocumented internal function.\n\
       if (! error_state)
         {
           octave_idx_type len = hcv.numel ();
 
           vals.resize (dim_vector (len, 1));
 
           for (octave_idx_type n = 0; n < len; n++)
             {
-              graphics_object obj = gh_manager::get_object (hcv(n));
-
-              if (obj)
-                vals(n) = obj.get (true);
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
+                vals(n) = go.get (true);
               else
                 {
                   error ("get: invalid handle (= %g)", hcv(n));
                   break;
                 }
             }
         }
       else
@@ -10462,18 +10500,17 @@ make_graphics_object (const std::string&
 
   double val = octave_NaN;
 
   octave_value_list xargs = args.splice (0, 1);
 
   caseless_str p ("parent");
 
   for (int i = 0; i < xargs.length (); i++)
-    if (xargs(i).is_string ()
-        && p.compare (xargs(i).string_value ()))
+    if (xargs(i).is_string () && p.compare (xargs(i).string_value ()))
       {
         if (i < (xargs.length () - 1))
           {
             val = xargs(i+1).double_value ();
 
             if (! error_state)
               {
                 xargs = xargs.splice (i, 2);
@@ -10554,22 +10591,22 @@ Undocumented internal function.\n\
               bool int_fig_handle = true;
 
               octave_value_list xargs = args.splice (0, 1);
 
               graphics_handle h = octave_NaN;
 
               if (xisnan (val))
                 {
-                  caseless_str p ("integerhandle");
+                  caseless_str pname ("integerhandle");
 
                   for (int i = 0; i < xargs.length (); i++)
                     {
                       if (xargs(i).is_string ()
-                          && p.compare (xargs(i).string_value ()))
+                          && pname.compare (xargs(i).string_value ()))
                         {
                           if (i < (xargs.length () - 1))
                             {
                               std::string pval = xargs(i+1).string_value ();
 
                               if (! error_state)
                                 {
                                   caseless_str on ("on");
@@ -10582,20 +10619,19 @@ Undocumented internal function.\n\
                     }
 
                   h = gh_manager::make_graphics_handle ("figure", 0,
                                                         int_fig_handle,
                                                         false, false);
 
                   if (! int_fig_handle)
                     {
-                      // We need to intiailize the integerhandle
-                      // property without calling the set_integerhandle
-                      // method, because doing that will generate a new
-                      // handle value...
+                      // We need to initialize the integerhandle property
+                      // without calling the set_integerhandle method,
+                      // because doing that will generate a new handle value...
 
                       graphics_object go = gh_manager::get_object (h);
                       go.get_properties ().init_integerhandle ("off");
                     }
                 }
               else if (val > 0 && D_NINT (val) == val)
                 h = gh_manager::make_figure_handle (val, false);
 
@@ -10634,35 +10670,34 @@ Undocumented internal function.\n\
   else \
     print_usage (); \
  \
   return retval
 
 int
 calc_dimensions (const graphics_object& go)
 {
-
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
   else if ((go.isa ("line") || go.isa ("patch"))
            && ! go.get ("zdata").is_empty ())
     nd = 3;
   else
     {
       Matrix kids = go.get_properties ().get_children ();
 
       for (octave_idx_type i = 0; i < kids.numel (); i++)
         {
-          graphics_handle hnd = gh_manager::lookup (kids(i));
-
-          if (hnd.ok ())
-            {
-              const graphics_object& kid = gh_manager::get_object (hnd);
+          graphics_handle hkid = gh_manager::lookup (kids(i));
+
+          if (hkid.ok ())
+            {
+              const graphics_object& kid = gh_manager::get_object (hkid);
 
               if (kid.valid_object ())
                 nd = calc_dimensions (kid);
 
               if (nd == 3)
                 break;
             }
         }
@@ -10838,27 +10873,25 @@ Undocumented internal function.\n\
   if (args.length () == 1)
     {
       graphics_handle h = octave_NaN;
 
       const NDArray vals = args(0).array_value ();
 
       if (! error_state)
         {
-          // Check is all the handles to delete are valid first
-          // as callbacks might delete one of the handles we
-          // later want to delete
+          // Check all the handles to delete are valid first, as callbacks
+          // might delete one of the handles we later want to delete
           for (octave_idx_type i = 0; i < vals.numel (); i++)
             {
-              h = gh_manager::lookup (vals.elem (i));
+              h = gh_manager::lookup (vals(i));
 
               if (! h.ok ())
                 {
-                  error ("delete: invalid graphics object (= %g)",
-                         vals.elem (i));
+                  error ("delete: invalid graphics object (= %g)", vals(i));
                   break;
                 }
             }
 
           if (! error_state)
             delete_graphics_objects (vals);
         }
       else
@@ -10899,19 +10932,19 @@ Undocumented internal function.\n\
       double val = args(0).double_value ();
 
       if (! error_state)
         {
           h = gh_manager::lookup (val);
 
           if (h.ok ())
             {
-              graphics_object obj = gh_manager::get_object (h);
-
-              obj.set_defaults (mode);
+              graphics_object go = gh_manager::get_object (h);
+
+              go.set_defaults (mode);
 
               h = gh_manager::lookup (val);
               if (! h.ok ())
                 error ("__go_axes_init__: axis deleted during initialization (= %g)",
                        val);
             }
           else
             error ("__go_axes_init__: invalid graphics object (= %g)", val);
@@ -11014,25 +11047,25 @@ Internal function: returns the pixel siz
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
-          graphics_object fobj = gh_manager::get_object (h);
-          if (fobj &&  fobj.isa ("image"))
+          graphics_object go = gh_manager::get_object (h);
+          if (go && go.isa ("image"))
             {
               image::properties& ip =
-                dynamic_cast<image::properties&> (fobj.get_properties ());
-
-              Matrix dp =  Matrix (1, 2, 0);
-              dp(0, 0) = ip.pixel_xsize ();
-              dp(0, 1) = ip.pixel_ysize ();
+                dynamic_cast<image::properties&> (go.get_properties ());
+
+              Matrix dp = Matrix (1, 2);
+              dp(0) = ip.pixel_xsize ();
+              dp(1) = ip.pixel_ysize ();
               retval = dp;
             }
           else
             error ("__image_pixel_size__: object is not an image");
         }
       else
         error ("__image_pixel_size__: argument is not a handle");
     }
@@ -11665,56 +11698,56 @@ addproperty (\"my_style\", gcf, \"lineli
 }
 
 octave_value
 get_property_from_handle (double handle, const std::string& property,
                           const std::string& func)
 {
   gh_manager::auto_lock guard;
 
-  graphics_object obj = gh_manager::get_object (handle);
   octave_value retval;
-
-  if (obj)
-    retval = obj.get (caseless_str (property));
+  graphics_object go = gh_manager::get_object (handle);
+
+  if (go)
+    retval = go.get (caseless_str (property));
   else
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return retval;
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
   gh_manager::auto_lock guard;
 
-  graphics_object obj = gh_manager::get_object (handle);
   int ret = false;
-
-  if (obj)
-    {
-      obj.set (caseless_str (property), arg);
+  graphics_object go = gh_manager::get_object (handle);
+
+  if (go)
+    {
+      go.set (caseless_str (property), arg);
 
       if (! error_state)
         ret = true;
     }
   else
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return ret;
 }
 
 static bool
-compare_property_values (const octave_value& o1, const octave_value& o2)
+compare_property_values (const octave_value& ov1, const octave_value& ov2)
 {
   octave_value_list args(2);
 
-  args(0) = o1;
-  args(1) = o2;
+  args(0) = ov1;
+  args(1) = ov2;
 
   octave_value_list result = feval ("isequal", args, 1);
 
   if (! error_state && result.length () > 0)
     return result(0).bool_value ();
 
   return false;
 }
@@ -11740,21 +11773,21 @@ do_cleanup_waitfor_listener (const octav
       if (! error_state)
         {
           caseless_str pname = c(3).string_value ();
 
           if (! error_state)
             {
               gh_manager::auto_lock guard;
 
-              graphics_handle handle = gh_manager::lookup (h);
-
-              if (handle.ok ())
+              graphics_handle gh = gh_manager::lookup (h);
+
+              if (gh.ok ())
                 {
-                  graphics_object go = gh_manager::get_object (handle);
+                  graphics_object go = gh_manager::get_object (gh);
 
                   if (go.get_properties ().has_property (pname))
                     {
                       go.get_properties ().delete_listener (pname, listener,
                                                             mode);
                       if (mode == POSTSET)
                         go.get_properties ().delete_listener (pname, listener,
                                                               PERSISTENT);
@@ -11789,21 +11822,21 @@ waitfor_listener (const octave_value_lis
               if (! error_state)
                 {
                   caseless_str pname = args(4).string_value ();
 
                   if (! error_state)
                     {
                       gh_manager::auto_lock guard;
 
-                      graphics_handle handle = gh_manager::lookup (h);
-
-                      if (handle.ok ())
+                      graphics_handle gh = gh_manager::lookup (h);
+
+                      if (gh.ok ())
                         {
-                          graphics_object go = gh_manager::get_object (handle);
+                          graphics_object go = gh_manager::get_object (gh);
                           octave_value pvalue = go.get (pname);
 
                           if (compare_property_values (pvalue, args(5)))
                             waitfor_results[id] = true;
                         }
                     }
                 }
             }
@@ -11888,18 +11921,17 @@ In all cases, typing CTRL-C stops progra
           int timeout_index = -1;
 
           int timeout = 0;
 
           if (args.length () > 1)
             {
               pname = args(1).string_value ();
               if (! error_state
-                  && ! pname.empty ()
-                  && ! pname.compare ("timeout"))
+                  && ! pname.empty () && ! pname.compare ("timeout"))
                 {
                   if (pname.compare ("\\timeout"))
                     pname = "timeout";
 
                   static octave_value wf_listener;
 
                   if (! wf_listener.is_defined ())
                     wf_listener =
@@ -11935,21 +11967,21 @@ In all cases, typing CTRL-C stops progra
 
                   if (max_arg_index >= 2)
                     listener(4) = args(2);
 
                   octave_value ov_listener (listener);
 
                   gh_manager::auto_lock guard;
 
-                  graphics_handle handle = gh_manager::lookup (h);
-
-                  if (handle.ok ())
+                  graphics_handle gh = gh_manager::lookup (h);
+
+                  if (gh.ok ())
                     {
-                      graphics_object go = gh_manager::get_object (handle);
+                      graphics_object go = gh_manager::get_object (gh);
 
                       if (max_arg_index >= 2
                           && compare_property_values (go.get (pname),
                                                       args(2)))
                         waitfor_results[id] = true;
                       else
                         {
 
@@ -11988,18 +12020,17 @@ In all cases, typing CTRL-C stops progra
                         }
                     }
                 }
               else if (error_state || pname.empty ())
                 error ("waitfor: invalid property name, expected a non-empty string value");
             }
 
           if (! error_state
-              && timeout_index < 0
-              && args.length () > (max_arg_index + 1))
+              && timeout_index < 0 && args.length () > (max_arg_index + 1))
             {
               caseless_str s = args(max_arg_index + 1).string_value ();
 
               if (! error_state)
                 {
                   if (s.compare ("timeout"))
                     timeout_index = max_arg_index + 1;
                   else
@@ -12028,20 +12059,20 @@ In all cases, typing CTRL-C stops progra
                     error ("waitfor: invalid timeout value, expected a value >= 1");
                 }
               else
                 error ("waitfor: missing timeout value");
             }
 
           // FIXME: There is still a "hole" in the following loop. The code
           //        assumes that an object handle is unique, which is a fair
-          //        assumption, except for figures. If a figure is destroyed
+          //        assumption, except for figures.  If a figure is destroyed
           //        then recreated with the same figure ID, within the same
           //        run of event hooks, then the figure destruction won't be
-          //        caught and the loop will not stop. This is an unlikely
+          //        caught and the loop will not stop.  This is an unlikely
           //        possibility in practice, though.
           //
           //        Using deletefcn callback is also unreliable as it could be
           //        modified during a callback execution and the waitfor loop
           //        would not stop.
           //
           //        The only "good" implementation would require object
           //        listeners, similar to property listeners.
@@ -12052,19 +12083,19 @@ In all cases, typing CTRL-C stops progra
             start = time (0);
 
           while (! error_state)
             {
               if (true)
                 {
                   gh_manager::auto_lock guard;
 
-                  graphics_handle handle = gh_manager::lookup (h);
-
-                  if (handle.ok ())
+                  graphics_handle gh = gh_manager::lookup (h);
+
+                  if (gh.ok ())
                     {
                       if (! pname.empty () && waitfor_results[id])
                         break;
                     }
                   else
                     break;
                 }
 
@@ -12139,25 +12170,25 @@ Undocumented internal function.\n\
         {
           if (opt == "out")
             {
               ax_props.clear_zoom_stack ();
               Vdrawnow_requested = true;
             }
           else
             ax_props.clear_zoom_stack (false);
-
         }
     }
   else
     {
       std::string mode = args(1).string_value ();
       double factor = args(2).scalar_value ();
 
       if (error_state)
         return retval;
 
       ax_props.zoom (mode, factor);
       Vdrawnow_requested = true;
     }
 
   return retval;
 }
+
