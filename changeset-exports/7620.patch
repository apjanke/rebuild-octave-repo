# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1206054504 -3600
#      Fri Mar 21 00:08:24 2008 +0100
# Node ID 36594d5bbe132bcb25f14fcd87cc524894e810fd
# Parent  56012914972a9aef16f517407167c677bdd5f207
Move diag function into the octave_value class

diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2619,16 +2619,103 @@ bool descending_compare (vec_index<doubl
 template <>
 Array<double> Array<double>::sort (octave_idx_type dim, sortmode mode) const;
 template <>
 Array<double> Array<double>::sort (Array<octave_idx_type> &sidx,
 				   octave_idx_type dim, sortmode mode) const;
 
 #endif
 
+template <class T>
+Array<T>
+Array<T>::diag (octave_idx_type k) const
+{
+  dim_vector dv = dims ();
+  octave_idx_type nd = dv.length ();
+  Array<T> d;
+
+  if (nd > 2)
+    (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");    
+  else
+    {
+      octave_idx_type nnr = dv (0);
+      octave_idx_type nnc = dv (1);
+
+      if (nnr == 0 || nnc == 0)
+	; // do nothing
+      else if (nnr != 1 && nnc != 1)
+	{
+	  if (k > 0)
+	    nnc -= k;
+	  else if (k < 0)
+	    nnr += k;
+
+	  if (nnr > 0 && nnc > 0)
+	    {
+	      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+	      d.resize (dim_vector (ndiag, 1));
+
+	      if (k > 0)
+		{
+		  for (octave_idx_type i = 0; i < ndiag; i++)
+		    d.xelem (i) = elem (i, i+k);
+		}
+	      else if (k < 0)
+		{
+		  for (octave_idx_type i = 0; i < ndiag; i++)
+		    d.xelem (i) = elem (i-k, i);
+		}
+	      else
+		{
+		  for (octave_idx_type i = 0; i < ndiag; i++)
+		    d.xelem (i) = elem (i, i);
+		}
+	    }
+	  else
+	    (*current_liboctave_error_handler)
+	      ("diag: requested diagonal out of range");
+	}
+      else if (nnr != 0 && nnc != 0)
+	{
+	  octave_idx_type roff = 0;
+	  octave_idx_type coff = 0;
+	  if (k > 0)
+	    {
+	      roff = 0;
+	      coff = k;
+	    }
+	  else if (k < 0)
+	    {
+	      roff = -k;
+	      coff = 0;
+	    }
+
+	  if (nnr == 1)
+	    {
+	      octave_idx_type n = nnc + std::abs (k);
+	      d = Array<T> (dim_vector (n, n), resize_fill_value (T ()));
+
+	      for (octave_idx_type i = 0; i < nnc; i++)
+		d.xelem (i+roff, i+coff) = elem (0, i);
+	    }
+	  else
+	    {
+	      octave_idx_type n = nnr + std::abs (k);
+	      d = Array<T> (dim_vector (n, n), resize_fill_value (T ()));
+
+	      for (octave_idx_type i = 0; i < nnr; i++)
+		d.xelem (i+roff, i+coff) = elem (i, 0);
+	    }
+	}
+    }
+
+  return d;
+}
+
 // FIXME -- this is a mess.
 
 template <class LT, class RT>
 int
 assign (Array<LT>& lhs, const Array<RT>& rhs, const LT& rfv)
 {
   int n_idx = lhs.index_count ();
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -545,16 +545,18 @@ public:
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Array<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const;
 
+  Array<T> diag (octave_idx_type k = 0) const;
+
   template <class U, class F>
   Array<U>
   map (F fcn) const
   {
     octave_idx_type len = length ();
 
     const T *m = data ();
 
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -131,16 +131,21 @@ public:
 
   Array2<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
+  Array2<T> diag (octave_idx_type k) const
+  {
+    return Array<T>::diag (k);
+  }
+
   template <class U, class F>
   Array2<U> map (F fcn) const
   {
     return Array<T>::template map<U> (fcn);
   }
 };
 
 #endif
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -144,16 +144,21 @@ public:
 
   ArrayN<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return ArrayN<T> (tmp, tmp.dims ());
     }
 
+  ArrayN<T> diag (octave_idx_type k) const
+  {
+    return Array<T>::diag (k);
+  }
+
   template <class U, class F>
   ArrayN<U> map (F fcn) const
   {
     return Array<T>::template map<U> (fcn);
   }
 };
 
 template <class T>
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -496,24 +496,16 @@ operator * (const DiagMatrix& a, const C
     }
 
   return c;
 }
 
 // other operations
 
 ComplexColumnVector
-ComplexDiagMatrix::diag (void) const
-{
-  return diag (0);
-}
-
-// Could be optimized...
-
-ComplexColumnVector
 ComplexDiagMatrix::diag (octave_idx_type k) const
 {
   octave_idx_type nnr = rows ();
   octave_idx_type nnc = cols ();
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -109,18 +109,17 @@ public:
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   // other operations
 
-  ComplexColumnVector diag (void) const;
-  ComplexColumnVector diag (octave_idx_type k) const;
+  ComplexColumnVector diag (octave_idx_type k = 0) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexDiagMatrix& a);
 
 private:
 
   ComplexDiagMatrix (Complex *d, octave_idx_type nr, octave_idx_type nc)
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3311,61 +3311,20 @@ Matrix ComplexMatrix::abs (void) const
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval (i, j) = std::abs (elem (i, j));
 
   return retval;
 }
 
-ComplexColumnVector
-ComplexMatrix::diag (void) const
-{
-  return diag (0);
-}
-
-ComplexColumnVector
+ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  ComplexColumnVector d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      d.resize (ndiag);
-
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i+k);
-	}
-      else if (k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i-k, i);
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i);
-	}
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return MArray2<Complex>::diag (k);
 }
 
 bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -329,18 +329,17 @@ public:
 
   ComplexMatrix cumprod (int dim = -1) const;
   ComplexMatrix cumsum (int dim = -1) const;
   ComplexMatrix prod (int dim = -1) const;
   ComplexMatrix sum (int dim = -1) const;
   ComplexMatrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
-  ComplexColumnVector diag (void) const;
-  ComplexColumnVector diag (octave_idx_type k) const;
+  ComplexMatrix diag (octave_idx_type k = 0) const;
 
   bool row_is_real_only (octave_idx_type) const;
   bool column_is_real_only (octave_idx_type) const;
 
   ComplexColumnVector row_min (void) const;
   ComplexColumnVector row_max (void) const;
 
   ComplexColumnVector row_min (Array<octave_idx_type>& index) const; 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -986,16 +986,22 @@ ComplexNDArray::increment_index (Array<o
 
 octave_idx_type 
 ComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+ComplexNDArray
+ComplexNDArray::diag (octave_idx_type k) const
+{
+  return MArrayN<Complex>::diag (k);
+}
+
 NDArray
 ComplexNDArray::map (dmapper fcn) const
 {
   return MArrayN<Complex>::map<double> (func_ptr (fcn));
 }
 
 ComplexNDArray
 ComplexNDArray::map (cmapper fcn) const
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -111,16 +111,18 @@ public:
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
+  ComplexNDArray diag (octave_idx_type k = 0) const;
+
   typedef double (*dmapper) (const Complex&);
   typedef Complex (*cmapper) (const Complex&);
   typedef bool (*bmapper) (const Complex&);
 
   NDArray map (dmapper fcn) const;
   ComplexNDArray map (cmapper fcn) const;
   boolNDArray map (bmapper fcn) const;
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7354,98 +7354,17 @@ SparseMatrix SparseComplexMatrix::abs (v
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  SparseComplexMatrix d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      // Count the number of non-zero elements
-      octave_idx_type nel = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i+k) != 0.)
-	      nel++;
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i-k, i) != 0.)
-	      nel++;
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i) != 0.)
-	      nel++;
-	}
-      
-      d = SparseComplexMatrix (ndiag, 1, nel);
-      d.xcidx (0) = 0;
-      d.xcidx (1) = nel;
-
-      octave_idx_type ii = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      Complex tmp = elem (i, i+k);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      Complex tmp = elem (i-k, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      Complex tmp = elem (i, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-    }
-  else
-    (*current_liboctave_error_handler) 
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return MSparse<Complex>::diag (k);
 }
 
 SparseMatrix
 SparseComplexMatrix::map (dmapper fcn) const
 {
   return MSparse<Complex>::map<double> (func_ptr (fcn));
 }
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,12 +1,83 @@
 2008-03-21  David Bateman  <dbateman@free.fr>
 
 	* oct-sparse.h: Add headers for amd.h.
 
+2008-03-20  David Bateman  <dbateman@free.fr>
+
+	* Array.cc (Array<T> Array<T>::diag (octave_idx_type) const): New
+	method for diag function.
+	* Array.h  (Array<T> diag (octave_idx_type) const): Declare it.
+	* Array2.h (Array2<T> diag (octave_idx_type) const): New method.
+	* MArray2.h (MArray2<T> diag (octave_idx_type) const): ditto.
+	* ArrayN.h (ArrayN<T> diag (octave_idx_type) const): ditto.
+	* MArrayN.h (MArrayN<T> diag (octave_idx_type) const): ditto.
+
+	* Sparse.cc (Sparse<T> Sparse<T>::diag (octave_idx_type) const):
+	New method for the diag function.
+	* Sparse.h  (Sparse<T> diag (octave_idx_type) const): Declare it.
+	* MSparse.h (MSparse<T> diag (octave_idx_type) const): New method.
+
+	* Range.cc (Matrix Range::diag (octave_idx_type) const):
+	New method for the diag function.
+	* Range.h  (Matrix diag (octave_idx_type) const): Declare it.
+	
+	* CDiagMatrix.cc (ComplexColumnVector ComplexDiagMatrix::diag
+	(void) const): delete.
+	* dDiagMatrix.cc (ColumnVector DiagMatrix::diag (void) const): delete.
+	* dDiagMatrix.h (ColumnVector diag (void) const): ditto.
+	* CMatrix.cc (ComplexColumnVector ComplexMatrix::diag (void) const):
+	delete.
+	* CMatrix.h (ComplexColumnVector diag (void) const): ditto.
+	* dMatrix.cc (ColumnVector Matrix::diag (void) const): ditto.
+	* dMatrix.h (ColumnVector diag (void) const): ditto.
+	* boolMatrix.cc (boolMatrix boolMatrix::diag (void) const): ditto.
+	* boolMatrix.h (boolMatrix diag (void) const): ditto.
+	* chMatrix.cc (charMatrix charMatrix::diag (void) const): ditto.
+	* chMatrix.h (charMatrix diag (void) const): ditto.
+	* intNDArray.cc (intNDArray<T> intNDArray<T>::diag (void) const): ditto.
+	* intNDArray.h (intNDArray<T> diag (void) const): ditto.
+	
+	* CMatrix.cc (ComplexMatrix ComplexMatrix::diag (octave_idx_type)
+	const): Rewrite in terms of template classes function.
+	* CMatrix.h (ComplexMatrix diag (octave_idx_type)const ): Change
+	return type.
+	* dMatrix.cc (Matrix Matrix::diag (octave_idx_type) const): Rewrite in
+	terms of template classes function.
+	* dMatrix.h (Matrix diag (octave_idx_type) const): Change return type.
+	* boolMatrix.cc (boolMatrix boolMatrix::diag (octave_idx_type) const):
+	Rewrite in terms of template classes function.
+	* boolMatrix.h (boolMatrix diag (octave_idx_type) const): Change
+	return type. 
+	* chMatrix.cc (charMatrix charMatrix::diag (octave_idx_type)
+	const): Rewrite in terms of template classes function.
+	
+	* dSparse.cc (SparseMatrix SparseMatrix::diag (octave_idx_type) const):
+	Rewrite in terms of template classes function.
+	* CSparse.cc (SparseComplexMatrix SparseComplexMatrix::diag
+	(octave_idx_type) const): ditto.
+	* boolSparse.cc (SparseBoolMatrix SparseBoolMatrix::diag
+	(octave_idx_type) const): ditto.
+	* intNDArray.cc (intNDArray<T> intNDArray<T>::diag
+	(octave_idx_type) const): ditto.
+
+	* CNDArray.cc (ComplexNDArray ComplexNDArray::diag
+	(octave_idx_type) const): New method.
+	* CNDArray.h (ComplexNDArray diag (octave_idx_type) const):
+	Declare it.
+	* dNDArray.cc (NDArray NDArray::diag (octave_idx_type) const): New
+	method.
+	* dNDArray.h (NDArray diag (octave_idx_type) const): Declare it.
+	* chNDArray.cc (charNDArray charNDArray::diag
+	(octave_idx_type) const): New method.
+	* chNDArray.h (charNDArray diag (octave_idx_type) const):
+	Declare it.
+
+	
 2008-03-19  John W. Eaton  <jwe@octave.org>
 
 	* oct-env.cc (octave_env::do_base_pathname): Also handle rooted
 	relative filenames.
 
 2008-03-19  David Bateman  <dbateman@free.fr>
 
 	* Array.cc (assignN): If orig_empty allow assignment like
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -76,16 +76,21 @@ public:
   MArray2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Array2<T>::insert (a, r, c);
     return *this;
   }
 
   MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
 
+  MArray2<T> diag (octave_idx_type k) const
+  {
+    return Array2<T>::diag (k);
+  }
+
   template <class U, class F>
   MArray2<U> map (F fcn) const
   {
     return Array2<T>::template map<U> (fcn);
   }
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -93,16 +93,21 @@ public:
 		      bool inv = false) const
     { return ArrayN<T>::permute (vec, inv); }
 
   MArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
     { return ArrayN<T>::ipermute (vec); }
 
   MArrayN squeeze (void) const { return ArrayN<T>::squeeze (); }
 
+  MArrayN<T> diag (octave_idx_type k) const
+  {
+    return ArrayN<T>::diag (k);
+  }
+
   template <class U, class F>
   MArrayN<U> map (F fcn) const
   {
     return ArrayN<T>::template map<U> (fcn);
   }
 };
 
 #endif
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -107,17 +107,22 @@ public:
      
   MSparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const
     { return Sparse<T>::permute (vec, inv); }
 
   MSparse<T> ipermute (const Array<octave_idx_type>& vec) const
     { return Sparse<T>::ipermute (vec); }
 
 
-  template <class U, class F>
+  MSparse<T> diag (octave_idx_type k = 0) const
+  {
+    return Sparse<T>::diag (k);
+  }
+
+ template <class U, class F>
   MSparse<U> map (F fcn) const
   {
     return Sparse<T>::template map<U> (fcn);
   }
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -173,16 +173,50 @@ Range::sort_internal (Array<octave_idx_t
   octave_idx_type tmp = reverse ? nel - 1 : 0;
   octave_idx_type stp = reverse ? -1 : 1;
 
   for (octave_idx_type i = 0; i < nel; i++, tmp += stp)
     psidx[i] = tmp;
 
 }
 
+Matrix 
+Range::diag (octave_idx_type k) const
+{
+  octave_idx_type nnr = 1;
+  octave_idx_type nnc = nelem ();
+  Matrix d;
+
+  if  (nnr != 0)
+    {
+      octave_idx_type roff = 0;
+      octave_idx_type coff = 0;
+      if (k > 0)
+	{
+	  roff = 0;
+	  coff = k;
+	}
+      else if (k < 0)
+	{
+	  roff = -k;
+	  coff = 0;
+	}
+
+      // Force cached matrix to be created
+      matrix_value ();
+
+      octave_idx_type n = nnc + std::abs (k);
+      d = Matrix (n, n, Matrix::resize_fill_value ());
+      for (octave_idx_type i = 0; i < nnc; i++)
+	d.xelem (i+roff, i+coff) = cache.xelem (i);
+    }
+
+  return d;
+}
+
 Range
 Range::sort (octave_idx_type dim, sortmode mode) const
 {
   Range retval = *this;
 
   if (dim == 1)
     {
       if (mode == ASCENDING)
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -60,16 +60,18 @@ Range
   Matrix matrix_value (void) const;
 
   double min (void) const;
   double max (void) const;
 
   void sort_internal (bool ascending = true);
   void sort_internal (Array<octave_idx_type>& sidx, bool ascending = true);
 
+  Matrix diag (octave_idx_type k = 0) const;
+
   Range sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
 
   Range sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
 	      sortmode mode = ASCENDING) const;
 
   void set_base (double b)
   {
     if (rng_base != b)
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -2248,16 +2248,166 @@ Sparse<T>::sort (Array<octave_idx_type> 
     {
       m = m.transpose ();
       sidx = sidx.transpose ();
     }
 
   return m;
 }
 
+template <class T>
+Sparse<T>
+Sparse<T>::diag (octave_idx_type k) const
+{
+  octave_idx_type nnr = rows ();
+  octave_idx_type nnc = cols ();
+  Sparse<T> d;
+
+  if (nnr == 0 || nnc == 0)
+    ; // do nothing
+  else if (nnr != 1 && nnc != 1)
+    {
+      if (k > 0)
+	nnc -= k;
+      else if (k < 0)
+	nnr += k;
+
+      if (nnr > 0 && nnc > 0)
+	{
+	  octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
+
+	  // Count the number of non-zero elements
+	  octave_idx_type nel = 0;
+	  if (k > 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		if (elem (i, i+k) != 0.)
+		  nel++;
+	    }
+	  else if ( k < 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		if (elem (i-k, i) != 0.)
+		  nel++;
+	    }
+	  else
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		if (elem (i, i) != 0.)
+		  nel++;
+	    }
+      
+	  d = Sparse<T> (ndiag, 1, nel);
+	  d.xcidx (0) = 0;
+	  d.xcidx (1) = nel;
+
+	  octave_idx_type ii = 0;
+	  if (k > 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		{
+		  T tmp = elem (i, i+k);
+		  if (tmp != 0.)
+		    {
+		      d.xdata (ii) = tmp;
+		      d.xridx (ii++) = i;
+		    }
+		}
+	    }
+	  else if ( k < 0)
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		{
+		  T tmp = elem (i-k, i);
+		  if (tmp != 0.)
+		    {
+		      d.xdata (ii) = tmp;
+		      d.xridx (ii++) = i;
+		    }
+		}
+	    }
+	  else
+	    {
+	      for (octave_idx_type i = 0; i < ndiag; i++)
+		{
+		  T tmp = elem (i, i);
+		  if (tmp != 0.)
+		    {
+		      d.xdata (ii) = tmp;
+		      d.xridx (ii++) = i;
+		    }
+		}
+	    }
+	}
+      else
+	(*current_liboctave_error_handler) 
+	  ("diag: requested diagonal out of range");
+    }
+  else if (nnr != 0 && nnc != 0)
+    {
+      octave_idx_type roff = 0;
+      octave_idx_type coff = 0;
+      if (k > 0) 
+	{
+	  roff = 0;
+	  coff = k;
+	} 
+      else if (k < 0) 
+	{
+	  roff = -k;
+	  coff = 0;
+	}
+
+      if (nnr == 1) 
+	{
+	  octave_idx_type n = nnc + std::abs (k);
+	  octave_idx_type nz = nzmax ();
+	  d = Sparse<T> (n, n, nz);
+	  for (octave_idx_type i = 0; i < coff+1; i++)
+	    d.xcidx (i) = 0;
+	  for (octave_idx_type j = 0; j < nnc; j++)
+	    {
+	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+		{
+		  d.xdata (i) = data (i);
+		  d.xridx (i) = j + roff;
+		}
+	      d.xcidx (j + coff + 1) = cidx(j+1);
+	    }
+	  for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
+	    d.xcidx (i) = nz;
+	} 
+      else 
+	{
+	  octave_idx_type n = nnr + std::abs (k);
+	  octave_idx_type nz = nzmax ();
+	  octave_idx_type ii = 0;
+	  octave_idx_type ir = ridx(0);
+	  d = Sparse<T> (n, n, nz);
+	  for (octave_idx_type i = 0; i < coff+1; i++)
+	    d.xcidx (i) = 0;
+	  for (octave_idx_type i = 0; i < nnr; i++)
+	    {
+	      if (ir == i)
+		{
+		  d.xdata (ii) = data (ii);
+		  d.xridx (ii++) = ir + roff;
+		  if (ii != nz)
+		    ir = ridx (ii);
+		}
+	      d.xcidx (i + coff + 1) = ii;
+	    }
+	  for (octave_idx_type i = nnr + coff + 1; i < n+1; i++)
+	    d.xcidx (i) = nz;
+	}
+    }
+
+  return d;
+}
+
 // FIXME
 // Unfortunately numel can overflow for very large but very sparse matrices.
 // For now just flag an error when this happens.
 template <class LT, class RT>
 int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -517,16 +517,18 @@ public:
   octave_idx_type *mex_get_ir (void) const { return const_cast<octave_idx_type *> (ridx ()); }
 
   octave_idx_type *mex_get_jc (void) const { return const_cast<octave_idx_type *> (cidx ()); }
 
   Sparse<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Sparse<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const;
 
+  Sparse<T> diag (octave_idx_type k = 0) const;
+
   template <class U, class F>
   Sparse<U>
   map (F fcn) const
   {
     Sparse<U> result;
     U f_zero = fcn (0.);
 
     if (f_zero != 0.)
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -73,60 +73,19 @@ boolMatrix::operator ! (void) const
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
 // other operations
 
 boolMatrix
-boolMatrix::diag (void) const
-{
-  return diag (0);
-}
-
-boolMatrix
 boolMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  boolMatrix d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      d.resize (ndiag, 1);
-
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i, i+k);
-	}
-      else if (k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i-k, i);
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i, i);
-	}
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return Array2<bool>::diag (k);
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 boolMatrix::all (int dim) const
 {
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -59,18 +59,17 @@ public:
   boolMatrix& insert (const boolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  boolMatrix diag (void) const;
-  boolMatrix diag (octave_idx_type k) const;
+  boolMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -124,16 +124,22 @@ boolNDArray::increment_index (Array<octa
 
 octave_idx_type
 boolNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+boolNDArray
+boolNDArray::diag (octave_idx_type k) const
+{
+  return ArrayN<bool>::diag (k);
+}
+
 NDND_BOOL_OPS (boolNDArray, boolNDArray, false)
 NDND_CMP_OPS (boolNDArray, , boolNDArray, )
 
 NDS_BOOL_OPS (boolNDArray, bool, false)
 NDS_CMP_OPS (boolNDArray, , bool, )
 
 SND_BOOL_OPS (bool, boolNDArray, false)
 SND_CMP_OPS (bool, , boolNDArray, )
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -104,16 +104,18 @@ public:
 	{
 	  if (d[i])
 	    retval++;
 	}
 
       return retval;
     }
 
+  boolNDArray diag (octave_idx_type k = 0) const;
+
 private:
 
   boolNDArray (bool *d, dim_vector& dv) : ArrayN<bool> (d, dv) { }
 };
 
 NDND_BOOL_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 NDND_CMP_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -138,98 +138,17 @@ SparseBoolMatrix
 SparseBoolMatrix::any (int dim) const
 {
   SPARSE_ANY_OP (dim);
 }
 
 SparseBoolMatrix
 SparseBoolMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  SparseBoolMatrix d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      // Count the number of non-zero elements
-      octave_idx_type nel = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i+k) != 0.)
-	      nel++;
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i-k, i) != 0.)
-	      nel++;
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i) != 0.)
-	      nel++;
-	}
-      
-      d = SparseBoolMatrix (ndiag, 1, nel);
-      d.xcidx (0) = 0;
-      d.xcidx (1) = nel;
-
-      octave_idx_type ii = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      bool tmp = elem (i, i+k);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      bool tmp = elem (i-k, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      bool tmp = elem (i, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-    }
-  else
-    (*current_liboctave_error_handler) 
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return Sparse<bool>::diag (k);
 }
 
 boolMatrix
 SparseBoolMatrix::matrix_value (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -187,60 +187,19 @@ charMatrix::extract (octave_idx_type r1,
   for (octave_idx_type j = 0; j < new_c; j++)
     for (octave_idx_type i = 0; i < new_r; i++)
       result.elem (i, j) = elem (r1+i, c1+j);
 
   return result;
 }
 
 charMatrix
-charMatrix::diag (void) const
-{
-  return diag (0);
-}
-
-charMatrix
 charMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  charMatrix d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      d.resize (ndiag, 1);
-
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i, i+k);
-	}
-      else if (k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i-k, i);
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.xelem (i) = elem (i, i);
-	}
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return MArray2<char>::diag (k);
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 charMatrix::all (int dim) const
 {
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -68,18 +68,17 @@ public:
   charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false, bool raw = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
-  charMatrix diag (void) const;
-  charMatrix diag (octave_idx_type k) const;
+  charMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -140,16 +140,22 @@ charNDArray::increment_index (Array<octa
 
 octave_idx_type 
 charNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+charNDArray
+charNDArray::diag (octave_idx_type k) const
+{
+  return MArrayN<char>::diag (k);
+}
+
 boolNDArray
 charNDArray::bmap (mapper fcn) const
 {
   octave_idx_type len = length ();
   const char *m = fortran_vec();
   boolNDArray result (dims ());
   bool *p = result.fortran_vec ();
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -84,16 +84,18 @@ public:
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
+  charNDArray diag (octave_idx_type k = 0) const;
+
   typedef int (*mapper) (int);
   boolNDArray bmap (mapper fcn) const;
   NDArray dmap (mapper fcn) const;
   charNDArray smap (mapper fcn) const;
 
 private:
 
   charNDArray (char *d, dim_vector& dv) : MArrayN<char> (d, dv) { }
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -342,28 +342,23 @@ operator * (const DiagMatrix& a, const D
     }
 
   return c;
 }
 
 // other operations
 
 ColumnVector
-DiagMatrix::diag (void) const
-{
-  return diag (0);
-}
-
-// Could be optimized...
-
-ColumnVector
 DiagMatrix::diag (octave_idx_type k) const
 {
   octave_idx_type nnr = rows ();
   octave_idx_type nnc = cols ();
+
+  if (nnr == 0  || nnc == 0)
+    
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
   ColumnVector d;
 
   if (nnr > 0 && nnc > 0)
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -87,18 +87,17 @@ public:
   ColumnVector column (octave_idx_type i) const;
   ColumnVector column (char *s) const;
 
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (int& info) const;
 
   // other operations
 
-  ColumnVector diag (void) const;
-  ColumnVector diag (octave_idx_type k) const;
+  ColumnVector diag (octave_idx_type k = 0) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const DiagMatrix& a);
 
 private:
 
   DiagMatrix (double *d, octave_idx_type nr, octave_idx_type nc) : MDiagArray2<double> (d, nr, nc) { }
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2838,61 +2838,20 @@ Matrix::abs (void) const
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval (i, j) = fabs (elem (i, j));
 
   return retval;
 }
 
-ColumnVector
-Matrix::diag (void) const
-{
-  return diag (0);
-}
-
-ColumnVector
+Matrix
 Matrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  ColumnVector d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      d.resize (ndiag);
-
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i+k);
-	}
-      else if (k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i-k, i);
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i);
-	}
-    }
-  else
-    (*current_liboctave_error_handler)
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return MArray2<double>::diag (k);
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -286,18 +286,17 @@ public:
 
   Matrix cumprod (int dim = -1) const;
   Matrix cumsum (int dim = -1) const;
   Matrix prod (int dim = -1) const;
   Matrix sum (int dim = -1) const;
   Matrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
-  ColumnVector diag (void) const;
-  ColumnVector diag (octave_idx_type k) const;
+  Matrix diag (octave_idx_type k = 0) const;
 
   ColumnVector row_min (void) const;
   ColumnVector row_max (void) const;
 
   ColumnVector row_min (Array<octave_idx_type>& index) const;
   ColumnVector row_max (Array<octave_idx_type>& index) const;
 
   RowVector column_min (void) const;
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -963,16 +963,22 @@ NDArray::increment_index (Array<octave_i
 octave_idx_type
 NDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 NDArray
+NDArray::diag (octave_idx_type k) const
+{
+  return MArrayN<double>::diag (k);
+}
+
+NDArray
 NDArray::map (dmapper fcn) const
 {
   return MArrayN<double>::map<double> (func_ptr (fcn));
 }
 
 ComplexNDArray
 NDArray::map (cmapper fcn) const
 {
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -119,16 +119,18 @@ public:
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
+  NDArray diag (octave_idx_type k = 0) const;
+
   typedef double (*dmapper) (double);
   typedef Complex (*cmapper) (const Complex&);
   typedef bool (*bmapper) (double);
 
   NDArray map (dmapper fcn) const;
   ComplexNDArray map (cmapper fcn) const;
   boolNDArray map (bmapper fcn) const;
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7432,98 +7432,17 @@ SparseMatrix::abs (void) const
     retval.data(i) = fabs(retval.data(i));
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  SparseMatrix d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      // Count the number of non-zero elements
-      octave_idx_type nel = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i+k) != 0.)
-	      nel++;
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i-k, i) != 0.)
-	      nel++;
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    if (elem (i, i) != 0.)
-	      nel++;
-	}
-      
-      d = SparseMatrix (ndiag, 1, nel);
-      d.xcidx (0) = 0;
-      d.xcidx (1) = nel;
-
-      octave_idx_type ii = 0;
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      double tmp = elem (i, i+k);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else if ( k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      double tmp = elem (i-k, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    {
-	      double tmp = elem (i, i);
-	      if (tmp != 0.)
-		{
-		  d.xdata (ii) = tmp;
-		  d.xridx (ii++) = i;
-		}
-	    }
-	}
-    }
-  else
-    (*current_liboctave_error_handler) 
-      ("diag: requested diagonal out of range");
-
-  return d;
+  return MSparse<double>::diag (k);
 }
 
 Matrix
 SparseMatrix::matrix_value (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -55,76 +55,21 @@ intNDArray<T>::any_element_not_one_or_ze
 
       if (val != 0.0 && val != 1.0)
 	return true;
     }
 
   return false;
 }
 
-
-template <class T>
-intNDArray<T>
-intNDArray<T>::diag (void) const
-{
-  return diag (0);
-}
-
 template <class T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type k) const
 {
-  dim_vector dv = this->dims ();
-  octave_idx_type nd = dv.length ();
-
-  if (nd > 2)
-    {
-      (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");    
-      return intNDArray<T>();
-    }
-  else
-    {
-      octave_idx_type nnr = dv (0);
-      octave_idx_type nnc = dv (1);
-
-      if (k > 0)
-	nnc -= k;
-      else if (k < 0)
-	nnr += k;
-
-      intNDArray<T> d;
-
-      if (nnr > 0 && nnc > 0)
-	{
-	  octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-	  d.resize (dim_vector (ndiag, 1));
-
-	  if (k > 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		d.xelem (i) = this->elem (i, i+k);
-	    }
-	  else if (k < 0)
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		d.xelem (i) = this->elem (i-k, i);
-	    }
-	  else
-	    {
-	      for (octave_idx_type i = 0; i < ndiag; i++)
-		d.xelem (i) = this->elem (i, i);
-	    }
-	}
-      else
-	(*current_liboctave_error_handler)
-	  ("diag: requested diagonal out of range");
-
-      return d;
-    }
+  return MArrayN<T>::diag (k);
 }
 
 // FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -60,18 +60,17 @@ public:
       MArrayN<T>::operator = (a);
       return *this;
     }
 
   boolNDArray operator ! (void) const;
 
   bool any_element_not_one_or_zero (void) const;
 
-  intNDArray diag (void) const;
-  intNDArray diag (octave_idx_type k) const;
+  intNDArray diag (octave_idx_type k = 0) const;
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray max (int dim = 0) const;
   intNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -234,58 +234,18 @@ Cell::map (ctype_mapper fcn) const
 
   for (octave_idx_type i = 0; i < numel (); i++)
     r[i] = ((p++)->*fcn) ();
 
   return retval;
 }
 
 Cell
-Cell::diag (void) const
-{
-  return diag (0);
-}
-
-Cell
 Cell::diag (octave_idx_type k) const
 {
-  octave_idx_type nnr = rows ();
-  octave_idx_type nnc = cols ();
-  if (k > 0)
-    nnc -= k;
-  else if (k < 0)
-    nnr += k;
-
-  Cell d;
-
-  if (nnr > 0 && nnc > 0)
-    {
-      octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
-
-      d.resize (dim_vector (ndiag, 1));
-
-      if (k > 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i+k);
-	}
-      else if (k < 0)
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i-k, i);
-	}
-      else
-	{
-	  for (octave_idx_type i = 0; i < ndiag; i++)
-	    d.elem (i) = elem (i, i);
-	}
-    }
-  else
-    error ("diag: requested diagonal out of range");
-
-  return d;
+  return ArrayN<octave_value>::diag (k);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -110,18 +110,17 @@ public:
   Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
   Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
   // FIXME
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 
-  Cell diag (void) const;
-  Cell diag (octave_idx_type k) const;
+  Cell diag (octave_idx_type k = 0) const;
 
   Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
   Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
   Cell xisascii (void) const { return map (&octave_value::xisascii); }
   Cell xiscntrl (void) const { return map (&octave_value::xiscntrl); }
   Cell xisdigit (void) const { return map (&octave_value::xisdigit); }
   Cell xisgraph (void) const { return map (&octave_value::xisgraph); }
   Cell xislower (void) const { return map (&octave_value::xislower); }
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,15 +1,38 @@
 2008-03-21  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/amd.cc: New file.
 	* Makefile.in (DLD_XSRC): Add amd.cc.
 
 2008-03-20  David Bateman  <dbateman@free.fr>
 
+	* Cell.cc (Cell Cell::diag (void) const): delete.
+	(Cell Cell::diag (octave__idx_type) const):Rewrite in terms of
+	template classes function.
+	* Cell.h (Cell diag (void) const): delete.
+
+	* ov.h (octave_value diag (octave_idx_type) const): New method.
+	* ov-base.h (virtual octave_value diag (octave_idx_type) const):
+	New virtual method.
+	* ov-base.cc (octave_value octave_base_value::diag
+	(octave_idx_type) const): New default method.
+	
+	* ov-base-mat.h (octave_value diag (octave_idx_type) const): New
+	method. 
+	* ov-base-sparse.h (octave_value diag (octave_idx_type) const): New
+	method. 
+	* ov-base-scalar.h (octave_value diag (octave_idx_type) const): New
+	method. 
+	* ov-range.h (octave_value diag (octave_idx_type) const): New
+	method. 
+
+	* data.cc (make_diag, make_spdiag): Delete.
+	(Fdiag): Rewrite in terms of octave_value diag function.
+		
 	* data.cc (static octave_value make_diag (const Cell&,
 	octave_idx_type)): New instantiation of template function.
 	(static octave_value make_diag (const octave_value&,
 	octave_idx_type)): Allow cell arrays.
 
 	* Cell.cc (Cell Cell::diag (void) const, Cell Cell::diag
 	(octave__idx_type)): New methods for diagonal matrices.
 	* Cell.h (Cell Cell::diag (void) const, Cell Cell::diag
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -878,315 +878,16 @@ is omitted, it defaults to 1 (column-wis
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the cumulative sum of the elements as a vector with the\n\
 same orientation as @var{x}.\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumsum);
 }
 
-template <class T>
-static octave_value
-make_diag (const T& v, octave_idx_type k)
-{
-  octave_value retval;
-  dim_vector dv = v.dims ();
-  octave_idx_type nd = dv.length ();
-
-  if (nd > 2)
-    error ("diag: expecting 2-dimensional matrix");
-  else
-    {
-      octave_idx_type nr = dv (0);
-      octave_idx_type nc = dv (1);
-
-      if (nr == 0 || nc == 0)
-	retval = T ();
-      else if (nr != 1 && nc != 1)
-	retval = v.diag (k);
-      else
-	{
-	  octave_idx_type roff = 0;
-	  octave_idx_type coff = 0;
-	  if (k > 0)
-	    {
-	      roff = 0;
-	      coff = k;
-	    }
-	  else if (k < 0)
-	    {
-	      roff = -k;
-	      coff = 0;
-	    }
-
-	  if (nr == 1)
-	    {
-	      octave_idx_type n = nc + std::abs (k);
-	      T m (dim_vector (n, n), T::resize_fill_value ());
-
-	      for (octave_idx_type i = 0; i < nc; i++)
-		m (i+roff, i+coff) = v (0, i);
-	      retval = m;
-	    }
-	  else
-	    {
-	      octave_idx_type n = nr + std::abs (k);
-	      T m (dim_vector (n, n), T::resize_fill_value ());
-	      for (octave_idx_type i = 0; i < nr; i++)
-		m (i+roff, i+coff) = v (i, 0);
-	      retval = m;
-	    }
-	}
-    }
-  
-  return retval;
-}
-
-#if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-static octave_value
-make_diag (const Matrix& v, octave_idx_type k);
-
-static octave_value
-make_diag (const ComplexMatrix& v, octave_idx_type k);
-
-static octave_value
-make_diag (const charMatrix& v, octave_idx_type k);
-
-static octave_value
-make_diag (const boolMatrix& v, octave_idx_type k);
-
-static octave_value
-make_diag (const int8NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const int16NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const int32NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const int64NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const uint8NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const uint16NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const uint32NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const uint64NDArray& v, octave_idx_type k);
-
-static octave_value
-make_diag (const Cell& v, octave_idx_type k);
-#endif
-
-template <class T>
-static octave_value
-make_spdiag (const T& v, octave_idx_type k)
-{
-  octave_value retval;
-  dim_vector dv = v.dims ();
-  octave_idx_type nr = dv (0);
-  octave_idx_type nc = dv (1);
-
-  if (nr == 0 || nc == 0)
-    retval = T ();
-  else if (nr != 1 && nc != 1)
-    retval = v.diag (k);
-  else
-    {
-      octave_idx_type roff = 0;
-      octave_idx_type coff = 0;
-      if (k > 0) 
-	{
-	  roff = 0;
-	  coff = k;
-	} 
-      else if (k < 0) 
-	{
-	  roff = -k;
-	  coff = 0;
-	}
-
-      if (nr == 1) 
-	{
-	  octave_idx_type n = nc + std::abs (k);
-	  octave_idx_type nz = v.nzmax ();
-	  T r (n, n, nz);
-	  for (octave_idx_type i = 0; i < coff+1; i++)
-	    r.xcidx (i) = 0;
-	  for (octave_idx_type j = 0; j < nc; j++)
-	    {
-	      for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++)
-		{
-		  r.xdata (i) = v.data (i);
-		  r.xridx (i) = j + roff;
-		}
-	      r.xcidx (j+coff+1) = v.cidx(j+1);
-	    }
-	  for (octave_idx_type i = nc+coff+1; i < n+1; i++)
-	    r.xcidx (i) = nz;
-	  retval = r;
-	} 
-      else 
-	{
-	  octave_idx_type n = nr + std::abs (k);
-	  octave_idx_type nz = v.nzmax ();
-	  octave_idx_type ii = 0;
-	  octave_idx_type ir = v.ridx(0);
-	  T r (n, n, nz);
-	  for (octave_idx_type i = 0; i < coff+1; i++)
-	    r.xcidx (i) = 0;
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      if (ir == i)
-		{
-		  r.xdata (ii) = v.data (ii);
-		  r.xridx (ii++) = ir + roff;
-		  if (ii != nz)
-		    ir = v.ridx (ii);
-		}
-	      r.xcidx (i+coff+1) = ii;
-	    }
-	  for (octave_idx_type i = nr+coff+1; i < n+1; i++)
-	    r.xcidx (i) = nz;
-	  retval = r;
-	}
-    }
-
-  return retval;
-}
-
-#if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-static octave_value
-make_spdiag (const SparseMatrix& v, octave_idx_type k);
-
-static octave_value
-make_spdiag (const SparseComplexMatrix& v, octave_idx_type k);
-
-static octave_value
-make_spdiag (const SparseBoolMatrix& v, octave_idx_type k);
-#endif
-
-static octave_value
-make_diag (const octave_value& a, octave_idx_type k)
-{
-  octave_value retval;
-  std::string result_type = a.class_name ();
-
-  if (result_type == "double")
-    {
-      if (a.is_sparse_type ())
-	{
-	  if (a.is_real_type ())
-	    {
-	      SparseMatrix m = a.sparse_matrix_value ();
-	      if (!error_state)
-		retval = make_spdiag (m, k);
-	    }
-	  else
-	    {
-	      SparseComplexMatrix m = a.sparse_complex_matrix_value ();
-	      if (!error_state)
-		retval = make_spdiag (m, k);
-	    }
-	}
-      else
-	{
-	  if (a.is_real_type ())
-	    {
-	      Matrix m = a.matrix_value ();
-	      if (!error_state)
-		retval = make_diag (m, k);
-	    }
-	  else
-	    {
-	      ComplexMatrix m = a.complex_matrix_value ();
-	      if (!error_state)
-		retval = make_diag (m, k);
-	    }
-	}
-    }
-#if 0
-  else if (result_type == "single")
-    retval = make_diag (a.single_array_value (), k);
-#endif
-  else if (result_type == "char")
-    {
-      charMatrix m = a.char_matrix_value ();
-      if (!error_state)
-	{
-	  retval = make_diag (m, k);
-	  if (a.is_sq_string ())
-	    retval = octave_value (retval.char_array_value (), true, '\'');
-	}
-    }
-  else if (result_type == "logical")
-    {
-      if (a.is_sparse_type ())
-	{
-	  SparseBoolMatrix m = a.sparse_bool_matrix_value ();
-	  if (!error_state)
-	    retval = make_spdiag (m, k);
-	}
-      else
-	{
-	  boolMatrix m = a.bool_matrix_value ();
-	  if (!error_state)
-	    retval = make_diag (m, k);
-	}
-    }
-  else if (result_type == "int8")
-    retval = make_diag (a.int8_array_value (), k);
-  else if (result_type == "int16")
-    retval = make_diag (a.int16_array_value (), k);
-  else if (result_type == "int32")
-    retval = make_diag (a.int32_array_value (), k);
-  else if (result_type == "int64")
-    retval = make_diag (a.int64_array_value (), k);
-  else if (result_type == "uint8")
-    retval = make_diag (a.uint8_array_value (), k);
-  else if (result_type == "uint16")
-    retval = make_diag (a.uint16_array_value (), k);
-  else if (result_type == "uint32")
-    retval = make_diag (a.uint32_array_value (), k);
-  else if (result_type == "uint64")
-    retval = make_diag (a.uint64_array_value (), k);
-  else if (result_type == "cell")
-    retval = make_diag (a.cell_value (), k);
-  else
-    gripe_wrong_type_arg ("diag", a);
-
-  return retval;
-}
-
-static octave_value
-make_diag (const octave_value& arg)
-{
-  return make_diag (arg, 0);
-}
-
-static octave_value
-make_diag (const octave_value& a, const octave_value& b)
-{
-  octave_value retval;
-
-  octave_idx_type k = b.int_value ();
-
-  if (error_state)
-    error ("diag: invalid second argument");      
-  else
-    retval = make_diag (a, k);
-
-  return retval;
-}
-
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} diag (@var{v}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\n\
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\n\
 vector is placed on the main diagonal.  For example,\n\
@@ -1206,19 +907,26 @@ Given a matrix argument, instead of a ve
 @var{k}-th diagonal of the matrix.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
-    retval = make_diag (args(0));
+    retval = args(0).diag();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
-    retval = make_diag (args(0), args(1));
+    {
+      octave_idx_type k = args(1).int_value ();
+
+      if (error_state)
+	error ("diag: invalid second argument");      
+      else
+	retval = args(0).diag(k);
+    }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -105,16 +105,19 @@ public:
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
     { MatrixType ret = typ; typ = _typ; return ret; }
 
+  octave_value diag (octave_idx_type k = 0) const
+    { return octave_value (matrix.diag (k)); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   bool is_matrix_type (void) const { return true; }
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -88,16 +88,19 @@ public:
     { return scalar; }
 
   size_t byte_size (void) const { return sizeof (ST); }
 
   octave_value all (int = 0) const { return (scalar != ST ()); }
 
   octave_value any (int = 0) const { return (scalar != ST ()); }
 
+  octave_value diag (octave_idx_type k = 0) const 
+    { return octave_value (matrix_value (). diag (k)); }
+
   octave_value sort (octave_idx_type, sortmode) const
     { return octave_value (scalar); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type,
 		     sortmode) const
     { 
       sidx.resize (dim_vector (1, 1)); 
       sidx(0) = 0; 
       return octave_value (scalar); 
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -111,16 +111,19 @@ octave_base_sparse : public octave_base_
   octave_value permute (const Array<int>& vec, bool inv = false) const
     { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
+  octave_value diag (octave_idx_type k = 0) const
+    { return octave_value (matrix.diag (k)); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		     sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -874,16 +874,24 @@ mxArray *
 octave_base_value::as_mxArray (void) const
 {
   gripe_wrong_type_arg ("octave_base_value::as_mxArray ()", type_name ());
 
   return 0;
 }
 
 octave_value
+octave_base_value::diag (octave_idx_type) const
+{
+  gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
+
+  return octave_value();
+}
+
+octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 octave_value
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -453,16 +453,18 @@ public:
   virtual void *mex_get_data (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
 
   virtual mxArray *as_mxArray (void) const;
 
+  virtual octave_value diag (octave_idx_type k = 0) const;
+
   virtual octave_value sort (octave_idx_type dim = 0, 
 			     sortmode mode = ASCENDING) const;
   virtual octave_value sort (Array<octave_idx_type> &sidx, 
 			     octave_idx_type dim = 0,
 			     sortmode mode = ASCENDING) const;
 
   virtual void lock (void);
 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -127,16 +127,19 @@ public:
   bool is_constant (void) const { return true; }
 
   bool is_range (void) const { return true; }
 
   octave_value all (int dim = 0) const;
 
   octave_value any (int dim = 0) const;
 
+  octave_value diag (octave_idx_type k = 0) const
+    { return octave_value (range.diag (k)); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return range.sort (dim, mode); }
 
   octave_value sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
 		     sortmode mode = ASCENDING) const
     { return range.sort (sidx, dim, mode); }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -863,16 +863,19 @@ public:
   void *mex_get_data (void) const { return rep->mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return rep->mex_get_ir (); }
 
   octave_idx_type *mex_get_jc (void) const { return rep->mex_get_jc (); }
 
   mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
 
+  octave_value diag (octave_idx_type k = 0) const
+    { return rep->diag (k); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return rep->sort (dim, mode); } 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const
     { return rep->sort (sidx, dim, mode); } 
 
   void lock (void) { rep->lock (); }
 
