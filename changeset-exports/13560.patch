# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@gmail.com>
# Date 1312054360 18000
#      Sat Jul 30 14:32:40 2011 -0500
# Node ID 09f3192f35be1ba634fd348c17fb9abbba215cf6
# Parent  b9c66f8912819d632f96c6f90ab2646ed93fe908
# Parent  316108b2dcd78db72940f675b8c8258d179be2e2
Merge with Savannah

diff --git a/gui/COPYING b/gui/COPYING
new file mode 100644
--- /dev/null
+++ b/gui/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/gui/Doxyfile b/gui/Doxyfile
new file mode 100644
--- /dev/null
+++ b/gui/Doxyfile
@@ -0,0 +1,1679 @@
+# Quint - A graphical user interface for Octave
+# Copyright (C) 2011 Jacob Dawid
+# jacob.dawid@googlemail.com
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# Doxyfile 1.7.1
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = Quint
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.4
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = /home/jacob/Desktop/Quint-Documentation
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German, 
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English 
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, 
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it 
+# parses. With this tag you can assign which parser to use for a given extension. 
+# Doxygen has a built-in mapping, but you can override or extend it using this 
+# tag. The format is ext=language, where ext is a file extension, and language 
+# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C, 
+# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make 
+# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C 
+# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions 
+# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to 
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen to replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk. 
+# When the cache is full, less often used symbols will be written to disk. 
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penality. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will rougly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen 
+# will list include files with double quotes in the documentation 
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen 
+# will sort the (brief and detailed) documentation of class members so that 
+# constructors and destructors are listed first. If set to NO (the default) 
+# the constructors will appear in the respective orders defined by 
+# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS. 
+# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO 
+# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES. 
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
+# This will remove the Files entry from the Quick Index and from the 
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page.  This will remove the Namespaces entry from the Quick Index 
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed 
+# by doxygen. The layout file controls the global structure of the generated 
+# output files in an output format independent way. The create the layout file 
+# that represents doxygen's defaults, run doxygen with the -l option. 
+# You can optionally specify a file name after the option, if omitted 
+# DoxygenLayout.xml will be used as the name of the layout file.
+
+LAYOUT_FILE            = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = /home/jacob/Desktop/gnu-octave/gui/src
+
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.d \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.idl \
+                         *.odl \
+                         *.cs \
+                         *.php \
+                         *.php3 \
+                         *.inc \
+                         *.m \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.f90 \
+                         *.f \
+                         *.vhd \
+                         *.vhdl
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default) 
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from 
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will 
+# link to the source code.  Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = YES
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. 
+# Doxygen will adjust the colors in the stylesheet and background images 
+# according to this color. Hue is specified as an angle on a colorwheel, 
+# see http://en.wikipedia.org/wiki/Hue for more information. 
+# For instance the value 0 represents red, 60 is yellow, 120 is green, 
+# 180 is cyan, 240 is blue, 300 purple, and 360 is red again. 
+# The allowed range is 0 to 359.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of 
+# the colors in the HTML output. For a value of 0 the output will use 
+# grayscales only. A value of 255 will produce the most vivid colors.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to 
+# the luminance component of the colors in the HTML output. Values below 
+# 100 gradually make the output lighter, whereas values above 100 make 
+# the output darker. The value divided by 100 is the actual gamma applied, 
+# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2, 
+# and 100 does not change the gamma.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML 
+# page will contain the date and time when the page was generated. Setting 
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html 
+# for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify 
+# the documentation publisher. This should be a reverse domain-name style 
+# string, e.g. com.mycompany.MyDocSet.documentation.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
+# content.
+
+CHM_INDEX_ENCODING     = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and 
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated 
+# that can be used as input for Qt's qhelpgenerator to generate a 
+# Qt Compressed Help (.qch) of the generated HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to 
+# add. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the 
+# custom filter to add. For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters"> 
+# Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this 
+# project's 
+# filter section matches. 
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes"> 
+# Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
+# .qhp file.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files  
+# will be generated, which together with the HTML files, form an Eclipse help 
+# plugin. To install this plugin and make it available under the help contents 
+# menu in Eclipse, the contents of the directory containing the HTML and XML 
+# files needs to be copied into the plugins directory of eclipse. The name of 
+# the directory within the plugins directory should be the same as 
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before 
+# the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin 
+# the directory name containing the HTML and XML files should also have 
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
+# structure should be generated to display hierarchical information. 
+# If the tag value is set to YES, a side panel will be generated 
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser). 
+# Windows users are probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories, 
+# and Class Hierarchy pages using a tree view instead of an ordered list.
+
+USE_INLINE_TREES       = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open 
+# links to external symbols imported via tag files in a separate window.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images 
+# generated for formulas are transparent PNGs. Transparent PNGs are 
+# not supported properly for IE 6.0, but are supported on all modern browsers. 
+# Note that when changing this option you need to delete any form_*.png files 
+# in the HTML output before the changes have effect.
+
+FORMULA_TRANSPARENT    = YES
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box 
+# for the HTML output. The underlying search engine uses javascript 
+# and DHTML and should work on any modern browser. Note that when using 
+# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets 
+# (GENERATE_DOCSET) there is already a search function so this one should 
+# typically be disabled. For large projects the javascript based search engine 
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be 
+# implemented using a PHP enabled web server instead of at the web client 
+# using Javascript. Doxygen will generate the search PHP script and index 
+# file to put on the web server. The advantage of the server 
+# based approach is that it scales better to large projects and allows 
+# full text search. The disadvances is that it is more difficult to setup 
+# and does not have live searching capabilities.
+
+SERVER_BASED_SEARCH    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name. 
+# Note that when enabling USE_PDFLATEX this option is only used for 
+# generating bitmaps for formulas in the HTML output, but not in the 
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include 
+# source code with syntax highlighting in the LaTeX output. 
+# Note that which sources are shown also depends on other settings 
+# such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links. 
+# Note that each tag file must have a unique name 
+# (where the name does NOT include the path) 
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = NO
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
+# default search path.
+
+MSCGEN_PATH            = 
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is 
+# allowed to run in parallel. When set to 0 (the default) doxygen will 
+# base this on the number of processors available in the system. You can set it 
+# explicitly to a value larger than 0 to get control over the balance 
+# between CPU load and processing speed.
+
+DOT_NUM_THREADS        = 0
+
+# By default doxygen will write a font called FreeSans.ttf to the output 
+# directory and reference it in all dot files that doxygen generates. This 
+# font does not include all possible unicode characters however, so when you need 
+# these (or just want a differently looking font) you can specify the font name 
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
+# containing the font.
+
+DOT_FONTNAME           = FreeSans.ttf
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
+# can find it using this tag.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = YES
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = YES
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include 
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif 
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
diff --git a/gui/README b/gui/README
new file mode 100644
--- /dev/null
+++ b/gui/README
@@ -0,0 +1,25 @@
+/* Quint - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+Quint is a graphical user interface for Octave with readline support.
+
+If you have any problems, suggestions or ideas, feel free to drop me a mail at
+jacob.dawid@googlemail.com or visit the official channel #octave on FreeNode.
+
+- Jacob Dawid
+
diff --git a/gui/bin/bin b/gui/bin/bin
new file mode 100644
diff --git a/gui/compile.sh b/gui/compile.sh
new file mode 100755
--- /dev/null
+++ b/gui/compile.sh
@@ -0,0 +1,18 @@
+# Quint - A graphical user interface for Octave
+# Copyright (C) 2011 Jacob Dawid
+# jacob.dawid@googlemail.com
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+qmake-qt4 && make
diff --git a/gui/default-settings/settings.ini b/gui/default-settings/settings.ini
new file mode 100644
--- /dev/null
+++ b/gui/default-settings/settings.ini
@@ -0,0 +1,8 @@
+[General]
+IRCNick=OctaveUser
+connectOnStartup=true
+autoIdentification=false
+nickServPassword=
+showMessageOfTheDay=false
+showTopic=true
+
diff --git a/gui/kb-layouts/default.keytab b/gui/kb-layouts/default.keytab
new file mode 100644
--- /dev/null
+++ b/gui/kb-layouts/default.keytab
@@ -0,0 +1,133 @@
+# [README.default.Keytab] Buildin Keyboard Table
+#
+# To customize your keyboard, copy this file to something
+# ending with .keytab and change it to meet you needs.
+# Please read the README.KeyTab and the README.keyboard
+# in this case.
+#
+# --------------------------------------------------------------
+
+keyboard "Default (XFree 4)"
+
+# --------------------------------------------------------------
+#
+# Note that this particular table is a "risc" version made to
+# ease customization without bothering with obsolete details.
+# See VT100.keytab for the more hairy stuff.
+#
+# --------------------------------------------------------------
+
+# common keys
+
+key Escape             : "\E"
+
+key Tab   -Shift       : "\t"
+key Tab   +Shift+Ansi  : "\E[Z"
+key Tab   +Shift-Ansi  : "\t"
+key Backtab     +Ansi  : "\E[Z"
+key Backtab     -Ansi  : "\t"
+
+key Return-Shift-NewLine : "\r"
+key Return-Shift+NewLine : "\r\n"
+
+key Return+Shift         : "\EOM"
+
+# Backspace and Delete codes are preserving CTRL-H.
+
+key Backspace      : "\x7f"
+
+# Arrow keys in VT52 mode
+# shift up/down are reserved for scrolling.
+# shift left/right are reserved for switching between tabs (this is hardcoded).
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# Arrow keys in ANSI mode with Application - and Normal Cursor Mode)
+
+key Up    -Shift-AnyMod+Ansi+AppCuKeys           : "\EOA"
+key Down  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOB"
+key Right -Shift-AnyMod+Ansi+AppCuKeys           : "\EOC"
+key Left  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOD"
+
+key Up    -Shift-AnyMod+Ansi-AppCuKeys           : "\E[A"
+key Down  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[B"
+key Right -Shift-AnyMod+Ansi-AppCuKeys           : "\E[C"
+key Left  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[D"
+
+key Up    -Shift+AnyMod+Ansi                     : "\E[1;*A"
+key Down  -Shift+AnyMod+Ansi                     : "\E[1;*B"
+key Right -Shift+AnyMod+Ansi                     : "\E[1;*C"
+key Left  -Shift+AnyMod+Ansi                     : "\E[1;*D"
+
+# other grey PC keys
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"
+
+key Home        -AnyMod     -AppCuKeys           : "\E[H"  
+key End         -AnyMod     -AppCuKeys           : "\E[F"  
+key Home        -AnyMod     +AppCuKeys           : "\EOH"  
+key End         -AnyMod     +AppCuKeys           : "\EOF"  
+key Home        +AnyMod                          : "\E[1;*H"
+key End         +AnyMod                          : "\E[1;*F"
+
+key Insert      -AnyMod                          : "\E[2~"
+key Delete      -AnyMod                          : "\E[3~"
+key Insert      +AnyMod                          : "\E[2;*~"
+key Delete      +AnyMod                          : "\E[3;*~"
+
+key Prior -Shift-AnyMod                          : "\E[5~"
+key Next  -Shift-AnyMod                          : "\E[6~"
+key Prior -Shift+AnyMod                          : "\E[5;*~"
+key Next  -Shift+AnyMod                          : "\E[6;*~"
+
+# Function keys
+key F1          -AnyMod                          : "\EOP"
+key F2          -AnyMod                          : "\EOQ"
+key F3          -AnyMod                          : "\EOR"
+key F4          -AnyMod                          : "\EOS"
+key F5          -AnyMod                          : "\E[15~"
+key F6          -AnyMod                          : "\E[17~"
+key F7          -AnyMod                          : "\E[18~"
+key F8          -AnyMod                          : "\E[19~"
+key F9          -AnyMod                          : "\E[20~"
+key F10         -AnyMod                          : "\E[21~"
+key F11         -AnyMod                          : "\E[23~"
+key F12         -AnyMod                          : "\E[24~"
+
+key F1          +AnyMod                          : "\EO*P"
+key F2          +AnyMod                          : "\EO*Q"
+key F3          +AnyMod                          : "\EO*R"
+key F4          +AnyMod                          : "\EO*S"
+key F5          +AnyMod                          : "\E[15;*~"
+key F6          +AnyMod                          : "\E[17;*~"
+key F7          +AnyMod                          : "\E[18;*~"
+key F8          +AnyMod                          : "\E[19;*~"
+key F9          +AnyMod                          : "\E[20;*~"
+key F10         +AnyMod                          : "\E[21;*~"
+key F11         +AnyMod                          : "\E[23;*~"
+key F12         +AnyMod                          : "\E[24;*~"
+
+# Work around dead keys
+
+key Space +Control : "\x00"
+
+# Some keys are used by konsole to cause operations.
+# The scroll* operations refer to the history buffer.
+
+key Up    +Shift-AppScreen  : scrollLineUp
+key Prior +Shift-AppScreen  : scrollPageUp
+key Down  +Shift-AppScreen  : scrollLineDown
+key Next  +Shift-AppScreen  : scrollPageDown
+
+#key Up    +Shift  : scrollLineUp
+#key Prior +Shift  : scrollPageUp
+#key Down  +Shift  : scrollLineDown
+#key Next  +Shift  : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+# keypad characters are not offered differently by Qt.
diff --git a/gui/kb-layouts/linux.keytab b/gui/kb-layouts/linux.keytab
new file mode 100644
--- /dev/null
+++ b/gui/kb-layouts/linux.keytab
@@ -0,0 +1,133 @@
+# [linux.keytab] Konsole Keyboard Table (Linux console keys)
+#
+# --------------------------------------------------------------
+
+# NOT TESTED, MAY NEED SOME CLEANUPS
+keyboard "Linux console"
+
+# --------------------------------------------------------------
+#
+# This configuration table allows to customize the
+# meaning of the keys.
+#
+# The syntax is that each entry has the form : 
+#
+#   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
+#
+# Keynames are those defined in <qnamespace.h> with the
+# "Qt::Key_" removed. (We'd better insert the list here)
+#
+# Mode names are : 
+#
+# - Shift
+# - Alt
+# - Control
+#
+#   The VT100 emulation has two modes that can affect the
+#   sequences emitted by certain keys. These modes are
+#   under control of the client program.
+#   
+# - Newline     : effects Return and Enter key.
+# - Application : effects Up and Down key.
+#
+# - Ansi        : effects Up and Down key (This is for VT52, really).
+#
+# Operations are
+#
+# - scrollUpLine
+# - scrollUpPage
+# - scrollDownLine
+# - scrollDownPage
+#
+# - emitSelection
+#
+# If the key is not found here, the text of the
+# key event as provided by QT is emitted, possibly
+# preceeded by ESC if the Alt key is pressed.
+#
+# --------------------------------------------------------------
+
+key Escape : "\E"
+key Tab    : "\t"
+
+# VT100 can add an extra \n after return.
+# The NewLine mode is set by an escape sequence.
+
+key Return-NewLine : "\r"  
+key Return+NewLine : "\r\n"
+
+# Some desperately try to save the ^H.
+
+key Backspace : "\x7f"
+key Delete    : "\E[3~"
+
+# These codes are for the VT52 mode of VT100
+# The Ansi mode (i.e. VT100 mode) is set by
+# an escape sequence
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# VT100 emits a mode bit together
+# with the arrow keys.The AppCuKeys
+# mode is set by an escape sequence.
+
+key Up   -Shift+Ansi+AppCuKeys : "\EOA"
+key Down -Shift+Ansi+AppCuKeys : "\EOB"
+key Right-Shift+Ansi+AppCuKeys : "\EOC"
+key Left -Shift+Ansi+AppCuKeys : "\EOD"
+
+key Up   -Shift+Ansi-AppCuKeys : "\E[A"
+key Down -Shift+Ansi-AppCuKeys : "\E[B"
+key Right-Shift+Ansi-AppCuKeys : "\E[C"
+key Left -Shift+Ansi-AppCuKeys : "\E[D"
+
+# linux functions keys F1-F5 differ from xterm
+
+key F1 : "\E[[A" 
+key F2 : "\E[[B" 
+key F3 : "\E[[C" 
+key F4 : "\E[[D" 
+key F5 : "\E[[E" 
+
+key F6     : "\E[17~" 
+key F7     : "\E[18~" 
+key F8     : "\E[19~" 
+key F9     : "\E[20~" 
+key F10    : "\E[21~" 
+key F11    : "\E[23~" 
+key F12    : "\E[24~" 
+
+key Home   : "\E[1~"  
+key End    : "\E[4~"  
+
+key Prior -Shift : "\E[5~"  
+key Next  -Shift : "\E[6~"  
+key Insert-Shift : "\E[2~"  
+
+# Keypad-Enter. See comment on Return above.
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"  
+
+key Space +Control : "\x00"
+
+# some of keys are used by konsole.
+
+key Up    +Shift   : scrollLineUp
+key Prior +Shift   : scrollPageUp
+key Down  +Shift   : scrollLineDown
+key Next  +Shift   : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+#----------------------------------------------------------
+
+# keypad characters as offered by Qt
+# cannot be recognized as such.
+
+#----------------------------------------------------------
+
+# Following other strings as emitted by konsole.
diff --git a/gui/kb-layouts/vt420pc.keytab b/gui/kb-layouts/vt420pc.keytab
new file mode 100644
--- /dev/null
+++ b/gui/kb-layouts/vt420pc.keytab
@@ -0,0 +1,163 @@
+# [vt420pc.keytab] Konsole Keyboard Table (VT420pc keys)
+# adapted by ferdinand gassauer f.gassauer@aon.at
+# Nov 2000
+#
+################################################################
+#
+# The escape sequences emmited by the 
+# keys Shift+F1 to Shift+F12 might not fit your needs
+#
+################# IMPORTANT NOTICE #############################
+# the key bindings (Kcontrol -> look and feel -> keybindgs) 
+# overrule the settings in this file. The key bindings might be 
+# changed by the user WITHOUT notification of the maintainer of
+# the keytab file. Konsole will not work as expected by 
+# the maintainer of the keytab file.
+################################################################
+#
+# --------------------------------------------------------------
+
+keyboard "DEC VT420 Terminal"
+
+# --------------------------------------------------------------
+#
+# This configuration table allows to customize the
+# meaning of the keys.
+#
+# The syntax is that each entry has the form : 
+#
+#   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
+#
+# Keynames are those defined in <qnamespace.h> with the
+# "Qt::Key_" removed. (We'd better insert the list here)
+#
+# Mode names are : 
+#
+# - Shift
+# - Alt
+# - Control
+#
+#   The VT100 emulation has two modes that can affect the
+#   sequences emitted by certain keys. These modes are
+#   under control of the client program.
+#   
+# - Newline     : effects Return and Enter key.
+# - Application : effects Up and Down key.
+#
+# - Ansi        : effects Up and Down key (This is for VT52, really).
+#
+# Operations are
+#
+# - scrollUpLine
+# - scrollUpPage
+# - scrollDownLine
+# - scrollDownPage
+#
+# - emitSelection
+#
+# If the key is not found here, the text of the
+# key event as provided by QT is emitted, possibly
+# preceeded by ESC if the Alt key is pressed.
+#
+# --------------------------------------------------------------
+
+key Escape : "\E"
+key Tab    : "\t"
+key Backtab: "\E[Z"
+
+# VT100 can add an extra \n after return.
+# The NewLine mode is set by an escape sequence.
+
+key Return-NewLine : "\r"  
+key Return+NewLine : "\r\n"
+
+# Some desperately try to save the ^H.
+# may be not everyone wants this
+
+key Backspace : "\x08"  # Control H
+key Delete    : "\x7f"
+
+# These codes are for the VT420pc
+# The Ansi mode (i.e. VT100 mode) is set by
+# an escape sequence
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# VT100 emits a mode bit together
+# with the arrow keys.The AppCuKeys
+# mode is set by an escape sequence.
+
+key Up   -Shift+Ansi+AppCuKeys : "\EOA"
+key Down -Shift+Ansi+AppCuKeys : "\EOB"
+key Right-Shift+Ansi+AppCuKeys : "\EOC"
+key Left -Shift+Ansi+AppCuKeys : "\EOD"
+
+key Up   -Shift+Ansi-AppCuKeys : "\E[A"
+key Down -Shift+Ansi-AppCuKeys : "\E[B"
+key Right-Shift+Ansi-AppCuKeys : "\E[C"
+key Left -Shift+Ansi-AppCuKeys : "\E[D"
+
+# function keys 
+
+key F1 -Shift    : "\E[11~"  
+key F2 -Shift    : "\E[12~"
+key F3 -Shift    : "\E[13~"
+key F4 -Shift    : "\E[14~"
+key F5 -Shift    : "\E[15~"
+key F6 -Shift    : "\E[17~"
+key F7 -Shift    : "\E[18~"
+key F8 -Shift    : "\E[19~"
+key F9 -Shift    : "\E[20~"
+key F10-Shift    : "\E[21~"
+key F11-Shift    : "\E[23~"
+key F12-Shift    : "\E[24~"  
+#
+# Shift F1-F12
+#
+key F1 +Shift    : "\E[11;2~"
+key F2 +Shift    : "\E[12;2~"
+key F3 +Shift    : "\E[13;2~"
+key F4 +Shift    : "\E[14;2~"
+key F5 +Shift    : "\E[15;2~"
+key F6 +Shift    : "\E[17;2~" 
+key F7 +Shift    : "\E[18;2~" 
+key F8 +Shift    : "\E[19;2~" 
+key F9 +Shift    : "\E[20;2~" 
+key F10+Shift    : "\E[21;2~" 
+key F11+Shift    : "\E[23;2~" 
+key F12+Shift    : "\E[24;2~" 
+
+key Home   : "\E[H"  
+key End    : "\E[F"  
+
+key Prior -Shift : "\E[5~"  
+key Next  -Shift : "\E[6~"  
+key Insert-Shift : "\E[2~"  
+
+# Keypad-Enter. See comment on Return above.
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"  
+
+key Space +Control : "\x00"
+
+# some of keys are used by konsole.
+
+key Up    +Shift   : scrollLineUp
+key Prior +Shift   : scrollPageUp
+key Down  +Shift   : scrollLineDown
+key Next  +Shift   : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+#----------------------------------------------------------
+
+# keypad characters as offered by Qt
+# cannot be recognized as such.
+
+#----------------------------------------------------------
+
+# Following other strings as emitted by konsole.
diff --git a/gui/languages/german b/gui/languages/german
new file mode 100644
--- /dev/null
+++ b/gui/languages/german
@@ -0,0 +1,462 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="de_DE">
+<context>
+    <name>FileEditorMdiSubWindow</name>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="79"/>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="172"/>
+        <source>File Editor</source>
+        <translation type="unfinished">Dateieditor</translation>
+    </message>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="80"/>
+        <source>Cannot read file %1:
+%2.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="92"/>
+        <source>File loaded.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="118"/>
+        <source>Do you want to save the current file
+%1 ?</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="173"/>
+        <source>Cannot write file %1:
+%2.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FileEditorMdiSubWindow.cpp" line="185"/>
+        <source>File %1 saved</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>FilesDockWidget</name>
+    <message>
+        <location filename="../src/FilesDockWidget.cpp" line="32"/>
+        <source>Current Folder</source>
+        <translation>Aktuelles Verzeichnis</translation>
+    </message>
+    <message>
+        <location filename="../src/FilesDockWidget.cpp" line="46"/>
+        <source>Move up one directory.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FilesDockWidget.cpp" line="49"/>
+        <source>Enter the path or filename.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/FilesDockWidget.cpp" line="78"/>
+        <source>Doubleclick a file to open it.</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>HistoryDockWidget</name>
+    <message>
+        <location filename="../src/HistoryDockWidget.cpp" line="36"/>
+        <source>Doubleclick a command to transfer it to the terminal.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/HistoryDockWidget.cpp" line="38"/>
+        <source>Enter text to filter the command history.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/HistoryDockWidget.cpp" line="41"/>
+        <source>Command History</source>
+        <translation>Befehlshistorie</translation>
+    </message>
+    <message>
+        <source>History updated.</source>
+        <translation type="obsolete">Befehlshistorie aktualisiert.</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="46"/>
+        <source>Opening file.</source>
+        <translation>√ñffne Datei.</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="79"/>
+        <source>Save Workspace</source>
+        <translation>Speichere Arbeitsumgebung</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="89"/>
+        <source>Load Workspace</source>
+        <translation>Lade Arbeitsumgebung</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="171"/>
+        <location filename="../src/MainWindow.cpp" line="302"/>
+        <source>About Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="183"/>
+        <source>Saving data and shutting down.</source>
+        <translation>Speichere Daten und schlie√üe.</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="225"/>
+        <source>View the variables in the active workspace.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="227"/>
+        <source>Browse and search the command history.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="229"/>
+        <source>Browse your files.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="245"/>
+        <source>Terminal</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="247"/>
+        <source>Enter your commands into the Octave terminal.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="257"/>
+        <source>Browse the Octave documentation for help.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="266"/>
+        <source>Chat</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="268"/>
+        <source>Instantly chat with other Octave users for help.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="270"/>
+        <source>Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="271"/>
+        <source>Settings</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="273"/>
+        <source>Exit</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="275"/>
+        <source>Interface</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="277"/>
+        <source>Align Windows</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="279"/>
+        <location filename="../src/MainWindow.cpp" line="291"/>
+        <source>Workspace</source>
+        <translation type="unfinished">Arbeitsumgebung</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="282"/>
+        <source>History</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="285"/>
+        <source>File Browser</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="289"/>
+        <source>Open New Editor Window</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="292"/>
+        <source>Load</source>
+        <translation type="unfinished">Laden</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="293"/>
+        <source>Save</source>
+        <translation type="unfinished">Sichern</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="295"/>
+        <source>Clear</source>
+        <translation type="unfinished">L√∂schen</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="297"/>
+        <source>Community</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="298"/>
+        <source>Report Bug</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="299"/>
+        <source>Agora</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="300"/>
+        <source>Octave Forge</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="303"/>
+        <source>About Qt</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <source>Octave Toolbar</source>
+        <translation type="obsolete">Octave Werkzeugleiste</translation>
+    </message>
+    <message>
+        <source>Command Window</source>
+        <translation type="obsolete">Konsolenfenster</translation>
+    </message>
+    <message>
+        <source>File Editor</source>
+        <translation type="obsolete">Dateieditor</translation>
+    </message>
+    <message>
+        <location filename="../src/MainWindow.cpp" line="255"/>
+        <source>Documentation</source>
+        <translation>Dokumentation</translation>
+    </message>
+    <message>
+        <source>Service</source>
+        <translation type="obsolete">Service</translation>
+    </message>
+    <message>
+        <source>Established link to Octave.</source>
+        <translation type="obsolete">Verbindung zu Octave hergestellt.</translation>
+    </message>
+</context>
+<context>
+    <name>NumberBar</name>
+    <message>
+        <source>Stop Here</source>
+        <translation type="obsolete">Stoppe hier</translation>
+    </message>
+    <message>
+        <source>Current Line</source>
+        <translation type="obsolete">Aktuelle Zeile</translation>
+    </message>
+    <message>
+        <source>Error Line</source>
+        <translation type="obsolete">Fehlerzeile</translation>
+    </message>
+</context>
+<context>
+    <name>NumberedCodeEdit</name>
+    <message>
+        <source>This file name is not valid.</source>
+        <translation type="obsolete">Dieser Dateiname ist nicht g√ºltig.</translation>
+    </message>
+    <message>
+        <source>Octave doesn&apos;t understand this file name:
+</source>
+        <translation type="obsolete">Octave versteht diesen Dateityp nicht:</translation>
+    </message>
+    <message>
+        <source>
+Please, change it.
+ Do you want to save your changes?</source>
+        <translation type="obsolete">Bitte √§ndern Sie dies. M√∂chten Sie Ihre √Ñnderungen sichern?</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="29"/>
+        <source>Settings</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="39"/>
+        <source>Chat</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="47"/>
+        <source>Connect to #octave on startup</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="57"/>
+        <source>Show message of the day</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="64"/>
+        <source>Show topic</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="71"/>
+        <source>Automatically identify on NickServ</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="78"/>
+        <source>Warning: Your password will be stored in ~/.octavegui in human-readable format. Do not enter your password if you worry about security issues.</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="103"/>
+        <source>Password:</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="125"/>
+        <source>Editor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="133"/>
+        <source>Use custom file editor:</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="143"/>
+        <source>emacs</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="166"/>
+        <source>File Browser</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="172"/>
+        <source>Show filenames</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="179"/>
+        <source>Show file size</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="186"/>
+        <source>Show file type</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="193"/>
+        <source>Show date of last modification</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="200"/>
+        <source>Show hidden files</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="207"/>
+        <source>Alternating row colors</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="223"/>
+        <source>Reset to defaults</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="246"/>
+        <source>Export</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location filename="../src/SettingsDialog.ui" line="256"/>
+        <source>Import</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>VariablesDockWidget</name>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="40"/>
+        <source>Name</source>
+        <translation>Bezeichner</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="40"/>
+        <source>Type</source>
+        <translation>Typ</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="40"/>
+        <source>Value</source>
+        <translation>Wert</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="36"/>
+        <source>Workspace</source>
+        <translation>Arbeitsumgebung</translation>
+    </message>
+    <message>
+        <source>Save</source>
+        <translation type="obsolete">Sichern</translation>
+    </message>
+    <message>
+        <source>Load</source>
+        <translation type="obsolete">Laden</translation>
+    </message>
+    <message>
+        <source>Clear</source>
+        <translation type="obsolete">L√∂schen</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="52"/>
+        <source>Local</source>
+        <translation>Lokal</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="56"/>
+        <source>Global</source>
+        <translation>Global</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="60"/>
+        <source>Persistent</source>
+        <translation>Persistent</translation>
+    </message>
+    <message>
+        <location filename="../src/VariablesDockWidget.cpp" line="64"/>
+        <source>Hidden</source>
+        <translation>Versteckt</translation>
+    </message>
+</context>
+</TS>
diff --git a/gui/languages/german.qm b/gui/languages/german.qm
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..13cd427ba4fa69ba638a54f79dbb25ff3e02654c
GIT binary patch
literal 2753
zc$}41U1(fI6h52%Np_oTYAX^n#1Vu_4EqqMXpn~dHfq`gHY6%Ryt{Xjz3$za<=)v1
z2|g);2tJA6gFg5qh-fJ&Rk2oR!79ZE(Kq!$L8wYauoMyWo4GglZqnP0vh1DNxpThr
zo$t&!vk#xMhrYP>`m0y&8UFO?H$VAqnuva<>~TfZdxf$K$BFtTDErzaj29?-fn)rO
z9=-oLydR?S(o00y8&rPcS*)jN{rUHa@?)vX=UyPnY@~iWf&J<Ap5j&P@A)kK#+Ppq
zrS49jPnU>tuVj9F9Cp3s%(b`AV|+PtBYy<@#<FLRevf@;a`%1!|Cy_~sh_{W_)eer
zr3d^dKl;$0cv|_(Ux8O<yfFCrMfl%2H2%?tc)i~L;6Lxe@5ciRUr&PHv4Km!7P0<b
zas34L_qfGB+^2y5%pjc=*f-<=>`WRvMrn%bq^L!lTzokB#Ap?xM>}{rRHYgTjDDXc
zlEb$+)ABqn6q}c>&AnbM4bD3*_h)6bzUJ7QT%|Pj2u%ZF1K%2ueLR5zUlQ03@d$5l
zMm8Fju-Ss+E9q@(z}v$4KFEpgkf3gb;aGUD-#I1}MWx8y;Sid&nzp65UFza*gdPL7
z0FE@`2;*BApTO;qBn)BA5w_gYh=o&@BZ8j>>Q0&kNFCG~210?N0zJS-FavPkYCu{`
zIZ`B{OozFtz*3M6G(npPdj~T{OURbSZ5t_SX6L5KsS5MkDa2iKzOpK=<JY*&Tu0QI
zl5DA}tTrzt`Mv`YSO!UpYU62ykMIuZL%`;22SO&<-$#qEw+*)`69YFGzR^VUtOW7I
zvMx#sno6(kH?1m90v+8K^qL8}ZVqn?pssOZ1c+gSAlZtPZpBLEIz-<h)f-@=LF2e%
z^#+!jTsUHrZ6NAIy~e3b&8UVnt^W~uSrhCU`9vc8E>(ef%N!8~H&s(FI&DAT8wW80
zH#!Csg2nXt^=mDq%!=F+iBT2dRy%7O$FZorW$v||WU9kAbs0ua8tQHbLjP`GS#*Sf
z$)9dDD%_j4yzu<ZhlL+^r%wCAoaagJ*4AZnUYkZVW?DyQ3Fpg7HrWFAl8oCZJe@FQ
zOn)-EY7$!Ia@cunGx}7*{1ja`n(t;}ch4hO3-WX^!U#$@*ynd-Q_y5Y?t#Lx%PpUe
zv1-i{o18hSRA94`ZOazhvY;7C*Vjh|3tqU%pVW~Y4kF?9jI_BfP7~1LzOrc>mqDM<
zwBv9BVsQm1+J=J6+zCO56A{hPu&`{&eQ`{&mcadhCWC{eYL0J8g$b*{CknTwHjB@$
zYj2Nhfmy@Q4Jx{m1cQcun+E4#7N79pl|7Cbeh8^p+j5<t^Cy!iLZRzn;qZ<Qot;4*
zOvgC7YIzRY=S|mMKb-^*iIT=06dC4Dy0T)qT`iA<%{@p%RhLX`zu?$57hUZOQG<;M
zXLJia&`MuSoous<vU&j7+s#$n`5&RPnlh&$_5t?GVX$F))^}oD%gZ=8xRTKhx}p?K
zX+<Ry``7)mt7VQ>^hu5_R<@hnE&9UCC1#mjwcJ*BqmlpE@bi0meIne8c+rze{R^V|
BTj2lz

diff --git a/gui/media/chat.png b/gui/media/chat.png
new file mode 100755
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..40b19cb63b244d6e71de31875904fb934d0498a2
GIT binary patch
literal 15258
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
A4FCWD

diff --git a/gui/media/help_index.png b/gui/media/help_index.png
new file mode 100755
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..cf0fd38174d6901460943a4c7e66039eb95afaae
GIT binary patch
literal 22733
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
Y1F4`rfN3>^-~a#s07*qoM6N<$f@plx0{{R3

diff --git a/gui/media/icons_license b/gui/media/icons_license
new file mode 100644
--- /dev/null
+++ b/gui/media/icons_license
@@ -0,0 +1,103 @@
+Icons license for:
+chat.png
+help_index.png
+terminal.png
+
+by http://www.everaldo.com/ on 17.07.2011:
+
+The Crystal Project are released under LGPL.
+GNU General Public License.
+
+This License Agreement applies to any software library or other program which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Lesser General Public License (also called "this License"). Each licensee is addressed as "you".
+
+A "library" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables.
+
+The "Library", below, refers to any such software library or work which has been distributed under these terms. A "work based on the Library" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term "modification".)
+
+"Source code" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library.
+
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does.
+
+You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library.
+
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
+
+You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
+
+The modified work must itself be a software library.
+You must cause the files modified to carry prominent notices stating that you changed the files and the date of any change.
+You must cause the whole of the work to be licensed at no charge to all third parties under the terms of this License.
+If a facility in the modified Library refers to a function or a table of data to be supplied by an application program that uses the facility, other than as an argument passed when the facility is invoked, then you must make a good faith effort to ensure that, in the event an application does not supply such function or table, the facility still operates, and performs whatever part of its purpose remains meaningful.
+(For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.
+
+You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices.
+
+Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy.
+
+This option is useful when you wish to copy part of the code of the Library into a program that is not a library.
+
+You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange.
+
+If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code.
+
+A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.
+
+However, linking a "work that uses the Library" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a "work that uses the library". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables.
+When a "work that uses the Library" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.
+
+If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)
+
+Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself.
+
+As an exception to the Sections above, you may also combine or link a "work that uses the Library" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications.
+
+You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things:
+
+Accompany the work with the complete corresponding machine-readable source code for the Library including whatever changes were used in the work (which must be distributed under Sections 1 and 2 above); and, if the work is an executable linked with the Library, with the complete machine-readable "work that uses the Library", as object code and/or source code, so that the user can modify the Library and then relink to produce a modified executable containing the modified Library. (It is understood that the user who changes the contents of definitions files in the Library will not necessarily be able to recompile the application to use the modified definitions.) .
+Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (1) uses at run time a copy of the library already present on the user's computer system, rather than copying library functions into the executable, and (2) will operate properly with a modified version of the library, if the user installs one, as long as the modified version is interface-compatible with the version that the work was made with.
+Accompany the work with a written offer, valid for at least three years, to give the same user the materials specified in Subsection 6a, above, for a charge no more than the cost of performing this distribution.
+If distribution of the work is made by offering access to copy from a designated place, offer equivalent access to copy the above specified materials from the same place.
+Verify that the user has already received a copy of these materials or that you have already sent this user a copy.
+For an executable, the required form of the "work that uses the Library" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.
+
+It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute.
+
+You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things:
+
+Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities. This must be distributed under the terms of the Sections above.
+
+Give prominent notice with the combined library of the fact that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work.
+
+You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.
+
+You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it.
+
+Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties with this License.
+
+If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
+
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
+
+If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.
+
+The Free Software Foundation may publish revised and/or new versions of the Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation.
+
+If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
+
+No Warranty
+
+Because the library is licensed free of charge, there is no warranty for the library, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the library "as is" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the library is with you. Should the library prove defective, you assume the cost of all necessary servicing, repair or correction.
+
+In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the library as permitted above, be liable to you for damages, including any general, special, incidental or consequential damages arising out of the use or inability to use the library (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the library to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
diff --git a/gui/media/logo.png b/gui/media/logo.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..a10cf826f3342dae72ea3cae5496644da33f694a
GIT binary patch
literal 9205
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
LNkvXXu0mjf1IW{U

diff --git a/gui/media/terminal.png b/gui/media/terminal.png
new file mode 100755
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..a7230e4fc22daeb0d5d71faedee86e1eafe65771
GIT binary patch
literal 7757
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

diff --git a/gui/moc-files/moc-files b/gui/moc-files/moc-files
new file mode 100644
diff --git a/gui/object-files/object-files b/gui/object-files/object-files
new file mode 100644
diff --git a/gui/octave-gui.pro b/gui/octave-gui.pro
new file mode 100644
--- /dev/null
+++ b/gui/octave-gui.pro
@@ -0,0 +1,140 @@
+# OctaveGUI - A graphical user interface for Octave
+# Copyright (C) 2011 Jacob Dawid
+# jacob.dawid@googlemail.com
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# Basic settings:
+QT                  += core gui webkit		    # Qt modules
+TEMPLATE            = app                           # Build as application
+TARGET              = octave-gui                    # Name of the target binary
+
+DESTDIR             = bin                           # Destination of the output
+UI_DIR              = ui-files                      # Folder for ui files
+MOC_DIR             = moc-files                     # Folder for moc files
+OBJECTS_DIR         = object-files                  # Folder for object files
+
+TRANSLATIONS        += languages/german             # Available translations
+LIBS                += -lqscintilla2
+
+mac {
+    CONFIG -= app_bundle
+}
+
+# Includepaths and libraries to link against:
+INCLUDEPATH         += src src/terminal src/qirc src/backend
+INCFLAGS            += $$system(mkoctfile -p INCFLAGS)
+mac {
+    INCFLAGS += -I/opt/local-native/include
+}
+
+LFLAGS              += $$system(mkoctfile -p LFLAGS) \
+                       $$system(mkoctfile -p OCTAVE_LIBS) \
+                       $$system(mkoctfile -p LIBS)
+mac {
+    LFLAGS += -L/opt/local-native/lib
+}
+
+QMAKE_LFLAGS        += $$LFLAGS -lutil $$system(mkoctfile -p RLD_FLAG)
+QMAKE_CXXFLAGS      += $$INCFLAGS
+
+# Files associated with the project:
+SOURCES +=\
+        src/lexer/lexeroctavegui.cpp \
+        src/terminal/TerminalCharacterDecoder.cpp \
+        src/terminal/KeyboardTranslator.cpp \
+        src/terminal/Screen.cpp \
+        src/terminal/History.cpp \
+        src/terminal/konsole_wcwidth.cpp \
+        src/terminal/ScreenWindow.cpp \
+        src/terminal/Emulation.cpp \
+        src/terminal/Vt102Emulation.cpp \
+        src/terminal/TerminalDisplay.cpp \
+        src/terminal/Filter.cpp \
+        src/terminal/Pty.cpp \
+        src/terminal/kpty.cpp \
+        src/terminal/kptyprocess.cpp \
+        src/terminal/kprocess.cpp \
+        src/terminal/kptydevice.cpp \
+        src/terminal/Session.cpp \
+        src/terminal/ShellCommand.cpp \
+        src/terminal/QTerminalWidget.cpp \
+        src/MainWindow.cpp \
+    	  src/OctaveTerminal.cpp \
+    	  src/VariablesDockWidget.cpp \
+    	  src/HistoryDockWidget.cpp \
+    	  src/FilesDockWidget.cpp \
+    	  src/FileEditorMdiSubWindow.cpp \
+    	  src/BrowserWidget.cpp \
+    	  src/ImageViewerMdiSubWindow.cpp \
+    src/IRCWidget.cpp \
+    src/qirc/IRCClient.cpp \
+    src/qirc/IClientSocket.cpp \
+    src/SettingsDialog.cpp \
+    src/OctaveGUI.cpp \
+    src/ResourceManager.cpp \
+    src/CommandLineParser.cpp \
+    src/backend/OctaveCallbackThread.cpp \
+    src/backend/OctaveLink.cpp \
+    src/backend/OctaveMainThread.cpp
+
+HEADERS += \
+        src/lexer/lexeroctavegui.h \
+        src/terminal/TerminalCharacterDecoder.h \
+        src/terminal/Character.h \
+        src/terminal/CharacterColor.h \
+		  src/terminal/ColorTables.h \
+        src/terminal/KeyboardTranslator.h \
+        src/terminal/Screen.h \
+        src/terminal/History.h \
+        src/terminal/konsole_wcwidth.h \
+		  src/terminal/konsole_export.h \
+        src/terminal/ScreenWindow.h \
+        src/terminal/Emulation.h \
+        src/terminal/Vt102Emulation.h \
+        src/terminal/TerminalDisplay.h \
+        src/terminal/Filter.h \
+        src/terminal/Pty.h \
+        src/terminal/kpty.h \
+        src/terminal/kpty_p.h \
+		  src/terminal/kpty_export.h \
+        src/terminal/kptyprocess.h \
+        src/terminal/kprocess.h \
+        src/terminal/kprocess_p.h \
+        src/terminal/kptydevice.h \
+        src/terminal/Session.h \
+        src/terminal/ShellCommand.h \
+        src/terminal/QTerminalWidget.h \
+    	  src/MainWindow.h \
+    	  src/OctaveTerminal.h \
+    	  src/VariablesDockWidget.h \
+    	  src/HistoryDockWidget.h \
+    	  src/FilesDockWidget.h \
+    	  src/FileEditorMdiSubWindow.h \
+    	  src/BrowserWidget.h \
+    	  src/ImageViewerMdiSubWindow.h \
+    src/IRCWidget.h \
+    src/qirc/IRCCodes.h \
+    src/qirc/IRCClient.h \
+    src/qirc/IClientSocket.h \
+    src/SettingsDialog.h \
+    src/ResourceManager.h \
+    src/CommandLineParser.h \
+    src/backend/OctaveCallbackThread.h \
+    src/backend/OctaveLink.h \
+    src/backend/OctaveMainThread.h
+
+FORMS += \
+    src/SettingsDialog.ui
diff --git a/gui/src/BrowserWidget.cpp b/gui/src/BrowserWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/BrowserWidget.cpp
@@ -0,0 +1,91 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "BrowserWidget.h"
+#include <QVBoxLayout>
+#include <QAction>
+#include <QStyle>
+#include <QApplication>
+
+BrowserWidget::BrowserWidget (QWidget * parent):QWidget (parent)
+{
+  construct ();
+}
+
+void
+BrowserWidget::construct ()
+{
+  QStyle *style = QApplication::style ();
+  m_navigationToolBar = new QToolBar (this);
+  m_webView = new QWebView (this);
+  m_urlLineEdit = new QLineEdit (this);
+  m_statusBar = new QStatusBar (this);
+
+  m_webView->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);
+  QAction *backAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowLeft),
+		 "", m_navigationToolBar);
+  QAction *forwardAction =
+    new QAction (style->standardIcon (QStyle::SP_ArrowRight),
+		 "", m_navigationToolBar);
+
+  m_navigationToolBar->addAction (backAction);
+  m_navigationToolBar->addAction (forwardAction);
+  m_navigationToolBar->addWidget (m_urlLineEdit);
+
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_navigationToolBar);
+  layout->addWidget (m_webView);
+  layout->addWidget (m_statusBar);
+  layout->setMargin (2);
+  setLayout (layout);
+
+  connect (backAction, SIGNAL (triggered ()), m_webView, SLOT (back ()));
+  connect (forwardAction, SIGNAL (triggered ()), m_webView,
+	   SLOT (forward ()));
+  connect (m_webView, SIGNAL (urlChanged (QUrl)), this, SLOT (setUrl (QUrl)));
+  connect (m_urlLineEdit, SIGNAL (returnPressed ()), this,
+	   SLOT (jumpToWebsite ()));
+}
+
+void
+BrowserWidget::setUrl (QUrl url)
+{
+  m_urlLineEdit->setText (url.toString ());
+}
+
+void
+BrowserWidget::jumpToWebsite ()
+{
+  QString url = m_urlLineEdit->text ();
+  if (!url.startsWith ("http://"))
+    url = "http://" + url;
+  load (url);
+}
+
+void
+BrowserWidget::showStatusMessage (QString message)
+{
+  m_statusBar->showMessage (message, 1000);
+}
+
+void
+BrowserWidget::load (QUrl url)
+{
+  m_webView->load (url);
+}
diff --git a/gui/src/BrowserWidget.h b/gui/src/BrowserWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/BrowserWidget.h
@@ -0,0 +1,49 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BROWSERMDISUBWINDOW_H
+#define BROWSERMDISUBWINDOW_H
+
+#include <QWidget>
+#include <QToolBar>
+#include <QLineEdit>
+#include <QtWebKit/QWebView>
+#include <QStatusBar>
+
+class BrowserWidget:public QWidget
+{
+  Q_OBJECT
+public:
+  BrowserWidget (QWidget * parent = 0);
+  void load (QUrl url);
+
+public slots:
+  void setUrl (QUrl url);
+  void jumpToWebsite ();
+  void showStatusMessage (QString message);
+
+private:
+  void construct ();
+
+  QLineEdit *m_urlLineEdit;
+  QToolBar *m_navigationToolBar;
+  QWebView *m_webView;
+  QStatusBar *m_statusBar;
+};
+
+#endif // BROWSERMDISUBWINDOW_H
diff --git a/gui/src/CommandLineParser.cpp b/gui/src/CommandLineParser.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/CommandLineParser.cpp
@@ -0,0 +1,48 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "CommandLineParser.h"
+
+CommandLineParser::CommandLineParser ()
+{
+}
+
+void
+CommandLineParser::registerOption (CommandLineOption commandLineOption)
+{
+  if (m_registeredCommandLineOptions.contains(commandLineOption))
+    m_registeredCommandLineOptions.append(commandLineOption);
+}
+
+void
+CommandLineParser::registerOption (QString longOption, QString shortOption, QString description, bool withArgument)
+{
+  CommandLineOption commandLineOption;
+  commandLineOption.longOption = longOption;
+  commandLineOption.shortOption = shortOption;
+  commandLineOption.description = description;
+  commandLineOption.withArgument = withArgument;
+  registerOption (commandLineOption);
+}
+
+void
+CommandLineParser::parse (int argc, char** argv)
+{
+  Q_UNUSED(argc);
+  Q_UNUSED(argv);
+}
diff --git a/gui/src/CommandLineParser.h b/gui/src/CommandLineParser.h
new file mode 100644
--- /dev/null
+++ b/gui/src/CommandLineParser.h
@@ -0,0 +1,51 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef COMMANDLINEPARSER_H
+#define COMMANDLINEPARSER_H
+
+#include <QList>
+#include <QString>
+
+class CommandLineParser
+{
+public:
+  struct CommandLineOption
+  {
+    QString longOption;
+    QString shortOption;
+    QString description;
+    bool withArgument;
+
+    bool operator== (CommandLineOption other)
+    {
+        return longOption == other.longOption
+            || shortOption == other.shortOption;
+    }
+  };
+
+  CommandLineParser ();
+  void registerOption (CommandLineOption commandLineOption);
+  void registerOption (QString longOption, QString shortOption, QString description, bool withArgument);
+  void parse (int argc, char** argv);
+
+private:
+  QList<CommandLineOption> m_registeredCommandLineOptions;
+};
+
+#endif // COMMANDLINEPARSER_H
diff --git a/gui/src/FileEditorMdiSubWindow.cpp b/gui/src/FileEditorMdiSubWindow.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/FileEditorMdiSubWindow.cpp
@@ -0,0 +1,361 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "FileEditorMdiSubWindow.h"
+#include <QVBoxLayout>
+#include <QApplication>
+#include <QFile>
+#include <QFileDialog>
+#include <QMessageBox>
+#include <QAction>
+#include <QStyle>
+#include <QTextStream>
+
+FileEditorMdiSubWindow::FileEditorMdiSubWindow (QWidget * parent):QMdiSubWindow
+  (parent)
+{
+  construct ();
+}
+
+FileEditorMdiSubWindow::~FileEditorMdiSubWindow ()
+{
+}
+
+void
+FileEditorMdiSubWindow::closeEvent(QCloseEvent *event)
+{
+  // ignore close event if file is not saved and user cancels closing this window
+  // TODO: This does not work if the main window is closed!
+  if (checkFileModified ("Close File")==QMessageBox::Cancel)
+    {
+      event->ignore();
+    }
+  else
+    {
+      event->accept();
+    }
+}
+
+void
+FileEditorMdiSubWindow::handleModificationChanged(bool modified)
+{
+  if ( modified )
+    {
+      QString title(m_fileName);
+      setWindowTitle(title.prepend("* "));
+    }
+  else
+     setWindowTitle (m_fileName);
+}
+
+void
+FileEditorMdiSubWindow::openFile ()
+{
+    if (checkFileModified ("Open File")==QMessageBox::Cancel)
+      {
+        return; // existing file not saved and opening another file canceled by user
+      }
+    QString openFileName =
+        QFileDialog::getOpenFileName (this, "Open File", QDir::homePath(), SAVE_FILE_FILTER);
+    if (openFileName.isEmpty ())
+      {
+        return;
+      }
+    else
+      {
+        loadFile(openFileName);
+      }
+}
+
+void
+FileEditorMdiSubWindow::loadFile (QString fileName)
+{
+  QFile file (fileName);
+  if (!file.open (QFile::ReadOnly))
+    {
+      QMessageBox::warning (this, tr ("File Editor"),
+			    tr ("Cannot read file %1:\n%2.").arg (fileName).
+			    arg (file.errorString ()));
+      return;
+    }
+
+  QTextStream in (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  m_editor->setText (in.readAll ());
+  QApplication::restoreOverrideCursor ();
+
+  m_fileName = fileName;
+  setWindowTitle (fileName);
+  m_statusBar->showMessage (tr ("File loaded."), 2000);
+  m_editor->setModified (false); // loaded file is not modified yet
+}
+
+void
+FileEditorMdiSubWindow::newFile ()
+{
+    if (checkFileModified ("Open New File")==QMessageBox::Cancel)
+      {
+        return; // existing file not saved and creating new file canceled by user
+      }
+    m_fileName = UNNAMED_FILE;
+    setWindowTitle (m_fileName);
+    m_editor->setText ("");
+    m_editor->setModified (false); // new file is not modified yet
+}
+
+int
+FileEditorMdiSubWindow::checkFileModified (QString msg)
+{
+  int decision = QMessageBox::Yes;
+  if (m_editor->isModified ())
+    {
+      // file is modified but not saved, aks user what to do
+      decision = QMessageBox::question (this,
+                                        msg,
+                                        tr ("Do you want to save the current file\n%1 ?").
+                                          arg (m_fileName),
+                                        QMessageBox::Cancel,
+                                        QMessageBox::No,
+                                        QMessageBox::Yes);
+
+      if (decision == QMessageBox::Yes)
+        {
+          saveFile ();
+          if (m_editor->isModified ())
+            {
+              // If the user attempted to save the file, but it's still
+              // modified, then probably something went wrong, so return cancel
+              // for cancel this operation
+              return (QMessageBox::Cancel);
+            }
+        }
+    }
+  return (decision);
+}
+
+void
+FileEditorMdiSubWindow::saveFile ()
+{
+  saveFile(m_fileName);
+}
+
+void
+FileEditorMdiSubWindow::saveFile (QString fileName)
+{
+  // it is a new file with the name "<unnamed>" -> call saveFielAs
+  if (fileName==UNNAMED_FILE)
+    {
+      saveFileAs();
+      return;
+    }
+
+  // check for a valid file name to save the contents
+  QString saveFileName;
+  if (fileName.isEmpty ())
+    {
+      saveFileName = QFileDialog::getSaveFileName (this, "Save File", fileName,SAVE_FILE_FILTER);
+      if (saveFileName.isEmpty ())
+        return;
+    }
+  else
+    {
+    saveFileName = fileName;
+    }
+
+  // open the file
+  QFile file (saveFileName);
+  if (!file.open (QFile::WriteOnly))
+    {
+      QMessageBox::warning (this, tr ("File Editor"),
+			    tr ("Cannot write file %1:\n%2.").
+          arg (saveFileName).arg (file.errorString ()));
+      return;
+    }
+
+  // save the contents into the file
+  QTextStream out (&file);
+  QApplication::setOverrideCursor (Qt::WaitCursor);
+  out << m_editor->text ();
+  QApplication::restoreOverrideCursor ();
+  m_fileName = saveFileName;     // save file name for later use
+  setWindowTitle(m_fileName);    // set the window title to actual file name
+  m_statusBar->showMessage (tr ("File %1 saved").arg(m_fileName), 2000);
+  m_editor->setModified (false); // files is save -> not modified
+}
+
+void
+FileEditorMdiSubWindow::saveFileAs ()
+{
+  QString saveDir(m_fileName);
+  if (saveDir==UNNAMED_FILE)
+    saveDir = QDir::homePath();
+  QString saveFileName = QFileDialog::getSaveFileName(
+        this, "Save File As", saveDir,SAVE_FILE_FILTER);
+  if(saveFileName.isEmpty())
+    return;
+  saveFile(saveFileName);
+}
+
+void
+FileEditorMdiSubWindow::setEditorLexer (LexerOctaveGui* lexer)
+{
+  m_editor->setLexer(lexer);
+}
+
+// TODO: Do we still need tool tips in the status bar? Tool tips are now
+//       shown directly at the theme icons
+void
+FileEditorMdiSubWindow::showToolTipNew ()
+{
+  m_statusBar->showMessage ("Create a new file", 2000);
+}
+
+void
+FileEditorMdiSubWindow::showToolTipOpen ()
+{
+  m_statusBar->showMessage ("Open a file", 2000);
+}
+
+void
+FileEditorMdiSubWindow::showToolTipSave ()
+{
+  m_statusBar->showMessage ("Save the file", 2000);
+}
+
+void
+FileEditorMdiSubWindow::showToolTipSaveAs ()
+{
+  m_statusBar->showMessage ("Save the file as", 2000);
+}
+
+void
+FileEditorMdiSubWindow::showToolTipUndo ()
+{
+  m_statusBar->showMessage ("Revert previous changes", 2000);
+}
+
+void
+FileEditorMdiSubWindow::showToolTipRedo ()
+{
+  m_statusBar->showMessage ("Append previous changes", 2000);
+}
+
+void
+FileEditorMdiSubWindow::registerModified (bool modified)
+{
+  m_modified = modified;
+}
+
+void
+FileEditorMdiSubWindow::construct ()
+{
+  QStyle *style = QApplication::style ();
+  setWidget (new QWidget ());
+  m_toolBar = new QToolBar (this);
+  m_statusBar = new QStatusBar (this);
+  m_editor = new QsciScintilla (this);
+
+  m_editor->setMarginType (1, QsciScintilla::SymbolMargin);
+  m_editor->setMarginType (2, QsciScintilla::TextMargin);
+  m_editor->setMarginType (3, QsciScintilla::SymbolMargin);
+  m_editor->setFolding (QsciScintilla::BoxedTreeFoldStyle , 3);
+  m_editor->setMarginLineNumbers (2, true);
+  m_editor->setMarginWidth (2, "99999");
+  m_editor->setMarginsForegroundColor (QColor(96,96,96));
+  m_editor->setMarginsBackgroundColor (QColor(224,224,224));
+
+  m_editor->setBraceMatching (QsciScintilla::SloppyBraceMatch);
+  m_editor->setAutoIndent (true);
+  m_editor->setIndentationWidth (2);
+  m_editor->setIndentationsUseTabs (false);
+  m_editor->autoCompleteFromAll();
+  m_editor->setAutoCompletionSource(QsciScintilla::AcsAPIs);
+  m_editor->setAutoCompletionThreshold (3);
+
+  // Theme icons with QStyle icons as fallback
+  m_toolBar->setIconSize(QSize(20,20)); // smaller icons (make configurable in user settings?)
+  QAction *closeAction = new QAction (
+        QIcon::fromTheme("window-close",style->standardIcon (QStyle::SP_DialogCloseButton)),
+        tr("&Close File"), m_toolBar);
+  QAction *newAction = new QAction (
+        QIcon::fromTheme("document-new",style->standardIcon (QStyle::SP_FileIcon)),
+        tr("&New File"), m_toolBar);
+  QAction *openAction = new QAction (
+        QIcon::fromTheme("document-open",style->standardIcon (QStyle::SP_DirOpenIcon)),
+        tr("&Open File"), m_toolBar);
+  QAction *saveAction = new QAction (
+        QIcon::fromTheme("document-save",style->standardIcon (QStyle::SP_DriveHDIcon)),
+        tr("&Save File"), m_toolBar);
+  QAction *saveAsAction = new QAction (
+        QIcon::fromTheme("document-save-as",style->standardIcon (QStyle::SP_DriveFDIcon)),
+        tr("Save File &As"), m_toolBar);
+  QAction *undoAction = new QAction (
+        QIcon::fromTheme("edit-undo",style->standardIcon (QStyle::SP_ArrowLeft)),
+        tr("&Undo"), m_toolBar);
+  QAction *redoAction = new QAction (
+        QIcon::fromTheme("edit-redo",style->standardIcon (QStyle::SP_ArrowRight)),
+        tr("&Redo"), m_toolBar);
+
+  // short cuts
+  newAction->setShortcut(QKeySequence::New);
+  openAction->setShortcut(QKeySequence::Open);
+  saveAction->setShortcut(QKeySequence::Save);
+  saveAsAction->setShortcut(QKeySequence::SaveAs);
+  undoAction->setShortcut(QKeySequence::Undo);
+  redoAction->setShortcut(QKeySequence::Redo);
+
+  m_toolBar->addAction (closeAction);
+  m_toolBar->addAction (newAction);
+  m_toolBar->addAction (openAction);
+  m_toolBar->addAction (saveAction);
+  m_toolBar->addAction (saveAsAction);
+  m_toolBar->addAction (undoAction);
+  m_toolBar->addAction (redoAction);
+
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_toolBar);
+  layout->addWidget (m_editor);
+  layout->addWidget (m_statusBar);
+  layout->setMargin (2);
+  widget ()->setLayout (layout);
+
+  connect (closeAction, SIGNAL (triggered()), this, SLOT (close()));
+  connect (newAction, SIGNAL (triggered ()), this, SLOT (newFile ()));
+  connect (openAction, SIGNAL (triggered ()), this, SLOT (openFile ()));
+  connect (undoAction, SIGNAL (triggered ()), m_editor, SLOT (undo ()));
+  connect (redoAction, SIGNAL (triggered ()), m_editor, SLOT (redo ()));
+  connect (saveAction, SIGNAL (triggered ()), this, SLOT (saveFile ()));
+  connect (saveAsAction, SIGNAL (triggered ()), this, SLOT (saveFileAs ()));
+
+  // TODO: Do we still need tool tips in the status bar? Tool tips are now
+  //       shown directly at the theme icons
+  connect (newAction, SIGNAL (hovered ()), this, SLOT (showToolTipNew ()));
+  connect (openAction, SIGNAL (hovered ()), this, SLOT (showToolTipOpen ()));
+  connect (undoAction, SIGNAL (hovered ()), this, SLOT (showToolTipUndo ()));
+  connect (redoAction, SIGNAL (hovered ()), this, SLOT (showToolTipRedo ()));
+  connect (saveAction, SIGNAL (hovered ()), this, SLOT (showToolTipSave ()));
+  connect (saveAsAction, SIGNAL (hovered ()), this,SLOT (showToolTipSaveAs ()));
+
+  // connect modified signal
+  connect (m_editor, SIGNAL (modificationChanged(bool)), this, SLOT (handleModificationChanged(bool)) );
+
+  m_fileName = "";
+  setWindowTitle (m_fileName);
+  setWindowIcon(QIcon::fromTheme("accessories-text-editor",style->standardIcon (QStyle::SP_FileIcon)));
+  show ();
+}
diff --git a/gui/src/FileEditorMdiSubWindow.h b/gui/src/FileEditorMdiSubWindow.h
new file mode 100644
--- /dev/null
+++ b/gui/src/FileEditorMdiSubWindow.h
@@ -0,0 +1,75 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FILEEDITORMDISUBWINDOW_H
+#define FILEEDITORMDISUBWINDOW_H
+
+#include <QMdiSubWindow>
+#include <QToolBar>
+#include <QStatusBar>
+#include <QCloseEvent>
+#include <Qsci/qsciscintilla.h>
+// Not available in the Debian repos yet!
+// #include <Qsci/qscilexeroctave.h>
+#include "lexer/lexeroctavegui.h"
+
+const char UNNAMED_FILE[]     = "<unnamed>";
+const char SAVE_FILE_FILTER[] = "Octave Files  *.m(*.m);;All Files   *.*(*.*)";
+
+class FileEditorMdiSubWindow:public QMdiSubWindow
+{
+Q_OBJECT public:
+  FileEditorMdiSubWindow (QWidget * parent = 0);
+  ~FileEditorMdiSubWindow ();
+  void loadFile (QString fileName);
+  void setEditorLexer (LexerOctaveGui *lexer);
+
+public slots:
+
+  void newFile ();
+  void openFile ();
+  void saveFile ();
+  void saveFile (QString fileName);
+  void saveFileAs ();
+
+  void showToolTipNew ();
+  void showToolTipOpen ();
+  void showToolTipSave ();
+  void showToolTipSaveAs ();
+  void showToolTipUndo ();
+  void showToolTipRedo ();
+  void registerModified (bool modified);
+
+protected:
+  void closeEvent(QCloseEvent *event);
+
+private:
+  int checkFileModified (QString msg);
+  void construct ();
+  QToolBar *m_toolBar;
+  QsciScintilla *m_editor;
+  QStatusBar *m_statusBar;
+  QString m_fileName;
+  bool m_modified;
+
+private slots:
+  void handleModificationChanged(bool modified);
+
+};
+
+#endif // FILEEDITORMDISUBWINDOW_H
diff --git a/gui/src/FilesDockWidget.cpp b/gui/src/FilesDockWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/FilesDockWidget.cpp
@@ -0,0 +1,182 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ResourceManager.h"
+#include "FilesDockWidget.h"
+
+#include <QApplication>
+#include <QFileInfo>
+#include <QCompleter>
+#include <QSettings>
+#include <QProcess>
+#include <QDebug>
+
+FilesDockWidget::FilesDockWidget (QWidget * parent):QDockWidget (parent)
+{
+  setObjectName ("FilesDockWidget");
+  setWindowTitle (tr ("Current Folder"));
+  setWidget (new QWidget (this));
+
+  // Create a toolbar
+  m_navigationToolBar = new QToolBar ("", widget ());
+  m_navigationToolBar->setAllowedAreas (Qt::TopToolBarArea);
+  m_navigationToolBar->setMovable (false);
+  m_navigationToolBar->setIconSize (QSize (20, 20));
+
+  // Add a button to the toolbar with the QT standard icon for up-directory
+  // TODO: Maybe change this to be an up-directory icon that is OS specific???
+  QStyle *style = QApplication::style ();
+  m_directoryIcon = style->standardIcon (QStyle::SP_FileDialogToParent);
+  m_directoryUpAction = new QAction (m_directoryIcon, "", m_navigationToolBar);
+  m_directoryUpAction->setStatusTip (tr ("Move up one directory."));
+
+  m_currentDirectory = new QLineEdit (m_navigationToolBar);
+  m_currentDirectory->setStatusTip (tr ("Enter the path or filename."));
+
+  m_navigationToolBar->addAction (m_directoryUpAction);
+  m_navigationToolBar->addWidget (m_currentDirectory);
+  connect (m_directoryUpAction, SIGNAL (triggered ()), this,
+	   SLOT (onUpDirectory ()));
+
+  // TODO: Add other buttons for creating directories
+
+  // Create the QFileSystemModel starting in the home directory
+  QString
+    homePath = QDir::homePath ();
+  // TODO: This should occur after Octave has been initialized and the startup directory of Octave is established
+
+  m_fileSystemModel = new QFileSystemModel (this);
+  m_fileSystemModel->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
+  QModelIndex
+    rootPathIndex = m_fileSystemModel->setRootPath (homePath);
+
+  // Attach the model to the QTreeView and set the root index
+  m_fileTreeView = new QTreeView (widget ());
+  m_fileTreeView->setModel (m_fileSystemModel);
+  m_fileTreeView->setRootIndex (rootPathIndex);
+  m_fileTreeView->setSortingEnabled (true);
+  m_fileTreeView->setAlternatingRowColors (true);
+  m_fileTreeView->setAnimated (true);
+  m_fileTreeView->setColumnHidden (1, true);
+  m_fileTreeView->setColumnHidden (2, true);
+  m_fileTreeView->setColumnHidden (3, true);
+  m_fileTreeView->setStatusTip (tr ("Doubleclick a file to open it."));
+
+  setCurrentDirectory (m_fileSystemModel->fileInfo (rootPathIndex).
+		       absoluteFilePath ());
+
+  connect (m_fileTreeView, SIGNAL (doubleClicked (const QModelIndex &)), this,
+	   SLOT (itemDoubleClicked (const QModelIndex &)));
+
+  // Layout the widgets vertically with the toolbar on top
+  QVBoxLayout *
+    layout = new QVBoxLayout ();
+  layout->setSpacing (0);
+  layout->addWidget (m_navigationToolBar);
+  layout->addWidget (m_fileTreeView);
+  widget ()->setLayout (layout);
+  // TODO: Add right-click contextual menus for copying, pasting, deleting files (and others)
+
+  connect (m_currentDirectory, SIGNAL (returnPressed ()), this,
+	   SLOT (currentDirectoryEntered ()));
+  QCompleter *
+    completer = new QCompleter (m_fileSystemModel, this);
+  m_currentDirectory->setCompleter (completer);
+}
+
+void
+FilesDockWidget::itemDoubleClicked (const QModelIndex & index)
+{
+  // Retrieve the file info associated with the model index.
+  QFileInfo fileInfo = m_fileSystemModel->fileInfo (index);
+
+  // If it is a directory, cd into it.
+  if (fileInfo.isDir ())
+    {
+      m_fileSystemModel->setRootPath (fileInfo.absolutePath ());
+      m_fileTreeView->setRootIndex (index);
+      setCurrentDirectory (m_fileSystemModel->fileInfo (index).
+			   absoluteFilePath ());
+    }
+  // Otherwise attempt to open it.
+  else
+    {
+      // Check if the user wants to use a custom file editor.
+      QSettings *settings = ResourceManager::instance ()->settings ();
+      if (settings->value ("useCustomFileEditor").toBool ())
+        {
+          QString editor = settings->value ("customFileEditor").toString ();
+          QStringList arguments;
+          arguments << fileInfo.filePath ();
+          QProcess::execute (editor, arguments);
+        }
+      else
+        {
+          emit openFile (fileInfo.filePath ());
+        }
+    }
+}
+
+void
+FilesDockWidget::setCurrentDirectory (QString currentDirectory)
+{
+  m_currentDirectory->setText (currentDirectory);
+}
+
+void
+FilesDockWidget::onUpDirectory (void)
+{
+  QDir dir =
+    QDir (m_fileSystemModel->filePath (m_fileTreeView->rootIndex ()));
+  dir.cdUp ();
+  m_fileSystemModel->setRootPath (dir.absolutePath ());
+  m_fileTreeView->setRootIndex (m_fileSystemModel->
+				index (dir.absolutePath ()));
+  setCurrentDirectory (dir.absolutePath ());
+}
+
+void
+FilesDockWidget::currentDirectoryEntered ()
+{
+  QFileInfo fileInfo (m_currentDirectory->text ());
+  if (fileInfo.isDir ())
+    {
+      m_fileTreeView->setRootIndex (m_fileSystemModel->
+				    index (fileInfo.absolutePath ()));
+      m_fileSystemModel->setRootPath (fileInfo.absolutePath ());
+      setCurrentDirectory (fileInfo.absoluteFilePath ());
+    }
+  else
+    {
+      if (QFile::exists (fileInfo.absoluteFilePath ()))
+	emit openFile (fileInfo.absoluteFilePath ());
+    }
+}
+
+void
+FilesDockWidget::noticeSettings ()
+{
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  m_fileTreeView->setColumnHidden (0, !settings->value ("showFilenames").toBool ());
+  m_fileTreeView->setColumnHidden (1, !settings->value ("showFileSize").toBool ());
+  m_fileTreeView->setColumnHidden (2, !settings->value ("showFileType").toBool ());
+  m_fileTreeView->setColumnHidden (3, !settings->value ("showLastModified").toBool ());
+  m_fileTreeView->setAlternatingRowColors (settings->value ("useAlternatingRowColors").toBool ());
+  //if (settings.value ("showHiddenFiles").toBool ())
+  // TODO: React on option for hidden files.
+}
diff --git a/gui/src/FilesDockWidget.h b/gui/src/FilesDockWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/FilesDockWidget.h
@@ -0,0 +1,91 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 John P. Swensen, Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FILESDOCKWIDGET_H
+#define FILESDOCKWIDGET_H
+
+#include <QListView>
+#include <QDate>
+#include <QObject>
+#include <QWidget>
+#include <QListWidget>
+#include <QFileSystemModel>
+#include <QToolBar>
+#include <QToolButton>
+#include <QVBoxLayout>
+#include <QAction>
+#include <QTreeView>
+
+#include <vector>
+#include <string>
+
+#undef PACKAGE_BUGREPORT
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
+#include "octave/config.h"
+#include "octave/octave.h"
+#include "octave/str-vec.h"
+#include "octave/cmd-hist.h"
+#include <QDockWidget>
+#include <QLineEdit>
+
+class FilesDockWidget:public QDockWidget
+{
+  Q_OBJECT
+public:
+  FilesDockWidget (QWidget * parent = 0);
+
+public slots:
+  /** Slot for handling a change in directory via double click. */
+  void itemDoubleClicked (const QModelIndex & index);
+
+  /** Slot for handling the up-directory button in the toolbar. */
+  void onUpDirectory ();
+
+  void setCurrentDirectory (QString currentDirectory);
+
+  void currentDirectoryEntered ();
+
+  /** Tells the widget to notice settings that are probably new. */
+  void noticeSettings ();
+
+signals:
+  void openFile (QString fileName);
+
+private:
+  // TODO: Add toolbar with buttons for navigating the path, creating dirs, etc
+
+    /** Toolbar for file and directory manipulation. */
+    QToolBar * m_navigationToolBar;
+
+    /** Variables for the up-directory action. */
+  QIcon m_directoryIcon;
+  QAction *m_directoryUpAction;
+  QToolButton *upDirectoryButton;
+
+    /** The file system model. */
+  QFileSystemModel *m_fileSystemModel;
+
+    /** The file system view. */
+  QTreeView *m_fileTreeView;
+  QLineEdit *m_currentDirectory;
+};
+
+#endif // FILESDOCKWIDGET_H
diff --git a/gui/src/HistoryDockWidget.cpp b/gui/src/HistoryDockWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/HistoryDockWidget.cpp
@@ -0,0 +1,64 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "HistoryDockWidget.h"
+#include <QVBoxLayout>
+
+HistoryDockWidget::HistoryDockWidget (QWidget * parent):QDockWidget (parent)
+{
+  setObjectName ("HistoryDockWidget");
+  construct ();
+}
+
+void
+HistoryDockWidget::construct ()
+{
+  m_sortFilterProxyModel.setSourceModel(OctaveLink::instance ()->historyModel());
+  m_historyListView = new QListView (this);
+  m_historyListView->setModel (&m_sortFilterProxyModel);
+  m_historyListView->setAlternatingRowColors (true);
+  m_historyListView->setEditTriggers (QAbstractItemView::NoEditTriggers);
+  m_historyListView->setStatusTip (tr ("Doubleclick a command to transfer it to the terminal."));
+  m_filterLineEdit = new QLineEdit (this);
+  m_filterLineEdit->setStatusTip (tr ("Enter text to filter the command history."));
+  QVBoxLayout *layout = new QVBoxLayout ();
+
+  setWindowTitle (tr ("Command History"));
+  setWidget (new QWidget ());
+
+  layout->addWidget (m_historyListView);
+  layout->addWidget (m_filterLineEdit);
+  layout->setMargin (2);
+
+  widget ()->setLayout (layout);
+
+  connect (m_filterLineEdit, SIGNAL (textEdited (QString)), &m_sortFilterProxyModel, SLOT (setFilterWildcard(QString)));
+  connect (m_historyListView, SIGNAL (doubleClicked (QModelIndex)), this, SLOT (handleDoubleClick (QModelIndex)));
+}
+
+void
+HistoryDockWidget::noticeSettings ()
+{
+
+}
+
+void
+HistoryDockWidget::handleDoubleClick (QModelIndex modelIndex)
+{
+  emit commandDoubleClicked (modelIndex.data().toString());
+}
diff --git a/gui/src/HistoryDockWidget.h b/gui/src/HistoryDockWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/HistoryDockWidget.h
@@ -0,0 +1,53 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HISTORYDOCKWIDGET_H
+#define HISTORYDOCKWIDGET_H
+
+#include <QDockWidget>
+#include <QLineEdit>
+#include <QListView>
+#include <QSortFilterProxyModel>
+#include "OctaveLink.h"
+
+class HistoryDockWidget:public QDockWidget
+{
+Q_OBJECT
+public:
+  HistoryDockWidget (QWidget *parent = 0);
+  void updateHistory (QStringList history);
+
+public slots:
+  /** Tells the widget to notice settings that are probably new. */
+  void noticeSettings ();
+
+signals:
+  void information (QString message);
+  void commandDoubleClicked (QString command);
+
+private slots:
+  void handleDoubleClick (QModelIndex modelIndex);
+
+private:
+  void construct ();
+  QListView *m_historyListView;
+  QLineEdit *m_filterLineEdit;
+  QSortFilterProxyModel m_sortFilterProxyModel;
+};
+
+#endif // HISTORYDOCKWIDGET_H
diff --git a/gui/src/IRCWidget.cpp b/gui/src/IRCWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/IRCWidget.cpp
@@ -0,0 +1,350 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ResourceManager.h"
+#include "IRCWidget.h"
+#include <QMessageBox>
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+#include <QLabel>
+#include <QSettings>
+#include <QInputDialog>
+
+IRCWidget::IRCWidget (QWidget * parent):
+QWidget (parent)
+{
+  m_alternatingColor = false;
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  bool connectOnStartup = settings->value ("connectOnStartup").toBool ();
+  m_autoIdentification = settings->value ("autoIdentification").toBool ();
+  m_nickServPassword = settings->value ("nickServPassword").toString ();
+
+  m_initialNick = settings->value ("IRCNick").toString ();
+
+  if (m_initialNick.isEmpty ())
+    m_initialNick = "OctaveGUI-User";
+
+  QVBoxLayout *layout = new QVBoxLayout ();
+
+  m_chatWindow = new QTextEdit (this);
+  m_chatWindow->setReadOnly (true);
+  m_chatWindow->setEnabled (false);
+  QWidget *bottomWidget = new QWidget (this);
+
+  layout->addWidget (m_chatWindow);
+  layout->addWidget (bottomWidget);
+  setLayout (layout);
+
+  QHBoxLayout *bottomLayout = new QHBoxLayout ();
+  m_nickButton = new QPushButton (bottomWidget);
+  m_nickButton->
+    setStatusTip (tr ((char *) "Click here to change your nick."));
+  m_nickButton->setText (m_initialNick);
+  m_inputLine = new QLineEdit (bottomWidget);
+  m_inputLine->setStatusTip (tr ((char *) "Enter your message here."));
+  bottomLayout->addWidget (m_nickButton);
+  bottomLayout->addWidget (new QLabel (":", this));
+  bottomLayout->addWidget (m_inputLine);
+  bottomLayout->setMargin (0);
+  bottomWidget->setLayout (bottomLayout);
+  m_nickButton->setEnabled (false);
+  m_inputLine->setEnabled (false);
+
+  //m_chatWindow->setFocusProxy (m_inputLine);
+  this->setFocusProxy (m_inputLine);
+  m_nickButton->setFocusProxy (m_inputLine);
+
+  QFont font;
+  font.setFamily ("Courier");
+  font.setPointSize (11);
+  m_chatWindow->setFont (font);
+  m_ircClient = new IRCClient ();
+
+  connect (m_nickButton, SIGNAL (clicked ()), this, SLOT (nickPopup ()));
+  connect (m_inputLine, SIGNAL (returnPressed ()), this,
+	   SLOT (sendInputLine ()));
+
+  connect (m_ircClient, SIGNAL (nickInUseChanged ()), this,
+	   SLOT (handleNickInUseChanged ()));
+  connect (m_ircClient, SIGNAL (connectionStatus (const char *)), this,
+	   SLOT (showStatusMessage (const char *)));
+  connect (m_ircClient, SIGNAL (error (const char *)), this,
+	   SLOT (showStatusMessage (const char *)));
+  connect (m_ircClient, SIGNAL (completedLogin (const char *)), this,
+	   SLOT (loginSuccessful (const char *)));
+  connect (m_ircClient, SIGNAL (completedLogin (const char *)), this,
+	   SLOT (joinOctaveChannel (const char *)));
+  connect (m_ircClient,
+	   SIGNAL (topic (const char *, const char *, const char *)), this,
+	   SLOT (showTopic (const char *, const char *, const char *)));
+  connect (m_ircClient, SIGNAL (join (const char *, const char *)), this,
+	   SLOT (showJoin (const char *, const char *)));
+  connect (m_ircClient, SIGNAL (quit (const char *, const char *)), this,
+	   SLOT (showQuit (const char *, const char *)));
+  connect (m_ircClient,
+	   SIGNAL (privateMessage (const char *, const char *, const char *)),
+	   this,
+	   SLOT (showPrivateMessage
+		 (const char *, const char *, const char *)));
+  connect (m_ircClient,
+	   SIGNAL (notice (const char *, const char *, const char *)), this,
+	   SLOT (showNotice (const char *, const char *, const char *)));
+  connect (m_ircClient, SIGNAL (nick (const char *, const char *)), this,
+	   SLOT (showNickChange (const char *, const char *)));
+  connect (m_ircClient, SIGNAL (replyCode (IRCEvent *)), this,
+	   SLOT (handleReplyCode (IRCEvent *)));
+
+  if (connectOnStartup)
+    connectToServer ();
+}
+
+void
+IRCWidget::connectToServer ()
+{
+  m_ircClient->connectToServer ("irc.freenode.net", 6667,
+				m_initialNick.toStdString ().c_str (),
+				m_initialNick.toStdString ().c_str (),
+				"Unknown", "Unknown", 0, 0);
+}
+
+void
+IRCWidget::showStatusMessage (const char *message)
+{
+  m_chatWindow->append (QString ("<i>%1</i>").arg (message));
+}
+
+void
+IRCWidget::joinOctaveChannel (const char *)
+{
+  m_ircClient->joinChannel ("#octave");
+}
+
+void
+IRCWidget::loginSuccessful (const char *nick)
+{
+  m_chatWindow->
+    append (QString
+	    ("<i><font color=\"#00AA00\"><b>Successfully logged in as %1.</b></font></i>").
+	    arg (nick));
+  m_nickButton->setEnabled (true);
+  m_inputLine->setEnabled (true);
+  m_chatWindow->setEnabled (true);
+  m_inputLine->setFocus ();
+
+  if (m_autoIdentification)
+    m_ircClient->sendCommand (2, COMMAND_PRIVMSG,
+			      "NickServ",
+			      QString ("identify %1").
+			      arg (m_nickServPassword).toStdString ().
+			      c_str ());
+}
+
+void
+IRCWidget::showPrivateMessage (const char *nick, const char *destination,
+			       const char *message)
+{
+  Q_UNUSED (destination);
+  QString msg (message);
+  msg.replace ("<", "&lt;");
+  msg.replace (">", "&gt;");
+  if (msg.contains (m_ircClient->nickInUse ()))
+    {
+      msg =
+	QString ("<font color=\"#990000\"><b>%1:</b> %2</font>").arg (nick).
+	arg (msg);
+    }
+  else
+    {
+      msg =
+	QString ("<font color=\"%3\"><b>%1:</b> %2</font>").arg (nick).
+	arg (msg).arg (getAlternatingColor ());
+    }
+  m_chatWindow->append (msg);
+}
+
+void
+IRCWidget::showNotice (const char *nick, const char *destination,
+		       const char *message)
+{
+  Q_UNUSED (nick);
+  Q_UNUSED (destination);
+  m_chatWindow->append (QString ("<font color=\"#007700\">%1</font>").
+			arg (message));
+}
+
+void
+IRCWidget::showTopic (const char *nick, const char *channel,
+		      const char *message)
+{
+  QString msg (message);
+  msg.replace ("<", "&lt;");
+  msg.replace (">", "&gt;");
+  m_chatWindow->append (QString ("Topic for %2 was set by %1: %3").arg (nick).
+                        arg (channel).arg (msg));
+}
+
+void
+IRCWidget::showNickChange (const char *oldNick, const char *newNick)
+{
+  m_chatWindow->append (QString ("%1 is now known as %2.").arg (oldNick).
+			arg (newNick));
+  m_nickList.removeAll (QString (oldNick));
+  m_nickList.append (QString (newNick));
+  updateNickCompleter ();
+}
+
+void
+IRCWidget::nickPopup ()
+{
+  bool ok;
+  QString newNick =
+    QInputDialog::getText (this, QString ("Nickname"),
+			   QString ("Type in your nickname:"),
+			   QLineEdit::Normal, m_ircClient->nickInUse (), &ok);
+  if (ok)
+    {
+      m_ircClient->sendNickChange (newNick);
+    }
+}
+
+void
+IRCWidget::showJoin (const char *nick, const char *channel)
+{
+  m_chatWindow->append (QString ("<i>%1 has joined %2.</i>").arg (nick).
+			arg (channel));
+  m_nickList.append (QString (nick));
+  updateNickCompleter ();
+}
+
+void
+IRCWidget::showQuit (const char *nick, const char *reason)
+{
+  m_chatWindow->append (QString ("<i>%1 has quit.(%2).</i>").arg (nick).
+			arg (reason));
+  m_nickList.removeAll (QString (nick));
+  updateNickCompleter ();
+}
+
+void
+IRCWidget::sendMessage (QString message)
+{
+  // Do not send empty messages.
+  if (message.isEmpty ())
+    return;
+
+  // Remove trailing spaces.
+  while (message.at (0).isSpace ())
+    message.remove (0, 1);
+  if (message.startsWith ("/"))
+    {
+      QStringList line =
+	message.split (QRegExp ("\\s+"), QString::SkipEmptyParts);
+      if (line.at (0) == "/join")
+	{
+	  m_ircClient->joinChannel (line.at (1));
+	}
+      else if (line.at (0) == "/nick")
+	{
+	  m_ircClient->sendNickChange (line.at (1));
+	}
+      else if (line.at (0) == "/msg")
+	{
+	  QString recipient = line.at (1);
+	  // Since we splitted the message before, we have to glue it together again.
+	  QString pmsg = "";
+	  for (int i = 2; i < line.length (); i++)
+	    {
+	      pmsg += line.at (i);
+	      pmsg += " ";
+	    }
+	  m_ircClient->sendCommand (2, COMMAND_PRIVMSG,
+				    recipient.toStdString ().c_str (),
+				    pmsg.toStdString ().c_str ());
+	}
+    }
+  else
+    {
+      m_ircClient->sendPublicMessage (message);
+      message.replace ("<", "&lt;");
+      message.replace (">", "&gt;");
+      m_chatWindow->append (QString ("<b>%1:</b> %2").
+                            arg (m_ircClient->nickInUse ()).arg (message));
+    }
+}
+
+void
+IRCWidget::sendInputLine ()
+{
+  sendMessage (m_inputLine->text ());
+  m_inputLine->setText ("");
+}
+
+void
+IRCWidget::handleNickInUseChanged ()
+{
+  m_nickButton->setText (m_ircClient->nickInUse ());
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  settings->setValue ("IRCNick", m_ircClient->nickInUse ());
+}
+
+void
+IRCWidget::handleReplyCode (IRCEvent * event)
+{
+  QSettings *settings = ResourceManager::instance ()->settings ();
+
+  switch (event->getNumeric ())
+    {
+    case RPL_MOTDSTART:
+    case RPL_MOTD:
+    case ERR_NOMOTD:
+    case RPL_ENDOFMOTD:
+      if (settings->value ("showMessageOfTheDay").toBool ())
+	m_chatWindow->append (QString ("<font color=\"#777777\">%1</font>").
+			      arg (event->getParam (1)));
+      break;
+    case RPL_NOTOPIC:
+    case RPL_TOPIC:
+      if (settings->value ("showTopic").toBool ())
+	m_chatWindow->
+	  append (QString ("<font color=\"#000088\"><b>%1</b></font>").
+		  arg (event->getParam (2)));
+      break;
+    case RPL_NAMREPLY:
+      m_chatWindow->
+	append (QString ("<font color=\"#000088\">Users online: %1</font>").
+		arg (event->getParam (3)));
+      m_nickList =
+	event->getParam (3).split (QRegExp ("\\s+"), QString::SkipEmptyParts);
+      updateNickCompleter ();
+      break;
+    case ERR_NICKNAMEINUSE:
+    case ERR_NICKCOLLISION:
+      m_chatWindow->
+	append (QString ("<font color=\"#AA0000\">Nickname in use.</font>"));
+      break;
+    };
+}
+
+
+void
+IRCWidget::updateNickCompleter ()
+{
+  QCompleter *completer = new QCompleter (m_nickList, this);
+  completer->setCompletionMode (QCompleter::InlineCompletion);
+  m_inputLine->setCompleter (completer);
+}
diff --git a/gui/src/IRCWidget.h b/gui/src/IRCWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/IRCWidget.h
@@ -0,0 +1,74 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef IRCWIDGET_H
+#define IRCWIDGET_H
+
+#include <QWidget>
+#include <QTextEdit>
+#include <QPushButton>
+#include <QLineEdit>
+#include <QCompleter>
+#include "IRCClient.h"
+
+class IRCWidget:public QWidget
+{
+Q_OBJECT public:
+  explicit IRCWidget (QWidget * parent);
+  void connectToServer ();
+
+    signals:public slots:void showStatusMessage (const char *);
+  void joinOctaveChannel (const char *);
+  void loginSuccessful (const char *);
+  void showPrivateMessage (const char *, const char *, const char *);
+  void showNotice (const char *, const char *, const char *);
+  void showTopic (const char *, const char *, const char *);
+  void showJoin (const char *, const char *);
+  void showQuit (const char *, const char *);
+  void showNickChange (const char *, const char *);
+  void nickPopup ();
+  void sendMessage (QString);
+  void sendInputLine ();
+
+  void handleNickInUseChanged ();
+  void handleReplyCode (IRCEvent * event);
+
+  void updateNickCompleter ();
+private:
+  IRCClient * m_ircClient;
+  QTextEdit *m_chatWindow;
+  QPushButton *m_nickButton;
+  QLineEdit *m_inputLine;
+  bool m_alternatingColor;
+
+  QString getAlternatingColor ()
+  {
+    m_alternatingColor = !m_alternatingColor;
+    if (m_alternatingColor)
+      return "#000077";
+    return "#005533";
+  }
+
+  QString m_initialNick;
+  bool m_autoIdentification;
+  QString m_nickServPassword;
+  QString m_settingsFile;
+  QStringList m_nickList;
+};
+
+#endif // IRCWIDGET_H
diff --git a/gui/src/ImageViewerMdiSubWindow.cpp b/gui/src/ImageViewerMdiSubWindow.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/ImageViewerMdiSubWindow.cpp
@@ -0,0 +1,44 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ImageViewerMdiSubWindow.h"
+#include <QLabel>
+#include <QPixmap>
+#include <QScrollArea>
+
+ImageViewerMdiSubWindow::ImageViewerMdiSubWindow (QPixmap pixmap, QWidget * parent):QMdiSubWindow (parent),
+m_pixmap
+(pixmap)
+{
+  construct ();
+}
+
+void
+ImageViewerMdiSubWindow::construct ()
+{
+  QLabel *label = new QLabel ();
+  label->setBackgroundRole (QPalette::Base);
+  label->setSizePolicy (QSizePolicy::Ignored, QSizePolicy::Ignored);
+  label->setScaledContents (true);
+  label->setPixmap (m_pixmap);
+
+  QScrollArea *scrollArea = new QScrollArea (this);
+  scrollArea->setBackgroundRole (QPalette::Dark);
+  scrollArea->setWidget (label);
+  setWidget (scrollArea);
+}
diff --git a/gui/src/ImageViewerMdiSubWindow.h b/gui/src/ImageViewerMdiSubWindow.h
new file mode 100644
--- /dev/null
+++ b/gui/src/ImageViewerMdiSubWindow.h
@@ -0,0 +1,34 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef IMAGEVIEWERMDISUBWINDOW_H
+#define IMAGEVIEWERMDISUBWINDOW_H
+
+#include <QMdiSubWindow>
+
+class ImageViewerMdiSubWindow:public QMdiSubWindow
+{
+public:
+  ImageViewerMdiSubWindow (QPixmap pixmap, QWidget * parent = 0);
+
+private:
+  void construct ();
+  QPixmap m_pixmap;
+};
+
+#endif // IMAGEVIEWERMDISUBWINDOW_H
diff --git a/gui/src/MainWindow.cpp b/gui/src/MainWindow.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/MainWindow.cpp
@@ -0,0 +1,384 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QMenuBar>
+#include <QMenu>
+#include <QAction>
+#include <QSettings>
+#include <QDesktopServices>
+#include <QFileDialog>
+#include "MainWindow.h"
+#include "FileEditorMdiSubWindow.h"
+#include "ImageViewerMdiSubWindow.h"
+#include "SettingsDialog.h"
+#include "cmd-edit.h"
+
+#define VERSION_STRING "Octave GUI (0.6.9)"
+
+MainWindow::MainWindow (QWidget * parent):QMainWindow (parent)
+{
+  construct ();
+  OctaveLink::instance ()->launchOctave();
+}
+
+MainWindow::~MainWindow ()
+{
+}
+
+void
+MainWindow::handleOpenFileRequest (QString fileName)
+{
+  reportStatusMessage (tr ("Opening file."));
+  QPixmap pixmap;
+  if (pixmap.load (fileName))
+    {
+//        ImageViewerMdiSubWindow *subWindow = new ImageViewerMdiSubWindow(pixmap, this);
+//        subWindow->setAttribute(Qt::WA_DeleteOnClose);
+//        m_centralMdiArea->addSubWindow(subWindow);
+//        subWindow->setWindowTitle(fileName);
+    }
+  else
+    {
+      openEditorFile(fileName);
+    }
+}
+
+void
+MainWindow::openEditor ()
+{
+  openEditorFile(QString());
+}
+void
+MainWindow::openEditorFile (QString fileName)
+{
+  FileEditorMdiSubWindow *subWindow = new FileEditorMdiSubWindow (m_centralMdiArea);
+  subWindow->setAttribute (Qt::WA_DeleteOnClose);
+  // check whether lexer is already prepared and prepare it if not
+  if ( m_lexer == NULL )
+    {
+      // this has to be done only once, not for each editor
+      m_lexer = new LexerOctaveGui();
+      m_lexer->setDefaultFont(QFont("Monospace",10));
+      // TODO: Autoindent not working as it should
+      m_lexer->setAutoIndentStyle(QsciScintilla::AiMaintain ||
+                                  QsciScintilla::AiOpening  ||
+                                  QsciScintilla::AiClosing);
+      // The API info that is used for auto completion
+      // TODO: Where to store a file with API info (raw or prepared?)?
+      // TODO: Also provide infos on octave-forge functions?
+      // TODO: Also provide infos on function parameters?
+      // By now, use the keywords-list from syntax highlighting
+       m_lexerAPI = new QsciAPIs(m_lexer);
+       QString keyword;
+       QStringList keywordList;
+       keyword     = m_lexer->keywords(1);  // get whole string with all keywords
+       keywordList = keyword.split(QRegExp("\\s+"));  // split into single strings
+       int i;
+       for ( i=0; i<keywordList.size(); i++ )
+         {
+           m_lexerAPI->add(keywordList.at(i));  // add single strings to the API
+         }
+       m_lexerAPI->prepare();           // prepare API info ... this make take some time
+    }
+  subWindow->setEditorLexer(m_lexer);   // set the already prepared lexer
+
+  if ( fileName.isEmpty() )
+    subWindow->newFile ();
+  else
+    subWindow->loadFile (fileName);
+}
+
+
+void
+MainWindow::reportStatusMessage (QString statusMessage)
+{
+  m_statusBar->showMessage (statusMessage, 1000);
+}
+
+void
+MainWindow::openWebPage (QString url)
+{
+  m_documentationWidget->load (QUrl (url));
+}
+
+void
+MainWindow::handleSaveWorkspaceRequest ()
+{
+  QString selectedFile =
+    QFileDialog::getSaveFileName (this, tr ("Save Workspace"),
+                                  ResourceManager::instance ()->homePath ());
+  m_octaveTerminal->sendText (QString ("save \'%1\'\n").arg (selectedFile));
+  m_octaveTerminal->setFocus ();
+}
+
+void
+MainWindow::handleLoadWorkspaceRequest ()
+{
+  QString selectedFile =
+    QFileDialog::getOpenFileName (this, tr ("Load Workspace"),
+                                  ResourceManager::instance ()->homePath ());
+  m_octaveTerminal->sendText (QString ("load \'%1\'\n").arg (selectedFile));
+  m_octaveTerminal->setFocus ();
+}
+
+void
+MainWindow::handleClearWorkspaceRequest ()
+{
+  m_octaveTerminal->sendText ("clear\n");
+  m_octaveTerminal->setFocus ();
+}
+
+void
+MainWindow::handleCommandDoubleClicked (QString command)
+{
+  m_octaveTerminal->sendText (command);
+  m_octaveTerminal->setFocus ();
+}
+
+void
+MainWindow::alignMdiWindows ()
+{
+  m_centralMdiArea->tileSubWindows ();
+}
+
+void
+MainWindow::openBugTrackerPage ()
+{
+  QDesktopServices::openUrl (QUrl ("http://savannah.gnu.org/bugs/?group=octave"));
+}
+
+void
+MainWindow::openAgoraPage ()
+{
+  QDesktopServices::openUrl (QUrl ("http://agora.panocha.org.mx/"));
+}
+
+void
+MainWindow::openOctaveForgePage ()
+{
+  QDesktopServices::openUrl (QUrl ("http://octave.sourceforge.net/"));
+}
+
+void
+MainWindow::processSettingsDialogRequest ()
+{
+  SettingsDialog settingsDialog (this);
+  settingsDialog.exec ();
+  emit settingsChanged ();
+}
+
+void
+MainWindow::showAboutOctave ()
+{
+  QString message =
+      "GNU Octave\n"
+      "Copyright (C) 2009 John W. Eaton and others.\n"
+      "This is free software; see the source code for copying conditions."
+      "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or"
+      "FITNESS FOR A PARTICULAR PURPOSE.  For details, type `warranty'.\n"
+      "\n"
+      "Octave was configured for \"x86_64-pc-linux-gnu\".\n"
+      "\n"
+      "Additional information about Octave is available at http://www.octave.org.\n"
+      "\n"
+      "Please contribute if you find this software useful."
+      "For more information, visit http://www.octave.org/help-wanted.html\n"
+      "\n"
+      "Report bugs to <bug@octave.org> (but first, please read"
+      "http://www.octave.org/bugs.html to learn how to write a helpful report).\n"
+      "\n"
+      "For information about changes from previous versions, type `news'.\n";
+
+  QMessageBox::about (this, tr ("About Octave"), message);
+}
+
+void
+MainWindow::showAboutQt ()
+{
+  QMessageBox::aboutQt (this);
+}
+
+void
+MainWindow::closeEvent (QCloseEvent * closeEvent)
+{
+  reportStatusMessage (tr ("Saving data and shutting down."));
+  writeSettings ();
+
+  OctaveLink::instance ()->terminateOctave();
+  QMainWindow::closeEvent (closeEvent);
+}
+
+void
+MainWindow::readSettings ()
+{
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
+  restoreState (settings->value ("MainWindow/windowState").toByteArray ());
+  m_centralMdiArea->restoreGeometry (settings->value ("MdiArea/geometry").toByteArray ());
+  emit settingsChanged ();
+}
+
+void
+MainWindow::writeSettings ()
+{
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  settings->setValue ("MainWindow/geometry", saveGeometry ());
+  settings->setValue ("MainWindow/windowState", saveState ());
+  settings->setValue ("MdiArea/geometry", m_centralMdiArea->saveGeometry ());
+}
+
+void
+MainWindow::construct ()
+{
+
+  if (QFile::exists ("../media/logo.png"))
+    setWindowIcon (QIcon ("../media/logo.png"));
+  else
+    setWindowIcon (QIcon ("/usr/share/octave/quint/media/logo.png"));
+
+  // Initialize MDI area.
+  m_centralMdiArea = new QMdiArea (this);
+  m_centralMdiArea->setObjectName ("CentralMdiArea");
+  m_centralMdiArea->setViewMode (QMdiArea::TabbedView);
+
+  // Setup dockable widgets and the status bar.
+  m_variablesDockWidget = new VariablesDockWidget (this);
+  m_variablesDockWidget->setStatusTip (tr ("View the variables in the active workspace."));
+  m_historyDockWidget = new HistoryDockWidget (this);
+  m_historyDockWidget->setStatusTip (tr ("Browse and search the command history."));
+  m_filesDockWidget = new FilesDockWidget (this);
+  m_filesDockWidget->setStatusTip (tr ("Browse your files."));
+  m_statusBar = new QStatusBar (this);
+
+  // Setup essential MDI Windows.
+  m_octaveTerminal = new OctaveTerminal (this);
+  m_documentationWidget = new BrowserWidget (this);
+  m_ircWidget = new IRCWidget (this);
+
+  m_octaveTerminal->openTerminal ();
+
+  // Octave Terminal subwindow.
+  m_octaveTerminalSubWindow =
+    m_centralMdiArea->addSubWindow (m_octaveTerminal,
+				    Qt::WindowTitleHint | Qt::
+				    WindowMinMaxButtonsHint);
+  m_octaveTerminalSubWindow->setObjectName ("OctaveTerminalSubWindow");
+  m_octaveTerminalSubWindow->setWindowTitle (tr ("Terminal"));
+  m_octaveTerminalSubWindow->setWindowIcon (QIcon ("../media/terminal.png"));
+  m_octaveTerminalSubWindow->setStatusTip (tr ("Enter your commands into the Octave terminal."));
+
+  // Documentation subwindow.
+  m_documentationWidgetSubWindow =
+    m_centralMdiArea->addSubWindow (m_documentationWidget,
+                                    Qt::WindowTitleHint | Qt::
+                                    WindowMinMaxButtonsHint);
+  m_documentationWidgetSubWindow->setObjectName ("DocumentationWidgetSubWindow");
+  m_documentationWidgetSubWindow->setWindowTitle (tr ("Documentation"));
+  m_documentationWidgetSubWindow->setWindowIcon (QIcon ("../media/help_index.png"));
+  m_documentationWidgetSubWindow->setStatusTip (tr ("Browse the Octave documentation for help."));
+
+  // Chat subwindow.
+  m_ircWidgetSubWindow = m_centralMdiArea->addSubWindow (m_ircWidget,
+                                                         Qt::
+                                                         WindowTitleHint |
+                                                         Qt::
+                                                         WindowMinMaxButtonsHint);
+  m_ircWidgetSubWindow->setObjectName ("ChatWidgetSubWindow");
+  m_ircWidgetSubWindow->setWindowTitle (tr ("Chat"));
+  m_ircWidgetSubWindow->setWindowIcon (QIcon ("../media/chat.png"));
+  m_ircWidgetSubWindow->setStatusTip(tr ("Instantly chat with other Octave users for help."));
+
+  m_lexer = NULL;  // initialise the empty lexer for the edtiors
+
+  QMenu *controlMenu = menuBar ()->addMenu (tr ("Octave"));
+  QAction *settingsAction = controlMenu->addAction (tr ("Settings"));
+  controlMenu->addSeparator ();
+  QAction *exitAction = controlMenu->addAction (tr ("Exit"));
+
+  QMenu *interfaceMenu = menuBar ()->addMenu (tr ("Interface"));
+
+  QAction *alignWindowsAction = interfaceMenu->addAction (tr ("Align Windows"));
+  interfaceMenu->addSeparator ();
+  QAction *showWorkspaceAction = interfaceMenu->addAction (tr ("Workspace"));
+  showWorkspaceAction->setCheckable (true);
+
+  QAction *showHistoryAction = interfaceMenu->addAction (tr ("History"));
+  showHistoryAction->setCheckable (true);
+
+  QAction *showFileBrowserAction = interfaceMenu->addAction (tr ("File Browser"));
+  showFileBrowserAction->setCheckable (true);
+
+  interfaceMenu->addSeparator ();
+  QAction *openEditorAction = interfaceMenu->addAction (tr ("Open New Editor Window"));
+
+  QMenu *workspaceMenu = menuBar ()->addMenu (tr ("Workspace"));
+  QAction *loadWorkspaceAction = workspaceMenu->addAction (tr ("Load"));
+  QAction *saveWorkspaceAction = workspaceMenu->addAction (tr ("Save"));
+  workspaceMenu->addSeparator ();
+  QAction *clearWorkspaceAction = workspaceMenu->addAction (tr ("Clear"));
+
+  QMenu *communityMenu = menuBar ()->addMenu (tr ("Community"));
+  QAction *reportBugAction = communityMenu->addAction (tr ("Report Bug"));
+  QAction *agoraAction = communityMenu->addAction (tr ("Agora"));
+  QAction *octaveForgeAction = communityMenu->addAction (tr ("Octave Forge"));
+  communityMenu->addSeparator ();
+  QAction *aboutOctaveAction = communityMenu->addAction (tr ("About Octave"));
+  QAction *aboutQt = communityMenu->addAction (tr ("About Qt"));
+
+  connect (settingsAction, SIGNAL (triggered ()), this, SLOT (processSettingsDialogRequest ()));
+  connect (exitAction, SIGNAL (triggered ()), this, SLOT (close ()));
+  connect (alignWindowsAction, SIGNAL (triggered ()), this, SLOT (alignMdiWindows ()));
+  connect (openEditorAction, SIGNAL (triggered ()), this, SLOT (openEditor ()));
+  connect (reportBugAction, SIGNAL (triggered ()), this, SLOT (openBugTrackerPage ()));
+  connect (agoraAction, SIGNAL (triggered ()), this, SLOT (openAgoraPage ()));
+  connect (octaveForgeAction, SIGNAL (triggered ()), this, SLOT (openOctaveForgePage ()));
+  connect (aboutOctaveAction, SIGNAL (triggered ()), this, SLOT (showAboutOctave ()));
+  connect (aboutQt, SIGNAL (triggered ()), this, SLOT (showAboutQt ()));
+
+  // TODO: Visibility cannot be taken as a signal, because it will be emitted even then
+  // the dock widget is tabbed or minimized.
+  connect (showWorkspaceAction, SIGNAL (toggled (bool)), m_variablesDockWidget, SLOT (setShown (bool)));
+  //connect (m_variablesDockWidget, SIGNAL (visibilityChanged (bool)), showWorkspaceAction, SLOT (setChecked (bool)));
+  connect (showHistoryAction, SIGNAL (toggled (bool)), m_historyDockWidget, SLOT (setShown (bool)));
+  //connect (m_historyDockWidget, SIGNAL (visibilityChanged (bool)), showHistoryAction, SLOT (setChecked (bool)));
+  connect (showFileBrowserAction, SIGNAL (toggled (bool)), m_filesDockWidget, SLOT (setShown (bool)));
+  //connect (m_filesDockWidget, SIGNAL (visibilityChanged (bool)), showFileBrowserAction, SLOT (setChecked (bool)));
+
+  connect (this, SIGNAL (settingsChanged ()), m_variablesDockWidget, SLOT (noticeSettings ()));
+  connect (this, SIGNAL (settingsChanged ()), m_historyDockWidget, SLOT (noticeSettings ()));
+  connect (this, SIGNAL (settingsChanged ()), m_filesDockWidget, SLOT (noticeSettings ()));
+
+  connect (m_filesDockWidget, SIGNAL (openFile (QString)), this, SLOT (handleOpenFileRequest (QString)));
+  connect (m_historyDockWidget, SIGNAL (information (QString)), this, SLOT (reportStatusMessage (QString)));
+  connect (m_historyDockWidget, SIGNAL (commandDoubleClicked (QString)), this, SLOT (handleCommandDoubleClicked (QString)));
+  connect (saveWorkspaceAction, SIGNAL (triggered ()), this, SLOT (handleSaveWorkspaceRequest ()));
+  connect (loadWorkspaceAction, SIGNAL (triggered ()), this, SLOT (handleLoadWorkspaceRequest ()));
+  connect (clearWorkspaceAction, SIGNAL (triggered ()), this, SLOT (handleClearWorkspaceRequest ()));
+
+  setWindowTitle (QString (VERSION_STRING));
+
+  setCentralWidget (m_centralMdiArea);
+  addDockWidget (Qt::LeftDockWidgetArea, m_variablesDockWidget);
+  addDockWidget (Qt::LeftDockWidgetArea, m_historyDockWidget);
+  addDockWidget (Qt::RightDockWidgetArea, m_filesDockWidget);
+  setStatusBar (m_statusBar);
+
+  readSettings ();
+  openWebPage ("http://www.gnu.org/software/octave/doc/interpreter/");
+}
+
diff --git a/gui/src/MainWindow.h b/gui/src/MainWindow.h
new file mode 100644
--- /dev/null
+++ b/gui/src/MainWindow.h
@@ -0,0 +1,120 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MAINWINDOW_H
+#define MAINWINDOW_H
+
+#include <QtGui/QMainWindow>
+#include <QThread>
+#include <QTabWidget>
+#include <QMdiArea>
+#include <QStatusBar>
+#include <QToolBar>
+#include <QQueue>
+#include <Qsci/qsciapis.h>
+#include "ResourceManager.h"
+#include "OctaveTerminal.h"
+#include "OctaveLink.h"
+#include "VariablesDockWidget.h"
+#include "HistoryDockWidget.h"
+#include "FilesDockWidget.h"
+#include "BrowserWidget.h"
+#include "IRCWidget.h"
+#include "lexer/lexeroctavegui.h"
+
+/**
+  * \class MainWindow
+  *
+  * Represents the main window.
+  */
+class MainWindow:public QMainWindow
+{
+Q_OBJECT public:
+  MainWindow (QWidget * parent = 0);
+  ~MainWindow ();
+
+  OctaveTerminal *octaveTerminal ()
+  {
+    return m_octaveTerminal;
+  }
+  VariablesDockWidget *variablesDockWidget ()
+  {
+    return m_variablesDockWidget;
+  }
+  HistoryDockWidget *historyDockWidget ()
+  {
+    return m_historyDockWidget;
+  }
+  FilesDockWidget *filesDockWidget ()
+  {
+    return m_filesDockWidget;
+  }
+signals:
+  void settingsChanged ();
+
+public slots:
+  void handleOpenFileRequest (QString fileName);
+  void reportStatusMessage (QString statusMessage);
+  void openWebPage (QString url);
+  void handleSaveWorkspaceRequest ();
+  void handleLoadWorkspaceRequest ();
+  void handleClearWorkspaceRequest ();
+  void handleCommandDoubleClicked (QString command);
+  void alignMdiWindows ();
+  void openEditor ();
+  void openEditorFile (QString fileName);
+  void openBugTrackerPage ();
+  void openAgoraPage ();
+  void openOctaveForgePage ();
+  void processSettingsDialogRequest ();
+  void showAboutOctave ();
+  void showAboutQt ();
+
+protected:
+  void closeEvent (QCloseEvent * closeEvent);
+  void readSettings ();
+  void writeSettings ();
+
+private:
+  void construct ();
+  void establishOctaveLink ();
+  QMdiArea *m_centralMdiArea;
+
+  // Mdi sub windows.
+  OctaveTerminal *m_octaveTerminal;
+  BrowserWidget *m_documentationWidget;
+  IRCWidget *m_ircWidget;
+
+  QMdiSubWindow *m_octaveTerminalSubWindow;
+  QMdiSubWindow *m_documentationWidgetSubWindow;
+  QMdiSubWindow *m_ircWidgetSubWindow;
+
+  // Dock widgets.
+  VariablesDockWidget *m_variablesDockWidget;
+  HistoryDockWidget *m_historyDockWidget;
+  FilesDockWidget *m_filesDockWidget;
+
+  // Editor's lexer
+  LexerOctaveGui *m_lexer;
+  QsciAPIs *m_lexerAPI;
+
+  // Toolbars.
+  QStatusBar *m_statusBar;
+};
+
+#endif // MAINWINDOW_H
diff --git a/gui/src/OctaveGUI.cpp b/gui/src/OctaveGUI.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/OctaveGUI.cpp
@@ -0,0 +1,45 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QtGui/QApplication>
+#include <QTranslator>
+#include <QSettings>
+#include "CommandLineParser.h"
+#include "ResourceManager.h"
+#include "MainWindow.h"
+
+int
+main (int argc, char *argv[])
+{
+  QApplication application (argc, argv);
+  CommandLineParser commandLineParser;
+  commandLineParser.registerOption ("--config", "-c", "Tells OctaveGUI to use that configuration file.", true);
+  commandLineParser.parse (argc, argv);
+
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  QString language = settings->value ("language").toString ();
+
+  QString translatorFile = ResourceManager::instance ()->findTranslatorFile (language);
+  QTranslator translator;
+  translator.load (translatorFile);
+  application.installTranslator (&translator);
+
+  MainWindow w;
+  w.show ();
+  return application.exec ();
+}
diff --git a/gui/src/OctaveTerminal.cpp b/gui/src/OctaveTerminal.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/OctaveTerminal.cpp
@@ -0,0 +1,63 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "OctaveTerminal.h"
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+#include <QStringListModel>
+#include <QStringList>
+
+#include "pty.h"
+#include "unistd.h"
+#include <assert.h>
+
+OctaveTerminal::OctaveTerminal (QWidget * parent):QWidget (parent)
+{
+  construct ();
+}
+
+OctaveTerminal::~OctaveTerminal ()
+{
+}
+
+void
+OctaveTerminal::construct ()
+{
+  m_terminalWidget = new QTerminalWidget (0, this);
+  m_terminalWidget->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);
+  setFocusProxy (m_terminalWidget);
+
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_terminalWidget);
+  setLayout (layout);
+}
+
+void
+OctaveTerminal::openTerminal ()
+{
+  int fdm, fds;
+  if (openpty (&fdm, &fds, 0, 0, 0) < 0)
+    {
+      assert (0);
+    }
+  dup2 (fds, 0);
+  dup2 (fds, 1);
+  dup2 (fds, 2);
+
+  m_terminalWidget->openTeletype (fdm);
+}
diff --git a/gui/src/OctaveTerminal.h b/gui/src/OctaveTerminal.h
new file mode 100644
--- /dev/null
+++ b/gui/src/OctaveTerminal.h
@@ -0,0 +1,37 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef OCTAVETERMINAL_H
+#define OCTAVETERMINAL_H
+#include <QWidget>
+#include "QTerminalWidget.h"
+
+class OctaveTerminal:public QWidget
+{
+Q_OBJECT
+public:
+  OctaveTerminal (QWidget * parent = 0);
+  ~OctaveTerminal ();
+
+  void sendText (QString text) { m_terminalWidget->sendText(text); }
+  void openTerminal ();
+private:
+  void construct ();
+  QTerminalWidget *m_terminalWidget;
+};
+#endif // OCTAVETERMINAL_H
diff --git a/gui/src/ResourceManager.cpp b/gui/src/ResourceManager.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/ResourceManager.cpp
@@ -0,0 +1,60 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ResourceManager.h"
+
+ResourceManager ResourceManager::m_singleton;
+
+ResourceManager::ResourceManager ()
+{
+  m_settings = 0;
+  QDesktopServices desktopServices;
+  m_homePath = desktopServices.storageLocation (QDesktopServices::HomeLocation);
+  setSettings(m_homePath + "/.octave-gui");
+}
+
+ResourceManager::~ResourceManager ()
+{
+  delete m_settings;
+}
+
+QSettings *
+ResourceManager::settings ()
+{
+  return m_settings;
+}
+
+QString
+ResourceManager::homePath ()
+{
+  return m_homePath;
+}
+
+void
+ResourceManager::setSettings (QString file)
+{
+  delete m_settings;
+  m_settings = new QSettings (file, QSettings::IniFormat);
+}
+
+QString
+ResourceManager::findTranslatorFile (QString language)
+{
+  // TODO: Quick hack to be able to test language files.
+  return QString("../languages/%1.qm").arg(language);
+}
diff --git a/gui/src/ResourceManager.h b/gui/src/ResourceManager.h
new file mode 100644
--- /dev/null
+++ b/gui/src/ResourceManager.h
@@ -0,0 +1,48 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef RESOURCEMANAGER_H
+#define RESOURCEMANAGER_H
+
+#include <QSettings>
+#include <QDesktopServices>
+
+class ResourceManager
+{
+public:
+  ~ResourceManager ();
+
+  static ResourceManager *
+  instance ()
+  {
+    return &m_singleton;
+  }
+
+  QSettings *settings ();
+  QString homePath ();
+  void setSettings (QString file);
+  QString findTranslatorFile (QString language);
+private:
+  ResourceManager ();
+
+  QSettings *m_settings;
+  QString m_homePath;
+  static ResourceManager m_singleton;
+};
+
+#endif // RESOURCEMANAGER_H
diff --git a/gui/src/SettingsDialog.cpp b/gui/src/SettingsDialog.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/SettingsDialog.cpp
@@ -0,0 +1,44 @@
+#include "ResourceManager.h"
+#include "SettingsDialog.h"
+#include "ui_SettingsDialog.h"
+#include <QSettings>
+
+SettingsDialog::SettingsDialog (QWidget * parent):
+QDialog (parent), ui (new Ui::SettingsDialog)
+{
+  ui->setupUi (this);
+
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  ui->connectOnStartup->setChecked (settings->value ("connectOnStartup").toBool ());
+  ui->showMessageOfTheDay->setChecked (settings->value ("showMessageOfTheDay").toBool ());
+  ui->showTopic->setChecked (settings->value ("showTopic").toBool ());
+  ui->autoIdentification->setChecked (settings->value ("autoIdentification").toBool ());
+  ui->nickServPassword->setText (settings->value ("nickServPassword").toString ());
+  ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor").toBool ());
+  ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
+  ui->showFilenames->setChecked (settings->value ("showFilenames").toBool());
+  ui->showFileSize->setChecked (settings->value ("showFileSize").toBool());
+  ui->showFileType->setChecked (settings->value ("showFileType").toBool());
+  ui->showLastModified->setChecked (settings->value ("showLastModified").toBool());
+  ui->showHiddenFiles->setChecked (settings->value ("showHiddenFiles").toBool());
+  ui->useAlternatingRowColors->setChecked (settings->value ("useAlternatingRowColors").toBool());
+}
+
+SettingsDialog::~SettingsDialog ()
+{
+  QSettings *settings = ResourceManager::instance ()->settings ();
+  settings->setValue ("connectOnStartup", ui->connectOnStartup->isChecked ());
+  settings->setValue ("showMessageOfTheDay", ui->showMessageOfTheDay->isChecked ());
+  settings->setValue ("showTopic", ui->showTopic->isChecked ());
+  settings->setValue ("autoIdentification", ui->autoIdentification->isChecked ());
+  settings->setValue ("nickServPassword", ui->nickServPassword->text ());
+  settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
+  settings->setValue ("customFileEditor", ui->customFileEditor->text ());
+  settings->setValue ("showFilenames", ui->showFilenames->isChecked ());
+  settings->setValue ("showFileSize", ui->showFileSize->isChecked ());
+  settings->setValue ("showFileType", ui->showFileType->isChecked ());
+  settings->setValue ("showLastModified", ui->showLastModified->isChecked ());
+  settings->setValue ("showHiddenFiles", ui->showHiddenFiles->isChecked ());
+  settings->setValue ("useAlternatingRowColors", ui->useAlternatingRowColors->isChecked ());
+  delete ui;
+}
diff --git a/gui/src/SettingsDialog.h b/gui/src/SettingsDialog.h
new file mode 100644
--- /dev/null
+++ b/gui/src/SettingsDialog.h
@@ -0,0 +1,21 @@
+#ifndef SETTINGSDIALOG_H
+#define SETTINGSDIALOG_H
+
+#include <QDialog>
+
+namespace Ui
+{
+  class SettingsDialog;
+}
+
+class SettingsDialog:public QDialog
+{
+Q_OBJECT public:
+  explicit SettingsDialog (QWidget * parent);
+  ~SettingsDialog ();
+
+private:
+  Ui::SettingsDialog * ui;
+};
+
+#endif // SETTINGSDIALOG_H
diff --git a/gui/src/SettingsDialog.ui b/gui/src/SettingsDialog.ui
new file mode 100644
--- /dev/null
+++ b/gui/src/SettingsDialog.ui
@@ -0,0 +1,299 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>SettingsDialog</class>
+ <widget class="QDialog" name="SettingsDialog">
+  <property name="windowModality">
+   <enum>Qt::ApplicationModal</enum>
+  </property>
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>500</width>
+    <height>300</height>
+   </rect>
+  </property>
+  <property name="minimumSize">
+   <size>
+    <width>500</width>
+    <height>300</height>
+   </size>
+  </property>
+  <property name="maximumSize">
+   <size>
+    <width>500</width>
+    <height>300</height>
+   </size>
+  </property>
+  <property name="windowTitle">
+   <string>Settings</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_2">
+   <item>
+    <widget class="QTabWidget" name="tabWidget">
+     <property name="currentIndex">
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="chatTab">
+      <attribute name="title">
+       <string>Chat</string>
+      </attribute>
+      <layout class="QGridLayout" name="gridLayout_2">
+       <item row="0" column="0">
+        <layout class="QVBoxLayout" name="verticalLayout">
+         <item>
+          <widget class="QCheckBox" name="connectOnStartup">
+           <property name="text">
+            <string>Connect to #octave on startup</string>
+           </property>
+           <property name="checked">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="showMessageOfTheDay">
+           <property name="text">
+            <string>Show message of the day</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="showTopic">
+           <property name="text">
+            <string>Show topic</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="autoIdentification">
+           <property name="text">
+            <string>Automatically identify on NickServ</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QLabel" name="label_2">
+           <property name="text">
+            <string>Warning: Your password will be stored in ~/.octavegui in human-readable format. Do not enter your password if you worry about security issues.</string>
+           </property>
+           <property name="wordWrap">
+            <bool>true</bool>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <layout class="QHBoxLayout" name="horizontalLayout">
+           <item>
+            <spacer name="horizontalSpacer">
+             <property name="orientation">
+              <enum>Qt::Horizontal</enum>
+             </property>
+             <property name="sizeHint" stdset="0">
+              <size>
+               <width>40</width>
+               <height>20</height>
+              </size>
+             </property>
+            </spacer>
+           </item>
+           <item>
+            <widget class="QLabel" name="label">
+             <property name="text">
+              <string>Password:</string>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QLineEdit" name="nickServPassword">
+             <property name="enabled">
+              <bool>false</bool>
+             </property>
+             <property name="echoMode">
+              <enum>QLineEdit::Password</enum>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </item>
+        </layout>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="tab">
+      <attribute name="title">
+       <string>Editor</string>
+      </attribute>
+      <layout class="QGridLayout" name="gridLayout">
+       <item row="0" column="0">
+        <layout class="QHBoxLayout" name="horizontalLayout_3">
+         <item>
+          <widget class="QCheckBox" name="useCustomFileEditor">
+           <property name="text">
+            <string>Use custom file editor:</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QLineEdit" name="customFileEditor">
+           <property name="enabled">
+            <bool>false</bool>
+           </property>
+           <property name="text">
+            <string>emacs</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </item>
+       <item row="1" column="0">
+        <spacer name="verticalSpacer">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>20</width>
+           <height>158</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="tab_2">
+      <attribute name="title">
+       <string>File Browser</string>
+      </attribute>
+      <layout class="QVBoxLayout" name="verticalLayout_3">
+       <item>
+        <widget class="QCheckBox" name="showFilenames">
+         <property name="text">
+          <string>Show filenames</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="showFileSize">
+         <property name="text">
+          <string>Show file size</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="showFileType">
+         <property name="text">
+          <string>Show file type</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="showLastModified">
+         <property name="text">
+          <string>Show date of last modification</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="showHiddenFiles">
+         <property name="text">
+          <string>Show hidden files</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="useAlternatingRowColors">
+         <property name="text">
+          <string>Alternating row colors</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="horizontalLayout_2">
+     <item>
+      <widget class="QPushButton" name="resetButton">
+       <property name="enabled">
+        <bool>false</bool>
+       </property>
+       <property name="text">
+        <string>Reset to defaults</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer_2">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="exportButton">
+       <property name="enabled">
+        <bool>false</bool>
+       </property>
+       <property name="text">
+        <string>Export</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QPushButton" name="importButton">
+       <property name="enabled">
+        <bool>false</bool>
+       </property>
+       <property name="text">
+        <string>Import</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>useCustomFileEditor</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>customFileEditor</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>111</x>
+     <y>62</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>343</x>
+     <y>63</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>autoIdentification</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>nickServPassword</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>249</x>
+     <y>144</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>384</x>
+     <y>229</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff --git a/gui/src/VariablesDockWidget.cpp b/gui/src/VariablesDockWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/VariablesDockWidget.cpp
@@ -0,0 +1,205 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "VariablesDockWidget.h"
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+#include <QPushButton>
+
+VariablesDockWidget::VariablesDockWidget (QWidget * parent):QDockWidget
+  (parent)
+{
+  setObjectName ("VariablesDockWidget");
+  construct ();
+
+  connect (OctaveLink::instance(), SIGNAL (symbolTableChanged()), this, SLOT (fetchSymbolTable()));
+}
+
+void
+VariablesDockWidget::construct ()
+{
+  setWindowTitle (tr ("Workspace"));
+
+  m_updateSemaphore = new QSemaphore (1);
+  QStringList headerLabels;
+  headerLabels << tr ("Name") << tr ("Type") << tr ("Value");
+  m_variablesTreeWidget = new QTreeWidget (this);
+  m_variablesTreeWidget->setHeaderHidden (false);
+  m_variablesTreeWidget->setHeaderLabels (headerLabels);
+
+  setWidget (new QWidget (this));
+  QVBoxLayout *layout = new QVBoxLayout ();
+  layout->addWidget (m_variablesTreeWidget);
+  layout->setMargin (2);
+  widget ()->setLayout (layout);
+
+  QTreeWidgetItem *treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Local")));
+  m_variablesTreeWidget->insertTopLevelItem (0, treeWidgetItem);
+
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Global")));
+  m_variablesTreeWidget->insertTopLevelItem (1, treeWidgetItem);
+
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Persistent")));
+  m_variablesTreeWidget->insertTopLevelItem (2, treeWidgetItem);
+
+  treeWidgetItem = new QTreeWidgetItem ();
+  treeWidgetItem->setData (0, 0, QString (tr ("Hidden")));
+  m_variablesTreeWidget->insertTopLevelItem (3, treeWidgetItem);
+
+  m_variablesTreeWidget->expandAll ();
+  m_variablesTreeWidget->setAlternatingRowColors (true);
+  m_variablesTreeWidget->setAnimated (true);
+}
+
+void
+VariablesDockWidget::updateTreeEntry (QTreeWidgetItem * treeItem,
+				      SymbolRecord symbolRecord)
+{
+  treeItem->setData (0, 0, QString (symbolRecord.name ().c_str ()));
+  treeItem->setData (1, 0,
+		     QString (symbolRecord.varval ().type_name ().c_str ()));
+  treeItem->setData (2, 0,
+		     OctaveLink::octaveValueAsQString (symbolRecord.
+						       varval ()));
+}
+
+void
+VariablesDockWidget::setVariablesList (QList < SymbolRecord > symbolTable)
+{
+  m_updateSemaphore->acquire ();
+  // Split the symbol table into its different scopes.
+  QList < SymbolRecord > localSymbolTable;
+  QList < SymbolRecord > globalSymbolTable;
+  QList < SymbolRecord > persistentSymbolTable;
+  QList < SymbolRecord > hiddenSymbolTable;
+
+  foreach (SymbolRecord symbolRecord, symbolTable)
+  {
+    // It's true that being global or hidden includes it's can mean it's also locally visible,
+    // but we want to distinguish that here.
+    if (symbolRecord.is_local () && !symbolRecord.is_global ()
+	&& !symbolRecord.is_hidden ())
+      {
+	localSymbolTable.append (symbolRecord);
+      }
+
+    if (symbolRecord.is_global ())
+      {
+	globalSymbolTable.append (symbolRecord);
+      }
+
+    if (symbolRecord.is_persistent ())
+      {
+	persistentSymbolTable.append (symbolRecord);
+      }
+
+    if (symbolRecord.is_hidden ())
+      {
+	hiddenSymbolTable.append (symbolRecord);
+      }
+  }
+
+  updateScope (0, localSymbolTable);
+  updateScope (1, globalSymbolTable);
+  updateScope (2, persistentSymbolTable);
+  updateScope (3, hiddenSymbolTable);
+  m_updateSemaphore->release ();
+}
+
+void
+VariablesDockWidget::updateScope (int topLevelItemIndex,
+				  QList < SymbolRecord > symbolTable)
+{
+  // This method may be a little bit confusing; variablesList is a complete list of all
+  // variables that are in the workspace currently.
+  QTreeWidgetItem *topLevelItem =
+    m_variablesTreeWidget->topLevelItem (topLevelItemIndex);
+
+  // First we check, if any variables that exist in the model tree have to be updated
+  // or created. So we walk the variablesList check against the tree.
+  foreach (SymbolRecord symbolRecord, symbolTable)
+  {
+    int childCount = topLevelItem->childCount ();
+    bool alreadyExists = false;
+    QTreeWidgetItem *child;
+
+    // Search for the corresponding item in the tree. If it has been found, child
+    // will contain the appropriate QTreeWidgetItem* pointing at it.
+    for (int i = 0; i < childCount; i++)
+      {
+	child = topLevelItem->child (i);
+	if (child->data (0, 0).toString () ==
+	    QString (symbolRecord.name ().c_str ()))
+	  {
+	    alreadyExists = true;
+	    break;
+	  }
+      }
+
+    // If it already exists, just update it.
+    if (alreadyExists)
+      {
+	updateTreeEntry (child, symbolRecord);
+      }
+    else
+      {
+	// It does not exist, so create a new one and set the right values.
+	child = new QTreeWidgetItem ();
+	updateTreeEntry (child, symbolRecord);
+	topLevelItem->addChild (child);
+      }
+  }
+
+  // Check the tree against the list for deleted variables.
+  for (int i = 0; i < topLevelItem->childCount (); i++)
+    {
+      bool existsInVariableList = false;
+      QTreeWidgetItem *child = topLevelItem->child (i);
+      foreach (SymbolRecord symbolRecord, symbolTable)
+      {
+	if (QString (symbolRecord.name ().c_str ()) ==
+	    child->data (0, 0).toString ())
+	  {
+	    existsInVariableList = true;
+	  }
+      }
+
+      if (!existsInVariableList)
+	{
+	  topLevelItem->removeChild (child);
+	  delete child;
+	  i--;
+	}
+    }
+}
+
+void
+VariablesDockWidget::noticeSettings ()
+{
+
+}
+
+void
+VariablesDockWidget::fetchSymbolTable ()
+{
+  QList < SymbolRecord > symbolTable = OctaveLink::instance ()->copyCurrentSymbolTable ();
+  setVariablesList (symbolTable);
+}
diff --git a/gui/src/VariablesDockWidget.h b/gui/src/VariablesDockWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/VariablesDockWidget.h
@@ -0,0 +1,49 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef VARIABLESDOCKWIDGET_H
+#define VARIABLESDOCKWIDGET_H
+
+#include <QDockWidget>
+#include <QTreeWidget>
+#include <QSemaphore>
+#include "OctaveLink.h"
+
+class VariablesDockWidget:public QDockWidget
+{
+  Q_OBJECT
+public:
+  VariablesDockWidget (QWidget * parent = 0);
+  void setVariablesList (QList < SymbolRecord > symbolTable);
+
+public slots:
+  /** Tells the widget to notice settings that are probably new. */
+  void noticeSettings ();
+  void fetchSymbolTable ();
+
+private:
+  void construct ();
+  void updateTreeEntry (QTreeWidgetItem * treeItem,
+			SymbolRecord symbolRecord);
+  void updateScope (int topLevelItemIndex,
+		    QList < SymbolRecord > symbolTable);
+  QTreeWidget *m_variablesTreeWidget;
+  QSemaphore *m_updateSemaphore;
+};
+
+#endif // VARIABLESDOCKWIDGET_H
diff --git a/gui/src/backend/OctaveCallbackThread.cpp b/gui/src/backend/OctaveCallbackThread.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveCallbackThread.cpp
@@ -0,0 +1,35 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "OctaveCallbackThread.h"
+#include "MainWindow.h"
+
+OctaveCallbackThread::OctaveCallbackThread (QObject * parent):QThread (parent)
+{
+}
+
+void
+OctaveCallbackThread::run ()
+{
+  while (1)
+    {
+      OctaveLink::instance ()->fetchSymbolTable ();
+      OctaveLink::instance ()->updateHistoryModel ();
+      usleep (500000);
+    }
+}
diff --git a/gui/src/backend/OctaveCallbackThread.h b/gui/src/backend/OctaveCallbackThread.h
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveCallbackThread.h
@@ -0,0 +1,34 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef OCTAVECALLBACKTHREAD_H
+#define OCTAVECALLBACKTHREAD_H
+
+#include <QThread>
+
+class OctaveCallbackThread:public QThread
+{
+  Q_OBJECT
+public:
+  OctaveCallbackThread (QObject * parent);
+protected:
+  void run ();
+
+};
+
+#endif // OCTAVECALLBACKTHREAD_H
diff --git a/gui/src/backend/OctaveLink.cpp b/gui/src/backend/OctaveLink.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveLink.cpp
@@ -0,0 +1,166 @@
+/*
+
+Copyright (C) 2007,2008,2009 John P. Swensen
+Copyright (C) 2010, 2011 Jacob Dawid
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.
+
+*/
+
+#include "OctaveLink.h"
+
+OctaveLink OctaveLink::m_singleton;
+
+OctaveLink::OctaveLink ():QObject ()
+{
+  m_symbolTableSemaphore = new QSemaphore (1);
+  m_historyModel = new QStringListModel (this);
+}
+
+OctaveLink::~OctaveLink ()
+{
+}
+
+QString
+OctaveLink::octaveValueAsQString (OctaveValue octaveValue)
+{
+  // Convert single qouted string.
+  if (octaveValue.is_sq_string ())
+    {
+      return QString ("\'%1\'").arg (octaveValue.string_value ().c_str ());
+
+      // Convert double qouted string.
+    }
+  else if (octaveValue.is_dq_string ())
+    {
+      return QString ("\"%1\"").arg (octaveValue.string_value ().c_str ());
+
+      // Convert real scalar.
+    }
+  else if (octaveValue.is_real_scalar ())
+    {
+      return QString ("%1").arg (octaveValue.scalar_value ());
+
+      // Convert complex scalar.
+    }
+  else if (octaveValue.is_complex_scalar ())
+    {
+      return QString ("%1 + %2i").arg (octaveValue.scalar_value ()).
+	arg (octaveValue.complex_value ().imag ());
+
+      // Convert range.
+    }
+  else if (octaveValue.is_range ())
+    {
+      return QString ("%1 : %2 : %3").arg (octaveValue.range_value ().
+					   base ()).arg (octaveValue.
+							 range_value ().
+							 inc ()).
+	arg (octaveValue.range_value ().limit ());
+
+      // Convert real matrix.
+    }
+  else if (octaveValue.is_real_matrix ())
+    {
+      // TODO: Convert real matrix into a string.
+      return QString ("{matrix}");
+
+      // Convert complex matrix.
+    }
+  else if (octaveValue.is_complex_matrix ())
+    {
+      // TODO: Convert complex matrix into a string.
+      return QString ("{complex matrix}");
+
+      // If everything else does not fit, we could not recognize the type.
+    }
+  else
+    {
+      return QString ("<Type not recognized>");
+    }
+}
+
+void
+OctaveLink::launchOctave ()
+{
+  m_octaveMainThread = new OctaveMainThread (this);
+  m_octaveMainThread->start ();
+
+  m_octaveCallbackThread = new OctaveCallbackThread (this);
+  connect (m_octaveMainThread, SIGNAL(ready()), m_octaveCallbackThread, SLOT(start()));
+}
+
+void
+OctaveLink::terminateOctave ()
+{
+  m_octaveCallbackThread->terminate ();
+  m_octaveCallbackThread->wait ();
+
+  m_octaveMainThread->terminate ();
+  m_octaveMainThread->wait();
+}
+
+void
+OctaveLink::fetchSymbolTable ()
+{
+  m_symbolTableSemaphore->acquire ();
+  m_symbolTableBuffer.clear ();
+  std::list < SymbolRecord > allVariables = symbol_table::all_variables ();
+  std::list < SymbolRecord >::iterator iterator;
+  for (iterator = allVariables.begin (); iterator != allVariables.end ();
+       iterator++)
+    m_symbolTableBuffer.append (iterator->dup ());
+  m_symbolTableSemaphore->release ();
+  emit symbolTableChanged ();
+}
+
+QList < SymbolRecord > OctaveLink::copyCurrentSymbolTable ()
+{
+  QList < SymbolRecord > m_symbolTableCopy;
+
+  // Generate a deep copy of the current symbol table.
+  m_symbolTableSemaphore->acquire ();
+  foreach (SymbolRecord symbolRecord, m_symbolTableBuffer)
+    m_symbolTableCopy.append (symbolRecord.dup ());
+  m_symbolTableSemaphore->release ();
+
+  return m_symbolTableCopy;
+}
+
+
+void
+OctaveLink::updateHistoryModel ()
+{
+  // Determine the client's (our) history length and the one of the server.
+  int clientHistoryLength = m_historyModel->rowCount ();
+  int serverHistoryLength = command_history::length ();
+
+  // If were behind the server, iterate through all new entries and add them to our history.
+  if (clientHistoryLength < serverHistoryLength)
+    {
+      for (int i = clientHistoryLength; i < serverHistoryLength; i++)
+        {
+          m_historyModel->insertRow (0);
+          m_historyModel->setData (m_historyModel->index (0), QString (command_history::get_entry (i).c_str ()));
+        }
+    }
+}
+
+QStringListModel *
+OctaveLink::historyModel ()
+{
+  return m_historyModel;
+}
diff --git a/gui/src/backend/OctaveLink.h b/gui/src/backend/OctaveLink.h
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveLink.h
@@ -0,0 +1,149 @@
+/*
+ *
+ * Copyright (C) 2007, 2008, 2009 John P. Swensen
+ *
+ * OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ * This file is as a part of OctaveDE.
+ *
+ * Octave is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * Octave is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Octave; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ * */
+
+#ifndef OCTAVELINK_H
+#define OCTAVELINK_H
+
+// Octave includes
+#undef PACKAGE_BUGREPORT
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
+#undef PACKAGE_URL
+#include <octave/config.h>
+#include "octave/cmd-edit.h"
+#include "octave/error.h"
+#include "octave/file-io.h"
+#include "octave/input.h"
+#include "octave/lex.h"
+#include "octave/load-path.h"
+#include "octave/octave.h"
+#include "octave/oct-hist.h"
+#include "octave/oct-map.h"
+#include "octave/oct-obj.h"
+#include "octave/ops.h"
+#include "octave/ov.h"
+#include "octave/ov-usr-fcn.h"
+#include "octave/symtab.h"
+#include "octave/pt.h"
+#include "octave/pt-eval.h"
+#include "octave/config.h"
+#include "octave/Range.h"
+#include "octave/toplev.h"
+#include "octave/procstream.h"
+#include "octave/sighandlers.h"
+#include "octave/debug.h"
+#include "octave/sysdep.h"
+#include "octave/ov.h"
+#include "octave/unwind-prot.h"
+#include "octave/utils.h"
+#include "octave/variables.h"
+
+// Standard includes
+#include <iostream>
+#include <string>
+#include <vector>
+#include <readline/readline.h>
+
+// Qt includes
+#include <QMutexLocker>
+#include <QMutex>
+#include <QFileInfo>
+#include <QList>
+#include <QString>
+#include <QStringList>
+#include <QVector>
+#include <QSemaphore>
+#include <QObject>
+#include <QStringListModel>
+
+#include "OctaveCallbackThread.h"
+#include "OctaveMainThread.h"
+
+typedef symbol_table::symbol_record SymbolRecord;
+typedef octave_value OctaveValue;
+
+/**
+  * \class OctaveLink
+  * Manages a link to an octave instance.
+  */
+class OctaveLink:public QObject
+{
+  Q_OBJECT
+public:
+  static OctaveLink *
+  instance ()
+  {
+    return &m_singleton;
+  }
+  static QString
+  octaveValueAsQString (OctaveValue octaveValue);
+
+  void launchOctave ();
+  void terminateOctave ();
+
+  /**
+    * Returns a copy of the current symbol table buffer.
+    * \return Copy of the current symbol table buffer.
+    */
+  QList < SymbolRecord > copyCurrentSymbolTable ();
+
+  void
+  updateHistoryModel ();
+
+  QStringListModel *
+  historyModel ();
+
+  /**
+    * Updates the current symbol table with new data
+    * from octave.
+    */
+  void
+  fetchSymbolTable ();
+
+signals:
+  void
+  symbolTableChanged ();
+
+private:
+  OctaveLink ();
+  ~OctaveLink ();
+
+  /** Variable related member variables. */
+  QSemaphore * m_symbolTableSemaphore;
+  QList < SymbolRecord > m_symbolTableBuffer;
+
+  /** History related member variables. */
+  QStringListModel *m_historyModel;
+
+  // Threads for running octave and managing the data interaction.
+  OctaveMainThread *m_octaveMainThread;
+  OctaveCallbackThread *m_octaveCallbackThread;
+
+  static OctaveLink m_singleton;
+};
+#endif // OCTAVELINK_H
diff --git a/gui/src/backend/OctaveMainThread.cpp b/gui/src/backend/OctaveMainThread.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveMainThread.cpp
@@ -0,0 +1,35 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "OctaveMainThread.h"
+#include "OctaveLink.h"
+
+OctaveMainThread::OctaveMainThread (QObject * parent):QThread (parent)
+{
+}
+
+void
+OctaveMainThread::run ()
+{
+  int argc = 3;
+  const char *argv[] = { "OctaveGUI", "--interactive", "--line-editing" };
+  octave_main (argc, (char **) argv, 1);
+  emit ready();
+  main_loop ();
+  clean_up_and_exit (0);
+}
diff --git a/gui/src/backend/OctaveMainThread.h b/gui/src/backend/OctaveMainThread.h
new file mode 100644
--- /dev/null
+++ b/gui/src/backend/OctaveMainThread.h
@@ -0,0 +1,36 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef OCTAVEMAINTHREAD_H
+#define OCTAVEMAINTHREAD_H
+
+#include <QThread>
+class OctaveMainThread:public QThread
+{
+  Q_OBJECT
+public:
+  OctaveMainThread (QObject * parent);
+
+signals:
+  void ready();
+
+protected:
+  void run ();
+};
+
+#endif // OCTAVEMAINTHREAD_H
diff --git a/gui/src/lexer/lexeroctavegui.cpp b/gui/src/lexer/lexeroctavegui.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/lexer/lexeroctavegui.cpp
@@ -0,0 +1,1699 @@
+/* OctaveGUI - A graphical user interface for Octave
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This module is a custom lexer for QScintilla for use with the Octave-GUI.
+ * Examples for lexers can be found in the sources of Qscintilla-gpl-2.5.1,
+ * QScintilla is a port to Qt of Neil Hodgson's Scintilla C++ editor control.
+ */
+
+
+#include "lexeroctavegui.h"
+#include <qcolor.h>
+#include <qfont.h>
+
+// -----------------------------------------------------
+// Some basic functions
+// -----------------------------------------------------
+LexerOctaveGui::LexerOctaveGui(QObject *parent)
+    : QsciLexer(parent)  // inherit from base lexer
+{
+}
+
+LexerOctaveGui::~LexerOctaveGui()
+{
+}
+
+const char *LexerOctaveGui::language() const
+{
+  return "Octave";  // return the name of the language
+}
+
+const char *LexerOctaveGui::lexer() const
+{
+  return "octave";  // return the name of the lexer
+}
+
+// -----------------------------------------------------
+// The colors for syntax highlighting
+// -----------------------------------------------------
+QColor LexerOctaveGui::defaultColor(int style) const
+{
+    switch (style)
+      {
+        case Default:  // black
+          return QColor(0x00,0x00,0x00);
+        case Operator: // red
+          return QColor(0xef,0x00,0x00);
+        case Comment:  // gray
+          return QColor(0x7f,0x7f,0x7f);
+        case Command:  // blue-green
+          return QColor(0x00,0x7f,0x7f);
+        case Number:   // orange
+          return QColor(0x7f,0x7f,0x00);
+        case Keyword:  // blue
+          return QColor(0x00,0x00,0xbf);
+        case SingleQuotedString: // green
+          return QColor(0x00,0x7f,0x00);
+        case DoubleQuotedString: // green-yellow
+          return QColor(0x4f,0x7f,0x00);
+      }
+    return QsciLexer::defaultColor(style);
+}
+
+
+// -----------------------------------------------------
+// The font decorations for highlighting
+// -----------------------------------------------------
+QFont LexerOctaveGui::defaultFont(int style) const
+{
+    QFont f;
+
+    switch (style)
+      {
+        case Comment: // default but italic
+          f = QsciLexer::defaultFont(style);
+          f.setItalic(true);
+          break;
+        case Keyword: // default
+          f = QsciLexer::defaultFont(style);
+          break;
+        case Operator:  // default
+          f = QsciLexer::defaultFont(style);
+          break;
+        default:        // default
+          f = QsciLexer::defaultFont(style);
+          break;
+      }
+    return f;   // return the selected font
+}
+
+
+// -----------------------------------------------------
+// Style names
+// -----------------------------------------------------
+QString LexerOctaveGui::description(int style) const
+{
+    switch (style)
+      {
+        case Default:
+          return tr("Default");
+        case Comment:
+          return tr("Comment");
+        case Command:
+          return tr("Command");
+        case Number:
+          return tr("Number");
+        case Keyword:
+          return tr("Keyword");
+        case SingleQuotedString:
+          return tr("Single-quoted string");
+        case Operator:
+          return tr("Operator");
+        case Identifier:
+          return tr("Identifier");
+        case DoubleQuotedString:
+          return tr("Double-quoted string");
+      }
+    return QString();
+}
+
+
+// -----------------------------------------------------
+// The set of keywords for highlighting
+// TODO: How to define a second set?
+// -----------------------------------------------------
+const char *LexerOctaveGui::keywords(int set) const
+{
+    if (set == 1)
+      {
+        return
+            ".nargin. "
+            "EDITOR "
+            "EXEC_PATH "
+            "F_DUPFD "
+            "F_GETFD "
+            "F_GETFL "
+            "F_SETFD "
+            "F_SETFL "
+            "I "
+            "IMAGE_PATH "
+            "Inf "
+            "J "
+            "NA "
+            "NaN "
+            "OCTAVE_HOME "
+            "OCTAVE_VERSION "
+            "O_APPEND "
+            "O_ASYNC "
+            "O_CREAT "
+            "O_EXCL "
+            "O_NONBLOCK "
+            "O_RDONLY "
+            "O_RDWR "
+            "O_SYNC "
+            "O_TRUNC "
+            "O_WRONLY "
+            "PAGER "
+            "PAGER_FLAGS "
+            "PS1 "
+            "PS2 "
+            "PS4 "
+            "P_tmpdir "
+            "SEEK_CUR "
+            "SEEK_END "
+            "SEEK_SET "
+            "SIG "
+            "S_ISBLK "
+            "S_ISCHR "
+            "S_ISDIR "
+            "S_ISFIFO "
+            "S_ISLNK "
+            "S_ISREG "
+            "S_ISSOCK "
+            "WCONTINUE "
+            "WCOREDUMP "
+            "WEXITSTATUS "
+            "WIFCONTINUED "
+            "WIFEXITED "
+            "WIFSIGNALED "
+            "WIFSTOPPED "
+            "WNOHANG "
+            "WSTOPSIG "
+            "WTERMSIG "
+            "WUNTRACED "
+            "__accumarray_max__ "
+            "__accumarray_min__ "
+            "__accumarray_sum__ "
+            "__accumdim_sum__ "
+            "__all_opts__ "
+            "__builtins__ "
+            "__calc_dimensions__ "
+            "__contourc__ "
+            "__current_scope__ "
+            "__delaunayn__ "
+            "__dispatch__ "
+            "__display_tokens__ "
+            "__dsearchn__ "
+            "__dump_symtab_info__ "
+            "__end__ "
+            "__error_text__ "
+            "__finish__ "
+            "__fltk_ginput__ "
+            "__fltk_print__ "
+            "__fltk_uigetfile__ "
+            "__ftp__ "
+            "__ftp_ascii__ "
+            "__ftp_binary__ "
+            "__ftp_close__ "
+            "__ftp_cwd__ "
+            "__ftp_delete__ "
+            "__ftp_dir__ "
+            "__ftp_mget__ "
+            "__ftp_mkdir__ "
+            "__ftp_mode__ "
+            "__ftp_mput__ "
+            "__ftp_pwd__ "
+            "__ftp_rename__ "
+            "__ftp_rmdir__ "
+            "__get__ "
+            "__glpk__ "
+            "__gnuplot_drawnow__ "
+            "__gnuplot_get_var__ "
+            "__gnuplot_ginput__ "
+            "__gnuplot_has_feature__ "
+            "__gnuplot_open_stream__ "
+            "__gnuplot_print__ "
+            "__gnuplot_version__ "
+            "__go_axes__ "
+            "__go_axes_init__ "
+            "__go_close_all__ "
+            "__go_delete__ "
+            "__go_draw_axes__ "
+            "__go_draw_figure__ "
+            "__go_execute_callback__ "
+            "__go_figure__ "
+            "__go_figure_handles__ "
+            "__go_handles__ "
+            "__go_hggroup__ "
+            "__go_image__ "
+            "__go_line__ "
+            "__go_patch__ "
+            "__go_surface__ "
+            "__go_text__ "
+            "__go_uimenu__ "
+            "__gud_mode__ "
+            "__image_pixel_size__ "
+            "__init_fltk__ "
+            "__isa_parent__ "
+            "__keywords__ "
+            "__lexer_debug_flag__ "
+            "__lin_interpn__ "
+            "__list_functions__ "
+            "__magick_finfo__ "
+            "__magick_format_list__ "
+            "__magick_read__ "
+            "__magick_write__ "
+            "__makeinfo__ "
+            "__marching_cube__ "
+            "__next_line_color__ "
+            "__next_line_style__ "
+            "__operators__ "
+            "__parent_classes__ "
+            "__parser_debug_flag__ "
+            "__pathorig__ "
+            "__pchip_deriv__ "
+            "__plt_get_axis_arg__ "
+            "__print_parse_opts__ "
+            "__qp__ "
+            "__request_drawnow__ "
+            "__sort_rows_idx__ "
+            "__strip_html_tags__ "
+            "__token_count__ "
+            "__varval__ "
+            "__version_info__ "
+            "__voronoi__ "
+            "__which__ "
+            "abs "
+            "accumarray "
+            "accumdim "
+            "acos "
+            "acosd "
+            "acosh "
+            "acot "
+            "acotd "
+            "acoth "
+            "acsc "
+            "acscd "
+            "acsch "
+            "add_input_event_hook "
+            "addlistener "
+            "addpath "
+            "addproperty "
+            "addtodate "
+            "airy "
+            "all "
+            "allchild "
+            "allow_noninteger_range_as_index "
+            "amd "
+            "ancestor "
+            "and "
+            "angle "
+            "anova "
+            "ans "
+            "any "
+            "arch_fit "
+            "arch_rnd "
+            "arch_test "
+            "area "
+            "arg "
+            "argnames "
+            "argv "
+            "arma_rnd "
+            "arrayfun "
+            "asctime "
+            "asec "
+            "asecd "
+            "asech "
+            "asin "
+            "asind "
+            "asinh "
+            "assert "
+            "assignin "
+            "atan "
+            "atan2 "
+            "atand "
+            "atanh "
+            "atexit "
+            "autocor "
+            "autocov "
+            "autoload "
+            "autoreg_matrix "
+            "autumn "
+            "available_graphics_toolkits "
+            "axes "
+            "axis "
+            "balance "
+            "bar "
+            "barh "
+            "bartlett "
+            "bartlett_test "
+            "base2dec "
+            "beep "
+            "beep_on_error "
+            "bessel "
+            "besselh "
+            "besseli "
+            "besselj "
+            "besselk "
+            "bessely "
+            "beta "
+            "betacdf "
+            "betai "
+            "betainc "
+            "betainv "
+            "betaln "
+            "betapdf "
+            "betarnd "
+            "bicgstab "
+            "bicubic "
+            "bin2dec "
+            "bincoeff "
+            "binocdf "
+            "binoinv "
+            "binopdf "
+            "binornd "
+            "bitand "
+            "bitcmp "
+            "bitget "
+            "bitmax "
+            "bitor "
+            "bitpack "
+            "bitset "
+            "bitshift "
+            "bitunpack "
+            "bitxor "
+            "blackman "
+            "blanks "
+            "blkdiag "
+            "blkmm "
+            "bone "
+            "box "
+            "break "
+            "brighten "
+            "bsxfun "
+            "bug_report "
+            "builtin "
+            "bunzip2 "
+            "bzip2 "
+            "calendar "
+            "canonicalize_file_name "
+            "cart2pol "
+            "cart2sph "
+            "case "
+            "cast "
+            "cat "
+            "catch "
+            "cauchy_cdf "
+            "cauchy_inv "
+            "cauchy_pdf "
+            "cauchy_rnd "
+            "caxis "
+            "cbrt "
+            "ccolamd "
+            "cd "
+            "ceil "
+            "cell "
+            "cell2mat "
+            "cell2struct "
+            "celldisp "
+            "cellfun "
+            "cellidx "
+            "cellindexmat "
+            "cellslices "
+            "cellstr "
+            "center "
+            "cgs "
+            "char "
+            "chdir "
+            "chi2cdf "
+            "chi2inv "
+            "chi2pdf "
+            "chi2rnd "
+            "chisquare_test_homogeneity "
+            "chisquare_test_independence "
+            "chol "
+            "chol2inv "
+            "choldelete "
+            "cholinsert "
+            "cholinv "
+            "cholshift "
+            "cholupdate "
+            "chop "
+            "circshift "
+            "cla "
+            "clabel "
+            "class "
+            "clc "
+            "clear "
+            "clf "
+            "clg "
+            "clock "
+            "cloglog "
+            "close "
+            "closereq "
+            "colamd "
+            "colloc "
+            "colon "
+            "colorbar "
+            "colormap "
+            "colperm "
+            "colstyle "
+            "columns "
+            "comet "
+            "comet3 "
+            "comma "
+            "command_line_path "
+            "common_size "
+            "commutation_matrix "
+            "compan "
+            "compare_versions "
+            "compass "
+            "complement "
+            "completion_append_char "
+            "completion_matches "
+            "complex "
+            "computer "
+            "cond "
+            "condest "
+            "confirm_recursive_rmdir "
+            "conj "
+            "continue "
+            "contour "
+            "contour3 "
+            "contourc "
+            "contourf "
+            "contrast "
+            "conv "
+            "conv2 "
+            "convhull "
+            "convhulln "
+            "convn "
+            "cool "
+            "copper "
+            "copyfile "
+            "cor "
+            "cor_test "
+            "corrcoef "
+            "cos "
+            "cosd "
+            "cosh "
+            "cot "
+            "cotd "
+            "coth "
+            "cov "
+            "cplxpair "
+            "cputime "
+            "cquad "
+            "crash_dumps_octave_core "
+            "create_set "
+            "cross "
+            "csc "
+            "cscd "
+            "csch "
+            "cstrcat "
+            "csvread "
+            "csvwrite "
+            "csymamd "
+            "ctime "
+            "ctranspose "
+            "cummax "
+            "cummin "
+            "cumprod "
+            "cumsum "
+            "cumtrapz "
+            "curl "
+            "cut "
+            "cylinder "
+            "daspect "
+            "daspk "
+            "daspk_options "
+            "dasrt "
+            "dasrt_options "
+            "dassl "
+            "dassl_options "
+            "date "
+            "datenum "
+            "datestr "
+            "datetick "
+            "datevec "
+            "dbclear "
+            "dbcont "
+            "dbdown "
+            "dblquad "
+            "dbnext "
+            "dbquit "
+            "dbstack "
+            "dbstatus "
+            "dbstep "
+            "dbstop "
+            "dbtype "
+            "dbup "
+            "dbwhere "
+            "deal "
+            "deblank "
+            "debug "
+            "debug_on_error "
+            "debug_on_interrupt "
+            "debug_on_warning "
+            "dec2base "
+            "dec2bin "
+            "dec2hex "
+            "deconv "
+            "default_save_options "
+            "del2 "
+            "delaunay "
+            "delaunay3 "
+            "delaunayn "
+            "delete "
+            "dellistener "
+            "demo "
+            "det "
+            "detrend "
+            "diag "
+            "diary "
+            "diff "
+            "diffpara "
+            "diffuse "
+            "dir "
+            "discrete_cdf "
+            "discrete_inv "
+            "discrete_pdf "
+            "discrete_rnd "
+            "disp "
+            "dispatch "
+            "display "
+            "divergence "
+            "dlmread "
+            "dlmwrite "
+            "dmperm "
+            "dmult "
+            "do "
+            "do_braindead_shortcircuit_evaluation "
+            "do_string_escapes "
+            "doc "
+            "doc_cache_file "
+            "dos "
+            "dot "
+            "double "
+            "drawnow "
+            "dsearch "
+            "dsearchn "
+            "dump_prefs "
+            "dup2 "
+            "duplication_matrix "
+            "durbinlevinson "
+            "e "
+            "echo "
+            "echo_executing_commands "
+            "edit "
+            "edit_history "
+            "eig "
+            "eigs "
+            "ellipsoid "
+            "else "
+            "elseif "
+            "empirical_cdf "
+            "empirical_inv "
+            "empirical_pdf "
+            "empirical_rnd "
+            "end "
+            "end_try_catch "
+            "end_unwind_protect "
+            "endfor "
+            "endfunction "
+            "endgrent "
+            "endif "
+            "endpwent "
+            "endswitch "
+            "endwhile "
+            "eomday "
+            "eps "
+            "eq "
+            "erf "
+            "erfc "
+            "erfcx "
+            "erfinv "
+            "errno "
+            "errno_list "
+            "error "
+            "error_text "
+            "errorbar "
+            "etime "
+            "etree "
+            "etreeplot "
+            "eval "
+            "evalin "
+            "example "
+            "exec "
+            "exist "
+            "exit "
+            "exp "
+            "expcdf "
+            "expinv "
+            "expm "
+            "expm1 "
+            "exppdf "
+            "exprnd "
+            "eye "
+            "ezcontour "
+            "ezcontourf "
+            "ezmesh "
+            "ezmeshc "
+            "ezplot "
+            "ezplot3 "
+            "ezpolar "
+            "ezsurf "
+            "ezsurfc "
+            "f_test_regression "
+            "factor "
+            "factorial "
+            "fail "
+            "false "
+            "fcdf "
+            "fclear "
+            "fclose "
+            "fcntl "
+            "fdisp "
+            "feather "
+            "feof "
+            "ferror "
+            "feval "
+            "fflush "
+            "fft "
+            "fft2 "
+            "fftconv "
+            "fftfilt "
+            "fftn "
+            "fftshift "
+            "fftw "
+            "fgetl "
+            "fgets "
+            "fieldnames "
+            "figure "
+            "file_in_loadpath "
+            "file_in_path "
+            "fileattrib "
+            "filemarker "
+            "fileparts "
+            "fileread "
+            "filesep "
+            "fill "
+            "filter "
+            "filter2 "
+            "find "
+            "find_dir_in_path "
+            "findall "
+            "findobj "
+            "findstr "
+            "finite "
+            "finv "
+            "fix "
+            "fixed_point_format "
+            "flag "
+            "flipdim "
+            "fliplr "
+            "flipud "
+            "floor "
+            "fminbnd "
+            "fminunc "
+            "fmod "
+            "fnmatch "
+            "fopen "
+            "for "
+            "fork "
+            "format "
+            "formula "
+            "fpdf "
+            "fplot "
+            "fprintf "
+            "fputs "
+            "fractdiff "
+            "fread "
+            "freport "
+            "freqz "
+            "freqz_plot "
+            "frewind "
+            "frnd "
+            "fscanf "
+            "fseek "
+            "fskipl "
+            "fsolve "
+            "fstat "
+            "ftell "
+            "full "
+            "fullfile "
+            "func2str "
+            "function "
+            "functions "
+            "fwrite "
+            "fzero "
+            "gamcdf "
+            "gaminv "
+            "gamma "
+            "gammai "
+            "gammainc "
+            "gammaln "
+            "gampdf "
+            "gamrnd "
+            "gca "
+            "gcbf "
+            "gcbo "
+            "gcd "
+            "gcf "
+            "ge "
+            "gen_doc_cache "
+            "genpath "
+            "genvarname "
+            "geocdf "
+            "geoinv "
+            "geopdf "
+            "geornd "
+            "get "
+            "get_first_help_sentence "
+            "get_help_text "
+            "get_help_text_from_file "
+            "getappdata "
+            "getegid "
+            "getenv "
+            "geteuid "
+            "getfield "
+            "getgid "
+            "getgrent "
+            "getgrgid "
+            "getgrnam "
+            "gethostname "
+            "getpgrp "
+            "getpid "
+            "getppid "
+            "getpwent "
+            "getpwnam "
+            "getpwuid "
+            "getrusage "
+            "getuid "
+            "ginput "
+            "givens "
+            "glob "
+            "global "
+            "glpk "
+            "glpkmex "
+            "gls "
+            "gmap40 "
+            "gmres "
+            "gmtime "
+            "gnuplot_binary "
+            "gplot "
+            "gradient "
+            "graphics_toolkit "
+            "gray "
+            "gray2ind "
+            "grid "
+            "griddata "
+            "griddata3 "
+            "griddatan "
+            "gt "
+            "gtext "
+            "gunzip "
+            "gzip "
+            "hadamard "
+            "hamming "
+            "hankel "
+            "hanning "
+            "help "
+            "hess "
+            "hex2dec "
+            "hex2num "
+            "hggroup "
+            "hidden "
+            "hilb "
+            "hist "
+            "histc "
+            "history "
+            "history_control "
+            "history_file "
+            "history_size "
+            "history_timestamp_format_string "
+            "hold "
+            "home "
+            "horzcat "
+            "hot "
+            "hotelling_test "
+            "hotelling_test_2 "
+            "housh "
+            "hsv "
+            "hsv2rgb "
+            "hurst "
+            "hygecdf "
+            "hygeinv "
+            "hygepdf "
+            "hygernd "
+            "hypot "
+            "i "
+            "idivide "
+            "if "
+            "ifelse "
+            "ifft "
+            "ifft2 "
+            "ifftn "
+            "ifftshift "
+            "ignore_function_time_stamp "
+            "imag "
+            "image "
+            "imagesc "
+            "imfinfo "
+            "imread "
+            "imshow "
+            "imwrite "
+            "ind2gray "
+            "ind2rgb "
+            "ind2sub "
+            "index "
+            "inf "
+            "inferiorto "
+            "info "
+            "info_file "
+            "info_program "
+            "inline "
+            "inpolygon "
+            "input "
+            "inputname "
+            "int16 "
+            "int2str "
+            "int32 "
+            "int64 "
+            "int8 "
+            "interp1 "
+            "interp1q "
+            "interp2 "
+            "interp3 "
+            "interpft "
+            "interpn "
+            "intersect "
+            "intmax "
+            "intmin "
+            "intwarning "
+            "inv "
+            "inverse "
+            "invhilb "
+            "ipermute "
+            "iqr "
+            "is_absolute_filename "
+            "is_duplicate_entry "
+            "is_global "
+            "is_leap_year "
+            "is_rooted_relative_filename "
+            "is_valid_file_id "
+            "isa "
+            "isalnum "
+            "isalpha "
+            "isappdata "
+            "isargout "
+            "isascii "
+            "isbool "
+            "iscell "
+            "iscellstr "
+            "ischar "
+            "iscntrl "
+            "iscolumn "
+            "iscommand "
+            "iscomplex "
+            "isdebugmode "
+            "isdefinite "
+            "isdeployed "
+            "isdigit "
+            "isdir "
+            "isempty "
+            "isequal "
+            "isequalwithequalnans "
+            "isfield "
+            "isfigure "
+            "isfinite "
+            "isfloat "
+            "isglobal "
+            "isgraph "
+            "ishandle "
+            "ishermitian "
+            "ishghandle "
+            "ishold "
+            "isieee "
+            "isindex "
+            "isinf "
+            "isinteger "
+            "iskeyword "
+            "isletter "
+            "islogical "
+            "islower "
+            "ismac "
+            "ismatrix "
+            "ismember "
+            "ismethod "
+            "isna "
+            "isnan "
+            "isnull "
+            "isnumeric "
+            "isobject "
+            "isocolors "
+            "isonormals "
+            "isosurface "
+            "ispc "
+            "isprime "
+            "isprint "
+            "isprop "
+            "ispunct "
+            "israwcommand "
+            "isreal "
+            "isrow "
+            "isscalar "
+            "issorted "
+            "isspace "
+            "issparse "
+            "issquare "
+            "isstr "
+            "isstrprop "
+            "isstruct "
+            "issymmetric "
+            "isunix "
+            "isupper "
+            "isvarname "
+            "isvector "
+            "isxdigit "
+            "j "
+            "jet "
+            "kbhit "
+            "kendall "
+            "keyboard "
+            "kill "
+            "kolmogorov_smirnov_cdf "
+            "kolmogorov_smirnov_test "
+            "kolmogorov_smirnov_test_2 "
+            "kron "
+            "kruskal_wallis_test "
+            "krylov "
+            "krylovb "
+            "kurtosis "
+            "laplace_cdf "
+            "laplace_inv "
+            "laplace_pdf "
+            "laplace_rnd "
+            "lasterr "
+            "lasterror "
+            "lastwarn "
+            "lchol "
+            "lcm "
+            "ldivide "
+            "le "
+            "legend "
+            "legendre "
+            "length "
+            "lgamma "
+            "license "
+            "lin2mu "
+            "line "
+            "link "
+            "linkprop "
+            "linspace "
+            "list "
+            "list_in_columns "
+            "list_primes "
+            "load "
+            "loadaudio "
+            "loadimage "
+            "loadobj "
+            "localtime "
+            "log "
+            "log10 "
+            "log1p "
+            "log2 "
+            "logical "
+            "logistic_cdf "
+            "logistic_inv "
+            "logistic_pdf "
+            "logistic_regression "
+            "logistic_rnd "
+            "logit "
+            "loglog "
+            "loglogerr "
+            "logm "
+            "logncdf "
+            "logninv "
+            "lognpdf "
+            "lognrnd "
+            "logspace "
+            "lookfor "
+            "lookup "
+            "lower "
+            "ls "
+            "ls_command "
+            "lsode "
+            "lsode_options "
+            "lsqnonneg "
+            "lstat "
+            "lt "
+            "lu "
+            "luinc "
+            "luupdate "
+            "magic "
+            "mahalanobis "
+            "make_absolute_filename "
+            "makeinfo_program "
+            "manova "
+            "mark_as_command "
+            "mark_as_rawcommand "
+            "mat2cell "
+            "mat2str "
+            "matlabroot "
+            "matrix_type "
+            "max "
+            "max_recursion_depth "
+            "mcnemar_test "
+            "md5sum "
+            "mean "
+            "meansq "
+            "median "
+            "menu "
+            "merge "
+            "mesh "
+            "meshc "
+            "meshgrid "
+            "meshz "
+            "methods "
+            "mex "
+            "mexext "
+            "mfilename "
+            "mgorth "
+            "min "
+            "minus "
+            "mislocked "
+            "missing_function_hook "
+            "mist "
+            "mkdir "
+            "mkfifo "
+            "mkoctfile "
+            "mkpp "
+            "mkstemp "
+            "mktime "
+            "mldivide "
+            "mlock "
+            "mod "
+            "mode "
+            "moment "
+            "more "
+            "most "
+            "movefile "
+            "mpoles "
+            "mpower "
+            "mrdivide "
+            "mtimes "
+            "mu2lin "
+            "munlock "
+            "namelengthmax "
+            "nan "
+            "nargchk "
+            "nargin "
+            "nargout "
+            "nargoutchk "
+            "native_float_format "
+            "nbincdf "
+            "nbininv "
+            "nbinpdf "
+            "nbinrnd "
+            "nchoosek "
+            "ndgrid "
+            "ndims "
+            "ne "
+            "newplot "
+            "news "
+            "nextpow2 "
+            "nfields "
+            "nnz "
+            "nonzeros "
+            "norm "
+            "normcdf "
+            "normest "
+            "norminv "
+            "normpdf "
+            "normrnd "
+            "not "
+            "now "
+            "nproc "
+            "nth_element "
+            "nthroot "
+            "ntsc2rgb "
+            "null "
+            "num2cell "
+            "num2hex "
+            "num2str "
+            "numel "
+            "nzmax "
+            "ocean "
+            "octave_config_info "
+            "octave_core_file_limit "
+            "octave_core_file_name "
+            "octave_core_file_options "
+            "octave_tmp_file_name "
+            "ols "
+            "onCleanup "
+            "onenormest "
+            "ones "
+            "optimget "
+            "optimize_subsasgn_calls "
+            "optimset "
+            "or "
+            "orderfields "
+            "orient "
+            "orth "
+            "otherwise "
+            "output_max_field_width "
+            "output_precision "
+            "pack "
+            "page_output_immediately "
+            "page_screen_output "
+            "paren "
+            "pareto "
+            "parseparams "
+            "pascal "
+            "patch "
+            "path "
+            "pathdef "
+            "pathsep "
+            "pause "
+            "pbaspect "
+            "pcg "
+            "pchip "
+            "pclose "
+            "pcolor "
+            "pcr "
+            "peaks "
+            "periodogram "
+            "perl "
+            "perms "
+            "permute "
+            "perror "
+            "persistent "
+            "pi "
+            "pie "
+            "pie3 "
+            "pink "
+            "pinv "
+            "pipe "
+            "pkg "
+            "planerot "
+            "playaudio "
+            "plot "
+            "plot3 "
+            "plotmatrix "
+            "plotyy "
+            "plus "
+            "poisscdf "
+            "poissinv "
+            "poisspdf "
+            "poissrnd "
+            "pol2cart "
+            "polar "
+            "poly "
+            "polyaffine "
+            "polyarea "
+            "polyder "
+            "polyderiv "
+            "polyfit "
+            "polygcd "
+            "polyint "
+            "polyout "
+            "polyreduce "
+            "polyval "
+            "polyvalm "
+            "popen "
+            "popen2 "
+            "postpad "
+            "pow2 "
+            "power "
+            "powerset "
+            "ppder "
+            "ppint "
+            "ppjumps "
+            "ppplot "
+            "ppval "
+            "pqpnonneg "
+            "prctile "
+            "prepad "
+            "primes "
+            "print "
+            "print_empty_dimensions "
+            "print_struct_array_contents "
+            "print_usage "
+            "printf "
+            "prism "
+            "probit "
+            "prod "
+            "program_invocation_name "
+            "program_name "
+            "prop_test_2 "
+            "putenv "
+            "puts "
+            "pwd "
+            "qp "
+            "qqplot "
+            "qr "
+            "qrdelete "
+            "qrinsert "
+            "qrshift "
+            "qrupdate "
+            "quad "
+            "quad_options "
+            "quadcc "
+            "quadgk "
+            "quadl "
+            "quadv "
+            "quantile "
+            "quit "
+            "quiver "
+            "quiver3 "
+            "qz "
+            "qzhess "
+            "rainbow "
+            "rand "
+            "rande "
+            "randg "
+            "randi "
+            "randn "
+            "randp "
+            "randperm "
+            "range "
+            "rank "
+            "ranks "
+            "rat "
+            "rats "
+            "rcond "
+            "rdivide "
+            "re_read_readline_init_file "
+            "read_readline_init_file "
+            "readdir "
+            "readlink "
+            "real "
+            "reallog "
+            "realmax "
+            "realmin "
+            "realpow "
+            "realsqrt "
+            "record "
+            "rectangle "
+            "rectint "
+            "refresh "
+            "refreshdata "
+            "regexp "
+            "regexpi "
+            "regexprep "
+            "regexptranslate "
+            "rehash "
+            "rem "
+            "remove_input_event_hook "
+            "rename "
+            "repelems "
+            "replot "
+            "repmat "
+            "reset "
+            "reshape "
+            "residue "
+            "resize "
+            "restoredefaultpath "
+            "rethrow "
+            "return "
+            "rgb2hsv "
+            "rgb2ind "
+            "rgb2ntsc "
+            "ribbon "
+            "rindex "
+            "rmappdata "
+            "rmdir "
+            "rmfield "
+            "rmpath "
+            "roots "
+            "rose "
+            "rosser "
+            "rot90 "
+            "rotdim "
+            "round "
+            "roundb "
+            "rows "
+            "rref "
+            "rsf2csf "
+            "run "
+            "run_count "
+            "run_history "
+            "run_test "
+            "rundemos "
+            "runlength "
+            "runtests "
+            "save "
+            "save_header_format_string "
+            "save_precision "
+            "saveas "
+            "saveaudio "
+            "saveimage "
+            "saveobj "
+            "savepath "
+            "saving_history "
+            "scanf "
+            "scatter "
+            "scatter3 "
+            "schur "
+            "sec "
+            "secd "
+            "sech "
+            "semicolon "
+            "semilogx "
+            "semilogxerr "
+            "semilogy "
+            "semilogyerr "
+            "set "
+            "setappdata "
+            "setaudio "
+            "setdiff "
+            "setenv "
+            "setfield "
+            "setgrent "
+            "setpwent "
+            "setstr "
+            "setxor "
+            "shading "
+            "shell_cmd "
+            "shg "
+            "shift "
+            "shiftdim "
+            "sighup_dumps_octave_core "
+            "sign "
+            "sign_test "
+            "sigterm_dumps_octave_core "
+            "silent_functions "
+            "sin "
+            "sinc "
+            "sind "
+            "sinetone "
+            "sinewave "
+            "single "
+            "sinh "
+            "size "
+            "size_equal "
+            "sizemax "
+            "sizeof "
+            "skewness "
+            "sleep "
+            "slice "
+            "sombrero "
+            "sort "
+            "sortrows "
+            "source "
+            "spalloc "
+            "sparse "
+            "sparse_auto_mutate "
+            "spatan2 "
+            "spaugment "
+            "spchol "
+            "spchol2inv "
+            "spcholinv "
+            "spconvert "
+            "spcumprod "
+            "spcumsum "
+            "spdet "
+            "spdiag "
+            "spdiags "
+            "spearman "
+            "spectral_adf "
+            "spectral_xdf "
+            "specular "
+            "speed "
+            "spencer "
+            "speye "
+            "spfind "
+            "spfun "
+            "sph2cart "
+            "sphcat "
+            "sphere "
+            "spinmap "
+            "spinv "
+            "spkron "
+            "splchol "
+            "spline "
+            "split "
+            "split_long_rows "
+            "splu "
+            "spmax "
+            "spmin "
+            "spones "
+            "spparms "
+            "spprod "
+            "spqr "
+            "sprand "
+            "sprandn "
+            "sprandsym "
+            "sprank "
+            "spring "
+            "sprintf "
+            "spstats "
+            "spsum "
+            "spsumsq "
+            "spvcat "
+            "spy "
+            "sqp "
+            "sqrt "
+            "sqrtm "
+            "squeeze "
+            "sscanf "
+            "stairs "
+            "stat "
+            "static "
+            "statistics "
+            "std "
+            "stderr "
+            "stdin "
+            "stdnormal_cdf "
+            "stdnormal_inv "
+            "stdnormal_pdf "
+            "stdnormal_rnd "
+            "stdout "
+            "stem "
+            "stem3 "
+            "stft "
+            "str2double "
+            "str2func "
+            "str2mat "
+            "str2num "
+            "strcat "
+            "strchr "
+            "strcmp "
+            "strcmpi "
+            "strerror "
+            "strfind "
+            "strftime "
+            "string_fill_char "
+            "strjust "
+            "strmatch "
+            "strncmp "
+            "strncmpi "
+            "strptime "
+            "strread "
+            "strrep "
+            "strsplit "
+            "strtok "
+            "strtrim "
+            "strtrunc "
+            "struct "
+            "struct2cell "
+            "struct_levels_to_print "
+            "structfun "
+            "strvcat "
+            "studentize "
+            "sub2ind "
+            "subplot "
+            "subsasgn "
+            "subsindex "
+            "subspace "
+            "subsref "
+            "substr "
+            "substruct "
+            "sum "
+            "summer "
+            "sumsq "
+            "superiorto "
+            "suppress_verbose_help_message "
+            "surf "
+            "surface "
+            "surfc "
+            "surfl "
+            "surfnorm "
+            "svd "
+            "svd_driver "
+            "svds "
+            "swapbytes "
+            "switch "
+            "syl "
+            "sylvester_matrix "
+            "symamd "
+            "symbfact "
+            "symlink "
+            "symrcm "
+            "symvar "
+            "synthesis "
+            "system "
+            "t_test "
+            "t_test_2 "
+            "t_test_regression "
+            "table "
+            "tan "
+            "tand "
+            "tanh "
+            "tar "
+            "tcdf "
+            "tempdir "
+            "tempname "
+            "terminal_size "
+            "test "
+            "test2 "
+            "test3 "
+            "text "
+            "textread "
+            "textscan "
+            "tic "
+            "tilde_expand "
+            "time "
+            "times "
+            "tinv "
+            "title "
+            "tmpfile "
+            "tmpnam "
+            "toascii "
+            "toc "
+            "toeplitz "
+            "tolower "
+            "toupper "
+            "tpdf "
+            "trace "
+            "transpose "
+            "trapz "
+            "treelayout "
+            "treeplot "
+            "tril "
+            "trimesh "
+            "triplequad "
+            "triplot "
+            "trisurf "
+            "triu "
+            "trnd "
+            "true "
+            "try "
+            "tsearch "
+            "tsearchn "
+            "type "
+            "typecast "
+            "typeinfo "
+            "u_test "
+            "uigetdir "
+            "uigetfile "
+            "uimenu "
+            "uint16 "
+            "uint32 "
+            "uint64 "
+            "uint8 "
+            "uiputfile "
+            "umask "
+            "uminus "
+            "uname "
+            "undo_string_escapes "
+            "unidcdf "
+            "unidinv "
+            "unidpdf "
+            "unidrnd "
+            "unifcdf "
+            "unifinv "
+            "unifpdf "
+            "unifrnd "
+            "unimplemented "
+            "union "
+            "unique "
+            "unix "
+            "unlink "
+            "unmark_command "
+            "unmark_rawcommand "
+            "unmkpp "
+            "unpack "
+            "untabify "
+            "untar "
+            "until "
+            "unwind_protect "
+            "unwind_protect_cleanup "
+            "unwrap "
+            "unzip "
+            "uplus "
+            "upper "
+            "urlread "
+            "urlwrite "
+            "usage "
+            "usleep "
+            "validatestring "
+            "values "
+            "vander "
+            "var "
+            "var_test "
+            "varargin "
+            "varargout "
+            "vec "
+            "vech "
+            "vectorize "
+            "ver "
+            "version "
+            "vertcat "
+            "view "
+            "voronoi "
+            "voronoin "
+            "waitforbuttonpress "
+            "waitpid "
+            "warning "
+            "warning_ids "
+            "warranty "
+            "wavread "
+            "wavwrite "
+            "wblcdf "
+            "wblinv "
+            "wblpdf "
+            "wblrnd "
+            "weekday "
+            "weibcdf "
+            "weibinv "
+            "weibpdf "
+            "weibrnd "
+            "welch_test "
+            "what "
+            "which "
+            "while "
+            "white "
+            "whitebg "
+            "who "
+            "whos "
+            "whos_line_format "
+            "wienrnd "
+            "wilcoxon_test "
+            "wilkinson "
+            "winter "
+            "xlabel "
+            "xlim "
+            "xor "
+            "yes_or_no "
+            "ylabel "
+            "ylim "
+            "yulewalker "
+            "z_test "
+            "z_test_2 "
+            "zeros "
+            "zip "
+            "zlabel "
+            "zlim ";
+      }
+/*            "break case catch continue do else elseif end end_unwind_protect "
+            "endfor endfunction endif endswitch endwhile for function "
+            "global if otherwise persistent return switch try until "
+            "unwind_protect unwind_protect_cleanup while";
+*/
+    return 0;
+}
+
diff --git a/gui/src/lexer/lexeroctavegui.h b/gui/src/lexer/lexeroctavegui.h
new file mode 100644
--- /dev/null
+++ b/gui/src/lexer/lexeroctavegui.h
@@ -0,0 +1,64 @@
+/* OctaveGUI - A graphical user interface for Octave
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This module is a custom lexer for QScintilla for use with the Octave-GUI.
+ * Examples for lexers can be found in the sources of Qscintilla-gpl-2.5.1,
+ * QScintilla is a port to Qt of Neil Hodgson's Scintilla C++ editor control.
+ */
+
+
+#ifndef LEXEROCTAVE_H
+#define LEXEROCTAVE_H
+
+#include <qobject.h>
+
+#include <Qsci/qsciglobal.h>
+#include <Qsci/qscilexer.h>
+
+
+class QSCINTILLA_EXPORT LexerOctaveGui : public QsciLexer
+{
+    Q_OBJECT
+
+public:
+    // the used styles
+    enum
+      {
+        Default = 0,
+        Comment = 1,
+        Command = 2,
+        Number = 3,
+        Keyword = 4,
+        SingleQuotedString = 5,
+        Operator = 6,
+        Identifier = 7,
+        DoubleQuotedString = 8
+      };
+
+    LexerOctaveGui(QObject *parent = 0);
+    virtual ~LexerOctaveGui();
+    const char *language() const;
+    const char *lexer() const;
+    QColor defaultColor(int style) const;
+    QFont defaultFont(int style) const;
+    const char *keywords(int set) const;
+    QString description(int style) const;
+
+private:
+    LexerOctaveGui(const LexerOctaveGui &);
+    LexerOctaveGui &operator=(const LexerOctaveGui &);
+};
+
+#endif
diff --git a/gui/src/qirc/IClientSocket.cpp b/gui/src/qirc/IClientSocket.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/IClientSocket.cpp
@@ -0,0 +1,289 @@
+/***************************************************************************
+                          IClientSocket.cpp  -  description
+                             -------------------
+    begin                : Fri Sep 15 2000
+    copyright            : (C) 2000 by gerardo Puga
+    email                : gere@mailroom.com
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <IClientSocket.h>
+
+#define ERROR_ICLIENTSOCKET_NOERROR		0
+#define ERROR_ICLIENTSOCKET_NOSOCKET            1
+#define ERROR_ICLIENTSOCKET_NOCONNECT           2
+#define ERROR_ICLIENTSOCKET_NORESOLV            3
+#define ERROR_ICLIENTSOCKET_NOREAD		4
+#define ERROR_ICLIENTSOCKET_NOWRITE		5
+#define ERROR_ICLIENTSOCKET_NOFCNTL		6
+
+const char *ICLIENTSOCKET_MENSAJES[] = { "Nothing has happened, boss",
+  "Can't create the socket to initiate the connection",
+  "Can't connect to the destination",
+  "Can't resolv the server name",
+  "Problems during read operation",
+  "Problems during write operation",
+  "Can't make the socket non-blocking"
+};
+
+#define ICLIENT_MAX_MENSAJE_ERROR 300
+
+char ICLIENTSOCKETmensajeError[ICLIENT_MAX_MENSAJE_ERROR + 1];
+
+void
+IClientSocket::inicializar ()
+{
+  handler = 0;
+  puerto = 0;
+  bzero ((void *) &ip, sizeof (in_addr));
+
+  conectado = false;
+  socketCreado = false;
+  blocking = true;
+  lastError = ERROR_ICLIENTSOCKET_NOERROR;
+}
+
+IClientSocket::IClientSocket ()
+{
+  inicializar ();
+}
+
+
+IClientSocket::~IClientSocket ()
+{
+  if (conectado == true)
+    {
+      close ();
+    }
+}
+
+int
+IClientSocket::getSocket ()
+{
+  return handler;
+}
+
+const char *
+IClientSocket::strError ()
+{
+  switch (lastError)
+    {
+    case ERROR_ICLIENTSOCKET_NORESOLV:
+      snprintf (ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR, "%s",
+		ICLIENTSOCKET_MENSAJES[lastError]);
+      break;
+    default:
+      snprintf (ICLIENTSOCKETmensajeError, ICLIENT_MAX_MENSAJE_ERROR,
+		"%s - %s",
+		ICLIENTSOCKET_MENSAJES[lastError],::
+		strerror (lastErrnoValue));
+      break;
+    }
+  return ICLIENTSOCKETmensajeError;
+}
+
+int
+IClientSocket::connect ()
+{
+  if (conectado == true)
+    {
+      close ();
+    }
+
+  if ((handler = socket (AF_INET, SOCK_STREAM, 0)) < 0)
+    {
+      lastError = ERROR_ICLIENTSOCKET_NOSOCKET;
+      lastErrnoValue = errno;
+      return -1;
+    }
+  socketCreado = true;
+
+  if (blocking == false)
+    {
+      if (fcntl (handler, F_SETFL, O_NONBLOCK) < 0)
+	{
+	  lastError = ERROR_ICLIENTSOCKET_NOFCNTL;
+	  lastErrnoValue = errno;
+	}
+    }
+
+  sockaddr_in addr;
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons (puerto);
+  addr.sin_addr = ip;
+  bzero (&(addr.sin_zero), 8);
+  int respuesta =::connect (handler, (sockaddr *) & addr,
+			    sizeof (sockaddr_in));
+
+  if ((respuesta == 0)
+      || ((respuesta < 0) && (errno == EINPROGRESS) && (blocking == false)))
+    {
+      conectado = true;
+    }
+  else
+    {
+      lastError = ERROR_ICLIENTSOCKET_NOCONNECT;
+      lastErrnoValue = errno;
+      return -1;
+    }
+
+  return 0;
+}
+
+
+int
+IClientSocket::connect (int socket, bool block)
+{
+  if (socketCreado)
+    {
+      close ();
+    }
+
+  handler = socket;
+  bzero ((void *) &ip, sizeof (in_addr));
+
+  conectado = true;
+  socketCreado = true;
+  blocking = block;
+  lastError = 0;
+
+  if (block == false)
+    {
+      fcntl (handler, F_SETFL, O_NONBLOCK);
+    }
+
+  return 0;
+}
+
+int
+IClientSocket::connect (in_addr addr, unsigned int p, bool block)
+{
+  if (socketCreado == true)
+    {
+      close ();
+    }
+
+  ip = addr;
+  puerto = p;
+  blocking = block;
+
+  return connect ();
+}
+
+int
+IClientSocket::connect (const char *server, unsigned int p, bool block)
+{
+  if (socketCreado == true)
+    {
+      close ();
+    }
+
+  puerto = p;
+  blocking = block;
+
+  if (resolv (server, &ip) < 0)
+    {
+      lastError = ERROR_ICLIENTSOCKET_NORESOLV;
+      return -1;
+    }
+  return connect ();
+}
+
+long int
+IClientSocket::read (char *data, long count)
+{
+  long done = 0;
+  long res = 0;
+
+  do
+    {
+      res = recv (handler, data + done, count - done, 0);
+
+      if (res > 0)
+	{
+	  done += res;
+	}
+    }
+  while ((((done < count) && (res > 0)) && (blocking == true))
+	 || ((res < 0) && (errno == EINTR)));
+
+  if (res < 0)
+    {
+      if (errno == EWOULDBLOCK)
+	{
+	  return 0;
+	}
+      else
+	{
+	  lastError = ERROR_ICLIENTSOCKET_NOREAD;
+	  lastErrnoValue = errno;
+	  return -1;
+	}
+    }
+  else
+    {
+      return done;
+    }
+}
+
+long
+IClientSocket::write (const char *data, long count)
+{
+  long sent = 0;
+  long response = 0;
+
+  do
+    {
+      response = send (handler, data + sent, count - sent, 0);
+
+      if (response > 0)
+	{
+	  sent += response;
+	}
+    }
+  while (((sent < count) && (response >= 0))
+	 || ((response < 0) && (errno == EWOULDBLOCK)));
+
+  if (response < 0)
+    {
+      lastError = ERROR_ICLIENTSOCKET_NOWRITE;
+      lastErrnoValue = errno;
+      return -1;
+    }
+  return sent;
+}
+
+void
+IClientSocket::close ()
+{
+  if (socketCreado == true)
+    {
+      ::close (handler);
+      conectado = false;
+      socketCreado = false;
+      blocking = true;
+    }
+}
+
+int
+IClientSocket::resolv (const char *fqdn, in_addr * ip)
+{
+  hostent *host;
+  host = gethostbyname (fqdn);
+  if (host == NULL)
+    {
+      return -1;
+    }
+
+  bcopy ((void *) host->h_addr, (void *) ip, sizeof (in_addr));
+  return 0;
+}
diff --git a/gui/src/qirc/IClientSocket.h b/gui/src/qirc/IClientSocket.h
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/IClientSocket.h
@@ -0,0 +1,68 @@
+/***************************************************************************
+                          IClientSocket.h  -  description
+                             -------------------
+    begin                : Fri Sep 15 2000
+    copyright            : (C) 2000 by gerardo Puga
+    email                : gere@mailroom.com
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef  ICLIENTSOCKET_H
+#define ICLIENTSOCKET_H
+
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+class IClientSocket
+{
+private:
+  int handler;
+  in_addr ip;
+  unsigned int puerto;
+
+  int lastError, lastErrnoValue;
+
+  bool conectado;
+  bool socketCreado;
+  bool blocking;
+
+  void inicializar ();
+  int connect ();
+
+public:
+    IClientSocket ();
+   ~IClientSocket ();
+
+  int getSocket ();
+  const char *strError ();
+
+  int connect (int socket, bool block = true);
+  int connect (in_addr addr, unsigned int puerto, bool blocking = true);
+  int connect (const char *server, unsigned int puerto, bool blocking = true);
+
+  long int read (char *, long count);
+  long int write (const char *, long count);
+
+  void close ();
+
+  int resolv (const char *fqdn, in_addr * ip);
+};
+
+#endif
diff --git a/gui/src/qirc/IRCClient.cpp b/gui/src/qirc/IRCClient.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/IRCClient.cpp
@@ -0,0 +1,576 @@
+/***************************************************************************
+                          IRCClient.cpp  -  description
+                             -------------------
+    begin                : Sun Sep 17 2000
+    copyright            : (C) 2000 by gerardo Puga
+    email                : gere@mailroom.com
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "IRCClient.h"
+
+#include <string.h>
+#include <stdlib.h>
+
+void
+IRCClient::handleIncomingLine ()
+{
+  IRCEvent evento (lines);
+  emit event (&evento);
+  if (evento.isNumeric () == true)
+    {
+      if (evento.getNumeric () == RPL_WELCOME)
+	{
+	  m_loggedIn = true;
+	  emit completedLogin (m_nickInUse.toStdString ().c_str ());
+	}
+      else if ((evento.getNumeric () == ERR_NICKNAMEINUSE)
+	       && (m_loggedIn == false))
+	{
+	  if (testedNicks == 50)
+	    {
+	      emit
+		connectionStatus ("Nicknames in use, aborting connection.");
+	      disconnectFromServer ();
+	    }
+	  else
+	    {
+	      emit connectionStatus (QString ("Nickname %1 is in use.").
+				     arg (m_nickInUse).toStdString ().
+				     c_str ());
+	      setNickInUse (QString ("%1%2").arg (m_nick1).arg (testedNicks));
+	      sendCommand (1, COMMAND_NICK,
+			   m_nickInUse.toStdString ().c_str ());
+	      testedNicks++;
+	    }
+	}
+      else if (evento.getNumeric () == ERR_PASSWDMISMATCH)
+	{
+	  emit
+	    connectionStatus ("The password you provided seems to be wrong.");
+	}
+      else
+	{
+	  emit replyCode (&evento);
+	}
+      return;
+    }
+
+  QString command = evento.getCommand ();
+
+  if (command == COMMAND_NICK)
+    {
+      emit nick (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
+
+      if (evento.getNick () == nickInUse ())
+	setNickInUse (evento.getParam (0));
+
+      return;
+    }
+  else if (command == COMMAND_QUIT)
+    {
+      emit quit (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_JOIN)
+    {
+      emit join (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PART)
+    {
+      emit part (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str (),
+		 evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_MODE)
+    {
+      emit mode (&evento);
+      return;
+    }
+  else if (command == COMMAND_TOPIC)
+    {
+      emit topic (evento.getNick ().toStdString ().c_str (),
+		  evento.getParam (0).toStdString ().c_str (),
+		  evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_KICK)
+    {
+      emit kick (evento.getNick ().toStdString ().c_str (),
+		 evento.getParam (0).toStdString ().c_str (),
+		 evento.getParam (1).toStdString ().c_str (),
+		 evento.getParam (2).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_INVITE)
+    {
+      emit invite (evento.getNick ().toStdString ().c_str (),
+		   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PRIVMSG)
+    {
+      emit privateMessage (evento.getNick ().toStdString ().c_str (),
+			   evento.getParam (0).toStdString ().c_str (),
+			   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_NOTICE)
+    {
+      emit notice (evento.getNick ().toStdString ().c_str (),
+		   evento.getParam (0).toStdString ().c_str (),
+		   evento.getParam (1).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_PING)
+    {
+      if (m_automaticPong == true)
+	{
+	  sendCommand (1, COMMAND_PONG, m_nickInUse.toStdString ().c_str ());
+	}
+      emit ping (evento.getParam (0).toStdString ().c_str ());
+      return;
+    }
+  else if (command == COMMAND_ERROR)
+    {
+      emit error (evento.getParam (0).toStdString ().c_str ());
+      terminateConnection ();
+      return;
+    }
+  else
+    {
+      emit notRecognized (&evento);
+    }
+}
+
+IRCClient::IRCClient (bool autoPong)
+{
+  m_clientSocket = new IClientSocket ();
+  m_connected = false;
+  m_loggedIn = false;
+  lines[0] = 0;
+  longitud = 0;
+
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_automaticPong = autoPong;
+}
+
+IRCClient::~IRCClient ()
+{
+  disconnectFromServer ();
+  delete m_clientSocket;
+}
+
+int
+IRCClient::getSocket ()
+{
+  return m_clientSocket->getSocket ();
+}
+
+bool
+IRCClient::setAutoPong (bool aP)
+{
+  return (m_automaticPong = aP);
+}
+
+void
+IRCClient::initializeReadingSocket (int socketHandler)
+{
+  Q_UNUSED (socketHandler);
+  int error = 0;
+  bool moreThanOne = false;
+  char c;
+
+  while ((m_connected == true)
+	 && ((error = m_clientSocket->read (&c, 1)) > 0))
+    {
+      if ((longitud < 510) && (c != 10) && (c != 13))
+	{
+	  lines[longitud] = c;
+	  lines[longitud + 1] = 0;
+	  longitud++;
+	}
+
+      if (((c == 10) || (c == 13)) && (longitud > 0))
+	{
+	  handleIncomingLine ();
+	  lines[0] = 0;
+	  longitud = 0;
+	}
+      moreThanOne = true;
+    }
+
+  if ((error == 0) && (moreThanOne == false))
+    {
+      terminateConnection ();
+    }
+
+  if ((error < 0) && (m_connected == true))
+    {
+      terminateConnection ();
+    }
+}
+
+void
+IRCClient::initializeWritingSocket (int socketHandler)
+{
+  Q_UNUSED (socketHandler);
+  m_writeSocketNotifier->setEnabled (false);
+  int resultado = 0;
+  socklen_t l = sizeof (resultado);
+  getsockopt (m_clientSocket->getSocket (), SOL_SOCKET, SO_ERROR, &resultado,
+	      &l);
+  if (resultado != 0)
+    {
+      emit
+	connectionStatus
+	("<font color=\"#990000\"><b>Connection failed.</b></font>");
+      terminateConnection ();
+    }
+  else
+    {
+      emit
+	connectionStatus
+	("<font color=\"#00AA00\"><b>Connection to server established.</b></font>");
+      m_connected = true;
+      m_readSocketNotifier->setEnabled (true);
+      emit establishedConnection ();
+      setNickInUse (m_nick1);
+      m_loggedIn = false;
+
+      emit connectionStatus (QString ("Attempting to login as %1.").
+			     arg (m_nickInUse).toStdString ().c_str ());
+      if (m_password.isNull () == false)
+	{
+	  sendCommand (1, COMMAND_PASS, m_password.toStdString ().c_str ());
+	}
+      sendCommand (4, COMMAND_USER, m_userName.toStdString ().c_str (),
+		   "0", "0", m_realName.toStdString ().c_str ());
+      sendCommand (1, COMMAND_NICK, m_nickInUse.toStdString ().c_str ());
+
+      testedNicks = 1;
+    }
+}
+
+void
+IRCClient::sendNickChange (QString nick)
+{
+  sendCommand (1, COMMAND_NICK, nick.toStdString ().c_str ());
+}
+
+void
+IRCClient::joinChannel (QString channel)
+{
+  emit connectionStatus (QString ("Joining channel %1.").arg (channel).
+			 toStdString ().c_str ());
+  sendCommand (1, COMMAND_JOIN, channel.toStdString ().c_str ());
+  m_recentChannel = channel;
+}
+
+void
+IRCClient::sendPublicMessage (QString message)
+{
+  sendCommand (2, COMMAND_PRIVMSG, m_recentChannel.toStdString ().c_str (),
+               message.toStdString ().c_str ());
+}
+
+void
+IRCClient::connectToServer (const char *server,
+			    int puerto,
+			    const char *nick1,
+			    const char *nick2,
+			    const char *user,
+			    const char *realName, const char *pass, int flags)
+{
+  Q_UNUSED (flags);
+  if (m_readSocketNotifier != NULL)
+    {
+      if (m_connected == true)
+	{
+	  disconnectFromServer ();
+	}
+      else
+	{
+	  terminateConnection ();
+	}
+    }
+
+  m_connected = false;
+  IRCClient::m_nick1 = nick1;
+  IRCClient::m_nick2 = nick2;
+  IRCClient::m_userName = user;
+  IRCClient::m_password = pass;
+  IRCClient::m_realName = realName;
+
+  if (m_clientSocket->connect (server, puerto, false) < 0)
+    {
+      emit
+	connectionStatus
+	("Can't resolve the server name. Connection aborted.");
+      return;
+    }
+
+  m_writeSocketNotifier =
+    new QSocketNotifier (m_clientSocket->getSocket (), QSocketNotifier::Write,
+			 this);
+  m_writeSocketNotifier->setEnabled (true);
+  connect (m_writeSocketNotifier, SIGNAL (activated (int)), this,
+	   SLOT (initializeWritingSocket (int)));
+
+  m_readSocketNotifier =
+    new QSocketNotifier (m_clientSocket->getSocket (), QSocketNotifier::Read,
+			 this);
+  m_readSocketNotifier->setEnabled (false);
+  connect (m_readSocketNotifier, SIGNAL (activated (int)), this,
+	   SLOT (initializeReadingSocket (int)));
+  emit connectionStatus ("Trying to connect to IRC server, please wait..");
+}
+
+void
+IRCClient::disconnectFromServer (const char *razon)
+{
+  lines[0] = 0;
+  longitud = 0;
+
+  if (m_readSocketNotifier == NULL)
+    return;
+
+  if (m_connected)
+    {
+      if (razon == 0)
+	{
+	  sendCommand (0, COMMAND_QUIT);
+	}
+      else
+	{
+	  sendCommand (1, COMMAND_QUIT, razon);
+	}
+    }
+
+  delete m_readSocketNotifier;
+  delete m_writeSocketNotifier;
+
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_clientSocket->close ();
+  m_connected = m_loggedIn = false;
+  emit disconnected ();
+}
+
+void
+IRCClient::terminateConnection ()
+{
+  if (m_readSocketNotifier == NULL)
+    return;
+
+  delete m_readSocketNotifier;
+  delete m_writeSocketNotifier;
+  m_readSocketNotifier = m_writeSocketNotifier = NULL;
+  m_clientSocket->close ();
+  m_connected = m_loggedIn = false;
+  emit disconnected ();
+}
+
+
+void
+IRCClient::sendLine (const char *line)
+{
+  QString msg = QString ("%1%2").arg (line).arg (CRLF);
+  m_clientSocket->write (msg.toStdString ().c_str (), msg.length ());
+}
+
+void
+IRCClient::sendCommand (int numberOfCommands, const char *command, ...)
+{
+  char linea[513];
+  char *parametro;
+  va_list lp;
+
+  strncpy (linea, command, 512);
+  linea[512] = 0;
+  va_start (lp, command);
+  for (int i = 0; i < numberOfCommands; i++)
+    {
+      if (i == 15)
+	break;
+      parametro = va_arg (lp, char *);
+      if (i == numberOfCommands - 1)
+	{
+	  if (strlen (linea) + strlen (parametro) + 2 > 512)
+	    break;
+	  if (strchr (parametro, ' ') != NULL)
+	    {
+	      strcat (linea, " :");
+	    }
+	  else
+	    {
+	      strcat (linea, " ");
+	    }
+	  strcat (linea, parametro);
+	}
+      else
+	{
+	  if (strlen (linea) + strlen (parametro) + 1 > 512)
+	    break;
+	  strcat (linea, " ");
+	  strcat (linea, parametro);
+	}
+    }
+  va_end (lp);
+  sendLine (linea);
+}
+
+
+// ************************** IRCEvent **********************
+
+IRCEvent::IRCEvent (const char *serverMessage)
+{
+  char prefix[MAX_LINE_LEN];
+  int index = 0;
+
+  nick = "";
+  user = "";
+  host = "";
+  for (int i = 0; i < 15; i++)
+    {
+      param[i] = "";
+    }
+
+  if (serverMessage[0] == CHR_COLON)
+    {
+      index++;
+      strcpy (prefix,
+	      getStringToken (serverMessage, index).toStdString ().c_str ());
+
+      int etapa = 0;
+      for (unsigned int i = 0; i < strlen (prefix); i++)
+	{
+	  switch (prefix[i])
+	    {
+	    case '!':
+	      etapa = 1;
+	      break;
+	    case '@':
+	      etapa = 2;
+	      break;
+	    default:
+	      switch (etapa)
+		{
+		case 0:
+		  nick += prefix[i];
+		  break;
+		case 1:
+		  user += prefix[i];
+		  break;
+		default:
+		  host += prefix[i];
+		  break;
+		}
+	    }
+	}
+    }
+
+  command = getStringToken (serverMessage, index);
+  command = command.toUpper ();
+
+  paramCount = 0;
+  while (serverMessage[index] != 0)
+    {
+      if ((serverMessage[index] == CHR_COLON) || (paramCount == 14))
+	{
+
+	  if (serverMessage[index] == CHR_COLON)
+	    {
+	      index++;
+	    }
+
+	  param[paramCount] = (const char *) (serverMessage + index);
+	  index += strlen (serverMessage + index);
+	}
+      else
+	{
+	  param[paramCount] = getStringToken (serverMessage, index);
+	}
+      paramCount++;
+    }
+
+  if (strlen (command.toStdString ().c_str ()) ==
+      strspn (command.toStdString ().c_str (), DIGITS))
+    {
+      numeric = true;
+      codeNumber = atoi (command.toStdString ().c_str ());
+    }
+  else
+    {
+      numeric = false;
+    }
+}
+
+int
+IRCEvent::getNumeric ()
+{
+  if (!numeric)
+    {
+      return -1;
+    }
+  else
+    {
+      return codeNumber;
+    }
+}
+
+QString
+IRCEvent::getParam (int index)
+{
+  if ((index < 0) || (index > 14))
+    {
+      return QString ();
+    }
+  else
+    {
+      return param[index];
+    }
+}
+
+int
+IRCEvent::skipSpaces (const char *line, int &index)
+{
+  while (line[index] == CHR_SPACE)
+    {
+      index++;
+    }
+  return index;
+}
+
+QString
+IRCEvent::getStringToken (const char *line, int &index)
+{
+  QString token ("");
+  skipSpaces (line, index);
+  while ((line[index] != CHR_SPACE) && (line[index] != CHR_ZERO))
+    {
+      token += line[index];
+      index++;
+    }
+
+  skipSpaces (line, index);
+  return token;
+}
+
+QString
+IRCEvent::getStringToken (QString line, int &index)
+{
+  return getStringToken (line.toStdString ().c_str (), index);
+}
diff --git a/gui/src/qirc/IRCClient.h b/gui/src/qirc/IRCClient.h
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/IRCClient.h
@@ -0,0 +1,171 @@
+/***************************************************************************
+                          IRCClient.h  -  description
+                             -------------------
+    begin                : Sun Sep 17 2000
+    copyright            : (C) 2000 by gerardo Puga
+    email                : gere@mailroom.com
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef IRCCLIENT_H
+#define IRCCLIENT_H
+
+#include <QObject>
+#include <QSocketNotifier>
+#include "IClientSocket.h"
+#include "IRCCodes.h"
+#include <stdarg.h>
+
+#define MAX_LINE_LEN 512
+#define PARAM_MAX_COUNT 15
+#define CHR_COLON ':'
+#define CHR_SPACE ' '
+#define CHR_ZERO '\0'
+#ifdef Q_OS_LINUX
+#define CRLF "\n"
+#else
+#define CRLF "\r\n"
+#endif
+#define DIGITS	"0123456789"
+
+class IRCEvent
+{
+private:
+  int codeNumber;
+  bool numeric;
+
+  QString nick, user, host;
+  QString command;
+  int paramCount;
+  QString param[PARAM_MAX_COUNT];
+
+protected:
+  int skipSpaces (const char *linea, int &index);
+  QString getStringToken (const char *linea, int &index);
+  QString getStringToken (QString linea, int &index);
+
+public:
+    IRCEvent (const char *serverMessage);
+
+  bool isNumeric ()
+  {
+    return numeric;
+  }
+
+  QString getNick ()
+  {
+    return nick;
+  }
+  QString getUser ()
+  {
+    return user;
+  }
+  QString getHost ()
+  {
+    return host;
+  }
+  QString getCommand ()
+  {
+    return command;
+  }
+  int getNumeric ();
+
+  int getParamCount ()
+  {
+    return paramCount;
+  }
+  QString getParam (int index);
+};
+
+class IRCClient:public QObject
+{
+Q_OBJECT public:
+  IRCClient (bool autoPong = true);
+  ~IRCClient ();
+
+  int getSocket ();
+  bool setAutoPong (bool aP);
+
+  void connectToServer (const char *server, int puerto, const char *m_nick1,
+			const char *m_nick2, const char *m_userName,
+			const char *m_realName, const char *m_password,
+			int flags);
+  void disconnectFromServer (const char *razon = 0);
+  void terminateConnection ();
+
+  void sendLine (const char *lines);
+  void sendCommand (int numberOfCommands, const char *command, ...);
+
+  QString nickInUse ()
+  {
+    return m_nickInUse;
+  }
+  void sendNickChange (QString nick);
+  void joinChannel (QString channel);
+  void sendPublicMessage (QString message);
+
+  protected slots:void initializeReadingSocket (int);
+  void initializeWritingSocket (int);
+
+signals:
+  void establishedConnection ();
+  void connectionStatus (const char *mensaje);
+  void completedLogin (const char *nick);
+  void disconnected ();
+
+  void event (IRCEvent * ircEvent);
+  void notRecognized (IRCEvent * e);
+  void replyCode (IRCEvent *);
+
+  void nick (const char *nick, const char *newNick);
+  void quit (const char *nick, const char *razon);
+  void join (const char *nick, const char *canal);
+  void part (const char *nick, const char *canal, const char *mensaje);
+  void mode (IRCEvent * evento);
+  void topic (const char *nick, const char *canal, const char *topic);
+  void invite (const char *nick, const char *canal);
+  void kick (const char *nick, const char *canal, const char *echado,
+	     const char *razon);
+
+  void privateMessage (const char *nick, const char *destino,
+		       const char *mensaje);
+  void notice (const char *nick, const char *destino, const char *mensaje);
+
+  void ping (const char *server);
+  void error (const char *mensaje);
+
+  void nickInUseChanged ();
+
+private:
+  void setNickInUse (QString nick)
+  {
+    m_nickInUse = nick;
+    emit nickInUseChanged ();
+  }
+  void handleIncomingLine ();
+
+  bool m_connected;
+  bool m_loggedIn;
+  int testedNicks;
+
+  char lines[MAX_LINE_LEN + 1];	// 513 ( para darle espacio al 0 )
+  int longitud;
+  IClientSocket *m_clientSocket;
+
+  QSocketNotifier *m_readSocketNotifier, *m_writeSocketNotifier;
+
+  QString m_nick1, m_nick2, m_password;
+  QString m_nickInUse, m_userName, m_realName;
+  QString m_recentChannel;
+  bool m_automaticPong;
+};
+
+#endif
diff --git a/gui/src/qirc/IRCCodes.h b/gui/src/qirc/IRCCodes.h
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/IRCCodes.h
@@ -0,0 +1,222 @@
+/***************************************************************************
+                          IRCCodes.h  -  description
+                             -------------------
+    begin                : Mon Sep 18 2000
+    copyright            : (C) 2000 by gerardo Puga
+    email                : gere@mailroom.com
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef IRCCODES_H
+#define IRCCODES_H
+
+// *********                                                     ***********
+// ************************  as seen on the RFC 2812 ***********************
+// *********                                                     ***********
+
+// COMMAND STRINGS
+// - connection registration
+#define COMMAND_PASS		 "PASS"
+#define COMMAND_NICK 		 "NICK"
+#define COMMAND_USER		 "USER"
+#define COMMAND_OPER		 "OPER"
+#define COMMAND_SERVICE  "SERVICE"
+#define COMMAND_QUIT		 "QUIT"
+#define COMMAND_SQUIT		 "SQUIT"
+// - channel operations
+#define COMMAND_JOIN		 "JOIN"
+#define COMMAND_PART 		 "PART"
+#define COMMAND_MODE		 "MODE"
+#define COMMAND_TOPIC		 "TOPIC"
+#define COMMAND_NAMES		 "NAMES"
+#define COMMAND_LIST		 "LIST"
+#define COMMAND_INVITE	 "INVITE"
+#define COMMAND_KICK		 "KICK"
+// - sending messages
+#define COMMAND_PRIVMSG  "PRIVMSG"
+#define COMMAND_NOTICE   "NOTICE"
+// - server queries and commands
+#define COMMAND_MOTD		 "MOTD"
+#define COMMAND_LUSERS	 "LUSERS"
+#define COMMAND_VERSION	 "VERSION"
+#define COMMAND_STATS		 "STATS"
+#define COMMAND_LINKS		 "LINKS"
+#define COMMAND_TIME		 "TIME"
+#define COMMAND_CONNECT  "CONNECT"
+#define COMMAND_TRACE    "TRACE"
+#define COMMAND_ADMIN    "ADMIN"
+#define COMMAND_INFO		 "INFO"
+// - service query and commands
+#define COMMAND_SERVLIST "SERVLIST"
+#define COMMAND_SQUERY	 "SQUERY"
+// - user based queries
+#define COMMAND_WHO			 "WHO"
+#define COMMAND_WHOIS		 "WHOIS"
+#define COMMAND_WHOWAS	 "WHOWAS"
+// - miscellaneous messages
+#define COMMAND_KILL		 "KILL"
+#define COMMAND_PING		 "PING"
+#define COMMAND_PONG		 "PONG"
+#define COMMAND_ERROR		 "ERROR"
+// - optional features
+#define COMMAND_AWAY		 "AWAY"
+#define COMMAND_REHASH	 "REHASH"
+#define COMMAND_DIE			 "DIE"
+#define COMMAND_RESTART  "RESTART"
+#define COMMAND_SUMMON	 "SUMMON"
+#define COMMAND_USERS		 "USERS"
+#define COMMAND_OPERWALL "OPERWALL"
+#define COMMAND_USERHOST "USERHOST"
+#define COMMAND_ISON		 "ISON"
+
+// COMMAND REPLIES
+
+#define RPL_WELCOME				1
+#define RPL_YOURHOST			2
+#define RPL_CREATED				3
+#define RPL_MYINFO        4
+#define RPL_RPLBOUNCE     5
+#define RPL_USERHOST      302
+#define RPL_ISON          303
+#define RPL_AWAY          301
+#define RPL_UNAWAY        305
+#define RPL_NOWAWAY       306
+#define RPL_HWOISUSER     311
+#define RPL_WHOISSERVER   312
+#define RPL_WHOISOPERATOR 313
+#define RPL_WHOISIDLE     317
+#define RPL_ENOFWHOIS     318
+#define RPL_WHOISCHANNELS 319
+#define RPL_WHOWASUSER    314
+#define RPL_ENDOFWHOWAS   369
+#define RPL_LISTSTART     321
+#define RPL_LIST          322
+#define RPL_LISTEND       323
+#define RPL_UNIQOPIS      325
+#define RPL_CHANNELMODEIS 324
+#define RPL_NOTOPIC       331
+#define RPL_TOPIC         332
+#define RPL_INVITING      341
+#define RPL_SUMMONING     342
+#define RPL_INVITELIST    346
+#define RPL_ENDOFINVITELIST 347
+#define RPL_EXCEPTLIST    348
+#define RPL_ENDOFEXCEPTLIST 349
+#define RPL_VERSION       351
+#define RPL_WHOREPLY      352
+#define RPL_ENDOFWHO      315
+#define RPL_NAMREPLY      353
+#define RPL_ENDOFNAMES    366
+#define RPL_LINKS         364
+#define RPL_ENDOFLINKS    367
+#define RPL_BANLIST       368
+#define RPL_INFO          371
+#define RPL_ENDOFINFO     374
+#define RPL_MOTDSTART     375
+#define RPL_MOTD          372
+#define RPL_ENDOFMOTD     376
+#define RPL_YOUREOPER     381
+#define RPL_REHASHING     382
+#define RPL_YOURESERVICE  383
+#define RPL_TIME          391
+#define RPL_USERSSTART    392
+#define RPL_USERS         393
+#define RPL_ENDOFUSERS    394
+#define RPL_NOUSERS       395
+#define RPL_TRACELINK				200
+#define RPL_TRACECONNECTING 201
+#define RPL_TRACEHANDSHAKE	202
+#define RPL_TRACEUNKNOWN    203
+#define RPL_TRACEOPERATOR   204
+#define RPL_TRACEUSER       205
+#define RPL_TRACESERVER     206
+#define RPL_TRACESERVICE    207
+#define RPL_TRACENEWTYPE    208
+#define RPL_TRACECLASS      209
+#define RPL_TRACECONNECT    210
+#define RPL_TRACELOG        261
+#define RPL_TRACEEND        262
+#define RPL_STATSLINKINFO   211
+#define RPL_STATSCOMMANDS   212
+#define RPL_ENDOFSTATS      219
+#define RPL_STATSUPTIME     242
+#define RPL_STATSONLINE     243
+#define RPL_UMODEIS         221
+#define RPL_SERVLIST        234
+#define RPL_SERVLISTEND     235
+#define RPL_LUSERCLIENT     251
+#define RPL_LUSEROP         252
+#define RPL_LUSERUNKNOWN    253
+#define RPL_LUSERCHANNELS   254
+#define RPL_LUSERME         255
+#define RPL_ADMINME         256
+#define RPL_ADMINLOC1       257
+#define RPL_ADMINLOC2       258
+#define RPL_ADMINEMAIL      259
+#define RPL_TRYAGAIN        263
+
+// ERRROR REPLIES
+
+#define ERR_NOSUCHNICK      401
+#define ERR_NOSUCHSERVER    402
+#define ERR_NOSUCHCHANNEL   403
+#define ERR_CANNOTSENDTOCHAN 404
+#define ERR_TOOMANYCHANNELS 405
+#define ERR_WASNOSUCHNICK   406
+#define ERR_TOOMANYTARGETS  407
+#define ERR_NOSUCHSERVICE   408
+#define ERR_NOORIGIN        409
+#define ERR_NORECPIENT      411
+#define ERR_NOTEXTTOSEND    412
+#define ERR_NOTOPLEVEL      413
+#define ERR_WILDTOPLEVEL    414
+#define ERR_BADMASK         415
+#define ERR_UNKNOWNCOMMAND  421
+#define ERR_NOMOTD          422
+#define ERR_NOADMININFO     423
+#define ERR_FILEERROR       424
+#define ERR_NONICKNAMEGIVEN 431
+#define ERR_ERRONEUSNICKNAME 432
+#define ERR_NICKNAMEINUSE   433
+#define ERR_NICKCOLLISION   436
+#define ERR_UNAVAILRESOURCE 437
+#define ERR_USERNOTINCHANNEL 441
+#define ERR_NOTONCHANNEL    442
+#define ERR_USERONCHANNEL   443
+#define ERR_NOLOGIN         444
+#define ERR_SUMMONDISABLED  445
+#define ERR_USERSDISABLED   446
+#define ERR_NOTREGISTERED   451
+#define ERR_NEEDMOREPARAMS  461
+#define ERR_ALREADYREGISTRED 462
+#define ERR_NOPERMFORHOST   463
+#define ERR_PASSWDMISMATCH  464
+#define ERR_YOUREBANNEDCREEP 465
+#define ERR_YOUWILLBEBANNED 466
+#define ERR_KEYSET          467
+#define ERR_CHANNELISFULL   471
+#define ERR_UNKNOWNMODE     472
+#define ERR_INVITEONLYCHANNEL 473
+#define ERR_BANNEDFROMCHAN  474
+#define ERR_BADCHANNELKEY   475
+#define ERR_BADCHANMASK     476
+#define ERR_NOCHANMODES     477
+#define ERR_BANLISTFULL     478
+#define ERR_NOPRIVILEGES    481
+#define ERR_CHANOPPRIVNEEDED 482
+#define ERR_CANTKILLSERVER  483
+#define ERR_RESTRICTED      484
+#define ERR_UNIQOPPRIVSNEEDED 485
+#define ERR_NOOPERHOST      491
+#define ERR_UMODELUNKNOWNFLAG 501
+#define ERR_USERSDONTMATCH  502
+
+#endif
diff --git a/gui/src/qirc/Makefile.am b/gui/src/qirc/Makefile.am
new file mode 100644
--- /dev/null
+++ b/gui/src/qirc/Makefile.am
@@ -0,0 +1,34 @@
+####### kdevelop will overwrite this part!!! (begin)##########
+bin_PROGRAMS = qirc
+  qirc_SOURCES =
+  programcommand.cpp newtab.cpp MainTab.cpp notifyshowcase.cpp channellist.
+  cpp dccget.cpp dccsend.cpp IServerSocket.cpp general.cpp listanicks.
+  cpp qirc.cpp ventanas.cpp inputBox.cpp cuadroListaNicks.
+  cpp cuadroConfiguracion.cpp cuadroConectarCon.cpp colamensajes.
+  cpp IRCClient.cpp IClientSocket.cpp Config.cpp ChatView.cpp main.
+  cpp qirc_LDADD = -lqt - lXext - lX11 $ (LIBSOCKET) SUBDIRS =
+  docs EXTRA_DIST =
+  main.cpp qirc.h ChatView.cpp ChatView.h Config.cpp Config.h IClientSocket.
+  cpp IClientSocket.h IRCClient.cpp IRCClient.h IRCCodes.h colamensajes.
+  cpp colamensajes.h cuadroConectarCon.cpp cuadroConectarCon.
+  h cuadroConfiguracion.cpp cuadroConfiguracion.h cuadroListaNicks.
+  cpp cuadroListaNicks.h inputBox.cpp inputBox.h ventanas.cpp ventanas.h qirc.
+  cpp resource.h qirc16x16.xpm qirc32x32.xpm qirc64x64.xpm listanicks.
+  cpp listanicks.h general.h general.cpp IServerSocket.cpp IServerSocket.
+  h dccsend.cpp dccsend.h dccget.cpp dccget.h connect.xpm dccsend.xpm help.
+  xpm connectto.xpm disconnect.xpm join.xpm part.xpm list.xpm channellist.
+  cpp channellist.h notifyshowcase.cpp notifyshowcase.h offline.xpm online.
+  xpm operator.xpm justconn.xpm MainTab.cpp MainTab.h newtab.cpp newtab.
+  h leftArrowDisabled.xpm leftArrowEnabled.xpm rightArrowDisabled.
+  xpm rightArrowEnabled.xpm tabLeft.xpm tabMiddle.xpm tabRight.xpm tabClose.
+  xpm programcommand.cpp programcommand.h
+####### kdevelop will overwrite this part!!! (end)############
+#set the include path for X, qt and KDE
+  INCLUDES = $ (all_includes)
+#claim, which subdirectories you want to install
+#you can add here more. This one gets installed
+  bin_PROGRAMS = qirc qirc_METASOURCES = USE_AUTOMOC
+#the library search path.
+  qirc_LDFLAGS = $ (all_libraries)
+#them while "make clean", use CLEANFILES
+  DISTCLEANFILES = $ (qirc_METASOURCES)
diff --git a/gui/src/terminal/Character.h b/gui/src/terminal/Character.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Character.h
@@ -0,0 +1,228 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+    
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef CHARACTER_H
+#define CHARACTER_H
+
+// Qt
+#include <QtCore/QHash>
+
+// Local
+#include "CharacterColor.h"
+
+typedef unsigned char LineProperty;
+
+static const int LINE_DEFAULT = 0;
+static const int LINE_WRAPPED = (1 << 0);
+static const int LINE_DOUBLEWIDTH = (1 << 1);
+static const int LINE_DOUBLEHEIGHT = (1 << 2);
+
+#define DEFAULT_RENDITION  0
+#define RE_BOLD            (1 << 0)
+#define RE_BLINK           (1 << 1)
+#define RE_UNDERLINE       (1 << 2)
+#define RE_REVERSE         (1 << 3)	// Screen only
+#define RE_INTENSIVE       (1 << 3)	// Widget only
+#define RE_CURSOR          (1 << 4)
+#define RE_EXTENDED_CHAR   (1 << 5)
+
+/**
+ * A single character in the terminal which consists of a unicode character
+ * value, foreground and background colors and a set of rendition attributes
+ * which specify how it should be drawn.
+ */
+class Character
+{
+public:
+  /** 
+   * Constructs a new character.
+   *
+   * @param _c The unicode character value of this character.
+   * @param _f The foreground color used to draw the character.
+   * @param _b The color used to draw the character's background.
+   * @param _r A set of rendition flags which specify how this character is to be drawn.
+   */
+inline Character (quint16 _c = ' ', CharacterColor _f = CharacterColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR), CharacterColor _b = CharacterColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR), quint8 _r = DEFAULT_RENDITION):character (_c), rendition (_r), foregroundColor (_f),
+    backgroundColor
+    (_b)
+  {
+  }
+
+  union
+  {
+    /** The unicode character value for this character. */
+    quint16 character;
+    /** 
+     * Experimental addition which allows a single Character instance to contain more than
+     * one unicode character.
+     *
+     * charSequence is a hash code which can be used to look up the unicode
+     * character sequence in the ExtendedCharTable used to create the sequence.
+     */
+    quint16 charSequence;
+  };
+
+  /** A combination of RENDITION flags which specify options for drawing the character. */
+  quint8 rendition;
+
+  /** The foreground color used to draw this character. */
+  CharacterColor foregroundColor;
+  /** The color used to draw this character's background. */
+  CharacterColor backgroundColor;
+
+  /** 
+   * Returns true if this character has a transparent background when
+   * it is drawn with the specified @p palette.
+   */
+  bool isTransparent (const ColorEntry * palette) const;
+  /**
+   * Returns true if this character should always be drawn in bold when
+   * it is drawn with the specified @p palette, independent of whether
+   * or not the character has the RE_BOLD rendition flag. 
+   */
+  ColorEntry::FontWeight fontWeight (const ColorEntry * base) const;
+
+  /** 
+   * returns true if the format (color, rendition flag) of the compared characters is equal
+   */
+  bool equalsFormat (const Character & other) const;
+
+  /** 
+   * Compares two characters and returns true if they have the same unicode character value,
+   * rendition and colors.
+   */
+  friend bool operator == (const Character & a, const Character & b);
+  /**
+   * Compares two characters and returns true if they have different unicode character values,
+   * renditions or colors.
+   */
+  friend bool operator != (const Character & a, const Character & b);
+};
+
+inline bool
+operator == (const Character & a, const Character & b)
+{
+  return a.character == b.character &&
+    a.rendition == b.rendition &&
+    a.foregroundColor == b.foregroundColor &&
+    a.backgroundColor == b.backgroundColor;
+}
+
+inline bool
+operator != (const Character & a, const Character & b)
+{
+  return a.character != b.character ||
+    a.rendition != b.rendition ||
+    a.foregroundColor != b.foregroundColor ||
+    a.backgroundColor != b.backgroundColor;
+}
+
+inline bool
+Character::isTransparent (const ColorEntry * base) const
+{
+  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
+	  base[backgroundColor._u + 0 +
+	       (backgroundColor._v ? BASE_COLORS : 0)].transparent)
+    || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
+	&& base[backgroundColor._u + 2 +
+		(backgroundColor._v ? BASE_COLORS : 0)].transparent);
+}
+
+inline bool
+Character::equalsFormat (const Character & other) const
+{
+  return
+    backgroundColor == other.backgroundColor &&
+    foregroundColor == other.foregroundColor && rendition == other.rendition;
+}
+
+inline ColorEntry::FontWeight
+Character::fontWeight (const ColorEntry * base) const
+{
+  if (backgroundColor._colorSpace == COLOR_SPACE_DEFAULT)
+    return base[backgroundColor._u + 0 +
+		(backgroundColor._v ? BASE_COLORS : 0)].fontWeight;
+  else if (backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
+    return base[backgroundColor._u + 2 +
+		(backgroundColor._v ? BASE_COLORS : 0)].fontWeight;
+  else
+    return ColorEntry::UseCurrentFormat;
+}
+
+extern unsigned short vt100_graphics[32];
+
+
+/**
+ * A table which stores sequences of unicode characters, referenced
+ * by hash keys.  The hash key itself is the same size as a unicode
+ * character ( ushort ) so that it can occupy the same space in
+ * a structure.
+ */
+class ExtendedCharTable
+{
+public:
+    /** Constructs a new character table. */
+  ExtendedCharTable ();
+  ~ExtendedCharTable ();
+
+    /**
+     * Adds a sequences of unicode characters to the table and returns
+     * a hash code which can be used later to look up the sequence
+     * using lookupExtendedChar()
+     *
+     * If the same sequence already exists in the table, the hash
+     * of the existing sequence will be returned.
+     *
+     * @param unicodePoints An array of unicode character points
+     * @param length Length of @p unicodePoints
+     */
+  ushort createExtendedChar (ushort * unicodePoints, ushort length);
+    /**
+     * Looks up and returns a pointer to a sequence of unicode characters
+     * which was added to the table using createExtendedChar().
+     *
+     * @param hash The hash key returned by createExtendedChar()
+     * @param length This variable is set to the length of the 
+     * character sequence.
+     *
+     * @return A unicode character sequence of size @p length.
+     */
+  ushort *lookupExtendedChar (ushort hash, ushort & length) const;
+
+    /** The global ExtendedCharTable instance. */
+  static ExtendedCharTable instance;
+private:
+  // calculates the hash key of a sequence of unicode points of size 'length'
+    ushort extendedCharHash (ushort * unicodePoints, ushort length) const;
+  // tests whether the entry in the table specified by 'hash' matches the 
+  // character sequence 'unicodePoints' of size 'length'
+  bool extendedCharMatch (ushort hash, ushort * unicodePoints,
+			  ushort length) const;
+  // internal, maps hash keys to character sequence buffers.  The first ushort
+  // in each value is the length of the buffer, followed by the ushorts in the buffer
+  // themselves.
+    QHash < ushort, ushort * >extendedCharTable;
+};
+
+Q_DECLARE_TYPEINFO (Character, Q_MOVABLE_TYPE);
+
+#endif // CHARACTER_H
diff --git a/gui/src/terminal/CharacterColor.h b/gui/src/terminal/CharacterColor.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/CharacterColor.h
@@ -0,0 +1,307 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+    
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef CHARACTERCOLOR_H
+#define CHARACTERCOLOR_H
+
+// Qt
+#include <QtGui/QColor>
+
+/** 
+ * An entry in a terminal display's color palette. 
+ *
+ * A color palette is an array of 16 ColorEntry instances which map
+ * system color indexes (from 0 to 15) into actual colors.
+ *
+ * Each entry can be set as bold, in which case any text
+ * drawn using the color should be drawn in bold.  
+ *
+ * Each entry can also be transparent, in which case the terminal
+ * display should avoid drawing the background for any characters
+ * using the entry as a background.
+ */
+class ColorEntry
+{
+public:
+  /** Specifies the weight to use when drawing text with this color. */
+  enum FontWeight
+  {
+    /** Always draw text in this color with a bold weight. */
+    Bold,
+    /** Always draw text in this color with a normal weight. */
+    Normal,
+    /** 
+     * Use the current font weight set by the terminal application.  
+     * This is the default behavior.
+     */
+    UseCurrentFormat
+  };
+
+  /** 
+   * Constructs a new color palette entry.
+   *
+   * @param c The color value for this entry.
+   * @param tr Specifies that the color should be transparent when used as a background color.
+   * @param weight Specifies the font weight to use when drawing text with this color. 
+   */
+  ColorEntry (QColor c, bool tr, FontWeight weight = UseCurrentFormat):color (c), transparent (tr),
+    fontWeight
+    (weight)
+  {
+  }
+
+  /**
+   * Constructs a new color palette entry with an undefined color, and
+   * with the transparent and bold flags set to false.
+   */
+  ColorEntry ():transparent (false), fontWeight (UseCurrentFormat)
+  {
+  }
+
+  /**
+   * Sets the color, transparency and boldness of this color to those of @p rhs.
+   */
+  void operator= (const ColorEntry & rhs)
+  {
+    color = rhs.color;
+    transparent = rhs.transparent;
+    fontWeight = rhs.fontWeight;
+  }
+
+  /** The color value of this entry for display. */
+  QColor color;
+
+  /** 
+   * If true character backgrounds using this color should be transparent. 
+   * This is not applicable when the color is used to render text.
+   */
+  bool transparent;
+  /**
+   * Specifies the font weight to use when drawing text with this color. 
+   * This is not applicable when the color is used to draw a character's background.
+   */
+  FontWeight fontWeight;
+};
+
+
+// Attributed Character Representations ///////////////////////////////
+
+// Colors
+
+#define BASE_COLORS   (2+8)
+#define INTENSITIES   2
+#define TABLE_COLORS  (INTENSITIES*BASE_COLORS)
+
+#define DEFAULT_FORE_COLOR 0
+#define DEFAULT_BACK_COLOR 1
+
+//a standard set of colors using black text on a white background.
+//defined in TerminalDisplay.cpp
+
+extern const ColorEntry base_color_table[TABLE_COLORS];
+
+/* CharacterColor is a union of the various color spaces.
+
+   Assignment is as follows:
+
+   Type  - Space        - Values
+
+   0     - Undefined   - u:  0,      v:0        w:0
+   1     - Default     - u:  0..1    v:intense  w:0
+   2     - System      - u:  0..7    v:intense  w:0
+   3     - Index(256)  - u: 16..255  v:0        w:0
+   4     - RGB         - u:  0..255  v:0..256   w:0..256
+
+   Default colour space has two separate colours, namely
+   default foreground and default background colour.
+*/
+
+#define COLOR_SPACE_UNDEFINED   0
+#define COLOR_SPACE_DEFAULT     1
+#define COLOR_SPACE_SYSTEM      2
+#define COLOR_SPACE_256         3
+#define COLOR_SPACE_RGB         4
+
+/**
+ * Describes the color of a single character in the terminal.
+ */
+class CharacterColor
+{
+  friend class Character;
+
+public:
+  /** Constructs a new CharacterColor whoose color and color space are undefined. */
+    CharacterColor ():_colorSpace (COLOR_SPACE_UNDEFINED),
+    _u (0), _v (0), _w (0)
+  {
+  }
+
+  /** 
+   * Constructs a new CharacterColor using the specified @p colorSpace and with 
+   * color value @p co
+   *
+   * The meaning of @p co depends on the @p colorSpace used.
+   *
+   * TODO : Document how @p co relates to @p colorSpace
+   *
+   * TODO : Add documentation about available color spaces.
+   */
+  CharacterColor (quint8 colorSpace, int co):_colorSpace (colorSpace),
+    _u (0), _v (0), _w (0)
+  {
+    switch (colorSpace)
+      {
+      case COLOR_SPACE_DEFAULT:
+	_u = co & 1;
+	break;
+      case COLOR_SPACE_SYSTEM:
+	_u = co & 7;
+	_v = (co >> 3) & 1;
+	break;
+      case COLOR_SPACE_256:
+	_u = co & 255;
+	break;
+      case COLOR_SPACE_RGB:
+	_u = co >> 16;
+	_v = co >> 8;
+	_w = co;
+	break;
+      default:
+	_colorSpace = COLOR_SPACE_UNDEFINED;
+      }
+  }
+
+  /** 
+   * Returns true if this character color entry is valid.
+   */
+  bool isValid ()
+  {
+    return _colorSpace != COLOR_SPACE_UNDEFINED;
+  }
+
+  /** 
+   * Toggles the value of this color between a normal system color and the corresponding intensive
+   * system color.
+   * 
+   * This is only applicable if the color is using the COLOR_SPACE_DEFAULT or COLOR_SPACE_SYSTEM
+   * color spaces.
+   */
+  void toggleIntensive ();
+
+  /** 
+   * Returns the color within the specified color @p palette
+   *
+   * The @p palette is only used if this color is one of the 16 system colors, otherwise
+   * it is ignored.
+   */
+  QColor color (const ColorEntry * palette) const;
+
+  /** 
+   * Compares two colors and returns true if they represent the same color value and
+   * use the same color space.
+   */
+  friend bool operator == (const CharacterColor & a,
+			   const CharacterColor & b);
+  /**
+   * Compares two colors and returns true if they represent different color values
+   * or use different color spaces.
+   */
+  friend bool operator != (const CharacterColor & a,
+			   const CharacterColor & b);
+
+private:
+  quint8 _colorSpace;
+
+  // bytes storing the character color 
+  quint8 _u;
+  quint8 _v;
+  quint8 _w;
+};
+
+inline bool
+operator == (const CharacterColor & a, const CharacterColor & b)
+{
+  return a._colorSpace == b._colorSpace &&
+    a._u == b._u && a._v == b._v && a._w == b._w;
+}
+
+inline bool
+operator != (const CharacterColor & a, const CharacterColor & b)
+{
+  return !operator== (a, b);
+}
+
+inline const QColor
+color256 (quint8 u, const ColorEntry * base)
+{
+  //   0.. 16: system colors
+  if (u < 8)
+    return base[u + 2].color;
+  u -= 8;
+  if (u < 8)
+    return base[u + 2 + BASE_COLORS].color;
+  u -= 8;
+
+  //  16..231: 6x6x6 rgb color cube
+  if (u < 216)
+    return QColor (((u / 36) % 6) ? (40 * ((u / 36) % 6) + 55) : 0,
+		   ((u / 6) % 6) ? (40 * ((u / 6) % 6) + 55) : 0,
+		   ((u / 1) % 6) ? (40 * ((u / 1) % 6) + 55) : 0);
+  u -= 216;
+
+  // 232..255: gray, leaving out black and white
+  int gray = u * 10 + 8;
+  return QColor (gray, gray, gray);
+}
+
+inline QColor
+CharacterColor::color (const ColorEntry * base) const
+{
+  switch (_colorSpace)
+    {
+    case COLOR_SPACE_DEFAULT:
+      return base[_u + 0 + (_v ? BASE_COLORS : 0)].color;
+    case COLOR_SPACE_SYSTEM:
+      return base[_u + 2 + (_v ? BASE_COLORS : 0)].color;
+    case COLOR_SPACE_256:
+      return color256 (_u, base);
+    case COLOR_SPACE_RGB:
+      return QColor (_u, _v, _w);
+    case COLOR_SPACE_UNDEFINED:
+      return QColor ();
+    }
+
+  Q_ASSERT (false);		// invalid color space
+
+  return QColor ();
+}
+
+inline void
+CharacterColor::toggleIntensive ()
+{
+  if (_colorSpace == COLOR_SPACE_SYSTEM || _colorSpace == COLOR_SPACE_DEFAULT)
+    {
+      _v = !_v;
+    }
+}
+
+#endif // CHARACTERCOLOR_H
diff --git a/gui/src/terminal/ColorTables.h b/gui/src/terminal/ColorTables.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/ColorTables.h
@@ -0,0 +1,97 @@
+/* OctaveGUI - A graphical user interface for Octave
+ * Copyright (C) 2011 Jacob Dawid
+ * jacob.dawid@googlemail.com
+ *
+ * This file was autogenerated for the Konsole project.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _COLOR_TABLE_H
+#define _COLOR_TABLE_H
+
+#include "CharacterColor.h"
+
+static const ColorEntry whiteonblack_color_table[TABLE_COLORS] = {
+  // normal
+  ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0, 0), ColorEntry (QColor (0x00, 0x00, 0x00), 1, 0),	// Dfore, Dback
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0, 0), ColorEntry (QColor (0xB2, 0x18, 0x18), 0, 0),	// Black, Red
+  ColorEntry (QColor (0x18, 0xB2, 0x18), 0, 0), ColorEntry (QColor (0xB2, 0x68, 0x18), 0, 0),	// Green, Yellow
+  ColorEntry (QColor (0x18, 0x18, 0xB2), 0, 0), ColorEntry (QColor (0xB2, 0x18, 0xB2), 0, 0),	// Blue, Magenta
+  ColorEntry (QColor (0x18, 0xB2, 0xB2), 0, 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 0, 0),	// Cyan, White
+  // intensiv
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0, 1),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 1, 0),
+  ColorEntry (QColor (0x68, 0x68, 0x68), 0, 0),
+    ColorEntry (QColor (0xFF, 0x54, 0x54), 0, 0),
+  ColorEntry (QColor (0x54, 0xFF, 0x54), 0, 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0x54), 0, 0),
+  ColorEntry (QColor (0x54, 0x54, 0xFF), 0, 0),
+    ColorEntry (QColor (0xFF, 0x54, 0xFF), 0, 0),
+  ColorEntry (QColor (0x54, 0xFF, 0xFF), 0, 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0, 0)
+};
+
+static const ColorEntry greenonblack_color_table[TABLE_COLORS] = {
+  ColorEntry (QColor (24, 240, 24), 0, 0), ColorEntry (QColor (0, 0, 0), 1,
+						       0),
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (178, 24, 24), 0,
+						   0),
+  ColorEntry (QColor (24, 178, 24), 0, 0), ColorEntry (QColor (178, 104, 24),
+						       0, 0),
+  ColorEntry (QColor (24, 24, 178), 0, 0), ColorEntry (QColor (178, 24, 178),
+						       0, 0),
+  ColorEntry (QColor (24, 178, 178), 0, 0),
+    ColorEntry (QColor (178, 178, 178), 0, 0),
+  // intensive colors
+  ColorEntry (QColor (24, 240, 24), 0, 1), ColorEntry (QColor (0, 0, 0), 1,
+						       0),
+  ColorEntry (QColor (104, 104, 104), 0, 0), ColorEntry (QColor (255, 84, 84),
+							 0, 0),
+  ColorEntry (QColor (84, 255, 84), 0, 0), ColorEntry (QColor (255, 255, 84),
+						       0, 0),
+  ColorEntry (QColor (84, 84, 255), 0, 0), ColorEntry (QColor (255, 84, 255),
+						       0, 0),
+  ColorEntry (QColor (84, 255, 255), 0, 0),
+    ColorEntry (QColor (255, 255, 255), 0, 0)
+};
+
+static const ColorEntry blackonlightyellow_color_table[TABLE_COLORS] = {
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (255, 255, 221), 1,
+						   0),
+  ColorEntry (QColor (0, 0, 0), 0, 0), ColorEntry (QColor (178, 24, 24), 0,
+						   0),
+  ColorEntry (QColor (24, 178, 24), 0, 0), ColorEntry (QColor (178, 104, 24),
+						       0, 0),
+  ColorEntry (QColor (24, 24, 178), 0, 0), ColorEntry (QColor (178, 24, 178),
+						       0, 0),
+  ColorEntry (QColor (24, 178, 178), 0, 0),
+    ColorEntry (QColor (178, 178, 178), 0, 0),
+  ColorEntry (QColor (0, 0, 0), 0, 1), ColorEntry (QColor (255, 255, 221), 1,
+						   0),
+  ColorEntry (QColor (104, 104, 104), 0, 0), ColorEntry (QColor (255, 84, 84),
+							 0, 0),
+  ColorEntry (QColor (84, 255, 84), 0, 0), ColorEntry (QColor (255, 255, 84),
+						       0, 0),
+  ColorEntry (QColor (84, 84, 255), 0, 0), ColorEntry (QColor (255, 84, 255),
+						       0, 0),
+  ColorEntry (QColor (84, 255, 255), 0, 0),
+    ColorEntry (QColor (255, 255, 255), 0, 0)
+};
+
+
+
+
+
+#endif
diff --git a/gui/src/terminal/Emulation.cpp b/gui/src/terminal/Emulation.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Emulation.cpp
@@ -0,0 +1,436 @@
+/*
+    Copyright 2007-2008 Robert Knight <robertknight@gmail.com> 
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 1996 by Matthias Ettrich <ettrich@kde.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "Emulation.h"
+
+// System
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtGui/QClipboard>
+#include <QtCore/QHash>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QRegExp>
+#include <QtCore/QTextStream>
+#include <QtCore/QThread>
+
+#include <QtCore/QTime>
+
+// Konsole
+#include "KeyboardTranslator.h"
+#include "Screen.h"
+#include "TerminalCharacterDecoder.h"
+#include "ScreenWindow.h"
+
+Emulation::Emulation ():
+_currentScreen (0),
+_codec (0), _decoder (0), _keyTranslator (0), _usesMouse (false)
+{
+  // create screens with a default size
+  _screen[0] = new Screen (40, 80);
+  _screen[1] = new Screen (40, 80);
+  _currentScreen = _screen[0];
+
+  QObject::connect (&_bulkTimer1, SIGNAL (timeout ()), this,
+		    SLOT (showBulk ()));
+  QObject::connect (&_bulkTimer2, SIGNAL (timeout ()), this,
+		    SLOT (showBulk ()));
+
+  // listen for mouse status changes
+  connect (this, SIGNAL (programUsesMouseChanged (bool)),
+	   SLOT (usesMouseChanged (bool)));
+}
+
+bool
+Emulation::programUsesMouse () const
+{
+  return _usesMouse;
+}
+
+void
+Emulation::usesMouseChanged (bool usesMouse)
+{
+  _usesMouse = usesMouse;
+}
+
+ScreenWindow *
+Emulation::createWindow ()
+{
+  ScreenWindow *window = new ScreenWindow ();
+  window->setScreen (_currentScreen);
+  _windows << window;
+
+  connect (window, SIGNAL (selectionChanged ()),
+	   this, SLOT (bufferedUpdate ()));
+
+  connect (this, SIGNAL (outputChanged ()),
+	   window, SLOT (notifyOutputChanged ()));
+  return window;
+}
+
+Emulation::~Emulation ()
+{
+  QListIterator < ScreenWindow * >windowIter (_windows);
+
+  while (windowIter.hasNext ())
+    {
+      delete windowIter.next ();
+    }
+
+  delete _screen[0];
+  delete _screen[1];
+  delete _decoder;
+}
+
+void
+Emulation::setScreen (int n)
+{
+  Screen *old = _currentScreen;
+  _currentScreen = _screen[n & 1];
+  if (_currentScreen != old)
+    {
+      // tell all windows onto this emulation to switch to the newly active screen
+      foreach (ScreenWindow * window, _windows)
+	window->setScreen (_currentScreen);
+    }
+}
+
+void
+Emulation::clearHistory ()
+{
+  _screen[0]->setScroll (_screen[0]->getScroll (), false);
+}
+
+void
+Emulation::setHistory (const HistoryType & t)
+{
+  _screen[0]->setScroll (t);
+
+  showBulk ();
+}
+
+const HistoryType &
+Emulation::history () const
+{
+  return _screen[0]->getScroll ();
+}
+
+void
+Emulation::setCodec (const QTextCodec * qtc)
+{
+  if (qtc)
+    _codec = qtc;
+  else
+    setCodec (LocaleCodec);
+
+  delete _decoder;
+  _decoder = _codec->makeDecoder ();
+
+  emit useUtf8Request (utf8 ());
+}
+
+void
+Emulation::setCodec (EmulationCodec codec)
+{
+  if (codec == Utf8Codec)
+    setCodec (QTextCodec::codecForName ("utf8"));
+  else if (codec == LocaleCodec)
+    setCodec (QTextCodec::codecForLocale ());
+}
+
+void
+Emulation::setKeyBindings (const QString & name)
+{
+  _keyTranslator =
+    KeyboardTranslatorManager::instance ()->findTranslator (name);
+  if (!_keyTranslator)
+    {
+      _keyTranslator =
+	KeyboardTranslatorManager::instance ()->defaultTranslator ();
+    }
+}
+
+QString
+Emulation::keyBindings () const
+{
+  return _keyTranslator->name ();
+}
+
+void
+Emulation::receiveChar (int c)
+// process application unicode input to terminal
+// this is a trivial scanner
+{
+  c &= 0xff;
+  switch (c)
+    {
+    case '\b':
+      _currentScreen->backspace ();
+      break;
+    case '\t':
+      _currentScreen->tab ();
+      break;
+    case '\n':
+      _currentScreen->newLine ();
+      break;
+    case '\r':
+      _currentScreen->toStartOfLine ();
+      break;
+    case 0x07:
+      emit stateSet (NOTIFYBELL);
+      break;
+    default:
+      _currentScreen->displayCharacter (c);
+      break;
+    };
+}
+
+void
+Emulation::sendKeyEvent (QKeyEvent * ev)
+{
+  emit stateSet (NOTIFYNORMAL);
+
+  if (!ev->text ().isEmpty ())
+    {				// A block of text
+      // Note that the text is proper unicode.
+      // We should do a conversion here
+      emit sendData (ev->text ().toUtf8 (), ev->text ().length ());
+    }
+}
+
+void
+Emulation::sendString (const char *, int)
+{
+  // default implementation does nothing
+}
+
+void
+Emulation::sendMouseEvent (int /*buttons */ , int /*column */ , int /*row */ ,
+			   int /*eventType */ )
+{
+  // default implementation does nothing
+}
+
+/*
+   We are doing code conversion from locale to unicode first.
+TODO: Character composition from the old code.  See #96536
+*/
+
+void
+Emulation::receiveData (const char *text, int length)
+{
+  emit stateSet (NOTIFYACTIVITY);
+
+  bufferedUpdate ();
+
+  QString unicodeText = _decoder->toUnicode (text, length);
+
+  //send characters to terminal emulator
+  for (int i = 0; i < unicodeText.length (); i++)
+    receiveChar (unicodeText[i].unicode ());
+}
+
+void
+Emulation::writeToStream (TerminalCharacterDecoder * _decoder,
+			  int startLine, int endLine)
+{
+  _currentScreen->writeLinesToStream (_decoder, startLine, endLine);
+}
+
+int
+Emulation::lineCount () const
+{
+  // sum number of lines currently on _screen plus number of lines in history
+  return _currentScreen->getLines () + _currentScreen->getHistLines ();
+}
+
+#define BULK_TIMEOUT1 10
+#define BULK_TIMEOUT2 40
+
+void
+Emulation::showBulk ()
+{
+  _bulkTimer1.stop ();
+  _bulkTimer2.stop ();
+
+  emit outputChanged ();
+
+  _currentScreen->resetScrolledLines ();
+  _currentScreen->resetDroppedLines ();
+}
+
+void
+Emulation::bufferedUpdate ()
+{
+  _bulkTimer1.setSingleShot (true);
+  _bulkTimer1.start (BULK_TIMEOUT1);
+  if (!_bulkTimer2.isActive ())
+    {
+      _bulkTimer2.setSingleShot (true);
+      _bulkTimer2.start (BULK_TIMEOUT2);
+    }
+}
+
+char
+Emulation::eraseChar () const
+{
+  return '\b';
+}
+
+void
+Emulation::setImageSize (int lines, int columns)
+{
+  if ((lines < 1) || (columns < 1))
+    return;
+
+  QSize screenSize[2] = { QSize (_screen[0]->getColumns (),
+				 _screen[0]->getLines ()),
+    QSize (_screen[1]->getColumns (),
+	   _screen[1]->getLines ())
+  };
+  QSize newSize (columns, lines);
+
+  if (newSize == screenSize[0] && newSize == screenSize[1])
+    return;
+
+  _screen[0]->resizeImage (lines, columns);
+  _screen[1]->resizeImage (lines, columns);
+
+  emit imageSizeChanged (lines, columns);
+
+  bufferedUpdate ();
+}
+
+QSize
+Emulation::imageSize () const
+{
+  return QSize (_currentScreen->getColumns (), _currentScreen->getLines ());
+}
+
+ushort
+ExtendedCharTable::extendedCharHash (ushort * unicodePoints, ushort length) const
+{
+  ushort hash = 0;
+  for (ushort i = 0; i < length; i++)
+    {
+      hash = 31 * hash + unicodePoints[i];
+    }
+  return hash;
+}
+
+bool
+ExtendedCharTable::extendedCharMatch (ushort hash, ushort * unicodePoints,
+				      ushort length) const
+{
+  ushort *entry = extendedCharTable[hash];
+
+  // compare given length with stored sequence length ( given as the first ushort in the 
+  // stored buffer ) 
+  if (entry == 0 || entry[0] != length)
+    return false;
+  // if the lengths match, each character must be checked.  the stored buffer starts at
+  // entry[1]
+  for (int i = 0; i < length; i++)
+    {
+      if (entry[i + 1] != unicodePoints[i])
+	return false;
+    }
+  return true;
+}
+
+ushort
+ExtendedCharTable::createExtendedChar (ushort * unicodePoints, ushort length)
+{
+  // look for this sequence of points in the table
+  ushort hash = extendedCharHash (unicodePoints, length);
+
+  // check existing entry for match
+  while (extendedCharTable.contains (hash))
+    {
+      if (extendedCharMatch (hash, unicodePoints, length))
+	{
+	  // this sequence already has an entry in the table, 
+	  // return its hash
+	  return hash;
+	}
+      else
+	{
+	  // if hash is already used by another, different sequence of unicode character
+	  // points then try next hash
+	  hash++;
+	}
+    }
+
+
+  // add the new sequence to the table and
+  // return that index
+  ushort *buffer = new ushort[length + 1];
+  buffer[0] = length;
+  for (int i = 0; i < length; i++)
+    buffer[i + 1] = unicodePoints[i];
+
+  extendedCharTable.insert (hash, buffer);
+
+  return hash;
+}
+
+ushort *
+ExtendedCharTable::lookupExtendedChar (ushort hash, ushort & length) const
+{
+  // lookup index in table and if found, set the length
+  // argument and return a pointer to the character sequence
+
+  ushort *buffer = extendedCharTable[hash];
+  if (buffer)
+    {
+      length = buffer[0];
+      return buffer + 1;
+    }
+  else
+    {
+      length = 0;
+      return 0;
+    }
+}
+
+ExtendedCharTable::ExtendedCharTable ()
+{
+}
+
+ExtendedCharTable::~ExtendedCharTable ()
+{
+  // free all allocated character buffers
+  QHashIterator < ushort, ushort * >iter (extendedCharTable);
+  while (iter.hasNext ())
+    {
+      iter.next ();
+      delete[]iter.value ();
+    }
+}
+
+// global instance
+ExtendedCharTable
+  ExtendedCharTable::instance;
diff --git a/gui/src/terminal/Emulation.h b/gui/src/terminal/Emulation.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Emulation.h
@@ -0,0 +1,461 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef EMULATION_H
+#define EMULATION_H
+
+// System
+#include <stdio.h>
+
+// Qt 
+#include <QtGui/QKeyEvent>
+#include <QtCore/QTextCodec>
+#include <QtCore/QTextStream>
+#include <QtCore/QTimer>
+
+
+class KeyboardTranslator;
+class HistoryType;
+class Screen;
+class ScreenWindow;
+class TerminalCharacterDecoder;
+
+/** 
+ * This enum describes the available states which 
+ * the terminal emulation may be set to.
+ *
+ * These are the values used by Emulation::stateChanged() 
+ */
+enum
+{
+    /** The emulation is currently receiving user input. */
+  NOTIFYNORMAL = 0,
+    /** 
+     * The terminal program has triggered a bell event
+     * to get the user's attention.
+     */
+  NOTIFYBELL = 1,
+    /** 
+     * The emulation is currently receiving data from its 
+     * terminal input.
+     */
+  NOTIFYACTIVITY = 2,
+
+  // unused here? 
+  NOTIFYSILENCE = 3
+};
+
+/**
+ * Base class for terminal emulation back-ends.
+ *
+ * The back-end is responsible for decoding an incoming character stream and 
+ * producing an output image of characters.
+ *
+ * When input from the terminal is received, the receiveData() slot should be called with
+ * the data which has arrived.  The emulation will process the data and update the 
+ * screen image accordingly.  The codec used to decode the incoming character stream
+ * into the unicode characters used internally can be specified using setCodec() 
+ *
+ * The size of the screen image can be specified by calling setImageSize() with the 
+ * desired number of lines and columns.  When new lines are added, old content
+ * is moved into a history store, which can be set by calling setHistory(). 
+ *
+ * The screen image can be accessed by creating a ScreenWindow onto this emulation 
+ * by calling createWindow().  Screen windows provide access to a section of the 
+ * output.  Each screen window covers the same number of lines and columns as the 
+ * image size returned by imageSize().  The screen window can be moved up and down
+ * and provides transparent access to both the current on-screen image and the 
+ * previous output.  The screen windows emit an outputChanged signal
+ * when the section of the image they are looking at changes.
+ * Graphical views can then render the contents of a screen window, listening for notifications
+ * of output changes from the screen window which they are associated with and updating 
+ * accordingly. 
+ *
+ * The emulation also is also responsible for converting input from the connected views such
+ * as keypresses and mouse activity into a character string which can be sent
+ * to the terminal program.  Key presses can be processed by calling the sendKeyEvent() slot,
+ * while mouse events can be processed using the sendMouseEvent() slot.  When the character
+ * stream has been produced, the emulation will emit a sendData() signal with a pointer
+ * to the character buffer.  This data should be fed to the standard input of the terminal
+ * process.  The translation of key presses into an output character stream is performed
+ * using a lookup in a set of key bindings which map key sequences to output
+ * character sequences.  The name of the key bindings set used can be specified using
+ * setKeyBindings()
+ *
+ * The emulation maintains certain state information which changes depending on the 
+ * input received.  The emulation can be reset back to its starting state by calling 
+ * reset().  
+ *
+ * The emulation also maintains an activity state, which specifies whether
+ * terminal is currently active ( when data is received ), normal
+ * ( when the terminal is idle or receiving user input ) or trying
+ * to alert the user ( also known as a "Bell" event ).  The stateSet() signal
+ * is emitted whenever the activity state is set.  This can be used to determine
+ * how long the emulation has been active/idle for and also respond to
+ * a 'bell' event in different ways.
+ */
+class Emulation:public QObject
+{
+Q_OBJECT public:
+
+   /** Constructs a new terminal emulation */
+  Emulation ();
+  ~Emulation ();
+
+  /**
+   * Creates a new window onto the output from this emulation.  The contents
+   * of the window are then rendered by views which are set to use this window using the
+   * TerminalDisplay::setScreenWindow() method.
+   */
+  ScreenWindow *createWindow ();
+
+  /** Returns the size of the screen image which the emulation produces */
+  QSize imageSize () const;
+
+  /**
+   * Returns the total number of lines, including those stored in the history.
+   */
+  int lineCount () const;
+
+  /** 
+   * Sets the history store used by this emulation.  When new lines
+   * are added to the output, older lines at the top of the screen are transferred to a history
+   * store.   
+   *
+   * The number of lines which are kept and the storage location depend on the 
+   * type of store.
+   */
+  void setHistory (const HistoryType &);
+  /** Returns the history store used by this emulation.  See setHistory() */
+  const HistoryType & history () const;
+  /** Clears the history scroll. */
+  void clearHistory ();
+
+  /** 
+   * Copies the output history from @p startLine to @p endLine 
+   * into @p stream, using @p decoder to convert the terminal
+   * characters into text. 
+   *
+   * @param decoder A decoder which converts lines of terminal characters with 
+   * appearance attributes into output text.  PlainTextDecoder is the most commonly
+   * used decoder.
+   * @param startLine Index of first line to copy
+   * @param endLine Index of last line to copy
+   */
+  virtual void writeToStream (TerminalCharacterDecoder * decoder,
+			      int startLine, int endLine);
+
+  /** Returns the codec used to decode incoming characters.  See setCodec() */
+  const QTextCodec *codec () const
+  {
+    return _codec;
+  }
+  /** Sets the codec used to decode incoming characters.  */
+  void setCodec (const QTextCodec *);
+
+  /** 
+   * Convenience method.  
+   * Returns true if the current codec used to decode incoming
+   * characters is UTF-8
+   */
+  bool utf8 () const
+  {
+    Q_ASSERT (_codec);
+    return _codec->mibEnum () == 106;
+  }
+
+
+  /** TODO Document me */
+  virtual char eraseChar () const;
+
+  /** 
+   * Sets the key bindings used to key events
+   * ( received through sendKeyEvent() ) into character
+   * streams to send to the terminal.
+   */
+  void setKeyBindings (const QString & name);
+  /** 
+   * Returns the name of the emulation's current key bindings.
+   * See setKeyBindings()
+   */
+  QString keyBindings () const;
+
+  /** 
+   * Copies the current image into the history and clears the screen.
+   */
+  virtual void clearEntireScreen () = 0;
+
+  /** Resets the state of the terminal. */
+  virtual void reset () = 0;
+
+  /** 
+   * Returns true if the active terminal program wants
+   * mouse input events.
+   *
+   * The programUsesMouseChanged() signal is emitted when this
+   * changes.
+   */
+  bool programUsesMouse () const;
+
+  public slots:
+  /** Change the size of the emulation's image */
+    virtual void setImageSize (int lines, int columns);
+
+  /** 
+   * Interprets a sequence of characters and sends the result to the terminal.
+   * This is equivalent to calling sendKeyEvent() for each character in @p text in succession.
+   */
+  virtual void sendText (const QString & text) = 0;
+
+  /** 
+   * Interprets a key press event and emits the sendData() signal with
+   * the resulting character stream. 
+   */
+  virtual void sendKeyEvent (QKeyEvent *);
+
+  /** 
+   * Converts information about a mouse event into an xterm-compatible escape
+   * sequence and emits the character sequence via sendData()
+   */
+  virtual void sendMouseEvent (int buttons, int column, int line,
+			       int eventType);
+
+  /**
+   * Sends a string of characters to the foreground terminal process. 
+   *
+   * @param string The characters to send.  
+   * @param length Length of @p string or if set to a negative value, @p string will
+   * be treated as a null-terminated string and its length will be determined automatically.
+   */
+  virtual void sendString (const char *string, int length = -1) = 0;
+
+  /** 
+   * Processes an incoming stream of characters.  receiveData() decodes the incoming
+   * character buffer using the current codec(), and then calls receiveChar() for
+   * each unicode character in the resulting buffer.  
+   *
+   * receiveData() also starts a timer which causes the outputChanged() signal
+   * to be emitted when it expires.  The timer allows multiple updates in quick
+   * succession to be buffered into a single outputChanged() signal emission.
+   *
+   * @param buffer A string of characters received from the terminal program.
+   * @param len The length of @p buffer
+   */
+  void receiveData (const char *buffer, int len);
+
+    signals:
+  /** 
+   * Emitted when a buffer of data is ready to send to the 
+   * standard input of the terminal.
+   *
+   * @param data The buffer of data ready to be sent
+   * @param len The length of @p data in bytes
+   */
+  void sendData (const char *data, int len);
+
+  /** 
+   * Requests that sending of input to the emulation
+   * from the terminal process be suspended or resumed.
+   *
+   * @param suspend If true, requests that sending of 
+   * input from the terminal process' stdout be 
+   * suspended.  Otherwise requests that sending of
+   * input be resumed. 
+   */
+  void lockPtyRequest (bool suspend);
+
+  /**
+   * Requests that the pty used by the terminal process
+   * be set to UTF 8 mode.  
+   *
+   * TODO: More documentation
+   */
+  void useUtf8Request (bool);
+
+  /**
+   * Emitted when the activity state of the emulation is set.
+   *
+   * @param state The new activity state, one of NOTIFYNORMAL, NOTIFYACTIVITY
+   * or NOTIFYBELL
+   */
+  void stateSet (int state);
+
+  /**
+   * Requests that the color of the text used
+   * to represent the tabs associated with this
+   * emulation be changed.  This is a Konsole-specific
+   * extension from pre-KDE 4 times.
+   *
+   * TODO: Document how the parameter works.
+   */
+  void changeTabTextColorRequest (int color);
+
+  /** 
+   * This is emitted when the program running in the shell indicates whether or
+   * not it is interested in mouse events.
+   *
+   * @param usesMouse This will be true if the program wants to be informed about
+   * mouse events or false otherwise.
+   */
+  void programUsesMouseChanged (bool usesMouse);
+
+  /** 
+   * Emitted when the contents of the screen image change.
+   * The emulation buffers the updates from successive image changes,
+   * and only emits outputChanged() at sensible intervals when
+   * there is a lot of terminal activity.
+   *
+   * Normally there is no need for objects other than the screen windows
+   * created with createWindow() to listen for this signal.
+   *
+   * ScreenWindow objects created using createWindow() will emit their
+   * own outputChanged() signal in response to this signal. 
+   */
+  void outputChanged ();
+
+  /**
+   * Emitted when the program running in the terminal wishes to update the 
+   * session's title.  This also allows terminal programs to customize other
+   * aspects of the terminal emulation display. 
+   *
+   * This signal is emitted when the escape sequence "\033]ARG;VALUE\007"
+   * is received in the input string, where ARG is a number specifying what
+   * should change and VALUE is a string specifying the new value.
+   *
+   * TODO:  The name of this method is not very accurate since this method
+   * is used to perform a whole range of tasks besides just setting
+   * the user-title of the session.    
+   *
+   * @param title Specifies what to change.
+   * <ul>
+   * <li>0 - Set window icon text and session title to @p newTitle</li>
+   * <li>1 - Set window icon text to @p newTitle</li>
+   * <li>2 - Set session title to @p newTitle</li>
+   * <li>11 - Set the session's default background color to @p newTitle,
+   *         where @p newTitle can be an HTML-style string ("#RRGGBB") or a named
+   *         color (eg 'red', 'blue').  
+   *         See http://doc.trolltech.com/4.2/qcolor.html#setNamedColor for more
+   *         details.
+   * </li>
+   * <li>31 - Supposedly treats @p newTitle as a URL and opens it (NOT IMPLEMENTED)</li>
+   * <li>32 - Sets the icon associated with the session.  @p newTitle is the name 
+   *    of the icon to use, which can be the name of any icon in the current KDE icon
+   *    theme (eg: 'konsole', 'kate', 'folder_home')</li>
+   * </ul>
+   * @param newTitle Specifies the new title 
+   */
+
+  void titleChanged (int title, const QString & newTitle);
+
+  /**
+   * Emitted when the program running in the terminal changes the
+   * screen size.
+   */
+  void imageSizeChanged (int lineCount, int columnCount);
+
+  /** 
+   * Emitted when the terminal program requests to change various properties
+   * of the terminal display.  
+   *
+   * A profile change command occurs when a special escape sequence, followed
+   * by a string containing a series of name and value pairs is received.
+   * This string can be parsed using a ProfileCommandParser instance.
+   *
+   * @param text A string expected to contain a series of key and value pairs in
+   * the form:  name=value;name2=value2 ...
+   */
+  void profileChangeCommandReceived (const QString & text);
+
+  /** 
+   * Emitted when a flow control key combination ( Ctrl+S or Ctrl+Q ) is pressed.
+   * @param suspendKeyPressed True if Ctrl+S was pressed to suspend output or Ctrl+Q to
+   * resume output.
+   */
+  void flowControlKeyPressed (bool suspendKeyPressed);
+
+protected:
+    virtual void setMode (int mode) = 0;
+  virtual void resetMode (int mode) = 0;
+
+  /** 
+   * Processes an incoming character.  See receiveData()
+   * @p ch A unicode character code. 
+   */
+  virtual void receiveChar (int ch);
+
+  /** 
+   * Sets the active screen.  The terminal has two screens, primary and alternate.
+   * The primary screen is used by default.  When certain interactive programs such
+   * as Vim are run, they trigger a switch to the alternate screen.
+   *
+   * @param index 0 to switch to the primary screen, or 1 to switch to the alternate screen
+   */
+  void setScreen (int index);
+
+  enum EmulationCodec
+  {
+    LocaleCodec = 0,
+    Utf8Codec = 1
+  };
+  void setCodec (EmulationCodec codec);	// codec number, 0 = locale, 1=utf8
+
+
+    QList < ScreenWindow * >_windows;
+
+  Screen *_currentScreen;	// pointer to the screen which is currently active, 
+  // this is one of the elements in the screen[] array
+
+  Screen *_screen[2];		// 0 = primary screen ( used by most programs, including the shell
+  //                      scrollbars are enabled in this mode )
+  // 1 = alternate      ( used by vi , emacs etc.
+  //                      scrollbars are not enabled in this mode )
+
+
+  //decodes an incoming C-style character stream into a unicode QString using 
+  //the current text codec.  (this allows for rendering of non-ASCII characters in text files etc.)
+  const QTextCodec *_codec;
+  QTextDecoder *_decoder;
+  const KeyboardTranslator *_keyTranslator;	// the keyboard layout
+
+  protected slots:
+  /** 
+   * Schedules an update of attached views.
+   * Repeated calls to bufferedUpdate() in close succession will result in only a single update,
+   * much like the Qt buffered update of widgets. 
+   */
+  void bufferedUpdate ();
+
+  private slots:
+    // triggered by timer, causes the emulation to send an updated screen image to each
+    // view
+  void showBulk ();
+
+  void usesMouseChanged (bool usesMouse);
+
+private:
+    bool _usesMouse;
+  QTimer _bulkTimer1;
+  QTimer _bulkTimer2;
+
+};
+
+#endif // ifndef EMULATION_H
diff --git a/gui/src/terminal/Filter.cpp b/gui/src/terminal/Filter.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Filter.cpp
@@ -0,0 +1,618 @@
+/*
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "Filter.h"
+
+// System
+#include <iostream>
+
+// Qt
+#include <QtGui/QAction>
+#include <QtGui/QApplication>
+#include <QtGui/QClipboard>
+#include <QtCore/QString>
+#include <QtCore/QTextStream>
+#include <QtCore/QSharedData>
+#include <QtCore/QFile>
+
+// Konsole
+#include "TerminalCharacterDecoder.h"
+#include "konsole_wcwidth.h"
+#include "konsole_export.h"
+
+FilterChain::~FilterChain ()
+{
+  QMutableListIterator < Filter * >iter (*this);
+
+  while (iter.hasNext ())
+    {
+      Filter *filter = iter.next ();
+      iter.remove ();
+      delete filter;
+    }
+}
+
+void
+FilterChain::addFilter (Filter * filter)
+{
+  append (filter);
+}
+
+void
+FilterChain::removeFilter (Filter * filter)
+{
+  removeAll (filter);
+}
+
+bool
+FilterChain::containsFilter (Filter * filter)
+{
+  return contains (filter);
+}
+
+void
+FilterChain::reset ()
+{
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->reset ();
+}
+
+void
+FilterChain::setBuffer (const QString * buffer,
+			const QList < int >*linePositions)
+{
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->setBuffer (buffer, linePositions);
+}
+
+void
+FilterChain::process ()
+{
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    iter.next ()->process ();
+}
+
+void
+FilterChain::clear ()
+{
+  QList < Filter * >::clear ();
+}
+
+Filter::HotSpot * FilterChain::hotSpotAt (int line, int column) const
+{
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    {
+      Filter *
+	filter = iter.next ();
+      Filter::HotSpot * spot = filter->hotSpotAt (line, column);
+      if (spot != 0)
+	{
+	  return spot;
+	}
+    }
+
+  return 0;
+}
+
+QList < Filter::HotSpot * >FilterChain::hotSpots () const
+{
+  QList < Filter::HotSpot * >list;
+  QListIterator < Filter * >iter (*this);
+  while (iter.hasNext ())
+    {
+      Filter *
+	filter = iter.next ();
+      list << filter->hotSpots ();
+    }
+  return list;
+}
+
+//QList<Filter::HotSpot*> FilterChain::hotSpotsAtLine(int line) const;
+
+TerminalImageFilterChain::TerminalImageFilterChain ():_buffer (0),
+_linePositions (0)
+{
+}
+
+TerminalImageFilterChain::~TerminalImageFilterChain ()
+{
+  delete _buffer;
+  delete _linePositions;
+}
+
+void
+TerminalImageFilterChain::setImage (const Character * const image, int lines,
+				    int columns,
+				    const QVector < LineProperty >
+				    &lineProperties)
+{
+  if (empty ())
+    return;
+
+  // reset all filters and hotspots
+  reset ();
+
+  PlainTextDecoder decoder;
+  decoder.setTrailingWhitespace (false);
+
+  // setup new shared buffers for the filters to process on
+  QString *newBuffer = new QString ();
+  QList < int >*newLinePositions = new QList < int >();
+  setBuffer (newBuffer, newLinePositions);
+
+  // free the old buffers
+  delete _buffer;
+  delete _linePositions;
+
+  _buffer = newBuffer;
+  _linePositions = newLinePositions;
+
+  QTextStream lineStream (_buffer);
+  decoder.begin (&lineStream);
+
+  for (int i = 0; i < lines; i++)
+    {
+      _linePositions->append (_buffer->length ());
+      decoder.decodeLine (image + i * columns, columns, LINE_DEFAULT);
+
+      // pretend that each line ends with a newline character.
+      // this prevents a link that occurs at the end of one line
+      // being treated as part of a link that occurs at the start of the next line
+      //
+      // the downside is that links which are spread over more than one line are not
+      // highlighted.  
+      //
+      // TODO - Use the "line wrapped" attribute associated with lines in a
+      // terminal image to avoid adding this imaginary character for wrapped
+      // lines
+      if (!(lineProperties.value (i, LINE_DEFAULT) & LINE_WRAPPED))
+	lineStream << QChar ('\n');
+    }
+  decoder.end ();
+}
+
+Filter::Filter ():
+_linePositions (0), _buffer (0)
+{
+}
+
+Filter::~Filter ()
+{
+  QListIterator < HotSpot * >iter (_hotspotList);
+  while (iter.hasNext ())
+    {
+      delete iter.next ();
+    }
+}
+
+void
+Filter::reset ()
+{
+  _hotspots.clear ();
+  _hotspotList.clear ();
+}
+
+void
+Filter::setBuffer (const QString * buffer, const QList < int >*linePositions)
+{
+  _buffer = buffer;
+  _linePositions = linePositions;
+}
+
+void
+Filter::getLineColumn (int position, int &startLine, int &startColumn)
+{
+  Q_ASSERT (_linePositions);
+  Q_ASSERT (_buffer);
+
+
+  for (int i = 0; i < _linePositions->count (); i++)
+    {
+      int nextLine = 0;
+
+      if (i == _linePositions->count () - 1)
+	nextLine = _buffer->length () + 1;
+      else
+	nextLine = _linePositions->value (i + 1);
+
+      if (_linePositions->value (i) <= position && position < nextLine)
+	{
+	  startLine = i;
+	  startColumn =
+	    string_width (buffer ()->
+			  mid (_linePositions->value (i),
+			       position - _linePositions->value (i)));
+	  return;
+	}
+    }
+}
+
+
+/*void Filter::addLine(const QString& text)
+{
+    _linePositions << _buffer.length();
+    _buffer.append(text);
+}*/
+
+const QString *
+Filter::buffer ()
+{
+  return _buffer;
+}
+
+Filter::HotSpot::~HotSpot ()
+{
+}
+
+void
+Filter::addHotSpot (HotSpot * spot)
+{
+  _hotspotList << spot;
+
+  for (int line = spot->startLine (); line <= spot->endLine (); line++)
+    {
+      _hotspots.insert (line, spot);
+    }
+}
+
+QList < Filter::HotSpot * >Filter::hotSpots () const
+{
+  return _hotspotList;
+}
+
+QList < Filter::HotSpot * >Filter::hotSpotsAtLine (int line) const
+{
+  return _hotspots.values (line);
+}
+
+Filter::HotSpot * Filter::hotSpotAt (int line, int column) const
+{
+  QListIterator < HotSpot * >spotIter (_hotspots.values (line));
+
+  while (spotIter.hasNext ())
+    {
+      HotSpot *
+	spot = spotIter.next ();
+
+      if (spot->startLine () == line && spot->startColumn () > column)
+	continue;
+      if (spot->endLine () == line && spot->endColumn () < column)
+	continue;
+
+      return spot;
+    }
+
+  return 0;
+}
+
+Filter::HotSpot::HotSpot (int startLine, int startColumn, int endLine, int endColumn):_startLine (startLine), _startColumn (startColumn), _endLine (endLine),
+_endColumn (endColumn),
+_type (NotSpecified)
+{
+}
+
+QString
+Filter::HotSpot::tooltip () const
+{
+  return QString ();
+}
+
+QList < QAction * >Filter::HotSpot::actions ()
+{
+  return QList < QAction * >();
+}
+
+int
+Filter::HotSpot::startLine () const
+{
+  return _startLine;
+}
+
+int
+Filter::HotSpot::endLine () const
+{
+  return _endLine;
+}
+
+int
+Filter::HotSpot::startColumn () const
+{
+  return _startColumn;
+}
+
+int
+Filter::HotSpot::endColumn () const
+{
+  return _endColumn;
+}
+
+Filter::HotSpot::Type Filter::HotSpot::type () const
+{
+  return _type;
+}
+
+void
+Filter::HotSpot::setType (Type type)
+{
+  _type = type;
+}
+
+RegExpFilter::RegExpFilter ()
+{
+}
+
+RegExpFilter::HotSpot::HotSpot (int startLine, int startColumn, int endLine,
+				int endColumn):
+Filter::HotSpot (startLine, startColumn, endLine, endColumn)
+{
+  setType (Marker);
+}
+
+void
+RegExpFilter::HotSpot::activate (QObject *)
+{
+}
+
+void
+RegExpFilter::HotSpot::setCapturedTexts (const QStringList & texts)
+{
+  _capturedTexts = texts;
+}
+
+QStringList
+RegExpFilter::HotSpot::capturedTexts () const
+{
+  return _capturedTexts;
+}
+
+void
+RegExpFilter::setRegExp (const QRegExp & regExp)
+{
+  _searchText = regExp;
+}
+
+QRegExp
+RegExpFilter::regExp () const
+{
+  return _searchText;
+}
+
+/*void RegExpFilter::reset(int)
+{
+    _buffer = QString();
+}*/
+void
+RegExpFilter::process ()
+{
+  int pos = 0;
+  const QString *text = buffer ();
+
+  Q_ASSERT (text);
+
+  // ignore any regular expressions which match an empty string.
+  // otherwise the while loop below will run indefinitely
+  static const QString emptyString ("");
+  if (_searchText.exactMatch (emptyString))
+    return;
+
+  while (pos >= 0)
+    {
+      pos = _searchText.indexIn (*text, pos);
+
+      if (pos >= 0)
+	{
+	  int startLine = 0;
+	  int endLine = 0;
+	  int startColumn = 0;
+	  int endColumn = 0;
+
+	  getLineColumn (pos, startLine, startColumn);
+	  getLineColumn (pos + _searchText.matchedLength (), endLine,
+			 endColumn);
+
+	  RegExpFilter::HotSpot * spot = newHotSpot (startLine, startColumn,
+						     endLine, endColumn);
+	  spot->setCapturedTexts (_searchText.capturedTexts ());
+
+	  addHotSpot (spot);
+	  pos += _searchText.matchedLength ();
+
+	  // if matchedLength == 0, the program will get stuck in an infinite loop
+	  if (_searchText.matchedLength () == 0)
+	    pos = -1;
+	}
+    }
+}
+
+RegExpFilter::HotSpot * RegExpFilter::newHotSpot (int startLine,
+						  int startColumn,
+						  int endLine, int endColumn)
+{
+  return new RegExpFilter::HotSpot (startLine, startColumn,
+				    endLine, endColumn);
+}
+
+RegExpFilter::HotSpot * UrlFilter::newHotSpot (int startLine, int startColumn,
+					       int endLine, int endColumn)
+{
+  return new UrlFilter::HotSpot (startLine, startColumn, endLine, endColumn);
+}
+
+UrlFilter::HotSpot::HotSpot (int startLine, int startColumn, int endLine, int endColumn):RegExpFilter::HotSpot (startLine, startColumn, endLine, endColumn),
+_urlObject (new
+	    FilterObject (this))
+{
+  setType (Link);
+}
+
+QString
+UrlFilter::HotSpot::tooltip () const
+{
+  QString
+    url = capturedTexts ().first ();
+
+  const UrlType
+    kind = urlType ();
+
+  if (kind == StandardUrl)
+    return QString ();
+  else if (kind == Email)
+    return QString ();
+  else
+    return QString ();
+}
+
+UrlFilter::HotSpot::UrlType UrlFilter::HotSpot::urlType () const
+{
+  QString
+    url = capturedTexts ().first ();
+
+  if (FullUrlRegExp.exactMatch (url))
+    return StandardUrl;
+  else if (EmailAddressRegExp.exactMatch (url))
+    return Email;
+  else
+    return Unknown;
+}
+
+void
+UrlFilter::HotSpot::activate (QObject * object)
+{
+  QString
+    url = capturedTexts ().first ();
+
+  const UrlType
+    kind = urlType ();
+
+  const
+    QString &
+    actionName = object ? object->objectName () : QString ();
+
+  if (actionName == "copy-action")
+    {
+      QApplication::clipboard ()->setText (url);
+      return;
+    }
+
+  if (!object || actionName == "open-action")
+    {
+      if (kind == StandardUrl)
+	{
+	  // if the URL path does not include the protocol ( eg. "www.kde.org" ) then
+	  // prepend http:// ( eg. "www.kde.org" --> "http://www.kde.org" )
+	  if (!url.contains ("://"))
+	    {
+	      url.prepend ("http://");
+	    }
+	}
+      else if (kind == Email)
+	{
+	  url.prepend ("mailto:");
+	}
+
+      //new KRun(url,QApplication::activeWindow());
+    }
+}
+
+// Note:  Altering these regular expressions can have a major effect on the performance of the filters 
+// used for finding URLs in the text, especially if they are very general and could match very long
+// pieces of text.
+// Please be careful when altering them.
+
+//regexp matches:
+// full url:  
+// protocolname:// or www. followed by anything other than whitespaces, <, >, ' or ", and ends before whitespaces, <, >, ', ", ], !, comma and dot
+const QRegExp
+UrlFilter::
+
+FullUrlRegExp
+("(www\\.(?!\\.)|[a-z][a-z0-9+.-]*://)[^\\s<>'\"]+[^!,\\.\\s<>'\"\\]]");
+// email address:
+// [word chars, dots or dashes]@[word chars, dots or dashes].[word chars]
+const QRegExp
+UrlFilter::EmailAddressRegExp ("\\b(\\w|\\.|-)+@(\\w|\\.|-)+\\.\\w+\\b");
+
+// matches full url or email address
+const QRegExp
+UrlFilter::CompleteUrlRegExp ('(' + FullUrlRegExp.pattern () + '|' +
+			      EmailAddressRegExp.pattern () + ')');
+
+UrlFilter::UrlFilter ()
+{
+  setRegExp (CompleteUrlRegExp);
+}
+
+UrlFilter::HotSpot::~HotSpot ()
+{
+  delete
+    _urlObject;
+}
+
+void
+FilterObject::activated ()
+{
+  _filter->activate (sender ());
+}
+
+QList < QAction * >UrlFilter::HotSpot::actions ()
+{
+  QList < QAction * >list;
+
+  const UrlType
+    kind = urlType ();
+
+  QAction *
+    openAction = new QAction (_urlObject);
+  QAction *
+    copyAction = new QAction (_urlObject);;
+
+  Q_ASSERT (kind == StandardUrl || kind == Email);
+
+  if (kind == StandardUrl)
+    {
+      openAction->setText (tr ((char *) "Open Link"));
+      copyAction->setText (tr ((char *) "Copy Link Address"));
+    }
+  else if (kind == Email)
+    {
+      openAction->setText (tr ((char *) "Send Email To..."));
+      copyAction->setText (tr ((char *) "Copy Email Address"));
+    }
+
+  // object names are set here so that the hotspot performs the
+  // correct action when activated() is called with the triggered
+  // action passed as a parameter.
+  openAction->setObjectName (QLatin1String ("open-action"));
+  copyAction->setObjectName (QLatin1String ("copy-action"));
+
+  QObject::connect (openAction, SIGNAL (triggered ()), _urlObject,
+		    SLOT (activated ()));
+  QObject::connect (copyAction, SIGNAL (triggered ()), _urlObject,
+		    SLOT (activated ()));
+
+  list << openAction;
+  list << copyAction;
+
+  return list;
+}
diff --git a/gui/src/terminal/Filter.h b/gui/src/terminal/Filter.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Filter.h
@@ -0,0 +1,379 @@
+/*
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef FILTER_H
+#define FILTER_H
+
+// Qt
+#include <QtGui/QAction>
+#include <QtCore/QList>
+#include <QtCore/QObject>
+#include <QtCore/QStringList>
+#include <QtCore/QHash>
+#include <QtCore/QRegExp>
+
+// Local
+#include "Character.h"
+
+
+/**
+ * A filter processes blocks of text looking for certain patterns (such as URLs or keywords from a list)
+ * and marks the areas which match the filter's patterns as 'hotspots'.
+ *
+ * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
+ * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
+ * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
+ * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
+ *
+ * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
+ * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
+ * actions() method.
+ *
+ * Different subclasses of filter will return different types of hotspot.
+ * Subclasses must reimplement the process() method to examine a block of text and identify sections of interest.
+ * When processing the text they should create instances of Filter::HotSpot subclasses for sections of interest
+ * and add them to the filter's list of hotspots using addHotSpot()
+ */
+class Filter
+{
+public:
+    /**
+    * Represents an area of text which matched the pattern a particular filter has been looking for.
+    *
+    * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
+    * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
+    * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
+    * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
+    *
+    * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
+    * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
+    * actions() method.  These actions may then be displayed in a popup menu or toolbar for example. 
+    */
+  class HotSpot
+  {
+  public:
+       /** 
+        * Constructs a new hotspot which covers the area from (@p startLine,@p startColumn) to (@p endLine,@p endColumn)
+        * in a block of text.
+        */
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+    virtual ~ HotSpot ();
+
+    enum Type
+    {
+      // the type of the hotspot is not specified
+      NotSpecified,
+      // this hotspot represents a clickable link
+      Link,
+      // this hotspot represents a marker
+      Marker
+    };
+
+       /** Returns the line when the hotspot area starts */
+    int startLine () const;
+       /** Returns the line where the hotspot area ends */
+    int endLine () const;
+       /** Returns the column on startLine() where the hotspot area starts */
+    int startColumn () const;
+       /** Returns the column on endLine() where the hotspot area ends */
+    int endColumn () const;
+       /** 
+        * Returns the type of the hotspot.  This is usually used as a hint for views on how to represent
+        * the hotspot graphically.  eg.  Link hotspots are typically underlined when the user mouses over them
+        */
+    Type type () const;
+       /** 
+        * Causes the an action associated with a hotspot to be triggered. 
+        *
+        * @param object The object which caused the hotspot to be triggered.  This is
+        * typically null ( in which case the default action should be performed ) or
+        * one of the objects from the actions() list.  In which case the associated
+        * action should be performed. 
+        */
+    virtual void activate (QObject * object = 0) = 0;
+       /** 
+        * Returns a list of actions associated with the hotspot which can be used in a 
+        * menu or toolbar 
+        */
+    virtual QList < QAction * >actions ();
+
+       /** 
+        * Returns the text of a tooltip to be shown when the mouse moves over the hotspot, or
+        * an empty string if there is no tooltip associated with this hotspot.
+        *
+        * The default implementation returns an empty string. 
+        */
+    virtual QString tooltip () const;
+
+  protected:
+       /** Sets the type of a hotspot.  This should only be set once */
+    void setType (Type type);
+
+  private:
+    int _startLine;
+    int _startColumn;
+    int _endLine;
+    int _endColumn;
+    Type _type;
+
+  };
+
+    /** Constructs a new filter. */
+  Filter ();
+  virtual ~ Filter ();
+
+    /** Causes the filter to process the block of text currently in its internal buffer */
+  virtual void process () = 0;
+
+    /** 
+     * Empties the filters internal buffer and resets the line count back to 0.
+     * All hotspots are deleted. 
+     */
+  void reset ();
+
+    /** Adds a new line of text to the filter and increments the line count */
+  //void addLine(const QString& string);
+
+    /** Returns the hotspot which covers the given @p line and @p column, or 0 if no hotspot covers that area */
+  HotSpot *hotSpotAt (int line, int column) const;
+
+    /** Returns the list of hotspots identified by the filter */
+  QList < HotSpot * >hotSpots ()const;
+
+    /** Returns the list of hotspots identified by the filter which occur on a given line */
+  QList < HotSpot * >hotSpotsAtLine (int line) const;
+
+    /** 
+     * TODO: Document me
+     */
+  void setBuffer (const QString * buffer, const QList < int >*linePositions);
+
+protected:
+    /** Adds a new hotspot to the list */
+  void addHotSpot (HotSpot *);
+    /** Returns the internal buffer */
+  const QString *buffer ();
+    /** Converts a character position within buffer() to a line and column */
+  void getLineColumn (int position, int &startLine, int &startColumn);
+
+private:
+  QMultiHash < int, HotSpot * >_hotspots;
+  QList < HotSpot * >_hotspotList;
+
+  const QList < int >*_linePositions;
+  const QString *_buffer;
+};
+
+/** 
+ * A filter which searches for sections of text matching a regular expression and creates a new RegExpFilter::HotSpot 
+ * instance for them.
+ *
+ * Subclasses can reimplement newHotSpot() to return custom hotspot types when matches for the regular expression
+ * are found. 
+ */
+class RegExpFilter:public Filter
+{
+public:
+    /** 
+     * Type of hotspot created by RegExpFilter.  The capturedTexts() method can be used to find the text
+     * matched by the filter's regular expression.
+     */
+  class HotSpot:public Filter::HotSpot
+  {
+  public:
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+    virtual void activate (QObject * object = 0);
+
+	/** Sets the captured texts associated with this hotspot */
+    void setCapturedTexts (const QStringList & texts);
+	/** Returns the texts found by the filter when matching the filter's regular expression */
+    QStringList capturedTexts () const;
+  private:
+      QStringList _capturedTexts;
+  };
+
+    /** Constructs a new regular expression filter */
+  RegExpFilter ();
+
+    /** 
+     * Sets the regular expression which the filter searches for in blocks of text. 
+     *
+     * Regular expressions which match the empty string are treated as not matching
+     * anything. 
+     */
+  void setRegExp (const QRegExp & text);
+    /** Returns the regular expression which the filter searches for in blocks of text */
+  QRegExp regExp () const;
+
+    /** 
+     * Reimplemented to search the filter's text buffer for text matching regExp() 
+     *
+     * If regexp matches the empty string, then process() will return immediately
+     * without finding results. 
+     */
+  virtual void process ();
+
+protected:
+    /** 
+     * Called when a match for the regular expression is encountered.  Subclasses should reimplement this
+     * to return custom hotspot types
+     */
+  virtual RegExpFilter::HotSpot * newHotSpot (int startLine, int startColumn,
+					      int endLine, int endColumn);
+
+private:
+  QRegExp _searchText;
+};
+
+class FilterObject;
+
+/** A filter which matches URLs in blocks of text */
+class UrlFilter:public RegExpFilter
+{
+public:
+    /** 
+     * Hotspot type created by UrlFilter instances.  The activate() method opens a web browser 
+     * at the given URL when called.
+     */
+  class HotSpot:public RegExpFilter::HotSpot
+  {
+  public:
+    HotSpot (int startLine, int startColumn, int endLine, int endColumn);
+      virtual ~ HotSpot ();
+
+    virtual QList < QAction * >actions ();
+
+	/** 
+         * Open a web browser at the current URL.  The url itself can be determined using
+         * the capturedTexts() method.
+         */
+    virtual void activate (QObject * object = 0);
+
+    virtual QString tooltip () const;
+  private:
+    enum UrlType
+    {
+      StandardUrl,
+      Email,
+      Unknown
+    };
+    UrlType urlType () const;
+
+    FilterObject *_urlObject;
+  };
+
+  UrlFilter ();
+
+protected:
+  virtual RegExpFilter::HotSpot * newHotSpot (int, int, int, int);
+
+private:
+
+  static const QRegExp FullUrlRegExp;
+  static const QRegExp EmailAddressRegExp;
+
+  // combined OR of FullUrlRegExp and EmailAddressRegExp
+  static const QRegExp CompleteUrlRegExp;
+};
+
+class FilterObject:public QObject
+{
+Q_OBJECT public:
+  FilterObject (Filter::HotSpot * filter):_filter (filter)
+  {
+  }
+  private slots:void activated ();
+private:
+  Filter::HotSpot * _filter;
+};
+
+/** 
+ * A chain which allows a group of filters to be processed as one. 
+ * The chain owns the filters added to it and deletes them when the chain itself is destroyed.
+ *
+ * Use addFilter() to add a new filter to the chain.  
+ * When new text to be filtered arrives, use addLine() to add each additional
+ * line of text which needs to be processed and then after adding the last line, use
+ * process() to cause each filter in the chain to process the text.
+ *
+ * After processing a block of text, the reset() method can be used to set the filter chain's
+ * internal cursor back to the first line.
+ *
+ * The hotSpotAt() method will return the first hotspot which covers a given position.
+ *
+ * The hotSpots() and hotSpotsAtLine() method return all of the hotspots in the text and on
+ * a given line respectively.
+ */
+class FilterChain:protected QList < Filter * >
+{
+public:
+  virtual ~ FilterChain ();
+
+    /** Adds a new filter to the chain.  The chain will delete this filter when it is destroyed */
+  void addFilter (Filter * filter);
+    /** Removes a filter from the chain.  The chain will no longer delete the filter when destroyed */
+  void removeFilter (Filter * filter);
+    /** Returns true if the chain contains @p filter */
+  bool containsFilter (Filter * filter);
+    /** Removes all filters from the chain */
+  void clear ();
+
+    /** Resets each filter in the chain */
+  void reset ();
+    /**
+     * Processes each filter in the chain 
+     */
+  void process ();
+
+    /** Sets the buffer for each filter in the chain to process. */
+  void setBuffer (const QString * buffer, const QList < int >*linePositions);
+
+    /** Returns the first hotspot which occurs at @p line, @p column or 0 if no hotspot was found */
+    Filter::HotSpot * hotSpotAt (int line, int column) const;
+    /** Returns a list of all the hotspots in all the chain's filters */
+    QList < Filter::HotSpot * >hotSpots () const;
+    /** Returns a list of all hotspots at the given line in all the chain's filters */
+    QList < Filter::HotSpot > hotSpotsAtLine (int line) const;
+
+};
+
+/** A filter chain which processes character images from terminal displays */
+class TerminalImageFilterChain:public FilterChain
+{
+public:
+  TerminalImageFilterChain ();
+  virtual ~ TerminalImageFilterChain ();
+
+    /**
+     * Set the current terminal image to @p image.
+     *
+     * @param image The terminal image
+     * @param lines The number of lines in the terminal image
+     * @param columns The number of columns in the terminal image
+     * @param lineProperties The line properties to set for image
+     */
+  void setImage (const Character * const image, int lines, int columns,
+		 const QVector < LineProperty > &lineProperties);
+
+private:
+    QString * _buffer;
+    QList < int >*_linePositions;
+};
+
+#endif //FILTER_H
diff --git a/gui/src/terminal/History.cpp b/gui/src/terminal/History.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/History.cpp
@@ -0,0 +1,749 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "History.h"
+
+// System
+#include <iostream>
+#include <stdlib.h>
+#include <assert.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+// Reasonable line size
+#define LINE_SIZE	1024
+
+/*
+   An arbitrary long scroll.
+
+   One can modify the scroll only by adding either cells
+   or newlines, but access it randomly.
+
+   The model is that of an arbitrary wide typewriter scroll
+   in that the scroll is a serie of lines and each line is
+   a serie of cells with no overwriting permitted.
+
+   The implementation provides arbitrary length and numbers
+   of cells and line/column indexed read access to the scroll
+   at constant costs.
+
+KDE4: Can we use QTemporaryFile here, instead of KTempFile?
+
+FIXME: some complain about the history buffer comsuming the
+       memory of their machines. This problem is critical
+       since the history does not behave gracefully in cases
+       where the memory is used up completely.
+
+       I put in a workaround that should handle it problem
+       now gracefully. I'm not satisfied with the solution.
+
+FIXME: Terminating the history is not properly indicated
+       in the menu. We should throw a signal.
+
+FIXME: There is noticeable decrease in speed, also. Perhaps,
+       there whole feature needs to be revisited therefore.
+       Disadvantage of a more elaborated, say block-oriented
+       scheme with wrap around would be it's complexity.
+*/
+
+//FIXME: tempory replacement for tmpfile
+//       this is here one for debugging purpose.
+
+//#define tmpfile xTmpFile
+
+// History File ///////////////////////////////////////////
+
+/*
+  A Row(X) data type which allows adding elements to the end.
+*/
+
+HistoryFile::HistoryFile ():ion (-1), length (0), fileMap (0)
+{
+  if (tmpFile.open ())
+    {
+      tmpFile.setAutoRemove (true);
+      ion = tmpFile.handle ();
+    }
+}
+
+HistoryFile::~HistoryFile ()
+{
+  if (fileMap)
+    unmap ();
+}
+
+//TODO:  Mapping the entire file in will cause problems if the history file becomes exceedingly large,
+//(ie. larger than available memory).  HistoryFile::map() should only map in sections of the file at a time,
+//to avoid this.
+void
+HistoryFile::map ()
+{
+  assert (fileMap == 0);
+
+  fileMap = (char *) mmap (0, length, PROT_READ, MAP_PRIVATE, ion, 0);
+
+  //if mmap'ing fails, fall back to the read-lseek combination
+  if (fileMap == MAP_FAILED)
+    {
+      readWriteBalance = 0;
+      fileMap = 0;
+      qDebug () << ": mmap'ing history failed.  errno = " << errno;
+    }
+}
+
+void
+HistoryFile::unmap ()
+{
+  int result = munmap (fileMap, length);
+  assert (result == 0);
+
+  fileMap = 0;
+}
+
+bool
+HistoryFile::isMapped ()
+{
+  return (fileMap != 0);
+}
+
+void
+HistoryFile::add (const unsigned char *bytes, int len)
+{
+  if (fileMap)
+    unmap ();
+
+  readWriteBalance++;
+
+  int rc = 0;
+
+  rc = lseek (ion, length, SEEK_SET);
+  if (rc < 0)
+    {
+      perror ("HistoryFile::add.seek");
+      return;
+    }
+  rc = write (ion, bytes, len);
+  if (rc < 0)
+    {
+      perror ("HistoryFile::add.write");
+      return;
+    }
+  length += rc;
+}
+
+void
+HistoryFile::get (unsigned char *bytes, int len, int loc)
+{
+  //count number of get() calls vs. number of add() calls.  
+  //If there are many more get() calls compared with add() 
+  //calls (decided by using MAP_THRESHOLD) then mmap the log
+  //file to improve performance.
+  readWriteBalance--;
+  if (!fileMap && readWriteBalance < MAP_THRESHOLD)
+    map ();
+
+  if (fileMap)
+    {
+      for (int i = 0; i < len; i++)
+	bytes[i] = fileMap[loc + i];
+    }
+  else
+    {
+      int rc = 0;
+
+      if (loc < 0 || len < 0 || loc + len > length)
+	fprintf (stderr, "getHist(...,%d,%d): invalid args.\n", len, loc);
+      rc = lseek (ion, loc, SEEK_SET);
+      if (rc < 0)
+	{
+	  perror ("HistoryFile::get.seek");
+	  return;
+	}
+      rc = read (ion, bytes, len);
+      if (rc < 0)
+	{
+	  perror ("HistoryFile::get.read");
+	  return;
+	}
+    }
+}
+
+int
+HistoryFile::len ()
+{
+  return length;
+}
+
+
+// History Scroll abstract base class //////////////////////////////////////
+
+
+HistoryScroll::HistoryScroll (HistoryType * t):m_histType (t)
+{
+}
+
+HistoryScroll::~HistoryScroll ()
+{
+  delete m_histType;
+}
+
+bool
+HistoryScroll::hasScroll ()
+{
+  return true;
+}
+
+// History Scroll File //////////////////////////////////////
+
+/* 
+   The history scroll makes a Row(Row(Cell)) from
+   two history buffers. The index buffer contains
+   start of line positions which refere to the cells
+   buffer.
+
+   Note that index[0] addresses the second line
+   (line #1), while the first line (line #0) starts
+   at 0 in cells.
+*/
+
+HistoryScrollFile::HistoryScrollFile (const QString & logFileName):HistoryScroll (new HistoryTypeFile (logFileName)),
+m_logFileName
+(logFileName)
+{
+}
+
+HistoryScrollFile::~HistoryScrollFile ()
+{
+}
+
+int
+HistoryScrollFile::getLines ()
+{
+  return index.len () / sizeof (int);
+}
+
+int
+HistoryScrollFile::getLineLen (int lineno)
+{
+  return (startOfLine (lineno + 1) -
+	  startOfLine (lineno)) / sizeof (Character);
+}
+
+bool
+HistoryScrollFile::isWrappedLine (int lineno)
+{
+  if (lineno >= 0 && lineno <= getLines ())
+    {
+      unsigned char flag;
+      lineflags.get ((unsigned char *) &flag, sizeof (unsigned char),
+		     (lineno) * sizeof (unsigned char));
+      return flag;
+    }
+  return false;
+}
+
+int
+HistoryScrollFile::startOfLine (int lineno)
+{
+  if (lineno <= 0)
+    return 0;
+  if (lineno <= getLines ())
+    {
+
+      if (!index.isMapped ())
+	index.map ();
+
+      int res;
+      index.get ((unsigned char *) &res, sizeof (int),
+		 (lineno - 1) * sizeof (int));
+      return res;
+    }
+  return cells.len ();
+}
+
+void
+HistoryScrollFile::getCells (int lineno, int colno, int count,
+			     Character res[])
+{
+  cells.get ((unsigned char *) res, count * sizeof (Character),
+	     startOfLine (lineno) + colno * sizeof (Character));
+}
+
+void
+HistoryScrollFile::addCells (const Character text[], int count)
+{
+  cells.add ((unsigned char *) text, count * sizeof (Character));
+}
+
+void
+HistoryScrollFile::addLine (bool previousWrapped)
+{
+  if (index.isMapped ())
+    index.unmap ();
+
+  int locn = cells.len ();
+  index.add ((unsigned char *) &locn, sizeof (int));
+  unsigned char flags = previousWrapped ? 0x01 : 0x00;
+  lineflags.add ((unsigned char *) &flags, sizeof (unsigned char));
+}
+
+
+// History Scroll Buffer //////////////////////////////////////
+HistoryScrollBuffer::HistoryScrollBuffer (unsigned int maxLineCount):
+HistoryScroll (new HistoryTypeBuffer (maxLineCount)),
+_historyBuffer (),
+_maxLineCount (0),
+_usedLines (0),
+_head (0)
+{
+  setMaxNbLines (maxLineCount);
+}
+
+HistoryScrollBuffer::~HistoryScrollBuffer ()
+{
+  delete[]_historyBuffer;
+}
+
+void
+HistoryScrollBuffer::addCellsVector (const QVector < Character > &cells)
+{
+  _head++;
+  if (_usedLines < _maxLineCount)
+    _usedLines++;
+
+  if (_head >= _maxLineCount)
+    {
+      _head = 0;
+    }
+
+  _historyBuffer[bufferIndex (_usedLines - 1)] = cells;
+  _wrappedLine[bufferIndex (_usedLines - 1)] = false;
+}
+
+void
+HistoryScrollBuffer::addCells (const Character a[], int count)
+{
+  HistoryLine newLine (count);
+  qCopy (a, a + count, newLine.begin ());
+
+  addCellsVector (newLine);
+}
+
+void
+HistoryScrollBuffer::addLine (bool previousWrapped)
+{
+  _wrappedLine[bufferIndex (_usedLines - 1)] = previousWrapped;
+}
+
+int
+HistoryScrollBuffer::getLines ()
+{
+  return _usedLines;
+}
+
+int
+HistoryScrollBuffer::getLineLen (int lineNumber)
+{
+  Q_ASSERT (lineNumber >= 0 && lineNumber < _maxLineCount);
+
+  if (lineNumber < _usedLines)
+    {
+      return _historyBuffer[bufferIndex (lineNumber)].size ();
+    }
+  else
+    {
+      return 0;
+    }
+}
+
+bool
+HistoryScrollBuffer::isWrappedLine (int lineNumber)
+{
+  Q_ASSERT (lineNumber >= 0 && lineNumber < _maxLineCount);
+
+  if (lineNumber < _usedLines)
+    {
+      //kDebug() << "Line" << lineNumber << "wrapped is" << _wrappedLine[bufferIndex(lineNumber)];
+      return _wrappedLine[bufferIndex (lineNumber)];
+    }
+  else
+    return false;
+}
+
+void
+HistoryScrollBuffer::getCells (int lineNumber, int startColumn, int count,
+			       Character * buffer)
+{
+  if (count == 0)
+    return;
+
+  Q_ASSERT (lineNumber < _maxLineCount);
+
+  if (lineNumber >= _usedLines)
+    {
+      memset (buffer, 0, count * sizeof (Character));
+      return;
+    }
+
+  const HistoryLine & line = _historyBuffer[bufferIndex (lineNumber)];
+
+  //kDebug() << "startCol " << startColumn;
+  //kDebug() << "line.size() " << line.size();
+  //kDebug() << "count " << count;
+
+  Q_ASSERT (startColumn <= line.size () - count);
+
+  memcpy (buffer, line.constData () + startColumn,
+	  count * sizeof (Character));
+}
+
+void
+HistoryScrollBuffer::setMaxNbLines (unsigned int lineCount)
+{
+  HistoryLine *oldBuffer = _historyBuffer;
+  HistoryLine *newBuffer = new HistoryLine[lineCount];
+
+  for (int i = 0; i < qMin (_usedLines, (int) lineCount); i++)
+    {
+      newBuffer[i] = oldBuffer[bufferIndex (i)];
+    }
+
+  _usedLines = qMin (_usedLines, (int) lineCount);
+  _maxLineCount = lineCount;
+  _head = (_usedLines == _maxLineCount) ? 0 : _usedLines - 1;
+
+  _historyBuffer = newBuffer;
+  delete[]oldBuffer;
+
+  _wrappedLine.resize (lineCount);
+}
+
+int
+HistoryScrollBuffer::bufferIndex (int lineNumber)
+{
+  Q_ASSERT (lineNumber >= 0);
+  Q_ASSERT (lineNumber < _maxLineCount);
+  Q_ASSERT ((_usedLines == _maxLineCount) || lineNumber <= _head);
+
+  if (_usedLines == _maxLineCount)
+    {
+      return (_head + lineNumber + 1) % _maxLineCount;
+    }
+  else
+    {
+      return lineNumber;
+    }
+}
+
+
+// History Scroll None //////////////////////////////////////
+
+HistoryScrollNone::HistoryScrollNone ():HistoryScroll (new HistoryTypeNone ())
+{
+}
+
+HistoryScrollNone::~HistoryScrollNone ()
+{
+}
+
+bool
+HistoryScrollNone::hasScroll ()
+{
+  return false;
+}
+
+int
+HistoryScrollNone::getLines ()
+{
+  return 0;
+}
+
+int
+HistoryScrollNone::getLineLen (int)
+{
+  return 0;
+}
+
+bool
+HistoryScrollNone::isWrappedLine (int /*lineno */ )
+{
+  return false;
+}
+
+void
+HistoryScrollNone::getCells (int, int, int, Character[])
+{
+}
+
+void
+HistoryScrollNone::addCells (const Character[], int)
+{
+}
+
+void
+HistoryScrollNone::addLine (bool)
+{
+}
+
+// History Scroll BlockArray //////////////////////////////////////
+
+HistoryScrollBlockArray::HistoryScrollBlockArray (size_t size):HistoryScroll (new
+	       HistoryTypeBlockArray
+	       (size))
+{
+  //m_blockArray.setHistorySize (size);	// nb. of lines.
+}
+
+HistoryScrollBlockArray::~HistoryScrollBlockArray ()
+{
+}
+
+int
+HistoryScrollBlockArray::getLines ()
+{
+  return m_lineLengths.count ();
+}
+
+int
+HistoryScrollBlockArray::getLineLen (int lineno)
+{
+  if (m_lineLengths.contains (lineno))
+    return m_lineLengths[lineno];
+  else
+    return 0;
+}
+
+bool
+HistoryScrollBlockArray::isWrappedLine (int /*lineno */ )
+{
+  return false;
+}
+
+void
+HistoryScrollBlockArray::getCells (int lineno, int colno,
+				   int count, Character res[])
+{
+  Q_UNUSED(lineno);
+  Q_UNUSED(colno);
+  Q_UNUSED(count);
+  Q_UNUSED(res);
+}
+
+void
+HistoryScrollBlockArray::addCells (const Character a[], int count)
+{
+  Q_UNUSED(a);
+  Q_UNUSED(count);
+}
+
+void
+HistoryScrollBlockArray::addLine (bool)
+{
+}
+
+//////////////////////////////////////////////////////////////////////
+// History Types
+//////////////////////////////////////////////////////////////////////
+
+HistoryType::HistoryType ()
+{
+}
+
+HistoryType::~HistoryType ()
+{
+}
+
+//////////////////////////////
+
+HistoryTypeNone::HistoryTypeNone ()
+{
+}
+
+bool
+HistoryTypeNone::isEnabled () const
+{
+  return false;
+}
+
+HistoryScroll *
+HistoryTypeNone::scroll (HistoryScroll * old) const
+{
+  delete old;
+  return new HistoryScrollNone ();
+}
+
+int
+HistoryTypeNone::maximumLineCount () const
+{
+  return 0;
+}
+
+//////////////////////////////
+
+HistoryTypeBlockArray::HistoryTypeBlockArray (size_t size):m_size (size)
+{
+}
+
+bool
+HistoryTypeBlockArray::isEnabled () const
+{
+  return true;
+}
+
+int
+HistoryTypeBlockArray::maximumLineCount () const
+{
+  return m_size;
+}
+
+HistoryScroll *
+HistoryTypeBlockArray::scroll (HistoryScroll * old) const
+{
+  delete old;
+  return new HistoryScrollBlockArray (m_size);
+}
+
+
+//////////////////////////////
+
+HistoryTypeBuffer::HistoryTypeBuffer (unsigned int nbLines):m_nbLines (nbLines)
+{
+}
+
+bool
+HistoryTypeBuffer::isEnabled () const
+{
+  return true;
+}
+
+int
+HistoryTypeBuffer::maximumLineCount () const
+{
+  return m_nbLines;
+}
+
+HistoryScroll *
+HistoryTypeBuffer::scroll (HistoryScroll * old) const
+{
+  if (old)
+    {
+      HistoryScrollBuffer *oldBuffer =
+	dynamic_cast < HistoryScrollBuffer * >(old);
+      if (oldBuffer)
+	{
+	  oldBuffer->setMaxNbLines (m_nbLines);
+	  return oldBuffer;
+	}
+
+      HistoryScroll *newScroll = new HistoryScrollBuffer (m_nbLines);
+      int lines = old->getLines ();
+      int startLine = 0;
+      if (lines > (int) m_nbLines)
+	startLine = lines - m_nbLines;
+
+      Character line[LINE_SIZE];
+      for (int i = startLine; i < lines; i++)
+	{
+	  int size = old->getLineLen (i);
+	  if (size > LINE_SIZE)
+	    {
+	      Character *tmp_line = new Character[size];
+	      old->getCells (i, 0, size, tmp_line);
+	      newScroll->addCells (tmp_line, size);
+	      newScroll->addLine (old->isWrappedLine (i));
+	      delete[]tmp_line;
+	    }
+	  else
+	    {
+	      old->getCells (i, 0, size, line);
+	      newScroll->addCells (line, size);
+	      newScroll->addLine (old->isWrappedLine (i));
+	    }
+	}
+      delete old;
+      return newScroll;
+    }
+  return new HistoryScrollBuffer (m_nbLines);
+}
+
+//////////////////////////////
+
+HistoryTypeFile::HistoryTypeFile (const QString & fileName):m_fileName
+  (fileName)
+{
+}
+
+bool
+HistoryTypeFile::isEnabled () const
+{
+  return true;
+}
+
+const QString &
+HistoryTypeFile::getFileName () const
+{
+  return m_fileName;
+}
+
+HistoryScroll *
+HistoryTypeFile::scroll (HistoryScroll * old) const
+{
+  if (dynamic_cast < HistoryFile * >(old))
+    return old;			// Unchanged.
+
+  HistoryScroll *newScroll = new HistoryScrollFile (m_fileName);
+
+  Character line[LINE_SIZE];
+  int lines = (old != 0) ? old->getLines () : 0;
+  for (int i = 0; i < lines; i++)
+    {
+      int size = old->getLineLen (i);
+      if (size > LINE_SIZE)
+	{
+	  Character *tmp_line = new Character[size];
+	  old->getCells (i, 0, size, tmp_line);
+	  newScroll->addCells (tmp_line, size);
+	  newScroll->addLine (old->isWrappedLine (i));
+	  delete[]tmp_line;
+	}
+      else
+	{
+	  old->getCells (i, 0, size, line);
+	  newScroll->addCells (line, size);
+	  newScroll->addLine (old->isWrappedLine (i));
+	}
+    }
+
+  delete old;
+  return newScroll;
+}
+
+int
+HistoryTypeFile::maximumLineCount () const
+{
+  return 0;
+}
diff --git a/gui/src/terminal/History.h b/gui/src/terminal/History.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/History.h
@@ -0,0 +1,321 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef HISTORY_H
+#define HISTORY_H
+
+// Qt
+#include <QtCore/QBitRef>
+#include <QtCore/QHash>
+#include <QtCore>
+
+// Konsole
+#include "Character.h"
+
+class HistoryFile
+{
+public:
+  HistoryFile ();
+  virtual ~ HistoryFile ();
+
+  virtual void add (const unsigned char *bytes, int len);
+  virtual void get (unsigned char *bytes, int len, int loc);
+  virtual int len ();
+
+  //mmaps the file in read-only mode
+  void map ();
+  //un-mmaps the file
+  void unmap ();
+  //returns true if the file is mmap'ed
+  bool isMapped ();
+
+
+private:
+  int ion;
+  int length;
+  QTemporaryFile tmpFile;
+
+  //pointer to start of mmap'ed file data, or 0 if the file is not mmap'ed
+  char *fileMap;
+
+  //incremented whenver 'add' is called and decremented whenever
+  //'get' is called.
+  //this is used to detect when a large number of lines are being read and processed from the history
+  //and automatically mmap the file for better performance (saves the overhead of many lseek-read calls).
+  int readWriteBalance;
+
+  //when readWriteBalance goes below this threshold, the file will be mmap'ed automatically
+  static const int MAP_THRESHOLD = -1000;
+};
+
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+// Abstract base class for file and buffer versions
+//////////////////////////////////////////////////////////////////////
+class HistoryType;
+
+class HistoryScroll
+{
+public:
+  HistoryScroll (HistoryType *);
+  virtual ~ HistoryScroll ();
+
+  virtual bool hasScroll ();
+
+  // access to history
+  virtual int getLines () = 0;
+  virtual int getLineLen (int lineno) = 0;
+  virtual void getCells (int lineno, int colno, int count, Character res[]) =
+    0;
+  virtual bool isWrappedLine (int lineno) = 0;
+
+  // backward compatibility (obsolete)
+  Character getCell (int lineno, int colno)
+  {
+    Character res;
+      getCells (lineno, colno, 1, &res);
+      return res;
+  }
+
+  // adding lines.
+  virtual void addCells (const Character a[], int count) = 0;
+  // convenience method - this is virtual so that subclasses can take advantage
+  // of QVector's implicit copying
+  virtual void addCellsVector (const QVector < Character > &cells)
+  {
+    addCells (cells.data (), cells.size ());
+  }
+
+  virtual void addLine (bool previousWrapped = false) = 0;
+
+  //
+  // FIXME:  Passing around constant references to HistoryType instances
+  // is very unsafe, because those references will no longer
+  // be valid if the history scroll is deleted.
+  //
+  const HistoryType & getType ()
+  {
+    return *m_histType;
+  }
+
+protected:
+  HistoryType * m_histType;
+
+};
+
+
+
+//////////////////////////////////////////////////////////////////////
+// File-based history (e.g. file log, no limitation in length)
+//////////////////////////////////////////////////////////////////////
+
+class HistoryScrollFile:public HistoryScroll
+{
+public:
+  HistoryScrollFile (const QString & logFileName);
+  virtual ~ HistoryScrollFile ();
+
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
+
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
+
+private:
+  int startOfLine (int lineno);
+
+  QString m_logFileName;
+  HistoryFile index;		// lines Row(int)
+  HistoryFile cells;		// text  Row(Character)
+  HistoryFile lineflags;	// flags Row(unsigned char)
+};
+
+
+//////////////////////////////////////////////////////////////////////
+// Buffer-based history (limited to a fixed nb of lines)
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollBuffer:public HistoryScroll
+{
+public:
+  typedef QVector < Character > HistoryLine;
+
+    HistoryScrollBuffer (unsigned int maxNbLines = 1000);
+    virtual ~ HistoryScrollBuffer ();
+
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
+
+  virtual void addCells (const Character a[], int count);
+  virtual void addCellsVector (const QVector < Character > &cells);
+  virtual void addLine (bool previousWrapped = false);
+
+  void setMaxNbLines (unsigned int nbLines);
+  unsigned int maxNbLines ()
+  {
+    return _maxLineCount;
+  }
+
+
+private:
+  int bufferIndex (int lineNumber);
+
+  HistoryLine *_historyBuffer;
+  QBitArray _wrappedLine;
+  int _maxLineCount;
+  int _usedLines;
+  int _head;
+};
+
+//////////////////////////////////////////////////////////////////////
+// Nothing-based history (no history :-)
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollNone:public HistoryScroll
+{
+public:
+  HistoryScrollNone ();
+  virtual ~ HistoryScrollNone ();
+
+  virtual bool hasScroll ();
+
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
+
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
+};
+
+//////////////////////////////////////////////////////////////////////
+// BlockArray-based history
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollBlockArray:public HistoryScroll
+{
+public:
+  HistoryScrollBlockArray (size_t size);
+  virtual ~ HistoryScrollBlockArray ();
+
+  virtual int getLines ();
+  virtual int getLineLen (int lineno);
+  virtual void getCells (int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine (int lineno);
+
+  virtual void addCells (const Character a[], int count);
+  virtual void addLine (bool previousWrapped = false);
+
+protected:
+    //BlockArray m_blockArray;
+    QHash < int, size_t > m_lineLengths;
+};
+
+//////////////////////////////////////////////////////////////////////
+// History type
+//////////////////////////////////////////////////////////////////////
+
+class HistoryType
+{
+public:
+  HistoryType ();
+  virtual ~ HistoryType ();
+
+  /**
+   * Returns true if the history is enabled ( can store lines of output )
+   * or false otherwise. 
+   */
+  virtual bool isEnabled () const = 0;
+  /**
+   * Returns true if the history size is unlimited.
+   */
+  bool isUnlimited () const
+  {
+    return maximumLineCount () == 0;
+  }
+  /**
+   * Returns the maximum number of lines which this history type
+   * can store or 0 if the history can store an unlimited number of lines.
+   */
+  virtual int maximumLineCount () const = 0;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const = 0;
+};
+
+class HistoryTypeNone:public HistoryType
+{
+public:
+  HistoryTypeNone ();
+
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
+};
+
+class HistoryTypeBlockArray:public HistoryType
+{
+public:
+  HistoryTypeBlockArray (size_t size);
+
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
+
+protected:
+    size_t m_size;
+};
+
+class HistoryTypeFile:public HistoryType
+{
+public:
+  HistoryTypeFile (const QString & fileName = QString ());
+
+  virtual bool isEnabled () const;
+  virtual const QString & getFileName () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
+
+protected:
+    QString m_fileName;
+};
+
+
+class HistoryTypeBuffer:public HistoryType
+{
+public:
+  HistoryTypeBuffer (unsigned int nbLines);
+
+  virtual bool isEnabled () const;
+  virtual int maximumLineCount () const;
+
+  virtual HistoryScroll *scroll (HistoryScroll *) const;
+
+protected:
+  unsigned int m_nbLines;
+};
+
+#endif // HISTORY_H
diff --git a/gui/src/terminal/KeyboardTranslator.cpp b/gui/src/terminal/KeyboardTranslator.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/KeyboardTranslator.cpp
@@ -0,0 +1,1091 @@
+/*
+    This source file is part of Konsole, a terminal emulator.
+
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "KeyboardTranslator.h"
+
+// System
+#include <ctype.h>
+#include <stdio.h>
+
+// Qt
+#include <QtCore/QBuffer>
+#include <QtCore/QFile>
+#include <QtCore/QFileInfo>
+#include <QtCore/QTextStream>
+#include <QtGui/QKeySequence>
+#include <QtCore/QDir>
+#include <QtCore/QStringList>
+#include <QtCore/QDebug>
+#include <QtCore/QDataStream>
+
+const QByteArray
+KeyboardTranslatorManager::
+
+defaultTranslatorText ("keyboard \"Fallback Key Translator\"\n"
+		       "key Tab : \"\\t\"");
+
+KeyboardTranslatorManager::KeyboardTranslatorManager ():_haveLoadedAll (false)
+{
+}
+
+KeyboardTranslatorManager::~KeyboardTranslatorManager ()
+{
+  qDeleteAll (_translators);
+}
+
+QString
+KeyboardTranslatorManager::findTranslatorPath (const QString & name)
+{
+  QString translatorFile = QString ("../kb-layouts/" + name + ".keytab");
+  if (QFile::exists (translatorFile))
+    return translatorFile;
+  return QString ("/usr/share/octave/quint/kb-layouts/" + name + ".keytab");
+}
+
+void
+KeyboardTranslatorManager::findTranslators ()
+{
+  //QStringList list = KGlobal::dirs()->findAllResources("data",
+  //                                                     "konsole/*.keytab",
+  //                                                     KStandardDirs::NoDuplicates);
+
+  QDir dir ("../kb-layouts/");
+  QStringList filters;
+  filters << "*.keytab";
+  dir.setNameFilters (filters);
+  QStringList list = dir.entryList (filters);
+
+  // add the name of each translator to the list and associated
+  // the name with a null pointer to indicate that the translator
+  // has not yet been loaded from disk
+  QStringListIterator listIter (list);
+  while (listIter.hasNext ())
+    {
+      QString translatorPath = listIter.next ();
+
+      QString name = QFileInfo (translatorPath).baseName ();
+
+      if (!_translators.contains (name))
+	_translators.insert (name, 0);
+    }
+
+  _haveLoadedAll = true;
+}
+
+const KeyboardTranslator *
+KeyboardTranslatorManager::findTranslator (const QString & name)
+{
+  if (name.isEmpty ())
+    return defaultTranslator ();
+
+  if (_translators.contains (name) && _translators[name] != 0)
+    return _translators[name];
+
+  KeyboardTranslator *translator = loadTranslator (name);
+
+  if (translator != 0)
+    _translators[name] = translator;
+  //else if ( !name.isEmpty() )
+  //  kWarning() << "Unable to load translator" << name;
+
+  return translator;
+}
+
+bool
+KeyboardTranslatorManager::saveTranslator (const KeyboardTranslator *
+					   translator)
+{
+  //const QString path = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
+  //         +".keytab";
+  const QString path = ".keytab";
+
+  //kDebug() << "Saving translator to" << path;
+
+  QFile destination (path);
+  if (!destination.open (QIODevice::WriteOnly | QIODevice::Text))
+    {
+      //kWarning() << "Unable to save keyboard translation:"
+      //          << destination.errorString();
+      return false;
+    }
+
+  {
+    KeyboardTranslatorWriter writer (&destination);
+    writer.writeHeader (translator->description ());
+
+    QListIterator < KeyboardTranslator::Entry > iter (translator->entries ());
+    while (iter.hasNext ())
+      writer.writeEntry (iter.next ());
+  }
+
+  destination.close ();
+
+  return true;
+}
+
+KeyboardTranslator *
+KeyboardTranslatorManager::loadTranslator (const QString & name)
+{
+  const QString & path = findTranslatorPath (name);
+
+  QFile source (path);
+  if (name.isEmpty () || !source.open (QIODevice::ReadOnly | QIODevice::Text))
+    return 0;
+
+  return loadTranslator (&source, name);
+}
+
+const KeyboardTranslator *
+KeyboardTranslatorManager::defaultTranslator ()
+{
+  // Try to find the default.keytab file if it exists, otherwise
+  // fall back to the hard-coded one
+  const KeyboardTranslator *translator = findTranslator ("default");
+  if (!translator)
+    {
+      QBuffer textBuffer;
+      textBuffer.setData (defaultTranslatorText);
+      textBuffer.open (QIODevice::ReadOnly);
+      translator = loadTranslator (&textBuffer, "fallback");
+    }
+  return translator;
+}
+
+KeyboardTranslator *
+KeyboardTranslatorManager::loadTranslator (QIODevice * source,
+					   const QString & name)
+{
+  KeyboardTranslator *translator = new KeyboardTranslator (name);
+  KeyboardTranslatorReader reader (source);
+  translator->setDescription (reader.description ());
+  while (reader.hasNextEntry ())
+    translator->addEntry (reader.nextEntry ());
+
+  source->close ();
+
+  if (!reader.parseError ())
+    {
+      return translator;
+    }
+  else
+    {
+      delete translator;
+      return 0;
+    }
+}
+
+KeyboardTranslatorWriter::KeyboardTranslatorWriter (QIODevice * destination):_destination
+  (destination)
+{
+  Q_ASSERT (destination && destination->isWritable ());
+
+  _writer = new QTextStream (_destination);
+}
+
+KeyboardTranslatorWriter::~KeyboardTranslatorWriter ()
+{
+  delete _writer;
+}
+
+void
+KeyboardTranslatorWriter::writeHeader (const QString & description)
+{
+  *_writer << "keyboard \"" << description << '\"' << '\n';
+}
+
+void
+KeyboardTranslatorWriter::writeEntry (const KeyboardTranslator::Entry & entry)
+{
+  QString result;
+  if (entry.command () != KeyboardTranslator::NoCommand)
+    result = entry.resultToString ();
+  else
+    result = '\"' + entry.resultToString () + '\"';
+
+  *_writer << "key " << entry.conditionToString () << " : " << result << '\n';
+}
+
+
+// each line of the keyboard translation file is one of:
+//
+// - keyboard "name"
+// - key KeySequence : "characters"
+// - key KeySequence : CommandName
+//
+// KeySequence begins with the name of the key ( taken from the Qt::Key enum )
+// and is followed by the keyboard modifiers and state flags ( with + or - in front
+// of each modifier or flag to indicate whether it is required ).  All keyboard modifiers
+// and flags are optional, if a particular modifier or state is not specified it is 
+// assumed not to be a part of the sequence.  The key sequence may contain whitespace
+//
+// eg:  "key Up+Shift : scrollLineUp"
+//      "key Next-Shift : "\E[6~"
+//
+// (lines containing only whitespace are ignored, parseLine assumes that comments have
+// already been removed)
+//
+
+KeyboardTranslatorReader::KeyboardTranslatorReader (QIODevice * source):_source (source),
+_hasNext
+(false)
+{
+  // read input until we find the description
+  while (_description.isEmpty () && !source->atEnd ())
+    {
+      QList < Token > tokens = tokenize (QString (source->readLine ()));
+      if (!tokens.isEmpty () && tokens.first ().type == Token::TitleKeyword)
+	_description = QString (tokens[1].text.toLatin1 ().data ());
+    }
+  // read first entry (if any)
+  readNext ();
+}
+
+void
+KeyboardTranslatorReader::readNext ()
+{
+  // find next entry
+  while (!_source->atEnd ())
+    {
+      const QList < Token > &tokens =
+	tokenize (QString (_source->readLine ()));
+      if (!tokens.isEmpty () && tokens.first ().type == Token::KeyKeyword)
+	{
+	  KeyboardTranslator::States flags = KeyboardTranslator::NoState;
+	  KeyboardTranslator::States flagMask = KeyboardTranslator::NoState;
+	  Qt::KeyboardModifiers modifiers = Qt::NoModifier;
+	  Qt::KeyboardModifiers modifierMask = Qt::NoModifier;
+
+	  int keyCode = Qt::Key_unknown;
+
+	  decodeSequence (tokens[1].text.toLower (),
+			  keyCode, modifiers, modifierMask, flags, flagMask);
+
+	  KeyboardTranslator::Command command = KeyboardTranslator::NoCommand;
+	  QByteArray text;
+
+	  // get text or command
+	  if (tokens[2].type == Token::OutputText)
+	    {
+	      text = tokens[2].text.toLocal8Bit ();
+	    }
+	  else if (tokens[2].type == Token::Command)
+	    {
+	      // identify command
+	      // if (!parseAsCommand(tokens[2].text,command))
+	      //  kWarning() << "Command" << tokens[2].text << "not understood.";
+	    }
+
+	  KeyboardTranslator::Entry newEntry;
+	  newEntry.setKeyCode (keyCode);
+	  newEntry.setState (flags);
+	  newEntry.setStateMask (flagMask);
+	  newEntry.setModifiers (modifiers);
+	  newEntry.setModifierMask (modifierMask);
+	  newEntry.setText (text);
+	  newEntry.setCommand (command);
+
+	  _nextEntry = newEntry;
+
+	  _hasNext = true;
+
+	  return;
+	}
+    }
+
+  _hasNext = false;
+}
+
+bool
+KeyboardTranslatorReader::parseAsCommand (const QString & text,
+					  KeyboardTranslator::
+					  Command & command)
+{
+  if (text.compare ("erase", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::EraseCommand;
+  else if (text.compare ("scrollpageup", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollPageUpCommand;
+  else if (text.compare ("scrollpagedown", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollPageDownCommand;
+  else if (text.compare ("scrolllineup", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLineUpCommand;
+  else if (text.compare ("scrolllinedown", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLineDownCommand;
+  else if (text.compare ("scrolllock", Qt::CaseInsensitive) == 0)
+    command = KeyboardTranslator::ScrollLockCommand;
+  else
+    return false;
+
+  return true;
+}
+
+bool
+KeyboardTranslatorReader::decodeSequence (const QString & text,
+					  int &keyCode,
+					  Qt::KeyboardModifiers & modifiers,
+					  Qt::
+					  KeyboardModifiers & modifierMask,
+					  KeyboardTranslator::States & flags,
+					  KeyboardTranslator::
+					  States & flagMask)
+{
+  bool isWanted = true;
+  bool endOfItem = false;
+  QString buffer;
+
+  Qt::KeyboardModifiers tempModifiers = modifiers;
+  Qt::KeyboardModifiers tempModifierMask = modifierMask;
+  KeyboardTranslator::States tempFlags = flags;
+  KeyboardTranslator::States tempFlagMask = flagMask;
+
+  for (int i = 0; i < text.count (); i++)
+    {
+      const QChar & ch = text[i];
+      bool isFirstLetter = i == 0;
+      bool isLastLetter = (i == text.count () - 1);
+      endOfItem = true;
+      if (ch.isLetterOrNumber ())
+	{
+	  endOfItem = false;
+	  buffer.append (ch);
+	}
+      else if (isFirstLetter)
+	{
+	  buffer.append (ch);
+	}
+
+      if ((endOfItem || isLastLetter) && !buffer.isEmpty ())
+	{
+	  Qt::KeyboardModifier itemModifier = Qt::NoModifier;
+	  int itemKeyCode = 0;
+	  KeyboardTranslator::State itemFlag = KeyboardTranslator::NoState;
+
+	  if (parseAsModifier (buffer, itemModifier))
+	    {
+	      tempModifierMask |= itemModifier;
+
+	      if (isWanted)
+		tempModifiers |= itemModifier;
+	    }
+	  else if (parseAsStateFlag (buffer, itemFlag))
+	    {
+	      tempFlagMask |= itemFlag;
+
+	      if (isWanted)
+		tempFlags |= itemFlag;
+	    }
+	  else if (parseAsKeyCode (buffer, itemKeyCode))
+	    keyCode = itemKeyCode;
+	  //else
+	  //      kWarning() << "Unable to parse key binding item:" << buffer;
+
+	  buffer.clear ();
+	}
+
+      // check if this is a wanted / not-wanted flag and update the 
+      // state ready for the next item
+      if (ch == '+')
+	isWanted = true;
+      else if (ch == '-')
+	isWanted = false;
+    }
+
+  modifiers = tempModifiers;
+  modifierMask = tempModifierMask;
+  flags = tempFlags;
+  flagMask = tempFlagMask;
+
+  return true;
+}
+
+bool
+KeyboardTranslatorReader::parseAsModifier (const QString & item,
+					   Qt::KeyboardModifier & modifier)
+{
+  if (item == "shift")
+    modifier = Qt::ShiftModifier;
+  else if (item == "ctrl" || item == "control")
+    modifier = Qt::ControlModifier;
+  else if (item == "alt")
+    modifier = Qt::AltModifier;
+  else if (item == "meta")
+    modifier = Qt::MetaModifier;
+  else if (item == "keypad")
+    modifier = Qt::KeypadModifier;
+  else
+    return false;
+
+  return true;
+}
+
+bool
+KeyboardTranslatorReader::parseAsStateFlag (const QString & item,
+					    KeyboardTranslator::State & flag)
+{
+  if (item == "appcukeys" || item == "appcursorkeys")
+    flag = KeyboardTranslator::CursorKeysState;
+  else if (item == "ansi")
+    flag = KeyboardTranslator::AnsiState;
+  else if (item == "newline")
+    flag = KeyboardTranslator::NewLineState;
+  else if (item == "appscreen")
+    flag = KeyboardTranslator::AlternateScreenState;
+  else if (item == "anymod" || item == "anymodifier")
+    flag = KeyboardTranslator::AnyModifierState;
+  else if (item == "appkeypad")
+    flag = KeyboardTranslator::ApplicationKeypadState;
+  else
+    return false;
+
+  return true;
+}
+
+bool
+KeyboardTranslatorReader::parseAsKeyCode (const QString & item, int &keyCode)
+{
+  QKeySequence sequence = QKeySequence::fromString (item);
+  if (!sequence.isEmpty ())
+    {
+      keyCode = sequence[0];
+
+      if (sequence.count () > 1)
+	{
+	  //kWarning() << "Unhandled key codes in sequence: " << item;
+	}
+    }
+  // additional cases implemented for backwards compatibility with KDE 3
+  else if (item == "prior")
+    keyCode = Qt::Key_PageUp;
+  else if (item == "next")
+    keyCode = Qt::Key_PageDown;
+  else
+    return false;
+
+  return true;
+}
+
+QString
+KeyboardTranslatorReader::description () const
+{
+  return _description;
+}
+
+bool
+KeyboardTranslatorReader::hasNextEntry ()
+{
+  return _hasNext;
+}
+
+KeyboardTranslator::Entry KeyboardTranslatorReader::
+createEntry (const QString & condition, const QString & result)
+{
+  QString
+  entryString ("keyboard \"temporary\"\nkey ");
+  entryString.append (condition);
+  entryString.append (" : ");
+
+  // if 'result' is the name of a command then the entry result will be that command,
+  // otherwise the result will be treated as a string to echo when the key sequence
+  // specified by 'condition' is pressed
+  KeyboardTranslator::Command command;
+  if (parseAsCommand (result, command))
+    entryString.append (result);
+  else
+    entryString.append ('\"' + result + '\"');
+
+  QByteArray
+    array = entryString.toUtf8 ();
+  QBuffer
+  buffer (&array);
+  buffer.open (QIODevice::ReadOnly);
+  KeyboardTranslatorReader
+  reader (&buffer);
+
+  KeyboardTranslator::Entry entry;
+  if (reader.hasNextEntry ())
+    entry = reader.nextEntry ();
+
+  return entry;
+}
+
+KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry ()
+{
+  Q_ASSERT (_hasNext);
+  KeyboardTranslator::Entry entry = _nextEntry;
+  readNext ();
+  return entry;
+}
+
+bool
+KeyboardTranslatorReader::parseError ()
+{
+  return false;
+}
+
+QList < KeyboardTranslatorReader::Token >
+  KeyboardTranslatorReader::tokenize (const QString & line)
+{
+  QString text = line;
+
+  // remove comments 
+  bool inQuotes = false;
+  int commentPos = -1;
+  for (int i = text.length () - 1; i >= 0; i--)
+    {
+      QChar ch = text[i];
+      if (ch == '\"')
+	inQuotes = !inQuotes;
+      else if (ch == '#' && !inQuotes)
+	commentPos = i;
+    }
+  if (commentPos != -1)
+    text.remove (commentPos, text.length ());
+
+  text = text.simplified ();
+
+  // title line: keyboard "title"
+  static QRegExp title ("keyboard\\s+\"(.*)\"");
+  // key line: key KeySequence : "output"
+  // key line: key KeySequence : command
+  static QRegExp
+    key ("key\\s+([\\w\\+\\s\\-\\*\\.]+)\\s*:\\s*(\"(.*)\"|\\w+)");
+
+  QList < Token > list;
+  if (text.isEmpty ())
+    {
+      return list;
+    }
+
+  if (title.exactMatch (text))
+    {
+      Token titleToken = { Token::TitleKeyword, QString () };
+      Token textToken = { Token::TitleText, title.capturedTexts ()[1] };
+
+      list << titleToken << textToken;
+    }
+  else if (key.exactMatch (text))
+    {
+      Token keyToken = { Token::KeyKeyword, QString () };
+      Token sequenceToken =
+	{ Token::KeySequence, key.capturedTexts ()[1].remove (' ') };
+
+      list << keyToken << sequenceToken;
+
+      if (key.capturedTexts ()[3].isEmpty ())
+	{
+	  // capturedTexts()[2] is a command
+	  Token commandToken = { Token::Command, key.capturedTexts ()[2] };
+	  list << commandToken;
+	}
+      else
+	{
+	  // capturedTexts()[3] is the output string
+	  Token outputToken = { Token::OutputText, key.capturedTexts ()[3] };
+	  list << outputToken;
+	}
+    }
+  else
+    {
+      //kWarning() << "Line in keyboard translator file could not be understood:" << text;
+    }
+
+  return list;
+}
+
+QList < QString > KeyboardTranslatorManager::allTranslators ()
+{
+  if (!_haveLoadedAll)
+    {
+      findTranslators ();
+    }
+
+  return _translators.keys ();
+}
+
+KeyboardTranslator::Entry::Entry ():_keyCode (0), _modifiers (Qt::NoModifier), _modifierMask (Qt::NoModifier),
+_state (NoState), _stateMask (NoState),
+_command (NoCommand)
+{
+}
+
+bool
+KeyboardTranslator::Entry::operator== (const Entry & rhs) const
+{
+  return _keyCode == rhs._keyCode &&
+    _modifiers == rhs._modifiers &&
+    _modifierMask == rhs._modifierMask &&
+    _state == rhs._state &&
+    _stateMask == rhs._stateMask &&
+    _command == rhs._command && _text == rhs._text;
+}
+
+bool
+KeyboardTranslator::Entry::matches (int keyCode,
+				    Qt::KeyboardModifiers modifiers,
+                                    States testState) const
+{
+  if (_keyCode != keyCode)
+    return false;
+
+  if ((modifiers & _modifierMask) != (_modifiers & _modifierMask))
+    return false;
+
+  // if modifiers is non-zero, the 'any modifier' state is implicit
+  if (modifiers != 0)
+    testState |= AnyModifierState;
+
+  if ((testState & _stateMask) != (_state & _stateMask))
+    return false;
+
+  // special handling for the 'Any Modifier' state, which checks for the presence of 
+  // any or no modifiers.  In this context, the 'keypad' modifier does not count.
+  bool
+    anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
+  bool
+    wantAnyModifier = _state & KeyboardTranslator::AnyModifierState;
+  if (_stateMask & KeyboardTranslator::AnyModifierState)
+    {
+      if (wantAnyModifier != anyModifiersSet)
+	return false;
+    }
+
+  return true;
+}
+
+QByteArray
+KeyboardTranslator::Entry::escapedText (bool expandWildCards,
+					Qt::
+					KeyboardModifiers modifiers) const
+{
+  QByteArray
+  result (text (expandWildCards, modifiers));
+
+  for (int i = 0; i < result.count (); i++)
+    {
+      char
+	ch = result[i];
+      char
+	replacement = 0;
+
+      switch (ch)
+	{
+	case 27:
+	  replacement = 'E';
+	  break;
+	case 8:
+	  replacement = 'b';
+	  break;
+	case 12:
+	  replacement = 'f';
+	  break;
+	case 9:
+	  replacement = 't';
+	  break;
+	case 13:
+	  replacement = 'r';
+	  break;
+	case 10:
+	  replacement = 'n';
+	  break;
+	default:
+	  // any character which is not printable is replaced by an equivalent
+	  // \xhh escape sequence (where 'hh' are the corresponding hex digits)
+	  if (!QChar (ch).isPrint ())
+	    replacement = 'x';
+	}
+
+      if (replacement == 'x')
+	{
+	  result.replace (i, 1, "\\x" + QByteArray (1, ch).toHex ());
+	}
+      else if (replacement != 0)
+	{
+	  result.remove (i, 1);
+	  result.insert (i, '\\');
+	  result.insert (i + 1, replacement);
+	}
+    }
+
+  return result;
+}
+
+QByteArray
+KeyboardTranslator::Entry::unescape (const QByteArray & input) const
+{
+  QByteArray
+  result (input);
+
+  for (int i = 0; i < result.count () - 1; i++)
+    {
+
+      QByteRef
+	ch = result[i];
+      if (ch == '\\')
+	{
+	  char
+	  replacement[2] = { 0, 0 };
+	  int
+	    charsToRemove = 2;
+	  bool
+	    escapedChar = true;
+
+	  switch (result[i + 1])
+	    {
+	    case 'E':
+	      replacement[0] = 27;
+	      break;
+	    case 'b':
+	      replacement[0] = 8;
+	      break;
+	    case 'f':
+	      replacement[0] = 12;
+	      break;
+	    case 't':
+	      replacement[0] = 9;
+	      break;
+	    case 'r':
+	      replacement[0] = 13;
+	      break;
+	    case 'n':
+	      replacement[0] = 10;
+	      break;
+	    case 'x':
+	      {
+		// format is \xh or \xhh where 'h' is a hexadecimal
+		// digit from 0-9 or A-F which should be replaced
+		// with the corresponding character value
+		char
+		hexDigits[3] = { 0 };
+
+		if ((i < result.count () - 2) && isxdigit (result[i + 2]))
+		  hexDigits[0] = result[i + 2];
+		if ((i < result.count () - 3) && isxdigit (result[i + 3]))
+		  hexDigits[1] = result[i + 3];
+
+		unsigned
+		  charValue = 0;
+		sscanf (hexDigits, "%x", &charValue);
+
+		replacement[0] = (char) charValue;
+		charsToRemove = 2 + strlen (hexDigits);
+	      }
+	      break;
+	    default:
+	      escapedChar = false;
+	    }
+
+	  if (escapedChar)
+	    result.replace (i, charsToRemove, replacement);
+	}
+    }
+
+  return result;
+}
+
+void
+KeyboardTranslator::Entry::insertModifier (QString & item, int modifier) const
+{
+  if (!(modifier & _modifierMask))
+    return;
+
+  if (modifier & _modifiers)
+    item += '+';
+  else
+    item += '-';
+
+  if (modifier == Qt::ShiftModifier)
+    item += "Shift";
+  else if (modifier == Qt::ControlModifier)
+    item += "Ctrl";
+  else if (modifier == Qt::AltModifier)
+    item += "Alt";
+  else if (modifier == Qt::MetaModifier)
+    item += "Meta";
+  else if (modifier == Qt::KeypadModifier)
+    item += "KeyPad";
+}
+
+void
+KeyboardTranslator::Entry::insertState (QString & item, int state) const
+{
+  if (!(state & _stateMask))
+    return;
+
+  if (state & _state)
+    item += '+';
+  else
+    item += '-';
+
+  if (state == KeyboardTranslator::AlternateScreenState)
+    item += "AppScreen";
+  else if (state == KeyboardTranslator::NewLineState)
+    item += "NewLine";
+  else if (state == KeyboardTranslator::AnsiState)
+    item += "Ansi";
+  else if (state == KeyboardTranslator::CursorKeysState)
+    item += "AppCursorKeys";
+  else if (state == KeyboardTranslator::AnyModifierState)
+    item += "AnyModifier";
+  else if (state == KeyboardTranslator::ApplicationKeypadState)
+    item += "AppKeypad";
+}
+
+QString
+KeyboardTranslator::Entry::resultToString (bool expandWildCards,
+					   Qt::
+					   KeyboardModifiers modifiers) const
+{
+  if (!_text.isEmpty ())
+    return escapedText (expandWildCards, modifiers);
+  else if (_command == EraseCommand)
+    return "Erase";
+  else if (_command == ScrollPageUpCommand)
+    return "ScrollPageUp";
+  else if (_command == ScrollPageDownCommand)
+    return "ScrollPageDown";
+  else if (_command == ScrollLineUpCommand)
+    return "ScrollLineUp";
+  else if (_command == ScrollLineDownCommand)
+    return "ScrollLineDown";
+  else if (_command == ScrollLockCommand)
+    return "ScrollLock";
+
+  return QString ();
+}
+
+QString
+KeyboardTranslator::Entry::conditionToString () const
+{
+  QString
+    result = QKeySequence (_keyCode).toString ();
+
+  insertModifier (result, Qt::ShiftModifier);
+  insertModifier (result, Qt::ControlModifier);
+  insertModifier (result, Qt::AltModifier);
+  insertModifier (result, Qt::MetaModifier);
+  insertModifier (result, Qt::KeypadModifier);
+
+  insertState (result, KeyboardTranslator::AlternateScreenState);
+  insertState (result, KeyboardTranslator::NewLineState);
+  insertState (result, KeyboardTranslator::AnsiState);
+  insertState (result, KeyboardTranslator::CursorKeysState);
+  insertState (result, KeyboardTranslator::AnyModifierState);
+  insertState (result, KeyboardTranslator::ApplicationKeypadState);
+
+  return result;
+}
+
+KeyboardTranslator::KeyboardTranslator (const QString & name):_name (name)
+{
+}
+
+void
+KeyboardTranslator::setDescription (const QString & description)
+{
+  _description = description;
+}
+
+QString
+KeyboardTranslator::description () const
+{
+  return _description;
+}
+
+void
+KeyboardTranslator::setName (const QString & name)
+{
+  _name = name;
+}
+
+QString
+KeyboardTranslator::name () const
+{
+  return _name;
+}
+
+QList < KeyboardTranslator::Entry >
+KeyboardTranslator::entries () const
+{
+  return _entries.values ();
+}
+
+void
+KeyboardTranslator::addEntry (const Entry & entry)
+{
+  const int keyCode = entry.keyCode ();
+  _entries.insert (keyCode, entry);
+}
+
+void
+KeyboardTranslator::replaceEntry (const Entry & existing,
+				  const Entry & replacement)
+{
+  if (!existing.isNull ())
+    _entries.remove (existing.keyCode (), existing);
+  _entries.insert (replacement.keyCode (), replacement);
+}
+
+void
+KeyboardTranslator::removeEntry (const Entry & entry)
+{
+  _entries.remove (entry.keyCode (), entry);
+}
+
+KeyboardTranslator::Entry KeyboardTranslator::findEntry (int keyCode,
+							 Qt::
+							 KeyboardModifiers
+							 modifiers,
+							 States state) const
+{
+  foreach (const Entry & entry, _entries.values (keyCode))
+  {
+    if (entry.matches (keyCode, modifiers, state))
+      return entry;
+  }
+  return Entry ();		// entry not found
+}
+
+void
+KeyboardTranslatorManager::addTranslator (KeyboardTranslator * translator)
+{
+  _translators.insert (translator->name (), translator);
+
+  //  if ( !saveTranslator(translator) )
+  //      kWarning() << "Unable to save translator" << translator->name()
+  //               << "to disk.";
+}
+
+bool
+KeyboardTranslatorManager::deleteTranslator (const QString & name)
+{
+  Q_ASSERT (_translators.contains (name));
+
+  // locate and delete
+  QString path = findTranslatorPath (name);
+  if (QFile::remove (path))
+    {
+      _translators.remove (name);
+      return true;
+    }
+  else
+    {
+      //kWarning() << "Failed to remove translator - " << path;
+      return false;
+    }
+}
+
+/**
+ * @internal
+ */
+typedef void (*KdeCleanUpFunction) ();
+
+/**
+ * @internal
+ *
+ * Helper class for K_GLOBAL_STATIC to clean up the object on library unload or application
+ * shutdown.
+ */
+class KCleanUpGlobalStatic
+{
+public:
+  KdeCleanUpFunction func;
+
+  inline ~ KCleanUpGlobalStatic ()
+  {
+    func ();
+  }
+};
+
+
+
+#ifdef Q_CC_MSVC
+/**
+ * @internal
+ *
+ * MSVC seems to give anonymous structs the same name which fails at link time. So instead we name
+ * the struct and hope that by adding the line number to the name it's unique enough to never clash.
+ */
+#define K_GLOBAL_STATIC_STRUCT_NAME(NAME) _k_##NAME##__LINE__
+#else
+/**
+ * @internal
+ *
+ * Make the struct of the K_GLOBAL_STATIC anonymous.
+ */
+#define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
+#endif
+
+
+
+#define K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                            \
+static QBasicAtomicPointer<TYPE > _k_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0); \
+static bool _k_static_##NAME##_destroyed;                                      \
+static struct K_GLOBAL_STATIC_STRUCT_NAME(NAME)                                \
+{                                                                              \
+    inline bool isDestroyed() const                                            \
+    {                                                                          \
+        return _k_static_##NAME##_destroyed;                                   \
+    }                                                                          \
+    inline bool exists() const                                                 \
+    {                                                                          \
+        return _k_static_##NAME != 0;                                          \
+    }                                                                          \
+    inline operator TYPE*()                                                    \
+    {                                                                          \
+        return operator->();                                                   \
+    }                                                                          \
+    inline TYPE *operator->()                                                  \
+    {                                                                          \
+        if (!_k_static_##NAME) {                                               \
+            if (isDestroyed()) {                                               \
+                qFatal("Fatal Error: Accessed global static '%s *%s()' after destruction. " \
+                       "Defined at %s:%d", #TYPE, #NAME, __FILE__, __LINE__);  \
+            }                                                                  \
+            TYPE *x = new TYPE ARGS;                                           \
+            if (!_k_static_##NAME.testAndSetOrdered(0, x)                      \
+                && _k_static_##NAME != x ) {                                   \
+                delete x;                                                      \
+            } else {                                                           \
+                static KCleanUpGlobalStatic cleanUpObject = { destroy };       \
+            }                                                                  \
+        }                                                                      \
+        return _k_static_##NAME;                                               \
+    }                                                                          \
+    inline TYPE &operator*()                                                   \
+    {                                                                          \
+        return *operator->();                                                  \
+    }                                                                          \
+    static void destroy()                                                      \
+    {                                                                          \
+        _k_static_##NAME##_destroyed = true;                                   \
+        TYPE *x = _k_static_##NAME;                                            \
+        _k_static_##NAME = 0;                                                  \
+        delete x;                                                              \
+    }                                                                          \
+} NAME;
+
+#define K_GLOBAL_STATIC(TYPE, NAME) K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())
+
+K_GLOBAL_STATIC (KeyboardTranslatorManager, theKeyboardTranslatorManager)
+     KeyboardTranslatorManager *KeyboardTranslatorManager::instance ()
+{
+  return theKeyboardTranslatorManager;
+}
diff --git a/gui/src/terminal/KeyboardTranslator.h b/gui/src/terminal/KeyboardTranslator.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/KeyboardTranslator.h
@@ -0,0 +1,626 @@
+/*
+    This source file is part of Konsole, a terminal emulator.
+
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef KEYBOARDTRANSLATOR_H
+#define KEYBOARDTRANSLATOR_H
+
+// Qt
+#include <QtCore/QHash>
+#include <QtCore/QList>
+#include <QtGui/QKeySequence>
+#include <QtCore/QMetaType>
+#include <QtCore/QVarLengthArray>
+
+class QIODevice;
+class QTextStream;
+
+/** 
+ * A convertor which maps between key sequences pressed by the user and the
+ * character strings which should be sent to the terminal and commands
+ * which should be invoked when those character sequences are pressed.
+ *
+ * Konsole supports multiple keyboard translators, allowing the user to
+ * specify the character sequences which are sent to the terminal
+ * when particular key sequences are pressed.
+ *
+ * A key sequence is defined as a key code, associated keyboard modifiers
+ * (Shift,Ctrl,Alt,Meta etc.) and state flags which indicate the state
+ * which the terminal must be in for the key sequence to apply.
+ */
+class KeyboardTranslator
+{
+public:
+    /** 
+     * The meaning of a particular key sequence may depend upon the state which
+     * the terminal emulation is in.  Therefore findEntry() may return a different
+     * Entry depending upon the state flags supplied.
+     *
+     * This enum describes the states which may be associated with with a particular
+     * entry in the keyboard translation entry.
+     */
+  enum State
+  {
+	/** Indicates that no special state is active */
+    NoState = 0,
+	/**
+         * TODO More documentation
+         */
+    NewLineState = 1,
+	/** 
+         * Indicates that the terminal is in 'Ansi' mode.
+         * TODO: More documentation
+         */
+    AnsiState = 2,
+	/**
+         * TODO More documentation
+         */
+    CursorKeysState = 4,
+	/**
+         * Indicates that the alternate screen ( typically used by interactive programs
+         * such as screen or vim ) is active 
+         */
+    AlternateScreenState = 8,
+	/** Indicates that any of the modifier keys is active. */
+    AnyModifierState = 16,
+	/** Indicates that the numpad is in application mode. */
+    ApplicationKeypadState = 32
+  };
+    Q_DECLARE_FLAGS (States, State)
+    /**
+     * This enum describes commands which are associated with particular key sequences.
+     */
+    enum Command
+  {
+	/** Indicates that no command is associated with this command sequence */
+    NoCommand = 0,
+	/** TODO Document me */
+    SendCommand = 1,
+	/** Scroll the terminal display up one page */
+    ScrollPageUpCommand = 2,
+	/** Scroll the terminal display down one page */
+    ScrollPageDownCommand = 4,
+	/** Scroll the terminal display up one line */
+    ScrollLineUpCommand = 8,
+	/** Scroll the terminal display down one line */
+    ScrollLineDownCommand = 16,
+	/** Toggles scroll lock mode */
+    ScrollLockCommand = 32,
+	/** Echos the operating system specific erase character. */
+    EraseCommand = 64
+  };
+    Q_DECLARE_FLAGS (Commands, Command)
+    /**
+     * Represents an association between a key sequence pressed by the user
+     * and the character sequence and commands associated with it for a particular
+     * KeyboardTranslator.
+     */
+  class Entry
+  {
+  public:
+	/** 
+         * Constructs a new entry for a keyboard translator.
+         */
+    Entry ();
+
+	/** 
+         * Returns true if this entry is null.
+         * This is true for newly constructed entries which have no properties set. 
+         */
+    bool isNull () const;
+
+	/** Returns the commands associated with this entry */
+    Command command () const;
+	/** Sets the command associated with this entry. */
+    void setCommand (Command command);
+
+	/** 
+         * Returns the character sequence associated with this entry, optionally replacing 
+         * wildcard '*' characters with numbers to indicate the keyboard modifiers being pressed.
+         *
+         * TODO: The numbers used to replace '*' characters are taken from the Konsole/KDE 3 code.
+         * Document them. 
+         *
+         * @param expandWildCards Specifies whether wild cards (occurrences of the '*' character) in
+         * the entry should be replaced with a number to indicate the modifier keys being pressed. 
+         *
+         * @param modifiers The keyboard modifiers being pressed.
+         */
+    QByteArray text (bool expandWildCards = false,
+		     Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+
+	/** Sets the character sequence associated with this entry */
+    void setText (const QByteArray & text);
+
+	/** 
+         * Returns the character sequence associated with this entry,
+         * with any non-printable characters replaced with escape sequences.
+         *
+         * eg. \\E for Escape, \\t for tab, \\n for new line.
+         *
+         * @param expandWildCards See text()
+         * @param modifiers See text()
+         */
+    QByteArray escapedText (bool expandWildCards = false,
+			    Qt::KeyboardModifiers modifiers =
+			    Qt::NoModifier) const;
+
+	/** Returns the character code ( from the Qt::Key enum ) associated with this entry */
+    int keyCode () const;
+	/** Sets the character code associated with this entry */
+    void setKeyCode (int keyCode);
+
+	/** 
+         * Returns a bitwise-OR of the enabled keyboard modifiers associated with this entry. 
+         * If a modifier is set in modifierMask() but not in modifiers(), this means that the entry
+         * only matches when that modifier is NOT pressed.
+         *
+         * If a modifier is not set in modifierMask() then the entry matches whether the modifier
+         * is pressed or not. 
+         */
+      Qt::KeyboardModifiers modifiers () const;
+
+	/** Returns the keyboard modifiers which are valid in this entry.  See modifiers() */
+      Qt::KeyboardModifiers modifierMask () const;
+
+	/** See modifiers() */
+    void setModifiers (Qt::KeyboardModifiers modifiers);
+	/** See modifierMask() and modifiers() */
+    void setModifierMask (Qt::KeyboardModifiers modifiers);
+
+	/** 
+         * Returns a bitwise-OR of the enabled state flags associated with this entry. 
+         * If flag is set in stateMask() but not in state(), this means that the entry only 
+         * matches when the terminal is NOT in that state.
+         *
+         * If a state is not set in stateMask() then the entry matches whether the terminal
+         * is in that state or not. 
+         */
+    States state () const;
+
+	/** Returns the state flags which are valid in this entry.  See state() */
+    States stateMask () const;
+
+	/** See state() */
+    void setState (States state);
+	/** See stateMask() */
+    void setStateMask (States mask);
+
+	/** 
+         * Returns the key code and modifiers associated with this entry 
+         * as a QKeySequence
+         */
+    //QKeySequence keySequence() const;
+
+	/** 
+         * Returns this entry's conditions ( ie. its key code, modifier and state criteria )
+         * as a string.
+         */
+    QString conditionToString () const;
+
+	/**
+         * Returns this entry's result ( ie. its command or character sequence )
+         * as a string.
+         *
+         * @param expandWildCards See text()
+         * @param modifiers See text()
+         */
+    QString resultToString (bool expandWildCards = false,
+			    Qt::KeyboardModifiers modifiers =
+			    Qt::NoModifier) const;
+
+	/** 
+         * Returns true if this entry matches the given key sequence, specified
+         * as a combination of @p keyCode , @p modifiers and @p state.
+         */
+    bool matches (int keyCode,
+		  Qt::KeyboardModifiers modifiers, States flags) const;
+
+    bool operator== (const Entry & rhs) const;
+
+  private:
+    void insertModifier (QString & item, int modifier) const;
+    void insertState (QString & item, int state) const;
+    QByteArray unescape (const QByteArray & text) const;
+
+    int _keyCode;
+      Qt::KeyboardModifiers _modifiers;
+      Qt::KeyboardModifiers _modifierMask;
+    States _state;
+    States _stateMask;
+
+    Command _command;
+    QByteArray _text;
+  };
+
+    /** Constructs a new keyboard translator with the given @p name */
+    KeyboardTranslator (const QString & name);
+
+  //KeyboardTranslator(const KeyboardTranslator& other);
+
+    /** Returns the name of this keyboard translator */
+  QString name () const;
+
+    /** Sets the name of this keyboard translator */
+  void setName (const QString & name);
+
+    /** Returns the descriptive name of this keyboard translator */
+  QString description () const;
+
+    /** Sets the descriptive name of this keyboard translator */
+  void setDescription (const QString & description);
+
+    /**
+     * Looks for an entry in this keyboard translator which matches the given
+     * key code, keyboard modifiers and state flags.
+     * 
+     * Returns the matching entry if found or a null Entry otherwise ( ie.
+     * entry.isNull() will return true )
+     *
+     * @param keyCode A key code from the Qt::Key enum
+     * @param modifiers A combination of modifiers
+     * @param state Optional flags which specify the current state of the terminal
+     */
+  Entry findEntry (int keyCode,
+		   Qt::KeyboardModifiers modifiers,
+		   States state = NoState) const;
+
+    /** 
+     * Adds an entry to this keyboard translator's table.  Entries can be looked up according
+     * to their key sequence using findEntry()
+     */
+  void addEntry (const Entry & entry);
+
+    /**
+     * Replaces an entry in the translator.  If the @p existing entry is null,
+     * then this is equivalent to calling addEntry(@p replacement)
+     */
+  void replaceEntry (const Entry & existing, const Entry & replacement);
+
+    /**
+     * Removes an entry from the table.
+     */
+  void removeEntry (const Entry & entry);
+
+    /** Returns a list of all entries in the translator. */
+    QList < Entry > entries () const;
+
+private:
+
+    QMultiHash < int, Entry > _entries;	// entries in this keyboard translation,
+  // entries are indexed according to
+  // their keycode
+  QString _name;
+  QString _description;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS (KeyboardTranslator::States)
+Q_DECLARE_OPERATORS_FOR_FLAGS (KeyboardTranslator::Commands)
+/** 
+ * Parses the contents of a Keyboard Translator (.keytab) file and 
+ * returns the entries found in it.
+ *
+ * Usage example:
+ *
+ * @code
+ *  QFile source( "/path/to/keytab" );
+ *  source.open( QIODevice::ReadOnly );
+ *
+ *  KeyboardTranslator* translator = new KeyboardTranslator( "name-of-translator" );
+ *
+ *  KeyboardTranslatorReader reader(source);
+ *  while ( reader.hasNextEntry() )
+ *      translator->addEntry(reader.nextEntry());
+ *
+ *  source.close();
+ *
+ *  if ( !reader.parseError() )
+ *  {
+ *      // parsing succeeded, do something with the translator
+ *  } 
+ *  else
+ *  {
+ *      // parsing failed
+ *  }
+ * @endcode
+ */
+     class KeyboardTranslatorReader
+     {
+     public:
+    /** Constructs a new reader which parses the given @p source */
+       KeyboardTranslatorReader (QIODevice * source);
+
+    /** 
+     * Returns the description text. 
+     * TODO: More documentation 
+     */
+       QString description () const;
+
+    /** Returns true if there is another entry in the source stream */
+       bool hasNextEntry ();
+    /** Returns the next entry found in the source stream */
+         KeyboardTranslator::Entry nextEntry ();
+
+    /** 
+     * Returns true if an error occurred whilst parsing the input or
+     * false if no error occurred.
+     */
+       bool parseError ();
+
+    /**
+     * Parses a condition and result string for a translator entry
+     * and produces a keyboard translator entry.
+     *
+     * The condition and result strings are in the same format as in  
+     */
+       static KeyboardTranslator::
+	 Entry createEntry (const QString & condition,
+			    const QString & result);
+     private:
+       struct Token
+       {
+	 enum Type
+	 {
+	   TitleKeyword,
+	   TitleText,
+	   KeyKeyword,
+	   KeySequence,
+	   Command,
+	   OutputText
+	 };
+	 Type type;
+	 QString text;
+       };
+         QList < Token > tokenize (const QString &);
+       void readNext ();
+       bool decodeSequence (const QString &,
+			    int &keyCode,
+			    Qt::KeyboardModifiers & modifiers,
+			    Qt::KeyboardModifiers & modifierMask,
+			    KeyboardTranslator::States & state,
+			    KeyboardTranslator::States & stateFlags);
+
+       static bool parseAsModifier (const QString & item,
+				    Qt::KeyboardModifier & modifier);
+       static bool parseAsStateFlag (const QString & item,
+				     KeyboardTranslator::State & state);
+       static bool parseAsKeyCode (const QString & item, int &keyCode);
+       static bool parseAsCommand (const QString & text,
+				   KeyboardTranslator::Command & command);
+
+       QIODevice *_source;
+       QString _description;
+         KeyboardTranslator::Entry _nextEntry;
+       bool _hasNext;
+     };
+
+/** Writes a keyboard translation to disk. */
+     class KeyboardTranslatorWriter
+     {
+     public:
+    /** 
+     * Constructs a new writer which saves data into @p destination.
+     * The caller is responsible for closing the device when writing is complete.
+     */
+       KeyboardTranslatorWriter (QIODevice * destination);
+       ~KeyboardTranslatorWriter ();
+
+    /** 
+     * Writes the header for the keyboard translator. 
+     * @param description Description of the keyboard translator. 
+     */
+       void writeHeader (const QString & description);
+    /** Writes a translator entry. */
+       void writeEntry (const KeyboardTranslator::Entry & entry);
+
+     private:
+         QIODevice * _destination;
+       QTextStream *_writer;
+     };
+
+/**
+ * Manages the keyboard translations available for use by terminal sessions,
+ * see KeyboardTranslator.
+ */
+     class KeyboardTranslatorManager
+     {
+     public:
+    /** 
+     * Constructs a new KeyboardTranslatorManager and loads the list of
+     * available keyboard translations.
+     *
+     * The keyboard translations themselves are not loaded until they are
+     * first requested via a call to findTranslator()
+     */
+       KeyboardTranslatorManager ();
+       ~KeyboardTranslatorManager ();
+
+    /**
+     * Adds a new translator.  If a translator with the same name 
+     * already exists, it will be replaced by the new translator.
+     *
+     * TODO: More documentation.
+     */
+       void addTranslator (KeyboardTranslator * translator);
+
+    /**
+     * Deletes a translator.  Returns true on successful deletion or false otherwise.
+     *
+     * TODO: More documentation
+     */
+       bool deleteTranslator (const QString & name);
+
+    /** Returns the default translator for Konsole. */
+       const KeyboardTranslator *defaultTranslator ();
+
+    /** 
+     * Returns the keyboard translator with the given name or 0 if no translator
+     * with that name exists.
+     *
+     * The first time that a translator with a particular name is requested,
+     * the on-disk .keyboard file is loaded and parsed.  
+     */
+       const KeyboardTranslator *findTranslator (const QString & name);
+    /**
+     * Returns a list of the names of available keyboard translators.
+     *
+     * The first time this is called, a search for available 
+     * translators is started.
+     */
+         QList < QString > allTranslators ();
+
+    /** Returns the global KeyboardTranslatorManager instance. */
+       static KeyboardTranslatorManager *instance ();
+
+     private:
+       static const QByteArray defaultTranslatorText;
+
+       void findTranslators ();	// locate the available translators
+       KeyboardTranslator *loadTranslator (const QString & name);	// loads the translator 
+       // with the given name
+       KeyboardTranslator *loadTranslator (QIODevice * device,
+					   const QString & name);
+
+       bool saveTranslator (const KeyboardTranslator * translator);
+       QString findTranslatorPath (const QString & name);
+
+         QHash < QString, KeyboardTranslator * >_translators;	// maps translator-name -> KeyboardTranslator
+       // instance
+       bool _haveLoadedAll;
+     };
+
+inline int
+KeyboardTranslator::Entry::keyCode () const
+{
+  return _keyCode;
+}
+
+inline void
+KeyboardTranslator::Entry::setKeyCode (int keyCode)
+{
+  _keyCode = keyCode;
+}
+
+inline void
+KeyboardTranslator::Entry::setModifiers (Qt::KeyboardModifiers modifier)
+{
+  _modifiers = modifier;
+}
+
+inline Qt::KeyboardModifiers
+KeyboardTranslator::Entry::modifiers () const
+{
+  return _modifiers;
+}
+
+inline void
+KeyboardTranslator::Entry::setModifierMask (Qt::KeyboardModifiers mask)
+{
+  _modifierMask = mask;
+}
+
+inline Qt::KeyboardModifiers
+KeyboardTranslator::Entry::modifierMask () const
+{
+  return _modifierMask;
+}
+
+inline bool
+KeyboardTranslator::Entry::isNull () const
+{
+  return (*this == Entry ());
+}
+
+inline void
+KeyboardTranslator::Entry::setCommand (Command command)
+{
+  _command = command;
+}
+
+inline KeyboardTranslator::Command
+KeyboardTranslator::Entry::command () const
+{
+  return _command;
+}
+
+inline void
+KeyboardTranslator::Entry::setText (const QByteArray & text)
+{
+  _text = unescape (text);
+}
+
+inline int
+oneOrZero (int value)
+{
+  return value ? 1 : 0;
+}
+
+inline QByteArray
+KeyboardTranslator::Entry::text (bool expandWildCards,
+                                 Qt::KeyboardModifiers modifiers) const
+{
+  QByteArray
+    expandedText = _text;
+
+  if (expandWildCards)
+    {
+      int
+	modifierValue = 1;
+      modifierValue += oneOrZero (modifiers & Qt::ShiftModifier);
+      modifierValue += oneOrZero (modifiers & Qt::AltModifier) << 1;
+      modifierValue += oneOrZero (modifiers & Qt::ControlModifier) << 2;
+
+      for (int i = 0; i < _text.length (); i++)
+	{
+	  if (expandedText[i] == '*')
+	    expandedText[i] = '0' + modifierValue;
+	}
+    }
+
+  return expandedText;
+}
+
+inline void
+KeyboardTranslator::Entry::setState (States state)
+{
+  _state = state;
+}
+
+inline KeyboardTranslator::States
+KeyboardTranslator::Entry::state () const
+{
+  return _state;
+}
+
+inline void
+KeyboardTranslator::Entry::setStateMask (States stateMask)
+{
+  _stateMask = stateMask;
+}
+
+inline KeyboardTranslator::States
+KeyboardTranslator::Entry::stateMask () const
+{
+  return _stateMask;
+}
+
+
+Q_DECLARE_METATYPE (KeyboardTranslator::Entry)
+Q_DECLARE_METATYPE (const KeyboardTranslator *)
+#endif // KEYBOARDTRANSLATOR_H
diff --git a/gui/src/terminal/Pty.cpp b/gui/src/terminal/Pty.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Pty.cpp
@@ -0,0 +1,305 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "kprocess_p.h"
+#include "kptyprocess.h"
+#include "Pty.h"
+
+// System
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <errno.h>
+#include <termios.h>
+#include <signal.h>
+
+// Qt
+#include <QtCore/QStringList>
+
+#include "kpty.h"
+#include "kptydevice.h"
+
+
+void
+Pty::setWindowSize (int lines, int cols)
+{
+  _windowColumns = cols;
+  _windowLines = lines;
+
+  if (pty ()->masterFd () >= 0)
+    pty ()->setWinSize (lines, cols);
+}
+
+QSize
+Pty::windowSize () const
+{
+  return QSize (_windowColumns, _windowLines);
+}
+
+void
+Pty::setFlowControlEnabled (bool enable)
+{
+  _xonXoff = enable;
+
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      if (!enable)
+	ttmode.c_iflag &= ~(IXOFF | IXON);
+      else
+	ttmode.c_iflag |= (IXOFF | IXON);
+      pty()->tcSetAttr(&ttmode);
+    }
+}
+
+bool
+Pty::flowControlEnabled () const
+{
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      return ttmode.c_iflag & IXOFF && ttmode.c_iflag & IXON;
+    }
+  return false;
+}
+
+void
+Pty::setUtf8Mode (bool enable)
+{
+#ifdef IUTF8
+  _utf8 = enable;
+
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      if (!enable)
+	ttmode.c_iflag &= ~IUTF8;
+      else
+	ttmode.c_iflag |= IUTF8;
+      pty()->tcSetAttr(&ttmode);
+    }
+#endif
+}
+
+void
+Pty::setErase (char erase)
+{
+  _eraseChar = erase;
+
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttmode;
+      pty ()->tcGetAttr (&ttmode);
+      ttmode.c_cc[VERASE] = erase;
+      pty()->tcSetAttr(&ttmode);
+    }
+}
+
+char
+Pty::erase () const
+{
+  if (pty ()->masterFd () >= 0)
+    {
+      struct::termios ttyAttributes;
+      pty ()->tcGetAttr (&ttyAttributes);
+      return ttyAttributes.c_cc[VERASE];
+    }
+
+  return _eraseChar;
+}
+
+void
+Pty::addEnvironmentVariables (const QStringList & environment)
+{
+  QListIterator < QString > iter (environment);
+  while (iter.hasNext ())
+    {
+      QString pair = iter.next ();
+
+      // split on the first '=' character
+      int pos = pair.indexOf ('=');
+
+      if (pos >= 0)
+	{
+	  QString variable = pair.left (pos);
+	  QString value = pair.mid (pos + 1);
+
+          setEnvironmentVariable (variable, value);
+	}
+    }
+}
+
+int
+Pty::start (const QString & program,
+	    const QStringList & programArguments,
+	    const QStringList & environment,
+	    ulong winid,
+	    bool addToUtmp,
+	    const QString & dbusService, const QString & dbusSession)
+{
+  Q_UNUSED(dbusService);
+  Q_UNUSED(dbusSession);
+  Q_UNUSED(winid);
+  clearProgram ();
+
+  // For historical reasons, the first argument in programArguments is the 
+  // name of the program to execute, so create a list consisting of all
+  // but the first argument to pass to setProgram()
+  Q_ASSERT (programArguments.count () >= 1);
+  setProgram (program.toLatin1 (), programArguments.mid (1));
+
+  addEnvironmentVariables (environment);
+
+  //if (!dbusService.isEmpty ())
+  //  setEnv ("KONSOLE_DBUS_SERVICE", dbusService);
+  //if (!dbusSession.isEmpty ())
+  //  setEnv ("KONSOLE_DBUS_SESSION", dbusSession);
+
+  //setEnv ("WINDOWID", QString::number (winid));
+
+  // unless the LANGUAGE environment variable has been set explicitly
+  // set it to a null string
+  // this fixes the problem where KCatalog sets the LANGUAGE environment
+  // variable during the application's startup to something which
+  // differs from LANG,LC_* etc. and causes programs run from
+  // the terminal to display messages in the wrong language
+  //
+  // this can happen if LANG contains a language which KDE
+  // does not have a translation for
+  //
+  // BR:149300
+  setEnvironmentVariable ("LANGUAGE", QString (),
+          false /* do not overwrite existing value if any */ );
+  setUseUtmp (addToUtmp);
+
+
+  struct::termios ttmode;
+  pty ()->tcGetAttr (&ttmode);
+  if (!_xonXoff)
+    ttmode.c_iflag &= ~(IXOFF | IXON);
+  else
+    ttmode.c_iflag |= (IXOFF | IXON);
+#ifdef IUTF8			// XXX not a reasonable place to check it.
+  if (!_utf8)
+    ttmode.c_iflag &= ~IUTF8;
+  else
+    ttmode.c_iflag |= IUTF8;
+#endif
+
+  if (_eraseChar != 0)
+    ttmode.c_cc[VERASE] = _eraseChar;
+
+  pty()->tcSetAttr(&ttmode);
+  pty ()->setWinSize (_windowLines, _windowColumns);
+
+  KProcess::start ();
+
+  if (!waitForStarted ())
+    return -1;
+  return 0;
+}
+
+void
+Pty::setWriteable (bool writeable)
+{
+  struct stat sbuf;
+  ::stat (pty ()->ttyName (), &sbuf);
+  if (writeable)
+    chmod (pty ()->ttyName (), sbuf.st_mode | S_IWGRP);
+  else
+    chmod (pty ()->ttyName (), sbuf.st_mode & ~(S_IWGRP | S_IWOTH));
+}
+
+Pty::Pty (int masterFd, QObject * parent):
+KPtyProcess (masterFd, parent)
+{
+  init ();
+}
+
+Pty::Pty (QObject * parent):KPtyProcess (parent)
+{
+  init ();
+}
+
+void
+Pty::init ()
+{
+  _windowColumns = 0;
+  _windowLines = 0;
+  _eraseChar = 0;
+  _xonXoff = true;
+  _utf8 = true;
+
+  connect (pty (), SIGNAL (readyRead ()), this, SLOT (dataReceived ()));
+  setPtyChannels (KPtyProcess::AllChannels);
+}
+
+Pty::~Pty ()
+{
+}
+
+void
+Pty::sendData (const char *data, int length)
+{
+  if (!length)
+    return;
+  pty ()->write (data, length);
+}
+
+void
+Pty::dataReceived ()
+{
+  QByteArray data = pty ()->readAll ();
+  emit receivedData (data.constData (), data.count ());
+}
+
+int
+Pty::foregroundProcessGroup () const
+{
+  int pid = tcgetpgrp (pty ()->masterFd ());
+
+  if (pid != -1)
+    {
+      return pid;
+    }
+
+  return 0;
+}
+
+void
+Pty::setupChildProcess ()
+{
+  KPtyProcess::setupChildProcess ();
+
+  // reset all signal handlers
+  // this ensures that terminal applications respond to 
+  // signals generated via key sequences such as Ctrl+C
+  // (which sends SIGINT)
+  struct sigaction action;
+  sigemptyset (&action.sa_mask);
+  action.sa_handler = SIG_DFL;
+  action.sa_flags = 0;
+  for (int signal = 1; signal < NSIG; signal++)
+    sigaction (signal, &action, 0L);
+}
diff --git a/gui/src/terminal/Pty.h b/gui/src/terminal/Pty.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Pty.h
@@ -0,0 +1,184 @@
+/*
+    This file is part of Konsole, KDE's terminal emulator. 
+    
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef PTY_H
+#define PTY_H
+
+// Qt
+#include <QtCore/QStringList>
+#include <QtCore/QVector>
+#include <QtCore/QList>
+#include <QtCore/QSize>
+
+// KDE
+#include "kprocess.h"
+#include "kptyprocess.h"
+
+/**
+ * The Pty class is used to start the terminal process, 
+ * send data to it, receive data from it and manipulate 
+ * various properties of the pseudo-teletype interface
+ * used to communicate with the process.
+ *
+ * To use this class, construct an instance and connect
+ * to the sendData slot and receivedData signal to
+ * send data to or receive data from the process.
+ *
+ * To start the terminal process, call the start() method
+ * with the program name and appropriate arguments. 
+ */
+//class KONSOLEPRIVATE_EXPORT Pty: public KPtyProcess
+class Pty:public KPtyProcess
+{
+Q_OBJECT public:
+
+    /** 
+     * Constructs a new Pty.
+     * 
+     * Connect to the sendData() slot and receivedData() signal to prepare
+     * for sending and receiving data from the terminal process.
+     *
+     * To start the terminal process, call the run() method with the 
+     * name of the program to start and appropriate arguments.
+     */
+  explicit Pty (QObject * parent = 0);
+
+    /** 
+     * Construct a process using an open pty master.
+     * See KPtyProcess::KPtyProcess()
+     */
+  explicit Pty (int ptyMasterFd, QObject * parent = 0);
+
+   ~Pty ();
+
+    /**
+     * Starts the terminal process.  
+     *
+     * Returns 0 if the process was started successfully or non-zero
+     * otherwise.
+     *
+     * @param program Path to the program to start
+     * @param arguments Arguments to pass to the program being started
+     * @param environment A list of key=value pairs which will be added
+     * to the environment for the new process.  At the very least this
+     * should include an assignment for the TERM environment variable.
+     * @param winid Specifies the value of the WINDOWID environment variable
+     * in the process's environment.
+     * @param addToUtmp Specifies whether a utmp entry should be created for
+     * the pty used.  See K3Process::setUsePty() 
+     * @param dbusService Specifies the value of the KONSOLE_DBUS_SERVICE 
+     * environment variable in the process's environment.
+     * @param dbusSession Specifies the value of the KONSOLE_DBUS_SESSION
+     * environment variable in the process's environment. 
+     */
+  int start (const QString & program,
+	     const QStringList & arguments,
+	     const QStringList & environment,
+	     ulong winid,
+	     bool addToUtmp,
+	     const QString & dbusService, const QString & dbusSession);
+
+    /** TODO: Document me */
+  void setWriteable (bool writeable);
+
+    /** 
+     * Enables or disables Xon/Xoff flow control.  The flow control setting
+     * may be changed later by a terminal application, so flowControlEnabled()
+     * may not equal the value of @p on in the previous call to setFlowControlEnabled()
+     */
+  void setFlowControlEnabled (bool on);
+
+    /** Queries the terminal state and returns true if Xon/Xoff flow control is enabled. */
+  bool flowControlEnabled () const;
+
+    /** 
+     * Sets the size of the window (in lines and columns of characters) 
+     * used by this teletype.
+     */
+  void setWindowSize (int lines, int cols);
+
+    /** Returns the size of the window used by this teletype.  See setWindowSize() */
+  QSize windowSize () const;
+
+    /** TODO Document me */
+  void setErase (char erase);
+
+    /** */
+  char erase () const;
+
+    /**
+     * Returns the process id of the teletype's current foreground
+     * process.  This is the process which is currently reading
+     * input sent to the terminal via. sendData()
+     *
+     * If there is a problem reading the foreground process group,
+     * 0 will be returned.
+     */
+  int foregroundProcessGroup () const;
+
+  public slots:
+    /**
+     * Put the pty into UTF-8 mode on systems which support it.
+     */
+  void setUtf8Mode (bool on);
+
+    /** 
+     * Sends data to the process currently controlling the 
+     * teletype ( whose id is returned by foregroundProcessGroup() )
+     *
+     * @param buffer Pointer to the data to send.
+     * @param length Length of @p buffer.
+     */
+  void sendData (const char *buffer, int length);
+
+    signals:
+    /**
+     * Emitted when a new block of data is received from
+     * the teletype.
+     *
+     * @param buffer Pointer to the data received.
+     * @param length Length of @p buffer
+     */
+  void receivedData (const char *buffer, int length);
+
+protected:
+  void setupChildProcess ();
+
+  private slots:
+    // called when data is received from the terminal process 
+  void dataReceived ();
+
+private:
+  void init ();
+
+  // takes a list of key=value pairs and adds them
+  // to the environment for the process
+  void addEnvironmentVariables (const QStringList & environment);
+
+  int _windowColumns;
+  int _windowLines;
+  char _eraseChar;
+  bool _xonXoff;
+  bool _utf8;
+};
+
+#endif // PTY_H
diff --git a/gui/src/terminal/QTerminalWidget.cpp b/gui/src/terminal/QTerminalWidget.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/QTerminalWidget.cpp
@@ -0,0 +1,162 @@
+/*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+		
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+				
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "QTerminalWidget.h"
+#include "Session.h"
+#include "TerminalDisplay.h"
+
+struct TermWidgetImpl
+{
+  TermWidgetImpl (QWidget * parent = 0);
+
+  TerminalDisplay *m_terminalDisplay;
+  Session *m_session;
+  Session *createSession ();
+  TerminalDisplay *createTerminalDisplay (Session * session,
+					  QWidget * parent);
+};
+
+TermWidgetImpl::TermWidgetImpl (QWidget * parent)
+{
+  QPalette palette = QApplication::palette ();
+  m_session = createSession ();
+  m_terminalDisplay = createTerminalDisplay (this->m_session, parent);
+  m_terminalDisplay->setBackgroundColor (palette.color (QPalette::Base));
+  m_terminalDisplay->setForegroundColor (palette.color (QPalette::Text));
+}
+
+Session *
+TermWidgetImpl::createSession ()
+{
+  Session *session = new Session ();
+  session->setTitle (Session::NameRole, "QTerminalWidget");
+  session->setProgram ("/bin/bash");
+  session->setArguments (QStringList ());
+  session->setAutoClose (true);
+  session->setCodec (QTextCodec::codecForName ("UTF-8"));
+  session->setFlowControlEnabled (true);
+  session->setHistoryType (HistoryTypeBuffer (1000));
+  session->setDarkBackground (true);
+  session->setKeyBindings ("");
+  return session;
+}
+
+TerminalDisplay *
+TermWidgetImpl::createTerminalDisplay (Session * session, QWidget * parent)
+{
+  TerminalDisplay *display = new TerminalDisplay (parent);
+  display->setBellMode (TerminalDisplay::NotifyBell);
+  display->setTerminalSizeHint (true);
+  display->setTripleClickMode (TerminalDisplay::SelectWholeLine);
+  display->setTerminalSizeStartup (true);
+  display->setRandomSeed (session->sessionId () * 31);
+  return display;
+}
+
+QTerminalWidget::QTerminalWidget (int startnow, QWidget * parent):QWidget
+  (parent)
+{
+  m_impl = new TermWidgetImpl (this);
+
+  initialize ();
+
+  if (startnow && m_impl->m_session)
+    {
+      m_impl->m_session->run ();
+    }
+
+  setFocus (Qt::OtherFocusReason);
+  m_impl->m_terminalDisplay->resize (this->size ());
+  setFocusProxy (m_impl->m_terminalDisplay);
+}
+
+void
+QTerminalWidget::initialize ()
+{
+  m_impl->m_terminalDisplay->setSize (80, 40);
+
+  QFont font = QApplication::font ();
+  font.setFamily ("Monospace");
+  font.setPointSize (10);
+  font.setStyleHint (QFont::TypeWriter);
+  m_impl->m_terminalDisplay->setVTFont (font);
+  m_impl->m_terminalDisplay->setScrollBarPosition (TerminalDisplay::ScrollBarRight);
+
+  m_impl->m_session->addView (m_impl->m_terminalDisplay);
+
+  connect (m_impl->m_session, SIGNAL (finished ()), this,
+	   SLOT (sessionFinished ()));
+}
+
+QTerminalWidget::~QTerminalWidget ()
+{
+  emit destroyed ();
+}
+
+void
+QTerminalWidget::openTeletype (int fd)
+{
+  if (m_impl->m_session->isRunning ())
+    return;
+
+  m_impl->m_session->openTeletype (fd);
+}
+
+void
+QTerminalWidget::setTextCodec (QTextCodec * codec)
+{
+  if (!m_impl->m_session)
+    return;
+  m_impl->m_session->setCodec (codec);
+}
+
+void
+QTerminalWidget::setSize (int h, int v)
+{
+  if (!m_impl->m_terminalDisplay)
+    return;
+  m_impl->m_terminalDisplay->setSize (h, v);
+}
+
+void
+QTerminalWidget::setHistorySize (int lines)
+{
+  if (lines < 0)
+    m_impl->m_session->setHistoryType (HistoryTypeFile ());
+  else
+    m_impl->m_session->setHistoryType (HistoryTypeBuffer (lines));
+}
+
+void
+QTerminalWidget::sendText (const QString & text)
+{
+  m_impl->m_session->sendText (text);
+}
+
+void
+QTerminalWidget::resizeEvent (QResizeEvent *)
+{
+  m_impl->m_terminalDisplay->resize (this->size ());
+  m_impl->m_terminalDisplay->update ();
+}
+
+void
+QTerminalWidget::sessionFinished ()
+{
+  emit finished ();
+}
diff --git a/gui/src/terminal/QTerminalWidget.h b/gui/src/terminal/QTerminalWidget.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/QTerminalWidget.h
@@ -0,0 +1,65 @@
+/*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+		    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+			    
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef QTERMINALWIDGET_H
+#define QTERMINALWIDGET_H
+
+#include <QtGui>
+
+struct TermWidgetImpl;
+/**
+  * \class QTerminalWidget
+  * This class forms a widget class that can be inserted into other widgets.
+  */
+class QTerminalWidget:public QWidget
+{
+Q_OBJECT
+  public:
+    QTerminalWidget (int startnow = 1, QWidget * parent = 0);
+   ~QTerminalWidget ();
+
+  void openTeletype (int fd);
+
+    /** Text codec, default is UTF-8. */
+  void setTextCodec (QTextCodec * codec);
+
+    /** Resize terminal widget. */
+  void setSize (int h, int v);
+
+    /** History size for scrolling, values below zero mean infinite. */
+  void setHistorySize (int lines);
+
+    /** Send some text to the terminal. */
+  void sendText (const QString & text);
+
+    signals:
+    /** Emitted, when the current program has finished. */
+  void finished ();
+
+protected:
+    virtual void resizeEvent (QResizeEvent *);
+
+  protected slots:void sessionFinished ();
+
+private:
+    /** Performs initial operations on this widget. */
+  void initialize ();
+  TermWidgetImpl *m_impl;
+};
+
+#endif // QTERMINALWIDGET_H
diff --git a/gui/src/terminal/Screen.cpp b/gui/src/terminal/Screen.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Screen.cpp
@@ -0,0 +1,1528 @@
+/*
+   This file is part of Konsole, an X terminal.
+
+   Copyright 2007-2008 by Robert Knight <robert.knight@gmail.com>
+   Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+   02110-1301  USA.
+   */
+
+// Own
+#include "Screen.h"
+
+// Standard
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+
+// Qt
+#include <QtCore/QTextStream>
+#include <QtCore/QDate>
+
+
+// Konsole
+#include "konsole_wcwidth.h"
+#include "TerminalCharacterDecoder.h"
+
+//FIXME: this is emulation specific. Use false for xterm, true for ANSI.
+//FIXME: see if we can get this from terminfo.
+#define BS_CLEARS false
+
+//Macro to convert x,y position on screen to position within an image.
+//
+//Originally the image was stored as one large contiguous block of 
+//memory, so a position within the image could be represented as an
+//offset from the beginning of the block.  For efficiency reasons this
+//is no longer the case.  
+//Many internal parts of this class still use this representation for parameters and so on,
+//notably moveImage() and clearImage().
+//This macro converts from an X,Y position into an image offset.
+#ifndef loc
+#define loc(X,Y) ((Y)*columns+(X))
+#endif
+
+
+Character
+  Screen::defaultChar = Character (' ',
+				   CharacterColor (COLOR_SPACE_DEFAULT,
+						   DEFAULT_FORE_COLOR),
+				   CharacterColor (COLOR_SPACE_DEFAULT,
+						   DEFAULT_BACK_COLOR),
+				   DEFAULT_RENDITION);
+
+//#define REVERSE_WRAPPED_LINES  // for wrapped line debug
+
+Screen::Screen (int l, int c):
+lines (l),
+columns (c),
+screenLines (new ImageLine[lines + 1]),
+_scrolledLines (0),
+_droppedLines (0),
+history (new HistoryScrollNone ()),
+cuX (0),
+cuY (0),
+currentRendition (0),
+_topMargin (0),
+_bottomMargin (0),
+selBegin (0),
+selTopLeft (0),
+selBottomRight (0),
+blockSelectionMode (false),
+effectiveForeground (CharacterColor ()),
+effectiveBackground (CharacterColor ()),
+effectiveRendition (0),
+lastPos (-1)
+{
+  lineProperties.resize (lines + 1);
+  for (int i = 0; i < lines + 1; i++)
+    lineProperties[i] = LINE_DEFAULT;
+
+  initTabStops ();
+  clearSelection ();
+  reset ();
+}
+
+/*! Destructor
+*/
+
+Screen::~Screen ()
+{
+  delete[]screenLines;
+  delete history;
+}
+
+void
+Screen::cursorUp (int n)
+    //=CUU
+{
+  if (n == 0)
+    n = 1;			// Default
+  int stop = cuY < _topMargin ? 0 : _topMargin;
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuY = qMax (stop, cuY - n);
+}
+
+void
+Screen::cursorDown (int n)
+    //=CUD
+{
+  if (n == 0)
+    n = 1;			// Default
+  int stop = cuY > _bottomMargin ? lines - 1 : _bottomMargin;
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuY = qMin (stop, cuY + n);
+}
+
+void
+Screen::cursorLeft (int n)
+    //=CUB
+{
+  if (n == 0)
+    n = 1;			// Default
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuX = qMax (0, cuX - n);
+}
+
+void
+Screen::cursorRight (int n)
+    //=CUF
+{
+  if (n == 0)
+    n = 1;			// Default
+  cuX = qMin (columns - 1, cuX + n);
+}
+
+void
+Screen::setMargins (int top, int bot)
+    //=STBM
+{
+  if (top == 0)
+    top = 1;			// Default
+  if (bot == 0)
+    bot = lines;		// Default
+  top = top - 1;		// Adjust to internal lineno
+  bot = bot - 1;		// Adjust to internal lineno
+  if (!(0 <= top && top < bot && bot < lines))
+    {				//Debug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
+      return;			// Default error action: ignore
+    }
+  _topMargin = top;
+  _bottomMargin = bot;
+  cuX = 0;
+  cuY = getMode (MODE_Origin) ? top : 0;
+
+}
+
+int
+Screen::topMargin () const
+{
+  return _topMargin;
+}
+
+int
+Screen::bottomMargin () const
+{
+  return _bottomMargin;
+}
+
+void
+Screen::index ()
+    //=IND
+{
+  if (cuY == _bottomMargin)
+    scrollUp (1);
+  else if (cuY < lines - 1)
+    cuY += 1;
+}
+
+void
+Screen::reverseIndex ()
+    //=RI
+{
+  if (cuY == _topMargin)
+    scrollDown (_topMargin, 1);
+  else if (cuY > 0)
+    cuY -= 1;
+}
+
+void
+Screen::nextLine ()
+    //=NEL
+{
+  toStartOfLine ();
+  index ();
+}
+
+void
+Screen::eraseChars (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+  int p = qMax (0, qMin (cuX + n - 1, columns - 1));
+  clearImage (loc (cuX, cuY), loc (p, cuY), ' ');
+}
+
+void
+Screen::deleteChars (int n)
+{
+  Q_ASSERT (n >= 0);
+
+  // always delete at least one char
+  if (n == 0)
+    n = 1;
+
+  // if cursor is beyond the end of the line there is nothing to do
+  if (cuX >= screenLines[cuY].count ())
+    return;
+
+  if (cuX + n > screenLines[cuY].count ())
+    n = screenLines[cuY].count () - cuX;
+
+  Q_ASSERT (n >= 0);
+  Q_ASSERT (cuX + n <= screenLines[cuY].count ());
+
+  screenLines[cuY].remove (cuX, n);
+}
+
+void
+Screen::insertChars (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+
+  if (screenLines[cuY].size () < cuX)
+    screenLines[cuY].resize (cuX);
+
+  screenLines[cuY].insert (cuX, n, ' ');
+
+  if (screenLines[cuY].count () > columns)
+    screenLines[cuY].resize (columns);
+}
+
+void
+Screen::deleteLines (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+  scrollUp (cuY, n);
+}
+
+void
+Screen::insertLines (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+  scrollDown (cuY, n);
+}
+
+void
+Screen::setMode (int m)
+{
+  currentModes[m] = true;
+  switch (m)
+    {
+    case MODE_Origin:
+      cuX = 0;
+      cuY = _topMargin;
+      break;			//FIXME: home
+    }
+}
+
+void
+Screen::resetMode (int m)
+{
+  currentModes[m] = false;
+  switch (m)
+    {
+    case MODE_Origin:
+      cuX = 0;
+      cuY = 0;
+      break;			//FIXME: home
+    }
+}
+
+void
+Screen::saveMode (int m)
+{
+  savedModes[m] = currentModes[m];
+}
+
+void
+Screen::restoreMode (int m)
+{
+  currentModes[m] = savedModes[m];
+}
+
+bool
+Screen::getMode (int m) const
+{
+  return currentModes[m];
+}
+
+void
+Screen::saveCursor ()
+{
+  savedState.cursorColumn = cuX;
+  savedState.cursorLine = cuY;
+  savedState.rendition = currentRendition;
+  savedState.foreground = currentForeground;
+  savedState.background = currentBackground;
+}
+
+void
+Screen::restoreCursor ()
+{
+  cuX = qMin (savedState.cursorColumn, columns - 1);
+  cuY = qMin (savedState.cursorLine, lines - 1);
+  currentRendition = savedState.rendition;
+  currentForeground = savedState.foreground;
+  currentBackground = savedState.background;
+  updateEffectiveRendition ();
+}
+
+void
+Screen::resizeImage (int new_lines, int new_columns)
+{
+  if ((new_lines == lines) && (new_columns == columns))
+    return;
+
+  if (cuY > new_lines - 1)
+    {				// attempt to preserve focus and lines
+      _bottomMargin = lines - 1;	//FIXME: margin lost
+      for (int i = 0; i < cuY - (new_lines - 1); i++)
+	{
+	  addHistLine ();
+	  scrollUp (0, 1);
+	}
+    }
+
+  // create new screen lines and copy from old to new
+
+  ImageLine *newScreenLines = new ImageLine[new_lines + 1];
+  for (int i = 0; i < qMin (lines - 1, new_lines + 1); i++)
+    newScreenLines[i] = screenLines[i];
+  for (int i = lines; (i > 0) && (i < new_lines + 1); i++)
+    newScreenLines[i].resize (new_columns);
+
+  lineProperties.resize (new_lines + 1);
+  for (int i = lines; (i > 0) && (i < new_lines + 1); i++)
+    lineProperties[i] = LINE_DEFAULT;
+
+  clearSelection ();
+
+  delete[]screenLines;
+  screenLines = newScreenLines;
+
+  lines = new_lines;
+  columns = new_columns;
+  cuX = qMin (cuX, columns - 1);
+  cuY = qMin (cuY, lines - 1);
+
+  // FIXME: try to keep values, evtl.
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
+  initTabStops ();
+  clearSelection ();
+}
+
+void
+Screen::setDefaultMargins ()
+{
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
+}
+
+
+/*
+   Clarifying rendition here and in the display.
+
+   currently, the display's color table is
+   0       1       2 .. 9    10 .. 17
+   dft_fg, dft_bg, dim 0..7, intensive 0..7
+
+   currentForeground, currentBackground contain values 0..8;
+   - 0    = default color
+   - 1..8 = ansi specified color
+
+   re_fg, re_bg contain values 0..17
+   due to the TerminalDisplay's color table
+
+   rendition attributes are
+
+   attr           widget screen
+   -------------- ------ ------
+   RE_UNDERLINE     XX     XX    affects foreground only
+   RE_BLINK         XX     XX    affects foreground only
+   RE_BOLD          XX     XX    affects foreground only
+   RE_REVERSE       --     XX
+   RE_TRANSPARENT   XX     --    affects background only
+   RE_INTENSIVE     XX     --    affects foreground only
+
+   Note that RE_BOLD is used in both widget
+   and screen rendition. Since xterm/vt102
+   is to poor to distinguish between bold
+   (which is a font attribute) and intensive
+   (which is a color attribute), we translate
+   this and RE_BOLD in falls eventually appart
+   into RE_BOLD and RE_INTENSIVE.
+   */
+
+void
+Screen::reverseRendition (Character & p) const
+{
+  CharacterColor f = p.foregroundColor;
+  CharacterColor b = p.backgroundColor;
+
+  p.foregroundColor = b;
+  p.backgroundColor = f;	//p->r &= ~RE_TRANSPARENT;
+}
+
+void
+Screen::updateEffectiveRendition ()
+{
+  effectiveRendition = currentRendition;
+  if (currentRendition & RE_REVERSE)
+    {
+      effectiveForeground = currentBackground;
+      effectiveBackground = currentForeground;
+    }
+  else
+    {
+      effectiveForeground = currentForeground;
+      effectiveBackground = currentBackground;
+    }
+
+  if (currentRendition & RE_BOLD)
+    effectiveForeground.toggleIntensive ();
+}
+
+void
+Screen::copyFromHistory (Character * dest, int startLine, int count) const
+{
+  Q_ASSERT (startLine >= 0 && count > 0
+	    && startLine + count <= history->getLines ());
+
+  for (int line = startLine; line < startLine + count; line++)
+    {
+      const int length = qMin (columns, history->getLineLen (line));
+      const int destLineOffset = (line - startLine) * columns;
+
+      history->getCells (line, 0, length, dest + destLineOffset);
+
+      for (int column = length; column < columns; column++)
+	dest[destLineOffset + column] = defaultChar;
+
+      // invert selected text
+      if (selBegin != -1)
+	{
+	  for (int column = 0; column < columns; column++)
+	    {
+	      if (isSelected (column, line))
+		{
+		  reverseRendition (dest[destLineOffset + column]);
+		}
+	    }
+	}
+    }
+}
+
+void
+Screen::copyFromScreen (Character * dest, int startLine, int count) const
+{
+  Q_ASSERT (startLine >= 0 && count > 0 && startLine + count <= lines);
+
+  for (int line = startLine; line < (startLine + count); line++)
+    {
+      int srcLineStartIndex = line * columns;
+      int destLineStartIndex = (line - startLine) * columns;
+
+      for (int column = 0; column < columns; column++)
+	{
+	  int srcIndex = srcLineStartIndex + column;
+	  int destIndex = destLineStartIndex + column;
+
+	  dest[destIndex] =
+	    screenLines[srcIndex / columns].value (srcIndex % columns,
+						   defaultChar);
+
+	  // invert selected text
+	  if (selBegin != -1
+	      && isSelected (column, line + history->getLines ()))
+	    reverseRendition (dest[destIndex]);
+	}
+
+    }
+}
+
+void
+Screen::getImage (Character * dest, int size, int startLine, int endLine) const
+{
+  Q_ASSERT (startLine >= 0);
+  Q_ASSERT (endLine >= startLine && endLine < history->getLines () + lines);
+
+  const int mergedLines = endLine - startLine + 1;
+
+  Q_ASSERT (size >= mergedLines * columns);
+  Q_UNUSED (size);
+
+  const int linesInHistoryBuffer =
+    qBound (0, history->getLines () - startLine, mergedLines);
+  const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
+
+  // copy lines from history buffer
+  if (linesInHistoryBuffer > 0)
+    copyFromHistory (dest, startLine, linesInHistoryBuffer);
+
+  // copy lines from screen buffer
+  if (linesInScreenBuffer > 0)
+    copyFromScreen (dest + linesInHistoryBuffer * columns,
+		    startLine + linesInHistoryBuffer - history->getLines (),
+		    linesInScreenBuffer);
+
+  // invert display when in screen mode
+  if (getMode (MODE_Screen))
+    {
+      for (int i = 0; i < mergedLines * columns; i++)
+	reverseRendition (dest[i]);	// for reverse display
+    }
+
+  // mark the character at the current cursor position
+  int cursorIndex = loc (cuX, cuY + linesInHistoryBuffer);
+  if (getMode (MODE_Cursor) && cursorIndex < columns * mergedLines)
+    dest[cursorIndex].rendition |= RE_CURSOR;
+}
+
+QVector < LineProperty > Screen::getLineProperties (int startLine,
+                                                    int endLine) const
+{
+  Q_ASSERT (startLine >= 0);
+  Q_ASSERT (endLine >= startLine && endLine < history->getLines () + lines);
+
+  const int
+    mergedLines = endLine - startLine + 1;
+  const int
+    linesInHistory =
+    qBound (0, history->getLines () - startLine, mergedLines);
+  const int
+    linesInScreen = mergedLines - linesInHistory;
+
+  QVector < LineProperty > result (mergedLines);
+  int
+    index = 0;
+
+  // copy properties for lines in history
+  for (int line = startLine; line < startLine + linesInHistory; line++)
+    {
+      //TODO Support for line properties other than wrapped lines
+      if (history->isWrappedLine (line))
+	{
+	  result[index] = (LineProperty) (result[index] | LINE_WRAPPED);
+	}
+      index++;
+    }
+
+  // copy properties for lines in screen buffer
+  const int
+    firstScreenLine = startLine + linesInHistory - history->getLines ();
+  for (int line = firstScreenLine; line < firstScreenLine + linesInScreen;
+       line++)
+    {
+      result[index] = lineProperties[line];
+      index++;
+    }
+
+  return result;
+}
+
+void
+Screen::reset (bool clearScreen)
+{
+  setMode (MODE_Wrap);
+  saveMode (MODE_Wrap);		// wrap at end of margin
+  resetMode (MODE_Origin);
+  saveMode (MODE_Origin);	// position refere to [1,1]
+  resetMode (MODE_Insert);
+  saveMode (MODE_Insert);	// overstroke
+  setMode (MODE_Cursor);	// cursor visible
+  resetMode (MODE_Screen);	// screen not inverse
+  resetMode (MODE_NewLine);
+
+  _topMargin = 0;
+  _bottomMargin = lines - 1;
+
+  setDefaultRendition ();
+  saveCursor ();
+
+  if (clearScreen)
+    clear ();
+}
+
+void
+Screen::clear ()
+{
+  clearEntireScreen ();
+  home ();
+}
+
+void
+Screen::backspace ()
+{
+  cuX = qMin (columns - 1, cuX);	// nowrap!
+  cuX = qMax (0, cuX - 1);
+
+  if (screenLines[cuY].size () < cuX + 1)
+    screenLines[cuY].resize (cuX + 1);
+
+  if (BS_CLEARS)
+    screenLines[cuY][cuX].character = ' ';
+}
+
+void
+Screen::tab (int n)
+{
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0)
+    n = 1;
+  while ((n > 0) && (cuX < columns - 1))
+    {
+      cursorRight (1);
+      while ((cuX < columns - 1) && !tabStops[cuX])
+	cursorRight (1);
+      n--;
+    }
+}
+
+void
+Screen::backtab (int n)
+{
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0)
+    n = 1;
+  while ((n > 0) && (cuX > 0))
+    {
+      cursorLeft (1);
+      while ((cuX > 0) && !tabStops[cuX])
+	cursorLeft (1);
+      n--;
+    }
+}
+
+void
+Screen::clearTabStops ()
+{
+  for (int i = 0; i < columns; i++)
+    tabStops[i] = false;
+}
+
+void
+Screen::changeTabStop (bool set)
+{
+  if (cuX >= columns)
+    return;
+  tabStops[cuX] = set;
+}
+
+void
+Screen::initTabStops ()
+{
+  tabStops.resize (columns);
+
+  // Arrg! The 1st tabstop has to be one longer than the other.
+  // i.e. the kids start counting from 0 instead of 1.
+  // Other programs might behave correctly. Be aware.
+  for (int i = 0; i < columns; i++)
+    tabStops[i] = (i % 8 == 0 && i != 0);
+}
+
+void
+Screen::newLine ()
+{
+  if (getMode (MODE_NewLine))
+    toStartOfLine ();
+  index ();
+}
+
+void
+Screen::checkSelection (int from, int to)
+{
+  if (selBegin == -1)
+    return;
+  int scr_TL = loc (0, history->getLines ());
+  //Clear entire selection if it overlaps region [from, to]
+  if ((selBottomRight >= (from + scr_TL)) && (selTopLeft <= (to + scr_TL)))
+    clearSelection ();
+}
+
+void
+Screen::displayCharacter (unsigned short c)
+{
+  // Note that VT100 does wrapping BEFORE putting the character.
+  // This has impact on the assumption of valid cursor positions.
+  // We indicate the fact that a newline has to be triggered by
+  // putting the cursor one right to the last column of the screen.
+
+  int w = konsole_wcwidth (c);
+  if (w <= 0)
+    return;
+
+  if (cuX + w > columns)
+    {
+      if (getMode (MODE_Wrap))
+	{
+	  lineProperties[cuY] =
+	    (LineProperty) (lineProperties[cuY] | LINE_WRAPPED);
+	  nextLine ();
+	}
+      else
+	cuX = columns - w;
+    }
+
+  // ensure current line vector has enough elements
+  int size = screenLines[cuY].size ();
+  if (size < cuX + w)
+    {
+      screenLines[cuY].resize (cuX + w);
+    }
+
+  if (getMode (MODE_Insert))
+    insertChars (w);
+
+  lastPos = loc (cuX, cuY);
+
+  // check if selection is still valid.
+  checkSelection (lastPos, lastPos);
+
+  Character & currentChar = screenLines[cuY][cuX];
+
+  currentChar.character = c;
+  currentChar.foregroundColor = effectiveForeground;
+  currentChar.backgroundColor = effectiveBackground;
+  currentChar.rendition = effectiveRendition;
+
+  int i = 0;
+  int newCursorX = cuX + w--;
+  while (w)
+    {
+      i++;
+
+      if (screenLines[cuY].size () < cuX + i + 1)
+	screenLines[cuY].resize (cuX + i + 1);
+
+      Character & ch = screenLines[cuY][cuX + i];
+      ch.character = 0;
+      ch.foregroundColor = effectiveForeground;
+      ch.backgroundColor = effectiveBackground;
+      ch.rendition = effectiveRendition;
+
+      w--;
+    }
+  cuX = newCursorX;
+}
+
+void
+Screen::compose (const QString & /*compose */ )
+{
+  Q_ASSERT (0 /*Not implemented yet */ );
+
+  /*  if (lastPos == -1)
+     return;
+
+     QChar c(image[lastPos].character);
+     compose.prepend(c);
+     //compose.compose(); ### FIXME!
+     image[lastPos].character = compose[0].unicode(); */
+}
+
+int
+Screen::scrolledLines () const
+{
+  return _scrolledLines;
+}
+
+int
+Screen::droppedLines () const
+{
+  return _droppedLines;
+}
+
+void
+Screen::resetDroppedLines ()
+{
+  _droppedLines = 0;
+}
+
+void
+Screen::resetScrolledLines ()
+{
+  _scrolledLines = 0;
+}
+
+void
+Screen::scrollUp (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+  if (_topMargin == 0)
+    addHistLine ();		// history.history
+  scrollUp (_topMargin, n);
+}
+
+QRect
+Screen::lastScrolledRegion () const
+{
+  return _lastScrolledRegion;
+}
+
+void
+Screen::scrollUp (int from, int n)
+{
+  if (n <= 0 || from + n > _bottomMargin)
+    return;
+
+  _scrolledLines -= n;
+  _lastScrolledRegion =
+    QRect (0, _topMargin, columns - 1, (_bottomMargin - _topMargin));
+
+  //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+  moveImage (loc (0, from), loc (0, from + n),
+	     loc (columns - 1, _bottomMargin));
+  clearImage (loc (0, _bottomMargin - n + 1),
+	      loc (columns - 1, _bottomMargin), ' ');
+}
+
+void
+Screen::scrollDown (int n)
+{
+  if (n == 0)
+    n = 1;			// Default
+  scrollDown (_topMargin, n);
+}
+
+void
+Screen::scrollDown (int from, int n)
+{
+  _scrolledLines += n;
+
+  //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+  if (n <= 0)
+    return;
+  if (from > _bottomMargin)
+    return;
+  if (from + n > _bottomMargin)
+    n = _bottomMargin - from;
+  moveImage (loc (0, from + n), loc (0, from),
+	     loc (columns - 1, _bottomMargin - n));
+  clearImage (loc (0, from), loc (columns - 1, from + n - 1), ' ');
+}
+
+void
+Screen::setCursorYX (int y, int x)
+{
+  setCursorY (y);
+  setCursorX (x);
+}
+
+void
+Screen::setCursorX (int x)
+{
+  if (x == 0)
+    x = 1;			// Default
+  x -= 1;			// Adjust
+  cuX = qMax (0, qMin (columns - 1, x));
+}
+
+void
+Screen::setCursorY (int y)
+{
+  if (y == 0)
+    y = 1;			// Default
+  y -= 1;			// Adjust
+  cuY =
+    qMax (0, qMin (lines - 1, y + (getMode (MODE_Origin) ? _topMargin : 0)));
+}
+
+void
+Screen::home ()
+{
+  cuX = 0;
+  cuY = 0;
+}
+
+void
+Screen::toStartOfLine ()
+{
+  cuX = 0;
+}
+
+int
+Screen::getCursorX () const
+{
+  return cuX;
+}
+
+int
+Screen::getCursorY () const
+{
+  return cuY;
+}
+
+void
+Screen::clearImage (int loca, int loce, char c)
+{
+  int scr_TL = loc (0, history->getLines ());
+  //FIXME: check positions
+
+  //Clear entire selection if it overlaps region to be moved...
+  if ((selBottomRight > (loca + scr_TL)) && (selTopLeft < (loce + scr_TL)))
+    {
+      clearSelection ();
+    }
+
+  int topLine = loca / columns;
+  int bottomLine = loce / columns;
+
+  Character clearCh (c, currentForeground, currentBackground,
+		     DEFAULT_RENDITION);
+
+  //if the character being used to clear the area is the same as the
+  //default character, the affected lines can simply be shrunk.
+  bool isDefaultCh = (clearCh == Character ());
+
+  for (int y = topLine; y <= bottomLine; y++)
+    {
+      lineProperties[y] = 0;
+
+      int endCol = (y == bottomLine) ? loce % columns : columns - 1;
+      int startCol = (y == topLine) ? loca % columns : 0;
+
+      QVector < Character > &line = screenLines[y];
+
+      if (isDefaultCh && endCol == columns - 1)
+	{
+	  line.resize (startCol);
+	}
+      else
+	{
+	  if (line.size () < endCol + 1)
+	    line.resize (endCol + 1);
+
+	  Character *data = line.data ();
+	  for (int i = startCol; i <= endCol; i++)
+	    data[i] = clearCh;
+	}
+    }
+}
+
+void
+Screen::moveImage (int dest, int sourceBegin, int sourceEnd)
+{
+  Q_ASSERT (sourceBegin <= sourceEnd);
+
+  int lines = (sourceEnd - sourceBegin) / columns;
+
+  //move screen image and line properties:
+  //the source and destination areas of the image may overlap, 
+  //so it matters that we do the copy in the right order - 
+  //forwards if dest < sourceBegin or backwards otherwise.
+  //(search the web for 'memmove implementation' for details)
+  if (dest < sourceBegin)
+    {
+      for (int i = 0; i <= lines; i++)
+	{
+	  screenLines[(dest / columns) + i] =
+	    screenLines[(sourceBegin / columns) + i];
+	  lineProperties[(dest / columns) + i] =
+	    lineProperties[(sourceBegin / columns) + i];
+	}
+    }
+  else
+    {
+      for (int i = lines; i >= 0; i--)
+	{
+	  screenLines[(dest / columns) + i] =
+	    screenLines[(sourceBegin / columns) + i];
+	  lineProperties[(dest / columns) + i] =
+	    lineProperties[(sourceBegin / columns) + i];
+	}
+    }
+
+  if (lastPos != -1)
+    {
+      int diff = dest - sourceBegin;	// Scroll by this amount
+      lastPos += diff;
+      if ((lastPos < 0) || (lastPos >= (lines * columns)))
+	lastPos = -1;
+    }
+
+  // Adjust selection to follow scroll.
+  if (selBegin != -1)
+    {
+      bool beginIsTL = (selBegin == selTopLeft);
+      int diff = dest - sourceBegin;	// Scroll by this amount
+      int scr_TL = loc (0, history->getLines ());
+      int srca = sourceBegin + scr_TL;	// Translate index from screen to global
+      int srce = sourceEnd + scr_TL;	// Translate index from screen to global
+      int desta = srca + diff;
+      int deste = srce + diff;
+
+      if ((selTopLeft >= srca) && (selTopLeft <= srce))
+	selTopLeft += diff;
+      else if ((selTopLeft >= desta) && (selTopLeft <= deste))
+	selBottomRight = -1;	// Clear selection (see below)
+
+      if ((selBottomRight >= srca) && (selBottomRight <= srce))
+	selBottomRight += diff;
+      else if ((selBottomRight >= desta) && (selBottomRight <= deste))
+	selBottomRight = -1;	// Clear selection (see below)
+
+      if (selBottomRight < 0)
+	{
+	  clearSelection ();
+	}
+      else
+	{
+	  if (selTopLeft < 0)
+	    selTopLeft = 0;
+	}
+
+      if (beginIsTL)
+	selBegin = selTopLeft;
+      else
+	selBegin = selBottomRight;
+    }
+}
+
+void
+Screen::clearToEndOfScreen ()
+{
+  clearImage (loc (cuX, cuY), loc (columns - 1, lines - 1), ' ');
+}
+
+void
+Screen::clearToBeginOfScreen ()
+{
+  clearImage (loc (0, 0), loc (cuX, cuY), ' ');
+}
+
+void
+Screen::clearEntireScreen ()
+{
+  // Add entire screen to history
+  for (int i = 0; i < (lines - 1); i++)
+    {
+      addHistLine ();
+      scrollUp (0, 1);
+    }
+
+  clearImage (loc (0, 0), loc (columns - 1, lines - 1), ' ');
+}
+
+/*! fill screen with 'E'
+  This is to aid screen alignment
+  */
+
+void
+Screen::helpAlign ()
+{
+  clearImage (loc (0, 0), loc (columns - 1, lines - 1), 'E');
+}
+
+void
+Screen::clearToEndOfLine ()
+{
+  clearImage (loc (cuX, cuY), loc (columns - 1, cuY), ' ');
+}
+
+void
+Screen::clearToBeginOfLine ()
+{
+  clearImage (loc (0, cuY), loc (cuX, cuY), ' ');
+}
+
+void
+Screen::clearEntireLine ()
+{
+  clearImage (loc (0, cuY), loc (columns - 1, cuY), ' ');
+}
+
+void
+Screen::setRendition (int re)
+{
+  currentRendition |= re;
+  updateEffectiveRendition ();
+}
+
+void
+Screen::resetRendition (int re)
+{
+  currentRendition &= ~re;
+  updateEffectiveRendition ();
+}
+
+void
+Screen::setDefaultRendition ()
+{
+  setForeColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR);
+  setBackColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR);
+  currentRendition = DEFAULT_RENDITION;
+  updateEffectiveRendition ();
+}
+
+void
+Screen::setForeColor (int space, int color)
+{
+  currentForeground = CharacterColor (space, color);
+
+  if (currentForeground.isValid ())
+    updateEffectiveRendition ();
+  else
+    setForeColor (COLOR_SPACE_DEFAULT, DEFAULT_FORE_COLOR);
+}
+
+void
+Screen::setBackColor (int space, int color)
+{
+  currentBackground = CharacterColor (space, color);
+
+  if (currentBackground.isValid ())
+    updateEffectiveRendition ();
+  else
+    setBackColor (COLOR_SPACE_DEFAULT, DEFAULT_BACK_COLOR);
+}
+
+void
+Screen::clearSelection ()
+{
+  selBottomRight = -1;
+  selTopLeft = -1;
+  selBegin = -1;
+}
+
+void
+Screen::getSelectionStart (int &column, int &line) const
+{
+  if (selTopLeft != -1)
+    {
+      column = selTopLeft % columns;
+      line = selTopLeft / columns;
+    }
+  else
+    {
+      column = cuX + getHistLines ();
+      line = cuY + getHistLines ();
+    }
+}
+
+void
+Screen::getSelectionEnd (int &column, int &line) const
+{
+  if (selBottomRight != -1)
+    {
+      column = selBottomRight % columns;
+      line = selBottomRight / columns;
+    }
+  else
+    {
+      column = cuX + getHistLines ();
+      line = cuY + getHistLines ();
+    }
+}
+
+void
+Screen::setSelectionStart (const int x, const int y, const bool mode)
+{
+  selBegin = loc (x, y);
+  /* FIXME, HACK to correct for x too far to the right... */
+  if (x == columns)
+    selBegin--;
+
+  selBottomRight = selBegin;
+  selTopLeft = selBegin;
+  blockSelectionMode = mode;
+}
+
+void
+Screen::setSelectionEnd (const int x, const int y)
+{
+  if (selBegin == -1)
+    return;
+
+  int endPos = loc (x, y);
+
+  if (endPos < selBegin)
+    {
+      selTopLeft = endPos;
+      selBottomRight = selBegin;
+    }
+  else
+    {
+      /* FIXME, HACK to correct for x too far to the right... */
+      if (x == columns)
+	endPos--;
+
+      selTopLeft = selBegin;
+      selBottomRight = endPos;
+    }
+
+  // Normalize the selection in column mode
+  if (blockSelectionMode)
+    {
+      int topRow = selTopLeft / columns;
+      int topColumn = selTopLeft % columns;
+      int bottomRow = selBottomRight / columns;
+      int bottomColumn = selBottomRight % columns;
+
+      selTopLeft = loc (qMin (topColumn, bottomColumn), topRow);
+      selBottomRight = loc (qMax (topColumn, bottomColumn), bottomRow);
+    }
+}
+
+bool
+Screen::isSelected (const int x, const int y) const
+{
+  bool columnInSelection = true;
+  if (blockSelectionMode)
+    {
+      columnInSelection = x >= (selTopLeft % columns) &&
+	x <= (selBottomRight % columns);
+    }
+
+  int pos = loc (x, y);
+  return pos >= selTopLeft && pos <= selBottomRight && columnInSelection;
+}
+
+QString
+Screen::selectedText (bool preserveLineBreaks) const
+{
+  QString result;
+  QTextStream stream (&result, QIODevice::ReadWrite);
+
+  PlainTextDecoder decoder;
+  decoder.begin (&stream);
+  writeSelectionToStream (&decoder, preserveLineBreaks);
+  decoder.end ();
+
+  return result;
+}
+
+bool
+Screen::isSelectionValid () const
+{
+  return selTopLeft >= 0 && selBottomRight >= 0;
+}
+
+void
+Screen::writeSelectionToStream (TerminalCharacterDecoder * decoder,
+                                bool preserveLineBreaks) const
+{
+  if (!isSelectionValid ())
+    return;
+  writeToStream (decoder, selTopLeft, selBottomRight, preserveLineBreaks);
+}
+
+void
+Screen::writeToStream (TerminalCharacterDecoder * decoder,
+		       int startIndex, int endIndex,
+                       bool preserveLineBreaks) const
+{
+  int top = startIndex / columns;
+  int left = startIndex % columns;
+
+  int bottom = endIndex / columns;
+  int right = endIndex % columns;
+
+  Q_ASSERT (top >= 0 && left >= 0 && bottom >= 0 && right >= 0);
+
+  for (int y = top; y <= bottom; y++)
+    {
+      int start = 0;
+      if (y == top || blockSelectionMode)
+	start = left;
+
+      int count = -1;
+      if (y == bottom || blockSelectionMode)
+	count = right - start + 1;
+
+      const bool appendNewLine = (y != bottom);
+      int copied = copyLineToStream (y,
+				     start,
+				     count,
+				     decoder,
+				     appendNewLine,
+				     preserveLineBreaks);
+
+      // if the selection goes beyond the end of the last line then
+      // append a new line character.
+      //
+      // this makes it possible to 'select' a trailing new line character after
+      // the text on a line.  
+      if (y == bottom && copied < count)
+	{
+	  Character newLineChar ('\n');
+	  decoder->decodeLine (&newLineChar, 1, 0);
+	}
+    }
+}
+
+int
+Screen::copyLineToStream (int line,
+			  int start,
+			  int count,
+			  TerminalCharacterDecoder * decoder,
+			  bool appendNewLine,
+                          bool preserveLineBreaks) const
+{
+  //buffer to hold characters for decoding
+  //the buffer is static to avoid initialising every 
+  //element on each call to copyLineToStream
+  //(which is unnecessary since all elements will be overwritten anyway)
+  static const int MAX_CHARS = 1024;
+  static Character characterBuffer[MAX_CHARS];
+
+  assert (count < MAX_CHARS);
+
+  LineProperty currentLineProperties = 0;
+
+  //determine if the line is in the history buffer or the screen image
+  if (line < history->getLines ())
+    {
+      const int lineLength = history->getLineLen (line);
+
+      // ensure that start position is before end of line
+      start = qMin (start, qMax (0, lineLength - 1));
+
+      // retrieve line from history buffer.  It is assumed
+      // that the history buffer does not store trailing white space
+      // at the end of the line, so it does not need to be trimmed here 
+      if (count == -1)
+	{
+	  count = lineLength - start;
+	}
+      else
+	{
+	  count = qMin (start + count, lineLength) - start;
+	}
+
+      // safety checks
+      assert (start >= 0);
+      assert (count >= 0);
+      assert ((start + count) <= history->getLineLen (line));
+
+      history->getCells (line, start, count, characterBuffer);
+
+      if (history->isWrappedLine (line))
+	currentLineProperties |= LINE_WRAPPED;
+    }
+  else
+    {
+      if (count == -1)
+	count = columns - start;
+
+      assert (count >= 0);
+
+      const int screenLine = line - history->getLines ();
+
+      Character *data = screenLines[screenLine].data ();
+      int length = screenLines[screenLine].count ();
+
+      //retrieve line from screen image
+      for (int i = start; i < qMin (start + count, length); i++)
+	{
+	  characterBuffer[i - start] = data[i];
+	}
+
+      // count cannot be any greater than length
+      count = qBound (0, count, length - start);
+
+      Q_ASSERT (screenLine < lineProperties.count ());
+      currentLineProperties |= lineProperties[screenLine];
+    }
+
+  // add new line character at end
+  const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
+    !preserveLineBreaks;
+
+  if (!omitLineBreak && appendNewLine && (count + 1 < MAX_CHARS))
+    {
+      characterBuffer[count] = '\n';
+      count++;
+    }
+
+  //decode line and write to text stream    
+  decoder->decodeLine ((Character *) characterBuffer,
+		       count, currentLineProperties);
+
+  return count;
+}
+
+void
+Screen::writeLinesToStream (TerminalCharacterDecoder * decoder, int fromLine,
+                            int toLine) const
+{
+  writeToStream (decoder, loc (0, fromLine), loc (columns - 1, toLine));
+}
+
+void
+Screen::addHistLine ()
+{
+  // add line to history buffer
+  // we have to take care about scrolling, too...
+
+  if (hasScroll ())
+    {
+      int oldHistLines = history->getLines ();
+
+      history->addCellsVector (screenLines[0]);
+      history->addLine (lineProperties[0] & LINE_WRAPPED);
+
+      int newHistLines = history->getLines ();
+
+      bool beginIsTL = (selBegin == selTopLeft);
+
+      // If the history is full, increment the count
+      // of dropped lines
+      if (newHistLines == oldHistLines)
+	_droppedLines++;
+
+      // Adjust selection for the new point of reference
+      if (newHistLines > oldHistLines)
+	{
+	  if (selBegin != -1)
+	    {
+	      selTopLeft += columns;
+	      selBottomRight += columns;
+	    }
+	}
+
+      if (selBegin != -1)
+	{
+	  // Scroll selection in history up
+	  int top_BR = loc (0, 1 + newHistLines);
+
+	  if (selTopLeft < top_BR)
+	    selTopLeft -= columns;
+
+	  if (selBottomRight < top_BR)
+	    selBottomRight -= columns;
+
+	  if (selBottomRight < 0)
+	    clearSelection ();
+	  else
+	    {
+	      if (selTopLeft < 0)
+		selTopLeft = 0;
+	    }
+
+	  if (beginIsTL)
+	    selBegin = selTopLeft;
+	  else
+	    selBegin = selBottomRight;
+	}
+    }
+
+}
+
+int
+Screen::getHistLines () const
+{
+  return history->getLines ();
+}
+
+void
+Screen::setScroll (const HistoryType & t, bool copyPreviousScroll)
+{
+  clearSelection ();
+
+  if (copyPreviousScroll)
+    history = t.scroll (history);
+  else
+    {
+      HistoryScroll *oldScroll = history;
+      history = t.scroll (0);
+      delete oldScroll;
+    }
+}
+
+bool
+Screen::hasScroll () const
+{
+  return history->hasScroll ();
+}
+
+const HistoryType &
+Screen::getScroll () const
+{
+  return history->getType ();
+}
+
+void
+Screen::setLineProperty (LineProperty property, bool enable)
+{
+  if (enable)
+    lineProperties[cuY] = (LineProperty) (lineProperties[cuY] | property);
+  else
+    lineProperties[cuY] = (LineProperty) (lineProperties[cuY] & ~property);
+}
+
+void
+Screen::fillWithDefaultChar (Character * dest, int count)
+{
+  for (int i = 0; i < count; i++)
+    dest[i] = defaultChar;
+}
diff --git a/gui/src/terminal/Screen.h b/gui/src/terminal/Screen.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Screen.h
@@ -0,0 +1,678 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SCREEN_H
+#define SCREEN_H
+
+// Qt
+#include <QtCore/QRect>
+#include <QtCore/QTextStream>
+#include <QtCore/QVarLengthArray>
+
+// Konsole
+#include "Character.h"
+#include "History.h"
+
+#define MODE_Origin    0
+#define MODE_Wrap      1
+#define MODE_Insert    2
+#define MODE_Screen    3
+#define MODE_Cursor    4
+#define MODE_NewLine   5
+#define MODES_SCREEN   6
+
+class TerminalCharacterDecoder;
+
+/**
+    \brief An image of characters with associated attributes.
+
+    The terminal emulation ( Emulation ) receives a serial stream of
+    characters from the program currently running in the terminal.
+    From this stream it creates an image of characters which is ultimately
+    rendered by the display widget ( TerminalDisplay ).  Some types of emulation
+    may have more than one screen image. 
+
+    getImage() is used to retrieve the currently visible image
+    which is then used by the display widget to draw the output from the
+    terminal. 
+
+    The number of lines of output history which are kept in addition to the current
+    screen image depends on the history scroll being used to store the output.  
+    The scroll is specified using setScroll()
+    The output history can be retrieved using writeToStream()
+
+    The screen image has a selection associated with it, specified using 
+    setSelectionStart() and setSelectionEnd().  The selected text can be retrieved
+    using selectedText().  When getImage() is used to retrieve the visible image,
+    characters which are part of the selection have their colours inverted.   
+*/
+class Screen
+{
+public:
+    /** Construct a new screen image of size @p lines by @p columns. */
+  Screen (int lines, int columns);
+   ~Screen ();
+
+  // VT100/2 Operations 
+  // Cursor Movement
+
+    /** 
+     * Move the cursor up by @p n lines.  The cursor will stop at the 
+     * top margin.
+     */
+  void cursorUp (int n);
+    /** 
+     * Move the cursor down by @p n lines.  The cursor will stop at the
+     * bottom margin.
+     */
+  void cursorDown (int n);
+    /** 
+     * Move the cursor to the left by @p n columns.
+     * The cursor will stop at the first column.
+     */
+  void cursorLeft (int n);
+    /** 
+     * Move the cursor to the right by @p n columns.
+     * The cursor will stop at the right-most column.
+     */
+  void cursorRight (int n);
+    /** Position the cursor on line @p y. */
+  void setCursorY (int y);
+    /** Position the cursor at column @p x. */
+  void setCursorX (int x);
+    /** Position the cursor at line @p y, column @p x. */
+  void setCursorYX (int y, int x);
+    /**
+     * Sets the margins for scrolling the screen.
+     *
+     * @param topLine The top line of the new scrolling margin. 
+     * @param bottomLine The bottom line of the new scrolling margin. 
+     */
+  void setMargins (int topLine, int bottomLine);
+    /** Returns the top line of the scrolling region. */
+  int topMargin () const;
+    /** Returns the bottom line of the scrolling region. */
+  int bottomMargin () const;
+
+    /** 
+     * Resets the scrolling margins back to the top and bottom lines
+     * of the screen.
+     */
+  void setDefaultMargins ();
+
+    /** 
+     * Moves the cursor down one line, if the MODE_NewLine mode 
+     * flag is enabled then the cursor is returned to the leftmost
+     * column first.
+     *
+     * Equivalent to NextLine() if the MODE_NewLine flag is set
+     * or index() otherwise. 
+     */
+  void newLine ();
+    /**
+     * Moves the cursor down one line and positions it at the beginning
+     * of the line.  Equivalent to calling Return() followed by index()
+     */
+  void nextLine ();
+
+    /** 
+     * Move the cursor down one line.  If the cursor is on the bottom
+     * line of the scrolling region (as returned by bottomMargin()) the
+     * scrolling region is scrolled up by one line instead.
+     */
+  void index ();
+    /**
+     * Move the cursor up one line.  If the cursor is on the top line
+     * of the scrolling region (as returned by topMargin()) the scrolling
+     * region is scrolled down by one line instead.
+     */
+  void reverseIndex ();
+
+    /** 
+     * Scroll the scrolling region of the screen up by @p n lines. 
+     * The scrolling region is initially the whole screen, but can be changed 
+     * using setMargins()
+     */
+  void scrollUp (int n);
+    /**
+     * Scroll the scrolling region of the screen down by @p n lines.
+     * The scrolling region is initially the whole screen, but can be changed
+     * using setMargins()
+     */
+  void scrollDown (int n);
+    /** 
+     * Moves the cursor to the beginning of the current line. 
+     * Equivalent to setCursorX(0)
+     */
+  void toStartOfLine ();
+    /** 
+     * Moves the cursor one column to the left and erases the character
+     * at the new cursor position.
+     */
+  void backspace ();
+    /** Moves the cursor @p n tab-stops to the right. */
+  void tab (int n = 1);
+    /** Moves the cursor @p n tab-stops to the left. */
+  void backtab (int n);
+
+  // Editing
+
+    /** 
+     * Erase @p n characters beginning from the current cursor position. 
+     * This is equivalent to over-writing @p n characters starting with the current
+     * cursor position with spaces.
+     * If @p n is 0 then one character is erased. 
+     */
+  void eraseChars (int n);
+    /** 
+     * Delete @p n characters beginning from the current cursor position. 
+     * If @p n is 0 then one character is deleted. 
+     */
+  void deleteChars (int n);
+    /**
+     * Insert @p n blank characters beginning from the current cursor position.
+     * The position of the cursor is not altered.  
+     * If @p n is 0 then one character is inserted.
+     */
+  void insertChars (int n);
+    /** 
+     * Removes @p n lines beginning from the current cursor position.
+     * The position of the cursor is not altered.
+     * If @p n is 0 then one line is removed.
+     */
+  void deleteLines (int n);
+    /**
+     * Inserts @p lines beginning from the current cursor position.
+     * The position of the cursor is not altered.
+     * If @p n is 0 then one line is inserted.
+     */
+  void insertLines (int n);
+    /** Clears all the tab stops. */
+  void clearTabStops ();
+    /**  Sets or removes a tab stop at the cursor's current column. */
+  void changeTabStop (bool set);
+
+    /** Resets (clears) the specified screen @p mode. */
+  void resetMode (int mode);
+    /** Sets (enables) the specified screen @p mode. */
+  void setMode (int mode);
+    /** 
+     * Saves the state of the specified screen @p mode.  It can be restored
+     * using restoreMode()
+     */
+  void saveMode (int mode);
+    /** Restores the state of a screen @p mode saved by calling saveMode() */
+  void restoreMode (int mode);
+    /** Returns whether the specified screen @p mode is enabled or not .*/
+  bool getMode (int mode) const;
+
+    /** 
+     * Saves the current position and appearance (text color and style) of the cursor. 
+     * It can be restored by calling restoreCursor() 
+     */
+  void saveCursor ();
+    /** Restores the position and appearance of the cursor.  See saveCursor() */
+  void restoreCursor ();
+
+    /** Clear the whole screen, moving the current screen contents into the history first. */
+  void clearEntireScreen ();
+    /** 
+     * Clear the area of the screen from the current cursor position to the end of 
+     * the screen.
+     */
+  void clearToEndOfScreen ();
+    /**
+     * Clear the area of the screen from the current cursor position to the start
+     * of the screen.
+     */
+  void clearToBeginOfScreen ();
+    /** Clears the whole of the line on which the cursor is currently positioned. */
+  void clearEntireLine ();
+    /** Clears from the current cursor position to the end of the line. */
+  void clearToEndOfLine ();
+    /** Clears from the current cursor position to the beginning of the line. */
+  void clearToBeginOfLine ();
+
+    /** Fills the entire screen with the letter 'E' */
+  void helpAlign ();
+
+    /** 
+     * Enables the given @p rendition flag.  Rendition flags control the appearance 
+     * of characters on the screen.
+     *
+     * @see Character::rendition
+     */
+  void setRendition (int rendition);
+    /**
+     * Disables the given @p rendition flag.  Rendition flags control the appearance
+     * of characters on the screen.
+     *
+     * @see Character::rendition
+     */
+  void resetRendition (int rendition);
+
+    /** 
+     * Sets the cursor's foreground color.
+     * @param space The color space used by the @p color argument
+     * @param color The new foreground color.  The meaning of this depends on
+     * the color @p space used.
+     *
+     * @see CharacterColor
+     */
+  void setForeColor (int space, int color);
+    /**
+     * Sets the cursor's background color.
+     * @param space The color space used by the @p color argumnet.
+     * @param color The new background color.  The meaning of this depends on
+     * the color @p space used.
+     *
+     * @see CharacterColor
+     */
+  void setBackColor (int space, int color);
+    /** 
+     * Resets the cursor's color back to the default and sets the 
+     * character's rendition flags back to the default settings.
+     */
+  void setDefaultRendition ();
+
+    /** Returns the column which the cursor is positioned at. */
+  int getCursorX () const;
+    /** Returns the line which the cursor is positioned on. */
+  int getCursorY () const;
+
+    /** Clear the entire screen and move the cursor to the home position.
+     * Equivalent to calling clearEntireScreen() followed by home().
+     */
+  void clear ();
+    /** 
+     * Sets the position of the cursor to the 'home' position at the top-left
+     * corner of the screen (0,0) 
+     */
+  void home ();
+    /**
+     * Resets the state of the screen.  This resets the various screen modes
+     * back to their default states.  The cursor style and colors are reset
+     * (as if setDefaultRendition() had been called)
+     *setDefaultRendition
+     * <ul>
+     * <li>Line wrapping is enabled.</li>
+     * <li>Origin mode is disabled.</li>
+     * <li>Insert mode is disabled.</li>
+     * <li>Cursor mode is enabled.  TODO Document me</li>
+     * <li>Screen mode is disabled. TODO Document me</li>
+     * <li>New line mode is disabled.  TODO Document me</li>
+     * </ul>
+     *
+     * If @p clearScreen is true then the screen contents are erased entirely, 
+     * otherwise they are unaltered.
+     */
+  void reset (bool clearScreen = true);
+
+    /** 
+     * Displays a new character at the current cursor position. 
+     * 
+     * If the cursor is currently positioned at the right-edge of the screen and
+     * line wrapping is enabled then the character is added at the start of a new 
+     * line below the current one.
+     *
+     * If the MODE_Insert screen mode is currently enabled then the character 
+     * is inserted at the current cursor position, otherwise it will replace the 
+     * character already at the current cursor position.  
+     */
+  void displayCharacter (unsigned short c);
+
+  // Do composition with last shown character FIXME: Not implemented yet for KDE 4
+  void compose (const QString & compose);
+
+    /** 
+     * Resizes the image to a new fixed size of @p new_lines by @p new_columns.  
+     * In the case that @p new_columns is smaller than the current number of columns,
+     * existing lines are not truncated.  This prevents characters from being lost
+     * if the terminal display is resized smaller and then larger again.
+     *
+     * The top and bottom margins are reset to the top and bottom of the new 
+     * screen size.  Tab stops are also reset and the current selection is
+     * cleared.
+     */
+  void resizeImage (int new_lines, int new_columns);
+
+    /**
+     * Returns the current screen image.  
+     * The result is an array of Characters of size [getLines()][getColumns()] which
+     * must be freed by the caller after use.
+     *
+     * @param dest Buffer to copy the characters into
+     * @param size Size of @p dest in Characters
+     * @param startLine Index of first line to copy
+     * @param endLine Index of last line to copy
+     */
+  void getImage (Character * dest, int size, int startLine,
+		 int endLine) const;
+
+    /** 
+     * Returns the additional attributes associated with lines in the image.
+     * The most important attribute is LINE_WRAPPED which specifies that the 
+     * line is wrapped,
+     * other attributes control the size of characters in the line.
+     */
+    QVector < LineProperty > getLineProperties (int startLine,
+						int endLine) const;
+
+
+    /** Return the number of lines. */
+  int getLines () const
+  {
+    return lines;
+  }
+    /** Return the number of columns. */
+  int getColumns () const
+  {
+    return columns;
+  }
+    /** Return the number of lines in the history buffer. */
+  int getHistLines () const;
+    /** 
+     * Sets the type of storage used to keep lines in the history. 
+     * If @p copyPreviousScroll is true then the contents of the previous 
+     * history buffer are copied into the new scroll.
+     */
+  void setScroll (const HistoryType &, bool copyPreviousScroll = true);
+    /** Returns the type of storage used to keep lines in the history. */
+  const HistoryType & getScroll () const;
+    /** 
+     * Returns true if this screen keeps lines that are scrolled off the screen
+     * in a history buffer.
+     */
+  bool hasScroll () const;
+
+    /** 
+     * Sets the start of the selection.
+     *
+     * @param column The column index of the first character in the selection.
+     * @param line The line index of the first character in the selection.
+     * @param blockSelectionMode True if the selection is in column mode.
+     */
+  void setSelectionStart (const int column, const int line,
+			  const bool blockSelectionMode);
+
+    /**
+     * Sets the end of the current selection.
+     *
+     * @param column The column index of the last character in the selection.
+     * @param line The line index of the last character in the selection. 
+     */
+  void setSelectionEnd (const int column, const int line);
+
+    /**
+     * Retrieves the start of the selection or the cursor position if there
+     * is no selection.
+     */
+  void getSelectionStart (int &column, int &line) const;
+
+    /**
+     * Retrieves the end of the selection or the cursor position if there
+     * is no selection.
+     */
+  void getSelectionEnd (int &column, int &line) const;
+
+    /** Clears the current selection */
+  void clearSelection ();
+
+    /** 
+      *  Returns true if the character at (@p column, @p line) is part of the
+      *  current selection. 
+      */
+  bool isSelected (const int column, const int line) const;
+
+    /** 
+     * Convenience method.  Returns the currently selected text. 
+     * @param preserveLineBreaks Specifies whether new line characters should 
+     * be inserted into the returned text at the end of each terminal line.
+     */
+  QString selectedText (bool preserveLineBreaks) const;
+
+    /**
+     * Copies part of the output to a stream.
+     *
+     * @param decoder A decoder which converts terminal characters into text
+     * @param fromLine The first line in the history to retrieve
+     * @param toLine The last line in the history to retrieve
+     */
+  void writeLinesToStream (TerminalCharacterDecoder * decoder, int fromLine,
+			   int toLine) const;
+
+    /**
+     * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
+     * into a stream.
+     *
+     * @param decoder A decoder which converts terminal characters into text.  
+     * PlainTextDecoder is the most commonly used decoder which converts characters 
+     * into plain text with no formatting.
+     * @param preserveLineBreaks Specifies whether new line characters should 
+     * be inserted into the returned text at the end of each terminal line. 
+     */
+  void writeSelectionToStream (TerminalCharacterDecoder * decoder, bool
+			       preserveLineBreaks = true) const;
+
+    /**
+     * Checks if the text between from and to is inside the current
+     * selection. If this is the case, the selection is cleared. The
+     * from and to are coordinates in the current viewable window.
+     * The loc(x,y) macro can be used to generate these values from a
+     * column,line pair.
+     *
+     * @param from The start of the area to check.
+     * @param to The end of the area to check
+     */
+  void checkSelection (int from, int to);
+
+    /** 
+     * Sets or clears an attribute of the current line.
+     * 
+     * @param property The attribute to set or clear
+     * Possible properties are:
+     * LINE_WRAPPED:     Specifies that the line is wrapped.
+     * LINE_DOUBLEWIDTH: Specifies that the characters in the current line
+     *                   should be double the normal width.
+     * LINE_DOUBLEHEIGHT:Specifies that the characters in the current line 
+     *                   should be double the normal height.
+     *                   Double-height lines are formed of two lines containing the same characters,
+     *                   with both having the LINE_DOUBLEHEIGHT attribute.
+     *                   This allows other parts of the code to work on the
+     *                   assumption that all lines are the same height.
+     *
+     * @param enable true to apply the attribute to the current line or false to remove it
+     */
+  void setLineProperty (LineProperty property, bool enable);
+
+    /** 
+     * Returns the number of lines that the image has been scrolled up or down by,
+     * since the last call to resetScrolledLines().
+     *
+     * a positive return value indicates that the image has been scrolled up,
+     * a negative return value indicates that the image has been scrolled down. 
+     */
+  int scrolledLines () const;
+
+    /**
+     * Returns the region of the image which was last scrolled.
+     *
+     * This is the area of the image from the top margin to the 
+     * bottom margin when the last scroll occurred.
+     */
+  QRect lastScrolledRegion () const;
+
+    /** 
+     * Resets the count of the number of lines that the image has been scrolled up or down by,
+     * see scrolledLines()
+     */
+  void resetScrolledLines ();
+
+    /**
+     * Returns the number of lines of output which have been
+     * dropped from the history since the last call
+     * to resetDroppedLines()
+     *
+     * If the history is not unlimited then it will drop
+     * the oldest lines of output if new lines are added when
+     * it is full.  
+     */
+  int droppedLines () const;
+
+    /**
+     * Resets the count of the number of lines dropped from
+     * the history.
+     */
+  void resetDroppedLines ();
+
+    /** 
+      * Fills the buffer @p dest with @p count instances of the default (ie. blank)
+      * Character style.
+      */
+  static void fillWithDefaultChar (Character * dest, int count);
+
+private:
+
+  //copies a line of text from the screen or history into a stream using a 
+  //specified character decoder.  Returns the number of lines actually copied,
+  //which may be less than 'count' if (start+count) is more than the number of characters on
+  //the line 
+  //
+  //line - the line number to copy, from 0 (the earliest line in the history) up to 
+  //         history->getLines() + lines - 1
+  //start - the first column on the line to copy
+  //count - the number of characters on the line to copy
+  //decoder - a decoder which converts terminal characters (an Character array) into text
+  //appendNewLine - if true a new line character (\n) is appended to the end of the line
+  int copyLineToStream (int line,
+			int start,
+			int count,
+			TerminalCharacterDecoder * decoder,
+			bool appendNewLine, bool preserveLineBreaks) const;
+
+  //fills a section of the screen image with the character 'c'
+  //the parameters are specified as offsets from the start of the screen image.
+  //the loc(x,y) macro can be used to generate these values from a column,line pair.
+  void clearImage (int loca, int loce, char c);
+
+  //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
+  //the parameters are specified as offsets from the start of the screen image.
+  //the loc(x,y) macro can be used to generate these values from a column,line pair.
+  //
+  //NOTE: moveImage() can only move whole lines
+  void moveImage (int dest, int sourceBegin, int sourceEnd);
+  // scroll up 'i' lines in current region, clearing the bottom 'i' lines 
+  void scrollUp (int from, int i);
+  // scroll down 'i' lines in current region, clearing the top 'i' lines
+  void scrollDown (int from, int i);
+
+  void addHistLine ();
+
+  void initTabStops ();
+
+  void updateEffectiveRendition ();
+  void reverseRendition (Character & p) const;
+
+  bool isSelectionValid () const;
+  // copies text from 'startIndex' to 'endIndex' to a stream
+  // startIndex and endIndex are positions generated using the loc(x,y) macro
+  void writeToStream (TerminalCharacterDecoder * decoder, int startIndex,
+		      int endIndex, bool preserveLineBreaks = true) const;
+  // copies 'count' lines from the screen buffer into 'dest',
+  // starting from 'startLine', where 0 is the first line in the screen buffer
+  void copyFromScreen (Character * dest, int startLine, int count) const;
+  // copies 'count' lines from the history buffer into 'dest',
+  // starting from 'startLine', where 0 is the first line in the history
+  void copyFromHistory (Character * dest, int startLine, int count) const;
+
+
+  // screen image ----------------
+  int lines;
+  int columns;
+
+  typedef QVector < Character > ImageLine;	// [0..columns]
+  ImageLine *screenLines;	// [lines]
+
+  int _scrolledLines;
+  QRect _lastScrolledRegion;
+
+  int _droppedLines;
+
+    QVarLengthArray < LineProperty, 64 > lineProperties;
+
+  // history buffer ---------------
+  HistoryScroll *history;
+
+  // cursor location
+  int cuX;
+  int cuY;
+
+  // cursor color and rendition info
+  CharacterColor currentForeground;
+  CharacterColor currentBackground;
+  quint8 currentRendition;
+
+  // margins ----------------
+  int _topMargin;
+  int _bottomMargin;
+
+  // states ----------------
+  int currentModes[MODES_SCREEN];
+  int savedModes[MODES_SCREEN];
+
+  // ----------------------------
+
+  QBitArray tabStops;
+
+  // selection -------------------
+  int selBegin;			// The first location selected.
+  int selTopLeft;		// TopLeft Location.
+  int selBottomRight;		// Bottom Right Location.
+  bool blockSelectionMode;	// Column selection mode
+
+  // effective colors and rendition ------------
+  CharacterColor effectiveForeground;	// These are derived from
+  CharacterColor effectiveBackground;	// the cu_* variables above
+  quint8 effectiveRendition;	// to speed up operation
+
+  class SavedState
+  {
+  public:
+    SavedState ():cursorColumn (0), cursorLine (0), rendition (0)
+    {
+    }
+
+    int cursorColumn;
+    int cursorLine;
+    quint8 rendition;
+    CharacterColor foreground;
+    CharacterColor background;
+  };
+  SavedState savedState;
+
+  // last position where we added a character
+  int lastPos;
+
+  static Character defaultChar;
+};
+
+#endif // SCREEN_H
diff --git a/gui/src/terminal/ScreenWindow.cpp b/gui/src/terminal/ScreenWindow.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/ScreenWindow.cpp
@@ -0,0 +1,326 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "ScreenWindow.h"
+
+// Qt
+#include <QtCore>
+
+// Konsole
+#include "Screen.h"
+
+ScreenWindow::ScreenWindow (QObject * parent):QObject (parent), _windowBuffer (0), _windowBufferSize (0),
+_bufferNeedsUpdate (true), _windowLines (1), _currentLine (0),
+_trackOutput (true), _scrollCount (0)
+{
+}
+
+ScreenWindow::~ScreenWindow ()
+{
+  delete[]_windowBuffer;
+}
+
+void
+ScreenWindow::setScreen (Screen * screen)
+{
+  Q_ASSERT (screen);
+
+  _screen = screen;
+}
+
+Screen *
+ScreenWindow::screen () const
+{
+  return _screen;
+}
+
+Character *
+ScreenWindow::getImage ()
+{
+  // reallocate internal buffer if the window size has changed
+  int size = windowLines () * windowColumns ();
+  if (_windowBuffer == 0 || _windowBufferSize != size)
+    {
+      delete[]_windowBuffer;
+      _windowBufferSize = size;
+      _windowBuffer = new Character[size];
+      _bufferNeedsUpdate = true;
+    }
+
+  if (!_bufferNeedsUpdate)
+    return _windowBuffer;
+
+  _screen->getImage (_windowBuffer, size, currentLine (), endWindowLine ());
+
+  // this window may look beyond the end of the screen, in which 
+  // case there will be an unused area which needs to be filled
+  // with blank characters
+  fillUnusedArea ();
+
+  _bufferNeedsUpdate = false;
+  return _windowBuffer;
+}
+
+void
+ScreenWindow::fillUnusedArea ()
+{
+  int screenEndLine = _screen->getHistLines () + _screen->getLines () - 1;
+  int windowEndLine = currentLine () + windowLines () - 1;
+
+  int unusedLines = windowEndLine - screenEndLine;
+  int charsToFill = unusedLines * windowColumns ();
+
+  Screen::fillWithDefaultChar (_windowBuffer + _windowBufferSize -
+			       charsToFill, charsToFill);
+}
+
+// return the index of the line at the end of this window, or if this window 
+// goes beyond the end of the screen, the index of the line at the end
+// of the screen.
+//
+// when passing a line number to a Screen method, the line number should
+// never be more than endWindowLine()
+//
+int
+ScreenWindow::endWindowLine () const
+{
+  return qMin (currentLine () + windowLines () - 1, lineCount () - 1);
+}
+
+QVector < LineProperty > ScreenWindow::getLineProperties ()
+{
+  QVector < LineProperty > result =
+    _screen->getLineProperties (currentLine (), endWindowLine ());
+
+  if (result.count () != windowLines ())
+    result.resize (windowLines ());
+
+  return result;
+}
+
+QString
+ScreenWindow::selectedText (bool preserveLineBreaks) const
+{
+  return _screen->selectedText (preserveLineBreaks);
+}
+
+void
+ScreenWindow::getSelectionStart (int &column, int &line)
+{
+  _screen->getSelectionStart (column, line);
+  line -= currentLine ();
+}
+
+void
+ScreenWindow::getSelectionEnd (int &column, int &line)
+{
+  _screen->getSelectionEnd (column, line);
+  line -= currentLine ();
+}
+
+void
+ScreenWindow::setSelectionStart (int column, int line, bool columnMode)
+{
+  _screen->setSelectionStart (column,
+			      qMin (line + currentLine (), endWindowLine ()),
+			      columnMode);
+
+  _bufferNeedsUpdate = true;
+  emit selectionChanged ();
+}
+
+void
+ScreenWindow::setSelectionEnd (int column, int line)
+{
+  _screen->setSelectionEnd (column,
+			    qMin (line + currentLine (), endWindowLine ()));
+
+  _bufferNeedsUpdate = true;
+  emit selectionChanged ();
+}
+
+bool
+ScreenWindow::isSelected (int column, int line)
+{
+  return _screen->isSelected (column,
+			      qMin (line + currentLine (), endWindowLine ()));
+}
+
+void
+ScreenWindow::clearSelection ()
+{
+  _screen->clearSelection ();
+
+  emit selectionChanged ();
+}
+
+void
+ScreenWindow::setWindowLines (int lines)
+{
+  Q_ASSERT (lines > 0);
+  _windowLines = lines;
+}
+
+int
+ScreenWindow::windowLines () const
+{
+  return _windowLines;
+}
+
+int
+ScreenWindow::windowColumns () const
+{
+  return _screen->getColumns ();
+}
+
+int
+ScreenWindow::lineCount () const
+{
+  return _screen->getHistLines () + _screen->getLines ();
+}
+
+int
+ScreenWindow::columnCount () const
+{
+  return _screen->getColumns ();
+}
+
+QPoint
+ScreenWindow::cursorPosition () const
+{
+  QPoint position;
+
+  position.setX (_screen->getCursorX ());
+  position.setY (_screen->getCursorY ());
+
+  return position;
+}
+
+int
+ScreenWindow::currentLine () const
+{
+  return qBound (0, _currentLine, lineCount () - windowLines ());
+}
+
+void
+ScreenWindow::scrollBy (RelativeScrollMode mode, int amount)
+{
+  if (mode == ScrollLines)
+    {
+      scrollTo (currentLine () + amount);
+    }
+  else if (mode == ScrollPages)
+    {
+      scrollTo (currentLine () + amount * (windowLines () / 2));
+    }
+}
+
+bool
+ScreenWindow::atEndOfOutput () const
+{
+  return currentLine () == (lineCount () - windowLines ());
+}
+
+void
+ScreenWindow::scrollTo (int line)
+{
+  int maxCurrentLineNumber = lineCount () - windowLines ();
+  line = qBound (0, line, maxCurrentLineNumber);
+
+  const int delta = line - _currentLine;
+  _currentLine = line;
+
+  // keep track of number of lines scrolled by,
+  // this can be reset by calling resetScrollCount()
+  _scrollCount += delta;
+
+  _bufferNeedsUpdate = true;
+
+  emit scrolled (_currentLine);
+}
+
+void
+ScreenWindow::setTrackOutput (bool trackOutput)
+{
+  _trackOutput = trackOutput;
+}
+
+bool
+ScreenWindow::trackOutput () const
+{
+  return _trackOutput;
+}
+
+int
+ScreenWindow::scrollCount () const
+{
+  return _scrollCount;
+}
+
+void
+ScreenWindow::resetScrollCount ()
+{
+  _scrollCount = 0;
+}
+
+QRect
+ScreenWindow::scrollRegion () const
+{
+  bool equalToScreenSize = windowLines () == _screen->getLines ();
+
+  if (atEndOfOutput () && equalToScreenSize)
+    return _screen->lastScrolledRegion ();
+  else
+    return QRect (0, 0, windowColumns (), windowLines ());
+}
+
+void
+ScreenWindow::notifyOutputChanged ()
+{
+  // move window to the bottom of the screen and update scroll count
+  // if this window is currently tracking the bottom of the screen
+  if (_trackOutput)
+    {
+      _scrollCount -= _screen->scrolledLines ();
+      _currentLine =
+	qMax (0,
+	      _screen->getHistLines () - (windowLines () -
+					  _screen->getLines ()));
+    }
+  else
+    {
+      // if the history is not unlimited then it may 
+      // have run out of space and dropped the oldest
+      // lines of output - in this case the screen
+      // window's current line number will need to 
+      // be adjusted - otherwise the output will scroll
+      _currentLine = qMax (0, _currentLine - _screen->droppedLines ());
+
+      // ensure that the screen window's current position does
+      // not go beyond the bottom of the screen
+      _currentLine = qMin (_currentLine, _screen->getHistLines ());
+    }
+
+  _bufferNeedsUpdate = true;
+
+  emit outputChanged ();
+}
diff --git a/gui/src/terminal/ScreenWindow.h b/gui/src/terminal/ScreenWindow.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/ScreenWindow.h
@@ -0,0 +1,249 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SCREENWINDOW_H
+#define SCREENWINDOW_H
+
+// Qt
+#include <QtCore/QObject>
+#include <QtCore/QPoint>
+#include <QtCore/QRect>
+
+// Konsole
+#include "Character.h"
+
+class Screen;
+
+/**
+ * Provides a window onto a section of a terminal screen.
+ * This window can then be rendered by a terminal display widget ( TerminalDisplay ).
+ *
+ * To use the screen window, create a new ScreenWindow() instance and associated it with 
+ * a terminal screen using setScreen().
+ * Use the scrollTo() method to scroll the window up and down on the screen.
+ * Call the getImage() method to retrieve the character image which is currently visible in the window.
+ *
+ * setTrackOutput() controls whether the window moves to the bottom of the associated screen when new
+ * lines are added to it.
+ *
+ * Whenever the output from the underlying screen is changed, the notifyOutputChanged() slot should
+ * be called.  This in turn will update the window's position and emit the outputChanged() signal
+ * if necessary.
+ */
+class ScreenWindow:public QObject
+{
+Q_OBJECT public:
+    /** 
+     * Constructs a new screen window with the given parent.
+     * A screen must be specified by calling setScreen() before calling getImage() or getLineProperties().
+     *
+     * You should not call this constructor directly, instead use the Emulation::createWindow() method
+     * to create a window on the emulation which you wish to view.  This allows the emulation
+     * to notify the window when the associated screen has changed and synchronize selection updates
+     * between all views on a session.
+     */
+  ScreenWindow (QObject * parent = 0);
+  virtual ~ ScreenWindow ();
+
+    /** Sets the screen which this window looks onto */
+  void setScreen (Screen * screen);
+    /** Returns the screen which this window looks onto */
+  Screen *screen () const;
+
+    /** 
+     * Returns the image of characters which are currently visible through this window
+     * onto the screen.
+     *
+     * The buffer is managed by the ScreenWindow instance and does not need to be
+     * deleted by the caller.
+     */
+  Character *getImage ();
+
+    /**
+     * Returns the line attributes associated with the lines of characters which
+     * are currently visible through this window
+     */
+    QVector < LineProperty > getLineProperties ();
+
+    /**
+     * Returns the number of lines which the region of the window
+     * specified by scrollRegion() has been scrolled by since the last call 
+     * to resetScrollCount().  scrollRegion() is in most cases the 
+     * whole window, but will be a smaller area in, for example, applications
+     * which provide split-screen facilities.
+     *
+     * This is not guaranteed to be accurate, but allows views to optimise
+     * rendering by reducing the amount of costly text rendering that
+     * needs to be done when the output is scrolled. 
+     */
+  int scrollCount () const;
+
+    /**
+     * Resets the count of scrolled lines returned by scrollCount()
+     */
+  void resetScrollCount ();
+
+    /**
+     * Returns the area of the window which was last scrolled, this is 
+     * usually the whole window area.
+     *
+     * Like scrollCount(), this is not guaranteed to be accurate,
+     * but allows views to optimise rendering.
+     */
+  QRect scrollRegion () const;
+
+    /** 
+     * Sets the start of the selection to the given @p line and @p column within 
+     * the window.
+     */
+  void setSelectionStart (int column, int line, bool columnMode);
+    /**
+     * Sets the end of the selection to the given @p line and @p column within
+     * the window.
+     */
+  void setSelectionEnd (int column, int line);
+    /**
+     * Retrieves the start of the selection within the window.
+     */
+  void getSelectionStart (int &column, int &line);
+    /**
+     * Retrieves the end of the selection within the window.
+     */
+  void getSelectionEnd (int &column, int &line);
+    /**
+     * Returns true if the character at @p line , @p column is part of the selection.
+     */
+  bool isSelected (int column, int line);
+    /** 
+     * Clears the current selection
+     */
+  void clearSelection ();
+
+	/** Sets the number of lines in the window */
+  void setWindowLines (int lines);
+    /** Returns the number of lines in the window */
+  int windowLines () const;
+    /** Returns the number of columns in the window */
+  int windowColumns () const;
+
+    /** Returns the total number of lines in the screen */
+  int lineCount () const;
+    /** Returns the total number of columns in the screen */
+  int columnCount () const;
+
+    /** Returns the index of the line which is currently at the top of this window */
+  int currentLine () const;
+
+    /** 
+     * Returns the position of the cursor 
+     * within the window.
+     */
+  QPoint cursorPosition () const;
+
+    /** 
+     * Convenience method. Returns true if the window is currently at the bottom
+     * of the screen.
+     */
+  bool atEndOfOutput () const;
+
+    /** Scrolls the window so that @p line is at the top of the window */
+  void scrollTo (int line);
+
+  enum RelativeScrollMode
+  {
+    ScrollLines,
+    ScrollPages
+  };
+
+    /** 
+     * Scrolls the window relative to its current position on the screen.
+     *
+     * @param mode Specifies whether @p amount refers to the number of lines or the number
+     * of pages to scroll.    
+     * @param amount The number of lines or pages ( depending on @p mode ) to scroll by.  If
+     * this number is positive, the view is scrolled down.  If this number is negative, the view
+     * is scrolled up.
+     */
+  void scrollBy (RelativeScrollMode mode, int amount);
+
+    /** 
+     * Specifies whether the window should automatically move to the bottom
+     * of the screen when new output is added.
+     *
+     * If this is set to true, the window will be moved to the bottom of the associated screen ( see 
+     * screen() ) when the notifyOutputChanged() method is called.
+     */
+  void setTrackOutput (bool trackOutput);
+    /** 
+     * Returns whether the window automatically moves to the bottom of the screen as
+     * new output is added.  See setTrackOutput()
+     */
+  bool trackOutput () const;
+
+    /**
+     * Returns the text which is currently selected.
+     *
+     * @param preserveLineBreaks See Screen::selectedText()
+     */
+  QString selectedText (bool preserveLineBreaks) const;
+
+  public slots:
+    /** 
+     * Notifies the window that the contents of the associated terminal screen have changed.
+     * This moves the window to the bottom of the screen if trackOutput() is true and causes
+     * the outputChanged() signal to be emitted.
+     */
+  void notifyOutputChanged ();
+
+    signals:
+    /**
+     * Emitted when the contents of the associated terminal screen ( see screen() ) changes. 
+     */
+  void outputChanged ();
+
+    /**
+     * Emitted when the screen window is scrolled to a different position.
+     * 
+     * @param line The line which is now at the top of the window.
+     */
+  void scrolled (int line);
+
+    /**
+     * Emitted when the selection is changed.
+     */
+  void selectionChanged ();
+
+private:
+  int endWindowLine () const;
+  void fillUnusedArea ();
+
+  Screen *_screen;		// see setScreen() , screen()
+  Character *_windowBuffer;
+  int _windowBufferSize;
+  bool _bufferNeedsUpdate;
+
+  int _windowLines;
+  int _currentLine;		// see scrollTo() , currentLine()
+  bool _trackOutput;		// see setTrackOutput() , trackOutput() 
+  int _scrollCount;		// count of lines which the window has been scrolled by since
+  // the last call to resetScrollCount()
+};
+#endif // SCREENWINDOW_H
diff --git a/gui/src/terminal/Session.cpp b/gui/src/terminal/Session.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Session.cpp
@@ -0,0 +1,1236 @@
+/*
+    This file is part of Konsole
+
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 2009 by Thomas Dreibholz <dreibh@iem.uni-due.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "Session.h"
+
+// Standard
+#include <assert.h>
+#include <stdlib.h>
+#include <signal.h>
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtCore/QByteRef>
+#include <QtCore/QDir>
+#include <QtCore/QFile>
+#include <QtCore/QRegExp>
+#include <QtCore/QStringList>
+#include <QtCore/QDate>
+
+#include "kprocess.h"
+#include "kptydevice.h"
+
+#include "Pty.h"
+#include "TerminalDisplay.h"
+#include "ShellCommand.h"
+#include "Vt102Emulation.h"
+
+int
+  Session::lastSessionId = 0;
+
+// HACK This is copied out of QUuid::createUuid with reseeding forced.
+// Required because color schemes repeatedly seed the RNG...
+// ...with a constant.
+QUuid
+createUuid ()
+{
+  static const int
+    intbits = sizeof (int) * 8;
+  static int
+    randbits = 0;
+  if (!randbits)
+    {
+      int
+	max = RAND_MAX;
+      do
+	{
+	  ++randbits;
+	}
+      while ((max = max >> 1));
+    }
+
+  qsrand (uint (QDateTime::currentDateTime ().toTime_t ()));
+  qrand ();			// Skip first
+
+  QUuid
+    result;
+  uint *
+    data = &(result.data1);
+  int
+    chunks = 16 / sizeof (uint);
+  while (chunks--)
+    {
+      uint
+	randNumber = 0;
+      for (int filled = 0; filled < intbits; filled += randbits)
+	randNumber |= qrand () << filled;
+      *(data + chunks) = randNumber;
+    }
+
+  result.data4[0] = (result.data4[0] & 0x3F) | 0x80;	// UV_DCE
+  result.data3 = (result.data3 & 0x0FFF) | 0x4000;	// UV_Random
+
+  return result;
+}
+
+Session::Session (QObject * parent):
+QObject (parent), _shellProcess (0), _emulation (0), _monitorActivity (false),
+_monitorSilence (false), _notifiedActivity (false), _autoClose (true),
+_wantedClose (false), _silenceSeconds (10), _addToUtmp (true),
+_flowControl (true), _fullScripting (false), _sessionId (0),
+/*_sessionProcessInfo (0), _foregroundProcessInfo (0),*/ _foregroundPid (0)
+  //, _zmodemBusy(false)
+  //, _zmodemProc(0)
+  //, _zmodemProgress(0)
+  , _hasDarkBackground (false)
+{
+  _uniqueIdentifier = createUuid ();
+
+  //prepare DBus communication
+  //new SessionAdaptor(this);
+  _sessionId = ++lastSessionId;
+
+  // JPS: commented out for lack of DBUS support by default on OSX
+  //QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
+
+  //create emulation backend
+  _emulation = new Vt102Emulation ();
+
+  connect (_emulation, SIGNAL (titleChanged (int, const QString &)),
+	   this, SLOT (setUserTitle (int, const QString &)));
+  connect (_emulation, SIGNAL (stateSet (int)),
+	   this, SLOT (activityStateSet (int)));
+  connect (_emulation, SIGNAL (changeTabTextColorRequest (int)),
+	   this, SIGNAL (changeTabTextColorRequest (int)));
+  connect (_emulation,
+	   SIGNAL (profileChangeCommandReceived (const QString &)), this,
+	   SIGNAL (profileChangeCommandReceived (const QString &)));
+  connect (_emulation, SIGNAL (flowControlKeyPressed (bool)), this,
+	   SLOT (updateFlowControlState (bool)));
+
+  //create new teletype for I/O with shell process
+  openTeletype (-1);
+
+  //setup timer for monitoring session activity
+  _monitorTimer = new QTimer (this);
+  _monitorTimer->setSingleShot (true);
+  connect (_monitorTimer, SIGNAL (timeout ()), this,
+	   SLOT (monitorTimerDone ()));
+}
+
+void
+Session::openTeletype (int fd)
+{
+  if (_shellProcess && isRunning ())
+    {
+      //kWarning() << "Attempted to open teletype in a running session.";
+      return;
+    }
+
+  delete _shellProcess;
+
+  if (fd < 0)
+    _shellProcess = new Pty ();
+  else
+    _shellProcess = new Pty (fd);
+
+  _shellProcess->setUtf8Mode (_emulation->utf8 ());
+
+  //connect teletype to emulation backend
+  connect (_shellProcess, SIGNAL (receivedData (const char *, int)), this,
+	   SLOT (onReceiveBlock (const char *, int)));
+  connect (_emulation, SIGNAL (sendData (const char *, int)), _shellProcess,
+	   SLOT (sendData (const char *, int)));
+  connect (_emulation, SIGNAL (useUtf8Request (bool)), _shellProcess,
+	   SLOT (setUtf8Mode (bool)));
+  connect (_shellProcess, SIGNAL (finished (int, QProcess::ExitStatus)), this,
+	   SLOT (done (int)));
+  connect (_emulation, SIGNAL (imageSizeChanged (int, int)), this,
+	   SLOT (updateWindowSize (int, int)));
+}
+
+WId
+Session::windowId () const
+{
+  // Returns a window ID for this session which is used
+  // to set the WINDOWID environment variable in the shell
+  // process.
+  //
+  // Sessions can have multiple views or no views, which means
+  // that a single ID is not always going to be accurate.
+  //
+  // If there are no views, the window ID is just 0.  If
+  // there are multiple views, then the window ID for the
+  // top-level window which contains the first view is
+  // returned
+
+  if (_views.count () == 0)
+    return 0;
+  else
+    {
+      QWidget *window = _views.first ();
+
+      Q_ASSERT (window);
+
+      while (window->parentWidget () != 0)
+	window = window->parentWidget ();
+
+      return window->winId ();
+    }
+}
+
+void
+Session::setDarkBackground (bool darkBackground)
+{
+  _hasDarkBackground = darkBackground;
+}
+
+bool
+Session::hasDarkBackground () const
+{
+  return _hasDarkBackground;
+}
+
+bool
+Session::isRunning () const
+{
+  return _shellProcess->state () == QProcess::Running;
+}
+
+void
+Session::setCodec (QTextCodec * codec)
+{
+  emulation ()->setCodec (codec);
+}
+
+bool
+Session::setCodec (QByteArray name)
+{
+  QTextCodec *codec = QTextCodec::codecForName (name);
+  if (codec)
+    {
+      setCodec (codec);
+      return true;
+    }
+  return false;
+}
+
+QByteArray
+Session::codec ()
+{
+  return _emulation->codec ()->name ();
+}
+
+void
+Session::setProgram (const QString & program)
+{
+  _program = ShellCommand::expand (program);
+}
+
+void
+Session::setInitialWorkingDirectory (const QString & dir)
+{
+  //_initialWorkingDir = KShell::tildeExpand(ShellCommand::expand(dir));
+  _initialWorkingDir = ShellCommand::expand (dir);
+}
+
+void
+Session::setArguments (const QStringList & arguments)
+{
+  _arguments = ShellCommand::expand (arguments);
+}
+
+QList < TerminalDisplay * >Session::views () const
+{
+  return _views;
+}
+
+void
+Session::addView (TerminalDisplay * widget)
+{
+  Q_ASSERT (!_views.contains (widget));
+
+  _views.append (widget);
+
+  if (_emulation != 0)
+    {
+      // connect emulation - view signals and slots
+      connect (widget, SIGNAL (keyPressedSignal (QKeyEvent *)), _emulation,
+	       SLOT (sendKeyEvent (QKeyEvent *)));
+      connect (widget, SIGNAL (mouseSignal (int, int, int, int)), _emulation,
+	       SLOT (sendMouseEvent (int, int, int, int)));
+      connect (widget, SIGNAL (sendStringToEmu (const char *)), _emulation,
+	       SLOT (sendString (const char *)));
+
+      // allow emulation to notify view when the foreground process
+      // indicates whether or not it is interested in mouse signals
+      connect (_emulation, SIGNAL (programUsesMouseChanged (bool)), widget,
+	       SLOT (setUsesMouse (bool)));
+
+      widget->setUsesMouse (_emulation->programUsesMouse ());
+
+      widget->setScreenWindow (_emulation->createWindow ());
+    }
+
+  //connect view signals and slots
+  QObject::connect (widget, SIGNAL (changedContentSizeSignal (int, int)),
+		    this, SLOT (onViewSizeChange (int, int)));
+
+  QObject::connect (widget, SIGNAL (destroyed (QObject *)), this,
+		    SLOT (viewDestroyed (QObject *)));
+}
+
+void
+Session::viewDestroyed (QObject * view)
+{
+  TerminalDisplay *display = (TerminalDisplay *) view;
+
+  Q_ASSERT (_views.contains (display));
+
+  removeView (display);
+}
+
+void
+Session::removeView (TerminalDisplay * widget)
+{
+  _views.removeAll (widget);
+
+  disconnect (widget, 0, this, 0);
+
+  if (_emulation != 0)
+    {
+      // disconnect
+      //  - key presses signals from widget
+      //  - mouse activity signals from widget
+      //  - string sending signals from widget
+      //
+      //  ... and any other signals connected in addView()
+      disconnect (widget, 0, _emulation, 0);
+
+      // disconnect state change signals emitted by emulation
+      disconnect (_emulation, 0, widget, 0);
+    }
+
+  // close the session automatically when the last view is removed
+  if (_views.count () == 0)
+    {
+      close ();
+    }
+}
+
+QString
+Session::checkProgram (const QString & program) const
+{
+  // Upon a KPty error, there is no description on what that error was...
+  // Check to see if the given program is executable.
+  QString exec = QFile::encodeName (program);
+
+  if (exec.isEmpty ())
+    return QString ();
+
+  // if 'exec' is not specified, fall back to default shell.  if that 
+  // is not set then fall back to /bin/sh
+  if (exec.isEmpty ())
+    exec = qgetenv ("SHELL");
+  if (exec.isEmpty ())
+    exec = "/bin/sh";
+  return program;
+}
+
+void
+Session::terminalWarning (const QString & message)
+{
+  static const QByteArray warningText =
+    QByteArray ("@info:shell Alert the user with red color text");
+  QByteArray messageText = message.toLocal8Bit ();
+
+  static const char redPenOn[] = "\033[1m\033[31m";
+  static const char redPenOff[] = "\033[0m";
+
+  _emulation->receiveData (redPenOn, strlen (redPenOn));
+  _emulation->receiveData ("\n\r\n\r", 4);
+  _emulation->receiveData (warningText.constData (),
+			   strlen (warningText.constData ()));
+  _emulation->receiveData (messageText.constData (),
+			   strlen (messageText.constData ()));
+  _emulation->receiveData ("\n\r\n\r", 4);
+  _emulation->receiveData (redPenOff, strlen (redPenOff));
+}
+
+QString
+Session::shellSessionId () const
+{
+  QString friendlyUuid (_uniqueIdentifier.toString ());
+  friendlyUuid.remove ('-').remove ('{').remove ('}');
+
+  return friendlyUuid;
+}
+
+void
+Session::run ()
+{
+  //check that everything is in place to run the session
+  if (_program.isEmpty ())
+    {
+      //kWarning() << "Session::run() - program to run not set.";
+    }
+  if (_arguments.isEmpty ())
+    {
+      //kWarning() << "Session::run() - no command line arguments specified.";
+    }
+  if (_uniqueIdentifier.isNull ())
+    {
+      _uniqueIdentifier = createUuid ();
+    }
+
+  const int CHOICE_COUNT = 3;
+  QString programs[CHOICE_COUNT] = { _program, qgetenv ("SHELL"), "/bin/sh" };
+  QString exec;
+  int choice = 0;
+  while (choice < CHOICE_COUNT)
+    {
+      exec = checkProgram (programs[choice]);
+      if (exec.isEmpty ())
+	choice++;
+      else
+	break;
+    }
+
+  // if a program was specified via setProgram(), but it couldn't be found, print a warning
+  if (choice != 0 && choice < CHOICE_COUNT && !_program.isEmpty ())
+    {
+      QString msg;
+      QTextStream msgStream (&msg);
+      msgStream << "Could not find '" << _program << "', starting '" << exec
+	<< "' instead. Please check your profile settings.";
+      terminalWarning (msg);
+      //terminalWarning(i18n("Could not find '%1', starting '%2' instead.  Please check your profile settings.",_program.toLatin1().data(),exec.toLatin1().data())); 
+    }
+  // if none of the choices are available, print a warning
+  else if (choice == CHOICE_COUNT)
+    {
+      terminalWarning (QString
+		       ("Could not find an interactive shell to start."));
+      return;
+    }
+
+  // if no arguments are specified, fall back to program name
+  QStringList arguments = _arguments.join (QChar (' ')).isEmpty ()?
+    QStringList () << exec : _arguments;
+
+  // JPS: commented out for lack of DBUS support by default on OSX
+  QString dbusService = "";	//QDBusConnection::sessionBus().baseService();
+  if (!_initialWorkingDir.isEmpty ())
+    _shellProcess->setWorkingDirectory (_initialWorkingDir);
+  else
+    _shellProcess->setWorkingDirectory (QDir::homePath ());
+
+  _shellProcess->setFlowControlEnabled (_flowControl);
+  _shellProcess->setErase (_emulation->eraseChar ());
+
+  // this is not strictly accurate use of the COLORFGBG variable.  This does not
+  // tell the terminal exactly which colors are being used, but instead approximates
+  // the color scheme as "black on white" or "white on black" depending on whether
+  // the background color is deemed dark or not
+  QString backgroundColorHint =
+    _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
+  _environment << backgroundColorHint;
+  _environment << QString ("SHELL_SESSION_ID=%1").arg (shellSessionId ());
+
+  int result = _shellProcess->start (exec,
+				     arguments,
+				     _environment,
+				     windowId (),
+				     _addToUtmp,
+				     dbusService,
+				     (QLatin1String ("/Sessions/") +
+				      QString::number (_sessionId)));
+
+  if (result < 0)
+    {
+      QString msg;
+      QTextStream msgStream (&msg);
+      msgStream << QString ("Could not start program '") << exec <<
+	QString ("' with arguments '") << arguments.
+	join (" ") << QString ("'.");
+      terminalWarning (msg);
+      //      terminalWarning(i18n("Could not start program '%1' with arguments '%2'.", exec.toLatin1().data(), arguments.join(" ").toLatin1().data()));
+      return;
+    }
+
+  _shellProcess->setWriteable (false);	// We are reachable via kwrited.
+
+  emit started ();
+}
+
+void
+Session::setUserTitle (int what, const QString & caption)
+{
+  //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
+  bool modified = false;
+
+  if ((what == IconNameAndWindowTitle) || (what == WindowTitle))
+    {
+      if (_userTitle != caption)
+	{
+	  _userTitle = caption;
+	  modified = true;
+	}
+    }
+
+  if ((what == IconNameAndWindowTitle) || (what == IconName))
+    {
+      if (_iconText != caption)
+	{
+	  _iconText = caption;
+	  modified = true;
+	}
+    }
+
+  if (what == TextColor || what == BackgroundColor)
+    {
+      QString colorString = caption.section (';', 0, 0);
+      QColor color = QColor (colorString);
+      if (color.isValid ())
+	{
+	  if (what == TextColor)
+	    emit changeForegroundColorRequest (color);
+	  else
+	  emit changeBackgroundColorRequest (color);
+	}
+    }
+
+  if (what == SessionName)
+    {
+      if (_nameTitle != caption)
+	{
+	  setTitle (Session::NameRole, caption);
+	  return;
+	}
+    }
+
+  if (what == 31)
+    {
+      QString cwd = caption;
+      cwd = cwd.replace (QRegExp ("^~"), QDir::homePath ());
+      emit openUrlRequest (cwd);
+    }
+
+  // change icon via \033]32;Icon\007
+  if (what == 32)
+    {
+      if (_iconName != caption)
+	{
+	  _iconName = caption;
+
+	  modified = true;
+	}
+    }
+
+  if (what == ProfileChange)
+    {
+      emit profileChangeCommandReceived (caption);
+      return;
+    }
+
+  if (modified)
+    emit titleChanged ();
+}
+
+QString
+Session::userTitle () const
+{
+  return _userTitle;
+}
+
+void
+Session::setTabTitleFormat (TabTitleContext context, const QString & format)
+{
+  if (context == LocalTabTitle)
+    _localTabTitleFormat = format;
+  else if (context == RemoteTabTitle)
+    _remoteTabTitleFormat = format;
+}
+
+QString
+Session::tabTitleFormat (TabTitleContext context) const
+{
+  if (context == LocalTabTitle)
+    return _localTabTitleFormat;
+  else if (context == RemoteTabTitle)
+    return _remoteTabTitleFormat;
+
+  return QString ();
+}
+
+void
+Session::monitorTimerDone ()
+{
+  //FIXME: The idea here is that the notification popup will appear to tell the user than output from
+  //the terminal has stopped and the popup will disappear when the user activates the session.
+  //
+  //This breaks with the addition of multiple views of a session.  The popup should disappear
+  //when any of the views of the session becomes active
+
+
+  //FIXME: Make message text for this notification and the activity notification more descriptive.    
+  if (_monitorSilence)
+    {
+      //KNotification::event("Silence", i18n("Silence in session '%1'", _nameTitle)propagateSize, QPixmap(),
+      //                QApplication::activeWindow(),
+      //                KNotification::CloseWhenWidgetActivated);
+      emit stateChanged (NOTIFYSILENCE);
+    }
+  else
+    {
+      emit stateChanged (NOTIFYNORMAL);
+    }
+
+  _notifiedActivity = false;
+}
+
+void
+Session::updateFlowControlState (bool suspended)
+{
+  if (suspended)
+    {
+      if (flowControlEnabled ())
+	{
+	  foreach (TerminalDisplay * display, _views)
+	  {
+	    if (display->flowControlWarningEnabled ())
+	      display->outputSuspended (true);
+	  }
+	}
+    }
+  else
+    {
+      foreach (TerminalDisplay * display, _views)
+	display->outputSuspended (false);
+    }
+}
+
+void
+Session::activityStateSet (int state)
+{
+  if (state == NOTIFYBELL)
+    {
+      emit bellRequest (QString ("Bell in session '%1'").
+			arg (_nameTitle.toLatin1 ().data ()));
+    }
+  else if (state == NOTIFYACTIVITY)
+    {
+      if (_monitorSilence)
+	{
+	  _monitorTimer->start (_silenceSeconds * 1000);
+	}
+
+      if (_monitorActivity)
+	{
+	  //FIXME:  See comments in Session::monitorTimerDone()
+	  if (!_notifiedActivity)
+	    {
+	      //KNotification::event("Activity", i18n("Activity in session '%1'", _nameTitle), QPixmap(),
+	      //                QApplication::activeWindow(),
+	      //KNotification::CloseWhenWidgetActivated);
+	      _notifiedActivity = true;
+	    }
+	}
+    }
+
+  if (state == NOTIFYACTIVITY && !_monitorActivity)
+    state = NOTIFYNORMAL;
+  if (state == NOTIFYSILENCE && !_monitorSilence)
+    state = NOTIFYNORMAL;
+
+  emit stateChanged (state);
+}
+
+void
+Session::onViewSizeChange (int /*height */ , int /*width */ )
+{
+  updateTerminalSize ();
+}
+
+void
+Session::updateTerminalSize ()
+{
+  QListIterator < TerminalDisplay * >viewIter (_views);
+
+  int minLines = -1;
+  int minColumns = -1;
+
+  // minimum number of lines and columns that views require for
+  // their size to be taken into consideration ( to avoid problems
+  // with new view widgets which haven't yet been set to their correct size )
+  const int VIEW_LINES_THRESHOLD = 2;
+  const int VIEW_COLUMNS_THRESHOLD = 2;
+
+  //select largest number of lines and columns that will fit in all visible views
+  while (viewIter.hasNext ())
+    {
+      TerminalDisplay *view = viewIter.next ();
+      if (view->isHidden () == false &&
+	  view->lines () >= VIEW_LINES_THRESHOLD &&
+	  view->columns () >= VIEW_COLUMNS_THRESHOLD)
+	{
+	  minLines =
+	    (minLines == -1) ? view->lines () : qMin (minLines,
+						      view->lines ());
+	  minColumns =
+	    (minColumns == -1) ? view->columns () : qMin (minColumns,
+							  view->columns ());
+	  view->processFilters ();
+	}
+    }
+
+  // backend emulation must have a _terminal of at least 1 column x 1 line in size
+  if (minLines > 0 && minColumns > 0)
+    {
+      _emulation->setImageSize (minLines, minColumns);
+    }
+}
+
+void
+Session::updateWindowSize (int lines, int columns)
+{
+  Q_ASSERT (lines > 0 && columns > 0);
+  _shellProcess->setWindowSize (lines, columns);
+}
+
+void
+Session::refresh ()
+{
+  // attempt to get the shell process to redraw the display
+  //
+  // this requires the program running in the shell
+  // to cooperate by sending an update in response to
+  // a window size change
+  //
+  // the window size is changed twice, first made slightly larger and then
+  // resized back to its normal size so that there is actually a change
+  // in the window size (some shells do nothing if the
+  // new and old sizes are the same)
+  //
+  // if there is a more 'correct' way to do this, please
+  // send an email with method or patches to konsole-devel@kde.org
+
+  const QSize existingSize = _shellProcess->windowSize ();
+  _shellProcess->setWindowSize (existingSize.height (),
+				existingSize.width () + 1);
+  _shellProcess->setWindowSize (existingSize.height (),
+				existingSize.width ());
+}
+
+bool
+Session::kill (int signal)
+{
+  int result =::kill (_shellProcess->pid (), signal);
+
+  if (result == 0)
+    {
+      _shellProcess->waitForFinished ();
+      return true;
+    }
+  else
+    return false;
+}
+
+void
+Session::close ()
+{
+  _autoClose = true;
+  _wantedClose = true;
+
+  if (!isRunning () || !kill (SIGHUP))
+    {
+      if (isRunning ())
+	{
+	  //kWarning() << "Process" << _shellProcess->pid() << "did not respond to SIGHUP";
+
+	  // close the pty and wait to see if the process finishes.  If it does,
+	  // the done() slot will have been called so we can return.  Otherwise,
+	  // emit the finished() signal regardless
+	  _shellProcess->pty ()->close ();
+	  if (_shellProcess->waitForFinished (3000))
+	    return;
+
+	  //kWarning() << "Unable to kill process" << _shellProcess->pid();
+	}
+
+      // Forced close.
+      QTimer::singleShot (1, this, SIGNAL (finished ()));
+    }
+}
+
+void
+Session::sendText (const QString & text) const
+{
+  _emulation->sendText (text);
+}
+
+void
+Session::sendMouseEvent (int buttons, int column, int line, int eventType)
+{
+  _emulation->sendMouseEvent (buttons, column, line, eventType);
+}
+
+Session::~Session ()
+{
+  //if (_foregroundProcessInfo)
+  //  delete _foregroundProcessInfo;
+  //if (_sessionProcessInfo)
+  //  delete _sessionProcessInfo;
+  delete _emulation;
+  delete _shellProcess;
+  //delete _zmodemProc;
+}
+
+void
+Session::done (int exitStatus)
+{
+  if (!_autoClose)
+    {
+      _userTitle = QString ("@info:shell This session is done");
+      emit titleChanged ();
+      return;
+    }
+
+  QString message;
+  QTextStream msgStream (&message);
+  if (!_wantedClose || exitStatus != 0)
+    {
+      if (_shellProcess->exitStatus () == QProcess::NormalExit)
+	{
+	  msgStream << "Program '" << _program << "' exited with statis " <<
+	    exitStatus << ".";
+	  //message = i18n("Program '%1' exited with status %2.", _program.toLatin1().data(), exitStatus);
+
+	}
+      else
+	{
+	  msgStream << "Program '" << _program << "' crashed.";
+	  //message = i18n("Program '%1' crashed.", _program.toLatin1().data());
+
+	}
+
+      //FIXME: See comments in Session::monitorTimerDone()
+      //KNotification::event("Finished", message , QPixmap(),
+      //                     QApplication::activeWindow(),
+      //                     KNotification::CloseWhenWidgetActivated);
+    }
+
+  if (!_wantedClose && _shellProcess->exitStatus () != QProcess::NormalExit)
+    terminalWarning (message);
+  else
+    emit finished ();
+}
+
+Emulation *
+Session::emulation () const
+{
+  return _emulation;
+}
+
+QString
+Session::keyBindings () const
+{
+  return _emulation->keyBindings ();
+}
+
+QStringList
+Session::environment () const
+{
+  return _environment;
+}
+
+void
+Session::setEnvironment (const QStringList & environment)
+{
+  _environment = environment;
+}
+
+int
+Session::sessionId () const
+{
+  return _sessionId;
+}
+
+void
+Session::setKeyBindings (const QString & id)
+{
+  _emulation->setKeyBindings (id);
+}
+
+void
+Session::setTitle (TitleRole role, const QString & newTitle)
+{
+  if (title (role) != newTitle)
+    {
+      if (role == NameRole)
+	_nameTitle = newTitle;
+      else if (role == DisplayedTitleRole)
+	_displayTitle = newTitle;
+
+      emit titleChanged ();
+    }
+}
+
+QString
+Session::title (TitleRole role) const
+{
+  if (role == NameRole)
+    return _nameTitle;
+  else if (role == DisplayedTitleRole)
+    return _displayTitle;
+  else
+    return QString ();
+}
+
+void
+Session::setIconName (const QString & iconName)
+{
+  if (iconName != _iconName)
+    {
+      _iconName = iconName;
+      emit titleChanged ();
+    }
+}
+
+void
+Session::setIconText (const QString & iconText)
+{
+  _iconText = iconText;
+}
+
+QString
+Session::iconName () const
+{
+  return _iconName;
+}
+
+QString
+Session::iconText () const
+{
+  return _iconText;
+}
+
+void
+Session::setHistoryType (const HistoryType & hType)
+{
+  _emulation->setHistory (hType);
+}
+
+const HistoryType &
+Session::historyType () const
+{
+  return _emulation->history ();
+}
+
+void
+Session::clearHistory ()
+{
+  _emulation->clearHistory ();
+}
+
+QStringList
+Session::arguments () const
+{
+  return _arguments;
+}
+
+QString
+Session::program () const
+{
+  return _program;
+}
+
+// unused currently
+bool
+Session::isMonitorActivity () const
+{
+  return _monitorActivity;
+}
+
+// unused currently
+bool
+Session::isMonitorSilence () const
+{
+  return _monitorSilence;
+}
+
+void
+Session::setMonitorActivity (bool _monitor)
+{
+  _monitorActivity = _monitor;
+  _notifiedActivity = false;
+
+  activityStateSet (NOTIFYNORMAL);
+}
+
+void
+Session::setMonitorSilence (bool _monitor)
+{
+  if (_monitorSilence == _monitor)
+    return;
+
+  _monitorSilence = _monitor;
+  if (_monitorSilence)
+    {
+      _monitorTimer->start (_silenceSeconds * 1000);
+    }
+  else
+    _monitorTimer->stop ();
+
+  activityStateSet (NOTIFYNORMAL);
+}
+
+void
+Session::setMonitorSilenceSeconds (int seconds)
+{
+  _silenceSeconds = seconds;
+  if (_monitorSilence)
+    {
+      _monitorTimer->start (_silenceSeconds * 1000);
+    }
+}
+
+void
+Session::setAddToUtmp (bool set)
+{
+  _addToUtmp = set;
+}
+
+void
+Session::setFlowControlEnabled (bool enabled)
+{
+  _flowControl = enabled;
+
+  if (_shellProcess)
+    _shellProcess->setFlowControlEnabled (_flowControl);
+  emit flowControlEnabledChanged (enabled);
+}
+
+bool
+Session::flowControlEnabled () const
+{
+  if (_shellProcess)
+    return _shellProcess->flowControlEnabled ();
+  else
+    return _flowControl;
+}
+
+void
+Session::onReceiveBlock (const char *buf, int len)
+{
+  _emulation->receiveData (buf, len);
+  emit receivedData (QString::fromLatin1 (buf, len));
+}
+
+QSize
+Session::size ()
+{
+  return _emulation->imageSize ();
+}
+
+void
+Session::setSize (const QSize & size)
+{
+  if ((size.width () <= 1) || (size.height () <= 1))
+    return;
+
+  emit resizeRequest (size);
+}
+
+int
+Session::processId () const
+{
+  return _shellProcess->pid ();
+}
+
+void
+Session::setTitle (int role, const QString & title)
+{
+  switch (role)
+    {
+    case (0):
+      this->setTitle (Session::NameRole, title);
+      break;
+    case (1):
+      this->setTitle (Session::DisplayedTitleRole, title);
+      break;
+    }
+}
+
+QString
+Session::title (int role) const
+{
+  switch (role)
+    {
+    case (0):
+      return this->title (Session::NameRole);
+    case (1):
+      return this->title (Session::DisplayedTitleRole);
+    default:
+      return QString ();
+    }
+}
+
+void
+Session::setTabTitleFormat (int context, const QString & format)
+{
+  switch (context)
+    {
+    case (0):
+      this->setTabTitleFormat (Session::LocalTabTitle, format);
+      break;
+    case (1):
+      this->setTabTitleFormat (Session::RemoteTabTitle, format);
+      break;
+    }
+}
+
+QString
+Session::tabTitleFormat (int context) const
+{
+  switch (context)
+    {
+    case (0):
+      return this->tabTitleFormat (Session::LocalTabTitle);
+    case (1):
+      return this->tabTitleFormat (Session::RemoteTabTitle);
+    default:
+      return QString ();
+    }
+}
+
+SessionGroup::SessionGroup (QObject * parent):QObject (parent), _masterMode (0)
+{
+}
+
+SessionGroup::~SessionGroup ()
+{
+}
+
+int
+SessionGroup::masterMode () const
+{
+  return _masterMode;
+}
+
+QList < Session * >SessionGroup::sessions () const
+{
+  return _sessions.keys ();
+}
+
+bool
+SessionGroup::masterStatus (Session * session) const
+{
+  return _sessions[session];
+}
+
+void
+SessionGroup::addSession (Session * session)
+{
+  connect (session, SIGNAL (finished ()), this, SLOT (sessionFinished ()));
+  _sessions.insert (session, false);
+}
+
+void
+SessionGroup::removeSession (Session * session)
+{
+  disconnect (session, SIGNAL (finished ()), this, SLOT (sessionFinished ()));
+  setMasterStatus (session, false);
+  _sessions.remove (session);
+}
+
+void
+SessionGroup::sessionFinished ()
+{
+  Session *session = qobject_cast < Session * >(sender ());
+  Q_ASSERT (session);
+  removeSession (session);
+}
+
+void
+SessionGroup::setMasterMode (int mode)
+{
+  _masterMode = mode;
+}
+
+QList < Session * >SessionGroup::masters () const
+{
+  return _sessions.keys (true);
+}
+
+void
+SessionGroup::setMasterStatus (Session * session, bool master)
+{
+  const bool wasMaster = _sessions[session];
+
+  if (wasMaster == master)
+    {
+      // No status change -> nothing to do.
+      return;
+    }
+  _sessions[session] = master;
+
+  if (master)
+    {
+      connect (session->emulation (), SIGNAL (sendData (const char *, int)),
+	       this, SLOT (forwardData (const char *, int)));
+    }
+  else
+    {
+      disconnect (session->emulation (),
+		  SIGNAL (sendData (const char *, int)), this,
+		  SLOT (forwardData (const char *, int)));
+    }
+}
+
+void
+SessionGroup::forwardData (const char *data, int size)
+{
+  static bool _inForwardData = false;
+  if (_inForwardData)
+    {				// Avoid recursive calls among session groups!
+      // A recursive call happens when a master in group A calls forwardData()
+      // in group B. If one of the destination sessions in group B is also a
+      // master of a group including the master session of group A, this would
+      // again call forwardData() in group A, and so on.
+      return;
+    }
+
+  _inForwardData = true;
+  QListIterator < Session * >iter (_sessions.keys ());
+  while (iter.hasNext ())
+    {
+      Session *other = iter.next ();
+      if (!_sessions[other])
+	{
+	  other->emulation ()->sendString (data, size);
+	}
+    }
+  _inForwardData = false;
+}
diff --git a/gui/src/terminal/Session.h b/gui/src/terminal/Session.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Session.h
@@ -0,0 +1,744 @@
+/*
+    This file is part of Konsole, an X terminal.
+
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 2009 by Thomas Dreibholz <dreibh@iem.uni-due.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SESSION_H
+#define SESSION_H
+
+// Qt
+#include <QtCore/QStringList>
+#include <QtCore/QByteRef>
+#include <QtCore/QSize>
+#include <QUuid>
+#include <QWidget>
+
+// Konsole
+#include "History.h"
+
+class KProcess;
+class KUrl;
+class Emulation;
+class Pty;
+class TerminalDisplay;
+  //class ZModemDialog;
+/**
+ * Represents a terminal session consisting of a pseudo-teletype and a terminal emulation.
+ * The pseudo-teletype (or PTY) handles I/O between the terminal process and Konsole.
+ * The terminal emulation ( Emulation and subclasses ) processes the output stream from the
+ * PTY and produces a character image which is then shown on views connected to the session.
+ *
+ * Each Session can be connected to one or more views by using the addView() method.
+ * The attached views can then display output from the program running in the terminal
+ * or send input to the program in the terminal in the form of keypresses and mouse
+ * activity.
+ */
+class Session:public QObject
+{
+Q_OBJECT Q_CLASSINFO ("D-Bus Interface", "org.kde.konsole.Session") public:
+  Q_PROPERTY (QString name READ nameTitle)
+    Q_PROPERTY (int processId READ processId)
+    Q_PROPERTY (QString keyBindings READ keyBindings WRITE setKeyBindings)
+    Q_PROPERTY (QSize size READ size WRITE setSize)
+  /**
+   * Constructs a new session.
+   *
+   * To start the terminal process, call the run() method,
+   * after specifying the program and arguments
+   * using setProgram() and setArguments()
+   *
+   * If no program or arguments are specified explicitly, the Session
+   * falls back to using the program specified in the SHELL environment
+   * variable.
+   */
+  explicit Session (QObject * parent = 0);
+   ~Session ();
+
+  /** 
+   * Connect to an existing terminal.  When a new Session() is constructed it 
+   * automatically searches for and opens a new teletype.  If you want to 
+   * use an existing teletype (given its file descriptor) call this after
+   * constructing the session.
+   *
+   * Calling openTeletype() while a session is running has no effect.
+   *
+   * @param masterFd The file descriptor of the pseudo-teletype master (See KPtyProcess::KPtyProcess())
+   */
+  void openTeletype (int masterFd);
+
+  /**
+   * Returns true if the session is currently running.  This will be true
+   * after run() has been called successfully.
+   */
+  bool isRunning () const;
+
+  /**
+   * Adds a new view for this session.
+   *
+   * The viewing widget will display the output from the terminal and
+   * input from the viewing widget (key presses, mouse activity etc.)
+   * will be sent to the terminal.
+   *
+   * Views can be removed using removeView().  The session is automatically
+   * closed when the last view is removed.
+   */
+  void addView (TerminalDisplay * widget);
+  /**
+   * Removes a view from this session.  When the last view is removed,
+   * the session will be closed automatically.
+   *
+   * @p widget will no longer display output from or send input
+   * to the terminal
+   */
+  void removeView (TerminalDisplay * widget);
+
+  /**
+   * Returns the views connected to this session
+   */
+    QList < TerminalDisplay * >views () const;
+
+  /**
+   * Returns the terminal emulation instance being used to encode / decode
+   * characters to / from the process.
+   */
+  Emulation *emulation () const;
+
+  /** Returns the unique ID for this session. */
+  int sessionId () const;
+
+  /**
+   * This enum describes the contexts for which separate
+   * tab title formats may be specified.
+   */
+  enum TabTitleContext
+  {
+    /** Default tab title format */
+    LocalTabTitle,
+    /**
+     * Tab title format used session currently contains
+     * a connection to a remote computer (via SSH)
+     */
+    RemoteTabTitle
+  };
+
+  /**
+   * Returns true if the session currently contains a connection to a 
+   * remote computer.  It currently supports ssh.
+   */
+  bool isRemote ();
+
+  /**
+   * Sets the format used by this session for tab titles.
+   *
+   * @param context The context whoose format should be set.
+   * @param format The tab title format.  This may be a mixture
+   * of plain text and dynamic elements denoted by a '%' character
+   * followed by a letter.  (eg. %d for directory).  The dynamic
+   * elements available depend on the @p context
+   */
+  void setTabTitleFormat (TabTitleContext context, const QString & format);
+  /** Returns the format used by this session for tab titles. */
+  QString tabTitleFormat (TabTitleContext context) const;
+
+
+  /** Returns the arguments passed to the shell process when run() is called. */
+  QStringList arguments () const;
+  /** Returns the program name of the shell process started when run() is called. */
+  QString program () const;
+
+  /**
+   * Sets the command line arguments which the session's program will be passed when
+   * run() is called.
+   */
+  void setArguments (const QStringList & arguments);
+  /** Sets the program to be executed when run() is called. */
+  void setProgram (const QString & program);
+
+  /** Returns the session's current working directory. */
+  QString initialWorkingDirectory ()
+  {
+    return _initialWorkingDir;
+  }
+
+  /**
+   * Sets the initial working directory for the session when it is run
+   * This has no effect once the session has been started.
+   */
+  void setInitialWorkingDirectory (const QString & dir);
+
+  /**
+   * Returns the current directory of the foreground process in the session
+   */
+  //QString currentWorkingDirectory ();
+
+  /**
+   * Sets the type of history store used by this session.
+   * Lines of output produced by the terminal are added
+   * to the history store.  The type of history store
+   * used affects the number of lines which can be
+   * remembered before they are lost and the storage
+   * (in memory, on-disk etc.) used.
+   */
+  void setHistoryType (const HistoryType & type);
+  /**
+   * Returns the type of history store used by this session.
+   */
+  const HistoryType & historyType () const;
+  /**
+   * Clears the history store used by this session.
+   */
+  void clearHistory ();
+
+  /**
+   * Sets the key bindings used by this session.  The bindings
+   * specify how input key sequences are translated into
+   * the character stream which is sent to the terminal.
+   *
+   * @param id The name of the key bindings to use.  The
+   * names of available key bindings can be determined using the
+   * KeyboardTranslatorManager class.
+   */
+  void setKeyBindings (const QString & id);
+  /** Returns the name of the key bindings used by this session. */
+  QString keyBindings () const;
+
+  /**
+   * This enum describes the available title roles.
+   */
+  enum TitleRole
+  {
+      /** The name of the session. */
+    NameRole,
+      /** The title of the session which is displayed in tabs etc. */
+    DisplayedTitleRole
+  };
+
+  /**
+   * Return the session title set by the user (ie. the program running
+   * in the terminal), or an empty string if the user has not set a custom title
+   */
+  QString userTitle () const;
+
+  /** Convenience method used to read the name property.  Returns title(Session::NameRole). */
+  QString nameTitle () const
+  {
+    return title (Session::NameRole);
+  }
+  /** Returns a title generated from tab format and process information. */
+  QString getDynamicTitle ();
+
+  /** Sets the name of the icon associated with this session. */
+  void setIconName (const QString & iconName);
+  /** Returns the name of the icon associated with this session. */
+  QString iconName () const;
+
+  /** Return URL for the session. */
+  //KUrl getUrl();
+
+  /** Sets the text of the icon associated with this session. */
+  void setIconText (const QString & iconText);
+  /** Returns the text of the icon associated with this session. */
+  QString iconText () const;
+
+  /** Sets the session's title for the specified @p role to @p title. */
+  void setTitle (TitleRole role, const QString & title);
+
+  /** Returns the session's title for the specified @p role. */
+  QString title (TitleRole role) const;
+
+  /** 
+   * Specifies whether a utmp entry should be created for the pty used by this session.
+   * If true, KPty::login() is called when the session is started.
+   */
+  void setAddToUtmp (bool);
+
+  /**
+   * Specifies whether to close the session automatically when the terminal
+   * process terminates.
+   */
+  void setAutoClose (bool b)
+  {
+    _autoClose = b;
+  }
+
+  /** Returns true if the user has started a program in the session. */
+  bool isForegroundProcessActive ();
+
+  /** Returns the name of the current foreground process. */
+  //QString foregroundProcessName ();
+
+  /** Returns the terminal session's window size in lines and columns. */
+  QSize size ();
+  /**
+   * Emits a request to resize the session to accommodate
+   * the specified window size.
+   *
+   * @param size The size in lines and columns to request.
+   */
+  void setSize (const QSize & size);
+
+  /**
+   * Sets whether the session has a dark background or not.  The session
+   * uses this information to set the COLORFGBG variable in the process's
+   * environment, which allows the programs running in the terminal to determine
+   * whether the background is light or dark and use appropriate colors by default.
+   *
+   * This has no effect once the session is running.
+   */
+  void setDarkBackground (bool darkBackground);
+  /**
+   * Returns true if the session has a dark background.
+   * See setDarkBackground()
+   */
+  bool hasDarkBackground () const;
+
+  /**
+   * Attempts to get the shell program to redraw the current display area.
+   * This can be used after clearing the screen, for example, to get the
+   * shell to redraw the prompt line.
+   */
+  void refresh ();
+
+  //  void startZModem(const QString &rz, const QString &dir, const QStringList &list);
+  //  void cancelZModem();
+  //  bool isZModemBusy() { return _zmodemBusy; }
+
+ /** 
+   * Possible values of the @p what parameter for setUserTitle()
+   * See "Operating System Controls" section on http://rtfm.etla.org/xterm/ctlseq.html 
+   */
+  enum UserTitleChange
+  {
+    IconNameAndWindowTitle = 0,
+    IconName = 1,
+    WindowTitle = 2,
+    TextColor = 10,
+    BackgroundColor = 11,
+    SessionName = 30,
+    ProfileChange = 50		// this clashes with Xterm's font change command
+  };
+
+  // Sets the text codec used by this sessions terminal emulation.
+  void setCodec (QTextCodec * codec);
+
+  // session management
+  //void saveSession(KConfigGroup& group);
+  //void restoreSession(KConfigGroup& group);
+
+  public slots:
+  /**
+   * Starts the terminal session.
+   *
+   * This creates the terminal process and connects the teletype to it.
+   */
+  void run ();
+
+  /**
+   * Returns the environment of this session as a list of strings like
+   * VARIABLE=VALUE
+   */
+  Q_SCRIPTABLE QStringList environment () const;
+
+  /**
+   * Sets the environment for this session.
+   * @p environment should be a list of strings like
+   * VARIABLE=VALUE
+   */
+  Q_SCRIPTABLE void setEnvironment (const QStringList & environment);
+
+  /**
+   * Closes the terminal session.  This sends a hangup signal
+   * (SIGHUP) to the terminal process and causes the finished()  
+   * signal to be emitted.  If the process does not respond to the SIGHUP signal
+   * then the terminal connection (the pty) is closed and Konsole waits for the 
+   * process to exit.
+   */
+  Q_SCRIPTABLE void close ();
+
+  /**
+   * Changes the session title or other customizable aspects of the terminal
+   * emulation display. For a list of what may be changed see the
+   * Emulation::titleChanged() signal.
+   *
+   * @param what The feature being changed.  Value is one of UserTitleChange
+   * @param caption The text part of the terminal command
+   */
+  void setUserTitle (int what, const QString & caption);
+
+  /**
+   * Enables monitoring for activity in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYACTIVITY state flag when output is
+   * received from the terminal.
+   */
+  Q_SCRIPTABLE void setMonitorActivity (bool);
+
+  /** Returns true if monitoring for activity is enabled. */
+  Q_SCRIPTABLE bool isMonitorActivity () const;
+
+  /**
+   * Enables monitoring for silence in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYSILENCE state flag when output is not
+   * received from the terminal for a certain period of
+   * time, specified with setMonitorSilenceSeconds()
+   */
+  Q_SCRIPTABLE void setMonitorSilence (bool);
+
+  /**
+   * Returns true if monitoring for inactivity (silence)
+   * in the session is enabled.
+   */
+  Q_SCRIPTABLE bool isMonitorSilence () const;
+
+  /** See setMonitorSilence() */
+  Q_SCRIPTABLE void setMonitorSilenceSeconds (int seconds);
+
+  /**
+   * Sets whether flow control is enabled for this terminal
+   * session.
+   */
+  Q_SCRIPTABLE void setFlowControlEnabled (bool enabled);
+
+  /** Returns whether flow control is enabled for this terminal session. */
+  Q_SCRIPTABLE bool flowControlEnabled () const;
+
+  /**
+   * Sends @p text to the current foreground terminal program.
+   */
+  Q_SCRIPTABLE void sendText (const QString & text) const;
+
+   /**
+    * Sends a mouse event of type @p eventType emitted by button
+    * @p buttons on @p column/@p line to the current foreground
+    * terminal program
+    */
+  Q_SCRIPTABLE void sendMouseEvent (int buttons, int column, int line,
+				    int eventType);
+
+   /**
+   * Returns the process id of the terminal process.
+   * This is the id used by the system API to refer to the process.
+   */
+  Q_SCRIPTABLE int processId () const;
+
+  /**
+   * Returns the process id of the terminal's foreground process.
+   * This is initially the same as processId() but can change
+   * as the user starts other programs inside the terminal.
+   */
+  //Q_SCRIPTABLE int foregroundProcessId ();
+
+  /** Sets the text codec used by this sessions terminal emulation.
+    * Overloaded to accept a QByteArray for convenience since DBus
+    * does not accept QTextCodec directky.
+    */
+  Q_SCRIPTABLE bool setCodec (QByteArray codec);
+
+  /** Returns the codec used to decode incoming characters in this
+   * terminal emulation
+   */
+  Q_SCRIPTABLE QByteArray codec ();
+
+  /** Sets the session's title for the specified @p role to @p title.
+   *  This is an overloaded member function for setTitle(TitleRole, QString)
+   *  provided for convenience since enum data types may not be
+   *  exported directly through DBus
+   */
+  Q_SCRIPTABLE void setTitle (int role, const QString & title);
+
+  /** Returns the session's title for the specified @p role.
+   * This is an overloaded member function for  setTitle(TitleRole)
+   * provided for convenience since enum data types may not be
+   * exported directly through DBus
+   */
+  Q_SCRIPTABLE QString title (int role) const;
+
+  /** Returns the "friendly" version of the QUuid of this session.
+  * This is a QUuid with the braces and dashes removed, so it cannot be
+  * used to construct a new QUuid. The same text appears in the
+  * SHELL_SESSION_ID environment variable.
+  */
+  Q_SCRIPTABLE QString shellSessionId () const;
+
+  /** Sets the session's tab title format for the specified @p context to @p format.
+   *  This is an overloaded member function for setTabTitleFormat(TabTitleContext, QString)
+   *  provided for convenience since enum data types may not be
+   *  exported directly through DBus
+   */
+  Q_SCRIPTABLE void setTabTitleFormat (int context, const QString & format);
+
+  /** Returns the session's tab title format for the specified @p context.
+   * This is an overloaded member function for tabTitleFormat(TitleRole)
+   * provided for convenience since enum data types may not be
+   * exported directly through DBus
+   */
+  Q_SCRIPTABLE QString tabTitleFormat (int context) const;
+
+signals:
+
+  /** Emitted when the terminal process starts. */
+  void started ();
+
+  /**
+   * Emitted when the terminal process exits.
+   */
+  void finished ();
+
+  /**
+   * Emitted when output is received from the terminal process.
+   */
+  void receivedData (const QString & text);
+
+  /** Emitted when the session's title has changed. */
+  void titleChanged ();
+
+  /**
+   * Emitted when the activity state of this session changes.
+   *
+   * @param state The new state of the session.  This may be one
+   * of NOTIFYNORMAL, NOTIFYSILENCE or NOTIFYACTIVITY
+   */
+  void stateChanged (int state);
+
+  /** Emitted when a bell event occurs in the session. */
+  void bellRequest (const QString & message);
+
+  /**
+   * Requests that the color the text for any tabs associated with
+   * this session should be changed;
+   *
+   * TODO: Document what the parameter does
+   */
+  void changeTabTextColorRequest (int);
+
+  /**
+   * Requests that the background color of views on this session
+   * should be changed.
+   */
+  void changeBackgroundColorRequest (const QColor &);
+  /** 
+   * Requests that the text color of views on this session should
+   * be changed to @p color.
+   */
+  void changeForegroundColorRequest (const QColor &);
+
+  /** TODO: Document me. */
+  void openUrlRequest (const QString & url);
+
+
+  /**
+   * Emitted when the terminal process requests a change
+   * in the size of the terminal window.
+   *
+   * @param size The requested window size in terms of lines and columns.
+   */
+  void resizeRequest (const QSize & size);
+
+  /**
+   * Emitted when a profile change command is received from the terminal.
+   *
+   * @param text The text of the command.  This is a string of the form
+   * "PropertyName=Value;PropertyName=Value ..."
+   */
+  void profileChangeCommandReceived (const QString & text);
+
+ /**
+  * Emitted when the flow control state changes.
+  *
+  * @param enabled True if flow control is enabled or false otherwise.
+  */
+  void flowControlEnabledChanged (bool enabled);
+
+  private slots:void done (int);
+
+  //  void fireZModemDetected();
+
+  void onReceiveBlock (const char *buffer, int len);
+  void monitorTimerDone ();
+
+  void onViewSizeChange (int height, int width);
+
+  void activityStateSet (int);
+
+  //automatically detach views from sessions when view is destroyed
+  void viewDestroyed (QObject * view);
+
+  //void zmodemReadStatus();
+  //void zmodemReadAndSendBlock();
+  //void zmodemRcvBlock(const char *data, int len);
+  //void zmodemFinished();
+
+  void updateFlowControlState (bool suspended);
+  void updateWindowSize (int lines, int columns);
+private:
+
+  void updateTerminalSize ();
+  WId windowId () const;
+  bool kill (int signal);
+  // print a warning message in the terminal.  This is used
+  // if the program fails to start, or if the shell exits in 
+  // an unsuccessful manner
+  void terminalWarning (const QString & message);
+  // checks that the binary 'program' is available and can be executed
+  // returns the binary name if available or an empty string otherwise
+  QString checkProgram (const QString & program) const;
+
+  QUuid _uniqueIdentifier;	// SHELL_SESSION_ID
+
+  Pty *_shellProcess;
+  Emulation *_emulation;
+
+  QList < TerminalDisplay * >_views;
+
+  bool _monitorActivity;
+  bool _monitorSilence;
+  bool _notifiedActivity;
+  bool _masterMode;
+  bool _autoClose;
+  bool _wantedClose;
+  QTimer *_monitorTimer;
+
+  int _silenceSeconds;
+
+  QString _nameTitle;
+  QString _displayTitle;
+  QString _userTitle;
+
+  QString _localTabTitleFormat;
+  QString _remoteTabTitleFormat;
+
+  QString _iconName;
+  QString _iconText;		// as set by: echo -en '\033]1;IconText\007
+  bool _addToUtmp;
+  bool _flowControl;
+  bool _fullScripting;
+
+  QString _program;
+  QStringList _arguments;
+
+  QStringList _environment;
+  int _sessionId;
+
+  QString _initialWorkingDir;
+  QString _currentWorkingDir;
+
+  int _foregroundPid;
+
+  // ZModem
+  //  bool           _zmodemBusy;
+  //  KProcess*      _zmodemProc;
+  //  ZModemDialog*  _zmodemProgress;
+
+  // Color/Font Changes by ESC Sequences
+
+  QColor _modifiedBackground;	// as set by: echo -en '\033]11;Color\007
+
+  QString _profileKey;
+
+  bool _hasDarkBackground;
+
+  static int lastSessionId;
+
+};
+
+/**
+ * Provides a group of sessions which is divided into master and slave sessions.
+ * Activity in master sessions can be propagated to all sessions within the group.
+ * The type of activity which is propagated and method of propagation is controlled
+ * by the masterMode() flags.
+ */
+class SessionGroup:public QObject
+{
+Q_OBJECT public:
+    /** Constructs an empty session group. */
+  SessionGroup (QObject * parent);
+    /** Destroys the session group and removes all connections between master and slave sessions. */
+  ~SessionGroup ();
+
+    /** Adds a session to the group. */
+  void addSession (Session * session);
+    /** Removes a session from the group. */
+  void removeSession (Session * session);
+
+    /** Returns the list of sessions currently in the group. */
+    QList < Session * >sessions () const;
+
+    /**
+     * Sets whether a particular session is a master within the group.
+     * Changes or activity in the group's master sessions may be propagated
+     * to all the sessions in the group, depending on the current masterMode()
+     *
+     * @param session The session whoose master status should be changed.
+     * @param master True to make this session a master or false otherwise
+     */
+  void setMasterStatus (Session * session, bool master);
+    /** Returns the master status of a session.  See setMasterStatus() */
+  bool masterStatus (Session * session) const;
+
+    /**
+     * This enum describes the options for propagating certain activity or
+     * changes in the group's master sessions to all sessions in the group.
+     */
+  enum MasterMode
+  {
+	/**
+         * Any input key presses in the master sessions are sent to all
+         * sessions in the group.
+         */
+    CopyInputToAll = 1
+  };
+
+    /**
+     * Specifies which activity in the group's master sessions is propagated
+     * to all sessions in the group.
+     *
+     * @param mode A bitwise OR of MasterMode flags.
+     */
+  void setMasterMode (int mode);
+    /**
+     * Returns a bitwise OR of the active MasterMode flags for this group.
+     * See setMasterMode()
+     */
+  int masterMode () const;
+
+  private slots:void sessionFinished ();
+  void forwardData (const char *data, int size);
+
+private:
+    QList < Session * >masters () const;
+
+  // maps sessions to their master status
+    QHash < Session *, bool > _sessions;
+
+  int _masterMode;
+};
+
+#endif
+
+/*
+  Local Variables:
+  mode: c++
+  c-file-style: "stroustrup"
+  indent-tabs-mode: nil
+  tab-width: 4
+  End:
+*/
diff --git a/gui/src/terminal/ShellCommand.cpp b/gui/src/terminal/ShellCommand.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/ShellCommand.cpp
@@ -0,0 +1,187 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "ShellCommand.h"
+
+//some versions of gcc(4.3) require explicit include
+#include <cstdlib>
+
+// expands environment variables in 'text'
+// function copied from kdelibs/kio/kio/kurlcompletion.cpp
+static bool expandEnv (QString & text);
+
+ShellCommand::ShellCommand (const QString & fullCommand)
+{
+  bool inQuotes = false;
+
+  QString builder;
+
+  for (int i = 0; i < fullCommand.count (); i++)
+    {
+      QChar ch = fullCommand[i];
+
+      const bool isLastChar = (i == fullCommand.count () - 1);
+      const bool isQuote = (ch == '\'' || ch == '\"');
+
+      if (!isLastChar && isQuote)
+	inQuotes = !inQuotes;
+      else
+	{
+	  if ((!ch.isSpace () || inQuotes) && !isQuote)
+	    builder.append (ch);
+
+	  if ((ch.isSpace () && !inQuotes) || (i == fullCommand.count () - 1))
+	    {
+	      _arguments << builder;
+	      builder.clear ();
+	    }
+	}
+    }
+}
+
+ShellCommand::ShellCommand (const QString & command,
+			    const QStringList & arguments)
+{
+  _arguments = arguments;
+
+  if (!_arguments.isEmpty ())
+    _arguments[0] == command;
+}
+
+QString
+ShellCommand::fullCommand () const
+{
+  return _arguments.join (QChar (' '));
+}
+
+QString
+ShellCommand::command () const
+{
+  if (!_arguments.isEmpty ())
+    return _arguments[0];
+  else
+    return QString ();
+}
+
+QStringList
+ShellCommand::arguments () const
+{
+  return _arguments;
+}
+
+bool
+ShellCommand::isRootCommand () const
+{
+  Q_ASSERT (0);			// not implemented yet
+  return false;
+}
+
+bool
+ShellCommand::isAvailable () const
+{
+  Q_ASSERT (0);			// not implemented yet
+  return false;
+}
+
+QStringList
+ShellCommand::expand (const QStringList & items)
+{
+  QStringList result;
+
+  foreach (QString item, items) result << expand (item);
+
+  return result;
+}
+
+QString
+ShellCommand::expand (const QString & text)
+{
+  QString result = text;
+  expandEnv (result);
+  return result;
+}
+
+/*
+ * expandEnv
+ *
+ * Expand environment variables in text. Escaped '$' characters are ignored.
+ * Return true if any variables were expanded
+ */
+static bool
+expandEnv (QString & text)
+{
+  // Find all environment variables beginning with '$'
+  //
+  int pos = 0;
+
+  bool expanded = false;
+
+  while ((pos = text.indexOf (QLatin1Char ('$'), pos)) != -1)
+    {
+
+      // Skip escaped '$'
+      //
+      if (pos > 0 && text.at (pos - 1) == QLatin1Char ('\\'))
+	{
+	  pos++;
+	}
+      // Variable found => expand
+      //
+      else
+	{
+	  // Find the end of the variable = next '/' or ' '
+	  //
+	  int pos2 = text.indexOf (QLatin1Char (' '), pos + 1);
+	  int pos_tmp = text.indexOf (QLatin1Char ('/'), pos + 1);
+
+	  if (pos2 == -1 || (pos_tmp != -1 && pos_tmp < pos2))
+	    pos2 = pos_tmp;
+
+	  if (pos2 == -1)
+	    pos2 = text.length ();
+
+	  // Replace if the variable is terminated by '/' or ' '
+	  // and defined
+	  //
+	  if (pos2 >= 0)
+	    {
+	      int len = pos2 - pos;
+	      QString key = text.mid (pos + 1, len - 1);
+	      QString value =
+		QString::fromLocal8Bit (::getenv (key.toLocal8Bit ()));
+
+	      if (!value.isEmpty ())
+		{
+		  expanded = true;
+		  text.replace (pos, len, value);
+		  pos = pos + value.length ();
+		}
+	      else
+		{
+		  pos = pos2;
+		}
+	    }
+	}
+    }
+
+  return expanded;
+}
diff --git a/gui/src/terminal/ShellCommand.h b/gui/src/terminal/ShellCommand.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/ShellCommand.h
@@ -0,0 +1,87 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SHELLCOMMAND_H
+#define SHELLCOMMAND_H
+
+// Qt
+#include <QtCore/QStringList>
+
+/** 
+ * A class to parse and extract information about shell commands. 
+ *
+ * ShellCommand can be used to:
+ *
+ * <ul>
+ *      <li>Take a command-line (eg "/bin/sh -c /path/to/my/script") and split it
+ *          into its component parts (eg. the command "/bin/sh" and the arguments
+ *          "-c","/path/to/my/script")
+ *      </li>
+ *      <li>Take a command and a list of arguments and combine them to 
+ *          form a complete command line.
+ *      </li>
+ *      <li>Determine whether the binary specified by a command exists in the
+ *          user's PATH.
+ *      </li>
+ *      <li>Determine whether a command-line specifies the execution of
+ *          another command as the root user using su/sudo etc.
+ *      </li>
+ * </ul> 
+ */
+class ShellCommand
+{
+public:
+    /**
+     * Constructs a ShellCommand from a command line.
+     *
+     * @param fullCommand The command line to parse.  
+     */
+  ShellCommand (const QString & fullCommand);
+    /**
+     * Constructs a ShellCommand with the specified @p command and @p arguments.
+     */
+  ShellCommand (const QString & command, const QStringList & arguments);
+
+    /** Returns the command. */
+  QString command () const;
+    /** Returns the arguments. */
+  QStringList arguments () const;
+
+    /** 
+     * Returns the full command line. 
+     */
+  QString fullCommand () const;
+
+    /** Returns true if this is a root command. */
+  bool isRootCommand () const;
+    /** Returns true if the program specified by @p command() exists. */
+  bool isAvailable () const;
+
+    /** Expands environment variables in @p text .*/
+  static QString expand (const QString & text);
+
+    /** Expands environment variables in each string in @p list. */
+  static QStringList expand (const QStringList & items);
+
+private:
+    QStringList _arguments;
+};
+#endif // SHELLCOMMAND_H
diff --git a/gui/src/terminal/TerminalCharacterDecoder.cpp b/gui/src/terminal/TerminalCharacterDecoder.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/TerminalCharacterDecoder.cpp
@@ -0,0 +1,267 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "TerminalCharacterDecoder.h"
+
+// Qt
+#include <QtCore/QTextStream>
+
+// Konsole
+#include "konsole_wcwidth.h"
+
+PlainTextDecoder::PlainTextDecoder ():_output (0), _includeTrailingWhitespace (true),
+_recordLinePositions (false)
+{
+
+}
+
+void
+PlainTextDecoder::setTrailingWhitespace (bool enable)
+{
+  _includeTrailingWhitespace = enable;
+}
+
+bool
+PlainTextDecoder::trailingWhitespace () const
+{
+  return _includeTrailingWhitespace;
+}
+
+void
+PlainTextDecoder::begin (QTextStream * output)
+{
+  _output = output;
+  if (!_linePositions.isEmpty ())
+    _linePositions.clear ();
+}
+
+void
+PlainTextDecoder::end ()
+{
+  _output = 0;
+}
+
+void
+PlainTextDecoder::setRecordLinePositions (bool record)
+{
+  _recordLinePositions = record;
+}
+
+QList < int >
+PlainTextDecoder::linePositions () const
+{
+  return _linePositions;
+}
+
+void
+PlainTextDecoder::decodeLine (const Character * const characters, int count, LineProperty	/*properties */
+  )
+{
+  Q_ASSERT (_output);
+
+  if (_recordLinePositions && _output->string ())
+    {
+      int pos = _output->string ()->count ();
+      _linePositions << pos;
+    }
+
+  //TODO should we ignore or respect the LINE_WRAPPED line property?
+
+  //note:  we build up a QString and send it to the text stream rather writing into the text
+  //stream a character at a time because it is more efficient.
+  //(since QTextStream always deals with QStrings internally anyway)
+  QString plainText;
+  plainText.reserve (count);
+
+  int outputCount = count;
+
+  // if inclusion of trailing whitespace is disabled then find the end of the
+  // line
+  if (!_includeTrailingWhitespace)
+    {
+      for (int i = count - 1; i >= 0; i--)
+	{
+	  if (characters[i].character != ' ')
+	    break;
+	  else
+	    outputCount--;
+	}
+    }
+
+  for (int i = 0; i < outputCount;)
+    {
+      plainText.append (QChar (characters[i].character));
+      i += qMax (1, konsole_wcwidth (characters[i].character));
+    }
+  *_output << plainText;
+}
+
+HTMLDecoder::HTMLDecoder ():
+_output (0), _colorTable (base_color_table), _innerSpanOpen (false),
+_lastRendition (DEFAULT_RENDITION)
+{
+
+}
+
+void
+HTMLDecoder::begin (QTextStream * output)
+{
+  _output = output;
+
+  QString text;
+
+  //open monospace span
+  openSpan (text, "font-family:monospace");
+
+  *output << text;
+}
+
+void
+HTMLDecoder::end ()
+{
+  Q_ASSERT (_output);
+
+  QString text;
+
+  closeSpan (text);
+
+  *_output << text;
+
+  _output = 0;
+
+}
+
+//TODO: Support for LineProperty (mainly double width , double height)
+void
+HTMLDecoder::decodeLine (const Character * const characters, int count, LineProperty	/*properties */
+  )
+{
+  Q_ASSERT (_output);
+
+  QString text;
+
+  int spaceCount = 0;
+
+  for (int i = 0; i < count; i++)
+    {
+      QChar ch (characters[i].character);
+
+      //check if appearance of character is different from previous char
+      if (characters[i].rendition != _lastRendition ||
+	  characters[i].foregroundColor != _lastForeColor ||
+	  characters[i].backgroundColor != _lastBackColor)
+	{
+	  if (_innerSpanOpen)
+	    closeSpan (text);
+
+	  _lastRendition = characters[i].rendition;
+	  _lastForeColor = characters[i].foregroundColor;
+	  _lastBackColor = characters[i].backgroundColor;
+
+	  //build up style string
+	  QString style;
+
+	  bool useBold;
+	  ColorEntry::FontWeight weight =
+	    characters[i].fontWeight (_colorTable);
+	  if (weight == ColorEntry::UseCurrentFormat)
+	    useBold = _lastRendition & RE_BOLD;
+	  else
+	    useBold = weight == ColorEntry::Bold;
+
+	  if (useBold)
+	    style.append ("font-weight:bold;");
+
+	  if (_lastRendition & RE_UNDERLINE)
+	    style.append ("font-decoration:underline;");
+
+	  //colours - a colour table must have been defined first
+	  if (_colorTable)
+	    {
+	      style.append (QString ("color:%1;").
+			    arg (_lastForeColor.color (_colorTable).name ()));
+
+	      if (!characters[i].isTransparent (_colorTable))
+		{
+		  style.append (QString ("background-color:%1;").
+				arg (_lastBackColor.color (_colorTable).
+				     name ()));
+		}
+	    }
+
+	  //open the span with the current style    
+	  openSpan (text, style);
+	  _innerSpanOpen = true;
+	}
+
+      //handle whitespace
+      if (ch.isSpace ())
+	spaceCount++;
+      else
+	spaceCount = 0;
+
+
+      //output current character
+      if (spaceCount < 2)
+	{
+	  //escape HTML tag characters and just display others as they are
+	  if (ch == '<')
+	    text.append ("&lt;");
+	  else if (ch == '>')
+	    text.append ("&gt;");
+	  else
+	    text.append (ch);
+	}
+      else
+	{
+	  text.append ("&nbsp;");	//HTML truncates multiple spaces, so use a space marker instead
+	}
+
+    }
+
+  //close any remaining open inner spans
+  if (_innerSpanOpen)
+    closeSpan (text);
+
+  //start new line
+  text.append ("<br>");
+
+  *_output << text;
+}
+
+void
+HTMLDecoder::openSpan (QString & text, const QString & style)
+{
+  text.append (QString ("<span style=\"%1\">").arg (style));
+}
+
+void
+HTMLDecoder::closeSpan (QString & text)
+{
+  text.append ("</span>");
+}
+
+void
+HTMLDecoder::setColorTable (const ColorEntry * table)
+{
+  _colorTable = table;
+}
diff --git a/gui/src/terminal/TerminalCharacterDecoder.h b/gui/src/terminal/TerminalCharacterDecoder.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/TerminalCharacterDecoder.h
@@ -0,0 +1,144 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef TERMINAL_CHARACTER_DECODER_H
+#define TERMINAL_CHARACTER_DECODER_H
+
+#include "Character.h"
+
+#include <QList>
+
+class QTextStream;
+
+/**
+ * Base class for terminal character decoders
+ *
+ * The decoder converts lines of terminal characters which consist of a unicode character, foreground
+ * and background colours and other appearance-related properties into text strings.
+ *
+ * Derived classes may produce either plain text with no other colour or appearance information, or
+ * they may produce text which incorporates these additional properties. 
+ */
+class TerminalCharacterDecoder
+{
+public:
+  virtual ~ TerminalCharacterDecoder ()
+  {
+  }
+
+    /** Begin decoding characters.  The resulting text is appended to @p output. */
+  virtual void begin (QTextStream * output) = 0;
+    /** End decoding. */
+  virtual void end () = 0;
+
+    /**
+     * Converts a line of terminal characters with associated properties into a text string
+     * and writes the string into an output QTextStream.
+     *
+     * @param characters An array of characters of length @p count.
+     * @param count The number of characters
+     * @param properties Additional properties which affect all characters in the line
+     */
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties) = 0;
+};
+
+/**
+ * A terminal character decoder which produces plain text, ignoring colours and other appearance-related
+ * properties of the original characters.
+ */
+class PlainTextDecoder:public TerminalCharacterDecoder
+{
+public:
+  PlainTextDecoder ();
+
+    /** 
+     * Set whether trailing whitespace at the end of lines should be included 
+     * in the output.
+     * Defaults to true.
+     */
+  void setTrailingWhitespace (bool enable);
+    /**
+     * Returns whether trailing whitespace at the end of lines is included
+     * in the output.
+     */
+  bool trailingWhitespace () const;
+    /** 
+     * Returns of character positions in the output stream
+     * at which new lines where added.  Returns an empty if setTrackLinePositions() is false or if 
+     * the output device is not a string.
+     */
+    QList < int >linePositions () const;
+    /** Enables recording of character positions at which new lines are added.  See linePositions() */
+  void setRecordLinePositions (bool record);
+
+  virtual void begin (QTextStream * output);
+  virtual void end ();
+
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties);
+
+
+private:
+    QTextStream * _output;
+  bool _includeTrailingWhitespace;
+
+  bool _recordLinePositions;
+    QList < int >_linePositions;
+};
+
+/**
+ * A terminal character decoder which produces pretty HTML markup
+ */
+class HTMLDecoder:public TerminalCharacterDecoder
+{
+public:
+    /** 
+     * Constructs an HTML decoder using a default black-on-white color scheme.
+     */
+  HTMLDecoder ();
+
+    /**
+     * Sets the colour table which the decoder uses to produce the HTML colour codes in its
+     * output
+     */
+  void setColorTable (const ColorEntry * table);
+
+  virtual void decodeLine (const Character * const characters,
+			   int count, LineProperty properties);
+
+  virtual void begin (QTextStream * output);
+  virtual void end ();
+
+private:
+  void openSpan (QString & text, const QString & style);
+  void closeSpan (QString & text);
+
+  QTextStream *_output;
+  const ColorEntry *_colorTable;
+  bool _innerSpanOpen;
+  quint8 _lastRendition;
+  CharacterColor _lastForeColor;
+  CharacterColor _lastBackColor;
+
+};
+
+#endif
diff --git a/gui/src/terminal/TerminalDisplay.cpp b/gui/src/terminal/TerminalDisplay.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/TerminalDisplay.cpp
@@ -0,0 +1,3098 @@
+/*
+    This file is part of Konsole, a terminal emulator for KDE.
+    
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "TerminalDisplay.h"
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtGui/QBoxLayout>
+#include <QtGui/QClipboard>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QEvent>
+#include <QtCore/QTime>
+#include <QtCore/QFile>
+#include <QtGui/QGridLayout>
+#include <QtGui/QLabel>
+#include <QtGui/QLayout>
+#include <QtGui/QPainter>
+#include <QtGui/QPixmap>
+#include <QtGui/QScrollBar>
+#include <QtGui/QStyle>
+#include <QtCore/QTimer>
+#include <QtGui/QToolTip>
+#include <QtCore/QTextStream>
+
+#include "Filter.h"
+#include "konsole_wcwidth.h"
+#include "ScreenWindow.h"
+#include "TerminalCharacterDecoder.h"
+
+#ifndef loc
+#define loc(X,Y) ((Y)*_columns+(X))
+#endif
+
+#define yMouseScroll 1
+
+#define REPCHAR   "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
+    "abcdefgjijklmnopqrstuvwxyz" \
+    "0123456789./+@"
+
+const ColorEntry base_color_table[TABLE_COLORS] =
+// The following are almost IBM standard color codes, with some slight
+// gamma correction for the dim colors to compensate for bright X screens.
+// It contains the 8 ansiterm/xterm colors in 2 intensities.
+{
+  // Fixme: could add faint colors here, also.
+  // normal
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 1),	// Dfore, Dback
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0), ColorEntry (QColor (0xB2, 0x18, 0x18), 0),	// Black, Red
+  ColorEntry (QColor (0x18, 0xB2, 0x18), 0), ColorEntry (QColor (0xB2, 0x68, 0x18), 0),	// Green, Yellow
+  ColorEntry (QColor (0x18, 0x18, 0xB2), 0), ColorEntry (QColor (0xB2, 0x18, 0xB2), 0),	// Blue, Magenta
+  ColorEntry (QColor (0x18, 0xB2, 0xB2), 0), ColorEntry (QColor (0xB2, 0xB2, 0xB2), 0),	// Cyan, White
+  // intensiv
+  ColorEntry (QColor (0x00, 0x00, 0x00), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 1),
+  ColorEntry (QColor (0x68, 0x68, 0x68), 0),
+    ColorEntry (QColor (0xFF, 0x54, 0x54), 0),
+  ColorEntry (QColor (0x54, 0xFF, 0x54), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0x54), 0),
+  ColorEntry (QColor (0x54, 0x54, 0xFF), 0),
+    ColorEntry (QColor (0xFF, 0x54, 0xFF), 0),
+  ColorEntry (QColor (0x54, 0xFF, 0xFF), 0),
+    ColorEntry (QColor (0xFF, 0xFF, 0xFF), 0)
+};
+
+// scroll increment used when dragging selection at top/bottom of window.
+
+// static
+bool
+  TerminalDisplay::_antialiasText = true;
+bool
+  TerminalDisplay::HAVE_TRANSPARENCY = false;
+
+// we use this to force QPainter to display text in LTR mode
+// more information can be found in: http://unicode.org/reports/tr9/ 
+const QChar
+LTR_OVERRIDE_CHAR (0x202D);
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Colors                                     */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/* Note that we use ANSI color order (bgr), while IBMPC color order is (rgb)
+
+   Code        0       1       2       3       4       5       6       7
+   ----------- ------- ------- ------- ------- ------- ------- ------- -------
+   ANSI  (bgr) Black   Red     Green   Yellow  Blue    Magenta Cyan    White
+   IBMPC (rgb) Black   Blue    Green   Cyan    Red     Magenta Yellow  White
+*/
+
+ScreenWindow *
+TerminalDisplay::screenWindow () const
+{
+  return _screenWindow;
+}
+
+void
+TerminalDisplay::setScreenWindow (ScreenWindow * window)
+{
+  // disconnect existing screen window if any
+  if (_screenWindow)
+    {
+      disconnect (_screenWindow, 0, this, 0);
+    }
+
+  _screenWindow = window;
+
+  if (window)
+    {
+
+      // TODO: Determine if this is an issue.
+      //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
+      connect (_screenWindow, SIGNAL (outputChanged ()), this,
+	       SLOT (updateLineProperties ()));
+      connect (_screenWindow, SIGNAL (outputChanged ()), this,
+	       SLOT (updateImage ()));
+      window->setWindowLines (_lines);
+    }
+}
+
+const ColorEntry *
+TerminalDisplay::colorTable () const
+{
+  return _colorTable;
+}
+
+void
+TerminalDisplay::setBackgroundColor (const QColor & color)
+{
+  _colorTable[DEFAULT_BACK_COLOR].color = color;
+  QPalette p = palette ();
+  p.setColor (backgroundRole (), color);
+  setPalette (p);
+
+  // Avoid propagating the palette change to the scroll bar
+  _scrollBar->setPalette (QApplication::palette ());
+
+  update ();
+}
+
+void
+TerminalDisplay::setForegroundColor (const QColor & color)
+{
+  _colorTable[DEFAULT_FORE_COLOR].color = color;
+
+  update ();
+}
+
+void
+TerminalDisplay::setColorTable (const ColorEntry table[])
+{
+  for (int i = 0; i < TABLE_COLORS; i++)
+    _colorTable[i] = table[i];
+
+  setBackgroundColor (_colorTable[DEFAULT_BACK_COLOR].color);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                   Font                                    */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*
+   The VT100 has 32 special graphical characters. The usual vt100 extended
+   xterm fonts have these at 0x00..0x1f.
+
+   QT's iso mapping leaves 0x00..0x7f without any changes. But the graphicals
+   come in here as proper unicode characters.
+
+   We treat non-iso10646 fonts as VT100 extended and do the requiered mapping
+   from unicode to 0x00..0x1f. The remaining translation is then left to the
+   QCodec.
+*/
+
+static inline bool
+isLineChar (quint16 c)
+{
+  return ((c & 0xFF80) == 0x2500);
+}
+
+static inline bool
+isLineCharString (const QString & string)
+{
+  return (string.length () > 0) && (isLineChar (string.at (0).unicode ()));
+}
+
+
+// assert for i in [0..31] : vt100extended(vt100_graphics[i]) == i.
+
+unsigned short vt100_graphics[32] = {	// 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
+  0x0020, 0x25C6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0,
+  0x00b1, 0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c,
+  0xF800, 0xF801, 0x2500, 0xF803, 0xF804, 0x251c, 0x2524, 0x2534,
+  0x252c, 0x2502, 0x2264, 0x2265, 0x03C0, 0x2260, 0x00A3, 0x00b7
+};
+
+void
+TerminalDisplay::fontChange (const QFont &)
+{
+  QFontMetrics fm (font ());
+  _fontHeight = fm.height () + _lineSpacing;
+
+  // waba TerminalDisplay 1.123:
+  // "Base character width on widest ASCII character. This prevents too wide
+  //  characters in the presence of double wide (e.g. Japanese) characters."
+  // Get the width from representative normal width characters
+  _fontWidth =
+    qRound ((double) fm.width (REPCHAR) / (double) strlen (REPCHAR));
+
+  _fixedFont = true;
+
+  int fw = fm.width (REPCHAR[0]);
+  for (unsigned int i = 1; i < strlen (REPCHAR); i++)
+    {
+      if (fw != fm.width (REPCHAR[i]))
+	{
+	  _fixedFont = false;
+	  break;
+	}
+    }
+
+  if (_fontWidth < 1)
+    _fontWidth = 1;
+
+  _fontAscent = fm.ascent ();
+
+  emit changedFontMetricSignal (_fontHeight, _fontWidth);
+  propagateSize ();
+  update ();
+}
+
+void
+TerminalDisplay::setVTFont (const QFont & f)
+{
+  QFont font = f;
+
+  QFontMetrics metrics (font);
+
+  if (!QFontInfo (font).fixedPitch ())
+    {
+      //kWarning() << "Using an unsupported variable-width font in the terminal.  This may produce display errors.";
+    }
+
+  if (metrics.height () < height () && metrics.maxWidth () < width ())
+    {
+      // hint that text should be drawn without anti-aliasing.
+      // depending on the user's font configuration, this may not be respected
+      if (!_antialiasText)
+	font.setStyleStrategy (QFont::NoAntialias);
+
+      // experimental optimization.  Konsole assumes that the terminal is using a
+      // mono-spaced font, in which case kerning information should have an effect.
+      // Disabling kerning saves some computation when rendering text.
+      font.setKerning (false);
+
+      QWidget::setFont (font);
+      fontChange (font);
+    }
+}
+
+void
+TerminalDisplay::setFont (const QFont &)
+{
+  // ignore font change request if not coming from konsole itself
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                         Constructor / Destructor                          */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+TerminalDisplay::TerminalDisplay (QWidget * parent):QWidget (parent), _screenWindow (0), _allowBell (true), _gridLayout (0),
+_fontHeight (1), _fontWidth (1), _fontAscent (1), _boldIntense (true),
+_lines (1), _columns (1), _usedLines (1), _usedColumns (1),
+_contentHeight (1), _contentWidth (1), _image (0), _randomSeed (0),
+_resizing (false), _terminalSizeHint (false), _terminalSizeStartup (true),
+_bidiEnabled (false), _actSel (0), _wordSelectionMode (false),
+_lineSelectionMode (false), _preserveLineBreaks (false),
+_columnSelectionMode (false), _scrollbarLocation (NoScrollBar),
+_wordCharacters (":@-./_~"), _bellMode (SystemBeepBell), _blinking (false),
+_hasBlinker (false), _cursorBlinking (false), _hasBlinkingCursor (false),
+_allowBlinkingText (true), _ctrlDrag (true),
+_tripleClickMode (SelectWholeLine), _isFixedSize (false),
+_possibleTripleClick (false), _resizeWidget (0), _resizeTimer (0),
+_flowControlWarningEnabled (false), _outputSuspendedLabel (0),
+_lineSpacing (0), _colorsInverted (false),
+_blendColor (qRgba (0, 0, 0, 0xff)),
+_filterChain (new TerminalImageFilterChain ()), _cursorShape (BlockCursor)
+{
+  // terminal applications are not designed with Right-To-Left in mind,
+  // so the layout is forced to Left-To-Right
+  setLayoutDirection (Qt::LeftToRight);
+
+  // The offsets are not yet calculated.
+  // Do not calculate these too often to be more smoothly when resizing
+  // konsole in opaque mode.
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _leftMargin = DEFAULT_LEFT_MARGIN;
+
+  // create scroll bar for scrolling output up and down
+  // set the scroll bar's slider to occupy the whole area of the scroll bar initially
+  _scrollBar = new QScrollBar (this);
+  setScroll (0, 0);
+  _scrollBar->setCursor (Qt::ArrowCursor);
+  connect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	   SLOT (scrollBarPositionChanged (int)));
+
+  // setup timers for blinking cursor and text
+  _blinkTimer = new QTimer (this);
+  connect (_blinkTimer, SIGNAL (timeout ()), this, SLOT (blinkEvent ()));
+  _blinkCursorTimer = new QTimer (this);
+  connect (_blinkCursorTimer, SIGNAL (timeout ()), this,
+	   SLOT (blinkCursorEvent ()));
+
+  //KCursor::setAutoHideCursor( this, true );
+
+  setUsesMouse (true);
+  setColorTable (base_color_table);
+  setMouseTracking (true);
+
+  // Enable drag and drop
+  setAcceptDrops (true);	// attempt
+  dragInfo.state = diNone;
+
+  setFocusPolicy (Qt::WheelFocus);
+
+  // enable input method support
+  setAttribute (Qt::WA_InputMethodEnabled, true);
+
+  // this is an important optimization, it tells Qt
+  // that TerminalDisplay will handle repainting its entire area.
+  setAttribute (Qt::WA_OpaquePaintEvent);
+
+  _gridLayout = new QGridLayout (this);
+  _gridLayout->setContentsMargins (0, 0, 0, 0);
+
+  setLayout (_gridLayout);
+
+  new
+  AutoScrollHandler (this);
+}
+
+TerminalDisplay::~TerminalDisplay ()
+{
+  disconnect (_blinkTimer);
+  disconnect (_blinkCursorTimer);
+  qApp->removeEventFilter (this);
+
+  delete[]_image;
+
+  delete _gridLayout;
+  delete _outputSuspendedLabel;
+  delete _filterChain;
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                             Display Operations                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/**
+ A table for emulating the simple (single width) unicode drawing chars.
+ It represents the 250x - 257x glyphs. If it's zero, we can't use it.
+ if it's not, it's encoded as follows: imagine a 5x5 grid where the points are numbered
+ 0 to 24 left to top, top to bottom. Each point is represented by the corresponding bit.
+
+ Then, the pixels basically have the following interpretation:
+ _|||_
+ -...-
+ -...-
+ -...-
+ _|||_
+
+where _ = none
+      | = vertical line.
+      - = horizontal line.
+ */
+
+
+enum LineEncode
+{
+  TopL = (1 << 1),
+  TopC = (1 << 2),
+  TopR = (1 << 3),
+
+  LeftT = (1 << 5),
+  Int11 = (1 << 6),
+  Int12 = (1 << 7),
+  Int13 = (1 << 8),
+  RightT = (1 << 9),
+
+  LeftC = (1 << 10),
+  Int21 = (1 << 11),
+  Int22 = (1 << 12),
+  Int23 = (1 << 13),
+  RightC = (1 << 14),
+
+  LeftB = (1 << 15),
+  Int31 = (1 << 16),
+  Int32 = (1 << 17),
+  Int33 = (1 << 18),
+  RightB = (1 << 19),
+
+  BotL = (1 << 21),
+  BotC = (1 << 22),
+  BotR = (1 << 23)
+};
+
+void
+TerminalDisplay::setKeyboardCursorShape (KeyboardCursorShape shape)
+{
+  _cursorShape = shape;
+}
+
+TerminalDisplay::KeyboardCursorShape TerminalDisplay::keyboardCursorShape () const
+{
+  return _cursorShape;
+}
+
+void
+TerminalDisplay::drawBackground (QPainter & painter, const QRect & rect,
+				 const QColor & backgroundColor,
+				 bool useOpacitySetting)
+{
+  // the area of the widget showing the contents of the terminal display is drawn
+  // using the background color from the color scheme set with setColorTable()
+  //
+  // the area of the widget behind the scroll-bar is drawn using the background
+  // brush from the scroll-bar's palette, to give the effect of the scroll-bar
+  // being outside of the terminal display and visual consistency with other KDE
+  // applications.
+  //
+  QRect scrollBarArea = _scrollBar->isVisible ()?
+    rect.intersected (_scrollBar->geometry ()) : QRect ();
+  QRegion contentsRegion = QRegion (rect).subtracted (scrollBarArea);
+  QRect contentsRect = contentsRegion.boundingRect ();
+
+  if (HAVE_TRANSPARENCY && qAlpha (_blendColor) < 0xff && useOpacitySetting)
+    {
+      QColor color (backgroundColor);
+      color.setAlpha (qAlpha (_blendColor));
+
+      painter.save ();
+      painter.setCompositionMode (QPainter::CompositionMode_Source);
+      painter.fillRect (contentsRect, color);
+      painter.restore ();
+    }
+  else
+    painter.fillRect (contentsRect, backgroundColor);
+
+  painter.fillRect (scrollBarArea, _scrollBar->palette ().background ());
+}
+
+void
+TerminalDisplay::drawCursor (QPainter & painter,
+			     const QRect & rect,
+			     const QColor & foregroundColor,
+			     const QColor & /*backgroundColor */ ,
+			     bool & invertCharacterColor)
+{
+  QRect cursorRect = rect;
+  cursorRect.setHeight (_fontHeight - _lineSpacing - 1);
+
+  if (!_cursorBlinking)
+    {
+      if (_cursorColor.isValid ())
+	painter.setPen (_cursorColor);
+      else
+	painter.setPen (foregroundColor);
+
+      if (_cursorShape == BlockCursor)
+	{
+	  // draw the cursor outline, adjusting the area so that
+	  // it is draw entirely inside 'rect'
+	  int penWidth = qMax (1, painter.pen ().width ());
+
+	  painter.drawRect (cursorRect.adjusted (penWidth / 2,
+						 penWidth / 2,
+						 -penWidth / 2 - penWidth % 2,
+						 -penWidth / 2 -
+						 penWidth % 2));
+	  if (hasFocus ())
+	    {
+	      painter.fillRect (cursorRect,
+				_cursorColor.
+				isValid ()? _cursorColor : foregroundColor);
+
+	      if (!_cursorColor.isValid ())
+		{
+		  // invert the colour used to draw the text to ensure that the character at
+		  // the cursor position is readable
+		  invertCharacterColor = true;
+		}
+	    }
+	}
+      else if (_cursorShape == UnderlineCursor)
+	painter.drawLine (cursorRect.left (),
+			  cursorRect.bottom (),
+			  cursorRect.right (), cursorRect.bottom ());
+      else if (_cursorShape == IBeamCursor)
+	painter.drawLine (cursorRect.left (),
+			  cursorRect.top (),
+			  cursorRect.left (), cursorRect.bottom ());
+
+    }
+}
+
+void
+TerminalDisplay::drawCharacters (QPainter & painter,
+				 const QRect & rect,
+				 const QString & text,
+				 const Character * style,
+				 bool invertCharacterColor)
+{
+  // don't draw text which is currently blinking
+  if (_blinking && (style->rendition & RE_BLINK))
+    return;
+
+  // setup boldJ and underline
+  bool useBold;
+  ColorEntry::FontWeight weight = style->fontWeight (_colorTable);
+  if (weight == ColorEntry::UseCurrentFormat)
+    useBold = ((style->rendition & RE_BOLD) && _boldIntense)
+      || font ().bold ();
+  else
+    useBold = (weight == ColorEntry::Bold) ? true : false;
+  bool useUnderline = style->rendition & RE_UNDERLINE || font ().underline ();
+
+  QFont font = painter.font ();
+  if (font.bold () != useBold || font.underline () != useUnderline)
+    {
+      font.setBold (useBold);
+      font.setUnderline (useUnderline);
+      painter.setFont (font);
+    }
+
+  // setup pen
+  const CharacterColor & textColor =
+    (invertCharacterColor ? style->backgroundColor : style->foregroundColor);
+  const QColor color = textColor.color (_colorTable);
+  QPen pen = painter.pen ();
+  if (pen.color () != color)
+    {
+      pen.setColor (color);
+      painter.setPen (color);
+    }
+
+  if (_bidiEnabled)
+    painter.drawText (rect, 0, text);
+  else
+    painter.drawText (rect, 0, LTR_OVERRIDE_CHAR + text);
+}
+
+void
+TerminalDisplay::drawTextFragment (QPainter & painter,
+				   const QRect & rect,
+				   const QString & text,
+				   const Character * style)
+{
+  painter.save ();
+
+  // setup painter 
+  const QColor foregroundColor = style->foregroundColor.color (_colorTable);
+  const QColor backgroundColor = style->backgroundColor.color (_colorTable);
+
+  // draw background if different from the display's background color
+  if (backgroundColor != palette ().background ().color ())
+    drawBackground (painter, rect, backgroundColor,
+		    false /* do not use transparency */ );
+
+  // draw cursor shape if the current character is the cursor
+  // this may alter the foreground and background colors
+  bool invertCharacterColor = false;
+  if (style->rendition & RE_CURSOR)
+    drawCursor (painter, rect, foregroundColor, backgroundColor,
+		invertCharacterColor);
+
+  // draw text
+  drawCharacters (painter, rect, text, style, invertCharacterColor);
+
+  painter.restore ();
+}
+
+void
+TerminalDisplay::setRandomSeed (uint randomSeed)
+{
+  _randomSeed = randomSeed;
+}
+
+uint
+TerminalDisplay::randomSeed () const
+{
+  return _randomSeed;
+}
+
+#if 0
+/*!
+    Set XIM Position
+*/
+void
+TerminalDisplay::setCursorPos (const int curx, const int cury)
+{
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+
+  int xpos, ypos;
+  ypos = _topMargin + tLy + _fontHeight * (cury - 1) + _fontAscent;
+  xpos = _leftMargin + tLx + _fontWidth * curx;
+  _cursorLine = cury;
+  _cursorCol = curx;
+}
+#endif
+
+// scrolls the image by 'lines', down if lines > 0 or up otherwise.
+//
+// the terminal emulation keeps track of the scrolling of the character 
+// image as it receives input, and when the view is updated, it calls scrollImage() 
+// with the final scroll amount.  this improves performance because scrolling the 
+// display is much cheaper than re-rendering all the text for the 
+// part of the image which has moved up or down.  
+// Instead only new lines have to be drawn
+void
+TerminalDisplay::scrollImage (int lines, const QRect & screenWindowRegion)
+{
+  // if the flow control warning is enabled this will interfere with the 
+  // scrolling optimizations and cause artifacts.  the simple solution here
+  // is to just disable the optimization whilst it is visible
+  if (_outputSuspendedLabel && _outputSuspendedLabel->isVisible ())
+    return;
+
+  // constrain the region to the display
+  // the bottom of the region is capped to the number of lines in the display's
+  // internal image - 2, so that the height of 'region' is strictly less
+  // than the height of the internal image.
+  QRect region = screenWindowRegion;
+  region.setBottom (qMin (region.bottom (), this->_lines - 2));
+
+  // return if there is nothing to do
+  if (lines == 0
+      || _image == 0
+      || !region.isValid ()
+      || (region.top () + abs (lines)) >= region.bottom ()
+      || this->_lines <= region.height ())
+    return;
+
+  // hide terminal size label to prevent it being scrolled
+  if (_resizeWidget && _resizeWidget->isVisible ())
+    _resizeWidget->hide ();
+
+  // Note:  With Qt 4.4 the left edge of the scrolled area must be at 0
+  // to get the correct (newly exposed) part of the widget repainted.
+  //
+  // The right edge must be before the left edge of the scroll bar to 
+  // avoid triggering a repaint of the entire widget, the distance is 
+  // given by SCROLLBAR_CONTENT_GAP
+  //
+  // Set the QT_FLUSH_PAINT environment variable to '1' before starting the
+  // application to monitor repainting.
+  //
+  int scrollBarWidth = _scrollBar->isHidden ()? 0 : _scrollBar->width ();
+  const int SCROLLBAR_CONTENT_GAP = 1;
+  QRect scrollRect;
+  if (_scrollbarLocation == ScrollBarLeft)
+    {
+      scrollRect.setLeft (scrollBarWidth + SCROLLBAR_CONTENT_GAP);
+      scrollRect.setRight (width ());
+    }
+  else
+    {
+      scrollRect.setLeft (0);
+      scrollRect.setRight (width () - scrollBarWidth - SCROLLBAR_CONTENT_GAP);
+    }
+  void *firstCharPos = &_image[region.top () * this->_columns];
+  void *lastCharPos = &_image[(region.top () + abs (lines)) * this->_columns];
+
+  int top = _topMargin + (region.top () * _fontHeight);
+  int linesToMove = region.height () - abs (lines);
+  int bytesToMove = linesToMove * this->_columns * sizeof (Character);
+
+  Q_ASSERT (linesToMove > 0);
+  Q_ASSERT (bytesToMove > 0);
+
+  //scroll internal image
+  if (lines > 0)
+    {
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT ((char *) lastCharPos + bytesToMove <
+		(char *) (_image + (this->_lines * this->_columns)));
+
+      Q_ASSERT ((lines * this->_columns) < _imageSize);
+
+      //scroll internal image down
+      memmove (firstCharPos, lastCharPos, bytesToMove);
+
+      //set region of display to scroll
+      scrollRect.setTop (top);
+    }
+  else
+    {
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT ((char *) firstCharPos + bytesToMove <
+		(char *) (_image + (this->_lines * this->_columns)));
+
+      //scroll internal image up
+      memmove (lastCharPos, firstCharPos, bytesToMove);
+
+      //set region of the display to scroll
+      scrollRect.setTop (top + abs (lines) * _fontHeight);
+    }
+  scrollRect.setHeight (linesToMove * _fontHeight);
+
+  Q_ASSERT (scrollRect.isValid () && !scrollRect.isEmpty ());
+
+  //scroll the display vertically to match internal _image
+  scroll (0, _fontHeight * (-lines), scrollRect);
+}
+
+QRegion
+TerminalDisplay::hotSpotRegion () const
+{
+  QRegion region;
+  foreach (Filter::HotSpot * hotSpot, _filterChain->hotSpots ())
+  {
+    QRect r;
+    if (hotSpot->startLine () == hotSpot->endLine ())
+      {
+	r.setLeft (hotSpot->startColumn ());
+	r.setTop (hotSpot->startLine ());
+	r.setRight (hotSpot->endColumn ());
+	r.setBottom (hotSpot->endLine ());
+	region |= imageToWidget (r);;
+      }
+    else
+      {
+	r.setLeft (hotSpot->startColumn ());
+	r.setTop (hotSpot->startLine ());
+	r.setRight (_columns);
+	r.setBottom (hotSpot->startLine ());
+	region |= imageToWidget (r);;
+	for (int line = hotSpot->startLine () + 1; line < hotSpot->endLine ();
+	     line++)
+	  {
+	    r.setLeft (0);
+	    r.setTop (line);
+	    r.setRight (_columns);
+	    r.setBottom (line);
+	    region |= imageToWidget (r);;
+	  }
+	r.setLeft (0);
+	r.setTop (hotSpot->endLine ());
+	r.setRight (hotSpot->endColumn ());
+	r.setBottom (hotSpot->endLine ());
+	region |= imageToWidget (r);;
+      }
+  }
+  return region;
+}
+
+void
+TerminalDisplay::processFilters ()
+{
+  if (!_screenWindow)
+    return;
+
+  QRegion preUpdateHotSpots = hotSpotRegion ();
+
+  // use _screenWindow->getImage() here rather than _image because
+  // other classes may call processFilters() when this display's
+  // ScreenWindow emits a scrolled() signal - which will happen before
+  // updateImage() is called on the display and therefore _image is 
+  // out of date at this point
+  _filterChain->setImage (_screenWindow->getImage (),
+			  _screenWindow->windowLines (),
+			  _screenWindow->windowColumns (),
+			  _screenWindow->getLineProperties ());
+  _filterChain->process ();
+
+  QRegion postUpdateHotSpots = hotSpotRegion ();
+
+  update (preUpdateHotSpots | postUpdateHotSpots);
+}
+
+void
+TerminalDisplay::updateImage ()
+{
+  if (!_screenWindow)
+    return;
+
+  // optimization - scroll the existing image where possible and
+  // avoid expensive text drawing for parts of the image that
+  // can simply be moved up or down
+  scrollImage (_screenWindow->scrollCount (), _screenWindow->scrollRegion ());
+  _screenWindow->resetScrollCount ();
+
+  if (!_image)
+    {
+      // Create _image.
+      // The emitted changedContentSizeSignal also leads to getImage being recreated, so do this first.
+      updateImageSize ();
+    }
+
+  Character *const newimg = _screenWindow->getImage ();
+  int lines = _screenWindow->windowLines ();
+  int columns = _screenWindow->windowColumns ();
+
+  setScroll (_screenWindow->currentLine (), _screenWindow->lineCount ());
+
+  Q_ASSERT (this->_usedLines <= this->_lines);
+  Q_ASSERT (this->_usedColumns <= this->_columns);
+
+  int y, x, len;
+
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+  _hasBlinker = false;
+
+  CharacterColor cf;		// undefined
+  CharacterColor _clipboard;	// undefined
+  int cr = -1;			// undefined
+
+  const int linesToUpdate = qMin (this->_lines, qMax (0, lines));
+  const int columnsToUpdate = qMin (this->_columns, qMax (0, columns));
+
+  QChar *disstrU = new QChar[columnsToUpdate];
+  char *dirtyMask = new char[columnsToUpdate + 2];
+  QRegion dirtyRegion;
+
+  // debugging variable, this records the number of lines that are found to
+  // be 'dirty' ( ie. have changed from the old _image to the new _image ) and
+  // which therefore need to be repainted
+  int dirtyLineCount = 0;
+
+  for (y = 0; y < linesToUpdate; ++y)
+    {
+      const Character *currentLine = &_image[y * this->_columns];
+      const Character *const newLine = &newimg[y * columns];
+
+      bool updateLine = false;
+
+      // The dirty mask indicates which characters need repainting. We also
+      // mark surrounding neighbours dirty, in case the character exceeds
+      // its cell boundaries
+      memset (dirtyMask, 0, columnsToUpdate + 2);
+
+      for (x = 0; x < columnsToUpdate; ++x)
+	{
+	  if (newLine[x] != currentLine[x])
+	    {
+	      dirtyMask[x] = true;
+	    }
+	}
+
+      if (!_resizing)		// not while _resizing, we're expecting a paintEvent
+	for (x = 0; x < columnsToUpdate; ++x)
+	  {
+	    _hasBlinker |= (newLine[x].rendition & RE_BLINK);
+
+	    // Start drawing if this character or the next one differs.
+	    // We also take the next one into account to handle the situation
+	    // where characters exceed their cell width.
+	    if (dirtyMask[x])
+	      {
+		quint16 c = newLine[x + 0].character;
+		if (!c)
+		  continue;
+		int p = 0;
+		disstrU[p++] = c;	//fontMap(c);
+		bool lineDraw = isLineChar (c);
+		bool doubleWidth =
+		  (x + 1 ==
+		   columnsToUpdate) ? false : (newLine[x + 1].character == 0);
+		cr = newLine[x].rendition;
+		_clipboard = newLine[x].backgroundColor;
+		if (newLine[x].foregroundColor != cf)
+		  cf = newLine[x].foregroundColor;
+		int lln = columnsToUpdate - x;
+		for (len = 1; len < lln; ++len)
+		  {
+		    const Character & ch = newLine[x + len];
+
+		    if (!ch.character)
+		      continue;	// Skip trailing part of multi-col chars.
+
+		    bool nextIsDoubleWidth =
+		      (x + len + 1 ==
+		       columnsToUpdate) ? false : (newLine[x + len +
+							   1].character == 0);
+
+		    if (ch.foregroundColor != cf ||
+			ch.backgroundColor != _clipboard ||
+			ch.rendition != cr ||
+			!dirtyMask[x + len] ||
+			isLineChar (c) != lineDraw ||
+			nextIsDoubleWidth != doubleWidth)
+		      break;
+
+		    disstrU[p++] = c;	//fontMap(c);
+		  }
+
+		QString unistr (disstrU, p);
+
+		bool saveFixedFont = _fixedFont;
+		if (lineDraw)
+		  _fixedFont = false;
+		if (doubleWidth)
+		  _fixedFont = false;
+
+		updateLine = true;
+
+		_fixedFont = saveFixedFont;
+		x += len - 1;
+	      }
+
+	  }
+
+      //both the top and bottom halves of double height _lines must always be redrawn
+      //although both top and bottom halves contain the same characters, only
+      //the top one is actually
+      //drawn.
+      if (_lineProperties.count () > y)
+	updateLine |= (_lineProperties[y] & LINE_DOUBLEHEIGHT);
+
+      // if the characters on the line are different in the old and the new _image
+      // then this line must be repainted.
+      if (updateLine)
+	{
+	  dirtyLineCount++;
+
+	  // add the area occupied by this line to the region which needs to be
+	  // repainted
+	  QRect dirtyRect = QRect (_leftMargin + tLx,
+				   _topMargin + tLy + _fontHeight * y,
+				   _fontWidth * columnsToUpdate,
+				   _fontHeight);
+
+	  dirtyRegion |= dirtyRect;
+	}
+
+      // replace the line of characters in the old _image with the
+      // current line of the new _image
+      memcpy ((void *) currentLine, (const void *) newLine,
+	      columnsToUpdate * sizeof (Character));
+    }
+
+  // if the new _image is smaller than the previous _image, then ensure that the area
+  // outside the new _image is cleared
+  if (linesToUpdate < _usedLines)
+    {
+      dirtyRegion |= QRect (_leftMargin + tLx,
+			    _topMargin + tLy + _fontHeight * linesToUpdate,
+			    _fontWidth * this->_columns,
+			    _fontHeight * (_usedLines - linesToUpdate));
+    }
+  _usedLines = linesToUpdate;
+
+  if (columnsToUpdate < _usedColumns)
+    {
+      dirtyRegion |= QRect (_leftMargin + tLx + columnsToUpdate * _fontWidth,
+			    _topMargin + tLy,
+			    _fontWidth * (_usedColumns - columnsToUpdate),
+			    _fontHeight * this->_lines);
+    }
+  _usedColumns = columnsToUpdate;
+
+  dirtyRegion |= _inputMethodData.previousPreeditRect;
+
+  // update the parts of the display which have changed
+  update (dirtyRegion);
+
+  if (_hasBlinker && !_blinkTimer->isActive ())
+    _blinkTimer->start (TEXT_BLINK_DELAY);
+  if (!_hasBlinker && _blinkTimer->isActive ())
+    {
+      _blinkTimer->stop ();
+      _blinking = false;
+    }
+  delete[]dirtyMask;
+  delete[]disstrU;
+
+}
+
+void
+TerminalDisplay::showResizeNotification ()
+{
+  if (_terminalSizeHint && isVisible ())
+    {
+      if (_terminalSizeStartup)
+	{
+	  _terminalSizeStartup = false;
+	  return;
+	}
+      if (!_resizeWidget)
+	{
+	  _resizeWidget = new QLabel (QString ("Size: XXX x XXX"), this);
+	  _resizeWidget->setMinimumWidth (_resizeWidget->fontMetrics ().
+					  width (QString
+						 ("Size: XXX x XXX")));
+	  _resizeWidget->setMinimumHeight (_resizeWidget->sizeHint ().
+					   height ());
+	  _resizeWidget->setAlignment (Qt::AlignCenter);
+
+	  _resizeWidget->
+	    setStyleSheet
+	    ("background-color:palette(window);border-style:solid;border-width:1px;border-color:palette(dark)");
+
+	  _resizeTimer = new QTimer (this);
+	  _resizeTimer->setSingleShot (true);
+	  connect (_resizeTimer, SIGNAL (timeout ()), _resizeWidget,
+		   SLOT (hide ()));
+	}
+      QString sizeStr = QString ("Size: %1 x %2").arg (_columns).arg (_lines);
+      _resizeWidget->setText (sizeStr);
+      _resizeWidget->move ((width () - _resizeWidget->width ()) / 2,
+			   (height () - _resizeWidget->height ()) / 2 + 20);
+      _resizeWidget->show ();
+      _resizeTimer->start (1000);
+    }
+}
+
+void
+TerminalDisplay::setBlinkingCursor (bool blink)
+{
+  _hasBlinkingCursor = blink;
+
+  if (blink && !_blinkCursorTimer->isActive ())
+    _blinkCursorTimer->start (QApplication::cursorFlashTime () / 2);
+
+  if (!blink && _blinkCursorTimer->isActive ())
+    {
+      _blinkCursorTimer->stop ();
+      if (_cursorBlinking)
+	blinkCursorEvent ();
+      else
+	_cursorBlinking = false;
+    }
+}
+
+void
+TerminalDisplay::setBlinkingTextEnabled (bool blink)
+{
+  _allowBlinkingText = blink;
+
+  if (blink && !_blinkTimer->isActive ())
+    _blinkTimer->start (TEXT_BLINK_DELAY);
+
+  if (!blink && _blinkTimer->isActive ())
+    {
+      _blinkTimer->stop ();
+      _blinking = false;
+    }
+}
+
+void
+TerminalDisplay::focusOutEvent (QFocusEvent *)
+{
+  // trigger a repaint of the cursor so that it is both visible (in case
+  // it was hidden during blinking)
+  // and drawn in a focused out state
+  _cursorBlinking = false;
+  updateCursor ();
+
+  _blinkCursorTimer->stop ();
+  if (_blinking)
+    blinkEvent ();
+
+  _blinkTimer->stop ();
+}
+
+void
+TerminalDisplay::focusInEvent (QFocusEvent *)
+{
+  if (_hasBlinkingCursor)
+    {
+      _blinkCursorTimer->start ();
+    }
+  updateCursor ();
+
+  if (_hasBlinker)
+    _blinkTimer->start ();
+}
+
+void
+TerminalDisplay::paintEvent (QPaintEvent * pe)
+{
+  QPainter paint (this);
+
+  foreach (const QRect & rect, (pe->region () & contentsRect ()).rects ())
+  {
+    drawBackground (paint, rect, palette ().background ().color (),
+		    true /* use opacity setting */ );
+    drawContents (paint, rect);
+  }
+  drawInputMethodPreeditString (paint, preeditRect ());
+  paintFilters (paint);
+}
+
+QPoint
+TerminalDisplay::cursorPosition () const
+{
+  if (_screenWindow)
+    return _screenWindow->cursorPosition ();
+  else
+    return QPoint (0, 0);
+}
+
+QRect
+TerminalDisplay::preeditRect () const
+{
+  const int preeditLength = string_width (_inputMethodData.preeditString);
+
+  if (preeditLength == 0)
+    return QRect ();
+
+  return QRect (_leftMargin + _fontWidth * cursorPosition ().x (),
+		_topMargin + _fontHeight * cursorPosition ().y (),
+		_fontWidth * preeditLength, _fontHeight);
+}
+
+void
+TerminalDisplay::drawInputMethodPreeditString (QPainter & painter,
+					       const QRect & rect)
+{
+  if (_inputMethodData.preeditString.isEmpty ())
+    return;
+
+  const QPoint cursorPos = cursorPosition ();
+
+  bool invertColors = false;
+  const QColor background = _colorTable[DEFAULT_BACK_COLOR].color;
+  const QColor foreground = _colorTable[DEFAULT_FORE_COLOR].color;
+  const Character *style = &_image[loc (cursorPos.x (), cursorPos.y ())];
+
+  drawBackground (painter, rect, background, true);
+  drawCursor (painter, rect, foreground, background, invertColors);
+  drawCharacters (painter, rect, _inputMethodData.preeditString, style,
+		  invertColors);
+
+  _inputMethodData.previousPreeditRect = rect;
+}
+
+FilterChain *
+TerminalDisplay::filterChain () const
+{
+  return _filterChain;
+}
+
+void
+TerminalDisplay::paintFilters (QPainter & painter)
+{
+  // get color of character under mouse and use it to draw
+  // lines for filters
+  QPoint cursorPos = mapFromGlobal (QCursor::pos ());
+  int cursorLine;
+  int cursorColumn;
+  int scrollBarWidth =
+    (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width () : 0;
+
+  getCharacterPosition (cursorPos, cursorLine, cursorColumn);
+  Character cursorCharacter = _image[loc (cursorColumn, cursorLine)];
+
+  painter.
+    setPen (QPen (cursorCharacter.foregroundColor.color (colorTable ())));
+
+  // iterate over hotspots identified by the display's currently active filters 
+  // and draw appropriate visuals to indicate the presence of the hotspot
+
+  QList < Filter::HotSpot * >spots = _filterChain->hotSpots ();
+  QListIterator < Filter::HotSpot * >iter (spots);
+  while (iter.hasNext ())
+    {
+      Filter::HotSpot * spot = iter.next ();
+
+      QRegion region;
+      if (spot->type () == Filter::HotSpot::Link)
+	{
+	  QRect r;
+	  if (spot->startLine () == spot->endLine ())
+	    {
+	      r.setCoords (spot->startColumn () * _fontWidth + 1 +
+			   scrollBarWidth,
+			   spot->startLine () * _fontHeight + 1,
+			   (spot->endColumn () - 1) * _fontWidth - 1 +
+			   scrollBarWidth,
+			   (spot->endLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	    }
+	  else
+	    {
+	      r.setCoords (spot->startColumn () * _fontWidth + 1 +
+			   scrollBarWidth,
+			   spot->startLine () * _fontHeight + 1,
+			   (_columns - 1) * _fontWidth - 1 + scrollBarWidth,
+			   (spot->startLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	      for (int line = spot->startLine () + 1; line < spot->endLine ();
+		   line++)
+		{
+		  r.setCoords (0 * _fontWidth + 1 + scrollBarWidth,
+			       line * _fontHeight + 1,
+			       (_columns - 1) * _fontWidth - 1 +
+			       scrollBarWidth, (line + 1) * _fontHeight - 1);
+		  region |= r;
+		}
+	      r.setCoords (0 * _fontWidth + 1 + scrollBarWidth,
+			   spot->endLine () * _fontHeight + 1,
+			   (spot->endColumn () - 1) * _fontWidth - 1 +
+			   scrollBarWidth,
+			   (spot->endLine () + 1) * _fontHeight - 1);
+	      region |= r;
+	    }
+	}
+
+      for (int line = spot->startLine (); line <= spot->endLine (); line++)
+	{
+	  int startColumn = 0;
+	  int endColumn = _columns - 1;	// TODO use number of _columns which are actually 
+	  // occupied on this line rather than the width of the
+	  // display in _columns
+
+	  // ignore whitespace at the end of the lines
+	  while (QChar (_image[loc (endColumn, line)].character).isSpace ()
+		 && endColumn > 0)
+	    endColumn--;
+
+	  // increment here because the column which we want to set 'endColumn' to
+	  // is the first whitespace character at the end of the line
+	  endColumn++;
+
+	  if (line == spot->startLine ())
+	    startColumn = spot->startColumn ();
+	  if (line == spot->endLine ())
+	    endColumn = spot->endColumn ();
+
+	  // subtract one pixel from
+	  // the right and bottom so that
+	  // we do not overdraw adjacent
+	  // hotspots
+	  //
+	  // subtracting one pixel from all sides also prevents an edge case where
+	  // moving the mouse outside a link could still leave it underlined 
+	  // because the check below for the position of the cursor
+	  // finds it on the border of the target area
+	  QRect r;
+	  r.setCoords (startColumn * _fontWidth + 1 + scrollBarWidth,
+		       line * _fontHeight + 1,
+		       endColumn * _fontWidth - 1 + scrollBarWidth,
+		       (line + 1) * _fontHeight - 1);
+	  // Underline link hotspots 
+	  if (spot->type () == Filter::HotSpot::Link)
+	    {
+	      QFontMetrics metrics (font ());
+
+	      // find the baseline (which is the invisible line that the characters in the font sit on,
+	      // with some having tails dangling below)
+	      int baseline = r.bottom () - metrics.descent ();
+	      // find the position of the underline below that
+	      int underlinePos = baseline + metrics.underlinePos ();
+	      if (region.contains (mapFromGlobal (QCursor::pos ())))
+		{
+		  painter.drawLine (r.left (), underlinePos,
+				    r.right (), underlinePos);
+		}
+	    }
+	  // Marker hotspots simply have a transparent rectanglular shape
+	  // drawn on top of them
+	  else if (spot->type () == Filter::HotSpot::Marker)
+	    {
+	      //TODO - Do not use a hardcoded colour for this
+	      painter.fillRect (r, QBrush (QColor (255, 0, 0, 120)));
+	    }
+	}
+    }
+}
+
+void
+TerminalDisplay::drawContents (QPainter & paint, const QRect & rect)
+{
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+
+  int lux =
+    qMin (_usedColumns - 1,
+	  qMax (0, (rect.left () - tLx - _leftMargin) / _fontWidth));
+  int luy =
+    qMin (_usedLines - 1,
+	  qMax (0, (rect.top () - tLy - _topMargin) / _fontHeight));
+  int rlx =
+    qMin (_usedColumns - 1,
+	  qMax (0, (rect.right () - tLx - _leftMargin) / _fontWidth));
+  int rly =
+    qMin (_usedLines - 1,
+	  qMax (0, (rect.bottom () - tLy - _topMargin) / _fontHeight));
+
+  const int bufferSize = _usedColumns;
+  QString unistr;
+  unistr.reserve (bufferSize);
+  for (int y = luy; y <= rly; y++)
+    {
+      quint16 c = _image[loc (lux, y)].character;
+      int x = lux;
+      if (!c && x)
+	x--;			// Search for start of multi-column character
+      for (; x <= rlx; x++)
+	{
+	  int len = 1;
+	  int p = 0;
+
+	  // reset our buffer to the maximal size
+	  unistr.resize (bufferSize);
+	  QChar *disstrU = unistr.data ();
+
+	  // is this a single character or a sequence of characters ?
+	  if (_image[loc (x, y)].rendition & RE_EXTENDED_CHAR)
+	    {
+	      // sequence of characters
+	      ushort extendedCharLength = 0;
+	      ushort *chars =
+		ExtendedCharTable::instance.
+		lookupExtendedChar (_image[loc (x, y)].charSequence,
+				    extendedCharLength);
+	      for (int index = 0; index < extendedCharLength; index++)
+		{
+		  Q_ASSERT (p < bufferSize);
+		  disstrU[p++] = chars[index];
+		}
+	    }
+	  else
+	    {
+	      // single character
+	      c = _image[loc (x, y)].character;
+	      if (c)
+		{
+		  Q_ASSERT (p < bufferSize);
+		  disstrU[p++] = c;	//fontMap(c);
+		}
+	    }
+
+	  bool lineDraw = isLineChar (c);
+	  bool doubleWidth =
+	    (_image[qMin (loc (x, y) + 1, _imageSize)].character == 0);
+	  CharacterColor currentForeground =
+	    _image[loc (x, y)].foregroundColor;
+	  CharacterColor currentBackground =
+	    _image[loc (x, y)].backgroundColor;
+	  quint8 currentRendition = _image[loc (x, y)].rendition;
+
+	  while (x + len <= rlx && _image[loc (x + len, y)].foregroundColor == currentForeground && _image[loc (x + len, y)].backgroundColor == currentBackground && _image[loc (x + len, y)].rendition == currentRendition && (_image[qMin (loc (x + len, y) + 1, _imageSize)].character == 0) == doubleWidth && isLineChar (c = _image[loc (x + len, y)].character) == lineDraw)	// Assignment!
+	    {
+	      if (c)
+		disstrU[p++] = c;	//fontMap(c);
+	      if (doubleWidth)	// assert((_image[loc(x+len,y)+1].character == 0)), see above if condition
+		len++;		// Skip trailing part of multi-column character
+	      len++;
+	    }
+	  if ((x + len < _usedColumns)
+	      && (!_image[loc (x + len, y)].character))
+	    len++;		// Adjust for trailing part of multi-column character
+
+	  bool save__fixedFont = _fixedFont;
+	  if (lineDraw)
+	    _fixedFont = false;
+	  if (doubleWidth)
+	    _fixedFont = false;
+	  unistr.resize (p);
+
+	  // Create a text scaling matrix for double width and double height lines.
+	  QMatrix textScale;
+
+	  if (y < _lineProperties.size ())
+	    {
+	      if (_lineProperties[y] & LINE_DOUBLEWIDTH)
+		textScale.scale (2, 1);
+
+	      if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+		textScale.scale (1, 2);
+	    }
+
+	  //Apply text scaling matrix.
+	  paint.setWorldMatrix (textScale, true);
+
+	  //calculate the area in which the text will be drawn
+	  QRect textArea =
+	    QRect (_leftMargin + tLx + _fontWidth * x,
+		   _topMargin + tLy + _fontHeight * y, _fontWidth * len,
+		   _fontHeight);
+
+	  //move the calculated area to take account of scaling applied to the painter.
+	  //the position of the area from the origin (0,0) is scaled
+	  //by the opposite of whatever
+	  //transformation has been applied to the painter.  this ensures that
+	  //painting does actually start from textArea.topLeft()
+	  //(instead of textArea.topLeft() * painter-scale)
+	  textArea.moveTopLeft (textScale.inverted ().
+				map (textArea.topLeft ()));
+
+	  //paint text fragment
+	  drawTextFragment (paint, textArea, unistr, &_image[loc (x, y)]);	//,
+	  //0,
+	  //!_isPrinting );
+
+	  _fixedFont = save__fixedFont;
+
+	  //reset back to single-width, single-height _lines
+	  paint.setWorldMatrix (textScale.inverted (), true);
+
+	  if (y < _lineProperties.size () - 1)
+	    {
+	      //double-height _lines are represented by two adjacent _lines
+	      //containing the same characters
+	      //both _lines will have the LINE_DOUBLEHEIGHT attribute.
+	      //If the current line has the LINE_DOUBLEHEIGHT attribute,
+	      //we can therefore skip the next line
+	      if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+		y++;
+	    }
+
+	  x += len - 1;
+	}
+    }
+}
+
+void
+TerminalDisplay::blinkEvent ()
+{
+  if (!_allowBlinkingText)
+    return;
+
+  _blinking = !_blinking;
+
+  //TODO:  Optimize to only repaint the areas of the widget
+  // where there is blinking text
+  // rather than repainting the whole widget.
+  update ();
+}
+
+QRect
+TerminalDisplay::imageToWidget (const QRect & imageArea) const
+{
+  QRect result;
+  result.setLeft (_leftMargin + _fontWidth * imageArea.left ());
+  result.setTop (_topMargin + _fontHeight * imageArea.top ());
+  result.setWidth (_fontWidth * imageArea.width ());
+  result.setHeight (_fontHeight * imageArea.height ());
+
+  return result;
+}
+
+void
+TerminalDisplay::updateCursor ()
+{
+  QRect cursorRect = imageToWidget (QRect (cursorPosition (), QSize (1, 1)));
+  update (cursorRect);
+}
+
+void
+TerminalDisplay::blinkCursorEvent ()
+{
+  _cursorBlinking = !_cursorBlinking;
+  updateCursor ();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                  Resizing                                 */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void
+TerminalDisplay::resizeEvent (QResizeEvent *)
+{
+  updateImageSize ();
+}
+
+void
+TerminalDisplay::propagateSize ()
+{
+  if (_isFixedSize)
+    {
+      setSize (_columns, _lines);
+      QWidget::setFixedSize (sizeHint ());
+      parentWidget ()->adjustSize ();
+      parentWidget ()->setFixedSize (parentWidget ()->sizeHint ());
+      return;
+    }
+  if (_image)
+    updateImageSize ();
+}
+
+void
+TerminalDisplay::updateImageSize ()
+{
+  Character *oldimg = _image;
+  int oldlin = _lines;
+  int oldcol = _columns;
+
+  makeImage ();
+
+  // copy the old image to reduce flicker
+  int lines = qMin (oldlin, _lines);
+  int columns = qMin (oldcol, _columns);
+
+  if (oldimg)
+    {
+      for (int line = 0; line < lines; line++)
+	{
+	  memcpy ((void *) &_image[_columns * line],
+		  (void *) &oldimg[oldcol * line],
+		  columns * sizeof (Character));
+	}
+      delete[]oldimg;
+    }
+
+  if (_screenWindow)
+    _screenWindow->setWindowLines (_lines);
+
+  _resizing = (oldlin != _lines) || (oldcol != _columns);
+
+  if (_resizing)
+    {
+      showResizeNotification ();
+      emit changedContentSizeSignal (_contentHeight, _contentWidth);	// expose resizeEvent
+    }
+
+  _resizing = false;
+}
+
+//showEvent and hideEvent are reimplemented here so that it appears to other classes that the 
+//display has been resized when the display is hidden or shown.
+//
+//TODO: Perhaps it would be better to have separate signals for show and hide instead of using
+//the same signal as the one for a content size change 
+void
+TerminalDisplay::showEvent (QShowEvent *)
+{
+  emit changedContentSizeSignal (_contentHeight, _contentWidth);
+}
+
+void
+TerminalDisplay::hideEvent (QHideEvent *)
+{
+  emit changedContentSizeSignal (_contentHeight, _contentWidth);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Scrollbar                                  */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void
+TerminalDisplay::scrollBarPositionChanged (int)
+{
+  if (!_screenWindow)
+    return;
+
+  _screenWindow->scrollTo (_scrollBar->value ());
+
+  // if the thumb has been moved to the bottom of the _scrollBar then set
+  // the display to automatically track new output,
+  // that is, scroll down automatically
+  // to how new _lines as they are added
+  const bool atEndOfOutput = (_scrollBar->value () == _scrollBar->maximum ());
+  _screenWindow->setTrackOutput (atEndOfOutput);
+
+  updateImage ();
+}
+
+void
+TerminalDisplay::setScroll (int cursor, int slines)
+{
+  // update _scrollBar if the range or value has changed,
+  // otherwise return
+  //
+  // setting the range or value of a _scrollBar will always trigger
+  // a repaint, so it should be avoided if it is not necessary
+  if (_scrollBar->minimum () == 0 &&
+      _scrollBar->maximum () == (slines - _lines) &&
+      _scrollBar->value () == cursor)
+    {
+      return;
+    }
+
+  disconnect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	      SLOT (scrollBarPositionChanged (int)));
+  _scrollBar->setRange (0, slines - _lines);
+  _scrollBar->setSingleStep (1);
+  _scrollBar->setPageStep (_lines);
+  _scrollBar->setValue (cursor);
+  connect (_scrollBar, SIGNAL (valueChanged (int)), this,
+	   SLOT (scrollBarPositionChanged (int)));
+}
+
+void
+TerminalDisplay::setScrollBarPosition (ScrollBarPosition position)
+{
+  if (_scrollbarLocation == position)
+    return;
+
+  if (position == NoScrollBar)
+    _scrollBar->hide ();
+  else
+    _scrollBar->show ();
+
+  _topMargin = _leftMargin = 1;
+  _scrollbarLocation = position;
+
+  propagateSize ();
+  update ();
+}
+
+void
+TerminalDisplay::mousePressEvent (QMouseEvent * ev)
+{
+  if (_possibleTripleClick && (ev->button () == Qt::LeftButton))
+    {
+      mouseTripleClickEvent (ev);
+      return;
+    }
+
+  if (!contentsRect ().contains (ev->pos ()))
+    return;
+
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+  QPoint pos = QPoint (charColumn, charLine);
+
+  if (ev->button () == Qt::LeftButton)
+    {
+      _lineSelectionMode = false;
+      _wordSelectionMode = false;
+
+      emit isBusySelecting (true);	// Keep it steady...
+      // Drag only when the Control key is hold
+      bool selected = false;
+
+      // The receiver of the testIsSelected() signal will adjust
+      // 'selected' accordingly.
+      //emit testIsSelected(pos.x(), pos.y(), selected);
+
+      selected = _screenWindow->isSelected (pos.x (), pos.y ());
+
+      if ((!_ctrlDrag || ev->modifiers () & Qt::ControlModifier) && selected)
+	{
+	  // The user clicked inside selected text
+	  dragInfo.state = diPending;
+	  dragInfo.start = ev->pos ();
+	}
+      else
+	{
+	  // No reason to ever start a drag event
+	  dragInfo.state = diNone;
+
+	  _preserveLineBreaks = !((ev->modifiers () & Qt::ControlModifier)
+				  && !(ev->modifiers () & Qt::AltModifier));
+	  _columnSelectionMode = (ev->modifiers () & Qt::AltModifier)
+	    && (ev->modifiers () & Qt::ControlModifier);
+
+	  if (_mouseMarks || (ev->modifiers () & Qt::ShiftModifier))
+	    {
+	      _screenWindow->clearSelection ();
+
+	      //emit clearSelectionSignal();
+	      pos.ry () += _scrollBar->value ();
+	      _iPntSel = _pntSel = pos;
+	      _actSel = 1;	// left mouse button pressed but nothing selected yet.
+
+	    }
+	  else
+	    {
+	      emit mouseSignal (0, charColumn + 1,
+				charLine + 1 + _scrollBar->value () -
+				_scrollBar->maximum (), 0);
+	    }
+	}
+    }
+  else if (ev->button () == Qt::MidButton)
+    {
+      if (_mouseMarks
+	  || (!_mouseMarks && (ev->modifiers () & Qt::ShiftModifier)))
+	emitSelection (true, ev->modifiers () & Qt::ControlModifier);
+      else
+	emit mouseSignal (1, charColumn + 1,
+			  charLine + 1 + _scrollBar->value () -
+			  _scrollBar->maximum (), 0);
+    }
+  else if (ev->button () == Qt::RightButton)
+    {
+      if (_mouseMarks || (ev->modifiers () & Qt::ShiftModifier))
+	emit configureRequest (ev->pos ());
+      else
+      emit mouseSignal (2, charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
+    }
+}
+
+QList < QAction * >TerminalDisplay::filterActions (const QPoint & position)
+{
+  int
+    charLine,
+    charColumn;
+  getCharacterPosition (position, charLine, charColumn);
+
+  Filter::HotSpot * spot = _filterChain->hotSpotAt (charLine, charColumn);
+
+  return spot ? spot->actions () : QList < QAction * >();
+}
+
+void
+TerminalDisplay::mouseMoveEvent (QMouseEvent * ev)
+{
+  int charLine = 0;
+  int charColumn = 0;
+  int scrollBarWidth =
+    (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width () : 0;
+
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  // handle filters
+  // change link hot-spot appearance on mouse-over
+  Filter::HotSpot * spot = _filterChain->hotSpotAt (charLine, charColumn);
+  if (spot && spot->type () == Filter::HotSpot::Link)
+    {
+      QRegion previousHotspotArea = _mouseOverHotspotArea;
+      _mouseOverHotspotArea = QRegion ();
+      QRect r;
+      if (spot->startLine () == spot->endLine ())
+	{
+	  r.setCoords (spot->startColumn () * _fontWidth + scrollBarWidth,
+		       spot->startLine () * _fontHeight,
+		       spot->endColumn () * _fontWidth + scrollBarWidth,
+		       (spot->endLine () + 1) * _fontHeight - 1);
+	  _mouseOverHotspotArea |= r;
+	}
+      else
+	{
+	  r.setCoords (spot->startColumn () * _fontWidth + scrollBarWidth,
+		       spot->startLine () * _fontHeight,
+		       _columns * _fontWidth - 1 + scrollBarWidth,
+		       (spot->startLine () + 1) * _fontHeight);
+	  _mouseOverHotspotArea |= r;
+	  for (int line = spot->startLine () + 1; line < spot->endLine ();
+	       line++)
+	    {
+	      r.setCoords (0 * _fontWidth + scrollBarWidth,
+			   line * _fontHeight,
+			   _columns * _fontWidth + scrollBarWidth,
+			   (line + 1) * _fontHeight);
+	      _mouseOverHotspotArea |= r;
+	    }
+	  r.setCoords (0 * _fontWidth + scrollBarWidth,
+		       spot->endLine () * _fontHeight,
+		       spot->endColumn () * _fontWidth + scrollBarWidth,
+		       (spot->endLine () + 1) * _fontHeight);
+	  _mouseOverHotspotArea |= r;
+	}
+      // display tooltips when mousing over links
+      // TODO: Extend this to work with filter types other than links
+      const QString & tooltip = spot->tooltip ();
+      if (!tooltip.isEmpty ())
+	{
+	  QToolTip::showText (mapToGlobal (ev->pos ()), tooltip, this,
+			      _mouseOverHotspotArea.boundingRect ());
+	}
+
+      update (_mouseOverHotspotArea | previousHotspotArea);
+    }
+  else if (!_mouseOverHotspotArea.isEmpty ())
+    {
+      update (_mouseOverHotspotArea);
+      // set hotspot area to an invalid rectangle
+      _mouseOverHotspotArea = QRegion ();
+    }
+
+  // for auto-hiding the cursor, we need mouseTracking
+  if (ev->buttons () == Qt::NoButton)
+    return;
+
+  // if the terminal is interested in mouse movements
+  // then emit a mouse movement signal, unless the shift
+  // key is being held down, which overrides this.
+  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
+    {
+      int button = 3;
+      if (ev->buttons () & Qt::LeftButton)
+	button = 0;
+      if (ev->buttons () & Qt::MidButton)
+	button = 1;
+      if (ev->buttons () & Qt::RightButton)
+	button = 2;
+
+
+      emit mouseSignal (button,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 1);
+
+      return;
+    }
+
+  if (dragInfo.state == diPending)
+    {
+      // we had a mouse down, but haven't confirmed a drag yet
+      // if the mouse has moved sufficiently, we will confirm
+
+      int distance = 10;	//KGlobalSettings::dndEventDelay();
+      if (ev->x () > dragInfo.start.x () + distance
+	  || ev->x () < dragInfo.start.x () - distance
+	  || ev->y () > dragInfo.start.y () + distance
+	  || ev->y () < dragInfo.start.y () - distance)
+	{
+	  // we've left the drag square, we can start a real drag operation now
+	  emit isBusySelecting (false);	// Ok.. we can breath again.
+
+	  _screenWindow->clearSelection ();
+	  doDrag ();
+	}
+      return;
+    }
+  else if (dragInfo.state == diDragging)
+    {
+      // this isn't technically needed because mouseMoveEvent is suppressed during
+      // Qt drag operations, replaced by dragMoveEvent
+      return;
+    }
+
+  if (_actSel == 0)
+    return;
+
+  // don't extend selection while pasting
+  if (ev->buttons () & Qt::MidButton)
+    return;
+
+  extendSelection (ev->pos ());
+}
+
+void
+TerminalDisplay::extendSelection (const QPoint & position)
+{
+  QPoint pos = position;
+
+  if (!_screenWindow)
+    return;
+
+  //if ( !contentsRect().contains(ev->pos()) ) return;
+  QPoint tL = contentsRect ().topLeft ();
+  int tLx = tL.x ();
+  int tLy = tL.y ();
+  int scroll = _scrollBar->value ();
+
+  // we're in the process of moving the mouse with the left button pressed
+  // the mouse cursor will kept caught within the bounds of the text in
+  // this widget.
+
+  int linesBeyondWidget = 0;
+
+  QRect textBounds (tLx + _leftMargin,
+		    tLy + _topMargin,
+		    _usedColumns * _fontWidth - 1,
+		    _usedLines * _fontHeight - 1);
+
+  // Adjust position within text area bounds.
+  QPoint oldpos = pos;
+
+  pos.setX (qBound (textBounds.left (), pos.x (), textBounds.right ()));
+  pos.setY (qBound (textBounds.top (), pos.y (), textBounds.bottom ()));
+
+  if (oldpos.y () > textBounds.bottom ())
+    {
+      linesBeyondWidget = (oldpos.y () - textBounds.bottom ()) / _fontHeight;
+      _scrollBar->setValue (_scrollBar->value () + linesBeyondWidget + 1);	// scrollforward
+    }
+  if (oldpos.y () < textBounds.top ())
+    {
+      linesBeyondWidget = (textBounds.top () - oldpos.y ()) / _fontHeight;
+      _scrollBar->setValue (_scrollBar->value () - linesBeyondWidget - 1);	// history
+    }
+
+  int charColumn = 0;
+  int charLine = 0;
+  getCharacterPosition (pos, charLine, charColumn);
+
+  QPoint here = QPoint (charColumn, charLine);	//QPoint((pos.x()-tLx-_leftMargin+(_fontWidth/2))/_fontWidth,(pos.y()-tLy-_topMargin)/_fontHeight);
+  QPoint ohere;
+  QPoint _iPntSelCorr = _iPntSel;
+  _iPntSelCorr.ry () -= _scrollBar->value ();
+  QPoint _pntSelCorr = _pntSel;
+  _pntSelCorr.ry () -= _scrollBar->value ();
+  bool swapping = false;
+
+  if (_wordSelectionMode)
+    {
+      // Extend to word boundaries
+      int i;
+      QChar selClass;
+
+      bool left_not_right = (here.y () < _iPntSelCorr.y () ||
+			     (here.y () == _iPntSelCorr.y ()
+			      && here.x () < _iPntSelCorr.x ()));
+      bool old_left_not_right = (_pntSelCorr.y () < _iPntSelCorr.y ()
+				 || (_pntSelCorr.y () == _iPntSelCorr.y ()
+				     && _pntSelCorr.x () <
+				     _iPntSelCorr.x ()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+      i = loc (left.x (), left.y ());
+      if (i >= 0 && i <= _imageSize)
+	{
+	  selClass = charClass (_image[i].character);
+	  while (((left.x () > 0)
+		  || (left.y () > 0
+		      && (_lineProperties[left.y () - 1] & LINE_WRAPPED)))
+		 && charClass (_image[i - 1].character) == selClass)
+	    {
+	      i--;
+	      if (left.x () > 0)
+		left.rx ()--;
+	      else
+		{
+		  left.rx () = _usedColumns - 1;
+		  left.ry ()--;
+		}
+	    }
+	}
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      i = loc (right.x (), right.y ());
+      if (i >= 0 && i <= _imageSize)
+	{
+	  selClass = charClass (_image[i].character);
+	  while (((right.x () < _usedColumns - 1)
+		  || (right.y () < _usedLines - 1
+		      && (_lineProperties[right.y ()] & LINE_WRAPPED)))
+		 && charClass (_image[i + 1].character) == selClass)
+	    {
+	      i++;
+	      if (right.x () < _usedColumns - 1)
+		right.rx ()++;
+	      else
+		{
+		  right.rx () = 0;
+		  right.ry ()++;
+		}
+	    }
+	}
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right)
+	{
+	  here = left;
+	  ohere = right;
+	}
+      else
+	{
+	  here = right;
+	  ohere = left;
+	}
+      ohere.rx ()++;
+    }
+
+  if (_lineSelectionMode)
+    {
+      // Extend to complete line
+      bool above_not_below = (here.y () < _iPntSelCorr.y ());
+
+      QPoint above = above_not_below ? here : _iPntSelCorr;
+      QPoint below = above_not_below ? _iPntSelCorr : here;
+
+      while (above.y () > 0
+	     && (_lineProperties[above.y () - 1] & LINE_WRAPPED))
+	above.ry ()--;
+      while (below.y () < _usedLines - 1
+	     && (_lineProperties[below.y ()] & LINE_WRAPPED))
+	below.ry ()++;
+
+      above.setX (0);
+      below.setX (_usedColumns - 1);
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (above_not_below)
+	{
+	  here = above;
+	  ohere = below;
+	}
+      else
+	{
+	  here = below;
+	  ohere = above;
+	}
+
+      QPoint newSelBegin = QPoint (ohere.x (), ohere.y ());
+      swapping = !(_tripleSelBegin == newSelBegin);
+      _tripleSelBegin = newSelBegin;
+
+      ohere.rx ()++;
+    }
+
+  int offset = 0;
+  if (!_wordSelectionMode && !_lineSelectionMode)
+    {
+      int i;
+      QChar selClass;
+
+      bool left_not_right = (here.y () < _iPntSelCorr.y () ||
+			     (here.y () == _iPntSelCorr.y ()
+			      && here.x () < _iPntSelCorr.x ()));
+      bool old_left_not_right = (_pntSelCorr.y () < _iPntSelCorr.y ()
+				 || (_pntSelCorr.y () == _iPntSelCorr.y ()
+				     && _pntSelCorr.x () <
+				     _iPntSelCorr.x ()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      if (right.x () > 0 && !_columnSelectionMode)
+	{
+	  i = loc (right.x (), right.y ());
+	  if (i >= 0 && i <= _imageSize)
+	    {
+	      selClass = charClass (_image[i - 1].character);
+	      /* if (selClass == ' ')
+	         {
+	         while ( right.x() < _usedColumns-1 && charClass(_image[i+1].character) == selClass && (right.y()<_usedLines-1) && 
+	         !(_lineProperties[right.y()] & LINE_WRAPPED))
+	         { i++; right.rx()++; }
+	         if (right.x() < _usedColumns-1)
+	         right = left_not_right ? _iPntSelCorr : here;
+	         else
+	         right.rx()++;  // will be balanced later because of offset=-1;
+	         } */
+	    }
+	}
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right)
+	{
+	  here = left;
+	  ohere = right;
+	  offset = 0;
+	}
+      else
+	{
+	  here = right;
+	  ohere = left;
+	  offset = -1;
+	}
+    }
+
+  if ((here == _pntSelCorr) && (scroll == _scrollBar->value ()))
+    return;			// not moved
+
+  if (here == ohere)
+    return;			// It's not left, it's not right.
+
+  if (_actSel < 2 || swapping)
+    {
+      if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode)
+	{
+	  _screenWindow->setSelectionStart (ohere.x (), ohere.y (), true);
+	}
+      else
+	{
+	  _screenWindow->setSelectionStart (ohere.x () - 1 - offset,
+					    ohere.y (), false);
+	}
+
+    }
+
+  _actSel = 2;			// within selection
+  _pntSel = here;
+  _pntSel.ry () += _scrollBar->value ();
+
+  if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode)
+    {
+      _screenWindow->setSelectionEnd (here.x (), here.y ());
+    }
+  else
+    {
+      _screenWindow->setSelectionEnd (here.x () + offset, here.y ());
+    }
+
+}
+
+void
+TerminalDisplay::mouseReleaseEvent (QMouseEvent * ev)
+{
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  if (ev->button () == Qt::LeftButton)
+    {
+      emit isBusySelecting (false);
+      if (dragInfo.state == diPending)
+	{
+	  // We had a drag event pending but never confirmed.  Kill selection
+	  _screenWindow->clearSelection ();
+	  //emit clearSelectionSignal();
+	}
+      else
+	{
+	  if (_actSel > 1)
+	    {
+	      setSelection (_screenWindow->
+			    selectedText (_preserveLineBreaks));
+	    }
+
+	  _actSel = 0;
+
+	  //FIXME: emits a release event even if the mouse is
+	  //       outside the range. The procedure used in `mouseMoveEvent'
+	  //       applies here, too.
+
+	  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
+	    emit mouseSignal (3,	// release
+			      charColumn + 1,
+			      charLine + 1 + _scrollBar->value () -
+			      _scrollBar->maximum (), 0);
+	}
+      dragInfo.state = diNone;
+    }
+
+
+  if (!_mouseMarks &&
+      ((ev->button () == Qt::RightButton
+	&& !(ev->modifiers () & Qt::ShiftModifier))
+       || ev->button () == Qt::MidButton))
+    {
+      emit mouseSignal (3,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
+    }
+}
+
+void
+TerminalDisplay::getCharacterPosition (const QPoint & widgetPoint, int &line,
+				       int &column) const
+{
+  column =
+    (widgetPoint.x () + _fontWidth / 2 - contentsRect ().left () -
+     _leftMargin) / _fontWidth;
+  line =
+    (widgetPoint.y () - contentsRect ().top () - _topMargin) / _fontHeight;
+
+  if (line < 0)
+    line = 0;
+  if (column < 0)
+    column = 0;
+
+  if (line >= _usedLines)
+    line = _usedLines - 1;
+
+  // the column value returned can be equal to _usedColumns, which
+  // is the position just after the last character displayed in a line.
+  //
+  // this is required so that the user can select characters in the right-most
+  // column (or left-most for right-to-left input)
+  if (column > _usedColumns)
+    column = _usedColumns;
+}
+
+void
+TerminalDisplay::updateLineProperties ()
+{
+  if (!_screenWindow)
+    return;
+
+  _lineProperties = _screenWindow->getLineProperties ();
+}
+
+void
+TerminalDisplay::mouseDoubleClickEvent (QMouseEvent * ev)
+{
+  if (ev->button () != Qt::LeftButton)
+    return;
+  if (!_screenWindow)
+    return;
+
+  int charLine = 0;
+  int charColumn = 0;
+
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+
+  QPoint pos (charColumn, charLine);
+
+  // pass on double click as two clicks.
+  if (!_mouseMarks && !(ev->modifiers () & Qt::ShiftModifier))
+    {
+      // Send just _ONE_ click event, since the first click of the double click
+      // was already sent by the click handler
+      emit mouseSignal (0, pos.x () + 1, pos.y () + 1 + _scrollBar->value () - _scrollBar->maximum (), 0);	// left button
+      return;
+    }
+
+  _screenWindow->clearSelection ();
+  QPoint bgnSel = pos;
+  QPoint endSel = pos;
+  int i = loc (bgnSel.x (), bgnSel.y ());
+  _iPntSel = bgnSel;
+  _iPntSel.ry () += _scrollBar->value ();
+
+  _wordSelectionMode = true;
+
+  // find word boundaries...
+  QChar selClass = charClass (_image[i].character);
+  {
+    // find the start of the word
+    int x = bgnSel.x ();
+    while (((x > 0)
+	    || (bgnSel.y () > 0
+		&& (_lineProperties[bgnSel.y () - 1] & LINE_WRAPPED)))
+	   && charClass (_image[i - 1].character) == selClass)
+      {
+	i--;
+	if (x > 0)
+	  x--;
+	else
+	  {
+	    x = _usedColumns - 1;
+	    bgnSel.ry ()--;
+	  }
+      }
+
+    bgnSel.setX (x);
+    _screenWindow->setSelectionStart (bgnSel.x (), bgnSel.y (), false);
+
+    // find the end of the word
+    i = loc (endSel.x (), endSel.y ());
+    x = endSel.x ();
+    while (((x < _usedColumns - 1)
+	    || (endSel.y () < _usedLines - 1
+		&& (_lineProperties[endSel.y ()] & LINE_WRAPPED)))
+	   && charClass (_image[i + 1].character) == selClass)
+      {
+	i++;
+	if (x < _usedColumns - 1)
+	  x++;
+	else
+	  {
+	    x = 0;
+	    endSel.ry ()++;
+	  }
+      }
+
+    endSel.setX (x);
+
+    // In word selection mode don't select @ (64) if at end of word.
+    if ((QChar (_image[i].character) == '@')
+	&& ((endSel.x () - bgnSel.x ()) > 0))
+      endSel.setX (x - 1);
+
+
+    _actSel = 2;		// within selection
+
+    _screenWindow->setSelectionEnd (endSel.x (), endSel.y ());
+
+    setSelection (_screenWindow->selectedText (_preserveLineBreaks));
+  }
+
+  _possibleTripleClick = true;
+
+  QTimer::singleShot (QApplication::doubleClickInterval (), this,
+		      SLOT (tripleClickTimeout ()));
+}
+
+void
+TerminalDisplay::wheelEvent (QWheelEvent * ev)
+{
+  if (ev->orientation () != Qt::Vertical)
+    return;
+
+  // if the terminal program is not interested mouse events
+  // then send the event to the scrollbar if the slider has room to move
+  // or otherwise send simulated up / down key presses to the terminal program
+  // for the benefit of programs such as 'less'
+  if (_mouseMarks)
+    {
+      bool canScroll = _scrollBar->maximum () > 0;
+      if (canScroll)
+	_scrollBar->event (ev);
+      else
+	{
+	  // assume that each Up / Down key event will cause the terminal application
+	  // to scroll by one line.
+	  //
+	  // to get a reasonable scrolling speed, scroll by one line for every 5 degrees
+	  // of mouse wheel rotation.  Mouse wheels typically move in steps of 15 degrees,
+	  // giving a scroll of 3 lines
+	  int key = ev->delta () > 0 ? Qt::Key_Up : Qt::Key_Down;
+
+	  // QWheelEvent::delta() gives rotation in eighths of a degree
+	  int wheelDegrees = ev->delta () / 8;
+	  int linesToScroll = abs (wheelDegrees) / 5;
+
+	  QKeyEvent keyScrollEvent (QEvent::KeyPress, key, Qt::NoModifier);
+
+	  for (int i = 0; i < linesToScroll; i++)
+	    emit keyPressedSignal (&keyScrollEvent);
+	}
+    }
+  else
+    {
+      // terminal program wants notification of mouse activity
+
+      int charLine;
+      int charColumn;
+      getCharacterPosition (ev->pos (), charLine, charColumn);
+
+      emit mouseSignal (ev->delta () > 0 ? 4 : 5,
+			charColumn + 1,
+			charLine + 1 + _scrollBar->value () -
+			_scrollBar->maximum (), 0);
+    }
+}
+
+void
+TerminalDisplay::tripleClickTimeout ()
+{
+  _possibleTripleClick = false;
+}
+
+void
+TerminalDisplay::mouseTripleClickEvent (QMouseEvent * ev)
+{
+  if (!_screenWindow)
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition (ev->pos (), charLine, charColumn);
+  _iPntSel = QPoint (charColumn, charLine);
+
+  _screenWindow->clearSelection ();
+
+  _lineSelectionMode = true;
+  _wordSelectionMode = false;
+
+  _actSel = 2;			// within selection
+  emit isBusySelecting (true);	// Keep it steady...
+
+  while (_iPntSel.y () > 0
+	 && (_lineProperties[_iPntSel.y () - 1] & LINE_WRAPPED))
+    _iPntSel.ry ()--;
+
+  if (_tripleClickMode == SelectForwardsFromCursor)
+    {
+      // find word boundary start
+      int i = loc (_iPntSel.x (), _iPntSel.y ());
+      QChar selClass = charClass (_image[i].character);
+      int x = _iPntSel.x ();
+
+      while (((x > 0) ||
+	      (_iPntSel.y () > 0
+	       && (_lineProperties[_iPntSel.y () - 1] & LINE_WRAPPED)))
+	     && charClass (_image[i - 1].character) == selClass)
+	{
+	  i--;
+	  if (x > 0)
+	    x--;
+	  else
+	    {
+	      x = _columns - 1;
+	      _iPntSel.ry ()--;
+	    }
+	}
+
+      _screenWindow->setSelectionStart (x, _iPntSel.y (), false);
+      _tripleSelBegin = QPoint (x, _iPntSel.y ());
+    }
+  else if (_tripleClickMode == SelectWholeLine)
+    {
+      _screenWindow->setSelectionStart (0, _iPntSel.y (), false);
+      _tripleSelBegin = QPoint (0, _iPntSel.y ());
+    }
+
+  while (_iPntSel.y () < _lines - 1
+	 && (_lineProperties[_iPntSel.y ()] & LINE_WRAPPED))
+    _iPntSel.ry ()++;
+
+  _screenWindow->setSelectionEnd (_columns - 1, _iPntSel.y ());
+
+  setSelection (_screenWindow->selectedText (_preserveLineBreaks));
+
+  _iPntSel.ry () += _scrollBar->value ();
+}
+
+
+bool
+TerminalDisplay::focusNextPrevChild (bool next)
+{
+  if (next)
+    return false;		// This disables changing the active part in konqueror
+  // when pressing Tab
+  return QWidget::focusNextPrevChild (next);
+}
+
+
+QChar
+TerminalDisplay::charClass (QChar qch) const
+{
+  if (qch.isSpace ())
+    return ' ';
+
+  if (qch.isLetterOrNumber ()
+      || _wordCharacters.contains (qch, Qt::CaseInsensitive))
+    return 'a';
+
+  return qch;
+}
+
+void
+TerminalDisplay::setWordCharacters (const QString & wc)
+{
+  _wordCharacters = wc;
+}
+
+void
+TerminalDisplay::setUsesMouse (bool on)
+{
+  _mouseMarks = on;
+  setCursor (_mouseMarks ? Qt::IBeamCursor : Qt::ArrowCursor);
+}
+
+bool
+TerminalDisplay::usesMouse () const
+{
+  return _mouseMarks;
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                               Clipboard                                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+#undef KeyPress
+
+void
+TerminalDisplay::emitSelection (bool useXselection, bool appendReturn)
+{
+  if (!_screenWindow)
+    return;
+
+  // Paste Clipboard by simulating keypress events
+  QString text =
+    QApplication::clipboard ()->
+    text (useXselection ? QClipboard::Selection : QClipboard::Clipboard);
+  if (appendReturn)
+    text.append ("\r");
+  if (!text.isEmpty ())
+    {
+      text.replace ('\n', '\r');
+      QKeyEvent e (QEvent::KeyPress, 0, Qt::NoModifier, text);
+      emit keyPressedSignal (&e);	// expose as a big fat keypress event
+
+      _screenWindow->clearSelection ();
+    }
+}
+
+void
+TerminalDisplay::setSelection (const QString & t)
+{
+  QApplication::clipboard ()->setText (t, QClipboard::Selection);
+}
+
+void
+TerminalDisplay::copyClipboard ()
+{
+  if (!_screenWindow)
+    return;
+
+  QString text = _screenWindow->selectedText (_preserveLineBreaks);
+  if (!text.isEmpty ())
+    QApplication::clipboard ()->setText (text);
+}
+
+void
+TerminalDisplay::pasteClipboard ()
+{
+  emitSelection (false, false);
+}
+
+void
+TerminalDisplay::pasteSelection ()
+{
+  emitSelection (true, false);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Keyboard                                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void
+TerminalDisplay::setFlowControlWarningEnabled (bool enable)
+{
+  _flowControlWarningEnabled = enable;
+
+  // if the dialog is currently visible and the flow control warning has 
+  // been disabled then hide the dialog
+  if (!enable)
+    outputSuspended (false);
+}
+
+void
+TerminalDisplay::keyPressEvent (QKeyEvent * event)
+{
+  bool emitKeyPressSignal = true;
+
+  if (event->modifiers () == Qt::ControlModifier)
+    {
+      switch (event->key ())
+	{
+	case Qt::Key_C:
+	  copyClipboard ();
+	  break;
+	case Qt::Key_V:
+	  pasteClipboard ();
+	  break;
+	};
+    }
+  else if (event->modifiers () == Qt::ShiftModifier)
+    {
+      bool update = true;
+
+      if (event->key () == Qt::Key_PageUp)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollPages, -1);
+	}
+      else if (event->key () == Qt::Key_PageDown)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollPages, 1);
+	}
+      else if (event->key () == Qt::Key_Up)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollLines, -1);
+	}
+      else if (event->key () == Qt::Key_Down)
+	{
+	  _screenWindow->scrollBy (ScreenWindow::ScrollLines, 1);
+	}
+      else
+	update = false;
+
+      if (update)
+	{
+	  _screenWindow->setTrackOutput (_screenWindow->atEndOfOutput ());
+
+	  updateLineProperties ();
+	  updateImage ();
+
+	  // do not send key press to terminal
+	  emitKeyPressSignal = false;
+	}
+    }
+
+  _actSel = 0;			// Key stroke implies a screen update, so TerminalDisplay won't
+  // know where the current selection is.
+
+  if (_hasBlinkingCursor)
+    {
+      _blinkCursorTimer->start (QApplication::cursorFlashTime () / 2);
+      if (_cursorBlinking)
+	blinkCursorEvent ();
+      else
+	_cursorBlinking = false;
+    }
+
+  if (emitKeyPressSignal)
+    emit keyPressedSignal (event);
+
+  event->accept ();
+}
+
+void
+TerminalDisplay::inputMethodEvent (QInputMethodEvent * event)
+{
+  QKeyEvent keyEvent (QEvent::KeyPress, 0,
+		      (Qt::KeyboardModifiers) Qt::NoModifier,
+		      event->commitString ());
+  emit keyPressedSignal (&keyEvent);
+
+  _inputMethodData.preeditString = event->preeditString ();
+  update (preeditRect () | _inputMethodData.previousPreeditRect);
+
+  event->accept ();
+}
+
+QVariant
+TerminalDisplay::inputMethodQuery (Qt::InputMethodQuery query) const
+{
+  const QPoint cursorPos =
+    _screenWindow ? _screenWindow->cursorPosition () : QPoint (0, 0);
+  switch (query)
+    {
+    case Qt::ImMicroFocus:
+      return imageToWidget (QRect (cursorPos.x (), cursorPos.y (), 1, 1));
+      break;
+    case Qt::ImFont:
+      return font ();
+      break;
+    case Qt::ImCursorPosition:
+      // return the cursor position within the current line
+      return cursorPos.x ();
+      break;
+    case Qt::ImSurroundingText:
+      {
+	// return the text from the current line
+	QString lineText;
+	QTextStream stream (&lineText);
+	PlainTextDecoder decoder;
+	decoder.begin (&stream);
+	decoder.decodeLine (&_image[loc (0, cursorPos.y ())], _usedColumns,
+			    _lineProperties[cursorPos.y ()]);
+	decoder.end ();
+	return lineText;
+      }
+      break;
+    case Qt::ImCurrentSelection:
+      return QString ();
+      break;
+    default:
+      break;
+    }
+
+  return QVariant ();
+}
+
+bool
+TerminalDisplay::handleShortcutOverrideEvent (QKeyEvent * keyEvent)
+{
+  int modifiers = keyEvent->modifiers ();
+
+  //  When a possible shortcut combination is pressed, 
+  //  emit the overrideShortcutCheck() signal to allow the host
+  //  to decide whether the terminal should override it or not.
+  if (modifiers != Qt::NoModifier)
+    {
+      int modifierCount = 0;
+      unsigned int currentModifier = Qt::ShiftModifier;
+
+      while (currentModifier <= Qt::KeypadModifier)
+	{
+	  if (modifiers & currentModifier)
+	    modifierCount++;
+	  currentModifier <<= 1;
+	}
+      if (modifierCount < 2)
+	{
+	  bool override = false;
+	  emit overrideShortcutCheck (keyEvent, override);
+	  if (override)
+	    {
+	      keyEvent->accept ();
+	      return true;
+	    }
+	}
+    }
+
+  // Override any of the following shortcuts because
+  // they are needed by the terminal
+  int keyCode = keyEvent->key () | modifiers;
+  switch (keyCode)
+    {
+      // list is taken from the QLineEdit::event() code
+    case Qt::Key_Tab:
+    case Qt::Key_Delete:
+    case Qt::Key_Home:
+    case Qt::Key_End:
+    case Qt::Key_Backspace:
+    case Qt::Key_Left:
+    case Qt::Key_Right:
+      keyEvent->accept ();
+      return true;
+    }
+  return false;
+}
+
+bool
+TerminalDisplay::event (QEvent * event)
+{
+  bool eventHandled = false;
+  switch (event->type ())
+    {
+    case QEvent::ShortcutOverride:
+      eventHandled = handleShortcutOverrideEvent ((QKeyEvent *) event);
+      break;
+    case QEvent::PaletteChange:
+    case QEvent::ApplicationPaletteChange:
+      _scrollBar->setPalette (QApplication::palette ());
+      break;
+    default:
+      break;
+    }
+  return eventHandled ? true : QWidget::event (event);
+}
+
+void
+TerminalDisplay::setBellMode (int mode)
+{
+  _bellMode = mode;
+}
+
+void
+TerminalDisplay::enableBell ()
+{
+  _allowBell = true;
+}
+
+void
+TerminalDisplay::bell (const QString & message)
+{
+  Q_UNUSED (message);
+  if (_bellMode == NoBell)
+    return;
+
+  //limit the rate at which bells can occur
+  //...mainly for sound effects where rapid bells in sequence
+  //produce a horrible noise
+  if (_allowBell)
+    {
+      _allowBell = false;
+      QTimer::singleShot (500, this, SLOT (enableBell ()));
+
+      if (_bellMode == SystemBeepBell)
+	{
+	  // TODO: This will need added back in at some point
+	  //KNotification::beep();
+	}
+      else if (_bellMode == NotifyBell)
+	{
+	  // TODO: This will need added back in at some point
+	  //KNotification::event("BellVisible", message,QPixmap(),this);
+	}
+      else if (_bellMode == VisualBell)
+	{
+	  swapColorTable ();
+	  QTimer::singleShot (200, this, SLOT (swapColorTable ()));
+	}
+    }
+}
+
+void
+TerminalDisplay::swapColorTable ()
+{
+  ColorEntry color = _colorTable[1];
+  _colorTable[1] = _colorTable[0];
+  _colorTable[0] = color;
+  _colorsInverted = !_colorsInverted;
+  update ();
+}
+
+void
+TerminalDisplay::clearImage ()
+{
+  // We initialize _image[_imageSize] too. See makeImage()
+  for (int i = 0; i <= _imageSize; i++)
+    {
+      _image[i].character = ' ';
+      _image[i].foregroundColor = CharacterColor (COLOR_SPACE_DEFAULT,
+						  DEFAULT_FORE_COLOR);
+      _image[i].backgroundColor = CharacterColor (COLOR_SPACE_DEFAULT,
+						  DEFAULT_BACK_COLOR);
+      _image[i].rendition = DEFAULT_RENDITION;
+    }
+}
+
+void
+TerminalDisplay::calcGeometry ()
+{
+  _scrollBar->resize (_scrollBar->sizeHint ().width (),
+		      contentsRect ().height ());
+  switch (_scrollbarLocation)
+    {
+    case NoScrollBar:
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth = contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN;
+      break;
+    case ScrollBarLeft:
+      _leftMargin = DEFAULT_LEFT_MARGIN + _scrollBar->width ();
+      _contentWidth =
+	contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN -
+	_scrollBar->width ();
+      _scrollBar->move (contentsRect ().topLeft ());
+      break;
+    case ScrollBarRight:
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth =
+	contentsRect ().width () - 2 * DEFAULT_LEFT_MARGIN -
+	_scrollBar->width ();
+      _scrollBar->move (contentsRect ().topRight () -
+			QPoint (_scrollBar->width () - 1, 0));
+      break;
+    }
+
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _contentHeight =
+    contentsRect ().height () - 2 * DEFAULT_TOP_MARGIN + /* mysterious */ 1;
+
+  if (!_isFixedSize)
+    {
+      // ensure that display is always at least one column wide
+      _columns = qMax (1, _contentWidth / _fontWidth);
+      _usedColumns = qMin (_usedColumns, _columns);
+
+      // ensure that display is always at least one line high
+      _lines = qMax (1, _contentHeight / _fontHeight);
+      _usedLines = qMin (_usedLines, _lines);
+    }
+}
+
+void
+TerminalDisplay::makeImage ()
+{
+  calcGeometry ();
+
+  // confirm that array will be of non-zero size, since the painting code
+  // assumes a non-zero array length
+  Q_ASSERT (_lines > 0 && _columns > 0);
+  Q_ASSERT (_usedLines <= _lines && _usedColumns <= _columns);
+
+  _imageSize = _lines * _columns;
+
+  // We over-commit one character so that we can be more relaxed in dealing with
+  // certain boundary conditions: _image[_imageSize] is a valid but unused position
+  _image = new Character[_imageSize + 1];
+
+  clearImage ();
+}
+
+// calculate the needed size, this must be synced with calcGeometry()
+void
+TerminalDisplay::setSize (int columns, int lines)
+{
+  int scrollBarWidth =
+    _scrollBar->isHidden ()? 0 : _scrollBar->sizeHint ().width ();
+  int horizontalMargin = 2 * DEFAULT_LEFT_MARGIN;
+  int verticalMargin = 2 * DEFAULT_TOP_MARGIN;
+
+  QSize newSize =
+    QSize (horizontalMargin + scrollBarWidth + (columns * _fontWidth),
+	   verticalMargin + (lines * _fontHeight));
+
+  if (newSize != size ())
+    {
+      _size = newSize;
+      updateGeometry ();
+    }
+}
+
+void
+TerminalDisplay::setFixedSize (int cols, int lins)
+{
+  _isFixedSize = true;
+
+  //ensure that display is at least one line by one column in size
+  _columns = qMax (1, cols);
+  _lines = qMax (1, lins);
+  _usedColumns = qMin (_usedColumns, _columns);
+  _usedLines = qMin (_usedLines, _lines);
+
+  if (_image)
+    {
+      delete[]_image;
+      makeImage ();
+    }
+  setSize (cols, lins);
+  QWidget::setFixedSize (_size);
+}
+
+QSize
+TerminalDisplay::sizeHint () const
+{
+  return _size;
+}
+
+
+/* --------------------------------------------------------------------- */
+/*                                                                       */
+/* Drag & Drop                                                           */
+/*                                                                       */
+/* --------------------------------------------------------------------- */
+
+void
+TerminalDisplay::dragEnterEvent (QDragEnterEvent * event)
+{
+  if (event->mimeData ()->hasFormat ("text/plain"))
+    event->acceptProposedAction ();
+}
+
+void
+TerminalDisplay::dropEvent (QDropEvent * event)
+{
+  //KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
+
+  QString dropText;
+  /*
+     if (!urls.isEmpty()) 
+     {
+     for ( int i = 0 ; i < urls.count() ; i++ ) 
+     {
+     KUrl url = KIO::NetAccess::mostLocalUrl( urls[i] , 0 );
+     QString urlText;
+
+     if (url.isLocalFile())
+     urlText = url.path(); 
+     else
+     urlText = url.url();
+
+     // in future it may be useful to be able to insert file names with drag-and-drop
+     // without quoting them (this only affects paths with spaces in) 
+     urlText = KShell::quoteArg(urlText);
+
+     dropText += urlText;
+
+     if ( i != urls.count()-1 ) 
+     dropText += ' ';
+     }
+     }
+     else 
+     {
+     dropText = event->mimeData()->text();
+     }
+   */
+
+  if (event->mimeData ()->hasFormat ("text/plain"))
+    {
+      emit sendStringToEmu (dropText.toLocal8Bit ());
+    }
+}
+
+void
+TerminalDisplay::doDrag ()
+{
+  dragInfo.state = diDragging;
+  dragInfo.dragObject = new QDrag (this);
+  QMimeData *mimeData = new QMimeData;
+  mimeData->setText (QApplication::clipboard ()->
+		     text (QClipboard::Selection));
+  dragInfo.dragObject->setMimeData (mimeData);
+  dragInfo.dragObject->start (Qt::CopyAction);
+  // Don't delete the QTextDrag object.  Qt will delete it when it's done with it.
+}
+
+void
+TerminalDisplay::outputSuspended (bool suspended)
+{
+  //create the label when this function is first called
+  if (!_outputSuspendedLabel)
+    {
+      //This label includes a link to an English language website
+      //describing the 'flow control' (Xon/Xoff) feature found in almost
+      //all terminal emulators.
+      //If there isn't a suitable article available in the target language the link
+      //can simply be removed.
+      _outputSuspendedLabel = new QLabel (QString ("<qt>Output has been "
+						   "<a href=\"http://en.wikipedia.org/wiki/Flow_control\">suspended</a>"
+						   " by pressing Ctrl+S."
+						   "  Press <b>Ctrl+Q</b> to resume.</qt>"),
+					  this);
+
+      QPalette palette (_outputSuspendedLabel->palette ());
+      //KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
+      _outputSuspendedLabel->setPalette (palette);
+      _outputSuspendedLabel->setAutoFillBackground (true);
+      _outputSuspendedLabel->setBackgroundRole (QPalette::Base);
+      _outputSuspendedLabel->setFont (QApplication::font ());
+      _outputSuspendedLabel->setContentsMargins (5, 5, 5, 5);
+
+      //enable activation of "Xon/Xoff" link in label
+      _outputSuspendedLabel->
+	setTextInteractionFlags (Qt::LinksAccessibleByMouse | Qt::
+				 LinksAccessibleByKeyboard);
+      _outputSuspendedLabel->setOpenExternalLinks (true);
+      _outputSuspendedLabel->setVisible (false);
+
+      _gridLayout->addWidget (_outputSuspendedLabel);
+      _gridLayout->addItem (new QSpacerItem (0, 0, QSizePolicy::Expanding,
+					     QSizePolicy::Expanding), 1, 0);
+
+    }
+
+  _outputSuspendedLabel->setVisible (suspended);
+}
+
+uint
+TerminalDisplay::lineSpacing () const
+{
+  return _lineSpacing;
+}
+
+void
+TerminalDisplay::setLineSpacing (uint i)
+{
+  _lineSpacing = i;
+  setVTFont (font ());		// Trigger an update.
+}
+
+AutoScrollHandler::AutoScrollHandler (QWidget * parent):QObject (parent),
+_timerId (0)
+{
+  //parent->installEventFilter(this);
+}
+
+void
+AutoScrollHandler::timerEvent (QTimerEvent * event)
+{
+  if (event->timerId () != _timerId)
+    return;
+
+  QMouseEvent mouseEvent (QEvent::MouseMove,
+			  widget ()->mapFromGlobal (QCursor::pos ()),
+			  Qt::NoButton, Qt::LeftButton, Qt::NoModifier);
+
+  QApplication::sendEvent (widget (), &mouseEvent);
+}
+
+bool
+AutoScrollHandler::eventFilter (QObject * watched, QEvent * event)
+{
+  Q_ASSERT (watched == parent ());
+  Q_UNUSED (watched);
+
+  QMouseEvent *mouseEvent = (QMouseEvent *) event;
+  switch (event->type ())
+    {
+    case QEvent::MouseMove:
+      {
+	bool mouseInWidget = widget ()->rect ().contains (mouseEvent->pos ());
+
+	if (mouseInWidget)
+	  {
+	    if (_timerId)
+	      killTimer (_timerId);
+	    _timerId = 0;
+	  }
+	else
+	  {
+	    if (!_timerId && (mouseEvent->buttons () & Qt::LeftButton))
+	      _timerId = startTimer (100);
+	  }
+	break;
+      }
+    case QEvent::MouseButtonRelease:
+      if (_timerId && (mouseEvent->buttons () & ~Qt::LeftButton))
+	{
+	  killTimer (_timerId);
+	  _timerId = 0;
+	}
+      break;
+    default:
+      break;
+    };
+
+  return false;
+}
diff --git a/gui/src/terminal/TerminalDisplay.h b/gui/src/terminal/TerminalDisplay.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/TerminalDisplay.h
@@ -0,0 +1,849 @@
+/*
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef TERMINALDISPLAY_H
+#define TERMINALDISPLAY_H
+
+// Qt
+#include <QtGui/QColor>
+#include <QtCore/QPointer>
+#include <QtGui/QWidget>
+
+// Konsole
+#include "Filter.h"
+#include "Character.h"
+
+class QDrag;
+class QDragEnterEvent;
+class QDropEvent;
+class QLabel;
+class QTimer;
+class QEvent;
+class QGridLayout;
+class QKeyEvent;
+class QScrollBar;
+class QShowEvent;
+class QHideEvent;
+class QTimerEvent;
+class QWidget;
+
+extern unsigned short vt100_graphics[32];
+
+class ScreenWindow;
+
+/**
+ * A widget which displays output from a terminal emulation and sends input keypresses and mouse activity
+ * to the terminal.
+ *
+ * When the terminal emulation receives new output from the program running in the terminal, 
+ * it will update the display by calling updateImage().
+ *
+ * TODO More documentation
+ */
+class TerminalDisplay:public QWidget
+{
+Q_OBJECT public:
+    /** Constructs a new terminal display widget with the specified parent. */
+  TerminalDisplay (QWidget * parent = 0);
+  virtual ~ TerminalDisplay ();
+
+    /** Returns the terminal color palette used by the display. */
+  const ColorEntry *colorTable () const;
+    /** Sets the terminal color palette used by the display. */
+  void setColorTable (const ColorEntry table[]);
+    /**
+     * Sets the seed used to generate random colors for the display
+     * (in color schemes that support them).
+     */
+  void setRandomSeed (uint seed);
+    /**
+     * Returns the seed used to generate random colors for the display
+     * (in color schemes that support them).
+     */
+  uint randomSeed () const;
+
+    /** 
+     * This enum describes the location where the scroll bar is positioned in the display widget.
+     */
+  enum ScrollBarPosition
+  {
+	/** Do not show the scroll bar. */
+    NoScrollBar = 0,
+	/** Show the scroll bar on the left side of the display. */
+    ScrollBarLeft = 1,
+	/** Show the scroll bar on the right side of the display. */
+    ScrollBarRight = 2
+  };
+    /** 
+     * Specifies whether the terminal display has a vertical scroll bar, and if so whether it
+     * is shown on the left or right side of the display.
+     */
+  void setScrollBarPosition (ScrollBarPosition position);
+
+    /** 
+     * Sets the current position and range of the display's scroll bar.
+     *
+     * @param cursor The position of the scroll bar's thumb.
+     * @param lines The maximum value of the scroll bar.
+     */
+  void setScroll (int cursor, int lines);
+
+    /** 
+     * Returns the display's filter chain.  When the image for the display is updated,
+     * the text is passed through each filter in the chain.  Each filter can define
+     * hotspots which correspond to certain strings (such as URLs or particular words).
+     * Depending on the type of the hotspots created by the filter ( returned by Filter::Hotspot::type() )
+     * the view will draw visual cues such as underlines on mouse-over for links or translucent
+     * rectangles for markers.
+     *
+     * To add a new filter to the view, call:
+     *      viewWidget->filterChain()->addFilter( filterObject );
+     */
+  FilterChain *filterChain () const;
+
+    /** 
+     * Updates the filters in the display's filter chain.  This will cause
+     * the hotspots to be updated to match the current image.
+     *
+     * WARNING:  This function can be expensive depending on the 
+     * image size and number of filters in the filterChain()
+     *
+     * TODO - This API does not really allow efficient usage.  Revise it so
+     * that the processing can be done in a better way.
+     *
+     * eg:
+     *      - Area of interest may be known ( eg. mouse cursor hovering
+     *      over an area )
+     */
+  void processFilters ();
+
+    /** 
+     * Returns a list of menu actions created by the filters for the content
+     * at the given @p position.
+     */
+    QList < QAction * >filterActions (const QPoint & position);
+
+    /** Returns true if the cursor is set to blink or false otherwise. */
+  bool blinkingCursor ()
+  {
+    return _hasBlinkingCursor;
+  }
+    /** Specifies whether or not the cursor blinks. */
+  void setBlinkingCursor (bool blink);
+
+    /** Specifies whether or not text can blink. */
+  void setBlinkingTextEnabled (bool blink);
+
+  void setCtrlDrag (bool enable)
+  {
+    _ctrlDrag = enable;
+  }
+  bool ctrlDrag ()
+  {
+    return _ctrlDrag;
+  }
+
+    /** 
+     *  This enum describes the methods for selecting text when
+      *  the user triple-clicks within the display. 
+      */
+  enum TripleClickMode
+  {
+	/** Select the whole line underneath the cursor. */
+    SelectWholeLine,
+	/** Select from the current cursor position to the end of the line. */
+    SelectForwardsFromCursor
+  };
+    /** Sets how the text is selected when the user triple clicks within the display. */
+  void setTripleClickMode (TripleClickMode mode)
+  {
+    _tripleClickMode = mode;
+  }
+    /** See setTripleClickSelectionMode() */
+  TripleClickMode tripleClickMode ()
+  {
+    return _tripleClickMode;
+  }
+
+  void setLineSpacing (uint);
+  uint lineSpacing () const;
+
+  void emitSelection (bool useXselection, bool appendReturn);
+
+    /**
+     * This enum describes the available shapes for the keyboard cursor.
+     * See setKeyboardCursorShape()
+     */
+  enum KeyboardCursorShape
+  {
+	/** A rectangular block which covers the entire area of the cursor character. */
+    BlockCursor,
+	/** 
+         * A single flat line which occupies the space at the bottom of the cursor
+         * character's area.
+         */
+    UnderlineCursor,
+	/** 
+         * An cursor shaped like the capital letter 'I', similar to the IBeam 
+         * cursor used in Qt/KDE text editors.
+         */
+    IBeamCursor
+  };
+    /** 
+     * Sets the shape of the keyboard cursor.  This is the cursor drawn   
+     * at the position in the terminal where keyboard input will appear.
+     *
+     * In addition the terminal display widget also has a cursor for 
+     * the mouse pointer, which can be set using the QWidget::setCursor()
+     * method.
+     *
+     * Defaults to BlockCursor
+     */
+  void setKeyboardCursorShape (KeyboardCursorShape shape);
+    /**
+     * Returns the shape of the keyboard cursor.  See setKeyboardCursorShape()
+     */
+  KeyboardCursorShape keyboardCursorShape () const;
+
+    /**
+     * Returns the number of lines of text which can be displayed in the widget.
+     *
+     * This will depend upon the height of the widget and the current font.
+     * See fontHeight()
+     */
+  int lines ()
+  {
+    return _lines;
+  }
+    /**
+     * Returns the number of characters of text which can be displayed on
+     * each line in the widget.
+     *
+     * This will depend upon the width of the widget and the current font.
+     * See fontWidth()
+     */
+  int columns ()
+  {
+    return _columns;
+  }
+
+    /**
+     * Returns the height of the characters in the font used to draw the text in the display.
+     */
+  int fontHeight ()
+  {
+    return _fontHeight;
+  }
+    /**
+     * Returns the width of the characters in the display.  
+     * This assumes the use of a fixed-width font.
+     */
+  int fontWidth ()
+  {
+    return _fontWidth;
+  }
+
+  void setSize (int cols, int lins);
+  void setFixedSize (int cols, int lins);
+
+  // reimplemented
+  QSize sizeHint () const;
+
+    /**
+     * Sets which characters, in addition to letters and numbers, 
+     * are regarded as being part of a word for the purposes
+     * of selecting words in the display by double clicking on them.
+     *
+     * The word boundaries occur at the first and last characters which
+     * are either a letter, number, or a character in @p wc
+     *
+     * @param wc An array of characters which are to be considered parts
+     * of a word ( in addition to letters and numbers ).
+     */
+  void setWordCharacters (const QString & wc);
+    /** 
+     * Returns the characters which are considered part of a word for the 
+     * purpose of selecting words in the display with the mouse.
+     *
+     * @see setWordCharacters()
+     */
+  QString wordCharacters ()
+  {
+    return _wordCharacters;
+  }
+
+    /** 
+     * Sets the type of effect used to alert the user when a 'bell' occurs in the 
+     * terminal session.
+     *
+     * The terminal session can trigger the bell effect by calling bell() with
+     * the alert message.
+     */
+  void setBellMode (int mode);
+    /** 
+     * Returns the type of effect used to alert the user when a 'bell' occurs in
+     * the terminal session.
+     * 
+     * See setBellMode()
+     */
+  int bellMode ()
+  {
+    return _bellMode;
+  }
+
+    /**
+     * This enum describes the different types of sounds and visual effects which
+     * can be used to alert the user when a 'bell' occurs in the terminal
+     * session.
+     */
+  enum BellMode
+  {
+	/** A system beep. */
+    SystemBeepBell = 0,
+	/** 
+         * KDE notification.  This may play a sound, show a passive popup
+         * or perform some other action depending on the user's settings.
+         */
+    NotifyBell = 1,
+	/** A silent, visual bell (eg. inverting the display's colors briefly) */
+    VisualBell = 2,
+	/** No bell effects */
+    NoBell = 3
+  };
+
+  void setSelection (const QString & t);
+
+    /** 
+     * Reimplemented.  Has no effect.  Use setVTFont() to change the font
+     * used to draw characters in the display.
+     */
+  virtual void setFont (const QFont &);
+
+    /** Returns the font used to draw characters in the display */
+  QFont getVTFont ()
+  {
+    return font ();
+  }
+
+    /** 
+     * Sets the font used to draw the display.  Has no effect if @p font
+     * is larger than the size of the display itself.    
+     */
+  void setVTFont (const QFont & font);
+
+    /**
+     * Specified whether anti-aliasing of text in the terminal display
+     * is enabled or not.  Defaults to enabled.
+     */
+  static void setAntialias (bool antialias)
+  {
+    _antialiasText = antialias;
+  }
+    /** 
+     * Returns true if anti-aliasing of text in the terminal is enabled.
+     */
+  static bool antialias ()
+  {
+    return _antialiasText;
+  }
+
+    /**
+     * Specifies whether characters with intense colors should be rendered
+     * as bold. Defaults to true.
+     */
+  void setBoldIntense (bool value)
+  {
+    _boldIntense = value;
+  }
+    /**
+     * Returns true if characters with intense colors are rendered in bold.
+     */
+  bool getBoldIntense ()
+  {
+    return _boldIntense;
+  }
+
+    /**
+     * Sets whether or not the current height and width of the 
+     * terminal in lines and columns is displayed whilst the widget
+     * is being resized.
+     */
+  void setTerminalSizeHint (bool on)
+  {
+    _terminalSizeHint = on;
+  }
+    /** 
+     * Returns whether or not the current height and width of
+     * the terminal in lines and columns is displayed whilst the widget
+     * is being resized.
+     */
+  bool terminalSizeHint ()
+  {
+    return _terminalSizeHint;
+  }
+    /** 
+     * Sets whether the terminal size display is shown briefly
+     * after the widget is first shown.
+     *
+     * See setTerminalSizeHint() , isTerminalSizeHint()
+     */
+  void setTerminalSizeStartup (bool on)
+  {
+    _terminalSizeStartup = on;
+  }
+
+    /**
+     * Sets the status of the BiDi rendering inside the terminal display.
+     * Defaults to disabled.
+     */
+  void setBidiEnabled (bool set)
+  {
+    _bidiEnabled = set;
+  }
+    /**
+     * Returns the status of the BiDi rendering in this widget.
+     */
+  bool isBidiEnabled ()
+  {
+    return _bidiEnabled;
+  }
+
+    /**
+     * Sets the terminal screen section which is displayed in this widget.
+     * When updateImage() is called, the display fetches the latest character image from the
+     * the associated terminal screen window.
+     *
+     * In terms of the model-view paradigm, the ScreenWindow is the model which is rendered
+     * by the TerminalDisplay.
+     */
+  void setScreenWindow (ScreenWindow * window);
+    /** Returns the terminal screen section which is displayed in this widget.  See setScreenWindow() */
+  ScreenWindow *screenWindow () const;
+
+  static bool HAVE_TRANSPARENCY;
+
+  public slots:
+    /** 
+     * Causes the terminal display to fetch the latest character image from the associated
+     * terminal screen ( see setScreenWindow() ) and redraw the display.
+     */
+  void updateImage ();
+    /**
+     * Causes the terminal display to fetch the latest line status flags from the 
+     * associated terminal screen ( see setScreenWindow() ).  
+     */
+  void updateLineProperties ();
+
+    /** Copies the selected text to the clipboard. */
+  void copyClipboard ();
+    /** 
+     * Pastes the content of the clipboard into the 
+     * display.
+     */
+  void pasteClipboard ();
+    /**
+     * Pastes the content of the selection into the
+     * display.
+     */
+  void pasteSelection ();
+
+    /** 
+       * Changes whether the flow control warning box should be shown when the flow control
+       * stop key (Ctrl+S) are pressed.
+       */
+  void setFlowControlWarningEnabled (bool enabled);
+    /** 
+     * Returns true if the flow control warning box is enabled. 
+     * See outputSuspended() and setFlowControlWarningEnabled()
+     */
+  bool flowControlWarningEnabled () const
+  {
+    return _flowControlWarningEnabled;
+  }
+
+    /** 
+     * Causes the widget to display or hide a message informing the user that terminal
+     * output has been suspended (by using the flow control key combination Ctrl+S)
+     *
+     * @param suspended True if terminal output has been suspended and the warning message should
+     *                     be shown or false to indicate that terminal output has been resumed and that
+     *                     the warning message should disappear.
+     */
+  void outputSuspended (bool suspended);
+
+    /**
+     * Sets whether the program whoose output is being displayed in the view
+     * is interested in mouse events.
+     *
+     * If this is set to true, mouse signals will be emitted by the view when the user clicks, drags
+     * or otherwise moves the mouse inside the view.
+     * The user interaction needed to create selections will also change, and the user will be required
+     * to hold down the shift key to create a selection or perform other mouse activities inside the 
+     * view area - since the program running in the terminal is being allowed to handle normal mouse
+     * events itself.
+     *
+     * @param usesMouse Set to true if the program running in the terminal is interested in mouse events
+     * or false otherwise.
+     */
+  void setUsesMouse (bool usesMouse);
+
+    /** See setUsesMouse() */
+  bool usesMouse () const;
+
+    /** 
+     * Shows a notification that a bell event has occurred in the terminal.
+     * TODO: More documentation here
+     */
+  void bell (const QString & message);
+
+    /** 
+     * Sets the background of the display to the specified color. 
+     * @see setColorTable(), setForegroundColor() 
+     */
+  void setBackgroundColor (const QColor & color);
+
+    /** 
+     * Sets the text of the display to the specified color. 
+     * @see setColorTable(), setBackgroundColor()
+     */
+  void setForegroundColor (const QColor & color);
+
+signals:
+
+    /**
+     * Emitted when the user presses a key whilst the terminal widget has focus.
+     */
+  void keyPressedSignal (QKeyEvent * e);
+
+    /** 
+     * A mouse event occurred.
+     * @param button The mouse button (0 for left button, 1 for middle button, 2 for right button, 3 for release)
+     * @param column The character column where the event occurred
+     * @param line The character row where the event occurred
+     * @param eventType The type of event.  0 for a mouse press / release or 1 for mouse motion
+     */
+  void mouseSignal (int button, int column, int line, int eventType);
+  void changedFontMetricSignal (int height, int width);
+  void changedContentSizeSignal (int height, int width);
+
+    /** 
+     * Emitted when the user right clicks on the display, or right-clicks with the Shift
+     * key held down if usesMouse() is true.
+     *
+     * This can be used to display a context menu.
+     */
+  void configureRequest (const QPoint & position);
+
+    /**
+     * When a shortcut which is also a valid terminal key sequence is pressed while 
+     * the terminal widget  has focus, this signal is emitted to allow the host to decide 
+     * whether the shortcut should be overridden.  
+     * When the shortcut is overridden, the key sequence will be sent to the terminal emulation instead
+     * and the action associated with the shortcut will not be triggered.
+     *
+     * @p override is set to false by default and the shortcut will be triggered as normal.
+     */
+  void overrideShortcutCheck (QKeyEvent * keyEvent, bool & override);
+
+  void isBusySelecting (bool);
+  void sendStringToEmu (const char *);
+
+protected:
+  virtual bool event (QEvent *);
+
+  virtual void paintEvent (QPaintEvent *);
+
+  virtual void showEvent (QShowEvent *);
+  virtual void hideEvent (QHideEvent *);
+  virtual void resizeEvent (QResizeEvent *);
+
+  virtual void fontChange (const QFont & font);
+  virtual void focusInEvent (QFocusEvent * event);
+  virtual void focusOutEvent (QFocusEvent * event);
+  virtual void keyPressEvent (QKeyEvent * event);
+  virtual void mouseDoubleClickEvent (QMouseEvent * ev);
+  virtual void mousePressEvent (QMouseEvent *);
+  virtual void mouseReleaseEvent (QMouseEvent *);
+  virtual void mouseMoveEvent (QMouseEvent *);
+  virtual void extendSelection (const QPoint & pos);
+  virtual void wheelEvent (QWheelEvent *);
+
+  virtual bool focusNextPrevChild (bool next);
+
+  // drag and drop
+  virtual void dragEnterEvent (QDragEnterEvent * event);
+  virtual void dropEvent (QDropEvent * event);
+  void doDrag ();
+  enum DragState
+  { diNone, diPending, diDragging };
+
+  struct _dragInfo
+  {
+    DragState state;
+    QPoint start;
+    QDrag *dragObject;
+  } dragInfo;
+
+  // classifies the 'ch' into one of three categories
+  // and returns a character to indicate which category it is in
+  //
+  //     - A space (returns ' ') 
+  //     - Part of a word (returns 'a')
+  //     - Other characters (returns the input character)
+  QChar charClass (QChar ch) const;
+
+  void clearImage ();
+
+  void mouseTripleClickEvent (QMouseEvent * ev);
+
+  // reimplemented
+  virtual void inputMethodEvent (QInputMethodEvent * event);
+  virtual QVariant inputMethodQuery (Qt::InputMethodQuery query) const;
+
+  protected slots:void scrollBarPositionChanged (int value);
+  void blinkEvent ();
+  void blinkCursorEvent ();
+
+  //Renables bell noises and visuals.  Used to disable further bells for a short period of time
+  //after emitting the first in a sequence of bell events.
+  void enableBell ();
+
+  private slots:void swapColorTable ();
+  void tripleClickTimeout ();	// resets possibleTripleClick
+
+private:
+
+  // -- Drawing helpers --
+
+  // divides the part of the display specified by 'rect' into
+  // fragments according to their colors and styles and calls
+  // drawTextFragment() to draw the fragments 
+  void drawContents (QPainter & paint, const QRect & rect);
+  // draws a section of text, all the text in this section
+  // has a common color and style
+  void drawTextFragment (QPainter & painter, const QRect & rect,
+			 const QString & text, const Character * style);
+  // draws the background for a text fragment
+  // if useOpacitySetting is true then the color's alpha value will be set to
+  // the display's transparency (set with setOpacity()), otherwise the background
+  // will be drawn fully opaque
+  void drawBackground (QPainter & painter, const QRect & rect,
+		       const QColor & color, bool useOpacitySetting);
+  // draws the cursor character
+  void drawCursor (QPainter & painter, const QRect & rect,
+		   const QColor & foregroundColor,
+		   const QColor & backgroundColor, bool & invertColors);
+  // draws the characters or line graphics in a text fragment
+  void drawCharacters (QPainter & painter, const QRect & rect,
+		       const QString & text, const Character * style,
+		       bool invertCharacterColor);
+
+  // draws the preedit string for input methods
+  void drawInputMethodPreeditString (QPainter & painter, const QRect & rect);
+
+  // --
+
+  // maps an area in the character image to an area on the widget 
+  QRect imageToWidget (const QRect & imageArea) const;
+
+  // maps a point on the widget to the position ( ie. line and column ) 
+  // of the character at that point.
+  void getCharacterPosition (const QPoint & widgetPoint, int &line,
+			     int &column) const;
+
+  // the area where the preedit string for input methods will be draw
+  QRect preeditRect () const;
+
+  // shows a notification window in the middle of the widget indicating the terminal's
+  // current size in columns and lines
+  void showResizeNotification ();
+
+  // scrolls the image by a number of lines.  
+  // 'lines' may be positive ( to scroll the image down ) 
+  // or negative ( to scroll the image up )
+  // 'region' is the part of the image to scroll - currently only
+  // the top, bottom and height of 'region' are taken into account,
+  // the left and right are ignored.
+  void scrollImage (int lines, const QRect & region);
+
+  void calcGeometry ();
+  void propagateSize ();
+  void updateImageSize ();
+  void makeImage ();
+
+  void paintFilters (QPainter & painter);
+
+  // returns a region covering all of the areas of the widget which contain
+  // a hotspot
+  QRegion hotSpotRegion () const;
+
+  // returns the position of the cursor in columns and lines
+  QPoint cursorPosition () const;
+
+  // redraws the cursor
+  void updateCursor ();
+
+  bool handleShortcutOverrideEvent (QKeyEvent * event);
+
+  // the window onto the terminal screen which this display
+  // is currently showing.  
+  QPointer < ScreenWindow > _screenWindow;
+
+  bool _allowBell;
+
+  QGridLayout *_gridLayout;
+
+  bool _fixedFont;		// has fixed pitch
+  int _fontHeight;		// height
+  int _fontWidth;		// width
+  int _fontAscent;		// ascend
+  bool _boldIntense;		// Whether intense colors should be rendered with bold font
+
+  int _leftMargin;		// offset
+  int _topMargin;		// offset
+
+  int _lines;			// the number of lines that can be displayed in the widget
+  int _columns;			// the number of columns that can be displayed in the widget
+
+  int _usedLines;		// the number of lines that are actually being used, this will be less
+  // than 'lines' if the character image provided with setImage() is smaller
+  // than the maximum image size which can be displayed
+
+  int _usedColumns;		// the number of columns that are actually being used, this will be less
+  // than 'columns' if the character image provided with setImage() is smaller
+  // than the maximum image size which can be displayed
+
+  int _contentHeight;
+  int _contentWidth;
+  Character *_image;		// [lines][columns]
+  // only the area [usedLines][usedColumns] in the image contains valid data
+
+  int _imageSize;
+  QVector < LineProperty > _lineProperties;
+
+  ColorEntry _colorTable[TABLE_COLORS];
+  uint _randomSeed;
+
+  bool _resizing;
+  bool _terminalSizeHint;
+  bool _terminalSizeStartup;
+  bool _bidiEnabled;
+  bool _mouseMarks;
+
+  QPoint _iPntSel;		// initial selection point
+  QPoint _pntSel;		// current selection point
+  QPoint _tripleSelBegin;	// help avoid flicker
+  int _actSel;			// selection state
+  bool _wordSelectionMode;
+  bool _lineSelectionMode;
+  bool _preserveLineBreaks;
+  bool _columnSelectionMode;
+
+  QClipboard *_clipboard;
+  QScrollBar *_scrollBar;
+  ScrollBarPosition _scrollbarLocation;
+  QString _wordCharacters;
+  int _bellMode;
+
+  bool _blinking;		// hide text in paintEvent
+  bool _hasBlinker;		// has characters to blink
+  bool _cursorBlinking;		// hide cursor in paintEvent
+  bool _hasBlinkingCursor;	// has blinking cursor enabled
+  bool _allowBlinkingText;	// allow text to blink
+  bool _ctrlDrag;		// require Ctrl key for drag
+  TripleClickMode _tripleClickMode;
+  bool _isFixedSize;		//Columns / lines are locked.
+  QTimer *_blinkTimer;		// active when hasBlinker
+  QTimer *_blinkCursorTimer;	// active when hasBlinkingCursor
+
+  QString _dropText;
+  int _dndFileCount;
+
+  bool _possibleTripleClick;	// is set in mouseDoubleClickEvent and deleted
+  // after QApplication::doubleClickInterval() delay
+
+
+  QLabel *_resizeWidget;
+  QTimer *_resizeTimer;
+
+  bool _flowControlWarningEnabled;
+
+  //widgets related to the warning message that appears when the user presses Ctrl+S to suspend
+  //terminal output - informing them what has happened and how to resume output
+  QLabel *_outputSuspendedLabel;
+
+  uint _lineSpacing;
+
+  bool _colorsInverted;		// true during visual bell
+
+  QSize _size;
+
+  QRgb _blendColor;
+
+  // list of filters currently applied to the display.  used for links and
+  // search highlight
+  TerminalImageFilterChain *_filterChain;
+  QRegion _mouseOverHotspotArea;
+
+  KeyboardCursorShape _cursorShape;
+
+  // custom cursor color.  if this is invalid then the foreground
+  // color of the character under the cursor is used
+  QColor _cursorColor;
+
+
+  struct InputMethodData
+  {
+    QString preeditString;
+    QRect previousPreeditRect;
+  };
+  InputMethodData _inputMethodData;
+
+  static bool _antialiasText;	// do we antialias or not
+
+  //the delay in milliseconds between redrawing blinking text
+  static const int TEXT_BLINK_DELAY = 500;
+  static const int DEFAULT_LEFT_MARGIN = 1;
+  static const int DEFAULT_TOP_MARGIN = 1;
+
+public:
+  static void setTransparencyEnabled (bool enable)
+  {
+    HAVE_TRANSPARENCY = enable;
+  }
+};
+
+class AutoScrollHandler:public QObject
+{
+Q_OBJECT public:
+  AutoScrollHandler (QWidget * parent);
+protected:
+  virtual void timerEvent (QTimerEvent * event);
+  virtual bool eventFilter (QObject * watched, QEvent * event);
+private:
+    QWidget * widget () const
+  {
+    return static_cast < QWidget * >(parent ());
+  }
+  int _timerId;
+};
+
+
+#endif // TERMINALDISPLAY_H
diff --git a/gui/src/terminal/Vt102Emulation.cpp b/gui/src/terminal/Vt102Emulation.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Vt102Emulation.cpp
@@ -0,0 +1,1790 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright 2007-2008 by Robert Knight <robert.knight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "Vt102Emulation.h"
+
+
+// this allows konsole to be compiled without XKB and XTEST extensions
+// even though it might be available on a particular system.
+#if defined(AVOID_XKB)
+#undef HAVE_XKB
+#endif
+
+#if defined(HAVE_XKB)
+void scrolllock_set_off ();
+void scrolllock_set_on ();
+#endif
+
+// Standard 
+#include <stdio.h>
+#include <unistd.h>
+#include <assert.h>
+
+// Qt
+#include <QtCore/QEvent>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QByteRef>
+
+// Konsole
+#include "KeyboardTranslator.h"
+#include "Screen.h"
+
+Vt102Emulation::Vt102Emulation ():Emulation (),
+_titleUpdateTimer (new QTimer (this))
+{
+  _titleUpdateTimer->setSingleShot (true);
+  QObject::connect (_titleUpdateTimer, SIGNAL (timeout ()), this,
+		    SLOT (updateTitle ()));
+
+  initTokenizer ();
+  reset ();
+}
+
+Vt102Emulation::~Vt102Emulation ()
+{
+}
+
+void
+Vt102Emulation::clearEntireScreen ()
+{
+  _currentScreen->clearEntireScreen ();
+  bufferedUpdate ();
+}
+
+void
+Vt102Emulation::reset ()
+{
+  resetTokenizer ();
+  resetModes ();
+  resetCharset (0);
+  _screen[0]->reset ();
+  resetCharset (1);
+  _screen[1]->reset ();
+  setCodec (LocaleCodec);
+
+  bufferedUpdate ();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                     Processing the incoming byte stream                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/* Incoming Bytes Event pipeline
+
+   This section deals with decoding the incoming character stream.
+   Decoding means here, that the stream is first separated into `tokens'
+   which are then mapped to a `meaning' provided as operations by the
+   `Screen' class or by the emulation class itself.
+
+   The pipeline proceeds as follows:
+
+   - Tokenizing the ESC codes (onReceiveChar)
+   - VT100 code page translation of plain characters (applyCharset)
+   - Interpretation of ESC codes (processToken)
+
+   The escape codes and their meaning are described in the
+   technical reference of this program.
+*/
+
+// Tokens ------------------------------------------------------------------ --
+
+/*
+   Since the tokens are the central notion if this section, we've put them
+   in front. They provide the syntactical elements used to represent the
+   terminals operations as byte sequences.
+
+   They are encodes here into a single machine word, so that we can later
+   switch over them easily. Depending on the token itself, additional
+   argument variables are filled with parameter values.
+
+   The tokens are defined below:
+
+   - CHR        - Printable characters     (32..255 but DEL (=127))
+   - CTL        - Control characters       (0..31 but ESC (= 27), DEL)
+   - ESC        - Escape codes of the form <ESC><CHR but `[]()+*#'>
+   - ESC_DE     - Escape codes of the form <ESC><any of `()+*#%'> C
+   - CSI_PN     - Escape codes of the form <ESC>'['     {Pn} ';' {Pn} C
+   - CSI_PS     - Escape codes of the form <ESC>'['     {Pn} ';' ...  C
+   - CSI_PR     - Escape codes of the form <ESC>'[' '?' {Pn} ';' ...  C
+   - CSI_PE     - Escape codes of the form <ESC>'[' '!' {Pn} ';' ...  C
+   - VT52       - VT52 escape codes
+                  - <ESC><Chr>
+                  - <ESC>'Y'{Pc}{Pc}
+   - XTE_HA     - Xterm window/terminal attribute commands 
+                  of the form <ESC>`]' {Pn} `;' {Text} <BEL>
+                  (Note that these are handled differently to the other formats)
+
+   The last two forms allow list of arguments. Since the elements of
+   the lists are treated individually the same way, they are passed
+   as individual tokens to the interpretation. Further, because the
+   meaning of the parameters are names (althought represented as numbers),
+   they are includes within the token ('N').
+
+*/
+
+#define TY_CONSTRUCT(T,A,N) ( ((((int)N) & 0xffff) << 16) | ((((int)A) & 0xff) << 8) | (((int)T) & 0xff) )
+
+#define TY_CHR(   )     TY_CONSTRUCT(0,0,0)
+#define TY_CTL(A  )     TY_CONSTRUCT(1,A,0)
+#define TY_ESC(A  )     TY_CONSTRUCT(2,A,0)
+#define TY_ESC_CS(A,B)  TY_CONSTRUCT(3,A,B)
+#define TY_ESC_DE(A  )  TY_CONSTRUCT(4,A,0)
+#define TY_CSI_PS(A,N)  TY_CONSTRUCT(5,A,N)
+#define TY_CSI_PN(A  )  TY_CONSTRUCT(6,A,0)
+#define TY_CSI_PR(A,N)  TY_CONSTRUCT(7,A,N)
+
+#define TY_VT52(A)    TY_CONSTRUCT(8,A,0)
+#define TY_CSI_PG(A)  TY_CONSTRUCT(9,A,0)
+#define TY_CSI_PE(A)  TY_CONSTRUCT(10,A,0)
+
+#define MAX_ARGUMENT 4096
+
+// Tokenizer --------------------------------------------------------------- --
+
+/* The tokenizer's state
+
+   The state is represented by the buffer (tokenBuffer, tokenBufferPos),
+   and accompanied by decoded arguments kept in (argv,argc).
+   Note that they are kept internal in the tokenizer.
+*/
+
+void
+Vt102Emulation::resetTokenizer ()
+{
+  tokenBufferPos = 0;
+  argc = 0;
+  argv[0] = 0;
+  argv[1] = 0;
+}
+
+void
+Vt102Emulation::addDigit (int digit)
+{
+  if (argv[argc] < MAX_ARGUMENT)
+    argv[argc] = 10 * argv[argc] + digit;
+}
+
+void
+Vt102Emulation::addArgument ()
+{
+  argc = qMin (argc + 1, MAXARGS - 1);
+  argv[argc] = 0;
+}
+
+void
+Vt102Emulation::addToCurrentToken (int cc)
+{
+  tokenBuffer[tokenBufferPos] = cc;
+  tokenBufferPos = qMin (tokenBufferPos + 1, MAX_TOKEN_LENGTH - 1);
+}
+
+// Character Class flags used while decoding
+
+#define CTL  1			// Control character
+#define CHR  2			// Printable character
+#define CPN  4			// TODO: Document me
+#define DIG  8			// Digit
+#define SCS 16			// TODO: Document me
+#define GRP 32			// TODO: Document me
+#define CPS 64			// Character which indicates end of window resize
+		// escape sequence '\e[8;<row>;<col>t'
+
+void
+Vt102Emulation::initTokenizer ()
+{
+  int i;
+  quint8 *s;
+  for (i = 0; i < 256; ++i)
+    charClass[i] = 0;
+  for (i = 0; i < 32; ++i)
+    charClass[i] |= CTL;
+  for (i = 32; i < 256; ++i)
+    charClass[i] |= CHR;
+  for (s = (quint8 *) "@ABCDGHILMPSTXZcdfry"; *s; ++s)
+    charClass[*s] |= CPN;
+  // resize = \e[8;<row>;<col>t
+  for (s = (quint8 *) "t"; *s; ++s)
+    charClass[*s] |= CPS;
+  for (s = (quint8 *) "0123456789"; *s; ++s)
+    charClass[*s] |= DIG;
+  for (s = (quint8 *) "()+*%"; *s; ++s)
+    charClass[*s] |= SCS;
+  for (s = (quint8 *) "()+*#[]%"; *s; ++s)
+    charClass[*s] |= GRP;
+
+  resetTokenizer ();
+}
+
+/* Ok, here comes the nasty part of the decoder.
+
+   Instead of keeping an explicit state, we deduce it from the
+   token scanned so far. It is then immediately combined with
+   the current character to form a scanning decision.
+
+   This is done by the following defines.
+
+   - P is the length of the token scanned so far.
+   - L (often P-1) is the position on which contents we base a decision.
+   - C is a character or a group of characters (taken from 'charClass').
+   
+   - 'cc' is the current character
+   - 's' is a pointer to the start of the token buffer
+   - 'p' is the current position within the token buffer 
+
+   Note that they need to applied in proper order.
+*/
+
+#define lec(P,L,C) (p == (P) && s[(L)] == (C))
+#define lun(     ) (p ==  1  && cc >= 32 )
+#define les(P,L,C) (p == (P) && s[L] < 256 && (charClass[s[(L)]] & (C)) == (C))
+#define eec(C)     (p >=  3  && cc == (C))
+#define ees(C)     (p >=  3  && cc < 256 && (charClass[cc] & (C)) == (C))
+#define eps(C)     (p >=  3  && s[2] != '?' && s[2] != '!' && s[2] != '>' && cc < 256 && (charClass[cc] & (C)) == (C))
+#define epp( )     (p >=  3  && s[2] == '?')
+#define epe( )     (p >=  3  && s[2] == '!')
+#define egt( )     (p >=  3  && s[2] == '>')
+#define Xpe        (tokenBufferPos >= 2 && tokenBuffer[1] == ']')
+#define Xte        (Xpe      && cc ==  7 )
+#define ces(C)     (cc < 256 && (charClass[cc] & (C)) == (C) && !Xte)
+
+#define ESC 27
+#define CNTL(c) ((c)-'@')
+
+// process an incoming unicode character
+void
+Vt102Emulation::receiveChar (int cc)
+{
+  if (cc == 127)
+    return;			//VT100: ignore.
+
+  if (ces (CTL))
+    {
+      // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
+      // This means, they do neither a resetTokenizer() nor a pushToToken(). Some of them, do
+      // of course. Guess this originates from a weakly layered handling of the X-on
+      // X-off protocol, which comes really below this level.
+      if (cc == CNTL ('X') || cc == CNTL ('Z') || cc == ESC)
+	resetTokenizer ();	//VT100: CAN or SUB
+      if (cc != ESC)
+	{
+	  processToken (TY_CTL (cc + '@'), 0, 0);
+	  return;
+	}
+    }
+  // advance the state
+  addToCurrentToken (cc);
+
+  int *s = tokenBuffer;
+  int p = tokenBufferPos;
+
+  if (getMode (MODE_Ansi))
+    {
+      if (lec (1, 0, ESC))
+	{
+	  return;
+	}
+      if (lec (1, 0, ESC + 128))
+	{
+	  s[0] = ESC;
+	  receiveChar ('[');
+	  return;
+	}
+      if (les (2, 1, GRP))
+	{
+	  return;
+	}
+      if (Xte)
+	{
+	  processWindowAttributeChange ();
+	  resetTokenizer ();
+	  return;
+	}
+      if (Xpe)
+	{
+	  return;
+	}
+      if (lec (3, 2, '?'))
+	{
+	  return;
+	}
+      if (lec (3, 2, '>'))
+	{
+	  return;
+	}
+      if (lec (3, 2, '!'))
+	{
+	  return;
+	}
+      if (lun ())
+	{
+	  processToken (TY_CHR (), applyCharset (cc), 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (2, 0, ESC))
+	{
+	  processToken (TY_ESC (s[1]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (les (3, 1, SCS))
+	{
+	  processToken (TY_ESC_CS (s[1], s[2]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (3, 1, '#'))
+	{
+	  processToken (TY_ESC_DE (s[2]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (eps (CPN))
+	{
+	  processToken (TY_CSI_PN (cc), argv[0], argv[1]);
+	  resetTokenizer ();
+	  return;
+	}
+
+      // resize = \e[8;<row>;<col>t
+      if (eps (CPS))
+	{
+	  processToken (TY_CSI_PS (cc, argv[0]), argv[1], argv[2]);
+	  resetTokenizer ();
+	  return;
+	}
+
+      if (epe ())
+	{
+	  processToken (TY_CSI_PE (cc), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (ees (DIG))
+	{
+	  addDigit (cc - '0');
+	  return;
+	}
+      if (eec (';'))
+	{
+	  addArgument ();
+	  return;
+	}
+      for (int i = 0; i <= argc; i++)
+	{
+	  if (epp ())
+	    processToken (TY_CSI_PR (cc, argv[i]), 0, 0);
+	  else if (egt ())
+	    processToken (TY_CSI_PG (cc), 0, 0);	// spec. case for ESC]>0c or ESC]>c
+	  else if (cc == 'm' && argc - i >= 4
+		   && (argv[i] == 38 || argv[i] == 48) && argv[i + 1] == 2)
+	    {
+	      // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
+	      i += 2;
+	      processToken (TY_CSI_PS (cc, argv[i - 2]), COLOR_SPACE_RGB,
+			    (argv[i] << 16) | (argv[i + 1] << 8) | argv[i +
+									2]);
+	      i += 2;
+	    }
+	  else if (cc == 'm' && argc - i >= 2
+		   && (argv[i] == 38 || argv[i] == 48) && argv[i + 1] == 5)
+	    {
+	      // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
+	      i += 2;
+	      processToken (TY_CSI_PS (cc, argv[i - 2]), COLOR_SPACE_256,
+			    argv[i]);
+	    }
+	  else
+	    processToken (TY_CSI_PS (cc, argv[i]), 0, 0);
+	}
+      resetTokenizer ();
+    }
+  else
+    {
+      // VT52 Mode
+      if (lec (1, 0, ESC))
+	return;
+      if (les (1, 0, CHR))
+	{
+	  processToken (TY_CHR (), s[0], 0);
+	  resetTokenizer ();
+	  return;
+	}
+      if (lec (2, 1, 'Y'))
+	return;
+      if (lec (3, 1, 'Y'))
+	return;
+      if (p < 4)
+	{
+	  processToken (TY_VT52 (s[1]), 0, 0);
+	  resetTokenizer ();
+	  return;
+	}
+      processToken (TY_VT52 (s[1]), s[2], s[3]);
+      resetTokenizer ();
+      return;
+    }
+}
+
+void
+Vt102Emulation::processWindowAttributeChange ()
+{
+  // Describes the window or terminal session attribute to change
+  // See Session::UserTitleChange for possible values
+  int attributeToChange = 0;
+  int i;
+  for (i = 2; i < tokenBufferPos &&
+       tokenBuffer[i] >= '0' && tokenBuffer[i] <= '9'; i++)
+    {
+      attributeToChange = 10 * attributeToChange + (tokenBuffer[i] - '0');
+    }
+
+  if (tokenBuffer[i] != ';')
+    {
+      reportDecodingError ();
+      return;
+    }
+
+  QString newValue;
+  newValue.reserve (tokenBufferPos - i - 2);
+  for (int j = 0; j < tokenBufferPos - i - 2; j++)
+    newValue[j] = tokenBuffer[i + 1 + j];
+
+  _pendingTitleUpdates[attributeToChange] = newValue;
+  _titleUpdateTimer->start (20);
+}
+
+void
+Vt102Emulation::updateTitle ()
+{
+  QListIterator < int >iter (_pendingTitleUpdates.keys ());
+  while (iter.hasNext ())
+    {
+      int arg = iter.next ();
+      emit titleChanged (arg, _pendingTitleUpdates[arg]);
+    }
+  _pendingTitleUpdates.clear ();
+}
+
+// Interpreting Codes ---------------------------------------------------------
+
+/*
+   Now that the incoming character stream is properly tokenized,
+   meaning is assigned to them. These are either operations of
+   the current _screen, or of the emulation class itself.
+
+   The token to be interpreteted comes in as a machine word
+   possibly accompanied by two parameters.
+
+   Likewise, the operations assigned to, come with up to two
+   arguments. One could consider to make up a proper table
+   from the function below.
+
+   The technical reference manual provides more information
+   about this mapping.
+*/
+
+void
+Vt102Emulation::processToken (int token, int p, int q)
+{
+  switch (token)
+    {
+
+    case TY_CHR ():
+      _currentScreen->displayCharacter (p);
+      break;			//UTF16
+
+      //             127 DEL    : ignored on input
+
+    case TY_CTL ('@'):		/* NUL: ignored                      */
+      break;
+    case TY_CTL ('A'):		/* SOH: ignored                      */
+      break;
+    case TY_CTL ('B'):		/* STX: ignored                      */
+      break;
+    case TY_CTL ('C'):		/* ETX: ignored                      */
+      break;
+    case TY_CTL ('D'):		/* EOT: ignored                      */
+      break;
+    case TY_CTL ('E'):
+      reportAnswerBack ();
+      break;			//VT100
+    case TY_CTL ('F'):		/* ACK: ignored                      */
+      break;
+    case TY_CTL ('G'):
+      emit stateSet (NOTIFYBELL);
+      break;			//VT100
+    case TY_CTL ('H'):
+      _currentScreen->backspace ();
+      break;			//VT100
+    case TY_CTL ('I'):
+      _currentScreen->tab ();
+      break;			//VT100
+    case TY_CTL ('J'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('K'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('L'):
+      _currentScreen->newLine ();
+      break;			//VT100
+    case TY_CTL ('M'):
+      _currentScreen->toStartOfLine ();
+      break;			//VT100
+
+    case TY_CTL ('N'):
+      useCharset (1);
+      break;			//VT100
+    case TY_CTL ('O'):
+      useCharset (0);
+      break;			//VT100
+
+    case TY_CTL ('P'):		/* DLE: ignored                      */
+      break;
+    case TY_CTL ('Q'):		/* DC1: XON continue                 */
+      break;			//VT100
+    case TY_CTL ('R'):		/* DC2: ignored                      */
+      break;
+    case TY_CTL ('S'):		/* DC3: XOFF halt                    */
+      break;			//VT100
+    case TY_CTL ('T'):		/* DC4: ignored                      */
+      break;
+    case TY_CTL ('U'):		/* NAK: ignored                      */
+      break;
+    case TY_CTL ('V'):		/* SYN: ignored                      */
+      break;
+    case TY_CTL ('W'):		/* ETB: ignored                      */
+      break;
+    case TY_CTL ('X'):
+      _currentScreen->displayCharacter (0x2592);
+      break;			//VT100
+    case TY_CTL ('Y'):		/* EM : ignored                      */
+      break;
+    case TY_CTL ('Z'):
+      _currentScreen->displayCharacter (0x2592);
+      break;			//VT100
+    case TY_CTL ('['):		/* ESC: cannot be seen here.         */
+      break;
+    case TY_CTL ('\\'):	/* FS : ignored                      */
+      break;
+    case TY_CTL (']'):		/* GS : ignored                      */
+      break;
+    case TY_CTL ('^'):		/* RS : ignored                      */
+      break;
+    case TY_CTL ('_'):		/* US : ignored                      */
+      break;
+
+    case TY_ESC ('D'):
+      _currentScreen->index ();
+      break;			//VT100
+    case TY_ESC ('E'):
+      _currentScreen->nextLine ();
+      break;			//VT100
+    case TY_ESC ('H'):
+      _currentScreen->changeTabStop (true);
+      break;			//VT100
+    case TY_ESC ('M'):
+      _currentScreen->reverseIndex ();
+      break;			//VT100
+    case TY_ESC ('Z'):
+      reportTerminalType ();
+      break;
+    case TY_ESC ('c'):
+      reset ();
+      break;
+
+    case TY_ESC ('n'):
+      useCharset (2);
+      break;
+    case TY_ESC ('o'):
+      useCharset (3);
+      break;
+    case TY_ESC ('7'):
+      saveCursor ();
+      break;
+    case TY_ESC ('8'):
+      restoreCursor ();
+      break;
+
+    case TY_ESC ('='):
+      setMode (MODE_AppKeyPad);
+      break;
+    case TY_ESC ('>'):
+      resetMode (MODE_AppKeyPad);
+      break;
+    case TY_ESC ('<'):
+      setMode (MODE_Ansi);
+      break;			//VT100
+
+    case TY_ESC_CS ('(', '0'):
+      setCharset (0, '0');
+      break;			//VT100
+    case TY_ESC_CS ('(', 'A'):
+      setCharset (0, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('(', 'B'):
+      setCharset (0, 'B');
+      break;			//VT100
+
+    case TY_ESC_CS (')', '0'):
+      setCharset (1, '0');
+      break;			//VT100
+    case TY_ESC_CS (')', 'A'):
+      setCharset (1, 'A');
+      break;			//VT100
+    case TY_ESC_CS (')', 'B'):
+      setCharset (1, 'B');
+      break;			//VT100
+
+    case TY_ESC_CS ('*', '0'):
+      setCharset (2, '0');
+      break;			//VT100
+    case TY_ESC_CS ('*', 'A'):
+      setCharset (2, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('*', 'B'):
+      setCharset (2, 'B');
+      break;			//VT100
+
+    case TY_ESC_CS ('+', '0'):
+      setCharset (3, '0');
+      break;			//VT100
+    case TY_ESC_CS ('+', 'A'):
+      setCharset (3, 'A');
+      break;			//VT100
+    case TY_ESC_CS ('+', 'B'):
+      setCharset (3, 'B');
+      break;			//VT100
+
+    case TY_ESC_CS ('%', 'G'):
+      setCodec (Utf8Codec);
+      break;			//LINUX
+    case TY_ESC_CS ('%', '@'):
+      setCodec (LocaleCodec);
+      break;			//LINUX
+
+    case TY_ESC_DE ('3'):	/* Double height line, top half    */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, true);
+      break;
+    case TY_ESC_DE ('4'):	/* Double height line, bottom half */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, true);
+      break;
+    case TY_ESC_DE ('5'):	/* Single width, single height line */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, false);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, false);
+      break;
+    case TY_ESC_DE ('6'):	/* Double width, single height line */
+      _currentScreen->setLineProperty (LINE_DOUBLEWIDTH, true);
+      _currentScreen->setLineProperty (LINE_DOUBLEHEIGHT, false);
+      break;
+    case TY_ESC_DE ('8'):
+      _currentScreen->helpAlign ();
+      break;
+
+// resize = \e[8;<row>;<col>t
+    case TY_CSI_PS ('t', 8):
+      setImageSize (q /* columns */ , p /* lines */ );
+      break;
+
+// change tab text color : \e[28;<color>t  color: 0-16,777,215
+    case TY_CSI_PS ('t', 28):
+      emit changeTabTextColorRequest (p);
+      break;
+
+    case TY_CSI_PS ('K', 0):
+      _currentScreen->clearToEndOfLine ();
+      break;
+    case TY_CSI_PS ('K', 1):
+      _currentScreen->clearToBeginOfLine ();
+      break;
+    case TY_CSI_PS ('K', 2):
+      _currentScreen->clearEntireLine ();
+      break;
+    case TY_CSI_PS ('J', 0):
+      _currentScreen->clearToEndOfScreen ();
+      break;
+    case TY_CSI_PS ('J', 1):
+      _currentScreen->clearToBeginOfScreen ();
+      break;
+    case TY_CSI_PS ('J', 2):
+      _currentScreen->clearEntireScreen ();
+      break;
+    case TY_CSI_PS ('J', 3):
+      clearHistory ();
+      break;
+    case TY_CSI_PS ('g', 0):
+      _currentScreen->changeTabStop (false);
+      break;			//VT100
+    case TY_CSI_PS ('g', 3):
+      _currentScreen->clearTabStops ();
+      break;			//VT100
+    case TY_CSI_PS ('h', 4):
+      _currentScreen->setMode (MODE_Insert);
+      break;
+    case TY_CSI_PS ('h', 20):
+      setMode (MODE_NewLine);
+      break;
+    case TY_CSI_PS ('i', 0):	/* IGNORE: attached printer          */
+      break;			//VT100
+    case TY_CSI_PS ('l', 4):
+      _currentScreen->resetMode (MODE_Insert);
+      break;
+    case TY_CSI_PS ('l', 20):
+      resetMode (MODE_NewLine);
+      break;
+    case TY_CSI_PS ('s', 0):
+      saveCursor ();
+      break;
+    case TY_CSI_PS ('u', 0):
+      restoreCursor ();
+      break;
+
+    case TY_CSI_PS ('m', 0):
+      _currentScreen->setDefaultRendition ();
+      break;
+    case TY_CSI_PS ('m', 1):
+      _currentScreen->setRendition (RE_BOLD);
+      break;			//VT100
+    case TY_CSI_PS ('m', 4):
+      _currentScreen->setRendition (RE_UNDERLINE);
+      break;			//VT100
+    case TY_CSI_PS ('m', 5):
+      _currentScreen->setRendition (RE_BLINK);
+      break;			//VT100
+    case TY_CSI_PS ('m', 7):
+      _currentScreen->setRendition (RE_REVERSE);
+      break;
+    case TY_CSI_PS ('m', 10):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 11):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 12):	/* IGNORED: mapping related          */
+      break;			//LINUX
+    case TY_CSI_PS ('m', 22):
+      _currentScreen->resetRendition (RE_BOLD);
+      break;
+    case TY_CSI_PS ('m', 24):
+      _currentScreen->resetRendition (RE_UNDERLINE);
+      break;
+    case TY_CSI_PS ('m', 25):
+      _currentScreen->resetRendition (RE_BLINK);
+      break;
+    case TY_CSI_PS ('m', 27):
+      _currentScreen->resetRendition (RE_REVERSE);
+      break;
+
+    case TY_CSI_PS ('m', 30):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 0);
+      break;
+    case TY_CSI_PS ('m', 31):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 1);
+      break;
+    case TY_CSI_PS ('m', 32):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 2);
+      break;
+    case TY_CSI_PS ('m', 33):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 3);
+      break;
+    case TY_CSI_PS ('m', 34):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 4);
+      break;
+    case TY_CSI_PS ('m', 35):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 5);
+      break;
+    case TY_CSI_PS ('m', 36):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 6);
+      break;
+    case TY_CSI_PS ('m', 37):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 7);
+      break;
+
+    case TY_CSI_PS ('m', 38):
+      _currentScreen->setForeColor (p, q);
+      break;
+
+    case TY_CSI_PS ('m', 39):
+      _currentScreen->setForeColor (COLOR_SPACE_DEFAULT, 0);
+      break;
+
+    case TY_CSI_PS ('m', 40):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 0);
+      break;
+    case TY_CSI_PS ('m', 41):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 1);
+      break;
+    case TY_CSI_PS ('m', 42):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 2);
+      break;
+    case TY_CSI_PS ('m', 43):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 3);
+      break;
+    case TY_CSI_PS ('m', 44):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 4);
+      break;
+    case TY_CSI_PS ('m', 45):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 5);
+      break;
+    case TY_CSI_PS ('m', 46):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 6);
+      break;
+    case TY_CSI_PS ('m', 47):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 7);
+      break;
+
+    case TY_CSI_PS ('m', 48):
+      _currentScreen->setBackColor (p, q);
+      break;
+
+    case TY_CSI_PS ('m', 49):
+      _currentScreen->setBackColor (COLOR_SPACE_DEFAULT, 1);
+      break;
+
+    case TY_CSI_PS ('m', 90):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 8);
+      break;
+    case TY_CSI_PS ('m', 91):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 9);
+      break;
+    case TY_CSI_PS ('m', 92):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 10);
+      break;
+    case TY_CSI_PS ('m', 93):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 11);
+      break;
+    case TY_CSI_PS ('m', 94):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 12);
+      break;
+    case TY_CSI_PS ('m', 95):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 13);
+      break;
+    case TY_CSI_PS ('m', 96):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 14);
+      break;
+    case TY_CSI_PS ('m', 97):
+      _currentScreen->setForeColor (COLOR_SPACE_SYSTEM, 15);
+      break;
+
+    case TY_CSI_PS ('m', 100):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 8);
+      break;
+    case TY_CSI_PS ('m', 101):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 9);
+      break;
+    case TY_CSI_PS ('m', 102):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 10);
+      break;
+    case TY_CSI_PS ('m', 103):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 11);
+      break;
+    case TY_CSI_PS ('m', 104):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 12);
+      break;
+    case TY_CSI_PS ('m', 105):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 13);
+      break;
+    case TY_CSI_PS ('m', 106):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 14);
+      break;
+    case TY_CSI_PS ('m', 107):
+      _currentScreen->setBackColor (COLOR_SPACE_SYSTEM, 15);
+      break;
+
+    case TY_CSI_PS ('n', 5):
+      reportStatus ();
+      break;
+    case TY_CSI_PS ('n', 6):
+      reportCursorPosition ();
+      break;
+    case TY_CSI_PS ('q', 0):	/* IGNORED: LEDs off                 */
+      break;			//VT100
+    case TY_CSI_PS ('q', 1):	/* IGNORED: LED1 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 2):	/* IGNORED: LED2 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 3):	/* IGNORED: LED3 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('q', 4):	/* IGNORED: LED4 on                  */
+      break;			//VT100
+    case TY_CSI_PS ('x', 0):
+      reportTerminalParms (2);
+      break;			//VT100
+    case TY_CSI_PS ('x', 1):
+      reportTerminalParms (3);
+      break;			//VT100
+
+    case TY_CSI_PN ('@'):
+      _currentScreen->insertChars (p);
+      break;
+    case TY_CSI_PN ('A'):
+      _currentScreen->cursorUp (p);
+      break;			//VT100
+    case TY_CSI_PN ('B'):
+      _currentScreen->cursorDown (p);
+      break;			//VT100
+    case TY_CSI_PN ('C'):
+      _currentScreen->cursorRight (p);
+      break;			//VT100
+    case TY_CSI_PN ('D'):
+      _currentScreen->cursorLeft (p);
+      break;			//VT100
+    case TY_CSI_PN ('G'):
+      _currentScreen->setCursorX (p);
+      break;			//LINUX
+    case TY_CSI_PN ('H'):
+      _currentScreen->setCursorYX (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('I'):
+      _currentScreen->tab (p);
+      break;
+    case TY_CSI_PN ('L'):
+      _currentScreen->insertLines (p);
+      break;
+    case TY_CSI_PN ('M'):
+      _currentScreen->deleteLines (p);
+      break;
+    case TY_CSI_PN ('P'):
+      _currentScreen->deleteChars (p);
+      break;
+    case TY_CSI_PN ('S'):
+      _currentScreen->scrollUp (p);
+      break;
+    case TY_CSI_PN ('T'):
+      _currentScreen->scrollDown (p);
+      break;
+    case TY_CSI_PN ('X'):
+      _currentScreen->eraseChars (p);
+      break;
+    case TY_CSI_PN ('Z'):
+      _currentScreen->backtab (p);
+      break;
+    case TY_CSI_PN ('c'):
+      reportTerminalType ();
+      break;			//VT100
+    case TY_CSI_PN ('d'):
+      _currentScreen->setCursorY (p);
+      break;			//LINUX
+    case TY_CSI_PN ('f'):
+      _currentScreen->setCursorYX (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('r'):
+      setMargins (p, q);
+      break;			//VT100
+    case TY_CSI_PN ('y'):	/* IGNORED: Confidence test          */
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 1):
+      setMode (MODE_AppCuKeys);
+      break;			//VT100
+    case TY_CSI_PR ('l', 1):
+      resetMode (MODE_AppCuKeys);
+      break;			//VT100
+    case TY_CSI_PR ('s', 1):
+      saveMode (MODE_AppCuKeys);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 1):
+      restoreMode (MODE_AppCuKeys);
+      break;			//FIXME
+
+    case TY_CSI_PR ('l', 2):
+      resetMode (MODE_Ansi);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 3):
+      setMode (MODE_132Columns);
+      break;			//VT100
+    case TY_CSI_PR ('l', 3):
+      resetMode (MODE_132Columns);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 4):	/* IGNORED: soft scrolling           */
+      break;			//VT100
+    case TY_CSI_PR ('l', 4):	/* IGNORED: soft scrolling           */
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 5):
+      _currentScreen->setMode (MODE_Screen);
+      break;			//VT100
+    case TY_CSI_PR ('l', 5):
+      _currentScreen->resetMode (MODE_Screen);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 6):
+      _currentScreen->setMode (MODE_Origin);
+      break;			//VT100
+    case TY_CSI_PR ('l', 6):
+      _currentScreen->resetMode (MODE_Origin);
+      break;			//VT100
+    case TY_CSI_PR ('s', 6):
+      _currentScreen->saveMode (MODE_Origin);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 6):
+      _currentScreen->restoreMode (MODE_Origin);
+      break;			//FIXME
+
+    case TY_CSI_PR ('h', 7):
+      _currentScreen->setMode (MODE_Wrap);
+      break;			//VT100
+    case TY_CSI_PR ('l', 7):
+      _currentScreen->resetMode (MODE_Wrap);
+      break;			//VT100
+    case TY_CSI_PR ('s', 7):
+      _currentScreen->saveMode (MODE_Wrap);
+      break;			//FIXME
+    case TY_CSI_PR ('r', 7):
+      _currentScreen->restoreMode (MODE_Wrap);
+      break;			//FIXME
+
+    case TY_CSI_PR ('h', 8):	/* IGNORED: autorepeat on            */
+      break;			//VT100
+    case TY_CSI_PR ('l', 8):	/* IGNORED: autorepeat off           */
+      break;			//VT100
+    case TY_CSI_PR ('s', 8):	/* IGNORED: autorepeat on            */
+      break;			//VT100
+    case TY_CSI_PR ('r', 8):	/* IGNORED: autorepeat off           */
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('l', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('s', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+    case TY_CSI_PR ('r', 9):	/* IGNORED: interlace                */
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('l', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('s', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+    case TY_CSI_PR ('r', 12):	/* IGNORED: Cursor blink             */
+      break;			//att610
+
+    case TY_CSI_PR ('h', 25):
+      setMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('l', 25):
+      resetMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('s', 25):
+      saveMode (MODE_Cursor);
+      break;			//VT100
+    case TY_CSI_PR ('r', 25):
+      restoreMode (MODE_Cursor);
+      break;			//VT100
+
+    case TY_CSI_PR ('h', 40):
+      setMode (MODE_Allow132Columns);
+      break;			// XTERM
+    case TY_CSI_PR ('l', 40):
+      resetMode (MODE_Allow132Columns);
+      break;			// XTERM
+
+    case TY_CSI_PR ('h', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('s', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 41):	/* IGNORED: obsolete more(1) fix     */
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 47):
+      setMode (MODE_AppScreen);
+      break;			//VT100
+    case TY_CSI_PR ('l', 47):
+      resetMode (MODE_AppScreen);
+      break;			//VT100
+    case TY_CSI_PR ('s', 47):
+      saveMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 47):
+      restoreMode (MODE_AppScreen);
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('s', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 67):	/* IGNORED: DECBKM                   */
+      break;			//XTERM
+
+      // XTerm defines the following modes:
+      // SET_VT200_MOUSE             1000
+      // SET_VT200_HIGHLIGHT_MOUSE   1001
+      // SET_BTN_EVENT_MOUSE         1002
+      // SET_ANY_EVENT_MOUSE         1003
+      //
+
+      //Note about mouse modes:
+      //There are four mouse modes which xterm-compatible terminals can support - 1000,1001,1002,1003
+      //Konsole currently supports mode 1000 (basic mouse press and release) and mode 1002 (dragging the mouse).
+      //TODO:  Implementation of mouse modes 1001 (something called hilight tracking) and 
+      //1003 (a slight variation on dragging the mouse)
+      //
+
+    case TY_CSI_PR ('h', 1000):
+      setMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1000):
+      resetMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1000):
+      saveMode (MODE_Mouse1000);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1000):
+      restoreMode (MODE_Mouse1000);
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1001):
+      resetMode (MODE_Mouse1001);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1001):	/* IGNORED: hilite mouse tracking    */
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1002):
+      setMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1002):
+      resetMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1002):
+      saveMode (MODE_Mouse1002);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1002):
+      restoreMode (MODE_Mouse1002);
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1003):
+      setMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1003):
+      resetMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1003):
+      saveMode (MODE_Mouse1003);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1003):
+      restoreMode (MODE_Mouse1003);
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1034):	/* IGNORED: 8bitinput activation     */
+      break;			//XTERM
+
+    case TY_CSI_PR ('h', 1047):
+      setMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1047):
+      _screen[1]->clearEntireScreen ();
+      resetMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1047):
+      saveMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1047):
+      restoreMode (MODE_AppScreen);
+      break;			//XTERM
+
+      //FIXME: Unitoken: save translations
+    case TY_CSI_PR ('h', 1048):
+      saveCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1048):
+      restoreCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('s', 1048):
+      saveCursor ();
+      break;			//XTERM
+    case TY_CSI_PR ('r', 1048):
+      restoreCursor ();
+      break;			//XTERM
+
+      //FIXME: every once new sequences like this pop up in xterm.
+      //       Here's a guess of what they could mean.
+    case TY_CSI_PR ('h', 1049):
+      saveCursor ();
+      _screen[1]->clearEntireScreen ();
+      setMode (MODE_AppScreen);
+      break;			//XTERM
+    case TY_CSI_PR ('l', 1049):
+      resetMode (MODE_AppScreen);
+      restoreCursor ();
+      break;			//XTERM
+
+      //FIXME: weird DEC reset sequence
+    case TY_CSI_PE ('p'):	/* IGNORED: reset         (        ) */
+      break;
+
+      //FIXME: when changing between vt52 and ansi mode evtl do some resetting.
+    case TY_VT52 ('A'):
+      _currentScreen->cursorUp (1);
+      break;			//VT52
+    case TY_VT52 ('B'):
+      _currentScreen->cursorDown (1);
+      break;			//VT52
+    case TY_VT52 ('C'):
+      _currentScreen->cursorRight (1);
+      break;			//VT52
+    case TY_VT52 ('D'):
+      _currentScreen->cursorLeft (1);
+      break;			//VT52
+
+    case TY_VT52 ('F'):
+      setAndUseCharset (0, '0');
+      break;			//VT52
+    case TY_VT52 ('G'):
+      setAndUseCharset (0, 'B');
+      break;			//VT52
+
+    case TY_VT52 ('H'):
+      _currentScreen->setCursorYX (1, 1);
+      break;			//VT52
+    case TY_VT52 ('I'):
+      _currentScreen->reverseIndex ();
+      break;			//VT52
+    case TY_VT52 ('J'):
+      _currentScreen->clearToEndOfScreen ();
+      break;			//VT52
+    case TY_VT52 ('K'):
+      _currentScreen->clearToEndOfLine ();
+      break;			//VT52
+    case TY_VT52 ('Y'):
+      _currentScreen->setCursorYX (p - 31, q - 31);
+      break;			//VT52
+    case TY_VT52 ('Z'):
+      reportTerminalType ();
+      break;			//VT52
+    case TY_VT52 ('<'):
+      setMode (MODE_Ansi);
+      break;			//VT52
+    case TY_VT52 ('='):
+      setMode (MODE_AppKeyPad);
+      break;			//VT52
+    case TY_VT52 ('>'):
+      resetMode (MODE_AppKeyPad);
+      break;			//VT52
+
+    case TY_CSI_PG ('c'):
+      reportSecondaryAttributes ();
+      break;			//VT100
+
+    default:
+      reportDecodingError ();
+      break;
+    };
+}
+
+void
+Vt102Emulation::clearScreenAndSetColumns (int columnCount)
+{
+  setImageSize (_currentScreen->getLines (), columnCount);
+  clearEntireScreen ();
+  setDefaultMargins ();
+  _currentScreen->setCursorYX (0, 0);
+}
+
+void
+Vt102Emulation::sendString (const char *s, int length)
+{
+  if (length >= 0)
+    emit sendData (s, length);
+  else
+  emit sendData (s, strlen (s));
+}
+
+void
+Vt102Emulation::reportCursorPosition ()
+{
+  char tmp[20];
+  sprintf (tmp, "\033[%d;%dR", _currentScreen->getCursorY () + 1,
+	   _currentScreen->getCursorX () + 1);
+  sendString (tmp);
+}
+
+void
+Vt102Emulation::reportTerminalType ()
+{
+  // Primary device attribute response (Request was: ^[[0c or ^[[c (from TT321 Users Guide))
+  // VT220:  ^[[?63;1;2;3;6;7;8c   (list deps on emul. capabilities)
+  // VT100:  ^[[?1;2c
+  // VT101:  ^[[?1;0c
+  // VT102:  ^[[?6v
+  if (getMode (MODE_Ansi))
+    sendString ("\033[?1;2c");	// I'm a VT100
+  else
+    sendString ("\033/Z");	// I'm a VT52
+}
+
+void
+Vt102Emulation::reportSecondaryAttributes ()
+{
+  // Seconday device attribute response (Request was: ^[[>0c or ^[[>c)
+  if (getMode (MODE_Ansi))
+    sendString ("\033[>0;115;0c");	// Why 115?  ;)
+  else
+    sendString ("\033/Z");	// FIXME I don't think VT52 knows about it but kept for
+  // konsoles backward compatibility.
+}
+
+void
+Vt102Emulation::reportTerminalParms (int p)
+// DECREPTPARM
+{
+  char tmp[100];
+  sprintf (tmp, "\033[%d;1;1;112;112;1;0x", p);	// not really true.
+  sendString (tmp);
+}
+
+void
+Vt102Emulation::reportStatus ()
+{
+  sendString ("\033[0n");	//VT100. Device status report. 0 = Ready.
+}
+
+void
+Vt102Emulation::reportAnswerBack ()
+{
+  // FIXME - Test this with VTTEST
+  // This is really obsolete VT100 stuff.
+  const char *ANSWER_BACK = "";
+  sendString (ANSWER_BACK);
+}
+
+/*!
+    `cx',`cy' are 1-based.
+    `eventType' indicates the button pressed (0-2)
+                or a general mouse release (3).
+
+    eventType represents the kind of mouse action that occurred:
+        0 = Mouse button press or release
+        1 = Mouse drag
+*/
+
+void
+Vt102Emulation::sendMouseEvent (int cb, int cx, int cy, int eventType)
+{
+  if (cx < 1 || cy < 1)
+    return;
+
+  // normal buttons are passed as 0x20 + button,
+  // mouse wheel (buttons 4,5) as 0x5c + button
+  if (cb >= 4)
+    cb += 0x3c;
+
+  //Mouse motion handling
+  if ((getMode (MODE_Mouse1002) || getMode (MODE_Mouse1003))
+      && eventType == 1)
+    cb += 0x20;			//add 32 to signify motion event
+
+  char command[20];
+  sprintf (command, "\033[M%c%c%c", cb + 0x20, cx + 0x20, cy + 0x20);
+  sendString (command);
+}
+
+void
+Vt102Emulation::sendText (const QString & text)
+{
+  if (!text.isEmpty ())
+    {
+      QKeyEvent event (QEvent::KeyPress,
+		       0, (Qt::KeyboardModifiers) Qt::NoModifier, text);
+
+      sendKeyEvent (&event);	// expose as a big fat keypress event
+    }
+}
+
+void
+Vt102Emulation::sendKeyEvent (QKeyEvent * event)
+{
+  Qt::KeyboardModifiers modifiers = event->modifiers ();
+  KeyboardTranslator::States states = KeyboardTranslator::NoState;
+
+  // get current states
+  if (getMode (MODE_NewLine))
+    states |= KeyboardTranslator::NewLineState;
+  if (getMode (MODE_Ansi))
+    states |= KeyboardTranslator::AnsiState;
+  if (getMode (MODE_AppCuKeys))
+    states |= KeyboardTranslator::CursorKeysState;
+  if (getMode (MODE_AppScreen))
+    states |= KeyboardTranslator::AlternateScreenState;
+  if (getMode (MODE_AppKeyPad) && (modifiers & Qt::KeypadModifier))
+    states |= KeyboardTranslator::ApplicationKeypadState;
+
+  // check flow control state
+  if (modifiers & Qt::ControlModifier)
+    {
+      if (event->key () == Qt::Key_S)
+	emit flowControlKeyPressed (true);
+      else
+    if (event->key () == Qt::Key_Q)
+      emit flowControlKeyPressed (false);
+    }
+
+  // lookup key binding
+  if (_keyTranslator)
+    {
+      KeyboardTranslator::Entry entry =
+	_keyTranslator->findEntry (event->key (), modifiers, states);
+
+      // send result to terminal
+      QByteArray textToSend;
+
+      // special handling for the Alt (aka. Meta) modifier.  pressing
+      // Alt+[Character] results in Esc+[Character] being sent
+      // (unless there is an entry defined for this particular combination
+      //  in the keyboard modifier)
+      bool wantsAltModifier =
+	entry.modifiers () & entry.modifierMask () & Qt::AltModifier;
+      bool wantsAnyModifier =
+	entry.state () & entry.
+	stateMask () & KeyboardTranslator::AnyModifierState;
+
+      if (modifiers & Qt::AltModifier
+	  && !(wantsAltModifier || wantsAnyModifier)
+	  && !event->text ().isEmpty ())
+	{
+	  textToSend.prepend ("\033");
+	}
+
+      if (entry.command () != KeyboardTranslator::NoCommand)
+	{
+	  if (entry.command () & KeyboardTranslator::EraseCommand)
+	    textToSend += eraseChar ();
+
+	  // TODO command handling
+	}
+      else if (!entry.text ().isEmpty ())
+	{
+	  textToSend += _codec->fromUnicode (entry.text (true, modifiers));
+	}
+      else
+	textToSend += _codec->fromUnicode (event->text ());
+
+      sendData (textToSend.constData (), textToSend.length ());
+    }
+  else
+    {
+      // print an error message to the terminal if no key translator has been
+      // set
+      QString translatorError = QString ("No keyboard translator available.  "
+					 "The information needed to convert key presses "
+					 "into characters to send to the terminal "
+					 "is missing.");
+      reset ();
+      receiveData (translatorError.toAscii ().constData (),
+		   translatorError.count ());
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                VT100 Charsets                             */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+// Character Set Conversion ------------------------------------------------ --
+
+/* 
+   The processing contains a VT100 specific code translation layer.
+   It's still in use and mainly responsible for the line drawing graphics.
+
+   These and some other glyphs are assigned to codes (0x5f-0xfe)
+   normally occupied by the latin letters. Since this codes also
+   appear within control sequences, the extra code conversion
+   does not permute with the tokenizer and is placed behind it
+   in the pipeline. It only applies to tokens, which represent
+   plain characters.
+
+   This conversion it eventually continued in TerminalDisplay.C, since 
+   it might involve VT100 enhanced fonts, which have these
+   particular glyphs allocated in (0x00-0x1f) in their code page.
+*/
+
+#define CHARSET _charset[_currentScreen==_screen[1]]
+
+// Apply current character map.
+
+unsigned short
+Vt102Emulation::applyCharset (unsigned short c)
+{
+  if (CHARSET.graphic && 0x5f <= c && c <= 0x7e)
+    return vt100_graphics[c - 0x5f];
+  if (CHARSET.pound && c == '#')
+    return 0xa3;		//This mode is obsolete
+  return c;
+}
+
+/*
+   "Charset" related part of the emulation state.
+   This configures the VT100 charset filter.
+
+   While most operation work on the current _screen,
+   the following two are different.
+*/
+
+void
+Vt102Emulation::resetCharset (int scrno)
+{
+  _charset[scrno].cu_cs = 0;
+  strncpy (_charset[scrno].charset, "BBBB", 4);
+  _charset[scrno].sa_graphic = false;
+  _charset[scrno].sa_pound = false;
+  _charset[scrno].graphic = false;
+  _charset[scrno].pound = false;
+}
+
+void
+Vt102Emulation::setCharset (int n, int cs)	// on both screens.
+{
+  _charset[0].charset[n & 3] = cs;
+  useCharset (_charset[0].cu_cs);
+  _charset[1].charset[n & 3] = cs;
+  useCharset (_charset[1].cu_cs);
+}
+
+void
+Vt102Emulation::setAndUseCharset (int n, int cs)
+{
+  CHARSET.charset[n & 3] = cs;
+  useCharset (n & 3);
+}
+
+void
+Vt102Emulation::useCharset (int n)
+{
+  CHARSET.cu_cs = n & 3;
+  CHARSET.graphic = (CHARSET.charset[n & 3] == '0');
+  CHARSET.pound = (CHARSET.charset[n & 3] == 'A');	//This mode is obsolete
+}
+
+void
+Vt102Emulation::setDefaultMargins ()
+{
+  _screen[0]->setDefaultMargins ();
+  _screen[1]->setDefaultMargins ();
+}
+
+void
+Vt102Emulation::setMargins (int t, int b)
+{
+  _screen[0]->setMargins (t, b);
+  _screen[1]->setMargins (t, b);
+}
+
+void
+Vt102Emulation::saveCursor ()
+{
+  CHARSET.sa_graphic = CHARSET.graphic;
+  CHARSET.sa_pound = CHARSET.pound;	//This mode is obsolete
+  // we are not clear about these
+  //sa_charset = charsets[cScreen->_charset];
+  //sa_charset_num = cScreen->_charset;
+  _currentScreen->saveCursor ();
+}
+
+void
+Vt102Emulation::restoreCursor ()
+{
+  CHARSET.graphic = CHARSET.sa_graphic;
+  CHARSET.pound = CHARSET.sa_pound;	//This mode is obsolete
+  _currentScreen->restoreCursor ();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Mode Operations                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*
+   Some of the emulations state is either added to the state of the screens.
+
+   This causes some scoping problems, since different emulations choose to
+   located the mode either to the current _screen or to both.
+
+   For strange reasons, the extend of the rendition attributes ranges over
+   all screens and not over the actual _screen.
+
+   We decided on the precise precise extend, somehow.
+*/
+
+// "Mode" related part of the state. These are all booleans.
+
+void
+Vt102Emulation::resetModes ()
+{
+  // MODE_Allow132Columns is not reset here
+  // to match Xterm's behaviour (see Xterm's VTReset() function)
+
+  resetMode (MODE_132Columns);
+  saveMode (MODE_132Columns);
+  resetMode (MODE_Mouse1000);
+  saveMode (MODE_Mouse1000);
+  resetMode (MODE_Mouse1001);
+  saveMode (MODE_Mouse1001);
+  resetMode (MODE_Mouse1002);
+  saveMode (MODE_Mouse1002);
+  resetMode (MODE_Mouse1003);
+  saveMode (MODE_Mouse1003);
+
+  resetMode (MODE_AppScreen);
+  saveMode (MODE_AppScreen);
+  resetMode (MODE_AppCuKeys);
+  saveMode (MODE_AppCuKeys);
+  resetMode (MODE_AppKeyPad);
+  saveMode (MODE_AppKeyPad);
+  resetMode (MODE_NewLine);
+  setMode (MODE_Ansi);
+}
+
+void
+Vt102Emulation::setMode (int m)
+{
+  _currentModes.mode[m] = true;
+  switch (m)
+    {
+    case MODE_132Columns:
+      if (getMode (MODE_Allow132Columns))
+	clearScreenAndSetColumns (132);
+      else
+	_currentModes.mode[m] = false;
+      break;
+    case MODE_Mouse1000:
+    case MODE_Mouse1001:
+    case MODE_Mouse1002:
+    case MODE_Mouse1003:
+      emit programUsesMouseChanged (false);
+      break;
+
+    case MODE_AppScreen:
+      _screen[1]->clearSelection ();
+      setScreen (1);
+      break;
+    }
+  if (m < MODES_SCREEN || m == MODE_NewLine)
+    {
+      _screen[0]->setMode (m);
+      _screen[1]->setMode (m);
+    }
+}
+
+void
+Vt102Emulation::resetMode (int m)
+{
+  _currentModes.mode[m] = false;
+  switch (m)
+    {
+    case MODE_132Columns:
+      if (getMode (MODE_Allow132Columns))
+	clearScreenAndSetColumns (80);
+      break;
+    case MODE_Mouse1000:
+    case MODE_Mouse1001:
+    case MODE_Mouse1002:
+    case MODE_Mouse1003:
+      emit programUsesMouseChanged (true);
+      break;
+
+    case MODE_AppScreen:
+      _screen[0]->clearSelection ();
+      setScreen (0);
+      break;
+    }
+  if (m < MODES_SCREEN || m == MODE_NewLine)
+    {
+      _screen[0]->resetMode (m);
+      _screen[1]->resetMode (m);
+    }
+}
+
+void
+Vt102Emulation::saveMode (int m)
+{
+  _savedModes.mode[m] = _currentModes.mode[m];
+}
+
+void
+Vt102Emulation::restoreMode (int m)
+{
+  if (_savedModes.mode[m])
+    setMode (m);
+  else
+    resetMode (m);
+}
+
+bool
+Vt102Emulation::getMode (int m)
+{
+  return _currentModes.mode[m];
+}
+
+char
+Vt102Emulation::eraseChar () const
+{
+  KeyboardTranslator::Entry entry =
+    _keyTranslator->findEntry (Qt::Key_Backspace, 0, 0);
+  if (entry.text ().count () > 0)
+    return entry.text ()[0];
+  else
+    return '\b';
+}
+
+// print contents of the scan buffer
+static void
+hexdump (int *s, int len)
+{
+  int i;
+  for (i = 0; i < len; i++)
+    {
+      if (s[i] == '\\')
+	printf ("\\\\");
+      else if ((s[i]) > 32 && s[i] < 127)
+	printf ("%c", s[i]);
+      else
+	printf ("\\%04x(hex)", s[i]);
+    }
+}
+
+void
+Vt102Emulation::reportDecodingError ()
+{
+  if (tokenBufferPos == 0
+      || (tokenBufferPos == 1 && (tokenBuffer[0] & 0xff) >= 32))
+    return;
+  printf ("Undecodable sequence: ");
+  hexdump (tokenBuffer, tokenBufferPos);
+  printf ("\n");
+}
diff --git a/gui/src/terminal/Vt102Emulation.h b/gui/src/terminal/Vt102Emulation.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/Vt102Emulation.h
@@ -0,0 +1,187 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef VT102EMULATION_H
+#define VT102EMULATION_H
+
+// Standard Library
+#include <stdio.h>
+
+// Qt 
+#include <QtGui/QKeyEvent>
+#include <QtCore/QHash>
+#include <QtCore/QTimer>
+
+// Konsole
+#include "Emulation.h"
+#include "Screen.h"
+
+#define MODE_AppScreen       (MODES_SCREEN+0)	// Mode #1
+#define MODE_AppCuKeys       (MODES_SCREEN+1)	// Application cursor keys (DECCKM)
+#define MODE_AppKeyPad       (MODES_SCREEN+2)	//
+#define MODE_Mouse1000       (MODES_SCREEN+3)	// Send mouse X,Y position on press and release
+#define MODE_Mouse1001       (MODES_SCREEN+4)	// Use Hilight mouse tracking
+#define MODE_Mouse1002       (MODES_SCREEN+5)	// Use cell motion mouse tracking
+#define MODE_Mouse1003       (MODES_SCREEN+6)	// Use all motion mouse tracking
+#define MODE_Ansi            (MODES_SCREEN+7)	// Use US Ascii for character sets G0-G3 (DECANM)
+#define MODE_132Columns      (MODES_SCREEN+8)	// 80 <-> 132 column mode switch (DECCOLM)
+#define MODE_Allow132Columns (MODES_SCREEN+9)	// Allow DECCOLM mode
+#define MODE_total           (MODES_SCREEN+10)
+
+struct CharCodes
+{
+  // coding info
+  char charset[4];		//
+  int cu_cs;			// actual charset.
+  bool graphic;			// Some VT100 tricks
+  bool pound;			// Some VT100 tricks
+  bool sa_graphic;		// saved graphic
+  bool sa_pound;		// saved pound
+};
+
+/**
+ * Provides an xterm compatible terminal emulation based on the DEC VT102 terminal.
+ * A full description of this terminal can be found at
+ * 
+ * In addition, various additional xterm escape sequences are supported to provide 
+ * features such as mouse input handling.
+ * See http://rtfm.etla.org/xterm/ctlseq.html for a description of xterm's escape
+ * sequences. 
+ *
+ */
+class Vt102Emulation:public Emulation
+{
+Q_OBJECT public:
+  /** Constructs a new emulation */
+  Vt102Emulation ();
+  ~Vt102Emulation ();
+
+  // reimplemented from Emulation
+  virtual void clearEntireScreen ();
+  virtual void reset ();
+  virtual char eraseChar () const;
+
+  public slots:
+    // reimplemented from Emulation 
+    virtual void sendString (const char *, int length = -1);
+  virtual void sendText (const QString & text);
+  virtual void sendKeyEvent (QKeyEvent *);
+  virtual void sendMouseEvent (int buttons, int column, int line,
+			       int eventType);
+
+protected:
+  // reimplemented from Emulation
+    virtual void setMode (int mode);
+  virtual void resetMode (int mode);
+  virtual void receiveChar (int cc);
+
+  private slots:
+    //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
+    //used to buffer multiple title updates
+  void updateTitle ();
+
+private:
+  unsigned short applyCharset (unsigned short c);
+  void setCharset (int n, int cs);
+  void useCharset (int n);
+  void setAndUseCharset (int n, int cs);
+  void saveCursor ();
+  void restoreCursor ();
+  void resetCharset (int scrno);
+
+  void setMargins (int top, int bottom);
+  //set margins for all screens back to their defaults
+  void setDefaultMargins ();
+
+  // returns true if 'mode' is set or false otherwise
+  bool getMode (int mode);
+  // saves the current boolean value of 'mode'
+  void saveMode (int mode);
+  // restores the boolean value of 'mode' 
+  void restoreMode (int mode);
+  // resets all modes
+  // (except MODE_Allow132Columns)
+  void resetModes ();
+
+  void resetTokenizer ();
+#define MAX_TOKEN_LENGTH 80
+  void addToCurrentToken (int cc);
+  int tokenBuffer[MAX_TOKEN_LENGTH];	//FIXME: overflow?
+  int tokenBufferPos;
+#define MAXARGS 15
+  void addDigit (int dig);
+  void addArgument ();
+  int argv[MAXARGS];
+  int argc;
+  void initTokenizer ();
+
+  // Set of flags for each of the ASCII characters which indicates
+  // what category they fall into (printable character, control, digit etc.)
+  // for the purposes of decoding terminal output
+  int charClass[256];
+
+  void reportDecodingError ();
+
+  void processToken (int code, int p, int q);
+  void processWindowAttributeChange ();
+
+  void reportTerminalType ();
+  void reportSecondaryAttributes ();
+  void reportStatus ();
+  void reportAnswerBack ();
+  void reportCursorPosition ();
+  void reportTerminalParms (int p);
+
+  void onScrollLock ();
+  void scrollLock (const bool lock);
+
+  // clears the screen and resizes it to the specified
+  // number of columns
+  void clearScreenAndSetColumns (int columnCount);
+
+  CharCodes _charset[2];
+
+  class TerminalState
+  {
+  public:
+    // Initializes all modes to false
+    TerminalState ()
+    {
+      memset (&mode, false, MODE_total * sizeof (bool));
+    }
+
+    bool mode[MODE_total];
+  };
+
+  TerminalState _currentModes;
+  TerminalState _savedModes;
+
+  //hash table and timer for buffering calls to the session instance 
+  //to update the name of the session
+  //or window title.
+  //these calls occur when certain escape sequences are seen in the 
+  //output from the terminal
+  QHash < int, QString > _pendingTitleUpdates;
+  QTimer *_titleUpdateTimer;
+};
+
+#endif // VT102EMULATION_H
diff --git a/gui/src/terminal/konsole_export.h b/gui/src/terminal/konsole_export.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/konsole_export.h
@@ -0,0 +1,68 @@
+/*
+    This file is part of the KDE project
+    Copyright (C) 2009 Patrick Spendrin <ps_ml@gmx.de>
+
+    This library is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef KONSOLE_EXPORT_H
+#define KONSOLE_EXPORT_H
+
+/* needed for KDE_EXPORT macros */
+//#include <kdemacros.h>
+#include <QtCore/qglobal.h>
+#define KDE_EXPORT
+#define KDE_IMPORT
+
+#ifndef KONSOLEPRIVATE_EXPORT
+#if defined(MAKE_KONSOLEPRIVATE_LIB)
+   /* We are building this library */
+#define KONSOLEPRIVATE_EXPORT KDE_EXPORT
+#else
+   /* We are using this library */
+#define KONSOLEPRIVATE_EXPORT KDE_IMPORT
+#endif
+#endif
+
+#include <iostream>
+//#define kWarning(x) std::cout
+
+#include <stdio.h>
+
+//#define i18n 
+inline QString
+tr (char *buff, ...)
+{
+  char msg[2048];
+  va_list arglist;
+
+  va_start (arglist, buff);
+
+  snprintf (msg, 2048, buff, arglist);
+
+  va_end (arglist);
+
+  return QString (msg);
+}
+
+#define i18nc
+
+
+//#define KDE_fseek ::fseek
+//#define KDE_lseek ::lseek
+
+
+#endif
diff --git a/gui/src/terminal/konsole_wcwidth.cpp b/gui/src/terminal/konsole_wcwidth.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/konsole_wcwidth.cpp
@@ -0,0 +1,220 @@
+/* $XFree86: xc/programs/xterm/wcwidth.character,v 1.3 2001/07/29 22:08:16 tsi Exp $ */
+/*
+ * This is an implementation of wcwidth() and wcswidth() as defined in
+ * "The Single UNIX Specification, Version 2, The Open Group, 1997"
+ * <http://www.UNIX-systems.org/online.html>
+ *
+ * Markus Kuhn -- 2001-01-12 -- public domain
+ */
+
+#include "konsole_wcwidth.h"
+
+struct interval
+{
+  unsigned short first;
+  unsigned short last;
+};
+
+/* auxiliary function for binary search in interval table */
+static int
+bisearch (quint16 ucs, const struct interval *table, int max)
+{
+  int min = 0;
+  int mid;
+
+  if (ucs < table[0].first || ucs > table[max].last)
+    return 0;
+  while (max >= min)
+    {
+      mid = (min + max) / 2;
+      if (ucs > table[mid].last)
+	min = mid + 1;
+      else if (ucs < table[mid].first)
+	max = mid - 1;
+      else
+	return 1;
+    }
+
+  return 0;
+}
+
+
+/* The following functions define the column width of an ISO 10646
+ * character as follows:
+ *
+ *    - The null character (U+0000) has a column width of 0.
+ *
+ *    - Other C0/C1 control characters and DEL will lead to a return
+ *      value of -1.
+ *
+ *    - Non-spacing and enclosing combining characters (general
+ *      category code Mn or Me in the Unicode database) have a
+ *      column width of 0.
+ *
+ *    - Other format characters (general category code Cf in the Unicode
+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
+ *
+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
+ *      have a column width of 0.
+ *
+ *    - Spacing characters in the East Asian Wide (W) or East Asian
+ *      FullWidth (F) category as defined in Unicode Technical
+ *      Report #11 have a column width of 2.
+ *
+ *    - All remaining characters (including all printable
+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,
+ *      etc.) have a column width of 1.
+ *
+ * This implementation assumes that quint16 characters are encoded
+ * in ISO 10646.
+ */
+
+int
+konsole_wcwidth (quint16 ucs)
+{
+  /* sorted list of non-overlapping intervals of non-spacing characters */
+  static const struct interval combining[] = {
+    {0x0300, 0x034E}, {0x0360, 0x0362}, {0x0483, 0x0486},
+    {0x0488, 0x0489}, {0x0591, 0x05A1}, {0x05A3, 0x05B9},
+    {0x05BB, 0x05BD}, {0x05BF, 0x05BF}, {0x05C1, 0x05C2},
+    {0x05C4, 0x05C4}, {0x064B, 0x0655}, {0x0670, 0x0670},
+    {0x06D6, 0x06E4}, {0x06E7, 0x06E8}, {0x06EA, 0x06ED},
+    {0x070F, 0x070F}, {0x0711, 0x0711}, {0x0730, 0x074A},
+    {0x07A6, 0x07B0}, {0x0901, 0x0902}, {0x093C, 0x093C},
+    {0x0941, 0x0948}, {0x094D, 0x094D}, {0x0951, 0x0954},
+    {0x0962, 0x0963}, {0x0981, 0x0981}, {0x09BC, 0x09BC},
+    {0x09C1, 0x09C4}, {0x09CD, 0x09CD}, {0x09E2, 0x09E3},
+    {0x0A02, 0x0A02}, {0x0A3C, 0x0A3C}, {0x0A41, 0x0A42},
+    {0x0A47, 0x0A48}, {0x0A4B, 0x0A4D}, {0x0A70, 0x0A71},
+    {0x0A81, 0x0A82}, {0x0ABC, 0x0ABC}, {0x0AC1, 0x0AC5},
+    {0x0AC7, 0x0AC8}, {0x0ACD, 0x0ACD}, {0x0B01, 0x0B01},
+    {0x0B3C, 0x0B3C}, {0x0B3F, 0x0B3F}, {0x0B41, 0x0B43},
+    {0x0B4D, 0x0B4D}, {0x0B56, 0x0B56}, {0x0B82, 0x0B82},
+    {0x0BC0, 0x0BC0}, {0x0BCD, 0x0BCD}, {0x0C3E, 0x0C40},
+    {0x0C46, 0x0C48}, {0x0C4A, 0x0C4D}, {0x0C55, 0x0C56},
+    {0x0CBF, 0x0CBF}, {0x0CC6, 0x0CC6}, {0x0CCC, 0x0CCD},
+    {0x0D41, 0x0D43}, {0x0D4D, 0x0D4D}, {0x0DCA, 0x0DCA},
+    {0x0DD2, 0x0DD4}, {0x0DD6, 0x0DD6}, {0x0E31, 0x0E31},
+    {0x0E34, 0x0E3A}, {0x0E47, 0x0E4E}, {0x0EB1, 0x0EB1},
+    {0x0EB4, 0x0EB9}, {0x0EBB, 0x0EBC}, {0x0EC8, 0x0ECD},
+    {0x0F18, 0x0F19}, {0x0F35, 0x0F35}, {0x0F37, 0x0F37},
+    {0x0F39, 0x0F39}, {0x0F71, 0x0F7E}, {0x0F80, 0x0F84},
+    {0x0F86, 0x0F87}, {0x0F90, 0x0F97}, {0x0F99, 0x0FBC},
+    {0x0FC6, 0x0FC6}, {0x102D, 0x1030}, {0x1032, 0x1032},
+    {0x1036, 0x1037}, {0x1039, 0x1039}, {0x1058, 0x1059},
+    {0x1160, 0x11FF}, {0x17B7, 0x17BD}, {0x17C6, 0x17C6},
+    {0x17C9, 0x17D3}, {0x180B, 0x180E}, {0x18A9, 0x18A9},
+    {0x200B, 0x200F}, {0x202A, 0x202E}, {0x206A, 0x206F},
+    {0x20D0, 0x20E3}, {0x302A, 0x302F}, {0x3099, 0x309A},
+    {0xFB1E, 0xFB1E}, {0xFE20, 0xFE23}, {0xFEFF, 0xFEFF},
+    {0xFFF9, 0xFFFB}
+  };
+
+  /* test for 8-bit control characters */
+  if (ucs == 0)
+    return 0;
+  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
+    return -1;
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch (ucs, combining,
+		sizeof (combining) / sizeof (struct interval) - 1))
+    return 0;
+
+  /* if we arrive here, ucs is not a combining or C0/C1 control character */
+
+  return 1 + (ucs >= 0x1100 && (ucs <= 0x115f ||	/* Hangul Jamo init. consonants */
+				(ucs >= 0x2e80 && ucs <= 0xa4cf && (ucs & ~0x0011) != 0x300a && ucs != 0x303f) ||	/* CJK ... Yi */
+				(ucs >= 0xac00 && ucs <= 0xd7a3) ||	/* Hangul Syllables */
+				(ucs >= 0xf900 && ucs <= 0xfaff) ||	/* CJK Compatibility Ideographs */
+				(ucs >= 0xfe30 && ucs <= 0xfe6f) ||	/* CJK Compatibility Forms */
+				(ucs >= 0xff00 && ucs <= 0xff5f) ||	/* Fullwidth Forms */
+				(ucs >= 0xffe0 && ucs <= 0xffe6)	/* do not compare UINT16 with 0x20000 ||
+									   (ucs >= 0x20000 && ucs <= 0x2ffff) */ ));
+}
+
+#if 0
+/*
+ * The following function is the same as konsole_wcwidth(), except that
+ * spacing characters in the East Asian Ambiguous (A) category as
+ * defined in Unicode Technical Report #11 have a column width of 2.
+ * This experimental variant might be useful for users of CJK legacy
+ * encodings who want to migrate to UCS. It is not otherwise
+ * recommended for general use.
+ */
+int
+konsole_wcwidth_cjk (quint16 ucs)
+{
+  /* sorted list of non-overlapping intervals of East Asian Ambiguous
+   * characters */
+  static const struct interval ambiguous[] = {
+    {0x00A1, 0x00A1}, {0x00A4, 0x00A4}, {0x00A7, 0x00A8},
+    {0x00AA, 0x00AA}, {0x00AD, 0x00AD}, {0x00B0, 0x00B4},
+    {0x00B6, 0x00BA}, {0x00BC, 0x00BF}, {0x00C6, 0x00C6},
+    {0x00D0, 0x00D0}, {0x00D7, 0x00D8}, {0x00DE, 0x00E1},
+    {0x00E6, 0x00E6}, {0x00E8, 0x00EA}, {0x00EC, 0x00ED},
+    {0x00F0, 0x00F0}, {0x00F2, 0x00F3}, {0x00F7, 0x00FA},
+    {0x00FC, 0x00FC}, {0x00FE, 0x00FE}, {0x0101, 0x0101},
+    {0x0111, 0x0111}, {0x0113, 0x0113}, {0x011B, 0x011B},
+    {0x0126, 0x0127}, {0x012B, 0x012B}, {0x0131, 0x0133},
+    {0x0138, 0x0138}, {0x013F, 0x0142}, {0x0144, 0x0144},
+    {0x0148, 0x014A}, {0x014D, 0x014D}, {0x0152, 0x0153},
+    {0x0166, 0x0167}, {0x016B, 0x016B}, {0x01CE, 0x01CE},
+    {0x01D0, 0x01D0}, {0x01D2, 0x01D2}, {0x01D4, 0x01D4},
+    {0x01D6, 0x01D6}, {0x01D8, 0x01D8}, {0x01DA, 0x01DA},
+    {0x01DC, 0x01DC}, {0x0251, 0x0251}, {0x0261, 0x0261},
+    {0x02C7, 0x02C7}, {0x02C9, 0x02CB}, {0x02CD, 0x02CD},
+    {0x02D0, 0x02D0}, {0x02D8, 0x02DB}, {0x02DD, 0x02DD},
+    {0x0391, 0x03A1}, {0x03A3, 0x03A9}, {0x03B1, 0x03C1},
+    {0x03C3, 0x03C9}, {0x0401, 0x0401}, {0x0410, 0x044F},
+    {0x0451, 0x0451}, {0x2010, 0x2010}, {0x2013, 0x2016},
+    {0x2018, 0x2019}, {0x201C, 0x201D}, {0x2020, 0x2021},
+    {0x2025, 0x2027}, {0x2030, 0x2030}, {0x2032, 0x2033},
+    {0x2035, 0x2035}, {0x203B, 0x203B}, {0x2074, 0x2074},
+    {0x207F, 0x207F}, {0x2081, 0x2084}, {0x20AC, 0x20AC},
+    {0x2103, 0x2103}, {0x2105, 0x2105}, {0x2109, 0x2109},
+    {0x2113, 0x2113}, {0x2121, 0x2122}, {0x2126, 0x2126},
+    {0x212B, 0x212B}, {0x2154, 0x2155}, {0x215B, 0x215B},
+    {0x215E, 0x215E}, {0x2160, 0x216B}, {0x2170, 0x2179},
+    {0x2190, 0x2199}, {0x21D2, 0x21D2}, {0x21D4, 0x21D4},
+    {0x2200, 0x2200}, {0x2202, 0x2203}, {0x2207, 0x2208},
+    {0x220B, 0x220B}, {0x220F, 0x220F}, {0x2211, 0x2211},
+    {0x2215, 0x2215}, {0x221A, 0x221A}, {0x221D, 0x2220},
+    {0x2223, 0x2223}, {0x2225, 0x2225}, {0x2227, 0x222C},
+    {0x222E, 0x222E}, {0x2234, 0x2237}, {0x223C, 0x223D},
+    {0x2248, 0x2248}, {0x224C, 0x224C}, {0x2252, 0x2252},
+    {0x2260, 0x2261}, {0x2264, 0x2267}, {0x226A, 0x226B},
+    {0x226E, 0x226F}, {0x2282, 0x2283}, {0x2286, 0x2287},
+    {0x2295, 0x2295}, {0x2299, 0x2299}, {0x22A5, 0x22A5},
+    {0x22BF, 0x22BF}, {0x2312, 0x2312}, {0x2460, 0x24BF},
+    {0x24D0, 0x24E9}, {0x2500, 0x254B}, {0x2550, 0x2574},
+    {0x2580, 0x258F}, {0x2592, 0x2595}, {0x25A0, 0x25A1},
+    {0x25A3, 0x25A9}, {0x25B2, 0x25B3}, {0x25B6, 0x25B7},
+    {0x25BC, 0x25BD}, {0x25C0, 0x25C1}, {0x25C6, 0x25C8},
+    {0x25CB, 0x25CB}, {0x25CE, 0x25D1}, {0x25E2, 0x25E5},
+    {0x25EF, 0x25EF}, {0x2605, 0x2606}, {0x2609, 0x2609},
+    {0x260E, 0x260F}, {0x261C, 0x261C}, {0x261E, 0x261E},
+    {0x2640, 0x2640}, {0x2642, 0x2642}, {0x2660, 0x2661},
+    {0x2663, 0x2665}, {0x2667, 0x266A}, {0x266C, 0x266D},
+    {0x266F, 0x266F}, {0x300A, 0x300B}, {0x301A, 0x301B},
+    {0xE000, 0xF8FF}, {0xFFFD, 0xFFFD}
+  };
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch (ucs, ambiguous,
+		sizeof (ambiguous) / sizeof (struct interval) - 1))
+    return 2;
+
+  return konsole_wcwidth (ucs);
+}
+#endif
+
+// single byte char: +1, multi byte char: +2
+int
+string_width (const QString & txt)
+{
+  int w = 0;
+  for (int i = 0; i < txt.length (); ++i)
+    w += konsole_wcwidth (txt[i].unicode ());
+  return w;
+}
diff --git a/gui/src/terminal/konsole_wcwidth.h b/gui/src/terminal/konsole_wcwidth.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/konsole_wcwidth.h
@@ -0,0 +1,24 @@
+/* $XFree86: xc/programs/xterm/wcwidth.h,v 1.2 2001/06/18 19:09:27 dickey Exp $ */
+
+/* Markus Kuhn -- 2001-01-12 -- public domain */
+/* Adaptions for KDE by Waldo Bastian <bastian@kde.org> */
+/*
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>
+*/
+
+
+#ifndef	_KONSOLE_WCWIDTH_H_
+#define	_KONSOLE_WCWIDTH_H_
+
+// Qt
+#include <QtCore/QBool>
+#include <QtCore/QString>
+
+int konsole_wcwidth (quint16 ucs);
+#if 0
+int konsole_wcwidth_cjk (Q_UINT16 ucs);
+#endif
+
+int string_width (const QString & txt);
+
+#endif
diff --git a/gui/src/terminal/kprocess.cpp b/gui/src/terminal/kprocess.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kprocess.cpp
@@ -0,0 +1,356 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "kprocess_p.h"
+
+#include <qfile.h>
+
+#ifdef Q_OS_WIN
+#include <windows.h>
+#else
+#include <unistd.h>
+#include <errno.h>
+#endif
+
+#ifndef Q_OS_WIN
+#define STD_OUTPUT_HANDLE 1
+#define STD_ERROR_HANDLE 2
+#endif
+
+#ifdef _WIN32_WCE
+#include <stdio.h>
+#endif
+
+void
+KProcessPrivate::writeAll (const QByteArray & buf, int fd)
+{
+#ifdef Q_OS_WIN
+#ifndef _WIN32_WCE
+  HANDLE h = GetStdHandle (fd);
+  if (h)
+    {
+      DWORD wr;
+      WriteFile (h, buf.data (), buf.size (), &wr, 0);
+    }
+#else
+  fwrite (buf.data (), 1, buf.size (), (FILE *) fd);
+#endif
+#else
+  int off = 0;
+  do
+    {
+      int ret =::write (fd, buf.data () + off, buf.size () - off);
+      if (ret < 0)
+	{
+	  if (errno != EINTR)
+	    return;
+	}
+      else
+	{
+	  off += ret;
+	}
+    }
+  while (off < buf.size ());
+#endif
+}
+
+void
+KProcessPrivate::forwardStd (KProcess::ProcessChannel good, int fd)
+{
+  Q_Q (KProcess);
+
+  QProcess::ProcessChannel oc = q->readChannel ();
+  q->setReadChannel (good);
+  writeAll (q->readAll (), fd);
+  q->setReadChannel (oc);
+}
+
+void
+KProcessPrivate::_k_forwardStdout ()
+{
+#ifndef _WIN32_WCE
+  forwardStd (KProcess::StandardOutput, STD_OUTPUT_HANDLE);
+#else
+  forwardStd (KProcess::StandardOutput, (int) stdout);
+#endif
+}
+
+void
+KProcessPrivate::_k_forwardStderr ()
+{
+#ifndef _WIN32_WCE
+  forwardStd (KProcess::StandardError, STD_ERROR_HANDLE);
+#else
+  forwardStd (KProcess::StandardError, (int) stderr);
+#endif
+}
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KProcess::KProcess (QObject * parent):
+QProcess (parent), d_ptr (new KProcessPrivate)
+{
+  d_ptr->q_ptr = this;
+  setOutputChannelMode (ForwardedChannels);
+}
+
+KProcess::KProcess (KProcessPrivate * d, QObject * parent):
+QProcess (parent), d_ptr (d)
+{
+  d_ptr->q_ptr = this;
+  setOutputChannelMode (ForwardedChannels);
+}
+
+KProcess::~KProcess ()
+{
+  delete d_ptr;
+}
+
+void
+KProcess::setOutputChannelMode (OutputChannelMode mode)
+{
+  Q_D (KProcess);
+
+  d->outputChannelMode = mode;
+  disconnect (this, SIGNAL (readyReadStandardOutput ()));
+  disconnect (this, SIGNAL (readyReadStandardError ()));
+  switch (mode)
+    {
+    case OnlyStdoutChannel:
+      connect (this, SIGNAL (readyReadStandardError ()),
+	       SLOT (_k_forwardStderr ()));
+      break;
+    case OnlyStderrChannel:
+      connect (this, SIGNAL (readyReadStandardOutput ()),
+	       SLOT (_k_forwardStdout ()));
+      break;
+    default:
+      QProcess::setProcessChannelMode ((ProcessChannelMode) mode);
+      return;
+    }
+  QProcess::setProcessChannelMode (QProcess::SeparateChannels);
+}
+
+KProcess::OutputChannelMode KProcess::outputChannelMode () const
+{
+  Q_D (const KProcess);
+
+  return d->outputChannelMode;
+}
+
+#define DUMMYENV "_KPROCESS_DUMMY_="
+
+void
+KProcess::setEnvironmentVariable (const QString & name, const QString & value, bool overwrite)
+{
+  QStringList env = environment ();
+  if (env.isEmpty ())
+    {
+      env = systemEnvironment ();
+      env.removeAll (QString::fromLatin1 (DUMMYENV));
+    }
+  QString fname (name);
+  fname.append (QLatin1Char ('='));
+  for (QStringList::Iterator it = env.begin (); it != env.end (); ++it)
+    if ((*it).startsWith (fname))
+      {
+	if (overwrite)
+	  {
+	    *it = fname.append (value);
+	    setEnvironment (env);
+	  }
+	return;
+      }
+  env.append (fname.append (value));
+  setEnvironment (env);
+}
+
+void
+KProcess::unsetEnvironmentVariable (const QString & name)
+{
+  QStringList env = environment ();
+  if (env.isEmpty ())
+    {
+      env = systemEnvironment ();
+      env.removeAll (QString::fromLatin1 (DUMMYENV));
+    }
+  QString fname (name);
+  fname.append (QLatin1Char ('='));
+  for (QStringList::Iterator it = env.begin (); it != env.end (); ++it)
+    if ((*it).startsWith (fname))
+      {
+	env.erase (it);
+	if (env.isEmpty ())
+	  env.append (QString::fromLatin1 (DUMMYENV));
+	setEnvironment (env);
+	return;
+      }
+}
+
+void
+KProcess::setProgram (const QString & exe, const QStringList & args)
+{
+  Q_D (KProcess);
+
+  d->prog = exe;
+  d->args = args;
+#ifdef Q_OS_WIN
+  setNativeArguments (QString ());
+#endif
+}
+
+void
+KProcess::setProgram (const QStringList & argv)
+{
+  Q_D (KProcess);
+
+  Q_ASSERT (!argv.isEmpty ());
+  d->args = argv;
+  d->prog = d->args.takeFirst ();
+#ifdef Q_OS_WIN
+  setNativeArguments (QString ());
+#endif
+}
+
+KProcess & KProcess::operator<< (const QString & arg)
+{
+  Q_D (KProcess);
+
+  if (d->prog.isEmpty ())
+    d->prog = arg;
+  else
+    d->args << arg;
+  return *this;
+}
+
+KProcess & KProcess::operator<< (const QStringList & args)
+{
+  Q_D (KProcess);
+
+  if (d->prog.isEmpty ())
+    setProgram (args);
+  else
+    d->args << args;
+  return *this;
+}
+
+void
+KProcess::clearProgram ()
+{
+  Q_D (KProcess);
+
+  d->prog.clear ();
+  d->args.clear ();
+#ifdef Q_OS_WIN
+  setNativeArguments (QString ());
+#endif
+}
+
+QStringList
+KProcess::program () const
+{
+  Q_D (const KProcess);
+
+  QStringList argv = d->args;
+  argv.prepend (d->prog);
+  return argv;
+}
+
+void
+KProcess::start ()
+{
+  Q_D (KProcess);
+
+  QProcess::start (d->prog, d->args, d->openMode);
+}
+
+int
+KProcess::execute (int msecs)
+{
+  start ();
+  if (!waitForFinished (msecs))
+    {
+      kill ();
+      waitForFinished (-1);
+      return -2;
+    }
+  return (exitStatus () == QProcess::NormalExit) ? exitCode () : -1;
+}
+
+// static
+int
+KProcess::execute (const QString & exe, const QStringList & args, int msecs)
+{
+  KProcess p;
+  p.setProgram (exe, args);
+  return p.execute (msecs);
+}
+
+// static
+int
+KProcess::execute (const QStringList & argv, int msecs)
+{
+  KProcess p;
+  p.setProgram (argv);
+  return p.execute (msecs);
+}
+
+int
+KProcess::startDetached ()
+{
+  Q_D (KProcess);
+
+  qint64 pid;
+  if (!QProcess::startDetached (d->prog, d->args, workingDirectory (), &pid))
+    return 0;
+  return (int) pid;
+}
+
+// static
+int
+KProcess::startDetached (const QString & exe, const QStringList & args)
+{
+  qint64 pid;
+  if (!QProcess::startDetached (exe, args, QString (), &pid))
+    return 0;
+  return (int) pid;
+}
+
+// static
+int
+KProcess::startDetached (const QStringList & argv)
+{
+  QStringList args = argv;
+  QString prog = args.takeFirst ();
+  return startDetached (prog, args);
+}
+
+int
+KProcess::pid () const
+{
+#ifdef Q_OS_UNIX
+  return (int) QProcess::pid ();
+#else
+  return QProcess::pid ()? QProcess::pid ()->dwProcessId : 0;
+#endif
+}
diff --git a/gui/src/terminal/kprocess.h b/gui/src/terminal/kprocess.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kprocess.h
@@ -0,0 +1,299 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPROCESS_H
+#define KPROCESS_H
+
+#include <QtCore/QProcess>
+class KProcess;
+class KProcessPrivate;
+
+
+/**
+ * \class KProcess kprocess.h <KProcess>
+ * 
+ * Child process invocation, monitoring and control.
+ *
+ * This class extends QProcess by some useful functionality, overrides
+ * some defaults with saner values and wraps parts of the API into a more
+ * accessible one.
+ * This is the preferred way of spawning child processes in KDE; don't
+ * use QProcess directly.
+ *
+ * @author Oswald Buddenhagen <ossi@kde.org>
+ **/
+class KProcess:public QProcess
+{
+Q_OBJECT Q_DECLARE_PRIVATE (KProcess) public:
+
+    /**
+     * Modes in which the output channels can be opened.
+     */
+  enum OutputChannelMode
+  {
+    SeparateChannels = QProcess::SeparateChannels,
+	    /**< Standard output and standard error are handled by KProcess
+                 as separate channels */
+    MergedChannels = QProcess::MergedChannels,
+	    /**< Standard output and standard error are handled by KProcess
+                 as one channel */
+    ForwardedChannels = QProcess::ForwardedChannels,
+	    /**< Both standard output and standard error are forwarded
+                 to the parent process' respective channel */
+    OnlyStdoutChannel,
+	    /**< Only standard output is handled; standard error is forwarded */
+    OnlyStderrChannel	   /**< Only standard error is handled; standard output is forwarded */
+  };
+
+    /**
+     * Constructor
+     */
+  explicit KProcess (QObject * parent = 0);
+
+    /**
+     * Destructor
+     */
+    virtual ~ KProcess ();
+
+    /**
+     * Set how to handle the output channels of the child process.
+     *
+     * The default is ForwardedChannels, which is unlike in QProcess.
+     * Do not request more than you actually handle, as this output is
+     * simply lost otherwise.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param mode the output channel handling mode
+     */
+  void setOutputChannelMode (OutputChannelMode mode);
+
+    /**
+     * Query how the output channels of the child process are handled.
+     *
+     * @return the output channel handling mode
+     */
+  OutputChannelMode outputChannelMode () const;
+
+    /**
+     * Adds the variable @p name to the process' environment.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param name the name of the environment variable
+     * @param value the new value for the environment variable
+     * @param overwrite if @c false and the environment variable is already
+     *   set, the old value will be preserved
+     */
+  void setEnvironmentVariable (const QString & name, const QString & value, bool overwrite =
+	       true);
+
+    /**
+     * Removes the variable @p name from the process' environment.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param name the name of the environment variable
+     */
+  void unsetEnvironmentVariable (const QString & name);
+
+    /**
+     * Set the program and the command line arguments.
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param exe the program to execute
+     * @param args the command line arguments for the program,
+     *   one per list element
+     */
+  void setProgram (const QString & exe, const QStringList & args =
+		   QStringList ());
+
+    /**
+     * @overload
+     *
+     * @param argv the program to execute and the command line arguments
+     *   for the program, one per list element
+     */
+  void setProgram (const QStringList & argv);
+
+    /**
+     * Append an element to the command line argument list for this process.
+     *
+     * If no executable is set yet, it will be set instead.
+     *
+     * For example, doing an "ls -l /usr/local/bin" can be achieved by:
+     *  \code
+     *  KProcess p;
+     *  p << "ls" << "-l" << "/usr/local/bin";
+     *  ...
+     *  \endcode
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param arg the argument to add
+     * @return a reference to this KProcess
+     */
+    KProcess & operator<< (const QString & arg);
+
+    /**
+     * @overload
+     *
+     * @param args the arguments to add
+     * @return a reference to this KProcess
+     */
+    KProcess & operator<< (const QStringList & args);
+
+    /**
+     * Clear the program and command line argument list.
+     */
+  void clearProgram ();
+
+    /**
+     * Obtain the currently set program and arguments.
+     *
+     * @return a list, the first element being the program, the remaining ones
+     *  being command line arguments to the program.
+     */
+  QStringList program () const;
+
+    /**
+     * Start the process.
+     *
+     * @see QProcess::start(const QString &, const QStringList &, OpenMode)
+     */
+  void start ();
+
+    /**
+     * Start the process, wait for it to finish, and return the exit code.
+     *
+     * This method is roughly equivalent to the sequence:
+     * <code>
+     *   start();
+     *   waitForFinished(msecs);
+     *   return exitCode();
+     * </code>
+     *
+     * Unlike the other execute() variants this method is not static,
+     * so the process can be parametrized properly and talked to.
+     *
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+  int execute (int msecs = -1);
+
+    /**
+     * @overload
+     *
+     * @param exe the program to execute
+     * @param args the command line arguments for the program,
+     *   one per list element
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+  static int execute (const QString & exe, const QStringList & args =
+		      QStringList (), int msecs = -1);
+
+    /**
+     * @overload
+     *
+     * @param argv the program to execute and the command line arguments
+     *   for the program, one per list element
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+  static int execute (const QStringList & argv, int msecs = -1);
+
+    /**
+     * Start the process and detach from it. See QProcess::startDetached()
+     * for details.
+     *
+     * Unlike the other startDetached() variants this method is not static,
+     * so the process can be parametrized properly.
+     * @note Currently, only the setProgram()/setShellCommand() and
+     * setWorkingDirectory() parametrizations are supported.
+     *
+     * The KProcess object may be re-used immediately after calling this
+     * function.
+     *
+     * @return the PID of the started process or 0 on error
+     */
+  int startDetached ();
+
+    /**
+     * @overload
+     *
+     * @param exe the program to start
+     * @param args the command line arguments for the program,
+     *   one per list element
+     * @return the PID of the started process or 0 on error
+     */
+  static int startDetached (const QString & exe, const QStringList & args =
+			    QStringList ());
+
+    /**
+     * @overload
+     *
+     * @param argv the program to start and the command line arguments
+     *   for the program, one per list element
+     * @return the PID of the started process or 0 on error
+     */
+  static int startDetached (const QStringList & argv);
+
+    /**
+     * Obtain the process' ID as known to the system.
+     *
+     * Unlike with QProcess::pid(), this is a real PID also on Windows.
+     *
+     * This function can be called only while the process is running.
+     * It cannot be applied to detached processes.
+     *
+     * @return the process ID
+     */
+  int pid () const;
+
+protected:
+    /**
+     * @internal
+     */
+    KProcess (KProcessPrivate * d, QObject * parent);
+
+    /**
+     * @internal
+     */
+  KProcessPrivate *const d_ptr;
+
+private:
+  // hide those
+    using QProcess::setReadChannelMode;
+  using QProcess::readChannelMode;
+  using QProcess::setProcessChannelMode;
+  using QProcess::processChannelMode;
+
+  Q_PRIVATE_SLOT (d_func (), void _k_forwardStdout ())
+    Q_PRIVATE_SLOT (d_func (), void _k_forwardStderr ())};
+
+#include "kprocess_p.h"
+
+#endif
diff --git a/gui/src/terminal/kprocess_p.h b/gui/src/terminal/kprocess_p.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kprocess_p.h
@@ -0,0 +1,48 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPROCESS_P_H
+#define KPROCESS_P_H
+class KProcess;
+class KProcessPrivate;
+
+#include "kprocess.h"
+class KProcessPrivate
+{
+Q_DECLARE_PUBLIC (KProcess) protected:
+  KProcessPrivate ():openMode (QIODevice::ReadWrite)
+  {
+  }
+  void writeAll (const QByteArray & buf, int fd);
+  void forwardStd (KProcess::ProcessChannel good, int fd);
+  void _k_forwardStdout ();
+  void _k_forwardStderr ();
+
+  QString prog;
+  QStringList args;
+  KProcess::OutputChannelMode outputChannelMode;
+  QIODevice::OpenMode openMode;
+
+  KProcess *q_ptr;
+};
+
+
+#endif
diff --git a/gui/src/terminal/kpty.cpp b/gui/src/terminal/kpty.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kpty.cpp
@@ -0,0 +1,764 @@
+/*
+
+   This file is part of the KDE libraries
+   Copyright (C) 2002 Waldo Bastian <bastian@kde.org>
+   Copyright (C) 2002-2003,2007-2008 Oswald Buddenhagen <ossi@kde.org>
+   Copyright (C) 2010 KDE e.V. <kde-ev-board@kde.org>
+     Author Adriaan de Groot <groot@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kpty_p.h"
+
+#ifdef __sgi
+#define __svr4__
+#endif
+
+#ifdef __osf__
+#define _OSF_SOURCE
+#include <float.h>
+#endif
+
+#ifdef _AIX
+#define _ALL_SOURCE
+#endif
+
+// __USE_XOPEN isn't defined by default in ICC
+// (needed for ptsname(), grantpt() and unlockpt())
+#ifdef __INTEL_COMPILER
+#ifndef __USE_XOPEN
+#define __USE_XOPEN
+#endif
+#endif
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <grp.h>
+
+#if defined(HAVE_PTY_H)
+#include <pty.h>
+#endif
+
+#ifdef HAVE_LIBUTIL_H
+#include <libutil.h>
+#elif defined(HAVE_UTIL_H)
+#include <util.h>
+#endif
+
+#define HAVE_UTMPX
+#define _UTMPX_COMPAT
+
+#ifdef HAVE_UTEMPTER
+extern "C"
+{
+#include <utempter.h>
+}
+#else
+#include <utmp.h>
+#ifdef HAVE_UTMPX
+#include <utmpx.h>
+#endif
+#if !defined(_PATH_UTMPX) && defined(_UTMPX_FILE)
+#define _PATH_UTMPX _UTMPX_FILE
+#endif
+#if !defined(_PATH_WTMPX) && defined(_WTMPX_FILE)
+#define _PATH_WTMPX _WTMPX_FILE
+#endif
+#endif
+
+/* for HP-UX (some versions) the extern C is needed, and for other
+   platforms it doesn't hurt */
+extern "C"
+{
+#include <termios.h>
+#if defined(HAVE_TERMIO_H)
+#include <termio.h>		// struct winsize on some systems
+#endif
+}
+
+#if defined (_HPUX_SOURCE)
+#define _TERMIOS_INCLUDED
+#include <bsdtty.h>
+#endif
+
+#ifdef HAVE_SYS_STROPTS_H
+#include <sys/stropts.h>	// Defines I_PUSH
+#define _NEW_TTY_CTRL
+#endif
+
+#if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
+#define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
+#else
+#if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__) || defined(__sun)
+#define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
+#else
+#define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
+#endif
+#endif
+
+#if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
+#define _tcsetattr(fd, ttmode) ioctl(fd, TIOCSETA, (char *)ttmode)
+#else
+#if defined(_HPUX_SOURCE) || defined(__CYGWIN__) || defined(__sun)
+#define _tcsetattr(fd, ttmode) tcsetattr(fd, TCSANOW, ttmode)
+#else
+#define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
+#endif
+#endif
+
+#include <QtCore/Q_PID>
+
+#define TTY_GROUP "tty"
+
+#ifndef PATH_MAX
+#ifdef MAXPATHLEN
+#define PATH_MAX MAXPATHLEN
+#else
+#define PATH_MAX 1024
+#endif
+#endif
+
+///////////////////////
+// private functions //
+///////////////////////
+
+//////////////////
+// private data //
+//////////////////
+
+KPtyPrivate::KPtyPrivate (KPty * parent):
+masterFd (-1),
+slaveFd (-1),
+ownMaster (true),
+q_ptr (parent)
+{
+}
+
+KPtyPrivate::~KPtyPrivate ()
+{
+}
+
+#ifndef HAVE_OPENPTY
+bool
+KPtyPrivate::chownpty (bool grant)
+{
+  return !QProcess::execute (KStandardDirs::findExe ("kgrantpty"),
+			     QStringList () << (grant ? "--grant" :
+						"--revoke") << QString::
+			     number (masterFd));
+}
+#endif
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KPty::KPty ():
+d_ptr (new KPtyPrivate (this))
+{
+}
+
+KPty::KPty (KPtyPrivate * d):
+d_ptr (d)
+{
+  d_ptr->q_ptr = this;
+}
+
+KPty::~KPty ()
+{
+  close ();
+  delete d_ptr;
+}
+
+bool
+KPty::open ()
+{
+  Q_D (KPty);
+
+  if (d->masterFd >= 0)
+    return true;
+
+  d->ownMaster = true;
+
+  QByteArray ptyName;
+
+  // Find a master pty that we can open ////////////////////////////////
+
+  // Because not all the pty animals are created equal, they want to
+  // be opened by several different methods.
+
+  // We try, as we know them, one by one.
+
+#ifdef HAVE_OPENPTY
+
+  char ptsn[PATH_MAX];
+  if (::openpty (&d->masterFd, &d->slaveFd, ptsn, 0, 0))
+    {
+      d->masterFd = -1;
+      d->slaveFd = -1;
+      //kWarning(175) << "Can't open a pseudo teletype";
+      return false;
+    }
+  d->ttyName = ptsn;
+
+#else
+
+#ifdef HAVE__GETPTY		// irix
+
+  char *ptsn =
+    _getpty (&d->masterFd, O_RDWR | O_NOCTTY, S_IRUSR | S_IWUSR, 0);
+  if (ptsn)
+    {
+      d->ttyName = ptsn;
+      goto grantedpt;
+    }
+
+#elif defined(HAVE_PTSNAME) || defined(TIOCGPTN)
+
+#ifdef HAVE_POSIX_OPENPT
+  d->masterFd =::posix_openpt (O_RDWR | O_NOCTTY);
+#elif defined(HAVE_GETPT)
+  d->masterFd =::getpt ();
+#elif defined(PTM_DEVICE)
+  //d->masterFd = KDE_open(PTM_DEVICE, O_RDWR|O_NOCTTY);
+  d->masterFd =::open (PTM_DEVICE, O_RDWR | O_NOCTTY);
+#else
+#error No method to open a PTY master detected.
+#endif
+  if (d->masterFd >= 0)
+    {
+#ifdef HAVE_PTSNAME
+      char *ptsn = ptsname (d->masterFd);
+      if (ptsn)
+	{
+	  d->ttyName = ptsn;
+#else
+      int ptyno;
+      if (!ioctl (d->masterFd, TIOCGPTN, &ptyno))
+	{
+	  char buf[32];
+	  sprintf (buf, "/dev/pts/%d", ptyno);
+	  d->ttyName = buf;
+#endif
+#ifdef HAVE_GRANTPT
+	  if (!grantpt (d->masterFd))
+	    goto grantedpt;
+#else
+	  goto gotpty;
+#endif
+	}
+      ::close (d->masterFd);
+      d->masterFd = -1;
+    }
+#endif // HAVE_PTSNAME || TIOCGPTN
+
+  // Linux device names, FIXME: Trouble on other systems?
+  for (const char *s3 = "pqrstuvwxyzabcde"; *s3; s3++)
+    {
+      for (const char *s4 = "0123456789abcdef"; *s4; s4++)
+	{
+	  ptyName = QString ().sprintf ("/dev/pty%c%c", *s3, *s4).toAscii ();
+	  d->ttyName =
+	    QString ().sprintf ("/dev/tty%c%c", *s3, *s4).toAscii ();
+
+	  d->masterFd =::open (ptyName.data (), O_RDWR);
+	  if (d->masterFd >= 0)
+	    {
+#ifdef Q_OS_SOLARIS
+	      /* Need to check the process group of the pty.
+	       * If it exists, then the slave pty is in use,
+	       * and we need to get another one.
+	       */
+	      int pgrp_rtn;
+	      if (ioctl (d->masterFd, TIOCGPGRP, &pgrp_rtn) == 0
+		  || errno != EIO)
+		{
+		  ::close (d->masterFd);
+		  d->masterFd = -1;
+		  continue;
+		}
+#endif /* Q_OS_SOLARIS */
+	      if (!access (d->ttyName.data (), R_OK | W_OK))	// checks availability based on permission bits
+		{
+		  if (!geteuid ())
+		    {
+		      struct group *p = getgrnam (TTY_GROUP);
+		      if (!p)
+			p = getgrnam ("wheel");
+		      gid_t gid = p ? p->gr_gid : getgid ();
+
+		      chown (d->ttyName.data (), getuid (), gid);
+		      chmod (d->ttyName.data (), S_IRUSR | S_IWUSR | S_IWGRP);
+		    }
+		  goto gotpty;
+		}
+	      ::close (d->masterFd);
+	      d->masterFd = -1;
+	    }
+	}
+    }
+
+  //kWarning(175) << "Can't open a pseudo teletype";
+  return false;
+
+gotpty:
+  KDE_struct_stat st;
+  if (KDE_stat (d->ttyName.data (), &st))
+    return false;		// this just cannot happen ... *cough*  Yeah right, I just
+  // had it happen when pty #349 was allocated.  I guess
+  // there was some sort of leak?  I only had a few open.
+  if (((st.st_uid != getuid ()) ||
+       (st.st_mode & (S_IRGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH))) &&
+      !d->chownpty (true))
+    {
+
+      /*kWarning(175)
+         << "chownpty failed for device " << ptyName << "::" << d->ttyName
+         << "\nThis means the communication can be eavesdropped." << endl;
+       */
+    }
+
+grantedpt:
+
+#ifdef HAVE_REVOKE
+  revoke (d->ttyName.data ());
+#endif
+
+#ifdef HAVE_UNLOCKPT
+  unlockpt (d->masterFd);
+#elif defined(TIOCSPTLCK)
+  int flag = 0;
+  ioctl (d->masterFd, TIOCSPTLCK, &flag);
+#endif
+
+  d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
+  if (d->slaveFd < 0)
+    {
+      //kWarning(175) << "Can't open slave pseudo teletype";
+      ::close (d->masterFd);
+      d->masterFd = -1;
+      return false;
+    }
+
+#if (defined(__svr4__) || defined(__sgi__) || defined(Q_OS_SOLARIS))
+  // Solaris uses STREAMS for terminal handling. It is possible
+  // for the pty handling modules to be left off the stream; in that
+  // case push them on. ioctl(fd, I_FIND, ...) is documented to return
+  // 1 if the module is on the stream already.
+  {
+    static const char *pt = "ptem";
+    static const char *ld = "ldterm";
+    if (ioctl (d->slaveFd, I_FIND, pt) == 0)
+      ioctl (d->slaveFd, I_PUSH, pt);
+    if (ioctl (d->slaveFd, I_FIND, ld) == 0)
+      ioctl (d->slaveFd, I_PUSH, ld);
+  }
+#endif
+
+#endif /* HAVE_OPENPTY */
+
+  fcntl (d->masterFd, F_SETFD, FD_CLOEXEC);
+  fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
+
+  return true;
+}
+
+bool
+KPty::open (int fd)
+{
+#if !defined(HAVE_PTSNAME) && !defined(TIOCGPTN)
+  //kWarning(175) << "Unsupported attempt to open pty with fd" << fd;
+  return false;
+#else
+  Q_D (KPty);
+
+  if (d->masterFd >= 0)
+    {
+      //kWarning(175) << "Attempting to open an already open pty";
+      return false;
+    }
+
+  d->ownMaster = false;
+
+#ifdef HAVE_PTSNAME
+  char *ptsn = ptsname (fd);
+  if (ptsn)
+    {
+      d->ttyName = ptsn;
+#else
+  int ptyno;
+  if (!ioctl (fd, TIOCGPTN, &ptyno))
+    {
+      char buf[32];
+      sprintf (buf, "/dev/pts/%d", ptyno);
+      d->ttyName = buf;
+#endif
+    }
+  else
+    {
+      //kWarning(175) << "Failed to determine pty slave device for fd" << fd;
+      return false;
+    }
+
+  d->masterFd = fd;
+  if (!openSlave ())
+    {
+      d->masterFd = -1;
+      return false;
+    }
+
+  return true;
+#endif
+}
+
+void
+KPty::closeSlave ()
+{
+  Q_D (KPty);
+
+  if (d->slaveFd < 0)
+    return;
+  ::close (d->slaveFd);
+  d->slaveFd = -1;
+}
+
+bool
+KPty::openSlave ()
+{
+  Q_D (KPty);
+
+  if (d->slaveFd >= 0)
+    return true;
+  if (d->masterFd < 0)
+    {
+      //kWarning(175) << "Attempting to open pty slave while master is closed";
+      return false;
+    }
+  d->slaveFd =::open (d->ttyName.data (), O_RDWR | O_NOCTTY);
+  if (d->slaveFd < 0)
+    {
+      //kWarning(175) << "Can't open slave pseudo teletype";
+      return false;
+    }
+  fcntl (d->slaveFd, F_SETFD, FD_CLOEXEC);
+  return true;
+}
+
+void
+KPty::close ()
+{
+  Q_D (KPty);
+
+  if (d->masterFd < 0)
+    return;
+  closeSlave ();
+  if (d->ownMaster)
+    {
+#ifndef HAVE_OPENPTY
+      // don't bother resetting unix98 pty, it will go away after closing master anyway.
+      if (memcmp (d->ttyName.data (), "/dev/pts/", 9))
+	{
+	  if (!geteuid ())
+	    {
+	      struct stat st;
+	      if (!stat (d->ttyName.data (), &st))
+		{
+		  chown (d->ttyName.data (), 0,
+			 st.st_gid == getgid ()? 0 : -1);
+		  chmod (d->ttyName.data (),
+			 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH |
+			 S_IWOTH);
+		}
+	    }
+	  else
+	    {
+	      fcntl (d->masterFd, F_SETFD, 0);
+	      d->chownpty (false);
+	    }
+	}
+#endif
+      ::close (d->masterFd);
+    }
+  d->masterFd = -1;
+}
+
+void
+KPty::setCTty ()
+{
+  Q_D (KPty);
+
+  // Setup job control //////////////////////////////////
+
+  // Become session leader, process group leader,
+  // and get rid of the old controlling terminal.
+  setsid ();
+
+  // make our slave pty the new controlling terminal.
+#ifdef TIOCSCTTY
+  ioctl (d->slaveFd, TIOCSCTTY, 0);
+#else
+  // __svr4__ hack: the first tty opened after setsid() becomes controlling tty
+  ::close (open (d->ttyName, O_WRONLY, 0));
+#endif
+
+  // make our new process group the foreground group on the pty
+  int pgrp = getpid ();
+#if defined(_POSIX_VERSION) || defined(__svr4__)
+  tcsetpgrp (d->slaveFd, pgrp);
+#elif defined(TIOCSPGRP)
+  ioctl (d->slaveFd, TIOCSPGRP, (char *) &pgrp);
+#endif
+}
+
+void
+KPty::login (const char *user, const char *remotehost)
+{
+#ifdef HAVE_UTEMPTER
+  Q_D (KPty);
+
+  addToUtmp (d->ttyName, remotehost, d->masterFd);
+  Q_UNUSED (user);
+#else
+#ifdef HAVE_UTMPX
+  struct utmpx l_struct;
+#else
+  struct utmp l_struct;
+#endif
+  memset (&l_struct, 0, sizeof (l_struct));
+  // note: strncpy without terminators _is_ correct here. man 4 utmp
+
+  if (user)
+    strncpy (l_struct.ut_name, user, sizeof (l_struct.ut_name));
+
+  if (remotehost)
+    {
+      strncpy (l_struct.ut_host, remotehost, sizeof (l_struct.ut_host));
+#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
+      l_struct.ut_syslen =
+	qMin (strlen (remotehost), sizeof (l_struct.ut_host));
+#endif
+    }
+
+#ifndef __GLIBC__
+  Q_D (KPty);
+  const char *str_ptr = d->ttyName.data ();
+  if (!memcmp (str_ptr, "/dev/", 5))
+    str_ptr += 5;
+  strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
+#ifdef HAVE_STRUCT_UTMP_UT_ID
+  strncpy (l_struct.ut_id,
+	   str_ptr + strlen (str_ptr) - sizeof (l_struct.ut_id),
+	   sizeof (l_struct.ut_id));
+#endif
+#endif
+
+#ifdef HAVE_UTMPX
+  //gettimeofday(&l_struct.ut_tv, 0);
+  gettimeofday ((struct timeval *) &l_struct.ut_tv, 0);
+#else
+  l_struct.ut_time = time (0);
+#endif
+
+#ifdef HAVE_LOGIN
+#ifdef HAVE_LOGINX
+  ::loginx (&l_struct);
+#else
+  ::login (&l_struct);
+#endif
+#else
+#ifdef HAVE_STRUCT_UTMP_UT_TYPE
+  l_struct.ut_type = USER_PROCESS;
+#endif
+#ifdef HAVE_STRUCT_UTMP_UT_PID
+  l_struct.ut_pid = getpid ();
+#ifdef HAVE_STRUCT_UTMP_UT_SESSION
+  l_struct.ut_session = getsid (0);
+#endif
+#endif
+#ifdef HAVE_UTMPX
+  utmpxname (_PATH_UTMPX);
+  setutxent ();
+  pututxline (&l_struct);
+  endutxent ();
+  //updwtmpx(_PATH_WTMPX, &l_struct);
+#else
+  utmpname (_PATH_UTMP);
+  setutent ();
+  pututline (&l_struct);
+  endutent ();
+  updwtmp (_PATH_WTMP, &l_struct);
+#endif
+#endif
+#endif
+}
+
+void
+KPty::logout ()
+{
+#ifdef HAVE_UTEMPTER
+  Q_D (KPty);
+
+  removeLineFromUtmp (d->ttyName, d->masterFd);
+#else
+  Q_D (KPty);
+
+  const char *str_ptr = d->ttyName.data ();
+  if (!memcmp (str_ptr, "/dev/", 5))
+    str_ptr += 5;
+#ifdef __GLIBC__
+  else
+    {
+      const char *sl_ptr = strrchr (str_ptr, '/');
+      if (sl_ptr)
+	str_ptr = sl_ptr + 1;
+    }
+#endif
+#ifdef HAVE_LOGIN
+#ifdef HAVE_LOGINX
+  ::logoutx (str_ptr, 0, DEAD_PROCESS);
+#else
+  ::logout (str_ptr);
+#endif
+#else
+#ifdef HAVE_UTMPX
+  struct utmpx l_struct, *ut;
+#else
+  struct utmp l_struct, *ut;
+#endif
+  memset (&l_struct, 0, sizeof (l_struct));
+
+  strncpy (l_struct.ut_line, str_ptr, sizeof (l_struct.ut_line));
+
+#ifdef HAVE_UTMPX
+  utmpxname (_PATH_UTMPX);
+  setutxent ();
+  if ((ut = getutxline (&l_struct)))
+    {
+#else
+  utmpname (_PATH_UTMP);
+  setutent ();
+  if ((ut = getutline (&l_struct)))
+    {
+#endif
+      memset (ut->ut_name, 0, sizeof (*ut->ut_name));
+      memset (ut->ut_host, 0, sizeof (*ut->ut_host));
+#ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
+      ut->ut_syslen = 0;
+#endif
+#ifdef HAVE_STRUCT_UTMP_UT_TYPE
+      ut->ut_type = DEAD_PROCESS;
+#endif
+#ifdef HAVE_UTMPX
+      //gettimeofday(&(ut->ut_tv), 0);
+      gettimeofday ((struct timeval *) &(ut->ut_tv), 0);
+      pututxline (ut);
+    }
+  endutxent ();
+#else
+      ut->ut_time = time (0);
+      pututline (ut);
+    }
+  endutent ();
+#endif
+#endif
+#endif
+}
+
+bool
+KPty::tcGetAttr (struct::termios * ttmode) const
+{
+  Q_D (const KPty);
+
+#ifdef Q_OS_SOLARIS
+  if (_tcgetattr (d->slaveFd, ttmode) == 0)
+    return true;
+#endif
+  return _tcgetattr (d->masterFd, ttmode) == 0;
+}
+
+bool
+KPty::tcSetAttr (struct::termios * ttmode)
+{
+  Q_D (KPty);
+
+#ifdef Q_OS_SOLARIS
+  if (_tcsetattr (d->slaveFd, ttmode) == 0)
+    return true;
+#endif
+  return _tcsetattr (d->masterFd, ttmode) == 0;
+}
+
+bool
+KPty::setWinSize (int lines, int columns)
+{
+  Q_D (KPty);
+
+  struct winsize winSize;
+  memset (&winSize, 0, sizeof (winSize));
+  winSize.ws_row = (unsigned short) lines;
+  winSize.ws_col = (unsigned short) columns;
+  return ioctl (d->masterFd, TIOCSWINSZ, (char *) &winSize) == 0;
+}
+
+bool
+KPty::setEcho (bool echo)
+{
+  struct::termios ttmode;
+  if (!tcGetAttr (&ttmode))
+    return false;
+  if (!echo)
+    ttmode.c_lflag &= ~ECHO;
+  else
+    ttmode.c_lflag |= ECHO;
+  return tcSetAttr (&ttmode);
+}
+
+const char *
+KPty::ttyName () const
+{
+  Q_D (const KPty);
+
+  return d->ttyName.data ();
+}
+
+int
+KPty::masterFd () const
+{
+  Q_D (const KPty);
+
+  return d->masterFd;
+}
+
+int
+KPty::slaveFd () const
+{
+  Q_D (const KPty);
+
+  return d->slaveFd;
+}
diff --git a/gui/src/terminal/kpty.h b/gui/src/terminal/kpty.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kpty.h
@@ -0,0 +1,202 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kpty_h
+#define kpty_h
+#include <QtCore/qglobal.h>
+
+struct KPtyPrivate;
+struct termios;
+
+/**
+ * Provides primitives for opening & closing a pseudo TTY pair, assigning the
+ * controlling TTY, utmp registration and setting various terminal attributes.
+ */
+class KPty
+{
+Q_DECLARE_PRIVATE (KPty) public:
+
+  /**
+   * Constructor
+   */
+  KPty ();
+
+  /**
+   * Destructor:
+   *
+   *  If the pty is still open, it will be closed. Note, however, that
+   *  an utmp registration is @em not undone.
+  */
+  ~KPty ();
+
+  /**
+   * Create a pty master/slave pair.
+   *
+   * @return true if a pty pair was successfully opened
+   */
+  bool open ();
+
+  /**
+   * Open using an existing pty master.
+   *
+   * @param fd an open pty master file descriptor.
+   *   The ownership of the fd remains with the caller;
+   *   it will not be automatically closed at any point.
+   * @return true if a pty pair was successfully opened
+   */
+  bool open (int fd);
+
+  /**
+   * Close the pty master/slave pair.
+   */
+  void close ();
+
+  /**
+   * Close the pty slave descriptor.
+   *
+   * When creating the pty, KPty also opens the slave and keeps it open.
+   * Consequently the master will never receive an EOF notification.
+   * Usually this is the desired behavior, as a closed pty slave can be
+   * reopened any time - unlike a pipe or socket. However, in some cases
+   * pipe-alike behavior might be desired.
+   *
+   * After this function was called, slaveFd() and setCTty() cannot be
+   * used.
+   */
+  void closeSlave ();
+
+  /**
+   * Open the pty slave descriptor.
+   *
+   * This undoes the effect of closeSlave().
+   *
+   * @return true if the pty slave was successfully opened
+   */
+  bool openSlave ();
+
+  /**
+   * Creates a new session and process group and makes this pty the
+   * controlling tty.
+   */
+  void setCTty ();
+
+  /**
+   * Creates an utmp entry for the tty.
+   * This function must be called after calling setCTty and
+   * making this pty the stdin.
+   * @param user the user to be logged on
+   * @param remotehost the host from which the login is coming. This is
+   *  @em not the local host. For remote logins it should be the hostname
+   *  of the client. For local logins from inside an X session it should
+   *  be the name of the X display. Otherwise it should be empty.
+   */
+  void login (const char *user = 0, const char *remotehost = 0);
+
+  /**
+   * Removes the utmp entry for this tty.
+   */
+  void logout ();
+
+  /**
+   * Wrapper around tcgetattr(3).
+   *
+   * This function can be used only while the PTY is open.
+   * You will need an #include &lt;termios.h&gt; to do anything useful
+   * with it.
+   *
+   * @param ttmode a pointer to a termios structure.
+   *  Note: when declaring ttmode, @c struct @c ::termios must be used -
+   *  without the '::' some version of HP-UX thinks, this declares
+   *  the struct in your class, in your method.
+   * @return @c true on success, false otherwise
+   */
+  bool tcGetAttr (struct::termios * ttmode) const;
+
+  /**
+   * Wrapper around tcsetattr(3) with mode TCSANOW.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param ttmode a pointer to a termios structure.
+   * @return @c true on success, false otherwise. Note that success means
+   *  that @em at @em least @em one attribute could be set.
+   */
+  bool tcSetAttr (struct::termios * ttmode);
+
+  /**
+   * Change the logical (screen) size of the pty.
+   * The default is 24 lines by 80 columns.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param lines the number of rows
+   * @param columns the number of columns
+   * @return @c true on success, false otherwise
+   */
+  bool setWinSize (int lines, int columns);
+
+  /**
+   * Set whether the pty should echo input.
+   *
+   * Echo is on by default.
+   * If the output of automatically fed (non-interactive) PTY clients
+   * needs to be parsed, disabling echo often makes it much simpler.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param echo true if input should be echoed.
+   * @return @c true on success, false otherwise
+   */
+  bool setEcho (bool echo);
+
+  /**
+   * @return the name of the slave pty device.
+   *
+   * This function should be called only while the pty is open.
+   */
+  const char *ttyName () const;
+
+  /**
+   * @return the file descriptor of the master pty
+   *
+   * This function should be called only while the pty is open.
+   */
+  int masterFd () const;
+
+  /**
+   * @return the file descriptor of the slave pty
+   *
+   * This function should be called only while the pty slave is open.
+   */
+  int slaveFd () const;
+
+protected:
+  /**
+   * @internal
+   */
+    KPty (KPtyPrivate * d);
+
+  /**
+   * @internal
+   */
+  KPtyPrivate *const d_ptr;
+};
+
+#endif
diff --git a/gui/src/terminal/kpty_export.h b/gui/src/terminal/kpty_export.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kpty_export.h
@@ -0,0 +1,46 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2007 David Faure <faure@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPTY_EXPORT_H
+#define KPTY_EXPORT_H
+
+/* needed for KDE_EXPORT and KDE_IMPORT macros */
+//#include <kdemacros.h>
+#include <QtCore/qglobal.h>
+#define KDE_EXPORT
+#define KDE_IMPORT
+
+#ifndef KPTY_EXPORT
+#if defined(KDELIBS_STATIC_LIBS)
+   /* No export/import for static libraries */
+#define KPTY_EXPORT
+#elif defined(MAKE_KDECORE_LIB)
+   /* We are building this library */
+#define KPTY_EXPORT KDE_EXPORT
+#else
+   /* We are using this library */
+#define KPTY_EXPORT KDE_IMPORT
+#endif
+#endif
+
+#ifndef KPTY_EXPORT_DEPRECATED
+#define KPTY_EXPORT_DEPRECATED KDE_DEPRECATED KPTY_EXPORT
+#endif
+
+#endif
diff --git a/gui/src/terminal/kpty_p.h b/gui/src/terminal/kpty_p.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kpty_p.h
@@ -0,0 +1,57 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kpty_p_h
+#define kpty_p_h
+
+#include "kpty.h"
+
+#if defined(Q_OS_MAC)
+#define HAVE_UTIL_H
+#define HAVE_UTMPX
+#define _UTMPX_COMPAT
+#define HAVE_PTSNAME
+#define HAVE_SYS_TIME_H
+#else
+#define HAVE_PTY_H
+#endif
+
+#define HAVE_OPENPTY
+
+#include <QtCore/QByteArray>
+
+struct KPtyPrivate
+{
+  Q_DECLARE_PUBLIC (KPty) KPtyPrivate (KPty * parent);
+  virtual ~ KPtyPrivate ();
+#ifndef HAVE_OPENPTY
+  bool chownpty (bool grant);
+#endif
+
+  int masterFd;
+  int slaveFd;
+  bool ownMaster:1;
+
+  QByteArray ttyName;
+
+  KPty *q_ptr;
+};
+
+#endif
diff --git a/gui/src/terminal/kptydevice.cpp b/gui/src/terminal/kptydevice.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kptydevice.cpp
@@ -0,0 +1,455 @@
+/*
+
+   This file is part of the KDE libraries
+   Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+   Copyright (C) 2010 KDE e.V. <kde-ev-board@kde.org>
+     Author Adriaan de Groot <groot@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kptydevice.h"
+#include "kpty_p.h"
+#define i18n
+
+#include <QtCore/QSocketNotifier>
+
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+#include <termios.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_FILIO_H
+#include <sys/filio.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#if defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+  // "the other end's output queue size" - kinda braindead, huh?
+#define PTY_BYTES_AVAILABLE TIOCOUTQ
+#elif defined(TIOCINQ)
+  // "our end's input queue size"
+#define PTY_BYTES_AVAILABLE TIOCINQ
+#else
+  // likewise. more generic ioctl (theoretically)
+#define PTY_BYTES_AVAILABLE FIONREAD
+#endif
+
+//////////////////
+// private data //
+//////////////////
+
+// Lifted from Qt. I don't think they would mind. ;)
+// Re-lift again from Qt whenever a proper replacement for pthread_once appears
+static void
+qt_ignore_sigpipe ()
+{
+  static QBasicAtomicInt atom = Q_BASIC_ATOMIC_INITIALIZER (0);
+  if (atom.testAndSetRelaxed (0, 1))
+    {
+      struct sigaction noaction;
+      memset (&noaction, 0, sizeof (noaction));
+      noaction.sa_handler = SIG_IGN;
+      sigaction (SIGPIPE, &noaction, 0);
+    }
+}
+
+#define NO_INTR(ret,func) do { ret = func; } while (ret < 0 && errno == EINTR)
+
+bool
+KPtyDevicePrivate::_k_canRead ()
+{
+  Q_Q (KPtyDevice);
+  qint64 readBytes = 0;
+
+#ifdef Q_OS_IRIX		// this should use a config define, but how to check it?
+  size_t available;
+#else
+  int available;
+#endif
+  if (!::ioctl (q->masterFd (), PTY_BYTES_AVAILABLE, (char *) &available))
+    {
+#ifdef Q_OS_SOLARIS
+      // A Pty is a STREAMS module, and those can be activated
+      // with 0 bytes available. This happens either when ^C is
+      // pressed, or when an application does an explicit write(a,b,0)
+      // which happens in experiments fairly often. When 0 bytes are
+      // available, you must read those 0 bytes to clear the STREAMS
+      // module, but we don't want to hit the !readBytes case further down.
+      if (!available)
+	{
+	  char c;
+	  // Read the 0-byte STREAMS message
+	  NO_INTR (readBytes, read (q->masterFd (), &c, 0));
+	  // Should return 0 bytes read; -1 is error
+	  if (readBytes < 0)
+	    {
+	      readNotifier->setEnabled (false);
+	      emit q->readEof ();
+	      return false;
+	    }
+	  return true;
+	}
+#endif
+
+      char *ptr = readBuffer.reserve (available);
+#ifdef Q_OS_SOLARIS
+      // Even if available > 0, it is possible for read()
+      // to return 0 on Solaris, due to 0-byte writes in the stream.
+      // Ignore them and keep reading until we hit *some* data.
+      // In Solaris it is possible to have 15 bytes available
+      // and to (say) get 0, 0, 6, 0 and 9 bytes in subsequent reads.
+      // Because the stream is set to O_NONBLOCK in finishOpen(),
+      // an EOF read will return -1.
+      readBytes = 0;
+      while (!readBytes)
+#endif
+	// Useless block braces except in Solaris
+	{
+	  NO_INTR (readBytes, read (q->masterFd (), ptr, available));
+	}
+      if (readBytes < 0)
+	{
+	  readBuffer.unreserve (available);
+	  q->setErrorString (i18n ("Error reading from PTY"));
+	  return false;
+	}
+      readBuffer.unreserve (available - readBytes);	// *should* be a no-op
+    }
+
+  if (!readBytes)
+    {
+      readNotifier->setEnabled (false);
+      emit q->readEof ();
+      return false;
+    }
+  else
+    {
+      if (!emittedReadyRead)
+	{
+	  emittedReadyRead = true;
+	  emit q->readyRead ();
+	  emittedReadyRead = false;
+	}
+      return true;
+    }
+}
+
+bool
+KPtyDevicePrivate::_k_canWrite ()
+{
+  Q_Q (KPtyDevice);
+
+  writeNotifier->setEnabled (false);
+  if (writeBuffer.isEmpty ())
+    return false;
+
+  qt_ignore_sigpipe ();
+  int wroteBytes;
+  NO_INTR (wroteBytes,
+	   write (q->masterFd (),
+		  writeBuffer.readPointer (), writeBuffer.readSize ()));
+  if (wroteBytes < 0)
+    {
+      q->setErrorString (i18n ("Error writing to PTY"));
+      return false;
+    }
+  writeBuffer.free (wroteBytes);
+
+  if (!emittedBytesWritten)
+    {
+      emittedBytesWritten = true;
+      emit q->bytesWritten (wroteBytes);
+      emittedBytesWritten = false;
+    }
+
+  if (!writeBuffer.isEmpty ())
+    writeNotifier->setEnabled (true);
+  return true;
+}
+
+#ifndef timeradd
+// Lifted from GLIBC
+#define timeradd(a, b, result) \
+    do { \
+        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; \
+        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; \
+        if ((result)->tv_usec >= 1000000) { \
+            ++(result)->tv_sec; \
+            (result)->tv_usec -= 1000000; \
+        } \
+    } while (0)
+#define timersub(a, b, result) \
+    do { \
+        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \
+        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
+        if ((result)->tv_usec < 0) { \
+            --(result)->tv_sec; \
+            (result)->tv_usec += 1000000; \
+        } \
+    } while (0)
+#endif
+
+bool
+KPtyDevicePrivate::doWait (int msecs, bool reading)
+{
+  Q_Q (KPtyDevice);
+#ifndef __linux__
+  struct timeval etv;
+#endif
+  struct timeval tv, *tvp;
+
+  if (msecs < 0)
+    tvp = 0;
+  else
+    {
+      tv.tv_sec = msecs / 1000;
+      tv.tv_usec = (msecs % 1000) * 1000;
+#ifndef __linux__
+      gettimeofday (&etv, 0);
+      timeradd (&tv, &etv, &etv);
+#endif
+      tvp = &tv;
+    }
+
+  while (reading ? readNotifier->isEnabled () : !writeBuffer.isEmpty ())
+    {
+      fd_set rfds;
+      fd_set wfds;
+
+      FD_ZERO (&rfds);
+      FD_ZERO (&wfds);
+
+      if (readNotifier->isEnabled ())
+	FD_SET (q->masterFd (), &rfds);
+      if (!writeBuffer.isEmpty ())
+	FD_SET (q->masterFd (), &wfds);
+
+#ifndef __linux__
+      if (tvp)
+	{
+	  gettimeofday (&tv, 0);
+	  timersub (&etv, &tv, &tv);
+	  if (tv.tv_sec < 0)
+	    tv.tv_sec = tv.tv_usec = 0;
+	}
+#endif
+
+      switch (select (q->masterFd () + 1, &rfds, &wfds, 0, tvp))
+	{
+	case -1:
+	  if (errno == EINTR)
+	    break;
+	  return false;
+	case 0:
+	  q->setErrorString (i18n ("PTY operation timed out"));
+	  return false;
+	default:
+	  if (FD_ISSET (q->masterFd (), &rfds))
+	    {
+	      bool canRead = _k_canRead ();
+	      if (reading && canRead)
+		return true;
+	    }
+	  if (FD_ISSET (q->masterFd (), &wfds))
+	    {
+	      bool canWrite = _k_canWrite ();
+	      if (!reading)
+		return canWrite;
+	    }
+	  break;
+	}
+    }
+  return false;
+}
+
+void
+KPtyDevicePrivate::finishOpen (QIODevice::OpenMode mode)
+{
+  Q_Q (KPtyDevice);
+
+  q->QIODevice::open (mode);
+  fcntl (q->masterFd (), F_SETFL, O_NONBLOCK);
+  readBuffer.clear ();
+  readNotifier =
+    new QSocketNotifier (q->masterFd (), QSocketNotifier::Read, q);
+  writeNotifier =
+    new QSocketNotifier (q->masterFd (), QSocketNotifier::Write, q);
+  QObject::connect (readNotifier, SIGNAL (activated (int)), q,
+		    SLOT (_k_canRead ()));
+  QObject::connect (writeNotifier, SIGNAL (activated (int)), q,
+		    SLOT (_k_canWrite ()));
+  readNotifier->setEnabled (true);
+}
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KPtyDevice::KPtyDevice (QObject * parent):
+QIODevice (parent), KPty (new KPtyDevicePrivate (this))
+{
+}
+
+KPtyDevice::~KPtyDevice ()
+{
+  close ();
+}
+
+bool
+KPtyDevice::open (OpenMode mode)
+{
+  Q_D (KPtyDevice);
+
+  if (masterFd () >= 0)
+    return true;
+
+  if (!KPty::open ())
+    {
+      setErrorString (i18n ("Error opening PTY"));
+      return false;
+    }
+
+  d->finishOpen (mode);
+
+  return true;
+}
+
+bool
+KPtyDevice::open (int fd, OpenMode mode)
+{
+  Q_D (KPtyDevice);
+
+  if (!KPty::open (fd))
+    {
+      setErrorString (i18n ("Error opening PTY"));
+      return false;
+    }
+
+  d->finishOpen (mode);
+
+  return true;
+}
+
+void
+KPtyDevice::close ()
+{
+  Q_D (KPtyDevice);
+
+  if (masterFd () < 0)
+    return;
+
+  delete d->readNotifier;
+  delete d->writeNotifier;
+
+  QIODevice::close ();
+
+  KPty::close ();
+}
+
+bool
+KPtyDevice::isSequential () const
+{
+  return true;
+}
+
+bool
+KPtyDevice::canReadLine () const
+{
+  Q_D (const KPtyDevice);
+  return QIODevice::canReadLine () || d->readBuffer.canReadLine ();
+}
+
+bool
+KPtyDevice::atEnd () const
+{
+  Q_D (const KPtyDevice);
+  return QIODevice::atEnd () && d->readBuffer.isEmpty ();
+}
+
+qint64
+KPtyDevice::bytesAvailable () const
+{
+  Q_D (const KPtyDevice);
+  return QIODevice::bytesAvailable () + d->readBuffer.size ();
+}
+
+qint64
+KPtyDevice::bytesToWrite () const
+{
+  Q_D (const KPtyDevice);
+  return d->writeBuffer.size ();
+}
+
+bool
+KPtyDevice::waitForReadyRead (int msecs)
+{
+  Q_D (KPtyDevice);
+  return d->doWait (msecs, true);
+}
+
+bool
+KPtyDevice::waitForBytesWritten (int msecs)
+{
+  Q_D (KPtyDevice);
+  return d->doWait (msecs, false);
+}
+
+void
+KPtyDevice::setSuspended (bool suspended)
+{
+  Q_D (KPtyDevice);
+  d->readNotifier->setEnabled (!suspended);
+}
+
+bool
+KPtyDevice::isSuspended () const
+{
+  Q_D (const KPtyDevice);
+  return !d->readNotifier->isEnabled ();
+}
+
+// protected
+qint64
+KPtyDevice::readData (char *data, qint64 maxlen)
+{
+  Q_D (KPtyDevice);
+  return d->readBuffer.read (data, (int) qMin < qint64 > (maxlen, KMAXINT));
+}
+
+// protected
+qint64
+KPtyDevice::readLineData (char *data, qint64 maxlen)
+{
+  Q_D (KPtyDevice);
+  return d->readBuffer.readLine (data,
+				 (int) qMin < qint64 > (maxlen, KMAXINT));
+}
+
+// protected
+qint64
+KPtyDevice::writeData (const char *data, qint64 len)
+{
+  Q_D (KPtyDevice);
+  Q_ASSERT (len <= KMAXINT);
+
+  d->writeBuffer.write (data, len);
+  d->writeNotifier->setEnabled (true);
+  return len;
+}
diff --git a/gui/src/terminal/kptydevice.h b/gui/src/terminal/kptydevice.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kptydevice.h
@@ -0,0 +1,357 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kptydev_h
+#define kptydev_h
+
+struct KPtyPrivate;
+struct KPtyDevicePrivate;
+
+#include "kpty.h"
+#include "kpty_p.h"
+#include <QtCore/QIODevice>
+#include <QSocketNotifier>
+
+#define Q_DECLARE_PRIVATE_MI(Class, SuperClass) \
+    inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(SuperClass::d_ptr); } \
+    inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(SuperClass::d_ptr); } \
+    friend class Class##Private;
+
+/**
+ * Encapsulates KPty into a QIODevice, so it can be used with Q*Stream, etc.
+ */
+class KPtyDevice:public QIODevice, public KPty
+{				//krazy:exclude=dpointer (via macro)
+Q_OBJECT Q_DECLARE_PRIVATE_MI (KPtyDevice, KPty) public:
+
+    /**
+     * Constructor
+     */
+  KPtyDevice (QObject * parent = 0);
+
+    /**
+     * Destructor:
+     *
+     *  If the pty is still open, it will be closed. Note, however, that
+     *  an utmp registration is @em not undone.
+     */
+  virtual ~ KPtyDevice ();
+
+    /**
+     * Create a pty master/slave pair.
+     *
+     * @return true if a pty pair was successfully opened
+     */
+  virtual bool open (OpenMode mode = ReadWrite | Unbuffered);
+
+    /**
+     * Open using an existing pty master. The ownership of the fd
+     * remains with the caller, i.e., close() will not close the fd.
+     *
+     * This is useful if you wish to attach a secondary "controller" to an
+     * existing pty device such as a terminal widget.
+     * Note that you will need to use setSuspended() on both devices to
+     * control which one gets the incoming data from the pty.
+     *
+     * @param fd an open pty master file descriptor.
+     * @param mode the device mode to open the pty with.
+     * @return true if a pty pair was successfully opened
+     */
+  bool open (int fd, OpenMode mode = ReadWrite | Unbuffered);
+
+    /**
+     * Close the pty master/slave pair.
+     */
+  virtual void close ();
+
+    /**
+     * Sets whether the KPtyDevice monitors the pty for incoming data.
+     *
+     * When the KPtyDevice is suspended, it will no longer attempt to buffer
+     * data that becomes available from the pty and it will not emit any
+     * signals.
+     *
+     * Do not use on closed ptys.
+     * After a call to open(), the pty is not suspended. If you need to
+     * ensure that no data is read, call this function before the main loop
+     * is entered again (i.e., immediately after opening the pty).
+     */
+  void setSuspended (bool suspended);
+
+    /**
+     * Returns true if the KPtyDevice is not monitoring the pty for incoming
+     * data.
+     *
+     * Do not use on closed ptys.
+     *
+     * See setSuspended()
+     */
+  bool isSuspended () const;
+
+    /**
+     * @return always true
+     */
+  virtual bool isSequential () const;
+
+    /**
+     * @reimp
+     */
+  bool canReadLine () const;
+
+    /**
+     * @reimp
+     */
+  bool atEnd () const;
+
+    /**
+     * @reimp
+     */
+  qint64 bytesAvailable () const;
+
+    /**
+     * @reimp
+     */
+  qint64 bytesToWrite () const;
+
+  bool waitForBytesWritten (int msecs = -1);
+  bool waitForReadyRead (int msecs = -1);
+
+
+    Q_SIGNALS:
+    /**
+     * Emitted when EOF is read from the PTY.
+     *
+     * Data may still remain in the buffers.
+     */
+  void readEof ();
+
+protected:
+    virtual qint64 readData (char *data, qint64 maxSize);
+  virtual qint64 readLineData (char *data, qint64 maxSize);
+  virtual qint64 writeData (const char *data, qint64 maxSize);
+
+private:
+  Q_PRIVATE_SLOT (d_func (), bool _k_canRead ())
+    Q_PRIVATE_SLOT (d_func (), bool _k_canWrite ())};
+
+#define KMAXINT ((int)(~0U >> 1))
+
+/////////////////////////////////////////////////////
+// Helper. Remove when QRingBuffer becomes public. //
+/////////////////////////////////////////////////////
+
+#include <QtCore/qbytearray.h>
+#include <QtCore/qlinkedlist.h>
+
+#define CHUNKSIZE 4096
+
+class KRingBuffer
+{
+public:
+  KRingBuffer ()
+  {
+    clear ();
+  }
+
+  void clear ()
+  {
+    buffers.clear ();
+    QByteArray tmp;
+    tmp.resize (CHUNKSIZE);
+    buffers << tmp;
+    head = tail = 0;
+    totalSize = 0;
+  }
+
+  inline bool isEmpty () const
+  {
+    return buffers.count () == 1 && !tail;
+  }
+
+  inline int size () const
+  {
+    return totalSize;
+  }
+
+  inline int readSize () const
+  {
+    return (buffers.count () == 1 ? tail : buffers.first ().size ()) - head;
+  }
+
+  inline const char *readPointer () const
+  {
+    Q_ASSERT (totalSize > 0);
+    return buffers.first ().constData () + head;
+  }
+
+  void free (int bytes)
+  {
+    totalSize -= bytes;
+    Q_ASSERT (totalSize >= 0);
+
+    forever
+    {
+      int nbs = readSize ();
+
+      if (bytes < nbs)
+	{
+	  head += bytes;
+	  if (head == tail && buffers.count () == 1)
+	    {
+	      buffers.first ().resize (CHUNKSIZE);
+	      head = tail = 0;
+	    }
+	  break;
+	}
+
+      bytes -= nbs;
+      if (buffers.count () == 1)
+	{
+	  buffers.first ().resize (CHUNKSIZE);
+	  head = tail = 0;
+	  break;
+	}
+
+      buffers.removeFirst ();
+      head = 0;
+    }
+  }
+
+  char *reserve (int bytes)
+  {
+    totalSize += bytes;
+
+    char *ptr;
+    if (tail + bytes <= buffers.last ().size ())
+      {
+	ptr = buffers.last ().data () + tail;
+	tail += bytes;
+      }
+    else
+      {
+	buffers.last ().resize (tail);
+	QByteArray tmp;
+	tmp.resize (qMax (CHUNKSIZE, bytes));
+	ptr = tmp.data ();
+	buffers << tmp;
+	tail = bytes;
+      }
+    return ptr;
+  }
+
+  // release a trailing part of the last reservation
+  inline void unreserve (int bytes)
+  {
+    totalSize -= bytes;
+    tail -= bytes;
+  }
+
+  inline void write (const char *data, int len)
+  {
+    memcpy (reserve (len), data, len);
+  }
+
+  // Find the first occurrence of c and return the index after it.
+  // If c is not found until maxLength, maxLength is returned, provided
+  // it is smaller than the buffer size. Otherwise -1 is returned.
+  int indexAfter (char c, int maxLength = KMAXINT) const
+  {
+    int index = 0;
+    int start = head;
+      QLinkedList < QByteArray >::ConstIterator it = buffers.begin ();
+      forever
+    {
+      if (!maxLength)
+	return index;
+      if (index == size ())
+	return -1;
+      const QByteArray & buf = *it;
+      ++it;
+      int len = qMin ((it == buffers.end ()? tail : buf.size ()) - start,
+		      maxLength);
+      const char *ptr = buf.data () + start;
+      if (const char *rptr = (const char *)memchr (ptr, c, len))
+	return index + (rptr - ptr) + 1;
+        index += len;
+        maxLength -= len;
+        start = 0;
+    }
+  }
+
+  inline int lineSize (int maxLength = KMAXINT) const
+  {
+    return indexAfter ('\n', maxLength);
+  }
+
+  inline bool canReadLine () const
+  {
+    return lineSize () != -1;
+  }
+
+  int read (char *data, int maxLength)
+  {
+    int bytesToRead = qMin (size (), maxLength);
+    int readSoFar = 0;
+    while (readSoFar < bytesToRead)
+      {
+	const char *ptr = readPointer ();
+	int bs = qMin (bytesToRead - readSoFar, readSize ());
+	memcpy (data + readSoFar, ptr, bs);
+	readSoFar += bs;
+	free (bs);
+      }
+    return readSoFar;
+  }
+
+  int readLine (char *data, int maxLength)
+  {
+    return read (data, lineSize (qMin (maxLength, size ())));
+  }
+
+private:
+  QLinkedList < QByteArray > buffers;
+  int head, tail;
+  int totalSize;
+};
+
+struct KPtyDevicePrivate:public KPtyPrivate
+{
+  Q_DECLARE_PUBLIC (KPtyDevice)
+    KPtyDevicePrivate (KPty * parent):KPtyPrivate (parent),
+    emittedReadyRead (false), emittedBytesWritten (false),
+    readNotifier (0), writeNotifier (0)
+  {
+  }
+
+  bool _k_canRead ();
+  bool _k_canWrite ();
+
+  bool doWait (int msecs, bool reading);
+  void finishOpen (QIODevice::OpenMode mode);
+
+  bool emittedReadyRead;
+  bool emittedBytesWritten;
+  QSocketNotifier *readNotifier;
+  QSocketNotifier *writeNotifier;
+  KRingBuffer readBuffer;
+  KRingBuffer writeBuffer;
+};
+
+#endif
diff --git a/gui/src/terminal/kptyprocess.cpp b/gui/src/terminal/kptyprocess.cpp
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kptyprocess.cpp
@@ -0,0 +1,125 @@
+/*
+
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+#include "kptyprocess.h"
+#include "kprocess.h"
+
+#include "kptydevice.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+//////////////////
+// private data //
+//////////////////
+
+KPtyProcess::KPtyProcess (QObject * parent):
+KProcess (new KPtyProcessPrivate, parent)
+{
+  Q_D (KPtyProcess);
+
+  d->pty = new KPtyDevice (this);
+  d->pty->open ();
+  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
+	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
+}
+
+KPtyProcess::KPtyProcess (int ptyMasterFd, QObject * parent):
+KProcess (new KPtyProcessPrivate, parent)
+{
+  Q_D (KPtyProcess);
+
+  d->pty = new KPtyDevice (this);
+  d->pty->open (ptyMasterFd);
+  connect (this, SIGNAL (stateChanged (QProcess::ProcessState)),
+	   SLOT (_k_onStateChanged (QProcess::ProcessState)));
+}
+
+KPtyProcess::~KPtyProcess ()
+{
+  Q_D (KPtyProcess);
+
+  if (state () != QProcess::NotRunning && d->addUtmp)
+    {
+      d->pty->logout ();
+      disconnect (SIGNAL (stateChanged (QProcess::ProcessState)),
+		  this, SLOT (_k_onStateChanged (QProcess::ProcessState)));
+    }
+  delete d->pty;
+}
+
+void
+KPtyProcess::setPtyChannels (PtyChannels channels)
+{
+  Q_D (KPtyProcess);
+
+  d->ptyChannels = channels;
+}
+
+KPtyProcess::PtyChannels KPtyProcess::ptyChannels () const
+{
+  Q_D (const KPtyProcess);
+
+  return d->ptyChannels;
+}
+
+void
+KPtyProcess::setUseUtmp (bool value)
+{
+  Q_D (KPtyProcess);
+
+  d->addUtmp = value;
+}
+
+bool
+KPtyProcess::isUseUtmp () const
+{
+  Q_D (const KPtyProcess);
+
+  return d->addUtmp;
+}
+
+KPtyDevice *
+KPtyProcess::pty () const
+{
+  Q_D (const KPtyProcess);
+
+  return d->pty;
+}
+
+void
+KPtyProcess::setupChildProcess ()
+{
+  Q_D (KPtyProcess);
+
+  d->pty->setCTty ();
+  if (d->addUtmp)
+    d->pty->login (getenv ("USER"), getenv ("DISPLAY"));
+  //d->pty->login(KUser(KUser::UseRealUserID).loginName().toLocal8Bit().data(), qgetenv("DISPLAY"));
+  if (d->ptyChannels & StdinChannel)
+    dup2 (d->pty->slaveFd (), 0);
+  if (d->ptyChannels & StdoutChannel)
+    dup2 (d->pty->slaveFd (), 1);
+  if (d->ptyChannels & StderrChannel)
+    dup2 (d->pty->slaveFd (), 2);
+
+  KProcess::setupChildProcess ();
+}
diff --git a/gui/src/terminal/kptyprocess.h b/gui/src/terminal/kptyprocess.h
new file mode 100644
--- /dev/null
+++ b/gui/src/terminal/kptyprocess.h
@@ -0,0 +1,152 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPTYPROCESS_H
+#define KPTYPROCESS_H
+
+#include "kprocess.h"
+#include "kprocess_p.h"
+#include "kptydevice.h"
+
+class KPtyDevice;
+class KPtyProcess;
+struct KPtyProcessPrivate;
+
+/**
+ * This class extends KProcess by support for PTYs (pseudo TTYs).
+ *
+ * The PTY is opened as soon as the class is instantiated. Verify that
+ * it was opened successfully by checking that pty()->masterFd() is not -1.
+ *
+ * The PTY is always made the process' controlling TTY.
+ * Utmp registration and connecting the stdio handles to the PTY are optional.
+ *
+ * No attempt to integrate with QProcess' waitFor*() functions was made,
+ * for it is impossible. Note that execute() does not work with the PTY, too.
+ * Use the PTY device's waitFor*() functions or use it asynchronously.
+ *
+ * @author Oswald Buddenhagen <ossi@kde.org>
+ */
+class KPtyProcess:public KProcess
+{
+Q_OBJECT Q_DECLARE_PRIVATE (KPtyProcess) public:
+  enum PtyChannelFlag
+  {
+    NoChannels = 0,	/**< The PTY is not connected to any channel. */
+    StdinChannel = 1,	  /**< Connect PTY to stdin. */
+    StdoutChannel = 2,	   /**< Connect PTY to stdout. */
+    StderrChannel = 4,	   /**< Connect PTY to stderr. */
+    AllOutputChannels = 6,     /**< Connect PTY to all output channels. */
+    AllChannels = 7	/**< Connect PTY to all channels. */
+  };
+
+    Q_DECLARE_FLAGS (PtyChannels, PtyChannelFlag)
+    /**
+     * Constructor
+     */
+  explicit KPtyProcess (QObject * parent = 0);
+
+    /**
+     * Construct a process using an open pty master.
+     *
+     * @param ptyMasterFd an open pty master file descriptor.
+     *   The process does not take ownership of the descriptor;
+     *   it will not be automatically closed at any point.
+     */
+    KPtyProcess (int ptyMasterFd, QObject * parent = 0);
+
+    /**
+     * Destructor
+     */
+    virtual ~ KPtyProcess ();
+
+    /**
+     * Set to which channels the PTY should be assigned.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param channels the output channel handling mode
+     */
+  void setPtyChannels (PtyChannels channels);
+
+    /**
+     * Query to which channels the PTY is assigned.
+     *
+     * @return the output channel handling mode
+     */
+  PtyChannels ptyChannels () const;
+
+    /**
+     * Set whether to register the process as a TTY login in utmp.
+     *
+     * Utmp is disabled by default.
+     * It should enabled for interactively fed processes, like terminal
+     * emulations.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param value whether to register in utmp.
+     */
+  void setUseUtmp (bool value);
+
+    /**
+     * Get whether to register the process as a TTY login in utmp.
+     *
+     * @return whether to register in utmp
+     */
+  bool isUseUtmp () const;
+
+    /**
+     * Get the PTY device of this process.
+     *
+     * @return the PTY device
+     */
+  KPtyDevice *pty () const;
+
+protected:
+    /**
+     * @reimp
+     */
+    virtual void setupChildProcess ();
+
+private:
+  Q_PRIVATE_SLOT (d_func (),
+		    void _k_onStateChanged (QProcess::ProcessState))};
+
+struct KPtyProcessPrivate:KProcessPrivate
+{
+  KPtyProcessPrivate ():ptyChannels (KPtyProcess::NoChannels), addUtmp (false)
+  {
+  }
+
+  void _k_onStateChanged (QProcess::ProcessState newState)
+  {
+    if (newState == QProcess::NotRunning && addUtmp)
+      pty->logout ();
+  }
+
+  KPtyDevice *pty;
+  KPtyProcess::PtyChannels ptyChannels;
+  bool addUtmp:1;
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS (KPtyProcess::PtyChannels)
+#endif
diff --git a/gui/start.sh b/gui/start.sh
new file mode 100755
--- /dev/null
+++ b/gui/start.sh
@@ -0,0 +1,20 @@
+# Quint - A graphical user interface for Octave
+# Copyright (C) 2011 Jacob Dawid
+# jacob.dawid@googlemail.com
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+LANG=en_US.UTF-8
+cd bin
+./octave-gui
