# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1499467412 14400
#      Fri Jul 07 18:43:32 2017 -0400
# Node ID ea879bc55272d4cd3c2fdb1748016c7bc5ae8f6d
# Parent  6921d8458203ba5d6a2dc2addf9c5e7d9dea5b60
move comment_list and comment_elt classes to octave namespace

* comment-list.h, comment-list.cc (class comment_list, class
comment_elt): Move inside octave namespace and rename from
octave_coment_list and octave_comment_elt.  Change all uses.

diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -247,19 +247,19 @@ public:
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
   void stash_parent_fcn_scope (octave::symbol_table::scope *ps);
 
-  void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
+  void stash_leading_comment (octave::comment_list *lc) { lead_comm = lc; }
 
-  void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
+  void stash_trailing_comment (octave::comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
   {
     t_parsed = t;
     mark_fcn_file_up_to_date (t);
   }
@@ -375,19 +375,19 @@ public:
         const octave_value_list& args = octave_value_list ());
 
   octave::tree_parameter_list * parameter_list (void) { return param_list; }
 
   octave::tree_parameter_list * return_list (void) { return ret_list; }
 
   octave::tree_statement_list * body (void) { return cmd_list; }
 
-  octave_comment_list * leading_comment (void) { return lead_comm; }
+  octave::comment_list * leading_comment (void) { return lead_comm; }
 
-  octave_comment_list * trailing_comment (void) { return trail_comm; }
+  octave::comment_list * trailing_comment (void) { return trail_comm; }
 
   // If is_special_expr is true, retrieve the sigular expression that forms the
   // body.  May be null (even if is_special_expr is true).
   octave::tree_expression * special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
   void accept (octave::tree_walker& tw);
@@ -420,20 +420,20 @@ private:
   // List of parameters we return.  These are also local variables in
   // this function.
   octave::tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
   octave::tree_statement_list *cmd_list;
 
   // The comments preceding the FUNCTION token.
-  octave_comment_list *lead_comm;
+  octave::comment_list *lead_comm;
 
   // The comments preceding the ENDFUNCTION token.
-  octave_comment_list *trail_comm;
+  octave::comment_list *trail_comm;
 
   // The name of the file we parsed.
   std::string file_name;
 
   // Location where this function was defined.
   int location_line;
   int location_column;
   int end_location_line;
diff --git a/libinterp/parse-tree/comment-list.cc b/libinterp/parse-tree/comment-list.cc
--- a/libinterp/parse-tree/comment-list.cc
+++ b/libinterp/parse-tree/comment-list.cc
@@ -24,18 +24,21 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "lo-utils.h"
 
 #include "comment-list.h"
 #include "error.h"
 
-octave_comment_list *
-octave_comment_list::dup (void) const
+namespace octave
 {
-  octave_comment_list *new_cl = new octave_comment_list ();
+  comment_list *
+  comment_list::dup (void) const
+  {
+    comment_list *new_cl = new comment_list ();
 
-  for (const auto& elt : *this)
-    new_cl->append (elt);
+    for (const auto& elt : *this)
+      new_cl->append (elt);
 
-  return new_cl;
+    return new_cl;
+  }
 }
diff --git a/libinterp/parse-tree/comment-list.h b/libinterp/parse-tree/comment-list.h
--- a/libinterp/parse-tree/comment-list.h
+++ b/libinterp/parse-tree/comment-list.h
@@ -24,80 +24,93 @@ along with Octave; see the file COPYING.
 #define octave_comment_list_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "base-list.h"
 
-extern std::string get_comment_text (void);
-
-extern char * get_comment_text_c_str (void);
-
-extern void save_comment_text (const std::string& text);
-
-class
-octave_comment_elt
+namespace octave
 {
-public:
+  extern std::string get_comment_text (void);
+
+  extern char * get_comment_text_c_str (void);
 
-  enum comment_type
+  extern void save_comment_text (const std::string& text);
+
+  class
+  comment_elt
   {
-    unknown,
-    block,
-    full_line,
-    end_of_line,
-    doc_string,
-    copyright
+  public:
+
+    enum comment_type
+      {
+        unknown,
+        block,
+        full_line,
+        end_of_line,
+        doc_string,
+        copyright
+      };
+
+    comment_elt (const std::string& s = "",
+                        comment_type t = unknown)
+      : txt (s), typ (t) { }
+
+    comment_elt (const comment_elt& oc)
+      : txt (oc.txt), typ (oc.typ) { }
+
+    comment_elt& operator = (const comment_elt& oc)
+    {
+      if (this != &oc)
+        {
+          txt = oc.txt;
+          typ = oc.typ;
+        }
+
+      return *this;
+    }
+
+    std::string text (void) const { return txt; }
+
+    comment_type type (void) const { return typ; }
+
+    ~comment_elt (void) = default;
+
+  private:
+
+    // The text of the comment.
+    std::string txt;
+
+    // The type of comment.
+    comment_type typ;
   };
 
-  octave_comment_elt (const std::string& s = "",
-                      comment_type t = unknown)
-    : txt (s), typ (t) { }
-
-  octave_comment_elt (const octave_comment_elt& oc)
-    : txt (oc.txt), typ (oc.typ) { }
-
-  octave_comment_elt& operator = (const octave_comment_elt& oc)
+  class
+  comment_list : public octave::base_list<comment_elt>
   {
-    if (this != &oc)
-      {
-        txt = oc.txt;
-        typ = oc.typ;
-      }
+  public:
 
-    return *this;
-  }
+    comment_list (void) { }
 
-  std::string text (void) const { return txt; }
-
-  comment_type type (void) const { return typ; }
-
-  ~octave_comment_elt (void) = default;
+    void append (const comment_elt& elt)
+    { octave::base_list<comment_elt>::append (elt); }
 
-private:
+    void append (const std::string& s,
+                 comment_elt::comment_type t = comment_elt::unknown)
+    { append (comment_elt (s, t)); }
 
-  // The text of the comment.
-  std::string txt;
-
-  // The type of comment.
-  comment_type typ;
-};
+    comment_list * dup (void) const;
+  };
+}
 
-class
-octave_comment_list : public octave::base_list<octave_comment_elt>
-{
-public:
-
-  octave_comment_list (void) { }
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  void append (const octave_comment_elt& elt)
-  { octave::base_list<octave_comment_elt>::append (elt); }
+OCTAVE_DEPRECATED (4.4, "use 'octave::comment_list' instead")
+typedef octave::comment_list octave_comment_list;
 
-  void append (const std::string& s,
-               octave_comment_elt::comment_type t = octave_comment_elt::unknown)
-  { append (octave_comment_elt (s, t)); }
-
-  octave_comment_list * dup (void) const;
-};
+OCTAVE_DEPRECATED (4.4, "use 'octave::comment_elt' instead")
+typedef octave::comment_elt octave_comment_elt;
 
 #endif
+
+#endif
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -515,49 +515,49 @@ namespace octave
 
     // Collect comment text.
 
     class
     comment_buffer
     {
     public:
 
-      comment_buffer (void) : comment_list (0) { }
+      comment_buffer (void) : m_comment_list (0) { }
 
-      ~comment_buffer (void) { delete comment_list; }
+      ~comment_buffer (void) { delete m_comment_list; }
 
-      void append (const std::string& s, octave_comment_elt::comment_type t)
+      void append (const std::string& s, comment_elt::comment_type t)
       {
-        if (! comment_list)
-          comment_list = new octave_comment_list ();
+        if (! m_comment_list)
+          m_comment_list = new comment_list ();
 
-        comment_list->append (s, t);
+        m_comment_list->append (s, t);
       }
 
       // Caller is expected to delete the returned value.
 
-      octave_comment_list * get_comment (void)
+      comment_list * get_comment (void)
       {
-        octave_comment_list *retval = comment_list;
+        comment_list *retval = m_comment_list;
 
-        comment_list = 0;
+        m_comment_list = 0;
 
         return retval;
       }
 
       void reset (void)
       {
-        delete comment_list;
+        delete m_comment_list;
 
-        comment_list = 0;
+        m_comment_list = 0;
       }
 
     private:
 
-      octave_comment_list *comment_list;
+      comment_list *m_comment_list;
     };
 
     base_lexer (interpreter *interp = nullptr)
       : lexical_feedback (), scanner (0), input_buf (), comment_buf (),
         m_interpreter (interp)
     {
       init ();
     }
@@ -609,19 +609,19 @@ namespace octave
     bool fq_identifier_contains_keyword (const std::string& s);
 
     bool whitespace_is_significant (void);
 
     void handle_number (void);
 
     void handle_continuation (void);
 
-    void finish_comment (octave_comment_elt::comment_type typ);
+    void finish_comment (comment_elt::comment_type typ);
 
-    octave_comment_list * get_comment (void) { return comment_buf.get_comment (); }
+    comment_list * get_comment (void) { return comment_buf.get_comment (); }
 
     int handle_close_bracket (int bracket_type);
 
     bool looks_like_command_arg (void);
 
     int handle_superclass_identifier (void);
 
     int handle_meta_identifier (void);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -96,17 +96,16 @@ object) relevant global values before an
 
 // These would be alphabetical, but oct-parse.h must be included before
 // oct-gperf.h and oct-parse.h must be included after token.h and the tree
 // class declarations.  We can't include oct-parse.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
 #include "Cell.h"
-#include "comment-list.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "octave.h"
@@ -653,17 +652,17 @@ ANY_INCLUDING_NL (.|{NL})
 ^{S}*{CCHAR}\{{S}*{NL} {
     curr_lexer->lexer_debug ("^{S}*{CCHAR}\\{{S}*{NL}");
 
     yyless (0);
 
     if (curr_lexer->start_state () == LINE_COMMENT_START)
       {
         if (! curr_lexer->comment_text.empty ())
-          curr_lexer->finish_comment (octave_comment_elt::full_line);
+          curr_lexer->finish_comment (octave::comment_elt::full_line);
 
         curr_lexer->pop_start_state ();
       }
 
     curr_lexer->decrement_promptflag ();
 
     curr_lexer->push_start_state (BLOCK_COMMENT_START);
 
@@ -691,17 +690,17 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\\}{S}*{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     if (curr_lexer->block_comment_nesting_level > 1)
       curr_lexer->comment_text = "\n";
     else
-      curr_lexer->finish_comment (octave_comment_elt::block);
+      curr_lexer->finish_comment (octave::comment_elt::block);
 
     curr_lexer->block_comment_nesting_level--;
 
     if (curr_lexer->block_comment_nesting_level == 0)
       {
         curr_lexer->increment_promptflag ();
 
         curr_lexer->pop_start_state ();
@@ -784,28 +783,28 @@ ANY_INCLUDING_NL (.|{NL})
                     break;
                   }
               }
 
             if (looks_like_block_comment)
               {
                 yyless (0);
 
-                curr_lexer->finish_comment (octave_comment_elt::full_line);
+                curr_lexer->finish_comment (octave::comment_elt::full_line);
 
                 curr_lexer->pop_start_state ();
               }
           }
       }
     else
       {
         if (have_space)
           curr_lexer->mark_previous_token_trailing_space ();
 
-        curr_lexer->finish_comment (octave_comment_elt::end_of_line);
+        curr_lexer->finish_comment (octave::comment_elt::end_of_line);
 
         curr_lexer->pop_start_state ();
 
         curr_lexer->xunput ('\n');
         curr_lexer->input_line_number--;
       }
   }
 
@@ -813,29 +812,29 @@ ANY_INCLUDING_NL (.|{NL})
 // End of a block of full-line comments.
 %}
 
 <LINE_COMMENT_START>{ANY_INCLUDING_NL} {
     curr_lexer->lexer_debug ("<LINE_COMMENT_START>{ANY_INCLUDING_NL}");
 
     curr_lexer->xunput (yytext[0]);
 
-    curr_lexer->finish_comment (octave_comment_elt::full_line);
+    curr_lexer->finish_comment (octave::comment_elt::full_line);
 
     curr_lexer->pop_start_state ();
   }
 
 %{
 // End of a block of full-line comments.
 %}
 
 <LINE_COMMENT_START><<EOF>> {
     curr_lexer->lexer_debug ("<LINE_COMMENT_START><<EOF>>");
 
-    curr_lexer->finish_comment (octave_comment_elt::full_line);
+    curr_lexer->finish_comment (octave::comment_elt::full_line);
 
     curr_lexer->pop_start_state ();
   }
 
 %{
 // Double-quoted character strings.
 %}
 
@@ -2940,37 +2939,37 @@ namespace octave
         comment_text = &yytxt[offset];
 
         // finish_comment sets at_beginning_of_statement to true but
         // that's not be correct if we are handling a continued
         // statement.  Preserve the current state.
 
         bool saved_bos = at_beginning_of_statement;
 
-        finish_comment (octave_comment_elt::end_of_line);
+        finish_comment (comment_elt::end_of_line);
 
         at_beginning_of_statement = saved_bos;
       }
 
     decrement_promptflag ();
     input_line_number++;
     current_input_column = 1;
   }
 
   void
-  base_lexer::finish_comment (octave_comment_elt::comment_type typ)
+  base_lexer::finish_comment (comment_elt::comment_type typ)
   {
     bool copyright = looks_like_copyright (comment_text);
 
     if (nesting_level.none () && help_text.empty () && ! comment_text.empty ()
         && ! copyright && ! looks_like_shebang (comment_text))
       help_text = comment_text;
 
     if (copyright)
-      typ = octave_comment_elt::copyright;
+      typ = comment_elt::copyright;
 
     comment_buf.append (comment_text, typ);
 
     comment_text = "";
 
     at_beginning_of_statement = true;
   }
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -50,17 +50,16 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
 #include "quit.h"
 
 #include "Cell.h"
 #include "builtin-defun-decls.h"
 #include "call-stack.h"
-#include "comment-list.h"
 #include "defaults.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
@@ -135,17 +134,17 @@ static void yyerror (octave::base_parser
 %union
 {
   int dummy_type;
 
   // The type of the basic tokens returned by the lexer.
   octave::token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
-  octave_comment_list *comment_type;
+  octave::comment_list *comment_type;
 
   // Types for the nonterminals we generate.
   char punct_type;
   octave::tree *tree_type;
   octave::tree_matrix *tree_matrix_type;
   octave::tree_cell *tree_cell_type;
   octave::tree_expression *tree_expression_type;
   octave::tree_constant *tree_constant_type;
@@ -2696,24 +2695,24 @@ namespace octave
 
   // Build an unwind-protect command.
 
   tree_command *
   base_parser::make_unwind_command (token *unwind_tok,
                                     tree_statement_list *body,
                                     tree_statement_list *cleanup_stmts,
                                     token *end_tok,
-                                    octave_comment_list *lc,
-                                    octave_comment_list *mc)
+                                    comment_list *lc,
+                                    comment_list *mc)
   {
     tree_command *retval = 0;
 
     if (end_token_ok (end_tok, token::unwind_protect_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = unwind_tok->line ();
         int c = unwind_tok->column ();
 
         retval = new tree_unwind_protect_command (body, cleanup_stmts,
                                                   lc, mc, tc, l, c);
       }
     else
@@ -2730,24 +2729,24 @@ namespace octave
   // Build a try-catch command.
 
   tree_command *
   base_parser::make_try_command (token *try_tok,
                                  tree_statement_list *body,
                                  char catch_sep,
                                  tree_statement_list *cleanup_stmts,
                                  token *end_tok,
-                                 octave_comment_list *lc,
-                                 octave_comment_list *mc)
+                                 comment_list *lc,
+                                 comment_list *mc)
   {
     tree_command *retval = 0;
 
     if (end_token_ok (end_tok, token::try_catch_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = try_tok->line ();
         int c = try_tok->column ();
 
         tree_identifier *id = 0;
 
         if (! catch_sep && cleanup_stmts && ! cleanup_stmts->empty ())
           {
@@ -2785,25 +2784,25 @@ namespace octave
 
   // Build a while command.
 
   tree_command *
   base_parser::make_while_command (token *while_tok,
                                    tree_expression *expr,
                                    tree_statement_list *body,
                                    token *end_tok,
-                                   octave_comment_list *lc)
+                                   comment_list *lc)
   {
     tree_command *retval = 0;
 
     maybe_warn_assign_as_truth_value (expr);
 
     if (end_token_ok (end_tok, token::while_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         m_lexer.looping--;
 
         int l = while_tok->line ();
         int c = while_tok->column ();
 
         retval = new tree_while_command (expr, body, lc, tc, l, c);
       }
@@ -2819,21 +2818,21 @@ namespace octave
   }
 
   // Build a do-until command.
 
   tree_command *
   base_parser::make_do_until_command (token *until_tok,
                                       tree_statement_list *body,
                                       tree_expression *expr,
-                                      octave_comment_list *lc)
+                                      comment_list *lc)
   {
     maybe_warn_assign_as_truth_value (expr);
 
-    octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+    comment_list *tc = m_lexer.comment_buf.get_comment ();
 
     m_lexer.looping--;
 
     int l = until_tok->line ();
     int c = until_tok->column ();
 
     return new tree_do_until_command (expr, body, lc, tc, l, c);
   }
@@ -2842,27 +2841,27 @@ namespace octave
 
   tree_command *
   base_parser::make_for_command (int tok_id, token *for_tok,
                                  tree_argument_list *lhs,
                                  tree_expression *expr,
                                  tree_expression *maxproc,
                                  tree_statement_list *body,
                                  token *end_tok,
-                                 octave_comment_list *lc)
+                                 comment_list *lc)
   {
     tree_command *retval = 0;
 
     bool parfor = tok_id == PARFOR;
 
     if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
       {
         expr->mark_as_for_cmd_expr ();
 
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         m_lexer.looping--;
 
         int l = for_tok->line ();
         int c = for_tok->column ();
 
         if (lhs->length () == 1)
           {
@@ -2955,23 +2954,23 @@ namespace octave
   }
 
   // Finish an if command.
 
   tree_if_command *
   base_parser::finish_if_command (token *if_tok,
                                   tree_if_command_list *list,
                                   token *end_tok,
-                                  octave_comment_list *lc)
+                                  comment_list *lc)
   {
     tree_if_command *retval = 0;
 
     if (end_token_ok (end_tok, token::if_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = if_tok->line ();
         int c = if_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_if_clause *elt = list->front ();
 
@@ -2995,40 +2994,40 @@ namespace octave
   }
 
   // Build an elseif clause.
 
   tree_if_clause *
   base_parser::make_elseif_clause (token *elseif_tok,
                                    tree_expression *expr,
                                    tree_statement_list *list,
-                                   octave_comment_list *lc)
+                                   comment_list *lc)
   {
     maybe_warn_assign_as_truth_value (expr);
 
     int l = elseif_tok->line ();
     int c = elseif_tok->column ();
 
     return new tree_if_clause (expr, list, lc, l, c);
   }
 
   // Finish a switch command.
 
   tree_switch_command *
   base_parser::finish_switch_command (token *switch_tok,
                                       tree_expression *expr,
                                       tree_switch_case_list *list,
                                       token *end_tok,
-                                      octave_comment_list *lc)
+                                      comment_list *lc)
   {
     tree_switch_command *retval = 0;
 
     if (end_token_ok (end_tok, token::switch_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = switch_tok->line ();
         int c = switch_tok->column ();
 
         if (list && ! list->empty ())
           {
             tree_switch_case *elt = list->front ();
 
@@ -3053,17 +3052,17 @@ namespace octave
   }
 
   // Build a switch case.
 
   tree_switch_case *
   base_parser::make_switch_case (token *case_tok,
                                  tree_expression *expr,
                                  tree_statement_list *list,
-                                 octave_comment_list *lc)
+                                 comment_list *lc)
   {
     maybe_warn_variable_switch_label (expr);
 
     int l = case_tok->line ();
     int c = case_tok->column ();
 
     return new tree_switch_case (expr, list, lc, l, c);
   }
@@ -3230,17 +3229,17 @@ namespace octave
 
   tree_function_def *
   base_parser::make_function (token *fcn_tok,
                               tree_parameter_list *ret_list,
                               tree_identifier *id,
                               tree_parameter_list *param_list,
                               tree_statement_list *body,
                               tree_statement *end_fcn_stmt,
-                              octave_comment_list *lc)
+                              comment_list *lc)
   {
     tree_function_def *retval = 0;
 
     int l = fcn_tok->line ();
     int c = fcn_tok->column ();
 
     octave_user_function *tmp_fcn
       = start_function (id, param_list, body, end_fcn_stmt);
@@ -3280,17 +3279,17 @@ namespace octave
     body->append (end_fcn_stmt);
 
     octave_user_function *fcn
       = new octave_user_function (m_lexer.symtab_context.curr_scope (),
                                   param_list, 0, body);
 
     if (fcn)
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         fcn->stash_trailing_comment (tc);
         fcn->stash_fcn_end_location (end_fcn_stmt->line (),
                                      end_fcn_stmt->column ());
       }
 
     // If input is coming from a file, issue a warning if the name of
     // the file does not match the name of the function stated in the
@@ -3392,17 +3391,17 @@ namespace octave
   base_parser::make_end (const std::string& type, bool eof, int l, int c)
   {
     return make_statement (new tree_no_op_command (type, eof, l, c));
   }
 
   tree_function_def *
   base_parser::finish_function (tree_parameter_list *ret_list,
                                 octave_user_function *fcn,
-                                octave_comment_list *lc,
+                                comment_list *lc,
                                 int l, int c)
   {
     tree_function_def *retval = 0;
 
     if (ret_list)
       ret_list->mark_as_formal_parameters ();
 
     if (fcn)
@@ -3537,17 +3536,17 @@ namespace octave
   // a parse tree containing meta information about the class.
 
   tree_classdef *
   base_parser::make_classdef (token *tok_val,
                               tree_classdef_attribute_list *a,
                               tree_identifier *id,
                               tree_classdef_superclass_list *sc,
                               tree_classdef_body *body, token *end_tok,
-                              octave_comment_list *lc)
+                              comment_list *lc)
   {
     tree_classdef *retval = 0;
 
     m_lexer.symtab_context.pop ();
 
     std::string cls_name = id->name ();
 
     std::string nm = m_lexer.fcn_file_name;
@@ -3566,17 +3565,17 @@ namespace octave
 
         bison_error ("invalid classdef definition, the class name must match the filename");
 
       }
     else
       {
         if (end_token_ok (end_tok, token::classdef_end))
           {
-            octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+            comment_list *tc = m_lexer.comment_buf.get_comment ();
 
             int l = tok_val->line ();
             int c = tok_val->column ();
 
             if (! body)
               body = new tree_classdef_body ();
 
             retval = new tree_classdef (a, id, sc, body, lc, tc,
@@ -3596,23 +3595,23 @@ namespace octave
     return retval;
   }
 
   tree_classdef_properties_block *
   base_parser::make_classdef_properties_block (token *tok_val,
                                                tree_classdef_attribute_list *a,
                                                tree_classdef_property_list *plist,
                                                token *end_tok,
-                                               octave_comment_list *lc)
+                                               comment_list *lc)
   {
     tree_classdef_properties_block *retval = 0;
 
     if (end_token_ok (end_tok, token::properties_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! plist)
           plist = new tree_classdef_property_list ();
 
         retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
@@ -3628,23 +3627,23 @@ namespace octave
     return retval;
   }
 
   tree_classdef_methods_block *
   base_parser::make_classdef_methods_block (token *tok_val,
                                             tree_classdef_attribute_list *a,
                                             tree_classdef_methods_list *mlist,
                                             token *end_tok,
-                                            octave_comment_list *lc)
+                                            comment_list *lc)
   {
     tree_classdef_methods_block *retval = 0;
 
     if (end_token_ok (end_tok, token::methods_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! mlist)
           mlist = new tree_classdef_methods_list ();
 
         retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
@@ -3660,23 +3659,23 @@ namespace octave
     return retval;
   }
 
   tree_classdef_events_block *
   base_parser::make_classdef_events_block (token *tok_val,
                                            tree_classdef_attribute_list *a,
                                            tree_classdef_events_list *elist,
                                            token *end_tok,
-                                           octave_comment_list *lc)
+                                           comment_list *lc)
   {
     tree_classdef_events_block *retval = 0;
 
     if (end_token_ok (end_tok, token::events_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_events_list ();
 
         retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
@@ -3692,23 +3691,23 @@ namespace octave
     return retval;
   }
 
   tree_classdef_enum_block *
   base_parser::make_classdef_enum_block (token *tok_val,
                                          tree_classdef_attribute_list *a,
                                          tree_classdef_enum_list *elist,
                                          token *end_tok,
-                                         octave_comment_list *lc)
+                                         comment_list *lc)
   {
     tree_classdef_enum_block *retval = 0;
 
     if (end_token_ok (end_tok, token::enumeration_end))
       {
-        octave_comment_list *tc = m_lexer.comment_buf.get_comment ();
+        comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
         if (! elist)
           elist = new tree_classdef_enum_list ();
 
         retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
@@ -3771,17 +3770,17 @@ namespace octave
       delete id;
 
     return retval;
   }
 
   tree_function_def *
   base_parser::finish_classdef_external_method (octave_user_function *fcn,
                                                 tree_parameter_list *ret_list,
-                                                octave_comment_list *cl)
+                                                comment_list *cl)
   {
     if (ret_list)
       fcn->define_ret_list (ret_list);
 
     if (cl)
       fcn->stash_leading_comment (cl);
 
     int l = fcn->beginning_line ();
@@ -4200,17 +4199,17 @@ namespace octave
     return list;
   }
 
   // Finish building a statement.
   template <typename T>
   tree_statement *
   base_parser::make_statement (T *arg)
   {
-    octave_comment_list *comment = m_lexer.get_comment ();
+    comment_list *comment = m_lexer.get_comment ();
 
     return new tree_statement (arg, comment);
   }
 
   tree_statement_list *
   base_parser::make_statement_list (tree_statement *stmt)
   {
     return new tree_statement_list (stmt);
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -33,22 +33,22 @@ along with Octave; see the file COPYING.
 #include <map>
 #include <set>
 
 #include "lex.h"
 #include "symtab.h"
 #include "pt-misc.h"
 #include "token.h"
 
-class octave_comment_list;
 class octave_function;
 class octave_user_function;
 
 namespace octave
 {
+  class comment_list;
   class tree;
   class tree_anon_fcn_handle;
   class tree_argument_list;
   class tree_array_list;
   class tree_cell;
   class tree_classdef;
   class tree_classdef_attribute_list;
   class tree_classdef_body;
@@ -201,42 +201,42 @@ namespace octave
     // Build a postfix expression.
     tree_expression *
     make_postfix_op (int op, tree_expression *op1, token *tok_val);
 
     // Build an unwind-protect command.
     tree_command *
     make_unwind_command (token *unwind_tok, tree_statement_list *body,
                          tree_statement_list *cleanup, token *end_tok,
-                         octave_comment_list *lc, octave_comment_list *mc);
+                         comment_list *lc, comment_list *mc);
 
     // Build a try-catch command.
     tree_command *
     make_try_command (token *try_tok, tree_statement_list *body,
                       char catch_sep, tree_statement_list *cleanup,
-                      token *end_tok, octave_comment_list *lc,
-                      octave_comment_list *mc);
+                      token *end_tok, comment_list *lc,
+                      comment_list *mc);
 
     // Build a while command.
     tree_command *
     make_while_command (token *while_tok, tree_expression *expr,
                         tree_statement_list *body, token *end_tok,
-                        octave_comment_list *lc);
+                        comment_list *lc);
 
     // Build a do-until command.
     tree_command *
     make_do_until_command (token *until_tok, tree_statement_list *body,
-                           tree_expression *expr, octave_comment_list *lc);
+                           tree_expression *expr, comment_list *lc);
 
     // Build a for command.
     tree_command *
     make_for_command (int tok_id, token *for_tok, tree_argument_list *lhs,
                       tree_expression *expr, tree_expression *maxproc,
                       tree_statement_list *body, token *end_tok,
-                      octave_comment_list *lc);
+                      comment_list *lc);
 
     // Build a break command.
     tree_command * make_break_command (token *break_tok);
 
     // Build a continue command.
     tree_command * make_continue_command (token *continue_tok);
 
     // Build a return command.
@@ -244,65 +244,65 @@ namespace octave
 
     // Start an if command.
     tree_if_command_list *
     start_if_command (tree_expression *expr, tree_statement_list *list);
 
     // Finish an if command.
     tree_if_command *
     finish_if_command (token *if_tok, tree_if_command_list *list,
-                       token *end_tok, octave_comment_list *lc);
+                       token *end_tok, comment_list *lc);
 
     // Build an elseif clause.
     tree_if_clause *
     make_elseif_clause (token *elseif_tok, tree_expression *expr,
-                        tree_statement_list *list, octave_comment_list *lc);
+                        tree_statement_list *list, comment_list *lc);
 
     // Finish a switch command.
     tree_switch_command *
     finish_switch_command (token *switch_tok, tree_expression *expr,
                            tree_switch_case_list *list, token *end_tok,
-                           octave_comment_list *lc);
+                           comment_list *lc);
 
     // Build a switch case.
     tree_switch_case *
     make_switch_case (token *case_tok, tree_expression *expr,
-                      tree_statement_list *list, octave_comment_list *lc);
+                      tree_statement_list *list, comment_list *lc);
 
     // Build an assignment to a variable.
     tree_expression *
     make_assign_op (int op, tree_argument_list *lhs, token *eq_tok,
                     tree_expression *rhs);
 
     // Define a script.
     void make_script (tree_statement_list *cmds, tree_statement *end_script);
 
     // Define a function.
     tree_function_def *
     make_function (token *fcn_tok, tree_parameter_list *ret_list,
                    tree_identifier *id, tree_parameter_list *param_list,
                    tree_statement_list *body, tree_statement *end_fcn_stmt,
-                   octave_comment_list *lc);
+                   comment_list *lc);
 
     // Begin defining a function.
     octave_user_function *
     start_function (tree_identifier *id, tree_parameter_list *param_list,
                     tree_statement_list *body, tree_statement *end_function);
 
     // Create a no-op statement for end_function.
     tree_statement * make_end (const std::string& type, bool eof, int l, int c);
 
     // Do most of the work for defining a function.
     octave_user_function *
     frob_function (tree_identifier *id, octave_user_function *fcn);
 
     // Finish defining a function.
     tree_function_def *
     finish_function (tree_parameter_list *ret_list,
-                     octave_user_function *fcn, octave_comment_list *lc,
+                     octave_user_function *fcn, comment_list *lc,
                      int l, int c);
 
     // Reset state after parsing function.
     void
     recover_from_parsing_function (void);
 
     tree_funcall *
     make_superclass_ref (const std::string& method_nm,
@@ -310,50 +310,50 @@ namespace octave
 
     tree_funcall *
     make_meta_class_query (const std::string& class_nm);
 
     tree_classdef *
     make_classdef (token *tok_val, tree_classdef_attribute_list *a,
                    tree_identifier *id, tree_classdef_superclass_list *sc,
                    tree_classdef_body *body, token *end_tok,
-                   octave_comment_list *lc);
+                   comment_list *lc);
 
     tree_classdef_properties_block *
     make_classdef_properties_block (token *tok_val,
                                     tree_classdef_attribute_list *a,
                                     tree_classdef_property_list *plist,
-                                    token *end_tok, octave_comment_list *lc);
+                                    token *end_tok, comment_list *lc);
 
     tree_classdef_methods_block *
     make_classdef_methods_block (token *tok_val,
                                  tree_classdef_attribute_list *a,
                                  tree_classdef_methods_list *mlist,
-                                 token *end_tok, octave_comment_list *lc);
+                                 token *end_tok, comment_list *lc);
 
     tree_classdef_events_block *
     make_classdef_events_block (token *tok_val,
                                 tree_classdef_attribute_list *a,
                                 tree_classdef_events_list *elist,
-                                token *end_tok, octave_comment_list *lc);
+                                token *end_tok, comment_list *lc);
 
     tree_classdef_enum_block *
     make_classdef_enum_block (token *tok_val,
                               tree_classdef_attribute_list *a,
                               tree_classdef_enum_list *elist,
-                              token *end_tok, octave_comment_list *lc);
+                              token *end_tok, comment_list *lc);
 
     octave_user_function *
     start_classdef_external_method (tree_identifier *id,
                                     tree_parameter_list *pl);
 
     tree_function_def *
     finish_classdef_external_method (octave_user_function *fcn,
                                      tree_parameter_list *ret_list,
-                                     octave_comment_list *cl);
+                                     comment_list *cl);
 
     // Make an index expression.
     tree_index_expression *
     make_index_expression (tree_expression *expr,
                            tree_argument_list *args, char type);
 
     // Make an indirect reference expression.
     tree_index_expression *
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_tree_classdef_h)
 #define octave_tree_classdef_h 1
 
 #include "octave-config.h"
 
 class octave_value;
 
+#include "comment-list.h"
 #include "pt-cmd.h"
 #include "pt-exp.h"
 #include "pt-walk.h"
 #include "pt-id.h"
 
 #include "base-list.h"
 
 #include <list>
@@ -163,17 +164,17 @@ namespace octave
 
   template <typename T>
   class tree_classdef_element : public tree
   {
   public:
 
     tree_classdef_element (tree_classdef_attribute_list *a,
                            base_list<T> *elist,
-                           octave_comment_list *lc, octave_comment_list *tc,
+                           comment_list *lc, comment_list *tc,
                            int l = -1, int c = -1)
       : tree (l, c), attr_list (a), elt_list (elist),
         lead_comm (lc), trail_comm (tc)
     { }
 
     // No copying!
 
     tree_classdef_element (const tree_classdef_element&) = delete;
@@ -187,35 +188,35 @@ namespace octave
       delete lead_comm;
       delete trail_comm;
     }
 
     tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
 
     base_list<T> * element_list (void) { return elt_list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker&) { }
 
   private:
 
     // List of attributes that apply to this class.
     tree_classdef_attribute_list *attr_list;
 
     // The list of objects contained in this block.
     base_list<T> *elt_list;
 
     // Comment preceding the token marking the beginning of the block.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding END token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 
   class tree_classdef_property
   {
   public:
 
     tree_classdef_property (tree_identifier *i = nullptr, tree_expression *e = nullptr)
       : id (i), expr (e) { }
@@ -275,18 +276,18 @@ namespace octave
 
   class tree_classdef_properties_block
     : public tree_classdef_element<tree_classdef_property *>
   {
   public:
 
     tree_classdef_properties_block (tree_classdef_attribute_list *a,
                                     tree_classdef_property_list *plist,
-                                    octave_comment_list *lc,
-                                    octave_comment_list *tc,
+                                    comment_list *lc,
+                                    comment_list *tc,
                                     int l = -1, int c = -1)
       : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
 
     // No copying!
 
     tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
 
     tree_classdef_properties_block&
@@ -327,18 +328,18 @@ namespace octave
   };
 
   class tree_classdef_methods_block : public tree_classdef_element<octave_value>
   {
   public:
 
     tree_classdef_methods_block (tree_classdef_attribute_list *a,
                                  tree_classdef_methods_list *mlist,
-                                 octave_comment_list *lc,
-                                 octave_comment_list *tc, int l = -1, int c = -1)
+                                 comment_list *lc,
+                                 comment_list *tc, int l = -1, int c = -1)
       : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
 
     // No copying!
 
     tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
 
     tree_classdef_methods_block&
     operator = (const tree_classdef_methods_block&) = delete;
@@ -408,18 +409,18 @@ namespace octave
 
   class tree_classdef_events_block
     : public tree_classdef_element<tree_classdef_event *>
   {
   public:
 
     tree_classdef_events_block (tree_classdef_attribute_list *a,
                                 tree_classdef_events_list *elist,
-                                octave_comment_list *lc,
-                                octave_comment_list *tc, int l = -1, int c = -1)
+                                comment_list *lc,
+                                comment_list *tc, int l = -1, int c = -1)
       : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
 
     // No copying!
 
     tree_classdef_events_block (const tree_classdef_events_block&) = delete;
 
     tree_classdef_events_block&
     operator = (const tree_classdef_events_block&) = delete;
@@ -495,18 +496,18 @@ namespace octave
 
   class tree_classdef_enum_block
     : public tree_classdef_element<tree_classdef_enum *>
   {
   public:
 
     tree_classdef_enum_block (tree_classdef_attribute_list *a,
                               tree_classdef_enum_list *elist,
-                              octave_comment_list *lc,
-                              octave_comment_list *tc, int l = -1, int c = -1)
+                              comment_list *lc,
+                              comment_list *tc, int l = -1, int c = -1)
       : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
 
     // No copying!
 
     tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
 
     tree_classdef_enum_block&
     operator = (const tree_classdef_enum_block&) = delete;
@@ -629,18 +630,18 @@ namespace octave
   // Classdef definition.
 
   class tree_classdef : public tree_command
   {
   public:
 
     tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
                    tree_classdef_superclass_list *sc,
-                   tree_classdef_body *b, octave_comment_list *lc,
-                   octave_comment_list *tc,
+                   tree_classdef_body *b, comment_list *lc,
+                   comment_list *tc,
                    const std::string& pn = "", int l = -1,
                    int c = -1)
       : tree_command (l, c), attr_list (a), id (i),
         supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
         pack_name (pn) { }
 
     // No copying!
 
@@ -661,18 +662,18 @@ namespace octave
     tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
 
     tree_identifier * ident (void) { return id; }
 
     tree_classdef_superclass_list * superclass_list (void) { return supclass_list; }
 
     tree_classdef_body * body (void) { return element_list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     const std::string& package_name (void) const { return pack_name; }
 
     octave_function * make_meta_class (interpreter& interp,
                                        bool is_at_folder = false);
 
     void accept (tree_walker& tw)
     {
@@ -684,18 +685,18 @@ namespace octave
     tree_classdef_attribute_list *attr_list;
 
     tree_identifier *id;
 
     tree_classdef_superclass_list *supclass_list;
 
     tree_classdef_body *element_list;
 
-    octave_comment_list *lead_comm;
-    octave_comment_list *trail_comm;
+    comment_list *lead_comm;
+    comment_list *trail_comm;
 
     std::string pack_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 // Hmm, a lot of these are templates, so not sure how to typedef them.
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <list>
 #include <set>
 #include <stack>
 #include <string>
 
 #include "call-stack.h"
-#include "comment-list.h"
 #include "ovl.h"
 #include "pt-exp.h"
 #include "pt-walk.h"
 
 namespace octave
 {
   class tree_decl_elt;
   class tree_expression;
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -20,41 +20,41 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_pt_except_h)
 #define octave_pt_except_h 1
 
 #include "octave-config.h"
 
-#include "comment-list.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class comment_list;
   class tree_statement_list;
 
   // Simple exception handling.
 
   class tree_try_catch_command : public tree_command
   {
   public:
 
     tree_try_catch_command (int l = -1, int c = -1)
       : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
         lead_comm (0), mid_comm (0), trail_comm (0) { }
 
     tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
                             tree_identifier *id,
-                            octave_comment_list *cl = nullptr,
-                            octave_comment_list *cm = nullptr,
-                            octave_comment_list *ct = nullptr,
+                            comment_list *cl = nullptr,
+                            comment_list *cm = nullptr,
+                            comment_list *ct = nullptr,
                             int l = -1, int c = -1)
       : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
         lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
     // No copying!
 
     tree_try_catch_command (const tree_try_catch_command&) = delete;
 
@@ -63,21 +63,21 @@ namespace octave
     ~tree_try_catch_command (void);
 
     tree_identifier * identifier (void) { return expr_id; }
 
     tree_statement_list * body (void) { return try_code; }
 
     tree_statement_list * cleanup (void) { return catch_code; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * middle_comment (void) { return mid_comm; }
+    comment_list * middle_comment (void) { return mid_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_try_catch_command (*this);
     }
 
   private:
 
@@ -86,40 +86,40 @@ namespace octave
 
     // The code to execute if an error occurs in the first block.
     tree_statement_list *catch_code;
 
     // Identifier to modify.
     tree_identifier *expr_id;
 
     // Comment preceding TRY token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding CATCH token.
-    octave_comment_list *mid_comm;
+    comment_list *mid_comm;
 
     // Comment preceding END_TRY_CATCH token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 
   // Simple exception handling.
 
   class tree_unwind_protect_command : public tree_command
   {
   public:
 
     tree_unwind_protect_command (int l = -1, int c = -1)
       : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
         lead_comm (0), mid_comm (0), trail_comm (0) { }
 
     tree_unwind_protect_command (tree_statement_list *tc,
                                  tree_statement_list *cc,
-                                 octave_comment_list *cl = nullptr,
-                                 octave_comment_list *cm = nullptr,
-                                 octave_comment_list *ct = nullptr,
+                                 comment_list *cl = nullptr,
+                                 comment_list *cm = nullptr,
+                                 comment_list *ct = nullptr,
                                  int l = -1, int c = -1)
       : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
         lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
     // No copying!
 
     tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
 
@@ -127,44 +127,44 @@ namespace octave
     operator = (const tree_unwind_protect_command&) = delete;
 
     ~tree_unwind_protect_command (void);
 
     tree_statement_list * body (void) { return unwind_protect_code; }
 
     tree_statement_list * cleanup (void) { return cleanup_code; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * middle_comment (void) { return mid_comm; }
+    comment_list * middle_comment (void) { return mid_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_unwind_protect_command (*this);
     }
 
   private:
 
     // The first body of code to attempt to execute.
     tree_statement_list *unwind_protect_code;
 
     // The body of code to execute no matter what happens in the first
     // body of code.
     tree_statement_list *cleanup_code;
 
     // Comment preceding UNWIND_PROTECT token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding UNWIND_PROTECT_CLEANUP token.
-    octave_comment_list *mid_comm;
+    comment_list *mid_comm;
 
     // Comment preceding END_UNWIND_PROTECT token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_try_catch_command' instead")
 typedef octave::tree_try_catch_command tree_try_catch_command;
 
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -22,17 +22,16 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_pt_loop_h)
 #define octave_pt_loop_h 1
 
 #include "octave-config.h"
 
 class octave_value;
 
-#include "comment-list.h"
 #include "pt-cmd.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 class jit_info;
 
 namespace octave
 {
@@ -50,29 +49,29 @@ namespace octave
       : tree_command (l, c), expr (0), list (0), lead_comm (0),
         trail_comm (0)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
     tree_while_command (tree_expression *e,
-                        octave_comment_list *lc = nullptr,
-                        octave_comment_list *tc = nullptr,
+                        comment_list *lc = nullptr,
+                        comment_list *tc = nullptr,
                         int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (0), lead_comm (lc),
         trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
     tree_while_command (tree_expression *e, tree_statement_list *lst,
-                        octave_comment_list *lc = nullptr,
-                        octave_comment_list *tc = nullptr,
+                        comment_list *lc = nullptr,
+                        comment_list *tc = nullptr,
                         int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
         trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
@@ -83,19 +82,19 @@ namespace octave
     tree_while_command& operator = (const tree_while_command&) = delete;
 
     ~tree_while_command (void);
 
     tree_expression * condition (void) { return expr; }
 
     tree_statement_list * body (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_while_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
@@ -114,20 +113,20 @@ namespace octave
 
     // Expression to test.
     tree_expression *expr;
 
     // List of commands to execute.
     tree_statement_list *list;
 
     // Comment preceding WHILE token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding ENDWHILE token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
 
   private:
 
 #if defined (HAVE_LLVM)
     // compiled version of the loop
     jit_info *compiled;
 #endif
   };
@@ -137,24 +136,24 @@ namespace octave
   class tree_do_until_command : public tree_while_command
   {
   public:
 
     tree_do_until_command (int l = -1, int c = -1)
       : tree_while_command (l, c) { }
 
     tree_do_until_command (tree_expression *e,
-                           octave_comment_list *lc = nullptr,
-                           octave_comment_list *tc = nullptr,
+                           comment_list *lc = nullptr,
+                           comment_list *tc = nullptr,
                            int l = -1, int c = -1)
       : tree_while_command (e, lc, tc, l, c) { }
 
     tree_do_until_command (tree_expression *e, tree_statement_list *lst,
-                           octave_comment_list *lc = nullptr,
-                           octave_comment_list *tc = nullptr,
+                           comment_list *lc = nullptr,
+                           comment_list *tc = nullptr,
                            int l = -1, int c = -1)
       : tree_while_command (e, lst, lc, tc, l, c) { }
 
     // No copying!
 
     tree_do_until_command (const tree_do_until_command&) = delete;
 
     tree_do_until_command& operator = (const tree_do_until_command&) = delete;
@@ -180,18 +179,18 @@ namespace octave
       , compiled (0)
 #endif
     { }
 
     tree_simple_for_command (bool parallel_arg, tree_expression *le,
                              tree_expression *re,
                              tree_expression *maxproc_arg,
                              tree_statement_list *lst,
-                             octave_comment_list *lc = nullptr,
-                             octave_comment_list *tc = nullptr,
+                             comment_list *lc = nullptr,
+                             comment_list *tc = nullptr,
                              int l = -1, int c = -1)
       : tree_command (l, c), parallel (parallel_arg), lhs (le),
         expr (re), maxproc (maxproc_arg), list (lst),
         lead_comm (lc), trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
@@ -209,19 +208,19 @@ namespace octave
     tree_expression * left_hand_side (void) { return lhs; }
 
     tree_expression * control_expr (void) { return expr; }
 
     tree_expression * maxproc_expr (void) { return maxproc; }
 
     tree_statement_list * body (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_for_command (*this);
     }
 
 #if defined (HAVE_LLVM)
     // some functions use by tree_jit
@@ -250,20 +249,20 @@ namespace octave
     // Expression to tell how many processors should be used (only valid
     // if parallel is TRUE).
     tree_expression *maxproc;
 
     // List of commands to execute.
     tree_statement_list *list;
 
     // Comment preceding FOR token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding ENDFOR token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
 
 #if defined (HAVE_LLVM)
     // compiled version of the loop
     jit_info *compiled;
 #endif
   };
 
   class tree_complex_for_command : public tree_command
@@ -271,18 +270,18 @@ namespace octave
   public:
 
     tree_complex_for_command (int l = -1, int c = -1)
       : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
         trail_comm (0) { }
 
     tree_complex_for_command (tree_argument_list *le, tree_expression *re,
                               tree_statement_list *lst,
-                              octave_comment_list *lc = nullptr,
-                              octave_comment_list *tc = nullptr,
+                              comment_list *lc = nullptr,
+                              comment_list *tc = nullptr,
                               int l = -1, int c = -1)
       : tree_command (l, c), lhs (le), expr (re), list (lst),
         lead_comm (lc), trail_comm (tc) { }
 
     // No copying!
 
     tree_complex_for_command (const tree_complex_for_command&) = delete;
 
@@ -291,19 +290,19 @@ namespace octave
     ~tree_complex_for_command (void);
 
     tree_argument_list * left_hand_side (void) { return lhs; }
 
     tree_expression * control_expr (void) { return expr; }
 
     tree_statement_list * body (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_complex_for_command (*this);
     }
 
   private:
 
@@ -312,20 +311,20 @@ namespace octave
 
     // Expression to evaluate.
     tree_expression *expr;
 
     // List of commands to execute.
     tree_statement_list *list;
 
     // Comment preceding FOR token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding ENDFOR token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_while_command' instead")
 typedef octave::tree_while_command tree_while_command;
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -323,17 +323,17 @@ namespace octave
       }
 
     visit_octave_user_function_trailer (fcn);
   }
 
   void
   tree_print_code::visit_octave_user_function_header (octave_user_function& fcn)
   {
-    octave_comment_list *leading_comment = fcn.leading_comment ();
+    comment_list *leading_comment = fcn.leading_comment ();
 
     if (leading_comment)
       {
         print_comment_list (leading_comment);
         newline ();
       }
 
     indent ();
@@ -1213,17 +1213,17 @@ namespace octave
   {
     int n = expr.paren_count ();
 
     for (int i = 0; i < n; i++)
       os << txt;
   }
 
   void
-  tree_print_code::print_comment_elt (const octave_comment_elt& elt)
+  tree_print_code::print_comment_elt (const comment_elt& elt)
   {
     bool printed_something = false;
 
     bool prev_char_was_newline = false;
 
     std::string comment = elt.text ();
 
     size_t len = comment.length ();
@@ -1273,36 +1273,36 @@ namespace octave
           }
       }
 
     if (printed_something && ! beginning_of_line)
       newline ();
   }
 
   void
-  tree_print_code::print_comment_list (octave_comment_list *comment_list)
+  tree_print_code::print_comment_list (comment_list *comment_list)
   {
     if (comment_list)
       {
-        octave_comment_list::iterator p = comment_list->begin ();
+        comment_list::iterator p = comment_list->begin ();
 
         while (p != comment_list->end ())
           {
-            octave_comment_elt elt = *p++;
+            comment_elt elt = *p++;
 
             print_comment_elt (elt);
 
             if (p != comment_list->end ())
               newline ();
           }
       }
   }
 
   void
-  tree_print_code::print_indented_comment (octave_comment_list *comment_list)
+  tree_print_code::print_indented_comment (comment_list *comment_list)
   {
     increment_indent_level ();
 
     print_comment_list (comment_list);
 
     decrement_indent_level ();
   }
 }
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -23,21 +23,22 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_pt_pr_code_h)
 #define octave_pt_pr_code_h 1
 
 #include "octave-config.h"
 
 #include <stack>
 #include <string>
 
-#include "comment-list.h"
 #include "pt-walk.h"
 
 namespace octave
 {
+  class comment_elt;
+  class comment_list;
   class tree_decl_command;
   class tree_expression;
 
   // How to print the code that the parse trees represent.
 
   class tree_print_code : public tree_walker
   {
   public:
@@ -178,21 +179,21 @@ namespace octave
     void newline (const char *alt_txt = ", ");
 
     void indent (void);
 
     void reset (void);
 
     void print_parens (const tree_expression& expr, const char *txt);
 
-    void print_comment_list (octave_comment_list *comment_list);
+    void print_comment_list (comment_list *comment_list);
 
-    void print_comment_elt (const octave_comment_elt& comment_elt);
+    void print_comment_elt (const comment_elt& comment_elt);
 
-    void print_indented_comment (octave_comment_list *comment_list);
+    void print_indented_comment (comment_list *comment_list);
 
     // Must create with an output stream!
 
     tree_print_code (void);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -40,22 +40,22 @@ namespace octave
 
   class tree_if_clause : public tree
   {
   public:
 
     tree_if_clause (int l = -1, int c = -1)
       : tree (l, c), expr (0), list (0), lead_comm (0) { }
 
-    tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = nullptr,
+    tree_if_clause (tree_statement_list *sl, comment_list *lc = nullptr,
                     int l = -1, int c = -1)
       : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
 
     tree_if_clause (tree_expression *e, tree_statement_list *sl,
-                    octave_comment_list *lc = nullptr,
+                    comment_list *lc = nullptr,
                     int l = -1, int c = -1)
       : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
     tree_if_clause (const tree_if_clause&) = delete;
 
     tree_if_clause& operator = (const tree_if_clause&) = delete;
@@ -63,33 +63,33 @@ namespace octave
     ~tree_if_clause (void);
 
     bool is_else_clause (void) { return ! expr; }
 
     tree_expression * condition (void) { return expr; }
 
     tree_statement_list * commands (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_clause (*this);
     }
 
   private:
 
     // The condition to test.
     tree_expression *expr;
 
     // The list of statements to evaluate if expr is true.
     tree_statement_list *list;
 
     // Comment preceding ELSE or ELSEIF token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
   };
 
   class tree_if_command_list : public base_list<tree_if_clause *>
   {
   public:
 
     tree_if_command_list (void) { }
 
@@ -119,66 +119,66 @@ namespace octave
 
   class tree_if_command : public tree_command
   {
   public:
 
     tree_if_command (int l = -1, int c = -1)
       : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
 
-    tree_if_command (tree_if_command_list *lst, octave_comment_list *lc,
-                     octave_comment_list *tc, int l = -1, int c = -1)
+    tree_if_command (tree_if_command_list *lst, comment_list *lc,
+                     comment_list *tc, int l = -1, int c = -1)
       : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
 
     // No copying!
 
     tree_if_command (const tree_if_command&) = delete;
 
     tree_if_command& operator = (const tree_if_command&) = delete;
 
     ~tree_if_command (void);
 
     tree_if_command_list * cmd_list (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_if_command (*this);
     }
 
   private:
 
     // List of if commands (if, elseif, elseif, ... else, endif)
     tree_if_command_list *list;
 
     // Comment preceding IF token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding ENDIF token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 
   // Switch.
 
   class tree_switch_case : public tree
   {
   public:
 
     tree_switch_case (int l = -1, int c = -1)
       : tree (l, c), label (0), list (0), lead_comm (0) { }
 
-    tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = nullptr,
+    tree_switch_case (tree_statement_list *sl, comment_list *lc = nullptr,
                       int l = -1, int c = -1)
       : tree (l, c), label (0), list (sl), lead_comm (lc) { }
 
     tree_switch_case (tree_expression *e, tree_statement_list *sl,
-                      octave_comment_list *lc = nullptr,
+                      comment_list *lc = nullptr,
                       int l = -1, int c = -1)
       : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
     tree_switch_case (const tree_switch_case&) = delete;
 
     tree_switch_case& operator = (const tree_switch_case&) = delete;
@@ -186,33 +186,33 @@ namespace octave
     ~tree_switch_case (void);
 
     bool is_default_case (void) { return ! label; }
 
     tree_expression * case_label (void) { return label; }
 
     tree_statement_list * commands (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_case (*this);
     }
 
   private:
 
     // The case label.
     tree_expression *label;
 
     // The list of statements to evaluate if the label matches.
     tree_statement_list *list;
 
     // Comment preceding CASE or OTHERWISE token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
   };
 
   class tree_switch_case_list : public base_list<tree_switch_case *>
   {
   public:
 
     tree_switch_case_list (void) { }
 
@@ -244,55 +244,55 @@ namespace octave
   {
   public:
 
     tree_switch_command (int l = -1, int c = -1)
       : tree_command (l, c), expr (0), list (0), lead_comm (0),
         trail_comm (0) { }
 
     tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
-                         octave_comment_list *lc, octave_comment_list *tc,
+                         comment_list *lc, comment_list *tc,
                          int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
         trail_comm (tc) { }
 
     // No copying!
 
     tree_switch_command (const tree_switch_command&) = delete;
 
     tree_switch_command& operator = (const tree_switch_command&) = delete;
 
     ~tree_switch_command (void);
 
     tree_expression * switch_value (void) { return expr; }
 
     tree_switch_case_list * case_list (void) { return list; }
 
-    octave_comment_list * leading_comment (void) { return lead_comm; }
+    comment_list * leading_comment (void) { return lead_comm; }
 
-    octave_comment_list * trailing_comment (void) { return trail_comm; }
+    comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_switch_command (*this);
     }
 
   private:
 
     // Value on which to switch.
     tree_expression *expr;
 
     // List of cases (case 1, case 2, ..., default)
     tree_switch_case_list *list;
 
     // Comment preceding SWITCH token.
-    octave_comment_list *lead_comm;
+    comment_list *lead_comm;
 
     // Comment preceding ENDSWITCH token.
-    octave_comment_list *trail_comm;
+    comment_list *trail_comm;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_if_clause' instead")
 typedef octave::tree_if_clause tree_if_clause;
 
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <typeinfo>
 
 #include "quit.h"
 
 #include "bp-table.h"
+#include "comment-list.h"
 #include "input.h"
 #include "oct-lvalue.h"
 #include "octave-link.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -26,40 +26,40 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 class octave_value_list;
 
 #include <deque>
 
 #include "base-list.h"
 #include "bp-table.h"
-#include "comment-list.h"
 #include "pt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class comment_list;
   class tree_command;
   class tree_expression;
 
   // A statement is either a command to execute or an expression to
   // evaluate.
 
   class tree_statement : public tree
   {
   public:
 
     tree_statement (void)
       : cmd (0), expr (0), comm (0) { }
 
-    tree_statement (tree_command *c, octave_comment_list *cl)
+    tree_statement (tree_command *c, comment_list *cl)
       : cmd (c), expr (0), comm (cl) { }
 
-    tree_statement (tree_expression *e, octave_comment_list *cl)
+    tree_statement (tree_expression *e, comment_list *cl)
       : cmd (0), expr (e), comm (cl) { }
 
     // No copying!
 
     tree_statement (const tree_statement&) = delete;
 
     tree_statement& operator = (const tree_statement&) = delete;
 
@@ -86,17 +86,17 @@ namespace octave
     void set_location (int l, int c);
 
     void echo_code (const std::string& prefix);
 
     tree_command * command (void) { return cmd; }
 
     tree_expression * expression (void) { return expr; }
 
-    octave_comment_list * comment_text (void) { return comm; }
+    comment_list * comment_text (void) { return comm; }
 
     bool is_null_statement (void) const { return ! (cmd || expr || comm); }
 
     bool is_end_of_fcn_or_script (void) const;
 
     bool is_end_of_file (void) const;
 
     // Allow modification of this statement.  Note that there is no
@@ -118,17 +118,17 @@ namespace octave
 
     // Command to execute.
     tree_command *cmd;
 
     // Expression to evaluate.
     tree_expression *expr;
 
     // Comment associated with this statement.
-    octave_comment_list *comm;
+    comment_list *comm;
   };
 
   // A list of statements to evaluate.
 
   class tree_statement_list : public base_list<tree_statement *>
   {
   public:
 
