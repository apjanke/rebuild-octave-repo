# HG changeset patch
# User jwe
# Date 1069574873 0
#      Sun Nov 23 08:07:53 2003 +0000
# Node ID bd2067547b40cd8f89c0b91806819593845ad82f
# Parent  3b74f1a867504a36ca822c40615aa685c484e1a1
[project @ 2003-11-23 08:07:52 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2003-11-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Also maybe add -W to WARN_CFLAGS and WARN_CXXFLAGS.
+
 2003-11-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in (SHLLIB_VER): Fix typo.
 
 	* Makeconf.in (WARN_CFLAGS, WARN_CXXFLAGS): Substitute them.
 	(ALL_CFLAGS, BUG_CFLAGS): Add $(WARN_CFLAGS).
 	(ALL_CXXFLAGS, BUG_CXXFLAGS): Add $(WARN_CXXFLAGS).
 	(UGLY_ALL_CXXFLAGS): Delete.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.440 $)
+AC_REVISION($Revision: 1.441 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1277,32 +1277,38 @@ case "$canonical_host_type" in
   ;;
   *)
     UGLY_DEFS=`echo $DEFS | sed 's,\\",\\\\\\\\\\\\\\\\\\",g'`
   ;;
 esac
 AC_MSG_RESULT([defining UGLY_DEFS to be $UGLY_DEFS])
 AC_SUBST(UGLY_DEFS)
 
-### Maybe add -Wall and -Wshadow to compiler flags now that we're
+### Maybe add -Wall, -W, and -Wshadow to compiler flags now that we're
 ### done feature testing. 
 
 if test -z "$EXTERN_CFLAGS"; then
   OCTAVE_CC_FLAG(-Wall, [
 	WARN_CFLAGS="$WARN_CFLAGS -Wall";
 	AC_MSG_RESULT([adding -Wall to WARN_CFLAGS])])
+  OCTAVE_CC_FLAG(-W, [
+	WARN_CFLAGS="$WARN_CFLAGS -W";
+	AC_MSG_RESULT([adding -W to WARN_CFLAGS])])
   OCTAVE_CC_FLAG(-Wshadow, [
 	WARN_CFLAGS="$WARN_CFLAGS -Wshadow";
 	AC_MSG_RESULT([adding -Wshadow to WARN_CFLAGS])])
 fi
 
 if test -z "$EXTERN_CXXFLAGS"; then
   OCTAVE_CXX_FLAG(-Wall, [
     WARN_CXXFLAGS="$WARN_CXXFLAGS -Wall";
     AC_MSG_RESULT([adding -Wall to WARN_CXXFLAGS])])
+  OCTAVE_CXX_FLAG(-W, [
+    WARN_CXXFLAGS="$WARN_CXXFLAGS -W";
+    AC_MSG_RESULT([adding -W to WARN_CXXFLAGS])])
   OCTAVE_CXX_FLAG(-Wshadow, [
     WARN_CXXFLAGS="$WARN_CXXFLAGS -Wshadow";
     AC_MSG_RESULT([adding -Wshadow to WARN_CXXFLAGS])])
 fi
 
 ### Someday, maybe include -ansi and even -pedantic in this list...
 
 GCC_PICKY_FLAGS="-Wcast-align -Wcast-qual -Wid-clash-31 \
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -64,28 +64,25 @@ public:
   Array2 (const Array<T>& a, int r, int c)
     : Array<T> (a, dim_vector (r, c)) { }
 
   ~Array2 (void) { }
 
   Array2<T>& operator = (const Array2<T>& a)
     {
       if (this != &a)
-	{
-	  Array<T>::operator = (a);
-
-	  dimensions = a.dimensions;
-	}
+	Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (int r, int c) { resize_no_fill (r, c); }
+  void resize (int r, int c) { this->resize_no_fill (r, c); }
 
-  void resize (int r, int c, const T& val) { resize_and_fill (r, c, val); }
+  void resize (int r, int c, const T& val)
+    { this->resize_and_fill (r, c, val); }
 
   Array2<T>& insert (const Array2<T>& a, int r, int c)
     {
       Array<T>::insert (a, r, c);
       return *this;
     }
 
   Array2<T> transpose (void) const
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -64,29 +64,25 @@ public:
   Array3 (const Array<T>& a, int r, int c, int p)
     : Array<T> (a, dim_vector (r, c, p)) { }
 
   ~Array3 (void) { }
 
   Array3<T>& operator = (const Array3<T>& a)
     {
       if (this != &a)
-	{
-	  Array<T>::operator = (a);
-
-	  dimensions = a.dimensions;
-	}
+	Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (int r, int c, int p) { resize_no_fill (r, c, p); }
+  void resize (int r, int c, int p) { this->resize_no_fill (r, c, p); }
 
   void resize (int r, int c, int p, const T& val)
-    { resize_and_fill (r, c, p, val); }
+    { this->resize_and_fill (r, c, p, val); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -78,17 +78,17 @@ public:
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
   void resize (const dim_vector& dv)
-    { Array<T>::resize_no_fill (dv); }
+    { this->resize_no_fill (dv); }
 
   void resize (const dim_vector& dv, const T& val)
     { Array<T>::resize (dv, val); }
 
   ArrayN<T> squeeze (void) const { return Array<T>::squeeze (); }
 
   ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dv)
     {
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,24 @@
+2003-11-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* MArrayN.cc (operator -=, operator +=): Check dimensions, not
+	just length.
+
+	* Array2.h, Array3.h, DiagArray2.h, DiagArray2.cc, MDiagArray2.h,
+	ArrayN.h:  Add this-> or Base:: qualifiers for references to
+	non-dependent member functions and data as needed.
+
+	* DiagArray2.h, DiagArray2.cc: Delete unused code.
+
+	* Array2.h (Array2<T>::operator =): Don't copy dimensions here.
+	* Array3.h (Array3<T>::operator =): Likewise.
+	* DiagArray2.h (DiagArray2<T>::operator =): Likewise.
+	Include Array.h, not Array2.h.
+
 2003-11-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* str-vec.cc (list_in_columns): Fix previous change.
 
 	* dim-vector.h (dim_vector::num_ones): New function.
 	* Array.cc (maybe_delete_elements): Use it instead of
 	num_ones (const Array<int>&).
 
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -34,76 +34,40 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 #include "DiagArray2.h"
 
 #include "lo-error.h"
 
 // A two-dimensional array with diagonal elements only.
 
-#if 0
-template <class T>
-T&
-DiagArray2<T>::elem (int r, int c)
-{
-  static T foo (0);
-  return (r == c) ? Array<T>::xelem (r) : foo;
-}
-
-template <class T>
-T&
-DiagArray2<T>::checkelem (int r, int c)
-{
-  static T foo (0);
-  if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
-    {
-      (*current_liboctave_error_handler) ("range error in DiagArray2");
-      return foo;
-    }
-  return (r == c) ? Array<T>::xelem (r) : foo;
-}
-
-template <class T>
-T&
-DiagArray2<T>::operator () (int r, int c)
-{
-  static T foo (0);
-  if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
-    {
-      (*current_liboctave_error_handler) ("range error in DiagArray2");
-      return foo;
-    }
-  return (r == c) ? Array<T>::xelem (r) : foo;
-}
-#endif
-
 template <class T>
 T
 DiagArray2<T>::elem (int r, int c) const
 {
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 T
 DiagArray2<T>::checkelem (int r, int c) const
 {
-  if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
+  if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
     {
       (*current_liboctave_error_handler) ("range error in DiagArray2");
       return T ();
     }
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
 T
 DiagArray2<T>::operator () (int r, int c) const
 {
-  if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
+  if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
     {
       (*current_liboctave_error_handler) ("range error in DiagArray2");
       return T ();
     }
   return (r == c) ? Array<T>::xelem (r) : T (0);
 }
 
 template <class T>
@@ -126,28 +90,28 @@ void
 DiagArray2<T>::resize (int r, int c)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
-  if (r == dim1 () && c == dim2 ())
+  if (r == this->dim1 () && c == this->dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
-  const T *old_data = data ();
-  int old_len = length ();
+  const T *old_data = this->data ();
+  int old_len = this->length ();
 
   int new_len = r < c ? r : c;
 
   Array<T>::rep = new typename Array<T>::ArrayRep (new_len);
 
-  dimensions = dim_vector (r, c);
+  this->dimensions = dim_vector (r, c);
 
   if (old_data && old_len > 0)
     {
       int min_len = old_len < new_len ? old_len : new_len;
 
       for (int i = 0; i < min_len; i++)
 	xelem (i, i) = old_data[i];
     }
@@ -161,28 +125,28 @@ void
 DiagArray2<T>::resize (int r, int c, const T& val)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
       return;
     }
 
-  if (r == dim1 () && c == dim2 ())
+  if (r == this->dim1 () && c == this->dim2 ())
     return;
 
   typename Array<T>::ArrayRep *old_rep = Array<T>::rep;
-  const T *old_data = data ();
-  int old_len = length ();
+  const T *old_data = this->data ();
+  int old_len = this->length ();
 
   int new_len = r < c ? r : c;
 
   Array<T>::rep = new typename Array<T>::ArrayRep (new_len);
 
-  dimensions = dim_vector (r, c);
+  this->dimensions = dim_vector (r, c);
 
   int min_len = old_len < new_len ? old_len : new_len;
 
   if (old_data && old_len > 0)
     {
       for (int i = 0; i < min_len; i++)
 	xelem (i, i) = old_data[i];
     }
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -26,17 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
 #include <cassert>
 #include <cstdlib>
 
-#include "Array2.h"
+#include "Array.h"
 #include "lo-error.h"
 
 class idx_vector;
 
 // A two-dimensional array with diagonal elements only.
 //
 // Idea and example code for Proxy class and functions from:
 //
@@ -106,100 +106,74 @@ private:
 
   };
 
 friend class Proxy;
 
 protected:
 
   DiagArray2 (T *d, int r, int c) : Array<T> (d, r < c ? r : c)
-    { dimensions = dim_vector (r, c); }
+    { Array<T>::dimensions = dim_vector (r, c); }
 
 public:
 
   DiagArray2 (void) : Array<T> (dim_vector (0, 0)) { }
 
   DiagArray2 (int r, int c) : Array<T> (r < c ? r : c)
-    { dimensions = dim_vector (r, c); }
+    { this->dimensions = dim_vector (r, c); }
 
   DiagArray2 (int r, int c, const T& val) : Array<T> (r < c ? r : c)
     {
-      dimensions = dim_vector (r, c);
+      this->dimensions = dim_vector (r, c);
 
       fill (val);
     }
 
   DiagArray2 (const Array<T>& a) : Array<T> (a)
-    { dimensions = dim_vector (a.length (), a.length ()); }
+    { this->dimensions = dim_vector (a.length (), a.length ()); }
 
   DiagArray2 (const DiagArray2<T>& a) : Array<T> (a)
-    { dimensions = a.dims (); }
+    { this->dimensions = a.dims (); }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
     {
       if (this != &a)
-	{
-	  Array<T>::operator = (a);
-	  dimensions = a.dims ();
-	}
+	Array<T>::operator = (a);
 
       return *this;
     }
 
-#if 0
-  operator Array2<T> () const
-    {
-      int nr = dim1 ();
-      int nc = dim2 ();
-
-      Array2<T> retval (nr, nc,  T (0));
-
-      int len = nr < nc ? nr : nc;
-
-      for (int i = 0; i < len; i++)
-	retval.xelem (i, i) = xelem (i, i);
-
-      return retval;
-    }
-#endif
-
-#if 1
   Proxy elem (int r, int c)
     {
       return Proxy (this, r, c);
     }
 
   Proxy checkelem (int r, int c)
     {
-      if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
+      if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
 	{
 	  (*current_liboctave_error_handler) ("range error in DiagArray2");
 	  return Proxy (0, r, c);
 	}
       else
 	return Proxy (this, r, c);
     }
 
   Proxy operator () (int r, int c)
     {
-      if (r < 0 || c < 0 || r >= dim1 () || c >= dim2 ())
+      if (r < 0 || c < 0 || r >= this->dim1 () || c >= this->dim2 ())
 	{
 	  (*current_liboctave_error_handler) ("range error in DiagArray2");
 	  return Proxy (0, r, c);
 	}
       else
 	return Proxy (this, r, c);
   }
-#else
-  T& elem (int r, int c);
-  T& checkelem (int r, int c);
-  T& operator () (int r, int c);
-#endif
 
   T elem (int r, int c) const;
   T checkelem (int r, int c) const;
   T operator () (int r, int c) const;
 
   // No checking.
 
   T& xelem (int r, int c);
diff --git a/liboctave/MArrayN.cc b/liboctave/MArrayN.cc
--- a/liboctave/MArrayN.cc
+++ b/liboctave/MArrayN.cc
@@ -56,37 +56,44 @@ operator -= (MArrayN<T>& a, const T& s)
 
 // Element by element MArrayN by MArrayN ops.
 
 template <class T>
 MArrayN<T>&
 operator += (MArrayN<T>& a, const MArrayN<T>& b)
 {
   int l = a.length ();
+
   if (l > 0)
     {
-      int bl = b.length ();
-      if (l != bl)
-	gripe_nonconformant ("operator +=", l, bl);
+      dim_vector a_dims = a.dims ();
+      dim_vector b_dims = b.dims ();
+
+      if (a_dims != b_dims)
+	gripe_nonconformant ("operator +=", a_dims, b_dims);
       else
 	DO_VV_OP2 (+=);
     }
+
   return a;
 }
 
 template <class T>
 MArrayN<T>&
 operator -= (MArrayN<T>& a, const MArrayN<T>& b)
 {
   int l = a.length ();
+
   if (l > 0)
     {
-      int bl = b.length ();
-      if (l != bl)
-	gripe_nonconformant ("operator -=", l, bl);
+      dim_vector a_dims = a.dims ();
+      dim_vector b_dims = b.dims ();
+
+      if (a_dims != b_dims)
+	gripe_nonconformant ("operator -=", a_dims, b_dims);
       else
 	DO_VV_OP2 (-=);
     }
   return a;
 }
 
 // Element by element MArrayN by scalar ops.
 
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -74,17 +74,17 @@ public:
       int nr = DiagArray2<T>::dim1 ();
       int nc = DiagArray2<T>::dim2 ();
 
       MArray2<T> retval (nr, nc,  T (0));
 
       int len = nr < nc ? nr : nc;
 
       for (int i = 0; i < len; i++)
-	retval.xelem (i, i) = xelem (i, i);
+	retval.xelem (i, i) = this->xelem (i, i);
 
       return retval;
     }
 
   static MDiagArray2<T> nil_array;
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,27 +1,66 @@
+2003-11-23  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* oct-stream.cc (octave_stream::seek): Extract std::streamoff from
+	tc_offset instead of int.
+
+	* ov-re-mat.cc (octave_matrix::double_value): Use numel, not length.
+
+	* ov-re-mat.cc (octave_matrix::streamoff_array_value): New function.
+	* ov-re-mat.h: Provide decl.
+
+	* ov-scalar.cc (octave_scalar::streamoff_value): New function.
+	* ov-scalar.h: Provide decl.
+
+	* ov.cc (octave_value::streamoff_array_value,
+	octave_value::streamoff_value): New functions.
+	* ov.h: Provide decls.
+
+	* ov-base.cc (octave_base_value::streamoff_array_value,
+	octave_base_value::streamoff_value): New functions.
+	* ov-base.h: Provide decls.
+
+	* ov-usr-fcn.cc (install_automatic_vars): Don't do anything unless
+	sym_tab is defined.
+
+	* ov-streamoff.h, ov-streamoff.cc, OPERATORS/op-streamoff.cc:
+	New files.
+
+	* ov-cell.h (octave_value_cell::is_matrix_type): New function.
+
+	* ov-mapper.h (octave_mapper::octave_mapper): No copying.
+	* ov-fcn.h (octave_function::octave_function): Likewise.
+	* ov-usr-fcn.h (octave_function::octave_function): Likewise.
+	* ov-builtin.h (octave_builtin::octave_builtin): Likewise.
+	* ov-dld-fcn.h (octave_dld_function::octave_dld_function): Likewise.
+
 2003-11-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
-	* ov-dld-fcn.h (octave_dld_function::octave_dld_function): 
-	Make public, but abort if called.
+	* ov-mapper.h (octave_mapper::octave_mapper): Make public.
+	Provide copy constructor and assignment operator.
+	* ov-fcn.h (octave_function::octave_function): Likewise.
 	* ov-builtin.h (octave_builtin::octave_builtin): Likewise.
-	* ov-fcn.h (octave_function::octave_function): Likewise.
+	* ov-dld-fcn.h (octave_dld_function::octave_dld_function): Likewise.
 
 	* ov-typeinfo.cc (octave_value_typeinfo::register_type,
 	octave_value_typeinfo::do_register_type): New arg, val.
+	Save it	in vals array.
 	(octave_value_typeinfo::lookup_type,
 	octave_value_typeinfo::do_lookup_type): New functions.
 	* ov-typeinfo.h: Provide decl.
+	(octave_value_typeinfo::vals): New data member.
+	(octave_value_typeinfo::octave_value_typeinfo): Initialize it.
 
 	* ov.h (DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA): Pass
 
 	* ov.h (DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA): Define register_type
 	here.  Also pass an empty object of the to-be-registered type to
 	register_type.
-	(DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA): Declare register type
+	(DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA): Declare register_type
 	here, but don't define it.
 
 2003-11-21  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* ov-fcn-handle.h (octave_fcn_handle::octave_fcn_handle (void)):
 	New constructor.
 
 	* ov-usr-fcn.h (octave_user_function::octave_user_function):
diff --git a/src/OPERATORS/op-streamoff.cc b/src/OPERATORS/op-streamoff.cc
new file mode 100644
--- /dev/null
+++ b/src/OPERATORS/op-streamoff.cc
@@ -0,0 +1,159 @@
+/*
+
+Copyright (C) 2003 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gripes.h"
+#include "ov.h"
+#include "ov-re-mat.h"
+#include "ov-scalar.h"
+#include "ov-streamoff.h"
+#include "ov-typeinfo.h"
+#include "ops.h"
+
+// streamoff unary ops.
+
+DEFUNOP (transpose, streamoff)
+{
+  CAST_UNOP_ARG (const octave_streamoff&);
+
+  return octave_value (streamoff_array (v.streamoff_array_value().transpose ()));
+}
+
+// DEFNCUNOP_METHOD (incr, streamoff, increment)
+// DEFNCUNOP_METHOD (decr, streamoff, decrement)
+
+// streamoff by streamoff ops.
+
+DEFNDBINOP_OP (add, streamoff, streamoff, streamoff_array, streamoff_array, +)
+DEFNDBINOP_OP (sub, streamoff, streamoff, streamoff_array, streamoff_array, -)
+
+DEFNDBINOP_OP (add_so_m, streamoff, matrix, streamoff_array, streamoff_array, +)
+DEFNDBINOP_OP (sub_so_m, streamoff, matrix, streamoff_array, streamoff_array, -)
+
+DEFNDBINOP_OP (add_m_so, matrix, streamoff, streamoff_array, streamoff_array, +)
+DEFNDBINOP_OP (sub_m_so, matrix, streamoff, streamoff_array, streamoff_array, +)
+DEFNDBINOP_OP (add_so_s, streamoff, scalar, streamoff_array, streamoff, +)
+DEFNDBINOP_OP (sub_so_s, streamoff, scalar, streamoff_array, streamoff, -)
+
+DEFNDBINOP_OP (add_s_so, scalar, streamoff, streamoff, streamoff_array, +)
+DEFNDBINOP_OP (sub_s_so, scalar, streamoff, streamoff, streamoff_array, +)
+
+DEFBINOP (eq, streamoff, streamoff)
+{
+  CAST_BINOP_ARGS (const octave_streamoff&,
+		   const octave_streamoff&);
+
+  streamoff_array cm1 = v1.streamoff_array_value ();
+  streamoff_array cm2 = v2.streamoff_array_value ();
+
+  if (cm1.rows () == 1 && cm1.columns () == 1)
+    {
+      if (cm2.rows () == 1 && cm2.columns () == 1)
+	return octave_value (cm1 (0, 0) == cm2 (0, 0));
+      else
+	SC_MX_BOOL_OP (std::streamoff, c, cm1 (0, 0), streamoff_array, m, cm2,
+		       c == m (i, j), 0.0);
+    }
+  else
+    {
+      int cm2_nr = cm2.rows ();
+      int cm2_nc = cm2.cols ();
+
+      if (cm2_nr == 1 && cm2_nc == 1)
+	MX_SC_BOOL_OP (streamoff_array, m, cm1, std::streamoff, c, cm2 (0, 0),
+		       c == m (i, j), 0.0);
+      else
+	MX_MX_BOOL_OP (streamoff_array, m1, cm1, streamoff_array, m2, cm2,
+		       m1 (i, j) == m2 (i, j), "==", 0.0, 1.0);
+    }
+}
+
+DEFBINOP (ne, streamoff, streamoff)
+{
+  CAST_BINOP_ARGS (const octave_streamoff&,
+		   const octave_streamoff&);
+
+  streamoff_array cm1 = v1.streamoff_array_value ();
+  streamoff_array cm2 = v2.streamoff_array_value ();
+
+  if (cm1.rows () == 1 && cm1.columns () == 1)
+    {
+      if (cm2.rows () == 1 && cm2.columns () == 1)
+	return octave_value (cm1 (0, 0) != cm2 (0, 0));
+      else
+	SC_MX_BOOL_OP (std::streamoff, c, cm1 (0, 0), streamoff_array, m, cm2,
+		       c != m (i, j), 1.0);
+    }
+  else
+    {
+      if (cm2.rows () == 1 && cm2.columns () == 1)
+	MX_SC_BOOL_OP (streamoff_array, m, cm1, std::streamoff, c, cm2 (0, 0),
+		       c != m (i, j), 1.0);
+      else
+	MX_MX_BOOL_OP (streamoff_array, m1, cm1, streamoff_array, m2, cm2,
+		       m1 (i, j) != m2 (i, j), "!=", 1.0, 0.0);
+    }
+}
+
+DEFASSIGNOP (assign, streamoff, streamoff)
+{
+  CAST_BINOP_ARGS (octave_streamoff&, const octave_streamoff&);
+
+  v1.assign (idx, v2.streamoff_array_value ());
+  return octave_value ();
+}
+
+void
+install_streamoff_ops (void)
+{
+  INSTALL_UNOP (op_transpose, octave_streamoff, transpose);
+  INSTALL_UNOP (op_hermitian, octave_streamoff, transpose);
+
+  INSTALL_BINOP (op_eq, octave_streamoff, octave_streamoff, eq);
+  INSTALL_BINOP (op_ne, octave_streamoff, octave_streamoff, ne);
+
+  INSTALL_BINOP (op_add, octave_streamoff, octave_streamoff, add);
+  INSTALL_BINOP (op_sub, octave_streamoff, octave_streamoff, sub);
+
+  INSTALL_BINOP (op_add, octave_streamoff, octave_matrix, add_so_m);
+  INSTALL_BINOP (op_sub, octave_streamoff, octave_matrix, sub_so_m);
+
+  INSTALL_BINOP (op_add, octave_matrix, octave_streamoff, add_m_so);
+  INSTALL_BINOP (op_sub, octave_matrix, octave_streamoff, sub_m_so);
+
+  INSTALL_BINOP (op_add, octave_streamoff, octave_scalar, add_so_s);
+  INSTALL_BINOP (op_sub, octave_streamoff, octave_scalar, sub_so_s);
+
+  INSTALL_BINOP (op_add, octave_scalar, octave_streamoff, add_s_so);
+  INSTALL_BINOP (op_sub, octave_scalar, octave_streamoff, sub_s_so);
+
+  INSTALL_ASSIGNOP (op_asn_eq, octave_streamoff, octave_streamoff, assign);
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -38,16 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include "str-vec.h"
 #include "quit.h"
 
 #include "error.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
+#include "ov-streamoff.h"
 #include "utils.h"
 
 // Possible values for conv_err:
 //
 //   1 : not a real scalar
 //   2 : value is NaN
 //   3 : value is not an integer
 
@@ -2692,22 +2693,22 @@ octave_stream::seek (std::streamoff offs
 }
 
 int
 octave_stream::seek (const octave_value& tc_offset,
 		     const octave_value& tc_origin)
 {
   int retval = -1;
 
-  int conv_err = 0;
-
-  int xoffset = convert_to_valid_int (tc_offset, conv_err);
-
-  if (! conv_err)
+  std::streamoff xoffset = tc_offset.streamoff_value ();
+
+  if (! error_state)
     {
+      int conv_err = 0;
+
       std::ios::seekdir origin = std::ios::beg;
 
       if (tc_origin.is_string ())
 	{
 	  std::string xorigin = tc_origin.string_value ();
 
 	  if (xorigin == "bof")
 	    origin = std::ios::beg;
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -461,21 +461,30 @@ octave_base_value::map_keys (void) const
 octave_stream
 octave_base_value::stream_value (void) const
 {
   octave_stream retval;
   gripe_wrong_type_arg ("octave_base_value::stream_value()", type_name ());
   return retval;
 }
 
-streamoff_array
+std::streamoff
 octave_base_value::streamoff_value (void) const
 {
+  std::streamoff retval;
+  gripe_wrong_type_arg ("octave_base_value::streamoff_value()", type_name ());
+  return retval;
+}
+
+streamoff_array
+octave_base_value::streamoff_array_value (void) const
+{
   streamoff_array retval;
-  gripe_wrong_type_arg ("octave_base_value::streamoff_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::streamoff_array_value()",
+			type_name ());
   return retval;
 }
 
 int
 octave_base_value::stream_number (void) const
 {
   int retval = -1;
   gripe_wrong_type_arg ("octave_base_value::stream_number()", type_name ());
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -221,17 +221,19 @@ public:
   Octave_map map_value (void) const;
 
   string_vector map_keys (void) const;
 
   octave_stream stream_value (void) const;
 
   int stream_number (void) const;
 
-  streamoff_array streamoff_value (void) const;
+  std::streamoff streamoff_value (void) const;
+
+  streamoff_array streamoff_array_value (void) const;
 
   octave_function *function_value (bool silent);
 
   octave_fcn_handle *fcn_handle_value (bool silent);
 
   octave_value_list list_value (void) const;
 
   octave_value convert_to_str_internal (bool pad, bool force) const;
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -22,34 +22,32 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_builtin_h)
 #define octave_builtin_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <cstdlib>
-
 #include <string>
 
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 
 class octave_value;
 class octave_value_list;
 
 // Builtin functions.
 
 class
 octave_builtin : public octave_function
 {
 public:
 
-  octave_builtin (void) { abort (); }
+  octave_builtin (void) { }
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = std::string (),
 		  const std::string& ds = std::string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
@@ -74,17 +72,21 @@ public:
 
 protected:
 
   // A pointer to the actual function.
   fcn f;
 
 private:
 
-  octave_builtin (const octave_builtin& m);
+  // No copying!
+
+  octave_builtin (const octave_builtin& ob);
+
+  octave_builtin& operator = (const octave_builtin& ob);
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -83,16 +83,18 @@ public:
       panic_impossible ();
       return octave_value_list ();
     }
 
   octave_value subsasgn (const std::string& type,
 			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
+  bool is_matrix_type (void) const { return false; }
+
   bool is_numeric_type (void) const { return false; }
 
   bool is_defined (void) const { return true; }
 
   bool is_cell (void) const { return true; }
 
   Cell cell_value (void) const { return matrix; }
 
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -22,18 +22,16 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_dld_function_h)
 #define octave_dld_function_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <cstdlib>
-
 #include <string>
 
 #include "oct-shlib.h"
 
 #include "ov-fcn.h"
 #include "ov-builtin.h"
 #include "ov-typeinfo.h"
 
@@ -44,17 +42,17 @@ class octave_value_list;
 
 // Dynamically-linked functions.
 
 class
 octave_dld_function : public octave_builtin
 {
 public:
 
-  octave_dld_function (void) { abort (); }
+  octave_dld_function (void) { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
 		       const std::string& nm = std::string (),
 		       const std::string& ds = std::string ());
 
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
@@ -68,29 +66,33 @@ public:
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
 private:
 
-  octave_dld_function (const octave_dld_function& m);
-
   octave_shlib sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   mutable octave_time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
+  // No copying!
+
+  octave_dld_function (const octave_dld_function& fn);
+
+  octave_dld_function& operator = (const octave_dld_function& fn);
+
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -22,18 +22,16 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_function_h)
 #define octave_function_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <cstdlib>
-
 #include <string>
 
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include "oct-alloc.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
@@ -42,20 +40,17 @@ class tree_walker;
 
 // Functions.
 
 class
 octave_function : public octave_base_value
 {
 public:
 
-  octave_function (void) { abort (); }
-
-  octave_function (const octave_function& f)
-    : octave_base_value (), my_name (f.my_name), doc (f.doc) { }
+  octave_function (void) { }
 
   ~octave_function (void) { }
 
   octave_value *clone (void) const;
   octave_value *empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
@@ -93,16 +88,22 @@ protected:
   // The name of this function.
   std::string my_name;
 
   // The help text for this function.
   std::string doc;
 
 private:
 
+  // No copying!
+
+  octave_function (const octave_function& f);
+
+  octave_function& operator = (const octave_function& f);
+
   DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
 
 /*
 ;; Local Variables: ***
 ;; mode: C++ ***
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
--- a/src/ov-mapper.h
+++ b/src/ov-mapper.h
@@ -22,35 +22,33 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_mapper_h)
 #define octave_mapper_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <cstdlib>
-
 #include <string>
 
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 
 class octave_value;
 class octave_value_list;
 
 // Builtin mapper functions.
 
 class
 octave_mapper : public octave_function
 {
 public:
 
-  octave_mapper (void) { abort (); }
+  octave_mapper (void) { }
 
   typedef int (*ch_mapper) (int);
   typedef bool (*d_b_mapper) (double);
   typedef bool (*c_b_mapper) (const Complex&);
   typedef double (*d_d_mapper) (double);
   typedef double (*d_c_mapper) (const Complex&);
   typedef Complex (*c_c_mapper) (const Complex&);
 
@@ -81,18 +79,16 @@ public:
 			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
 private:
 
-  octave_mapper (const octave_mapper& m);
-
   octave_value apply (const octave_value& arg) const;
 
   // ch_map_fcn is a kluge.
 
   ch_mapper ch_map_fcn;
   d_b_mapper d_b_map_fcn;
   c_b_mapper c_b_map_fcn;
   d_d_mapper d_d_map_fcn;
@@ -116,16 +112,22 @@ private:
   int ch_map_flag;
 
   // can_ret_cmplx_for_real is a flag that says whether this function
   // can create a complex number given a real-valued  argument
   // (e.g., sqrt (-1)).
 
   bool can_ret_cmplx_for_real;
 
+  // No copying!
+
+  octave_mapper (const octave_mapper& om);
+
+  octave_mapper& operator = (const octave_mapper& om);
+
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -77,18 +77,17 @@ octave_matrix::valid_as_scalar_index (vo
   return false;
 }
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  // XXX FIXME XXX -- maybe this should be a function, valid_as_scalar()
-  if (rows () > 0 && columns () > 0)
+  if (numel () > 0)
     {
       // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
       if (Vwarn_fortran_indexing)
 	gripe_implicit_conversion ("real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
@@ -130,16 +129,39 @@ octave_matrix::complex_value (bool) cons
 // XXX FIXME XXX
 
 ComplexMatrix
 octave_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
 }
 
+streamoff_array
+octave_matrix::streamoff_array_value (void) const
+{
+  streamoff_array retval (dims ());
+
+  int nel = numel ();
+
+  for (int i = 0; i < nel; i++)
+    {
+      double d = matrix(i);
+
+      if (D_NINT (d) == d)
+	retval(i) = std::streamoff (static_cast<long> (d));
+      else
+	{
+	  error ("conversion to streamoff_array value failed");
+	  break;
+	}
+    }
+
+  return retval;
+}
+
 octave_value
 octave_matrix::convert_to_str_internal (bool, bool) const
 {
   octave_value retval;
 
   int nr = matrix.rows ();
   int nc = matrix.columns ();
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -34,16 +34,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
+#include "ov-streamoff.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Real matrix values.
@@ -98,16 +99,18 @@ public:
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   NDArray array_value (bool = false) const { return matrix; }
 
+  streamoff_array streamoff_array_value (void) const;
+
   void increment (void) { matrix += 1.0; }
 
   void decrement (void) { matrix -= 1.0; }
 
   octave_value convert_to_str_internal (bool pad, bool force) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -71,16 +71,29 @@ octave_scalar::do_index_op (const octave
       octave_value tmp (new octave_matrix (matrix_value ()));
 
       retval = tmp.do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
+std::streamoff
+octave_scalar::streamoff_value (void) const
+{
+  std::streamoff retval (-1);
+
+  if (D_NINT (scalar) == scalar)
+    retval = std::streamoff (static_cast<long> (scalar));
+  else
+    error ("conversion to streamoff value failed");
+
+  return retval;
+}
+
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     ::error ("invalid conversion from NaN to character");
   else
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -95,16 +95,18 @@ public:
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
     { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
+  std::streamoff streamoff_value (void) const;
+
   octave_value convert_to_str_internal (bool pad, bool force) const;
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
 private:
 
diff --git a/src/ov-streamoff.cc b/src/ov-streamoff.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-streamoff.cc
@@ -0,0 +1,235 @@
+/*
+
+Copyright (C) 2003 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iostream>
+
+#include "Array.h"
+#include "Array.cc"
+#include "ArrayN.h"
+#include "ArrayN.cc"
+
+#include "defun.h"
+#include "error.h"
+#include "gripes.h"
+#include "ov-streamoff.h"
+#include "oct-obj.h"
+#include "unwind-prot.h"
+#include "utils.h"
+#include "ov-base-mat.h"
+#include "ov-base-mat.cc"
+
+INSTANTIATE_ARRAY_AND_ASSIGN (std::streamoff);
+
+template class ArrayN<std::streamoff>;
+
+template class octave_base_matrix<streamoff_array>;
+
+DEFINE_OCTAVE_ALLOCATOR (octave_streamoff);
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_streamoff,
+				     "streamoff", "streamoff");
+boolNDArray
+streamoff_array::all (int dim) const
+{
+  MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (MX_ND_ALL_EXPR), true);
+}
+
+boolNDArray
+streamoff_array::any (int dim) const
+{
+  MX_ND_ANY_ALL_REDUCTION (MX_ND_ANY_EVAL (MX_ND_ANY_EXPR), false);
+}
+
+#if 0
+streamoff_array&
+streamoff_array::operator += (const streamoff_array& a)
+{
+  // XXX FIXME XXX 
+  return *this;
+}
+
+streamoff_array&
+streamoff_array::operator -= (const streamoff_array& a)
+{
+  // XXX FIXME XXX 
+  return *this;
+}
+#endif
+
+int
+streamoff_array::compute_index (Array<int>& ra_idx,
+				const dim_vector& dimensions)
+{
+  return ::compute_index (ra_idx, dimensions);
+}
+
+SND_CMP_OP (mx_el_eq, ==, std::streamoff, , streamoff_array, , FBM)
+SND_CMP_OP (mx_el_ne, !=, std::streamoff, , streamoff_array, , TBM)
+
+NDS_CMP_OP (mx_el_eq, ==, streamoff_array, , std::streamoff, , FBM)
+NDS_CMP_OP (mx_el_ne, !=, streamoff_array, , std::streamoff, , TBM)
+
+NDND_CMP_OP (mx_el_eq, ==, streamoff_array, , streamoff_array, , FBM, TBM)
+NDND_CMP_OP (mx_el_ne, !=, streamoff_array, , streamoff_array, , TBM, FBM)
+
+NDND_BIN_OP (streamoff_array, operator +, streamoff_array, streamoff_array, mx_inline_add)
+NDND_BIN_OP (streamoff_array, operator -, streamoff_array, streamoff_array, mx_inline_subtract)
+
+NDS_BIN_OP (streamoff_array, operator +, streamoff_array, std::streamoff, mx_inline_add)
+NDS_BIN_OP (streamoff_array, operator -, streamoff_array, std::streamoff, mx_inline_subtract)
+
+SND_BIN_OP (streamoff_array, operator +, std::streamoff, streamoff_array, mx_inline_add)
+SND_BIN_OP (streamoff_array, operator -, std::streamoff, streamoff_array, mx_inline_subtract)
+
+std::streamoff
+octave_streamoff::streamoff_value (void) const
+{
+  std::streamoff retval (-1);
+
+  if (numel () > 0)
+    {
+      // XXX FIXME XXX -- is warn_fortran_indexing the right variable here?
+      if (Vwarn_fortran_indexing)
+	gripe_implicit_conversion ("streamoff array", "scalar streamoff");
+
+      retval = matrix (0, 0);
+    }
+  else
+    gripe_invalid_conversion ("streamoff array", "scalar streamoff");
+
+  return retval;
+}
+
+void
+octave_streamoff::print (std::ostream& os, bool) const
+{
+  print_raw (os);
+  newline (os);
+}
+
+void
+octave_streamoff::print_raw (std::ostream& os, bool) const
+{
+  dim_vector dv = matrix.dims ();
+  os << "<" << dv.str () << " streamoff object>";
+}
+
+DEFUN (isstreamoff, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} isstreamoff (@var{x})\n\
+Return true if @var{x} is a streamoff object.  Otherwise, return\n\
+false.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (args.length () == 1)
+    retval = args(0).is_streamoff ();
+  else
+    print_usage ("isstreamoff");
+
+  return retval;
+}
+
+DEFUN (streamoff, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} streamoff (@var{x})\n\
+@deftypefnx {Built-in Function} {} streamoff (@var{n}, @var{m})\n\
+Create a new streamoff array object.  If invoked with a single scalar\n\
+argument, @code{streamoff} returns a square streamoff array with\n\
+the dimension specified.  If you supply two scalar arguments,\n\
+@code{streamoff} takes them to be the number of rows and columns.\n\
+If given a vector with two elements, @code{streamoff} uses the values\n\
+of the elements as the number of rows and columns, respectively.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  dim_vector dims;
+
+  switch (nargin)
+    {
+    case 0:
+      dims = dim_vector (0, 0);
+      break;
+
+    case 1:
+      get_dimensions (args(0), "streamoff", dims);
+      break;
+
+    default:
+      {
+	dims.resize (nargin);
+
+	for (int i = 0; i < nargin; i++)
+	  {
+	    dims(i) = args(i).is_empty () ? 0 : args(i).nint_value ();
+
+	    if (error_state)
+	      {
+		error ("streamoff: expecting scalar arguments");
+		break;
+	      }
+	  }
+      }
+      break;
+    }
+
+  if (! error_state)
+    {
+      int ndim = dims.length ();
+
+      check_dimensions (dims, "streamoff");
+
+      if (! error_state)
+	{
+	  switch (ndim)
+	    {
+	    case 1:
+	      retval = Cell (dims(0), dims(0), Matrix ());
+	      break;
+
+	    default:
+	      retval = Cell (dims, Matrix ());
+	      break;
+	    }
+	}
+    }
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-streamoff.h b/src/ov-streamoff.h
new file mode 100644
--- /dev/null
+++ b/src/ov-streamoff.h
@@ -0,0 +1,160 @@
+/*
+
+Copyright (C) 2003 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_streamoff_h)
+#define octave_streamoff_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include <iostream>
+#include <string>
+
+#include "mx-base.h"
+#include "mx-op-defs.h"
+#include "oct-alloc.h"
+#include "str-vec.h"
+
+#include "error.h"
+#include "oct-obj.h"
+#include "ov-base-mat.h"
+#include "ov-typeinfo.h"
+
+class tree_walker;
+
+// Stream offsets.
+
+class streamoff_array : public ArrayN<std::streamoff>
+{
+public:
+
+  streamoff_array (void) : ArrayN<std::streamoff> () { }
+
+  streamoff_array (const dim_vector& dv,
+		   const std::streamoff& val = resize_fill_value ())
+    : ArrayN<std::streamoff> (dv, val) { }
+
+  streamoff_array (const ArrayN<std::streamoff>& sa)
+    : ArrayN<std::streamoff> (sa) { }
+
+  streamoff_array (const streamoff_array& sa)
+    : ArrayN<std::streamoff> (sa) { }
+
+  ~streamoff_array (void) { }
+
+  streamoff_array& operator = (const streamoff_array& a)
+    {
+      if (this != &a)
+	ArrayN<std::streamoff>::operator = (a);
+
+      return *this;
+    }
+
+  streamoff_array squeeze (void) const
+    { return ArrayN<std::streamoff>::squeeze (); }
+
+  boolNDArray all (int dim = -1) const;
+  boolNDArray any (int dim = -1) const;
+
+  // streamoff_array& operator += (const streamoff_array& a);
+  // streamoff_array& operator -= (const streamoff_array& a);
+
+  static int compute_index (Array<int>& ra_idx,
+			    const dim_vector& dimensions);
+
+  static std::streamoff resize_fill_value (void) { return 0; }
+};
+
+NDCMP_OP_DECL (mx_el_eq, std::streamoff, streamoff_array);
+NDCMP_OP_DECL (mx_el_ne, std::streamoff, streamoff_array);
+
+NDCMP_OP_DECL (mx_el_eq, streamoff_array, std::streamoff);
+NDCMP_OP_DECL (mx_el_ne, streamoff_array, std::streamoff);
+
+NDCMP_OP_DECL (mx_el_eq, streamoff_array, streamoff_array);
+NDCMP_OP_DECL (mx_el_ne, streamoff_array, streamoff_array);
+
+BIN_OP_DECL (streamoff_array, operator +, streamoff_array, streamoff_array);
+BIN_OP_DECL (streamoff_array, operator -, streamoff_array, streamoff_array);
+
+BIN_OP_DECL (streamoff_array, operator +, streamoff_array, std::streamoff);
+BIN_OP_DECL (streamoff_array, operator -, streamoff_array, std::streamoff);
+
+BIN_OP_DECL (streamoff_array, operator +, std::streamoff, streamoff_array);
+BIN_OP_DECL (streamoff_array, operator -, std::streamoff, streamoff_array);
+
+class
+octave_streamoff : public octave_base_matrix<streamoff_array>
+{
+public:
+
+  octave_streamoff (void)
+    : octave_base_matrix<streamoff_array> () { }
+
+  octave_streamoff (const std::streamoff& off)
+    : octave_base_matrix<streamoff_array>
+        (streamoff_array (dim_vector (1, 1), off)) { }
+
+  octave_streamoff (const streamoff_array& off)
+    : octave_base_matrix<streamoff_array> (off) { }
+
+  octave_streamoff (const octave_streamoff& off)
+    : octave_base_matrix<streamoff_array> (off) { }
+
+  ~octave_streamoff (void) { }
+
+  octave_value *clone (void) const { return new octave_streamoff (*this); }
+  octave_value *empty_clone (void) const { return new octave_streamoff (); }
+
+  bool is_defined (void) const { return true; }
+
+  bool is_streamoff (void) const { return true; }
+
+  std::streamoff streamoff_value (void) const;
+
+  streamoff_array streamoff_array_value (void) const { return matrix; }
+
+  //  void increment (void) { matrix += 1; }
+
+  //  void decrement (void) { matrix -= 1; }
+
+  bool print_as_scalar (void) const { return true; }
+
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+private:
+
+  DECLARE_OCTAVE_ALLOCATOR
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -117,16 +117,17 @@ public:
   {
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
     : num_types (0), types (init_tab_sz, std::string ()),
+      vals (init_tab_sz),
       unary_ops (octave_value::num_unary_ops, init_tab_sz,
 		 (unary_op_fcn) 0),
       non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz,
 			   (non_const_unary_op_fcn) 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz,
 		  init_tab_sz, (binary_op_fcn) 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz,
 		  init_tab_sz, (assign_op_fcn) 0),
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -553,22 +553,25 @@ octave_user_function::print_code_functio
   tree_print_code tpc (octave_stdout, Vps4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::install_automatic_vars (void)
 {
-  argn_sr = sym_tab->lookup ("argn", true);
-  nargin_sr = sym_tab->lookup ("nargin", true);
-  nargout_sr = sym_tab->lookup ("nargout", true);
+  if (sym_tab)
+    {
+      argn_sr = sym_tab->lookup ("argn", true);
+      nargin_sr = sym_tab->lookup ("nargin", true);
+      nargout_sr = sym_tab->lookup ("nargout", true);
 
-  if (takes_varargs ())
-    varargin_sr = sym_tab->lookup ("varargin", true);
+      if (takes_varargs ())
+	varargin_sr = sym_tab->lookup ("varargin", true);
+    }
 }
 
 void
 octave_user_function::bind_automatic_vars
   (const string_vector& arg_names, int nargin, int nargout,
    const octave_value_list& va_args)
 {
   if (! arg_names.empty ())
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -163,18 +163,16 @@ public:
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   void accept (tree_walker& tw);
 
   void print_symtab_info (std::ostream& os) const;
 
 private:
 
-  octave_user_function (const octave_user_function& m);
-
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
@@ -251,16 +249,23 @@ private:
 
   void print_code_function_trailer (void);
 
   void install_automatic_vars (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
 			    int nargout, const octave_value_list& va_args);
 
+
+  // No copying!
+
+  octave_user_function (const octave_user_function& fn);
+
+  octave_user_function& operator = (const octave_user_function& fn);
+
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -925,22 +925,28 @@ octave_value::stream_value (void) const
 }
 
 int
 octave_value::stream_number (void) const
 {
   return rep->stream_number ();
 }
 
-streamoff_array
+std::streamoff
 octave_value::streamoff_value (void) const
 {
   return rep->streamoff_value ();
 }
 
+streamoff_array
+octave_value::streamoff_array_value (void) const
+{
+  return rep->streamoff_array_value ();
+}
+
 octave_function *
 octave_value::function_value (bool silent)
 {
   return rep->function_value (silent);
 }
 
 octave_fcn_handle *
 octave_value::fcn_handle_value (bool silent)
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -543,17 +543,19 @@ public:
 
   virtual string_vector map_keys (void) const
     { return rep->map_keys (); }
 
   virtual octave_stream stream_value (void) const;
 
   virtual int stream_number (void) const;
 
-  virtual streamoff_array streamoff_value (void) const;
+  virtual std::streamoff streamoff_value (void) const;
+
+  virtual streamoff_array streamoff_array_value (void) const;
 
   virtual octave_function *function_value (bool silent = false);
 
   virtual octave_fcn_handle *fcn_handle_value (bool silent = false);
 
   virtual octave_value_list list_value (void) const;
 
   ColumnVector column_vector_value (bool frc_str_conv = false,
@@ -774,17 +776,17 @@ OV_BINOP_FN (op_struct_ref)
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
   int t::t_id (-1); \
   const std::string t::t_name (n); \
   const std::string t::c_name (c); \
   void t::register_type (void) \
     { \
       t_id = octave_value_typeinfo::register_type (t::t_name, \
 						   t::c_name, \
-						   octave_value (new t)); \
+						   octave_value (new t ())); \
     }
 
 // If TRUE, print a warning for assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 extern bool Vwarn_fortran_indexing;
