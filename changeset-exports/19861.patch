# HG changeset patch
# User Rik <rik@octave.org>
# Date 1424894149 28800
#      Wed Feb 25 11:55:49 2015 -0800
# Node ID 19755f4fc851f3fa8721c1885d32f99a2d654d13
# Parent  e8ccfc5d892be91036c4c9a3f60ee18aa220fb9d
maint: Cleanup C++ code to follow Octave coding conventions.
Try to wrap long lines to < 80 characters.
Use GNU style and don't indent first brace of function definition.
"case" statement is aligned flush left with brace of switch stmt.
Remove trailing '\' line continuation from the end of #define macros.
Use 2 spaces for indent.

* files-dock-widget.cc, history-dock-widget.cc, main-window.cc, octave-cmd.cc,
octave-dock-widget.cc, octave-gui.cc, resource-manager.cc, settings-dialog.cc,
shortcut-manager.cc, welcome-wizard.cc, workspace-view.cc, cellfun.cc, data.cc,
debug.cc, debug.h, dirfns.cc, error.h, file-io.cc, gl-render.cc, gl-render.h,
gl2ps-renderer.h, graphics.cc, graphics.in.h, help.cc, input.cc, load-path.cc,
load-path.h, lookup.cc, lu.cc, oct-stream.cc, octave-default-image.h,
ordschur.cc, pr-output.cc, qz.cc, strfns.cc, symtab.cc, symtab.h, sysdep.cc,
variables.cc, zfstream.h, __fltk_uigetfile__.cc, __init_fltk__.cc,
__magick_read__.cc, __osmesa_print__.cc, audiodevinfo.cc, ov-classdef.cc,
ov-classdef.h, ov-fcn.h, ov-float.cc, ov-flt-complex.cc, ov-java.cc,
ov-range.cc, ov-re-mat.cc, ov-usr-fcn.h, ov.cc, op-int.h, options-usage.h,
pt-eval.cc, Array-C.cc, Array-fC.cc, Array.cc, Array.h, PermMatrix.cc,
Sparse.cc, chMatrix.h, dSparse.cc, dim-vector.h, bsxfun-decl.h, bsxfun-defs.cc,
oct-norm.cc, Sparse-op-defs.h, oct-inttypes.cc, oct-inttypes.h, main.in.cc,
mkoctfile.in.cc: Cleanup C++ code to follow Octave coding conventions.

diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -194,17 +194,18 @@ files_dock_widget::files_dock_widget (QW
   // Attach the model to the QTreeView and set the root index
   _file_tree_view = new FileTreeViewer (container);
   _file_tree_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
   _file_tree_view->setModel (_file_system_model);
   _file_tree_view->setRootIndex (rootPathIndex);
   _file_tree_view->setSortingEnabled (true);
   _file_tree_view->setAlternatingRowColors (true);
   _file_tree_view->setAnimated (true);
-  _file_tree_view->setToolTip (tr ("Activate to open in editor, right click for alternatives"));
+  _file_tree_view->setToolTip (
+    tr ("Activate to open in editor, right click for alternatives"));
 
   // get sort column and order as well as cloumn state (order and width)
 
   _file_tree_view->sortByColumn (
     settings->value ("filesdockwidget/sort_files_by_column",0).toInt (),
     static_cast<Qt::SortOrder>
     (settings->value ("filesdockwidget/sort_files_by_order",
                       Qt::AscendingOrder).toUInt ())
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -279,17 +279,18 @@ history_dock_widget::clear_history (void
   _history_model->setStringList (QStringList ());
 }
 
 void
 history_dock_widget::copyClipboard ()
 {
   if (_history_list_view->hasFocus ())
     handle_contextmenu_copy (true);
-  if (_filter->lineEdit ()->hasFocus () && _filter->lineEdit ()->hasSelectedText ())
+  if (_filter->lineEdit ()->hasFocus ()
+      && _filter->lineEdit ()->hasSelectedText ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText ( _filter->lineEdit ()->selectedText ());
     }
 }
 
 void
 history_dock_widget::pasteClipboard ()
@@ -303,15 +304,15 @@ history_dock_widget::pasteClipboard ()
     }
 }
 
 void
 history_dock_widget::selectAll ()
 {
   if (_filter->lineEdit ()->hasFocus ())
     {
-        _filter->lineEdit ()->selectAll ();
+      _filter->lineEdit ()->selectAll ();
     }
   if (_history_list_view->hasFocus ())
     {
-        _history_list_view->selectAll ();
+      _history_list_view->selectAll ();
     }
 }
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1569,21 +1569,21 @@ main_window::add_action (QMenu *menu, co
   return a;
 }
 
 void
 main_window::enable_menu_shortcuts (bool enable)
 {
   QHash<QMenu*, QStringList>::const_iterator i = _hash_menu_text.constBegin();
 
- while (i != _hash_menu_text.constEnd())
-   {
-     i.key ()->setTitle (i.value ().at (! enable));
-     ++i;
-   }
+  while (i != _hash_menu_text.constEnd())
+    {
+      i.key ()->setTitle (i.value ().at (! enable));
+      ++i;
+    }
 }
 
 QMenu*
 main_window::m_add_menu (QMenuBar *p, QString name)
 {
   QMenu *menu = p->addMenu (name);
 
   QString base_name = name;  // get a copy
@@ -1807,17 +1807,17 @@ main_window::construct_window_menu_item 
     {
       if (checkable)
         {
           // action for visibilty of dock widget
           connect (action, SIGNAL (toggled (bool)),
                    widget, SLOT (setVisible (bool)));
 
           connect (widget, SIGNAL (active_changed (bool)),
-                  action, SLOT (setChecked (bool)));
+                   action, SLOT (setChecked (bool)));
         }
       else
         {
           // action for focus of dock widget
           connect (action, SIGNAL (triggered ()), widget, SLOT (focus ()));
         }
     }
 
@@ -2054,17 +2054,17 @@ main_window::execute_command_callback ()
 
   if (! _cmd_queue.isEmpty ())  // list can not be empty here, just to make sure
     {
       _cmd_queue_mutex.lock (); // critical path
 
       octave_cmd *cmd = _cmd_queue.takeFirst ();
 
       if (_cmd_queue.isEmpty ())
-          _cmd_processing.release ();  // cmd queue empty, processing will stop
+        _cmd_processing.release ();  // cmd queue empty, processing will stop
       else
         repost = true;          // not empty, repost at end
       _cmd_queue_mutex.unlock ();
 
       cmd->execute ();
 
       delete cmd;
     }
@@ -2184,25 +2184,27 @@ main_window::find_files_finished (int)
 
 }
 
 void
 main_window::set_global_edit_shortcuts (bool editor_has_focus)
 {
   // this slot is called when editor gets/loses focus
   if (editor_has_focus)
-    { // disable shortcuts that are also provided by the editor itself
+    {
+      // disable shortcuts that are also provided by the editor itself
       QKeySequence no_key = QKeySequence ();
       _copy_action->setShortcut (no_key);
       _paste_action->setShortcut (no_key);
       _undo_action->setShortcut (no_key);
       _select_all_action->setShortcut (no_key);
     }
   else
-    { // editor loses focus, set the global shortcuts
+    {
+      // editor loses focus, set the global shortcuts
       shortcut_manager::set_shortcut (_copy_action, "main_edit:copy");
       shortcut_manager::set_shortcut (_paste_action, "main_edit:paste");
       shortcut_manager::set_shortcut (_undo_action, "main_edit:undo");
       shortcut_manager::set_shortcut (_select_all_action, "main_edit:select_all");
     }
 
   // dis-/enable global menu depending on editor's focus
   enable_menu_shortcuts (! editor_has_focus);
@@ -2211,84 +2213,100 @@ main_window::set_global_edit_shortcuts (
 void
 main_window::configure_shortcuts ()
 {
   // file menu
   shortcut_manager::set_shortcut (_open_action, "main_file:open_file");
   shortcut_manager::set_shortcut (_new_script_action, "main_file:new_file");
   shortcut_manager::set_shortcut (_new_function_action, "main_file:new_function");
   shortcut_manager::set_shortcut (_new_function_action, "main_file:new_figure");
-  shortcut_manager::set_shortcut (_load_workspace_action, "main_file:load_workspace");
-  shortcut_manager::set_shortcut (_save_workspace_action, "main_file:save_workspace");
+  shortcut_manager::set_shortcut (_load_workspace_action,
+                                  "main_file:load_workspace");
+  shortcut_manager::set_shortcut (_save_workspace_action,
+                                  "main_file:save_workspace");
   shortcut_manager::set_shortcut (_preferences_action, "main_file:preferences");
   shortcut_manager::set_shortcut (_exit_action,"main_file:exit");
 
   // edit menu
   shortcut_manager::set_shortcut (_copy_action, "main_edit:copy");
   shortcut_manager::set_shortcut (_paste_action, "main_edit:paste");
   shortcut_manager::set_shortcut (_undo_action, "main_edit:undo");
   shortcut_manager::set_shortcut (_select_all_action, "main_edit:select_all");
-  shortcut_manager::set_shortcut (_clear_clipboard_action, "main_edit:clear_clipboard");
+  shortcut_manager::set_shortcut (_clear_clipboard_action,
+                                  "main_edit:clear_clipboard");
   shortcut_manager::set_shortcut (_find_files_action, "main_edit:find_in_files");
-  shortcut_manager::set_shortcut (_clear_command_history_action, "main_edit:clear_history");
-  shortcut_manager::set_shortcut (_clear_command_window_action, "main_edit:clear_command_window");
-  shortcut_manager::set_shortcut (_clear_workspace_action, "main_edit:clear_workspace");
+  shortcut_manager::set_shortcut (_clear_command_history_action,
+                                  "main_edit:clear_history");
+  shortcut_manager::set_shortcut (_clear_command_window_action,
+                                  "main_edit:clear_command_window");
+  shortcut_manager::set_shortcut (_clear_workspace_action,
+                                  "main_edit:clear_workspace");
 
   // debug menu
   shortcut_manager::set_shortcut (_debug_step_over, "main_debug:step_over");
   shortcut_manager::set_shortcut (_debug_step_into, "main_debug:step_into");
   shortcut_manager::set_shortcut (_debug_step_out,  "main_debug:step_out");
   shortcut_manager::set_shortcut (_debug_continue,  "main_debug:continue");
   shortcut_manager::set_shortcut (_debug_quit,  "main_debug:quit");
 
   // window menu
-  shortcut_manager::set_shortcut (_show_command_window_action, "main_window:show_command");
-  shortcut_manager::set_shortcut (_show_history_action, "main_window:show_history");
-  shortcut_manager::set_shortcut (_show_workspace_action,  "main_window:show_workspace");
-  shortcut_manager::set_shortcut (_show_file_browser_action,  "main_window:show_file_browser");
+  shortcut_manager::set_shortcut (_show_command_window_action,
+                                  "main_window:show_command");
+  shortcut_manager::set_shortcut (_show_history_action,
+                                  "main_window:show_history");
+  shortcut_manager::set_shortcut (_show_workspace_action,
+                                  "main_window:show_workspace");
+  shortcut_manager::set_shortcut (_show_file_browser_action,
+                                  "main_window:show_file_browser");
   shortcut_manager::set_shortcut (_show_editor_action, "main_window:show_editor");
-  shortcut_manager::set_shortcut (_show_documentation_action, "main_window:show_doc");
+  shortcut_manager::set_shortcut (_show_documentation_action,
+                                  "main_window:show_doc");
   shortcut_manager::set_shortcut (_command_window_action, "main_window:command");
   shortcut_manager::set_shortcut (_history_action, "main_window:history");
   shortcut_manager::set_shortcut (_workspace_action,  "main_window:workspace");
-  shortcut_manager::set_shortcut (_file_browser_action,  "main_window:file_browser");
+  shortcut_manager::set_shortcut (_file_browser_action,
+                                  "main_window:file_browser");
   shortcut_manager::set_shortcut (_editor_action, "main_window:editor");
   shortcut_manager::set_shortcut (_documentation_action, "main_window:doc");
   shortcut_manager::set_shortcut (_reset_windows_action, "main_window:reset");
 
   // help menu
   shortcut_manager::set_shortcut (_ondisk_doc_action, "main_help:ondisk_doc");
   shortcut_manager::set_shortcut (_online_doc_action, "main_help:online_doc");
   shortcut_manager::set_shortcut (_report_bug_action, "main_help:report_bug");
   shortcut_manager::set_shortcut (_octave_packages_action, "main_help:packages");
   shortcut_manager::set_shortcut (_agora_action, "main_help:agora");
   shortcut_manager::set_shortcut (_contribute_action, "main_help:contribute");
   shortcut_manager::set_shortcut (_developer_action, "main_help:developer");
   shortcut_manager::set_shortcut (_about_octave_action, "main_help:about");
 
   // news menu
-  shortcut_manager::set_shortcut (_release_notes_action, "main_news:release_notes");
-  shortcut_manager::set_shortcut (_current_news_action, "main_news:community_news");
+  shortcut_manager::set_shortcut (_release_notes_action,
+                                  "main_news:release_notes");
+  shortcut_manager::set_shortcut (_current_news_action,
+                                  "main_news:community_news");
 }
 
 void
 main_window::set_global_shortcuts (bool set_shortcuts)
 {
   // this slot is called when the terminal gets/loses focus
 
   // return if the user don't want to use readline shortcuts
   if (! _prevent_readline_conflicts)
     return;
 
   if (set_shortcuts)
-    { // terminal loses focus: set the global shortcuts
+    {
+      // terminal loses focus: set the global shortcuts
       configure_shortcuts ();
     }
   else
-    { // terminal gets focus: disable some shortcuts
+    {
+      // terminal gets focus: disable some shortcuts
       QKeySequence no_key = QKeySequence ();
 
       // file menu
       _open_action->setShortcut (no_key);
       _new_script_action->setShortcut (no_key);
       _new_function_action->setShortcut (no_key);
       _new_function_action->setShortcut (no_key);
       _load_workspace_action->setShortcut (no_key);
diff --git a/libgui/src/octave-cmd.cc b/libgui/src/octave-cmd.cc
--- a/libgui/src/octave-cmd.cc
+++ b/libgui/src/octave-cmd.cc
@@ -57,23 +57,25 @@ octave_cmd_eval::execute ()
 {
   QString function_name = _info.fileName ();
   function_name.chop (_info.suffix ().length () + 1);
   std::string file_path = _info.absoluteFilePath ().toStdString ();
 
   std::string pending_input = command_editor::get_current_line ();
 
   if (valid_identifier (function_name.toStdString ()))
-    { // valid identifier: call as function with possibility to debug
+    {
+      // valid identifier: call as function with possibility to debug
       std::string path = _info.absolutePath ().toStdString ();
       if (octave_qt_link::file_in_path (file_path, path))
-          Feval (ovl (function_name.toStdString ()));
+        Feval (ovl (function_name.toStdString ()));
     }
   else
-    { // no valid identifier: use Fsource (), no debug possible
+    {
+      // no valid identifier: use Fsource (), no debug possible
       Fsource (ovl (file_path));
     }
 
   command_editor::replace_line ("");
   command_editor::set_initial_input (pending_input);
   command_editor::redisplay ();
 
   command_editor::interrupt ();
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -312,20 +312,20 @@ octave_dock_widget::set_style (bool acti
       else
         {
           bg_col = _bg_color;
           fg_col = _fg_color;
           icon_col = _icon_color;
         }
 
       QString background =
-          QString ("background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,"
-                   "            stop: 0 %1, stop: 0.75 %2, stop: 0.9 %2, stop: 1.0 %1);").
-                   arg (bg_col.lighter ().name ()).
-                   arg (bg_col.name ());
+        QString ("background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,"
+                 "            stop: 0 %1, stop: 0.75 %2, stop: 0.9 %2, stop: 1.0 %1);").
+        arg (bg_col.lighter ().name ()).
+        arg (bg_col.name ());
 
 #if defined (Q_OS_WIN32)
       css = background + QString (" color: %1 ;").arg (fg_col.name ());
 #else
       css = QString ("QDockWidget::title { " + background +
                      "                     text-align: center left;"
                      "                     padding: 0px 0px 0px 4px;}\n"
                      "QDockWidget { color: %1 ; "
@@ -354,53 +354,55 @@ octave_dock_widget::set_style (bool acti
 #endif
     }
 
 #if defined (Q_OS_WIN32)
   _title_widget->setStyleSheet (css);
   css_button = QString ("background: transparent; border: 0px;");
   _dock_button->setStyleSheet (css_button);
   _close_button->setStyleSheet (css_button);
-  _dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col + ".png"));
-  _close_action->setIcon (QIcon (":/actions/icons/widget-close" + dock_icon + icon_col + ".png"));
+  _dock_action->setIcon (QIcon (":/actions/icons/" + dock_icon + icon_col +
+                                ".png"));
+  _close_action->setIcon (QIcon (":/actions/icons/widget-close" + dock_icon +
+                                 icon_col + ".png"));
 #else
   setStyleSheet (css);
 #endif
 }
 
 void
 octave_dock_widget::handle_settings (const QSettings *settings)
 {
   _custom_style =
     settings->value ("DockWidgets/widget_title_custom_style",false).toBool ();
 
   QColor default_var = QColor (0,0,0);
   _fg_color = settings->value ("Dockwidgets/title_fg_color",
-                                default_var).value<QColor> ();
+                               default_var).value<QColor> ();
   default_var = QColor (0,0,0);
   _fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
-                                default_var).value<QColor> ();
+                                      default_var).value<QColor> ();
 
   default_var = QColor (255,255,255);
   _bg_color = settings->value ("Dockwidgets/title_bg_color",
-                                default_var).value<QColor> ();
+                               default_var).value<QColor> ();
   default_var = QColor (192,192,192);
   _bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
-                                       default_var).value<QColor> ();
+                                      default_var).value<QColor> ();
 
   int r, g, b;
   _bg_color.getRgb (&r, &g, &b);
   if (r+g+b < 400)
-      _icon_color = "-light";
+    _icon_color = "-light";
   else
     _icon_color = "";
 
   _bg_color_active.getRgb (&r, &g, &b);
   if (r+g+b < 400)
-      _icon_color_active = "-light";
+    _icon_color_active = "-light";
   else
     _icon_color_active = "";
 
   notice_settings (settings);  // call individual handler
 
   set_style (false);
 }
 
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -115,33 +115,35 @@ octave_start_gui (int argc, char *argv[]
       // Set the codec for all strings (before wizard)
 #if not defined (Q_OS_WIN32)
       QTextCodec::setCodecForCStrings (QTextCodec::codecForName ("UTF-8"));
 #endif
 
       // show wizard if this is the first run
       if (resource_manager::is_first_run ())
         {
-          resource_manager::config_translators (&qt_tr, &qsci_tr, &gui_tr); // before wizard
+          // before wizard
+          resource_manager::config_translators (&qt_tr, &qsci_tr, &gui_tr);
           application.installTranslator (&qt_tr);
           application.installTranslator (&qsci_tr);
           application.installTranslator (&gui_tr);
 
           welcome_wizard welcomeWizard;
 
           if (welcomeWizard.exec () == QDialog::Rejected)
             exit (1);
 
           resource_manager::reload_settings ();  // install settings file
         }
       else
         {
           resource_manager::reload_settings ();  // get settings file
 
-          resource_manager::config_translators (&qt_tr, &qsci_tr, &gui_tr); // after settings
+          // after settings
+          resource_manager::config_translators (&qt_tr, &qsci_tr, &gui_tr);
           application.installTranslator (&qt_tr);
           application.installTranslator (&qsci_tr);
           application.installTranslator (&gui_tr);
         }
 
       // update network-settings
       resource_manager::update_network_settings ();
 
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -227,20 +227,21 @@ resource_manager::do_set_settings (const
   delete settings;
   settings = new QSettings (file, QSettings::IniFormat);
 
   if (! (settings
          && QFile::exists (settings->fileName ())
          && settings->isWritable ()
          && settings->status () ==  QSettings::NoError))
     {
-      QString msg = QString (QT_TR_NOOP ("The settings file\n%1\n"
-              "does not exist and can not be created.\n"
-              "Make sure you have read and write permissions to\n%2\n\n"
-              "Octave GUI must be closed now."));
+      QString msg = QString (QT_TR_NOOP (
+        "The settings file\n%1\n"
+        "does not exist and can not be created.\n"
+        "Make sure you have read and write permissions to\n%2\n\n"
+        "Octave GUI must be closed now."));
       QMessageBox::critical (0, QString (QT_TR_NOOP ("Octave Critical Error")),
           msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
       exit (1);
     }
 }
 
 bool
 resource_manager::do_is_first_run (void) const
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -105,17 +105,17 @@ settings_dialog::settings_dialog (QWidge
   ui->general_icon_octave-> setChecked (true);  // the default (if invalid set)
   ui->general_icon_octave-> setChecked (widget_icon_set == "NONE");
   ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
   ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
 
   // custom title bar of dock widget
   QVariant default_var = QColor (255,255,255);
   QColor bg_color = settings->value ("Dockwidgets/title_bg_color",
-                                      default_var).value<QColor> ();
+                                     default_var).value<QColor> ();
   _widget_title_bg_color = new color_picker (bg_color);
   _widget_title_bg_color->setEnabled (false);
   ui->layout_widget_bgtitle->addWidget (_widget_title_bg_color,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_bg_color, SLOT (setEnabled (bool)));
 
   default_var = QColor (192,192,192);
   QColor bg_color_active = settings->value ("Dockwidgets/title_bg_color_active",
@@ -123,17 +123,17 @@ settings_dialog::settings_dialog (QWidge
   _widget_title_bg_color_active = new color_picker (bg_color_active);
   _widget_title_bg_color_active->setEnabled (false);
   ui->layout_widget_bgtitle_active->addWidget (_widget_title_bg_color_active,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_bg_color_active, SLOT (setEnabled (bool)));
 
   default_var = QColor (0,0,0);
   QColor fg_color = settings->value ("Dockwidgets/title_fg_color",
-                                      default_var).value<QColor> ();
+                                     default_var).value<QColor> ();
   _widget_title_fg_color = new color_picker (fg_color);
   _widget_title_fg_color->setEnabled (false);
   ui->layout_widget_fgtitle->addWidget (_widget_title_fg_color,0);
   connect (ui->cb_widget_custom_style, SIGNAL (toggled (bool)),
            _widget_title_fg_color, SLOT (setEnabled (bool)));
 
   default_var = QColor (0,0,0);
   QColor fg_color_active = settings->value ("Dockwidgets/title_fg_color_active",
@@ -152,19 +152,19 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("prompt_to_exit",false).toBool ());
 
   // Main status bar
   ui->cb_status_bar->setChecked (
     settings->value ("show_status_bar",true).toBool ());
 
   // Octave startup
   ui->cb_restore_octave_dir->setChecked (
-                 settings->value ("restore_octave_dir",false).toBool ());
+    settings->value ("restore_octave_dir",false).toBool ());
   ui->le_octave_dir->setText (
-                 settings->value ("octave_startup_dir").toString ());
+    settings->value ("octave_startup_dir").toString ());
   connect (ui->pb_octave_dir, SIGNAL (pressed ()),
            this, SLOT (get_octave_dir ()));
 
   // editor
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",
                                                         false).toBool ());
   ui->customFileEditor->setText (
     settings->value ("customFileEditor").toString ());
@@ -257,21 +257,21 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("editor/restoreSession", true).toBool ());
   ui->editor_create_new_file->setChecked (
     settings->value ("editor/create_new_file",false).toBool ());
   ui->editor_reload_changed_files->setChecked (
     settings->value ("editor/always_reload_changed_files",false).toBool ());
 
   // terminal
   ui->terminal_fontName->setCurrentFont (QFont (
-    settings->value ("terminal/fontName","Courier New").toString ()));
+      settings->value ("terminal/fontName","Courier New").toString ()));
   ui->terminal_fontSize->setValue (
     settings->value ("terminal/fontSize", 10).toInt ());
   ui->terminal_history_buffer->setValue (
-     settings->value ("terminal/history_buffer",1000).toInt ());
+    settings->value ("terminal/history_buffer",1000).toInt ());
   ui->terminal_cursorBlinking->setChecked (
     settings->value ("terminal/cursorBlinking",true).toBool ());
   ui->terminal_cursorUseForegroundColor->setChecked (
     settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
   ui->terminal_focus_command->setChecked (
     settings->value ("terminal/focus_after_command",false).toBool ());
   ui->terminal_print_dbg_location->setChecked (
     settings->value ("terminal/print_debug_location",false).toBool ());
@@ -304,32 +304,32 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("filesdockwidget/showHiddenFiles",false).toBool ());
   ui->useAlternatingRowColors->setChecked (
     settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool ());
   connect (ui->sync_octave_directory, SIGNAL (toggled (bool)),
            this, SLOT (set_disabled_pref_file_browser_dir (bool)));
   ui->sync_octave_directory->setChecked (
     settings->value ("filesdockwidget/sync_octave_directory",true).toBool ());
   ui->cb_restore_file_browser_dir->setChecked (
-                 settings->value ("filesdockwidget/restore_last_dir",false).toBool ());
+    settings->value ("filesdockwidget/restore_last_dir",false).toBool ());
   ui->le_file_browser_dir->setText (
-                 settings->value ("filesdockwidget/startup_dir").toString ());
+    settings->value ("filesdockwidget/startup_dir").toString ());
   connect (ui->pb_file_browser_dir, SIGNAL (pressed ()),
            this, SLOT (get_file_browser_dir ()));
 
   ui->checkbox_allow_web_connect->setChecked (
     settings->value ("news/allow_web_connection",false).toBool ());
   ui->useProxyServer->setChecked (
     settings->value ("useProxyServer", false).toBool ());
   ui->proxyHostName->setText (settings->value ("proxyHostName").toString ());
 
   int currentIndex = 0;
   QString proxyTypeString = settings->value ("proxyType").toString ();
   while ((currentIndex < ui->proxyType->count ())
-          && (ui->proxyType->currentText () != proxyTypeString))
+         && (ui->proxyType->currentText () != proxyTypeString))
     {
       currentIndex++;
       ui->proxyType->setCurrentIndex (currentIndex);
     }
 
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
   ui->proxyPassword->setText (settings->value ("proxyPassword").toString ());
@@ -1013,18 +1013,20 @@ settings_dialog::get_file_browser_dir ()
 
 void
 settings_dialog::set_disabled_pref_file_browser_dir (bool disable)
 {
   ui->cb_restore_file_browser_dir->setDisabled (disable);
 
   if (! disable)
     {
-      ui->le_file_browser_dir->setDisabled (ui->cb_restore_file_browser_dir->isChecked ());
-      ui->pb_file_browser_dir->setDisabled (ui->cb_restore_file_browser_dir->isChecked ());
+      ui->le_file_browser_dir->setDisabled (
+        ui->cb_restore_file_browser_dir->isChecked ());
+      ui->pb_file_browser_dir->setDisabled (
+        ui->cb_restore_file_browser_dir->isChecked ());
     }
   else
     {
       ui->le_file_browser_dir->setDisabled (disable);
       ui->pb_file_browser_dir->setDisabled (disable);
     }
 }
 
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -165,23 +165,26 @@ shortcut_manager::do_init_data ()
         prefix + ctrl + Qt::Key_3);
   init (tr ("Editor"), "main_window:editor",
         prefix + ctrl + Qt::Key_4);
   init (tr ("Documentation"), "main_window:doc",
         prefix + ctrl + Qt::Key_5);
   init (tr ("Reset Window Layout"), "main_window:reset", QKeySequence ());
 
   // help
-  init (tr ("Show Ondisk Documentation"), "main_help:ondisk_doc", QKeySequence ());
-  init (tr ("Show Online Documentation"), "main_help:online_doc", QKeySequence ());
+  init (tr ("Show Ondisk Documentation"), "main_help:ondisk_doc",
+        QKeySequence ());
+  init (tr ("Show Online Documentation"), "main_help:online_doc",
+        QKeySequence ());
   init (tr ("Report a Bug"), "main_help:report_bug", QKeySequence ());
   init (tr ("Octave Packages"), "main_help:packages", QKeySequence ());
   init (tr ("Share Code"), "main_help:agora", QKeySequence ());
   init (tr ("Contribute to Octave"), "main_help:contribute", QKeySequence ());
-  init (tr ("Octave Developer Resources"), "main_help:developer", QKeySequence ());
+  init (tr ("Octave Developer Resources"), "main_help:developer",
+        QKeySequence ());
   init (tr ("About Octave"), "main_help:about", QKeySequence ());
 
   // news
   init (tr ("Release Notes"), "main_news:release_notes", QKeySequence ());
   init (tr ("Community News"), "main_news:community_news", QKeySequence ());
 
   // actions of the editor
 
@@ -268,21 +271,25 @@ shortcut_manager::do_init_data ()
   init (tr ("Remove All Bookmark"), "editor_edit:remove_bookmark",
         QKeySequence ());
 
   init (tr ("Preferences"), "editor_edit:preferences", QKeySequence ());
   init (tr ("Styles Preferences"), "editor_edit:styles_preferences",
         QKeySequence ());
 
   // view
-  init (tr ("Show Line Numbers"), "editor_view:show_line_numbers", QKeySequence ());
-  init (tr ("Show White Spaces"), "editor_view:show_white_spaces", QKeySequence ());
+  init (tr ("Show Line Numbers"), "editor_view:show_line_numbers",
+        QKeySequence ());
+  init (tr ("Show White Spaces"), "editor_view:show_white_spaces",
+        QKeySequence ());
   init (tr ("Show Line Endings"), "editor_view:show_eol_chars", QKeySequence ());
-  init (tr ("Show Indentation Guides"), "editor_view:show_ind_guides", QKeySequence ());
-  init (tr ("Show Long Line Marker"), "editor_view:show_long_line", QKeySequence ());
+  init (tr ("Show Indentation Guides"), "editor_view:show_ind_guides",
+        QKeySequence ());
+  init (tr ("Show Long Line Marker"), "editor_view:show_long_line",
+        QKeySequence ());
   init (tr ("Zoom In"), "editor_view:zoom_in", QKeySequence::ZoomIn);
   init (tr ("Zoom Out"), "editor_view:zoom_out", QKeySequence::ZoomOut);
 #if defined (Q_OS_MAC)
   init (tr ("Zoom Normal"), "editor_view:zoom_normal",
         QKeySequence (ctrl + Qt::Key_Underscore));
 #else
   init (tr ("Zoom Normal"), "editor_view:zoom_normal",
         QKeySequence (ctrl_alt + Qt::Key_0));
@@ -300,42 +307,48 @@ shortcut_manager::do_init_data ()
 
   // run
   init (tr ("Run File"), "editor_run:run_file",
         QKeySequence (prefix + Qt::Key_F5) );
   init (tr ("Run Selection"), "editor_run:run_selection",
         QKeySequence (prefix + Qt::Key_F9) );
 
   // help
-  init (tr ("Help on Keyword"), "editor_help:help_keyword", QKeySequence::HelpContents);
-  init (tr ("Document on Keyword"), "editor_help:doc_keyword", QKeySequence (Qt::SHIFT + Qt::Key_F1));
+  init (tr ("Help on Keyword"), "editor_help:help_keyword",
+        QKeySequence::HelpContents);
+  init (tr ("Document on Keyword"), "editor_help:doc_keyword",
+        QKeySequence (Qt::SHIFT + Qt::Key_F1));
 }
 
 void
 shortcut_manager::init (QString description, QString key, QKeySequence def_sc)
 {
-  QKeySequence actual_0 = QKeySequence (_settings->value ("shortcuts/"+key, def_sc).toString ());
-  QKeySequence actual_1 = QKeySequence (_settings->value ("shortcuts/"+key+"_1", def_sc).toString ());
+  QKeySequence actual_0
+    = QKeySequence (_settings->value ("shortcuts/"+key, def_sc).toString ());
+  QKeySequence actual_1
+    = QKeySequence (_settings->value ("shortcuts/"+key+"_1", def_sc).toString ());
 
   // append the new shortcut to the list
   shortcut_t shortcut_info;
   shortcut_info.description = description;
   shortcut_info.settings_key = key;
   shortcut_info.actual_sc [0] = actual_0;
   shortcut_info.actual_sc [1] = actual_1;
   shortcut_info.default_sc [0] = def_sc;
   shortcut_info.default_sc [1] = def_sc;  // TODO: Different defaults
   _sc << shortcut_info;
 
   // insert shortcut prepended by widget in order check for duplicates later
   QString widget = key.section ('_',0,0);  // get widget that uses the shortcut
   if (! actual_0.isEmpty ())
-    _shortcut_hash[widget + ":" + actual_0.toString ()] = _sc.count ();  // offset of 1 to avoid 0
+    _shortcut_hash[widget + ":" + actual_0.toString ()] =
+      _sc.count ();  // offset of 1 to avoid 0
   if (! actual_1.isEmpty ())
-    _shortcut_hash[widget + "_1:" + actual_1.toString ()] = _sc.count ();  // offset of 1 to avoid 0
+    _shortcut_hash[widget + "_1:" + actual_1.toString ()] =
+      _sc.count ();  // offset of 1 to avoid 0
   _action_hash[key] = _sc.count ();  // offset of 1 to avoid 0
 }
 
 void
 shortcut_manager::do_fill_treewidget (QTreeWidget *tree_view)
 {
   _dialog = 0;
   _level_hash.clear ();
@@ -414,17 +427,18 @@ shortcut_manager::do_fill_treewidget (QT
       _item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
       _index_item_hash[i] = tree_item;
     }
 
 }
 
 // write one or all actual shortcut set(s) into a settings file
 void
-shortcut_manager::do_write_shortcuts (int set, QSettings* settings, bool closing)
+shortcut_manager::do_write_shortcuts (int set, QSettings* settings,
+                                      bool closing)
 {
   if (set)
     {
       // set is not zero, only write the desired set (index = set-1)
       // into the settings file that the user has selected for this export
       for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
         {
           settings->setValue("shortcuts/"+_sc.at (i).settings_key,
@@ -435,17 +449,17 @@ shortcut_manager::do_write_shortcuts (in
     {
       // set is zero, write all sets into the normal octave settings file
       // (this is only the case when called from the closing settings dialog)
       for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
         {
           settings->setValue("shortcuts/"+_sc.at (i).settings_key,
                              _sc.at (i).actual_sc[0].toString ());
           settings->setValue("shortcuts/"+_sc.at (i).settings_key+"_1",
-                            _sc.at (i).actual_sc[1].toString ());
+                             _sc.at (i).actual_sc[1].toString ());
         }
 
       if (closing)
         {
           delete _dialog;  // the dialog for key sequences can be removed now
           _dialog = 0;     // make sure it is zero again
         }
     }
@@ -472,23 +486,23 @@ shortcut_manager::do_set_shortcut (QActi
     qDebug () << "Key: " << key_set << " not found in _action_hash";
 }
 
 void
 shortcut_manager::handle_double_clicked (QTreeWidgetItem* item, int col)
 {
   switch (col)
     {
-      case 2:
-      case 4:
-        _selected_set = col/2 - 1;
-        break;
+    case 2:
+    case 4:
+      _selected_set = col/2 - 1;
+      break;
 
-      default:
-        return;
+    default:
+      return;
     }
 
   int i = _item_index_hash[item];
   if (i == 0)
     return;  // top-level-item clicked
 
   shortcut_dialog (i-1); // correct to index starting at 0
 }
@@ -506,17 +520,18 @@ shortcut_manager::shortcut_dialog (int i
       QVBoxLayout *box = new QVBoxLayout(_dialog);
 
       QLabel *help = new QLabel (tr ("Apply the desired shortcut or click "
                                      "on the right button to reset the "
                                      "shortcut to its default."));
       help->setWordWrap (true);
       box->addWidget (help);
 
-      QCheckBox *direct = new QCheckBox (tr ("Enter shortcut directly by performing it"));
+      QCheckBox *direct = new QCheckBox (
+        tr ("Enter shortcut directly by performing it"));
       direct->setCheckState (Qt::Checked);
       box->addWidget (direct);
 
       QGridLayout *grid = new QGridLayout();
 
       QLabel *actual = new QLabel (tr ("Actual shortcut"));
       _edit_actual = new enter_shortcut (_dialog);
       _edit_actual->setAlignment (Qt::AlignHCenter);
@@ -599,26 +614,27 @@ shortcut_manager::shortcut_dialog_finish
           _index_item_hash[double_index]->setText ((_selected_set + 1)*2, QKeySequence ());
         }
       else
         return;
     }
 
   shortcut_t shortcut = _sc.at (_handled_index);
   if (! shortcut.actual_sc[_selected_set].isEmpty ())
-    _shortcut_hash.remove (widget + sep + shortcut.actual_sc[_selected_set].toString ());
+    _shortcut_hash.remove (widget + sep +
+                           shortcut.actual_sc[_selected_set].toString ());
   shortcut.actual_sc[_selected_set] = _edit_actual->text();
   _sc.replace (_handled_index, shortcut);
 
   _index_item_hash[_handled_index]->setText ((_selected_set + 1)*2,
                                              shortcut.actual_sc[_selected_set]);
 
   if (! shortcut.actual_sc[_selected_set].isEmpty ())
     _shortcut_hash[widget + sep + shortcut.actual_sc[_selected_set].toString ()] =
-        _handled_index + 1;
+      _handled_index + 1;
 }
 
 void
 shortcut_manager::shortcut_dialog_set_default ()
 {
   _edit_actual->setText (_label_default->text ());
 }
 
@@ -714,20 +730,20 @@ enter_shortcut::keyPressEvent (QKeyEvent
     {
       int key = e->key ();
 
       if (key == Qt::Key_unknown || key == 0)
         return;
 
       Qt::KeyboardModifiers modifiers = e->modifiers ();
 
-      if(modifiers & Qt::ShiftModifier)
+      if (modifiers & Qt::ShiftModifier)
         key += Qt::SHIFT;
-      if(modifiers & Qt::ControlModifier)
+      if (modifiers & Qt::ControlModifier)
         key += Qt::CTRL;
-      if(modifiers & Qt::AltModifier)
+      if (modifiers & Qt::AltModifier)
         key += Qt::ALT;
-      if(modifiers & Qt::MetaModifier)
+      if (modifiers & Qt::MetaModifier)
         key += Qt::META;
 
       setText (QKeySequence(key));
     }
 }
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -40,234 +40,234 @@ make_octave_logo (QWidget *p = 0, int he
   QPixmap logo_pixmap (":/actions/icons/logo.png");
   logo->setPixmap (logo_pixmap.scaledToHeight (height));
   return logo;
 };
 
 
 
 initial_page::initial_page (welcome_wizard *wizard)
-    : QWidget (wizard),
-      title (new QLabel (tr ("Welcome to Octave!"), this)),
-      message (new QLabel (this)),
-      logo (make_octave_logo (this)),
-      next (new QPushButton (tr ("Next"), this)),
-      cancel (new QPushButton (tr ("Cancel"), this))
-  {
-    QFont ft;
-    ft.setPointSize (20);
-    title->setFont (ft);
+  : QWidget (wizard),
+    title (new QLabel (tr ("Welcome to Octave!"), this)),
+    message (new QLabel (this)),
+    logo (make_octave_logo (this)),
+    next (new QPushButton (tr ("Next"), this)),
+    cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  title->setFont (ft);
 
-    message->setText
-      (tr ("<html><body>\n"
-           "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
-           "Click 'Next' to create a configuration file and launch Octave.</p>\n"
-           "<p>The configuration file is stored in<br>%1.</p>\n"
-           "</body></html>").
-           arg (resource_manager::get_settings_file ()));
-    message->setWordWrap (true);
-    message->setMinimumWidth (400);
+  message->setText
+  (tr ("<html><body>\n"
+       "<p>You seem to be using the Octave graphical interface for the first time on this computer.\n"
+       "Click 'Next' to create a configuration file and launch Octave.</p>\n"
+       "<p>The configuration file is stored in<br>%1.</p>\n"
+       "</body></html>").
+   arg (resource_manager::get_settings_file ()));
+  message->setWordWrap (true);
+  message->setMinimumWidth (400);
 
-    QVBoxLayout *message_layout = new QVBoxLayout;
+  QVBoxLayout *message_layout = new QVBoxLayout;
 
-    message_layout->addWidget (title);
-    message_layout->addWidget (message);
+  message_layout->addWidget (title);
+  message_layout->addWidget (message);
 
-    QHBoxLayout *message_and_logo = new QHBoxLayout;
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-    message_and_logo->addLayout (message_layout);
-    message_and_logo->addStretch (10);
-    message_and_logo->addWidget (logo, 0, Qt::AlignTop);
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
 
-    QHBoxLayout *button_bar = new QHBoxLayout;
+  QHBoxLayout *button_bar = new QHBoxLayout;
 
-    button_bar->addStretch (10);
-    button_bar->addWidget (next);
-    button_bar->addWidget (cancel);
+  button_bar->addStretch (10);
+  button_bar->addWidget (next);
+  button_bar->addWidget (cancel);
 
-    QVBoxLayout *page_layout = new QVBoxLayout (this);
-    setLayout (page_layout);
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
 
-    page_layout->addLayout (message_and_logo);
-    page_layout->addStretch (10);
-    page_layout->addLayout (button_bar);
+  page_layout->addLayout (message_and_logo);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
 
-    next->setDefault (true);
-    next->setFocus ();
+  next->setDefault (true);
+  next->setFocus ();
 
-    connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-    connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-  }
+  connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
 
 
 
 setup_community_news::setup_community_news (welcome_wizard *wizard)
-    : QWidget (wizard),
-      title (new QLabel (tr ("Community News"), this)),
-      message (new QLabel (this)),
-      checkbox (new QCheckBox (this)),
-      checkbox_message (new QLabel (this)),
-      logo (make_octave_logo (this)),
-      previous (new QPushButton (tr ("Previous"), this)),
-      next (new QPushButton (tr ("Next"), this)),
-      cancel (new QPushButton (tr ("Cancel"), this))
-  {
-    QFont ft;
-    ft.setPointSize (20);
-    title->setFont (ft);
+  : QWidget (wizard),
+    title (new QLabel (tr ("Community News"), this)),
+    message (new QLabel (this)),
+    checkbox (new QCheckBox (this)),
+    checkbox_message (new QLabel (this)),
+    logo (make_octave_logo (this)),
+    previous (new QPushButton (tr ("Previous"), this)),
+    next (new QPushButton (tr ("Next"), this)),
+    cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  title->setFont (ft);
 
-    message->setText
-      (tr ("<html><body>\n"
-           "<p>When the Octave GUI starts, it will check the Octave web site for current news and information about the Octave community.\n"
-           "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
-           "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu in the GUI, or by visiting\n"
-           "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
-           "</body></html>"));
-    message->setWordWrap (true);
-    message->setMinimumWidth (400);
-    message->setOpenExternalLinks (true);
+  message->setText
+  (tr ("<html><body>\n"
+       "<p>When the Octave GUI starts, it will check the Octave web site for current news and information about the Octave community.\n"
+       "The check will happen at most once each day and news will only be displayed if there is something new since the last time you viewed the news.</p>\n"
+       "<p>You may also view the news by selecting the \"Community News\" item in the \"Help\" menu in the GUI, or by visiting\n"
+       "<a href=\"http://octave.org/community-news.html\">http://octave.org/community-news.html</a>.</p>\n"
+       "</body></html>"));
+  message->setWordWrap (true);
+  message->setMinimumWidth (400);
+  message->setOpenExternalLinks (true);
 
-    QVBoxLayout *message_layout = new QVBoxLayout;
+  QVBoxLayout *message_layout = new QVBoxLayout;
 
-    message_layout->addWidget (title);
-    message_layout->addWidget (message);
+  message_layout->addWidget (title);
+  message_layout->addWidget (message);
 
-    QHBoxLayout *message_and_logo = new QHBoxLayout;
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-    message_and_logo->addLayout (message_layout);
-    message_and_logo->addStretch (10);
-    message_and_logo->addWidget (logo, 0, Qt::AlignTop);
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
 
-    QHBoxLayout *checkbox_layout = new QHBoxLayout;
+  QHBoxLayout *checkbox_layout = new QHBoxLayout;
 
-    checkbox->setCheckState (Qt::Checked);
+  checkbox->setCheckState (Qt::Checked);
 
-    checkbox_message->setText
-      (tr ("<html><head>\n"
-           "<style>\n"
-           "a:link { text-decoration: underline; color: #0000ff; }\n"
-           "</style>\n"
-           "<head/><body>\n"
-           "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
-           "</body></html>"));
-    checkbox_message->setWordWrap (true);
-    checkbox_message->setOpenExternalLinks (true);
-    checkbox_message->setMinimumWidth (500);
+  checkbox_message->setText
+  (tr ("<html><head>\n"
+       "<style>\n"
+       "a:link { text-decoration: underline; color: #0000ff; }\n"
+       "</style>\n"
+       "<head/><body>\n"
+       "<p>Allow Octave to connect to the Octave web site when it starts to display current news and information about the Octave community.</p>\n"
+       "</body></html>"));
+  checkbox_message->setWordWrap (true);
+  checkbox_message->setOpenExternalLinks (true);
+  checkbox_message->setMinimumWidth (500);
 
-    checkbox_layout->addWidget (checkbox, 0, Qt::AlignTop);
-    checkbox_layout->addSpacing (20);
-    checkbox_layout->addWidget (checkbox_message, 0, Qt::AlignTop);
-    checkbox_layout->addStretch (10);
+  checkbox_layout->addWidget (checkbox, 0, Qt::AlignTop);
+  checkbox_layout->addSpacing (20);
+  checkbox_layout->addWidget (checkbox_message, 0, Qt::AlignTop);
+  checkbox_layout->addStretch (10);
 
-    QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
+  QVBoxLayout *message_logo_and_checkbox = new QVBoxLayout;
 
-    message_logo_and_checkbox->addLayout (message_and_logo);
-    message_logo_and_checkbox->addSpacing (20);
-    message_logo_and_checkbox->addLayout (checkbox_layout);
+  message_logo_and_checkbox->addLayout (message_and_logo);
+  message_logo_and_checkbox->addSpacing (20);
+  message_logo_and_checkbox->addLayout (checkbox_layout);
 
-    QHBoxLayout *button_bar = new QHBoxLayout;
+  QHBoxLayout *button_bar = new QHBoxLayout;
 
-    button_bar->addStretch (10);
-    button_bar->addWidget (previous);
-    button_bar->addWidget (next);
-    button_bar->addWidget (cancel);
+  button_bar->addStretch (10);
+  button_bar->addWidget (previous);
+  button_bar->addWidget (next);
+  button_bar->addWidget (cancel);
 
-    QVBoxLayout *page_layout = new QVBoxLayout (this);
-    setLayout (page_layout);
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
 
-    page_layout->addLayout (message_logo_and_checkbox);
-    page_layout->addStretch (10);
-    page_layout->addLayout (button_bar);
+  page_layout->addLayout (message_logo_and_checkbox);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
 
-    next->setDefault (true);
-    next->setFocus ();
+  next->setDefault (true);
+  next->setFocus ();
 
-    connect (checkbox, SIGNAL (stateChanged (int)),
-             wizard, SLOT (handle_web_connect_option (int)));
+  connect (checkbox, SIGNAL (stateChanged (int)),
+           wizard, SLOT (handle_web_connect_option (int)));
 
-    connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-    connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
-    connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-  }
+  connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+  connect (next, SIGNAL (clicked ()), wizard, SLOT (next_page ()));
+  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
 
 
 final_page::final_page (welcome_wizard *wizard)
-    : QWidget (wizard),
-      title (new QLabel (tr ("Enjoy!"), this)),
-      message (new QLabel (this)),
-      logo (make_octave_logo (this)),
-      links (new QLabel (this)),
-      previous (new QPushButton (tr ("Previous"), this)),
-      finish (new QPushButton (tr ("Finish"), this)),
-      cancel (new QPushButton (tr ("Cancel"), this))
-  {
-    QFont ft;
-    ft.setPointSize (20);
-    title->setFont (ft);
+  : QWidget (wizard),
+    title (new QLabel (tr ("Enjoy!"), this)),
+    message (new QLabel (this)),
+    logo (make_octave_logo (this)),
+    links (new QLabel (this)),
+    previous (new QPushButton (tr ("Previous"), this)),
+    finish (new QPushButton (tr ("Finish"), this)),
+    cancel (new QPushButton (tr ("Cancel"), this))
+{
+  QFont ft;
+  ft.setPointSize (20);
+  title->setFont (ft);
 
-    message->setText
-      (tr ("<html><body>\n"
-           "<p>We hope you find Octave to be a useful tool.</p>\n"
-           "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other commnity-based support channels.\n"
-           "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
-           "</body></html>"));
-    message->setWordWrap (true);
-    message->setMinimumWidth (400);
-    message->setOpenExternalLinks (true);
+  message->setText
+  (tr ("<html><body>\n"
+       "<p>We hope you find Octave to be a useful tool.</p>\n"
+       "<p>If you encounter problems, there are a number of ways to get help, including commercial support options, a mailing list, a wiki, and other commnity-based support channels.\n"
+       "You can find more information about each of these by visiting <a href=\"http://octave.org/support.html\">http://octave.org/support.html</a> (opens in external browser).</p>\n"
+       "</body></html>"));
+  message->setWordWrap (true);
+  message->setMinimumWidth (400);
+  message->setOpenExternalLinks (true);
 
-    QVBoxLayout *message_layout = new QVBoxLayout;
+  QVBoxLayout *message_layout = new QVBoxLayout;
 
-    message_layout->addWidget (title);
-    message_layout->addWidget (message);
+  message_layout->addWidget (title);
+  message_layout->addWidget (message);
 
-    QHBoxLayout *message_and_logo = new QHBoxLayout;
+  QHBoxLayout *message_and_logo = new QHBoxLayout;
 
-    message_and_logo->addLayout (message_layout);
-    message_and_logo->addStretch (10);
-    message_and_logo->addWidget (logo, 0, Qt::AlignTop);
+  message_and_logo->addLayout (message_layout);
+  message_and_logo->addStretch (10);
+  message_and_logo->addWidget (logo, 0, Qt::AlignTop);
 
-    links->setText
-      (tr ("<html><head>\n"
-           "<style>\n"
-           "a:link { text-decoration: underline; color: #0000ff; }\n"
-           "</style>\n"
-           "<head/><body>\n"
-           "<p>For more information about Octave:</p>\n"
-           "<ul>\n"
-           "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
-           "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
-           "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
-           "</ul>\n"
-           "</body></html>"));
-    links->setWordWrap (true);
-    links->setOpenExternalLinks (true);
+  links->setText
+  (tr ("<html><head>\n"
+       "<style>\n"
+       "a:link { text-decoration: underline; color: #0000ff; }\n"
+       "</style>\n"
+       "<head/><body>\n"
+       "<p>For more information about Octave:</p>\n"
+       "<ul>\n"
+       "<li>Visit <a href=\"http://octave.org\">http://octave.org</a> (opens in external browser)</li>\n"
+       "<li>Get the documentation online as <a href=\"http://www.gnu.org/software/octave/doc/interpreter/index.html\">html</a>- or <a href=\"http://www.gnu.org/software/octave/octave.pdf\">pdf</span></a>-document (opens in external browser)</li>\n"
+       "<li>Open the documentation browser of the Octave GUI with the help menu</li>\n"
+       "</ul>\n"
+       "</body></html>"));
+  links->setWordWrap (true);
+  links->setOpenExternalLinks (true);
 
-    QHBoxLayout *button_bar = new QHBoxLayout;
+  QHBoxLayout *button_bar = new QHBoxLayout;
 
-    button_bar->addStretch (10);
-    button_bar->addWidget (previous);
-    button_bar->addWidget (finish);
-    button_bar->addWidget (cancel);
+  button_bar->addStretch (10);
+  button_bar->addWidget (previous);
+  button_bar->addWidget (finish);
+  button_bar->addWidget (cancel);
 
-    QVBoxLayout *page_layout = new QVBoxLayout (this);
-    setLayout (page_layout);
+  QVBoxLayout *page_layout = new QVBoxLayout (this);
+  setLayout (page_layout);
 
-    page_layout->addLayout (message_and_logo);
-    page_layout->addSpacing (20);
-    page_layout->addWidget (links);
-    page_layout->addStretch (10);
-    page_layout->addLayout (button_bar);
+  page_layout->addLayout (message_and_logo);
+  page_layout->addSpacing (20);
+  page_layout->addWidget (links);
+  page_layout->addStretch (10);
+  page_layout->addLayout (button_bar);
 
-    finish->setDefault (true);
-    finish->setFocus ();
+  finish->setDefault (true);
+  finish->setFocus ();
 
-    connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
-    connect (finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
-    connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
-  }
+  connect (previous, SIGNAL (clicked ()), wizard, SLOT (previous_page ()));
+  connect (finish, SIGNAL (clicked ()), wizard, SLOT (accept ()));
+  connect (cancel, SIGNAL (clicked ()), wizard, SLOT (reject ()));
+}
 
 
 welcome_wizard::welcome_wizard (QWidget *p)
   : QDialog (p), page_ctor_list (), page_list_iterator (),
     current_page (initial_page::create (this)),
     allow_web_connect_state (true)
 {
   page_ctor_list.push_back (initial_page::create);
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -51,17 +51,17 @@ workspace_view::workspace_view (QWidget 
   setStatusTip (tr ("View the variables in the active workspace."));
 
   _filter = new QComboBox (this);
   _filter->setToolTip (tr ("Enter text to filter the workspace"));
   _filter->setEditable (true);
   _filter->setMaxCount (MaxFilterHistory);
   _filter->setInsertPolicy (QComboBox::NoInsert);
   _filter->setSizeAdjustPolicy (
-            QComboBox::AdjustToMinimumContentsLengthWithIcon);
+    QComboBox::AdjustToMinimumContentsLengthWithIcon);
   QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
   _filter->setSizePolicy (sizePol);
   _filter->completer ()->setCaseSensitivity (Qt::CaseSensitive);
 
   QLabel *filter_label = new QLabel (tr ("Filter"));
 
   _filter_checkbox = new QCheckBox ();
 
@@ -95,17 +95,17 @@ workspace_view::workspace_view (QWidget 
   // Initialize column order and width of the workspace
   view->horizontalHeader ()->restoreState (
     settings->value ("workspaceview/column_state").toByteArray ());
 
   // Init state of the filter
   _filter->addItems (settings->value ("workspaceview/mru_list").toStringList ());
 
   bool filter_state =
-            settings->value ("workspaceview/filter_active", false).toBool ();
+    settings->value ("workspaceview/filter_active", false).toBool ();
   _filter_checkbox->setChecked (filter_state);
   filter_activate (filter_state);
 
   // Connect signals and slots.
 
   connect (_filter, SIGNAL (editTextChanged (const QString&)),
            this, SLOT (filter_update (const QString&)));
   connect (_filter_checkbox, SIGNAL (toggled (bool)),
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1235,18 +1235,19 @@ arrayfun (@@str2num, [1234],\n\
 
               // Overloaded function handles need to check the type of
               // the arguments for each element of the array, so they
               // cannot be optimised this way.
 
               if (f -> is_overloaded ())
                 goto nevermind;
             }
-          octave_value f = symbol_table::find_function (func.function_value ()
-                                                         -> name ());
+          octave_value f
+            = symbol_table::find_function (func.function_value () -> name ());
+
           if (f.is_defined ())
             func = f;
         }
 
     nevermind:
 
       bool uniform_output = true;
       octave_value error_handler;
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -3667,17 +3667,17 @@ numeric.\n\
 %!assert (isnumeric ("Hello World"), false)
 %!assert (isnumeric (true), false)
 %!assert (isnumeric (false), false)
 %!assert (isnumeric ([true, false]), false)
 %!assert (isnumeric (sparse ([true, false])), false)
 */
 
 DEFUN (isscalar, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isscalar (@var{x})\n\
 Return true if @var{x} is a scalar.\n\
 @seealso{isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -3703,17 +3703,17 @@ Return true if @var{x} is a scalar.\n\
 %! assert (isscalar (s));
 
 %% Test input validation
 %!error isscalar ()
 %!error isscalar (1, 2)
 */
 
 DEFUN (isvector, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {} isvector (@var{x})\n\
 Return true if @var{x} is a vector.\n\
 \n\
 A vector is a 2-D array where one of the dimensions is equal to 1.  As a\n\
 consequence a 1x1 array, or scalar, is also a vector.\n\
 @seealso{isscalar, ismatrix, size, rows, columns, length}\n\
 @end deftypefn")
 {
@@ -3746,17 +3746,17 @@ consequence a 1x1 array, or scalar, is a
 %! assert (isvector (s), true);
 
 %% Test input validation
 %!error isvector ()
 %!error isvector ([1, 2], 2)
 */
 
 DEFUN (isrow, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {} isrow (@var{x})\n\
 Return true if @var{x} is a row vector 1xN with non-negative N.\n\
 @seealso{iscolumn, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -3796,17 +3796,17 @@ Return true if @var{x} is a row vector 1
 %! assert (isrow (s), true);
 
 %% Test input validation
 %!error isrow ()
 %!error isrow ([1, 2], 2)
 */
 
 DEFUN (iscolumn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {} iscolumn (@var{x})\n\
 Return true if @var{x} is a column vector Nx1 with non-negative N.\n\
 @seealso{isrow, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -3893,17 +3893,17 @@ Return true if @var{a} is a 2-D array.\n
 %! s.a = 1;
 %! assert (ismatrix (s), true);
 
 %!error ismatrix ()
 %!error ismatrix ([1, 2; 3, 4], 2)
 */
 
 DEFUN (issquare, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {} issquare (@var{x})\n\
 Return true if @var{x} is a square matrix.\n\
 @seealso{isscalar, isvector, ismatrix, size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -201,45 +201,45 @@ parse_dbfunction_params (const char *who
   int list_idx = 0;
   symbol_name = std::string ();
   lines = bp_table::intmap ();
 
   if (args.length () == 0)
     return;
 
   if (args(0).is_string ())
-  {
-    // string could be function name or line number
-    int isint = atoi (args(0).string_value ().c_str ());
+    {
+      // string could be function name or line number
+      int isint = atoi (args(0).string_value ().c_str ());
 
-    if (error_state)
-      return;
+      if (error_state)
+        return;
 
-    if (isint == 0)
-      {
-        // It was a function name
-        symbol_name = args(0).string_value ();
-        if (error_state)
-          return;
-        idx = 1;
-      }
-    else
-      {
-        // It was a line number.  Need to get function name from debugger.
-        if (Vdebugging)
-          {
-            symbol_name = get_user_code ()->name ();
-            idx = 0;
-          }
-        else
-          {
-            error ("%s: no function specified", who);
-          }
-      }
-  }
+      if (isint == 0)
+        {
+          // It was a function name
+          symbol_name = args(0).string_value ();
+          if (error_state)
+            return;
+          idx = 1;
+        }
+      else
+        {
+          // It was a line number.  Need to get function name from debugger.
+          if (Vdebugging)
+            {
+              symbol_name = get_user_code ()->name ();
+              idx = 0;
+            }
+          else
+            {
+              error ("%s: no function specified", who);
+            }
+        }
+    }
   else if (args(0).is_map ())
     {
       // This is a problem because parse_dbfunction_params()
       // can only pass out a single function.
       error ("%s: struct input not implemented", who);
       return;
     }
   else
@@ -534,17 +534,19 @@ bp_table::do_remove_all_breakpoints_in_f
 
   return retval;
 }
 
 void
 bp_table::do_remove_all_breakpoints (void)
 {
   // Odd loop structure required because delete will invalidate bp_set iterators
-  for (const_bp_set_iterator it=bp_set.begin (), it_next=it; it != bp_set.end (); it=it_next)
+  for (const_bp_set_iterator it=bp_set.begin (), it_next=it;
+       it != bp_set.end ();
+       it=it_next)
     {
       ++it_next;
       remove_all_breakpoints_in_file (*it);
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 }
 
@@ -724,20 +726,20 @@ files.\n\
 
   int nargin = args.length ();
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
 
   if (nargin == 1 && symbol_name == "all")
     bp_table::remove_all_breakpoints ();
   else
-  {
-    if (! error_state)
-      bp_table::remove_breakpoint (symbol_name, lines);
-  }
+    {
+      if (! error_state)
+        bp_table::remove_breakpoint (symbol_name, lines);
+    }
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbstatus ()\n\
 @deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus ()\n\
@@ -919,22 +921,22 @@ do_dbtype (std::ostream& os, const std::
       std::ifstream fs (ff.c_str (), std::ios::in);
 
       if (fs)
         {
           int line = 1;
           std::string text;
 
           while (std::getline (fs, text) && line <= end)
-          {
-            if (line >= start)
-              os << line << "\t" << text << "\n";
+            {
+              if (line >= start)
+                os << line << "\t" << text << "\n";
 
-            line++;
-          }
+              line++;
+            }
         }
       else
         os << "dbtype: unable to open '" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
diff --git a/libinterp/corefcn/debug.h b/libinterp/corefcn/debug.h
--- a/libinterp/corefcn/debug.h
+++ b/libinterp/corefcn/debug.h
@@ -57,49 +57,50 @@ public:
 
   static bool instance_ok (void);
 
   // Add a breakpoint at the nearest executable line.
   static intmap add_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
-      ? instance->do_add_breakpoint (fname, lines) : intmap ();
+           ? instance->do_add_breakpoint (fname, lines) : intmap ();
   }
 
   // Remove a breakpoint from a line in file.
   static int remove_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
-      ? instance->do_remove_breakpoint (fname, lines) : 0;
+           ? instance->do_remove_breakpoint (fname, lines) : 0;
   }
 
   // Remove all the breakpoints in a specified file.
   static intmap remove_all_breakpoints_in_file (const std::string& fname,
                                                 bool silent = false)
   {
     return instance_ok ()
-      ? instance->do_remove_all_breakpoints_in_file (fname, silent) : intmap ();
+           ? instance->do_remove_all_breakpoints_in_file (fname, silent)
+           : intmap ();
   }
 
   // Remove all the breakpoints registered with octave.
   static void remove_all_breakpoints (void)
   {
     if (instance_ok ())
       instance->do_remove_all_breakpoints ();
   }
 
   // Return all breakpoints.  Each element of the map is a vector
   // containing the breakpoints corresponding to a given function name.
   static fname_line_map
   get_breakpoint_list (const octave_value_list& fname_list)
   {
     return instance_ok ()
-      ? instance->do_get_breakpoint_list (fname_list) : fname_line_map ();
+           ? instance->do_get_breakpoint_list (fname_list) : fname_line_map ();
   }
 
   static bool
   have_breakpoints (void)
   {
     return instance_ok () ? instance->do_have_breakpoints () : 0;
   }
 
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -661,17 +661,17 @@ glob (\"file[12]\")\n\
 %! cd (cwd);
 %! rmdir (tmpdir);
 %! assert (result1, {"file1"; "myfile1"});
 %! assert (result2, {"myfile1"});
 %! assert (result3, {"file1"; "file2"});
 */
 
 DEFUN (__fnmatch__, args, ,
-        "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return true or false for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 filename pattern matching.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})\n\
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -26,18 +26,17 @@ along with Octave; see the file COPYING.
 #include <cstdarg>
 #include <string>
 
 class octave_map;
 class octave_value_list;
 class unwind_protect;
 
 #define panic_impossible() \
-  panic ("impossible state reached in file '%s' at line %d", \
-         __FILE__, __LINE__)
+  panic ("impossible state reached in file '%s' at line %d", __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
 extern OCTINTERP_API void
 vmessage (const char *name, const char *fmt, va_list args);
 
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1836,17 +1836,17 @@ state on the stream will be cleared.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen", Fpopen, args, ,
-       "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.  The name of the command to run is\n\
 given by @var{command}.  The file identifier corresponding to the input\n\
 or output stream of the process is returned in @var{fid}.  The argument\n\
 @var{mode} may be\n\
 \n\
 @table @code\n\
 @item @qcode{\"r\"}\n\
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -33,32 +33,35 @@ along with Octave; see the file COPYING.
 #include "oct-refcount.h"
 #include "gl-render.h"
 #include "txt-eng.h"
 #include "txt-eng-ft.h"
 
 #define LIGHT_MODE GL_FRONT_AND_BACK
 
 // Use symbolic names for axes
-enum {
+enum
+{
   X_AXIS,
   Y_AXIS,
   Z_AXIS
 };
 
 // Use symbolic names for color mode
-enum {
+enum
+{
   UNIFORM,
   FLAT,
   INTERP,
   TEXTURE
 };
 
 // Use symbolic names for lighting
-enum {
+enum
+{
   NONE,
   //FLAT,  // Already declared in anonymous enum for color mode
   GOURAUD = 2
 };
 
 // Win32 API requires the CALLBACK attributes for
 // GLU callback functions. Define it to empty on
 // other platforms.
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -63,27 +63,27 @@ public:
 #endif
   { }
 
   virtual ~opengl_renderer (void) { }
 
   virtual void draw (const graphics_object& go, bool toplevel = true);
 
   virtual void draw (const Matrix& hlist, bool toplevel = false)
-    {
-      int len = hlist.length ();
+  {
+    int len = hlist.length ();
 
-      for (int i = len-1; i >= 0; i--)
-        {
-          graphics_object obj = gh_manager::get_object (hlist(i));
+    for (int i = len-1; i >= 0; i--)
+      {
+        graphics_object obj = gh_manager::get_object (hlist(i));
 
-          if (obj)
-            draw (obj, toplevel);
-        }
-    }
+        if (obj)
+          draw (obj, toplevel);
+      }
+  }
 
   virtual void set_viewport (int w, int h);
   virtual graphics_xform get_transform (void) const { return xform; }
 
 protected:
   virtual void draw_figure (const figure::properties& props);
   virtual void draw_axes (const axes::properties& props);
   virtual void draw_line (const line::properties& props);
@@ -145,37 +145,37 @@ protected:
 private:
   opengl_renderer (const opengl_renderer&)
     : toolkit (), xform (), xmin (), xmax (), ymin (), ymax (),
     zmin (), zmax (), xZ1 (), xZ2 (), marker_id (), filled_marker_id (),
     camera_pos (), camera_dir ()
 #if HAVE_FREETYPE
     , text_renderer ()
 #endif
-    { }
+  { }
 
   opengl_renderer& operator = (const opengl_renderer&)
-    { return *this; }
+  { return *this; }
 
   bool is_nan_or_inf (double x, double y, double z) const
-    {
-      return (xisnan (x) || xisnan (y) || xisnan (z)
-              || xisinf (x) || xisinf (y) || xisinf (z));
-    }
+  {
+    return (xisnan (x) || xisnan (y) || xisnan (z)
+            || xisinf (x) || xisinf (y) || xisinf (z));
+  }
 
   octave_uint8 clip_code (double x, double y, double z) const
-    {
-      return ((x < xmin ? 1 : 0)
-              | (x > xmax ? 1 : 0) << 1
-              | (y < ymin ? 1 : 0) << 2
-              | (y > ymax ? 1 : 0) << 3
-              | (z < zmin ? 1 : 0) << 4
-              | (z > zmax ? 1 : 0) << 5
-              | (is_nan_or_inf (x, y, z) ? 0 : 1) << 6);
-    }
+  {
+    return ((x < xmin ? 1 : 0)
+            | (x > xmax ? 1 : 0) << 1
+            | (y < ymin ? 1 : 0) << 2
+            | (y > ymax ? 1 : 0) << 3
+            | (z < zmin ? 1 : 0) << 4
+            | (z > zmax ? 1 : 0) << 5
+            | (is_nan_or_inf (x, y, z) ? 0 : 1) << 6);
+  }
 
   unsigned int make_marker_list (const std::string& m, double size,
                                  bool filled) const;
 
   void draw_axes_planes (const axes::properties& props);
   void draw_axes_boxes (const axes::properties& props);
 
   void draw_axes_x_grid (const axes::properties& props);
diff --git a/libinterp/corefcn/gl2ps-renderer.h b/libinterp/corefcn/gl2ps-renderer.h
--- a/libinterp/corefcn/gl2ps-renderer.h
+++ b/libinterp/corefcn/gl2ps-renderer.h
@@ -71,17 +71,17 @@ protected:
         opengl_renderer::set_polygon_offset (on, offset);
         gl2psEnable (GL2PS_POLYGON_OFFSET_FILL);
       }
     else
       {
         gl2psDisable (GL2PS_POLYGON_OFFSET_FILL);
         opengl_renderer::set_polygon_offset (on, offset);
       }
-  } 
+  }
 
   void set_linewidth (float w)
   {
     gl2psLineWidth (w);
   }
 
 private:
   int alignment_to_mode (int ha, int va) const;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1342,17 +1342,17 @@ array_property::validate (const octave_v
 
       dim_vector vdims = v.dims ();
       int vlen = vdims.length ();
 
       xok = false;
 
       // check dimensional size constraints until a match is found
       for (std::list<dim_vector>::const_iterator it = size_constraints.begin ();
-           ! xok && it != size_constraints.end ();++it)
+           ! xok && it != size_constraints.end (); ++it)
         {
           dim_vector itdims = (*it);
 
           if (itdims.length () == vlen)
             {
               xok = true;
 
               for (int i = 0; xok && i < vlen; i++)
@@ -3170,19 +3170,19 @@ base_graphics_object::remove_all_listene
         p.delete_listener ();
     }
 }
 
 void 
 base_graphics_object::build_user_defaults_map (property_list::pval_map_type &def, const std::string go_name) const
 {
   property_list local_defaults = get_defaults_list ();
-  property_list::plist_map_const_iterator p = 
+  property_list::plist_map_const_iterator p =
     local_defaults.find (go_name);
-  
+
   if (p != local_defaults.end ())
     {
       property_list::pval_map_type pval = p->second;
       for (property_list::pval_map_const_iterator q = pval.begin ();
            q != pval.end (); q++)
         {
           std::string pname = q->first;
           if (def.find (pname) == def.end ())
@@ -3194,26 +3194,26 @@ base_graphics_object::build_user_default
 
   if (parent_obj)
     parent_obj.build_user_defaults_map (def, go_name);
 
 }
 
 void
 base_graphics_object::reset_default_properties (void)
-  {
-    if (valid_object ())
-      {
-        property_list::pval_map_type factory_pval =
-          gh_manager::get_object (0).get_factory_defaults_list ()
-          .find (type ())->second;
-
-        xreset_default_properties (get_handle (), factory_pval);
-      }
-  }
+{
+  if (valid_object ())
+    {
+      property_list::pval_map_type factory_pval =
+        gh_manager::get_object (0).get_factory_defaults_list ()
+        .find (type ())->second;
+
+      xreset_default_properties (get_handle (), factory_pval);
+    }
+}
 
 std::string
 base_graphics_object::values_as_string (void)
 {
   std::string retval;
 
   if (valid_object ())
     {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1725,17 +1725,17 @@ protected:
         if (visible_kids.numel () == new_kids.numel ())
           {
             Matrix t1 = visible_kids.sort ();
             Matrix t2 = new_kids_column.sort ();
             Matrix t3 = get_hidden ().sort ();
 
             if (t1 != t2)
               is_ok = false;
-            
+
             if (t1 == t3)
               add_hidden = false;
           }
         else
           is_ok = false;
 
         if (! is_ok)
           error ("set: new children must be a permutation of existing children");
@@ -1996,17 +1996,17 @@ private:
 };
 
 // ---------------------------------------------------------------------
 
 typedef std::pair <std::string, octave_value> pval_pair;
 
 class pval_vector : public std::vector <pval_pair>
 {
- public:
+public:
   const_iterator find (const std::string pname) const
   {
     const_iterator it;
 
     for (it = (*this).begin (); it != (*this).end (); it++)
       if (pname.compare ((*it).first) == 0)
         return it;
 
@@ -2026,17 +2026,17 @@ class pval_vector : public std::vector <
 
   octave_value lookup (const std::string pname) const
   {
     octave_value retval;
 
     const_iterator it = find (pname);
 
     if (it != (*this).end ())
-     retval = (*it).second;
+      retval = (*it).second;
 
     return retval;
   }
 
   octave_value& operator [] (const std::string pname)
   {
     iterator it = find (pname);
 
@@ -2711,17 +2711,17 @@ public:
 
   virtual void override_defaults (base_graphics_object& obj)
   {
     if (valid_object ())
       get_properties ().override_defaults (obj);
     else
       error ("base_graphics_object::override_defaults: invalid graphics object");
   }
-  
+
   void build_user_defaults_map (property_list::pval_map_type &def,
                                 const std::string go_name) const;
 
   virtual void set_from_list (property_list& plist)
   {
     if (valid_object ())
       get_properties ().set_from_list (*this, plist);
     else
@@ -2767,17 +2767,17 @@ public:
 
   virtual octave_value get_factory_default (const caseless_str&) const;
 
   virtual octave_value get_defaults (void) const
   {
     error ("base_graphics_object::get_defaults: invalid graphics object");
     return octave_value ();
   }
-  
+
   virtual property_list get_defaults_list (void) const
   {
     if (! valid_object ())
       error ("base_graphics_object::get_defaults_list: invalid graphics object");
     return property_list ();
   }
 
   virtual octave_value get_factory_defaults (void) const
@@ -4089,34 +4089,34 @@ public:
     }
     void update_zticklabelmode (void)
     {
       if (zticklabelmode.is ("auto"))
         calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
     }
 
     void update_font (void);
-    void update_fontname (void) 
-    { 
-      update_font (); 
+    void update_fontname (void)
+    {
+      update_font ();
       sync_positions ();
     }
-    void update_fontsize (void) 
-    { 
-      update_font (); 
+    void update_fontsize (void)
+    {
+      update_font ();
       sync_positions ();
     }
-    void update_fontangle (void) 
-    { 
-      update_font (); 
+    void update_fontangle (void)
+    {
+      update_font ();
       sync_positions ();
     }
-    void update_fontweight (void) 
-    { 
-      update_font (); 
+    void update_fontweight (void)
+    {
+      update_font ();
       sync_positions ();
     }
 
     void update_outerposition (void)
     {
       set_activepositionproperty ("outerposition");
       caseless_str old_units = get_units ();
       set_units ("normalized");
@@ -4679,32 +4679,32 @@ public:
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       radio_property xdatamode ha , "{auto}|manual"
       radio_property ydatamode ha , "{auto}|manual"
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        xdata.add_constraint (2);
-        ydata.add_constraint (2);
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("single");
-        cdata.add_constraint ("logical");
-        cdata.add_constraint ("uint8");
-        cdata.add_constraint ("uint16");
-        cdata.add_constraint ("int16");
-        cdata.add_constraint ("real");
-        cdata.add_constraint (dim_vector (-1, -1));
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-        alphadata.add_constraint (dim_vector (-1, -1));
-        alphadata.add_constraint ("double");
-        alphadata.add_constraint ("uint8");
-      }
+    {
+      xdata.add_constraint (2);
+      ydata.add_constraint (2);
+      cdata.add_constraint ("double");
+      cdata.add_constraint ("single");
+      cdata.add_constraint ("logical");
+      cdata.add_constraint ("uint8");
+      cdata.add_constraint ("uint16");
+      cdata.add_constraint ("int16");
+      cdata.add_constraint ("real");
+      cdata.add_constraint (dim_vector (-1, -1));
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+      alphadata.add_constraint (dim_vector (-1, -1));
+      alphadata.add_constraint ("double");
+      alphadata.add_constraint ("uint8");
+    }
 
   private:
     void update_alphadata (void)
     {
       if (alphadatamapping_is ("scaled"))
         set_alim (alphadata.get_limits ());
       else
         alim = alphadata.get_limits ();
@@ -4851,20 +4851,20 @@ public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
     // Matlab allows incoherent data to be stored into patch properties.
     // The patch should then be ignored by the renderer.
     bool has_bad_data (std::string &msg) const
-      {
-        msg = bad_data_msg;
-        return ! msg.empty ();
-      }
+    {
+      msg = bad_data_msg;
+      return ! msg.empty ();
+    }
 
     bool is_aliminclude (void) const
     { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
     { return aliminclude.current_value (); }
 
     bool is_climinclude (void) const
     { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
@@ -5541,19 +5541,19 @@ public:
       color_property shadowcolor , color_values (0, 0, 0)
       string_property title , ""
       radio_property titleposition , "{lefttop}|centertop|righttop|leftbottom|centerbottom|rightbottom"
       radio_property units S , "{normalized}|inches|centimeters|points|pixels|characters"
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        position.add_constraint (dim_vector (1, 4));
-      }
+    {
+      position.add_constraint (dim_vector (1, 4));
+    }
 
     void update_units (const caseless_str& old_units);
     void update_fontunits (const caseless_str& old_units);
 
   };
 
 private:
   properties xproperties;
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -103,523 +103,523 @@ std::size_t
 size (T const (&)[z])
 {
   return z;
 }
 
 const static pair_type operators[] =
 {
   pair_type ("!",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} !\n\
 Logical 'not' operator.\n\
 @seealso{~, not}\n\
 @end deftypefn"),
 
   pair_type ("~",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ~\n\
 Logical 'not' operator.\n\
 @seealso{!, not}\n\
 @end deftypefn"),
 
   pair_type ("!=",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} !=\n\
 Logical 'not equals' operator.\n\
 @seealso{~=, ne}\n\
 @end deftypefn"),
 
   pair_type ("~=",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ~=\n\
 Logical 'not equals' operator.\n\
 @seealso{!=, ne}\n\
 @end deftypefn"),
 
   pair_type ("\"",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} \"\n\
 String delimiter.\n\
 @end deftypefn"),
 
   pair_type ("#",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #\n\
 Begin comment character.\n\
 @seealso{%, #@\\{}\n\
 @end deftypefn"),
 
   pair_type ("%",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %\n\
 Begin comment character.\n\
 @seealso{#, %@\\{}\n\
 @end deftypefn"),
 
   pair_type ("#{",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@{}.\n\
 It is possible to nest block comments.\n\
 @seealso{%@\\{, #@\\}, #}\n\
 @end deftypefn"),
 
   pair_type ("%{",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@{\n\
 Begin block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@{}.\n\
 It is possible to nest block comments.\n\
 @seealso{#@\\{, %@\\}, %}\n\
 @end deftypefn"),
 
   pair_type ("#}",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} #@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{#@}}.\n\
 It is possible to nest block comments.\n\
 @seealso{%@\\}, #@\\{, #}\n\
 @end deftypefn"),
 
   pair_type ("%}",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} %@}\n\
 Close block comment.  There must be nothing else, other than\n\
 whitespace, in the line both before and after @code{%@}}.\n\
 It is possible to nest block comments.\n\
 @seealso{#@\\}, %@\\{, %}\n\
 @end deftypefn"),
 
   pair_type ("...",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ...\n\
 Continuation marker.  Joins current line with following line.\n\
 @end deftypefn"),
 
   pair_type ("&",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} &\n\
 Element by element logical 'and' operator.\n\
 @seealso{&&, and}\n\
 @end deftypefn"),
 
   pair_type ("&&",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} &&\n\
 Logical 'and' operator (with short-circuit evaluation).\n\
 @seealso{&, and}\n\
 @end deftypefn"),
 
   pair_type ("'",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} '\n\
 Matrix transpose operator.  For complex matrices, computes the\n\
 complex conjugate (Hermitian) transpose.\n\
 \n\
 The single quote character may also be used to delimit strings, but\n\
 it is better to use the double quote character, since that is never\n\
 ambiguous.\n\
 @seealso{.', transpose}\n\
 @end deftypefn"),
 
   pair_type ("(",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} (\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type (")",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {})\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type ("*",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
 @end deftypefn"),
 
   pair_type ("**",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} **\n\
 Power operator.  This may return complex results for real inputs.  Use\n\
 @code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
 real results when possible.\n\
 @seealso{power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("^",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ^\n\
 Power operator.  This may return complex results for real inputs.  Use\n\
 @code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
 real results when possible.\n\
 @seealso{power, **, .^, .**, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("+",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
 
   pair_type ("++",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ++\n\
 Increment operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{--}\n\
 @end deftypefn"),
 
   pair_type (",",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ,\n\
 Array index, function argument, or command separator.\n\
 @end deftypefn"),
 
   pair_type ("-",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} -\n\
 Subtraction or unary negation operator.\n\
 @seealso{minus}\n\
 @end deftypefn"),
 
   pair_type ("--",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} --\n\
 Decrement operator.  As in C, may be applied as a prefix or postfix\n\
 operator.\n\
 @seealso{++}\n\
 @end deftypefn"),
 
   pair_type (".'",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .'\n\
 Matrix transpose operator.  For complex matrices, computes the\n\
 transpose, @emph{not} the complex conjugate transpose.\n\
 @seealso{', transpose}\n\
 @end deftypefn"),
 
   pair_type (".*",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
 Element by element multiplication operator.\n\
 @seealso{*, times}\n\
 @end deftypefn"),
 
   pair_type (".**",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
 Element by element power operator.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 @seealso{**, ^, .^, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type (".^",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .^\n\
 Element by element power operator.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 @seealso{.**, ^, **, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("./",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ./\n\
 Element by element right division operator.\n\
 @seealso{/, .\\, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type ("/",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} /\n\
 Right division operator.\n\
 @seealso{./, \\, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type (".\\",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .\\\n\
 Element by element left division operator.\n\
 @seealso{\\, ./, rdivide, mrdivide}\n\
 @end deftypefn"),
 
   pair_type ("\\",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} \\\n\
 Left division operator.\n\
 @seealso{.\\, /, ldivide, mldivide}\n\
 @end deftypefn"),
 
   pair_type (":",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} :\n\
 Select entire rows or columns of matrices.\n\
 @end deftypefn"),
 
   pair_type (";",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ;\n\
 Array row or command separator.\n\
 @seealso{,}\n\
 @end deftypefn"),
 
   pair_type ("<",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} <\n\
 'Less than' operator.\n\
 @seealso{lt}\n\
 @end deftypefn"),
 
   pair_type ("<=",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} <=\n\
 'Less than' or 'equals' operator.\n\
 @seealso{le}\n\
 @end deftypefn"),
 
   pair_type ("=",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} =\n\
 Assignment operator.\n\
 @end deftypefn"),
 
   pair_type ("==",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ==\n\
 Equality test operator.\n\
 @seealso{eq}\n\
 @end deftypefn"),
 
   pair_type (">",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} >\n\
 'Greater than' operator.\n\
 @seealso{gt}\n\
 @end deftypefn"),
 
   pair_type (">=",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} >=\n\
 'Greater than' or 'equals' operator.\n\
 @seealso{ge}\n\
 @end deftypefn"),
 
   pair_type ("[",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} [\n\
 Return list delimiter.\n\
 @seealso{]}\n\
 @end deftypefn"),
 
   pair_type ("]",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ]\n\
 Return list delimiter.\n\
 @seealso{[}\n\
 @end deftypefn"),
 
   pair_type ("|",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} |\n\
 Element by element logical 'or' operator.\n\
 @seealso{||, or}\n\
 @end deftypefn"),
 
   pair_type ("||",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ||\n\
 Logical 'or' (with short-circuit evaluation) operator.\n\
 @seealso{|, or}\n\
 @end deftypefn"),
 };
 
 const static pair_type keywords[] =
 {
   pair_type ("break",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} break\n\
 Exit the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, parfor, continue}\n\
 @end deftypefn"),
 
   pair_type ("case",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn  {Keyword} {} case @var{value}\n\
 @deftypefnx {Keyword} {} case @{@var{value}, @dots{}@}\n\
 A case statement in a switch.  Octave cases are exclusive and do not\n\
 fall-through as do C-language cases.  A switch statement must have at least\n\
 one case.  See @code{switch} for an example.\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("catch",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn  {Keyword} {} catch\n\
 @deftypefnx {Keyword} {} catch @var{value}\n\
 Begin the cleanup part of a try-catch block.\n\
 @seealso{try}\n\
 @end deftypefn"),
 
   pair_type ("continue",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} continue\n\
 Jump to the end of the innermost enclosing do, while or for loop.\n\
 @seealso{do, while, for, parfor, break}\n\
 @end deftypefn"),
 
   pair_type ("do",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} do\n\
 Begin a do-until loop.  This differs from a do-while loop in that the\n\
 body of the loop is executed at least once.\n\
 \n\
 @example\n\
 @group\n\
 i = 0;\n\
 do\n\
   i++\n\
 until (i == 10)\n\
 @end group\n\
 @end example\n\
 @seealso{for, until, while}\n\
 @end deftypefn"),
 
   pair_type ("else",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} else\n\
 Alternate action for an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("elseif",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} elseif (@var{condition})\n\
 Alternate conditional test for an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("end",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} end\n\
 Mark the end of any @code{for}, @code{parfor}, @code{if}, @code{do},\n\
 @code{while}, @code{function}, @code{switch}, @code{try}, or\n\
 @code{unwind_protect} block.\n\
 @seealso{for, parfor, if, do, while, function, switch, try, unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("end_try_catch",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} end_try_catch\n\
 Mark the end of an @code{try-catch} block.\n\
 @seealso{try, catch}\n\
 @end deftypefn"),
 
   pair_type ("end_unwind_protect",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} end_unwind_protect\n\
 Mark the end of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("endfor",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endfor\n\
 Mark the end of a for loop.  See @code{for} for an example.\n\
 @seealso{for}\n\
 @end deftypefn"),
 
   pair_type ("endfunction",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endfunction\n\
 Mark the end of a function.\n\
 @seealso{function}\n\
 @end deftypefn"),
 
   pair_type ("endif",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endif\n\
 Mark the end of an if block.  See @code{if} for an example.\n\
 @seealso{if}\n\
 @end deftypefn"),
 
   pair_type ("endparfor",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endparfor\n\
 Mark the end of a parfor loop.  See @code{parfor} for an example.\n\
 @seealso{parfor}\n\
 @end deftypefn"),
 
   pair_type ("endswitch",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endswitch\n\
 Mark the end of a switch block.  See @code{switch} for an example.\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("endwhile",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endwhile\n\
 Mark the end of a while loop.  See @code{while} for an example.\n\
 @seealso{do, while}\n\
 @end deftypefn"),
 
   pair_type ("for",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} for @var{i} = @var{range}\n\
 Begin a for loop.\n\
 \n\
 @example\n\
 @group\n\
 for i = 1:10\n\
   i\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @seealso{do, parfor, while}\n\
 @end deftypefn"),
 
   pair_type ("function",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn  {Keyword} {} function @var{outputs} = function (@var{input}, @dots{})\n\
 @deftypefnx {Keyword} {} function {} function (@var{input}, @dots{})\n\
 @deftypefnx {Keyword} {} function @var{outputs} = function\n\
 Begin a function body with @var{outputs} as results and @var{inputs} as\n\
 parameters.\n\
 @seealso{return}\n\
 @end deftypefn"),
 
   pair_type ("global",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} global @var{var}\n\
 Declare variables to have global scope.\n\
 \n\
 @example\n\
 @group\n\
 global @var{x};\n\
 if (isempty (@var{x}))\n\
   x = 1;\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("if",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn  {Keyword} {} if (@var{cond}) @dots{} endif\n\
 @deftypefnx {Keyword} {} if (@var{cond}) @dots{} else @dots{} endif\n\
 @deftypefnx {Keyword} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} endif\n\
 @deftypefnx {Keyword} {} if (@var{cond}) @dots{} elseif (@var{cond}) @dots{} else @dots{} endif\n\
 Begin an if block.\n\
 \n\
 @example\n\
 @group\n\
@@ -632,65 +632,65 @@ else\n\
   disp (\"not one or two\");\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("otherwise",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn  {Keyword} {} parfor @var{i} = @var{range}\n\
 @deftypefnx {Keyword} {} parfor (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
 @end group\n\
 @end example\n\
 @seealso{for, do, while}\n\
 @end deftypefn"),
 
   pair_type ("persistent",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} persistent @var{var}\n\
 Declare variables as persistent.  A variable that has been declared\n\
 persistent within a function will retain its contents in memory between\n\
 subsequent calls to the same function.  The difference between persistent\n\
 variables and global variables is that persistent variables are local in \n\
 scope to a particular function and are not visible elsewhere.\n\
 @seealso{global}\n\
 @end deftypefn"),
 
   pair_type ("return",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} return\n\
 Return from a function.\n\
 @seealso{function}\n\
 @end deftypefn"),
 
   pair_type ("static",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} static\n\
 This statement has been deprecated in favor of @code{persistent}.\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("switch",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} switch @var{statement}\n\
 Begin a switch block.\n\
 \n\
 @example\n\
 @group\n\
 yesno = \"yes\"\n\
 \n\
 switch yesno\n\
@@ -702,71 +702,71 @@ switch yesno\n\
     error (\"invalid value\");\n\
 endswitch\n\
 @end group\n\
 @end example\n\
 @seealso{if, case, otherwise}\n\
 @end deftypefn"),
 
   pair_type ("try",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} try\n\
 Begin a try-catch block.\n\
 \n\
 If an error occurs within a try block, then the catch code will be run and\n\
 execution will proceed after the catch block (though it is often\n\
 recommended to use the lasterr function to re-throw the error after cleanup\n\
 is completed).\n\
 @seealso{catch, unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("until",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} until (@var{cond})\n\
 End a do-until loop.  See @code{do} for an example.\n\
 @seealso{do}\n\
 @end deftypefn"),
 
   pair_type ("unwind_protect",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} unwind_protect\n\
 Begin an unwind_protect block.\n\
 \n\
 If an error occurs within the first part of an unwind_protect block\n\
 the commands within the unwind_protect_cleanup block are executed before\n\
 the error is thrown.  If an error is not thrown, then the\n\
 unwind_protect_cleanup block is still executed (in other words, the\n\
 unwind_protect_cleanup will be run with or without an error in the\n\
 unwind_protect block).\n\
 @seealso{unwind_protect_cleanup, try}\n\
 @end deftypefn"),
 
   pair_type ("unwind_protect_cleanup",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} unwind_protect_cleanup\n\
 Begin the cleanup section of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn"),
 
   pair_type ("varargin",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} varargin\n\
 Pass an arbitrary number of arguments into a function.\n\
 @seealso{varargout, nargin, isargout, nargout, nthargout}\n\
 @end deftypefn"),
 
   pair_type ("varargout",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} varargout\n\
 Pass an arbitrary number of arguments out of a function.\n\
 @seealso{varargin, nargin, isargout, nargout, nthargout}\n\
 @end deftypefn"),
 
   pair_type ("while",
-    "-*- texinfo -*-\n\
+  "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} while\n\
 Begin a while loop.\n\
 \n\
 @example\n\
 @group\n\
 i = 0;\n\
 while (i < 10)\n\
   i++\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -605,17 +605,17 @@ get_debug_input (const std::string& prom
       reset_error_handler ();
 
       curr_parser.reset ();
 
       int retval = curr_parser.run ();
 
       if (command_editor::interrupt (false))
         break;
-       else
+      else
         {
           if (retval == 0 && curr_parser.stmt_list)
             {
               curr_parser.stmt_list->accept (*current_evaluator);
 
               if (octave_completion_matches_called)
                 octave_completion_matches_called = false;
             }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -74,17 +74,17 @@ load_path::dir_info::update (void)
                   // If it is out of date, initialize it.  Otherwise,
                   // copy the info from the cache.  By doing that, we
                   // avoid unnecessary calls to stat that can slow
                   // things down tremendously for large directories.
 
                   const dir_info& di = p->second;
 
                   if (fs.mtime () + fs.time_resolution ()
-                       > di.dir_time_last_checked)
+                      > di.dir_time_last_checked)
                     initialize ();
                   else
                     *this = di;
                 }
               else
                 {
                   // We haven't seen this directory before.
 
@@ -1274,17 +1274,17 @@ find_private_file (const std::string& fn
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
 
       if (! dir_name.empty ())
         {
           std::string pfname = dir_name + file_ops::dir_sep_str ()
-            + "private" + file_ops::dir_sep_str () + fname;
+                               + "private" + file_ops::dir_sep_str () + fname;
 
           file_stat fs (pfname);
 
           if (fs.exists () && fs.is_reg ())
             retval = pfname;
         }
     }
 
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -526,25 +526,25 @@ private:
       add_to_method_map (di, at_end);
     }
 
     void move (const dir_info& di, bool at_end);
 
     void remove (const dir_info& di);
 
     void clear (void)
-      {
-        dir_list.clear ();
+    {
+      dir_list.clear ();
 
-        fcn_map.clear ();
+      fcn_map.clear ();
 
-        private_fcn_map.clear ();
+      private_fcn_map.clear ();
 
-        method_map.clear ();
-      }
+      method_map.clear ();
+    }
 
     void display (std::ostream& out) const;
 
     std::string find_fcn (const std::string& fcn,
                           std::string& dir_name,
                           int type = M_FILE | OCT_FILE | MEX_FILE) const;
 
     std::string find_private_fcn (const std::string& dir,
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -47,23 +47,23 @@ contains_char (const std::string& str, c
   return (str.find (c) != std::string::npos
           || str.find (std::toupper (c)) != std::string::npos);
 }
 
 // case-insensitive character comparison functors
 struct icmp_char_lt : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
-    { return std::toupper (x) < std::toupper (y); }
+  { return std::toupper (x) < std::toupper (y); }
 };
 
 struct icmp_char_gt : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
-    { return std::toupper (x) > std::toupper (y); }
+  { return std::toupper (x) > std::toupper (y); }
 };
 
 // FIXME: maybe these should go elsewhere?
 // FIXME: are they even needed now?
 // case-insensitive ascending comparator
 #if 0
 static bool
 stri_comp_lt (const std::string& a, const std::string& b)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -213,17 +213,17 @@ information.\n\
 
               ColumnVector Qinit;
               Qinit.resize (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit (i) = i;
               SparseLU fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
-                  retval(0) = fact.Y ();
+                retval(0) = fact.Y ();
               else
                 {
 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
@@ -245,35 +245,35 @@ information.\n\
                     }
 
                 }
 
             }
           else
             {
 
-                SparseLU fact (m, thres, scale);
+              SparseLU fact (m, thres, scale);
 
-                if (scale)
-                  retval(4) = fact.R ();
+              if (scale)
+                retval(4) = fact.R ();
 
-                if (vecout)
-                  {
-                    retval(3) = fact.Pc_vec ();
-                    retval(2) = fact.Pr_vec ();
-                  }
-                else
-                  {
-                    retval(3) = fact.Pc_mat ();
-                    retval(2) = fact.Pr_mat ();
-                  }
-                retval(1) = octave_value (fact.U (),
-                                          MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (),
-                                          MatrixType (MatrixType::Lower));
+              if (vecout)
+                {
+                  retval(3) = fact.Pc_vec ();
+                  retval(2) = fact.Pr_vec ();
+                }
+              else
+                {
+                  retval(3) = fact.Pc_mat ();
+                  retval(2) = fact.Pr_mat ();
+                }
+              retval(1) = octave_value (fact.U (),
+                                        MatrixType (MatrixType::Upper));
+              retval(0) = octave_value (fact.L (),
+                                        MatrixType (MatrixType::Lower));
             }
 
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           if (nargout < 4)
@@ -282,68 +282,68 @@ information.\n\
               ColumnVector Qinit;
               Qinit.resize (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit (i) = i;
               SparseComplexLU fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
 
-                  retval(0) = fact.Y ();
+                retval(0) = fact.Y ();
 
               else
                 {
 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseComplexMatrix L = fact.L ();
                   if (nargout < 3)
-                      retval(0)
-                        = octave_value (P.transpose () * L,
-                            MatrixType (MatrixType::Permuted_Lower,
-                                        nr, fact.row_perm ()));
+                    retval(0)
+                      = octave_value (P.transpose () * L,
+                                      MatrixType (MatrixType::Permuted_Lower,
+                                                  nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
                       if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
 
                 }
 
             }
           else
             {
 
-                SparseComplexLU fact (m, thres, scale);
+              SparseComplexLU fact (m, thres, scale);
 
-                if (scale)
-                  retval(4) = fact.R ();
+              if (scale)
+                retval(4) = fact.R ();
 
-                if (vecout)
-                  {
-                    retval(3) = fact.Pc_vec ();
-                    retval(2) = fact.Pr_vec ();
-                  }
-                else
-                  {
-                    retval(3) = fact.Pc_mat ();
-                    retval(2) = fact.Pr_mat ();
-                  }
-                retval(1) = octave_value (fact.U (),
-                                          MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (),
-                                          MatrixType (MatrixType::Lower));
+              if (vecout)
+                {
+                  retval(3) = fact.Pc_vec ();
+                  retval(2) = fact.Pr_vec ();
+                }
+              else
+                {
+                  retval(3) = fact.Pc_mat ();
+                  retval(2) = fact.Pr_mat ();
+                }
+              retval(1) = octave_value (fact.U (),
+                                        MatrixType (MatrixType::Upper));
+              retval(0) = octave_value (fact.L (),
+                                        MatrixType (MatrixType::Lower));
             }
 
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
   else
     {
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2510,17 +2510,17 @@ octave_base_stream::do_numeric_printf_co
   if (is_nan_or_inf (val))
     {
       double dval = val.double_value ();
 
       std::string tfmt = fmt;
       std::string::size_type i1, i2;
 
       tfmt.replace ((i1 = tfmt.rfind (elt->type)),
-                   1, 1, 's');
+                    1, 1, 's');
 
       if ((i2 = tfmt.rfind ('.')) != std::string::npos
           && i2 < i1)
         {
           tfmt.erase (i2, i1-i2);
           if (elt->prec == -2)
             nsa--;
         }
diff --git a/libinterp/corefcn/octave-default-image.h b/libinterp/corefcn/octave-default-image.h
--- a/libinterp/corefcn/octave-default-image.h
+++ b/libinterp/corefcn/octave-default-image.h
@@ -15,17 +15,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-static char default_im_data[] = {
+static char default_im_data[] =
+{
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,20,20,20,20,20,20,21,21,21,21,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,20,20,20,20,20,20,20,20,20,20,20,21,21,
   21,21,21,21,31,31,31,31,31,31,31,31,31,31,31,31,
   31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -157,17 +157,17 @@ is in the upper left corner, by doing:\n
 
 #define PREPARE_OUTPUT()\
           if (info != 0) \
             { \
               error ("ordschur: trsen failed"); \
               return retval; \
             } \
           retval(0) = U; \
-          retval(1) = S; \
+          retval(1) = S;
 
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -817,17 +817,17 @@ set_format (const Matrix& m, int& fw, do
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
   scale = (x_max == 0 || int_or_inf_or_nan)
-            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
+          ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_real_matrix_format (x_max, x_min, inf_or_nan, int_or_inf_or_nan, fw);
 }
 
 static inline void
 set_format (const Matrix& m)
 {
   int fw;
@@ -1233,17 +1233,17 @@ set_format (const ComplexMatrix& cm, int
   int i_x_max = i_max_abs == 0.0 ? 0 : num_digits (i_max_abs);
 
   int i_x_min = i_min_abs == 0.0 ? 0 : num_digits (i_min_abs);
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
   scale = (x_max == 0 || int_or_inf_or_nan)
-            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
+          ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
                              int_or_inf_or_nan, r_fw, i_fw);
 }
 
 static inline void
 set_format (const ComplexMatrix& cm)
 {
@@ -1389,17 +1389,17 @@ set_format (const Range& r, int& fw, dou
   double max_abs = r_max < 0.0 ? -r_max : r_max;
   double min_abs = r_min < 0.0 ? -r_min : r_min;
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
   scale = (x_max == 0 || all_ints)
-            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
+          ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_range_format (x_max, x_min, all_ints, fw);
 }
 
 static inline void
 set_format (const Range& r)
 {
   int fw;
@@ -2581,17 +2581,17 @@ octave_print_internal (std::ostream& os,
     case 1:
     case 2:
       octave_print_internal (os, ComplexMatrix (nda),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
       print_nd_array <ComplexNDArray, Complex, ComplexMatrix>
-                      (os, nda, pr_as_read_syntax);
+                     (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, bool d, bool pr_as_read_syntax)
 {
   octave_print_internal (os, double (d), pr_as_read_syntax);
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -70,17 +70,17 @@ extern "C"
                              const octave_idx_type& N, double* A,
                              const octave_idx_type& LDA, double* B,
                              const octave_idx_type& LDB, octave_idx_type& ILO,
                              octave_idx_type& IHI, double* LSCALE,
                              double* RSCALE, double* WORK,
                              octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL);
 
-F77_RET_T
+  F77_RET_T
   F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N, Complex* A,
                              const octave_idx_type& LDA, Complex* B,
                              const octave_idx_type& LDB, octave_idx_type& ILO,
                              octave_idx_type& IHI, double* LSCALE,
                              double* RSCALE, double* WORK,
                              octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL);
@@ -92,17 +92,17 @@ F77_RET_T
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI,
                              const double* LSCALE, const double* RSCALE,
                              octave_idx_type& M, double* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
-F77_RET_T
+  F77_RET_T
   F77_FUNC (zggbak, ZGGBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N,
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI,
                              const double* LSCALE, const double* RSCALE,
                              octave_idx_type& M, Complex* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
@@ -117,17 +117,17 @@ F77_RET_T
                              const octave_idx_type& IHI, double* A,
                              const octave_idx_type& LDA, double* B,
                              const octave_idx_type& LDB, double* Q,
                              const octave_idx_type& LDQ, double* Z,
                              const octave_idx_type& LDZ, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
- F77_RET_T
+  F77_RET_T
   F77_FUNC (zgghrd, ZGGHRD) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N,
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI, Complex* A,
                              const octave_idx_type& LDA, Complex* B,
                              const octave_idx_type& LDB, Complex* Q,
                              const octave_idx_type& LDQ, Complex* Z,
@@ -148,17 +148,17 @@ F77_RET_T
                              const octave_idx_type& LDQ, double* Z,
                              const octave_idx_type& LDZ, double* WORK,
                              const octave_idx_type& LWORK,
                              octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
-F77_RET_T
+  F77_RET_T
   F77_FUNC (zhgeqz, ZHGEQZ) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N,
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI,
                              Complex* A, const octave_idx_type& LDA,
                              Complex* B, const octave_idx_type& LDB,
@@ -199,17 +199,17 @@ F77_RET_T
                              const octave_idx_type& LDB, double* VL,
                              const octave_idx_type& LDVL, double* VR,
                              const octave_idx_type& LDVR,
                              const octave_idx_type& MM, octave_idx_type& M,
                              double* WORK, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
-F77_RET_T
+  F77_RET_T
   F77_FUNC (ztgevc, ZTGEVC) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              octave_idx_type* SELECT,
                              const octave_idx_type& N, const Complex* A,
                              const octave_idx_type& LDA,const Complex* B,
                              const octave_idx_type& LDB, Complex* xVL,
                              const octave_idx_type& LDVL, Complex* xVR,
                              const octave_idx_type& LDVR,
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -732,17 +732,17 @@ This is just the opposite of the corresp
 %!error strncmp ()
 %!error strncmp ("abc", "def")
 */
 
 // case-insensitive character equality functor
 struct icmp_char_eq : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
-    { return std::toupper (x) == std::toupper (y); }
+  { return std::toupper (x) == std::toupper (y); }
 };
 
 // strcmpi is equivalent to strcmp in that it checks all dims.
 static bool
 strcmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type)
 {
   return (s1.dims () == s2.dims ()
           && std::equal (s1.data (), s1.data () + s1.numel (), s2.data (),
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -242,17 +242,17 @@ out_of_date_check (octave_value& functio
 
                   if (check_relative)
                     {
                       int nm_len = nm.length ();
 
                       if (octave_env::absolute_pathname (nm) &&
                           ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
                                            || nm.substr (nm_len-4) == ".mex"))
-                            || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
+                           || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
                         file = nm;
                       else
                         {
                           // We don't want to make this an absolute name,
                           // because load_fcn_file looks at the name to
                           // decide whether it came from a relative lookup.
 
                           if (! dispatch_type.empty ())
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -1051,17 +1051,17 @@ public:
     }
 
     bool is_user_function_defined (void) const
     {
       return rep->is_user_function_defined ();
     }
 
     octave_value find_function (const octave_value_list& args
-                                  = octave_value_list (),
+                                = octave_value_list (),
                                 bool local_funcs = true)
     {
       return rep->find_function (args, local_funcs);
     }
 
     void lock_subfunction (scope_id scope)
     {
       rep->lock_subfunction (scope);
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -181,17 +181,17 @@ w32_init (void)
 
 static bool
 w32_shell_execute (const std::string& file)
 {
 }
 #endif
 
 DEFUN (__open_with_system_app__, args, ,
-           "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __open_with_system_app__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
@@ -1012,17 +1012,17 @@ tilde_expand (\"~/bin\")\n\
 %! assert (tilde_expand ("foo/bar"), "foo/bar");
 */
 
 // This function really belongs in display.cc, but including defun.h in
 // that file results in conflicts with symbols from headers that are
 // needed for X11 and Carbon functions.
 
 DEFUN (have_window_system, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} have_window_system ()\n\
 Return true if a window system is available (X11, Windows, or Apple OS X)\n\
 and false otherwise.\n\
 @seealso{isguirunning}\n\
 @end deftypefn")
 {
   return octave_value (display_info::display_available ());
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -455,28 +455,28 @@ symbol_exist (const std::string& name, c
       if (file_name.empty ())
         file_name = name;
 
       file_stat fs (file_name);
 
       if (fs)
         {
           if (search_any || search_file)
-          {
-            if (fs.is_dir ())
-              return 7;
-
-            len = file_name.length ();
-
-            if (len > 4 && (file_name.substr (len-4) == ".oct"
-                            || file_name.substr (len-4) == ".mex"))
-              return 3;
-            else
-              return 2;
-          }
+            {
+              if (fs.is_dir ())
+                return 7;
+
+              len = file_name.length ();
+
+              if (len > 4 && (file_name.substr (len-4) == ".oct"
+                              || file_name.substr (len-4) == ".mex"))
+                return 3;
+              else
+                return 2;
+            }
           else if (search_dir && fs.is_dir ())
             return 7;
         }
 
       if (search_file || search_dir)
         return 0;
     }
 
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -173,26 +173,26 @@ protected:
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekoff (off_type off, std::ios_base::seekdir way,
            std::ios_base::openmode mode =
-           std::ios_base::in|std::ios_base::out);
+             std::ios_base::in|std::ios_base::out);
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekpos (pos_type sp, std::ios_base::openmode mode =
-           std::ios_base::in|std::ios_base::out);
+             std::ios_base::in|std::ios_base::out);
 
   virtual int_type
   pbackfail (int_type c = traits_type::eof ());
 
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -121,17 +121,18 @@ Undocumented internal function.\n\
             }
           retval(0) = file_cell;
         }
 
       if (multi_type == Fl_File_Chooser::DIRECTORY)
         retval(0) = file_ops::native_separator_path (std::string (fc.value ()));
       else
         {
-          retval(1) = file_ops::native_separator_path (std::string (fc.directory ()) + sep);
+          retval(1) = file_ops::native_separator_path (
+                        std::string (fc.directory ()) + sep);
           retval(2) = fc.filter_value () + 1;
         }
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -646,17 +646,18 @@ xerror_handler (Display *, XErrorEvent *
   return 0;
 }
 #endif
 
 class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
 public:
-  plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp, bool internal)
+  plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp,
+               bool internal)
     : Fl_Window (xx, yy, ww, hh + menu_h + status_h + 2, "octave"),
       window_label (), fp (xfp), canvas (0),
       autoscale (0), togglegrid (0), panzoom (0), rotate (0), help (0),
       status (0), resize_dummy (0), ax_obj (), pos_x (0), pos_y (0)
   {
     callback (window_close, static_cast<void*> (this));
 
     // The size of the resize_dummy box also determines the minimum window size
@@ -884,30 +885,30 @@ public:
     status->resize (5 * status_h + 1, toolbar_y,
                     w () - 5 * status_h - 1, status_h);
 
     init_sizes ();
     redraw ();
   }
 
   Matrix outerposition2position (const Matrix& outerpos)
-    {
-      Matrix pos = outerpos;
-      pos(1) += menu_dy ();
-      pos(3) -= menu_dy () + status_h + 2;
-      return pos;
-    }
+  {
+    Matrix pos = outerpos;
+    pos(1) += menu_dy ();
+    pos(3) -= menu_dy () + status_h + 2;
+    return pos;
+  }
 
   Matrix position2outerposition (const Matrix& pos)
-    {
-      Matrix outerpos = pos;
-      outerpos(1) -= menu_dy ();
-      outerpos(3) += menu_dy () + status_h + 2;
-      return outerpos;
-    }
+  {
+    Matrix outerpos = pos;
+    outerpos(1) -= menu_dy ();
+    outerpos(3) += menu_dy () + status_h + 2;
+    return outerpos;
+  }
 
   // Called from figure::properties::ID_POSITION if internal = true
   // or ID_OUTERPOSITION if false.
   // (someone has requested a position change with set (h, "position", [...])
   // or set (h, "outerposition", [...])
 
   void update_boundingbox (bool internal)
   {
@@ -1432,246 +1433,247 @@ private:
               if (fp.get_keyreleasefcn ().is_defined ()
                   && (evt.contents ("Key").length () > 0))
                 fp.execute_keyreleasefcn (evt);
               return 1;
             }
             break;
           }
 
-      // Events we only handle if they are in the canvas area.
-      if (Fl::event_inside (canvas))
-        switch (event)
-          {
-          case FL_MOVE:
-            pixel2status (pixel2axes_or_ca (Fl::event_x (),
-                                            Fl::event_y () - menu_dy ()),
-                          Fl::event_x (), Fl::event_y () - menu_dy ());
-            return 1;
+        // Events we only handle if they are in the canvas area.
+        if (Fl::event_inside (canvas))
+          switch (event)
+            {
+            case FL_MOVE:
+              pixel2status (pixel2axes_or_ca (Fl::event_x (),
+                                              Fl::event_y () - menu_dy ()),
+                            Fl::event_x (), Fl::event_y () - menu_dy ());
+              return 1;
 
-          case FL_PUSH:
-            pos_x = Fl::event_x ();
-            pos_y = Fl::event_y () - menu_dy ();
-
-            set_currentpoint (pos_x, pos_y);
+            case FL_PUSH:
+              pos_x = Fl::event_x ();
+              pos_y = Fl::event_y () - menu_dy ();
 
-            if (Fl::event_button () == FL_LEFT_MOUSE
-                && Fl::event_shift ())
-              fp.set_selectiontype ("extend");
-            else if ((Fl::event_button () == FL_LEFT_MOUSE
-                      && Fl::event_ctrl ())
-                      || Fl::event_button () == FL_RIGHT_MOUSE)
-              fp.set_selectiontype ("alternate");
-            else if (Fl::event_clicks ())
-              fp.set_selectiontype ("open");
-            else
-              fp.set_selectiontype ("normal");
+              set_currentpoint (pos_x, pos_y);
 
-            if (fp.get_windowbuttondownfcn ().is_defined ())
-              fp.execute_windowbuttondownfcn (Fl::event_button ());
+              if (Fl::event_button () == FL_LEFT_MOUSE
+                  && Fl::event_shift ())
+                fp.set_selectiontype ("extend");
+              else if ((Fl::event_button () == FL_LEFT_MOUSE
+                        && Fl::event_ctrl ())
+                       || Fl::event_button () == FL_RIGHT_MOUSE)
+                fp.set_selectiontype ("alternate");
+              else if (Fl::event_clicks ())
+                fp.set_selectiontype ("open");
+              else
+                fp.set_selectiontype ("normal");
 
-            gh = pixel2axes_or_ca (pos_x, pos_y);
+              if (fp.get_windowbuttondownfcn ().is_defined ())
+                fp.execute_windowbuttondownfcn (Fl::event_button ());
 
-            if (gh.ok ())
-              {
-                ax_obj = gh_manager::get_object (gh);
-                set_axes_currentpoint (ax_obj, pos_x, pos_y);
+              gh = pixel2axes_or_ca (pos_x, pos_y);
 
-                int ndim = calc_dimensions (ax_obj);
+              if (gh.ok ())
+                {
+                  ax_obj = gh_manager::get_object (gh);
+                  set_axes_currentpoint (ax_obj, pos_x, pos_y);
 
-                if (ndim == 3)
-                  rotate->activate ();
-                else // ndim == 2
-                  rotate->deactivate ();
+                  int ndim = calc_dimensions (ax_obj);
 
-                fp.set_currentobject (ax_obj.get_handle ().value ());
+                  if (ndim == 3)
+                    rotate->activate ();
+                  else // ndim == 2
+                    rotate->deactivate ();
 
-                base_properties& props = ax_obj.get_properties ();
-                if (props.get_buttondownfcn ().is_defined ())
-                  props.execute_buttondownfcn (Fl::event_button ());
+                  fp.set_currentobject (ax_obj.get_handle ().value ());
 
-                return 1;
-              }
-            else if (fp.get_buttondownfcn ().is_defined ())
-              fp.execute_buttondownfcn (Fl::event_button ());
+                  base_properties& props = ax_obj.get_properties ();
+                  if (props.get_buttondownfcn ().is_defined ())
+                    props.execute_buttondownfcn (Fl::event_button ());
 
-            break;
+                  return 1;
+                }
+              else if (fp.get_buttondownfcn ().is_defined ())
+                fp.execute_buttondownfcn (Fl::event_button ());
 
-          case FL_DRAG:
-            if (fp.get_windowbuttonmotionfcn ().is_defined ())
-              {
-                set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
-                fp.execute_windowbuttonmotionfcn ();
-              }
+              break;
 
-            if (Fl::event_button () == 1)
-              {
-                if (ax_obj && ax_obj.isa ("axes"))
-                  {
-                    axes::properties& ap =
-                      dynamic_cast<axes::properties&>
-                      (ax_obj.get_properties ());
+            case FL_DRAG:
+              if (fp.get_windowbuttonmotionfcn ().is_defined ())
+                {
+                  set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
+                  fp.execute_windowbuttonmotionfcn ();
+                }
 
-                    // Don't pan or rotate legend
-                    if (ap.get_tag ().compare ("legend") < 0)
-                      {
-                        if (rotate_enabled ())
-                          view2status (ax_obj);
-                        else
-                          pixel2status (ax_obj, pos_x, pos_y,
-                                        Fl::event_x (),
-                                        Fl::event_y () - menu_dy ());
-
-                        double x0, y0, x1, y1;
-                        Matrix pos = fp.get_boundingbox (true);
-                        pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
-                        pixel2pos (ax_obj, Fl::event_x (),
-                                           Fl::event_y () - menu_dy (),
-                                           x1, y1);
+              if (Fl::event_button () == 1)
+                {
+                  if (ax_obj && ax_obj.isa ("axes"))
+                    {
+                      axes::properties& ap =
+                        dynamic_cast<axes::properties&>
+                        (ax_obj.get_properties ());
 
-                        if (pan_enabled ())
-                          ap.translate_view ("both", x0, x1, y0, y1);
-                        else if (rotate_enabled ())
-                          {
-                            double daz, del;
-                            daz = (Fl::event_x () - pos_x) / pos(2) * 360;
-                            del = (Fl::event_y () - menu_dy () - pos_y)
-                                  / pos(3) * 360;
-                            ap.rotate_view (del, daz);
-                          }
-                      }
-                    else
-                      {  // move the position of the legend
-                        Matrix pos = ap.get_position ().matrix_value ();
-                        pos(0) += double (Fl::event_x () - pos_x)
-                                  / canvas->w ();
-                        pos(1) -= double (Fl::event_y () - menu_dy () - pos_y)
-                                  / canvas->h ();
-                        ap.set_position (pos);
-                      }
+                      // Don't pan or rotate legend
+                      if (ap.get_tag ().compare ("legend") < 0)
+                        {
+                          if (rotate_enabled ())
+                            view2status (ax_obj);
+                          else
+                            pixel2status (ax_obj, pos_x, pos_y,
+                                          Fl::event_x (),
+                                          Fl::event_y () - menu_dy ());
+
+                          double x0, y0, x1, y1;
+                          Matrix pos = fp.get_boundingbox (true);
+                          pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
+                          pixel2pos (ax_obj, Fl::event_x (),
+                                     Fl::event_y () - menu_dy (),
+                                     x1, y1);
 
-                    pos_x = Fl::event_x ();
-                    pos_y = Fl::event_y () - menu_dy ();
-                    mark_modified ();
-                  }
-                return 1;
-              }
-            else if (Fl::event_button () == 3)
-              {
-                pixel2status (ax_obj, pos_x, pos_y,
-                              Fl::event_x (), Fl::event_y () - menu_dy ());
-                Matrix zoom_box (1,4,0);
-                zoom_box (0) = pos_x;
-                zoom_box (1) = pos_y;
-                zoom_box (2) =  Fl::event_x ();
-                zoom_box (3) =  Fl::event_y () - menu_dy ();
-                canvas->set_zoom_box (zoom_box);
-                canvas->zoom (true);
-                mark_modified ();
-                return 1;
-              }
-
-            break;
+                          if (pan_enabled ())
+                            ap.translate_view ("both", x0, x1, y0, y1);
+                          else if (rotate_enabled ())
+                            {
+                              double daz, del;
+                              daz = (Fl::event_x () - pos_x) / pos(2) * 360;
+                              del = (Fl::event_y () - menu_dy () - pos_y)
+                                    / pos(3) * 360;
+                              ap.rotate_view (del, daz);
+                            }
+                        }
+                      else
+                        {
+                          // move the position of the legend
+                          Matrix pos = ap.get_position ().matrix_value ();
+                          pos(0) += double (Fl::event_x () - pos_x)
+                                    / canvas->w ();
+                          pos(1) -= double (Fl::event_y () - menu_dy () - pos_y)
+                                    / canvas->h ();
+                          ap.set_position (pos);
+                        }
 
-          case FL_MOUSEWHEEL:
-            {
-              graphics_object ax =
-                gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (),
-                                                          Fl::event_y ()
-                                                          - menu_dy ()));
-              if (ax && ax.isa ("axes"))
+                      pos_x = Fl::event_x ();
+                      pos_y = Fl::event_y () - menu_dy ();
+                      mark_modified ();
+                    }
+                  return 1;
+                }
+              else if (Fl::event_button () == 3)
                 {
-                  axes::properties& ap =
-                    dynamic_cast<axes::properties&> (ax.get_properties ());
-
-                  // Control how fast to zoom when using scroll wheel.
-                  double wheel_zoom_speed = ap.get_mousewheelzoom ();
-
-                  // Determine if we're zooming in or out.
-                  const double factor =
-                    (Fl::event_dy () > 0) ? 1 / (1.0 - wheel_zoom_speed)
-                                          : 1.0 - wheel_zoom_speed;
-
-                  // Get the point we're zooming about.
-                  double x1, y1;
-                  pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (),
-                             x1, y1);
-
-                  ap.zoom_about_point ("both", x1, y1, factor, false);
+                  pixel2status (ax_obj, pos_x, pos_y,
+                                Fl::event_x (), Fl::event_y () - menu_dy ());
+                  Matrix zoom_box (1,4,0);
+                  zoom_box (0) = pos_x;
+                  zoom_box (1) = pos_y;
+                  zoom_box (2) =  Fl::event_x ();
+                  zoom_box (3) =  Fl::event_y () - menu_dy ();
+                  canvas->set_zoom_box (zoom_box);
+                  canvas->zoom (true);
                   mark_modified ();
                   return 1;
                 }
-            }
+
+              break;
+
+            case FL_MOUSEWHEEL:
+              {
+                graphics_object ax =
+                  gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (),
+                                          Fl::event_y ()
+                                          - menu_dy ()));
+                if (ax && ax.isa ("axes"))
+                  {
+                    axes::properties& ap =
+                      dynamic_cast<axes::properties&> (ax.get_properties ());
 
-          case FL_RELEASE:
-            if (fp.get_windowbuttonupfcn ().is_defined ())
-              {
-                set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
-                fp.execute_windowbuttonupfcn ();
+                    // Control how fast to zoom when using scroll wheel.
+                    double wheel_zoom_speed = ap.get_mousewheelzoom ();
+
+                    // Determine if we're zooming in or out.
+                    const double factor =
+                      (Fl::event_dy () > 0) ? 1 / (1.0 - wheel_zoom_speed)
+                      : 1.0 - wheel_zoom_speed;
+
+                    // Get the point we're zooming about.
+                    double x1, y1;
+                    pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (),
+                               x1, y1);
+
+                    ap.zoom_about_point ("both", x1, y1, factor, false);
+                    mark_modified ();
+                    return 1;
+                  }
               }
 
-            if ((Fl::event_button () == 1) && Fl::event_clicks ())
-              {
-                // Double click
-                set_on_ax_obj ("xlimmode", "auto");
-                set_on_ax_obj ("ylimmode", "auto");
-                set_on_ax_obj ("zlimmode", "auto");
-                return 1;
-              }
-            if (Fl::event_button () == 3)
-              {
-                // End of drag -- zoom.
-                if (canvas->zoom ())
-                  {
-                    canvas->zoom (false);
-                    double x0,y0,x1,y1;
-                    if (ax_obj && ax_obj.isa ("axes"))
-                      {
-                        axes::properties& ap = dynamic_cast<axes::properties&>
-                                               (ax_obj.get_properties ());
-                        pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
-                        int pos_x1 = Fl::event_x ();
-                        int pos_y1 = Fl::event_y () - menu_dy ();
-                        pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
-                        Matrix xl (1,2,0);
-                        Matrix yl (1,2,0);
-                        int dx = abs (pos_x - pos_x1);
-                        int dy = abs (pos_y - pos_y1);
-                        // Smallest zoom box must be 4 pixels square
-                        if ((dx > 4) && (dy > 4))
-                          {
-                            if (x0 < x1)
-                              {
-                                xl(0) = x0;
-                                xl(1) = x1;
-                              }
-                            else
-                              {
-                                xl(0) = x1;
-                                xl(1) = x0;
-                              }
-                            if (y0 < y1)
-                              {
-                                yl(0) = y0;
-                                yl(1) = y1;
-                              }
-                            else
-                              {
-                                yl(0) = y1;
-                                yl(1) = y0;
-                              }
-                            ap.zoom ("both", xl, yl);
-                          }
-                        mark_modified ();
-                        return 1;
-                      }
-                  }
-              }
-            break;
-          }
+            case FL_RELEASE:
+              if (fp.get_windowbuttonupfcn ().is_defined ())
+                {
+                  set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
+                  fp.execute_windowbuttonupfcn ();
+                }
+
+              if ((Fl::event_button () == 1) && Fl::event_clicks ())
+                {
+                  // Double click
+                  set_on_ax_obj ("xlimmode", "auto");
+                  set_on_ax_obj ("ylimmode", "auto");
+                  set_on_ax_obj ("zlimmode", "auto");
+                  return 1;
+                }
+              if (Fl::event_button () == 3)
+                {
+                  // End of drag -- zoom.
+                  if (canvas->zoom ())
+                    {
+                      canvas->zoom (false);
+                      double x0,y0,x1,y1;
+                      if (ax_obj && ax_obj.isa ("axes"))
+                        {
+                          axes::properties& ap = dynamic_cast<axes::properties&>
+                                                 (ax_obj.get_properties ());
+                          pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
+                          int pos_x1 = Fl::event_x ();
+                          int pos_y1 = Fl::event_y () - menu_dy ();
+                          pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
+                          Matrix xl (1,2,0);
+                          Matrix yl (1,2,0);
+                          int dx = abs (pos_x - pos_x1);
+                          int dy = abs (pos_y - pos_y1);
+                          // Smallest zoom box must be 4 pixels square
+                          if ((dx > 4) && (dy > 4))
+                            {
+                              if (x0 < x1)
+                                {
+                                  xl(0) = x0;
+                                  xl(1) = x1;
+                                }
+                              else
+                                {
+                                  xl(0) = x1;
+                                  xl(1) = x0;
+                                }
+                              if (y0 < y1)
+                                {
+                                  yl(0) = y0;
+                                  yl(1) = y1;
+                                }
+                              else
+                                {
+                                  yl(0) = y1;
+                                  yl(1) = y0;
+                                }
+                              ap.zoom ("both", xl, yl);
+                            }
+                          mark_modified ();
+                          return 1;
+                        }
+                    }
+                }
+              break;
+            }
       }
     //std::cout << "plot_window::handle wasn't interested in event " <<  fl_eventnames[event] << std::endl;
     return Fl_Window::handle (event);
   }
 };
 
 class figure_manager
 {
@@ -1852,17 +1854,18 @@ private:
           {
             // use position
             internal = true;
             pos = fp.get_boundingbox (internal);
           }
 
         idx2figprops (curr_index, fp);
 
-        windows[curr_index++] = new plot_window (pos(0), pos(1), pos(2), pos(3), fp, internal);
+        windows[curr_index++] = new plot_window (pos(0), pos(1), pos(2), pos(3),
+                                                 fp, internal);
       }
   }
 
   void do_delete_window (int idx)
   {
     wm_iterator win = windows.find (idx);
 
     if (win != windows.end ())
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -1487,18 +1487,20 @@ use @code{imwrite}.\n\
         }
     }
   static std::map<std::string, octave_idx_type> disposal_methods
     = init_reverse_disposal_methods ();
 
   const octave_idx_type nFrames = imvec.size ();
 
   const octave_idx_type quality = options.getfield ("quality").int_value ();
-  const ColumnVector delaytime = options.getfield ("delaytime").column_vector_value ();
-  const Array<std::string> disposalmethod = options.getfield ("disposalmethod").cellstr_value ();
+  const ColumnVector delaytime =
+    options.getfield ("delaytime").column_vector_value ();
+  const Array<std::string> disposalmethod =
+    options.getfield ("disposalmethod").cellstr_value ();
   for (octave_idx_type i = 0; i < nFrames; i++)
     {
       imvec[i].quality (quality);
       imvec[i].animationDelay (delaytime(i));
       imvec[i].gifDisposeMethod (disposal_methods[disposalmethod(i)]);
     }
 
   // If writemode is set to append, read the image and append to it. Even
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -105,18 +105,18 @@ instead.\n\
     {
       if (! (args(1).is_string () && args(2).is_string ()))
         {
           error ("__osmesa_print__: FILE and TERM has to be strings");
           return retval;
         }
 
 #ifndef HAVE_GL2PS_H
-        error ("__osmesa_print__: Octave has been compiled without gl2ps");
-        return retval;
+      error ("__osmesa_print__: Octave has been compiled without gl2ps");
+      return retval;
 #endif
     }
 
   int h = args(0).double_value ();
   graphics_object fobj = gh_manager::get_object (h);
   if (! (fobj && fobj.isa ("figure")))
     {
       error ("__osmesa_print__: H has to be a valid figure handle");
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -2542,21 +2542,21 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   audiorecorder *recorder = get_recorder (args(0));
 
-      if (! recorder)
-        {
-          print_usage ();
-          return retval;
-        }
+  if (! recorder)
+    {
+      print_usage ();
+      return retval;
+    }
 
   recorder->stop ();
 
 #else
 
   error ("portaudio not found on your system and thus audio functionality is not present");
 
 #endif
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -566,22 +566,22 @@ class_fevalStatic (const octave_value_li
           std::string meth_name = args(1).string_value ();
 
           if (! error_state)
             {
               cdef_method meth = cls.find_method (meth_name);
 
               if (meth.ok ())
                 {
-                    if (meth.is_static ())
-                      retval = meth.execute (args.splice (0, 2), nargout,
-                                             true, "fevalStatic");
-                    else
-                      error ("fevalStatic: method `%s' is not static",
-                             meth_name.c_str ());
+                  if (meth.is_static ())
+                    retval = meth.execute (args.splice (0, 2), nargout,
+                                           true, "fevalStatic");
+                  else
+                    error ("fevalStatic: method `%s' is not static",
+                           meth_name.c_str ());
                 }
               else
                 error ("fevalStatic: method not found: %s",
                        meth_name.c_str ());
             }
           else
             error ("fevalStatic: invalid method name, expected a string value");
         }
@@ -637,18 +637,20 @@ class_getConstant (const octave_value_li
 
 #define META_CLASS_CMP(OP, CLSA, CLSB, FUN) \
 static octave_value_list \
 class_ ## OP (const octave_value_list& args, int /* nargout */) \
 { \
   octave_value_list retval; \
 \
   if (args.length () == 2 \
-      && args(0).type_name () == "object" && args(1).type_name () == "object" \
-      && args(0).class_name () == "meta.class" && args(1).class_name () == "meta.class") \
+      && args(0).type_name () == "object" \
+      && args(1).type_name () == "object" \
+      && args(0).class_name () == "meta.class" \
+      && args(1).class_name () == "meta.class") \
     { \
       cdef_class clsa = to_cdef (args(0)); \
 \
       cdef_class clsb = to_cdef (args(1)); \
 \
       if (! error_state) \
         retval(0) = FUN (CLSA, CLSB); \
       else \
@@ -728,17 +730,18 @@ make_class (const std::string& name,
   else
     {
       bool all_handle_compatible = true;
       bool has_handle_class = false;
 
       for (std::list<cdef_class>::const_iterator it = super_list.begin ();
            it != super_list.end (); ++it)
         {
-          all_handle_compatible = all_handle_compatible && it->get ("HandleCompatible").bool_value ();
+          all_handle_compatible = all_handle_compatible
+                                  && it->get ("HandleCompatible").bool_value ();
           has_handle_class = has_handle_class || it->is_handle_class ();
         }
 
       if (has_handle_class && ! all_handle_compatible)
         ::error ("%s: cannot mix handle and non-HandleCompatible classes",
                  name.c_str ());
       else
         {
@@ -879,17 +882,18 @@ make_package (const std::string& nm,
 int octave_classdef::t_id (-1);
 
 const std::string octave_classdef::t_name ("object");
 
 void
 octave_classdef::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
-    (octave_classdef::t_name, "<unknown>", octave_value (new octave_classdef ()));
+    (octave_classdef::t_name, "<unknown>",
+     octave_value (new octave_classdef ()));
 }
 
 octave_value_list
 octave_classdef::subsref (const std::string& type,
                           const std::list<octave_value_list>& idx,
                           int nargout)
 {
   size_t skip = 0;
@@ -1102,71 +1106,71 @@ octave_classdef::is_instance_of (const s
 
 class octave_classdef_meta : public octave_function
 {
 public:
   octave_classdef_meta (const cdef_meta_object& obj)
     : object (obj) { }
 
   ~octave_classdef_meta (void)
-    { object.meta_release (); }
+  { object.meta_release (); }
 
   octave_function* function_value (bool = false) { return this; }
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            int nargout)
-    { return object.meta_subsref (type, idx, nargout); }
+  { return object.meta_subsref (type, idx, nargout); }
 
   octave_value
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx)
-    {
-      octave_value_list retval;
-
-      retval = subsref (type, idx, 1);
-
-      return (retval.length () > 0 ? retval(0) : octave_value ());
-    }
+  {
+    octave_value_list retval;
+
+    retval = subsref (type, idx, 1);
+
+    return (retval.length () > 0 ? retval(0) : octave_value ());
+  }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx)
-    {
-      // Emulate ()-type meta subsref
-
-      std::list<octave_value_list> l (1, idx);
-      std::string type ("(");
-
-      return subsref (type, l, nargout);
-    }
+  {
+    // Emulate ()-type meta subsref
+
+    std::list<octave_value_list> l (1, idx);
+    std::string type ("(");
+
+    return subsref (type, l, nargout);
+  }
 
   bool is_postfix_index_handled (char type) const
-    { return object.meta_is_postfix_index_handled (type); }
+  { return object.meta_is_postfix_index_handled (type); }
 
   bool
   is_classdef_constructor (const std::string& cname = std::string ()) const
-    {
-      bool retval = false;
-
-      if (object.is_class ())
-        {
-          if (cname.empty ())
-            retval = true;
-          else
-            {
-              cdef_class cls (object);
-
-              if (cls.get_name () == cname)
-                retval = true;
-            }
-        }
-
-      return retval;
-    }
+  {
+    bool retval = false;
+
+    if (object.is_class ())
+      {
+        if (cname.empty ())
+          retval = true;
+        else
+          {
+            cdef_class cls (object);
+
+            if (cls.get_name () == cname)
+              retval = true;
+          }
+      }
+
+    return retval;
+  }
 
 private:
   cdef_meta_object object;
 };
 
 //----------------------------------------------------------------------------
 
 class octave_classdef_superclass_ref : public octave_function
@@ -1178,155 +1182,155 @@ public:
   ~octave_classdef_superclass_ref (void) { }
 
   octave_function* function_value (bool = false) { return this; }
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            int nargout)
-    {
-      size_t skip = 0;
-      octave_value_list retval;
-
-      switch (type[0])
-        {
-        case '(':
-          skip = 1;
-          retval = do_multi_index_op (type.length () > 1 ? 1 : nargout,
-                                      idx.front ());
-          break;
-        default:
-          retval = do_multi_index_op (1, octave_value_list ());
-          break;
-        }
-
-      if (! error_state)
-        {
-          if (type.length () > skip && idx.size () > skip
-              && retval.length () > 0)
-            retval = retval(0).next_subsref (nargout, type, idx, skip);
-        }
-
-      return retval;
-    }
+  {
+    size_t skip = 0;
+    octave_value_list retval;
+
+    switch (type[0])
+      {
+      case '(':
+        skip = 1;
+        retval = do_multi_index_op (type.length () > 1 ? 1 : nargout,
+                                    idx.front ());
+        break;
+      default:
+        retval = do_multi_index_op (1, octave_value_list ());
+        break;
+      }
+
+    if (! error_state)
+      {
+        if (type.length () > skip && idx.size () > skip
+            && retval.length () > 0)
+          retval = retval(0).next_subsref (nargout, type, idx, skip);
+      }
+
+    return retval;
+  }
 
   octave_value
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx)
-    {
-      octave_value_list retval;
-
-      retval = subsref (type, idx, 1);
-
-      return (retval.length () > 0 ? retval(0) : octave_value ());
-    }
+  {
+    octave_value_list retval;
+
+    retval = subsref (type, idx, 1);
+
+    return (retval.length () > 0 ? retval(0) : octave_value ());
+  }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx)
-    {
-      octave_value_list retval;
-
-      std::string meth_name;
-      bool in_constructor;
-      cdef_class ctx;
-
-      ctx = get_class_context (meth_name, in_constructor);
-
-      if (! error_state && ctx.ok ())
-        {
-          std::string mname = args(0).string_value ();
-          std::string cname = args(1).string_value ();
-
-          cdef_class cls = lookup_class (cname);
-
-          if (! error_state)
-            {
-              if (in_constructor)
-                {
-                  if (is_direct_superclass (cls, ctx))
-                    {
-                      if (is_constructed_object (mname))
-                        {
-                          octave_value sym = symbol_table::varval (mname);
-
-                          cls.run_constructor (to_cdef_ref (sym), idx);
-
-                          retval(0) = sym;
-                        }
-                      else
-                        ::error ("cannot call superclass constructor with "
-                                 "variable `%s'", mname.c_str ());
-                    }
-                  else
-                    ::error ("`%s' is not a direct superclass of `%s'",
-                             cname.c_str (), ctx.get_name ().c_str ());
-                }
-              else
-                {
-                  if (mname == meth_name)
-                    {
-                      if (is_strict_superclass (cls, ctx))
-                        {
-                          // I see 2 possible implementations here:
-                          // 1) use cdef_object::subsref with a different class
-                          //    context; this avoids duplicating code, but
-                          //    assumes the object is always the first argument
-                          // 2) lookup the method manually and call
-                          //    cdef_method::execute; this duplicates part of
-                          //    logic in cdef_object::subsref, but avoid the
-                          //    assumption of 1)
-                          // Not being sure about the assumption of 1), I
-                          // go with option 2) for the time being.
-
-                          cdef_method meth = cls.find_method (meth_name, false);
-
-                          if (meth.ok ())
-                            retval = meth.execute (idx, nargout, true,
-                                                   meth_name);
-                          else
-                            ::error ("no method `%s' found in superclass `%s'",
-                                     meth_name.c_str (), cname.c_str ());
-                        }
-                      else
-                        ::error ("`%s' is not a superclass of `%s'",
-                                 cname.c_str (), ctx.get_name ().c_str ());
-                    }
-                  else
-                    ::error ("method name mismatch (`%s' != `%s')",
-                             mname.c_str (), meth_name.c_str ());
-                }
-            }
-        }
-      else if (! error_state)
-        ::error ("superclass calls can only occur in methods or constructors");
-
-      return retval;
-    }
+  {
+    octave_value_list retval;
+
+    std::string meth_name;
+    bool in_constructor;
+    cdef_class ctx;
+
+    ctx = get_class_context (meth_name, in_constructor);
+
+    if (! error_state && ctx.ok ())
+      {
+        std::string mname = args(0).string_value ();
+        std::string cname = args(1).string_value ();
+
+        cdef_class cls = lookup_class (cname);
+
+        if (! error_state)
+          {
+            if (in_constructor)
+              {
+                if (is_direct_superclass (cls, ctx))
+                  {
+                    if (is_constructed_object (mname))
+                      {
+                        octave_value sym = symbol_table::varval (mname);
+
+                        cls.run_constructor (to_cdef_ref (sym), idx);
+
+                        retval(0) = sym;
+                      }
+                    else
+                      ::error ("cannot call superclass constructor with "
+                               "variable `%s'", mname.c_str ());
+                  }
+                else
+                  ::error ("`%s' is not a direct superclass of `%s'",
+                           cname.c_str (), ctx.get_name ().c_str ());
+              }
+            else
+              {
+                if (mname == meth_name)
+                  {
+                    if (is_strict_superclass (cls, ctx))
+                      {
+                        // I see 2 possible implementations here:
+                        // 1) use cdef_object::subsref with a different class
+                        //    context; this avoids duplicating code, but
+                        //    assumes the object is always the first argument
+                        // 2) lookup the method manually and call
+                        //    cdef_method::execute; this duplicates part of
+                        //    logic in cdef_object::subsref, but avoid the
+                        //    assumption of 1)
+                        // Not being sure about the assumption of 1), I
+                        // go with option 2) for the time being.
+
+                        cdef_method meth = cls.find_method (meth_name, false);
+
+                        if (meth.ok ())
+                          retval = meth.execute (idx, nargout, true,
+                                                 meth_name);
+                        else
+                          ::error ("no method `%s' found in superclass `%s'",
+                                   meth_name.c_str (), cname.c_str ());
+                      }
+                    else
+                      ::error ("`%s' is not a superclass of `%s'",
+                               cname.c_str (), ctx.get_name ().c_str ());
+                  }
+                else
+                  ::error ("method name mismatch (`%s' != `%s')",
+                           mname.c_str (), meth_name.c_str ());
+              }
+          }
+      }
+    else if (! error_state)
+      ::error ("superclass calls can only occur in methods or constructors");
+
+    return retval;
+  }
 
 private:
   bool is_constructed_object (const std::string nm)
-    {
-      octave_function *of = octave_call_stack::current ();
-
-      if (of->is_classdef_constructor ())
-        {
-          octave_user_function *uf = of->user_function_value (true);
-
-          if (uf)
-            {
-              tree_parameter_list *ret_list = uf->return_list ();
-
-              if (ret_list && ret_list->length () == 1)
-                return (ret_list->front ()->name () == nm);
-            }
-        }
-
-      return false;
-    }
+  {
+    octave_function *of = octave_call_stack::current ();
+
+    if (of->is_classdef_constructor ())
+      {
+        octave_user_function *uf = of->user_function_value (true);
+
+        if (uf)
+          {
+            tree_parameter_list *ret_list = uf->return_list ();
+
+            if (ret_list && ret_list->length () == 1)
+              return (ret_list->front ()->name () == nm);
+          }
+      }
+
+    return false;
+  }
 
 private:
   octave_value_list args;
 };
 
 //----------------------------------------------------------------------------
 
 octave_map
@@ -1367,17 +1371,18 @@ cdef_object::map_value (void) const
                     break;
                 }
 
               if (! error_state)
                 retval.setfield (it->first, cvalue);
             }
           else
             {
-              Cell cvalue (dim_vector (1, 1), it->second.get_value (*this, false));
+              Cell cvalue (dim_vector (1, 1),
+                           it->second.get_value (*this, false));
 
               if (! error_state)
                 retval.setfield (it->first, cvalue);
             }
 
           if (error_state)
             break;
         }
@@ -1410,85 +1415,85 @@ cdef_object_scalar::subsref (const std::
   octave_value_list retval;
 
   if (! cls.ok ())
     return retval;
 
   switch (type[0])
     {
     case '.':
-        {
-          std::string name = (idx.front ())(0).string_value ();
-
-          cdef_method meth = cls.find_method (name);
-
-          if (meth.ok ())
-            {
-              int _nargout = (type.length () > 2 ? 1 : nargout);
-
-              octave_value_list args;
-
-              skip = 1;
-
-              if (type.length () > 1 && type[1] == '(')
-                {
-                  std::list<octave_value_list>::const_iterator it = idx.begin ();
-
-                  args = *++it;
-
-                  skip++;
-                }
-
-              if (meth.is_static ())
-                retval = meth.execute (args, _nargout, true, "subsref");
-              else
-                {
-                  refcount++;
-                  retval = meth.execute (cdef_object (this), args, _nargout,
-                                         true, "subsref");
-                }
-            }
-
-          if (skip == 0 && ! error_state)
-            {
-              cdef_property prop = cls.find_property (name);
-
-              if (prop.ok ())
-                {
-                  if (prop.is_constant ())
-                    retval(0) = prop.get_value (true, "subsref");
-                  else
-                    {
-                      refcount++;
-                      retval(0) = prop.get_value (cdef_object (this),
-                                                  true, "subsref");
-                    }
-
-                  skip = 1;
-                }
-              else
-                error ("subsref: unknown method or property: %s", name.c_str ());
-            }
-          break;
-        }
+      {
+        std::string name = (idx.front ())(0).string_value ();
+
+        cdef_method meth = cls.find_method (name);
+
+        if (meth.ok ())
+          {
+            int _nargout = (type.length () > 2 ? 1 : nargout);
+
+            octave_value_list args;
+
+            skip = 1;
+
+            if (type.length () > 1 && type[1] == '(')
+              {
+                std::list<octave_value_list>::const_iterator it = idx.begin ();
+
+                args = *++it;
+
+                skip++;
+              }
+
+            if (meth.is_static ())
+              retval = meth.execute (args, _nargout, true, "subsref");
+            else
+              {
+                refcount++;
+                retval = meth.execute (cdef_object (this), args, _nargout,
+                                       true, "subsref");
+              }
+          }
+
+        if (skip == 0 && ! error_state)
+          {
+            cdef_property prop = cls.find_property (name);
+
+            if (prop.ok ())
+              {
+                if (prop.is_constant ())
+                  retval(0) = prop.get_value (true, "subsref");
+                else
+                  {
+                    refcount++;
+                    retval(0) = prop.get_value (cdef_object (this),
+                                                true, "subsref");
+                  }
+
+                skip = 1;
+              }
+            else
+              error ("subsref: unknown method or property: %s", name.c_str ());
+          }
+        break;
+      }
 
     case '(':
-        {
-          refcount++;
-
-          cdef_object this_obj (this);
-
-          Array<cdef_object> arr (dim_vector (1, 1), this_obj);
-
-          cdef_object new_obj = cdef_object (new cdef_object_array (arr));
-
-          new_obj.set_class (get_class ());
-
-          retval = new_obj.subsref (type, idx, nargout, skip, cls, auto_add);
-        }
+      {
+        refcount++;
+
+        cdef_object this_obj (this);
+
+        Array<cdef_object> arr (dim_vector (1, 1), this_obj);
+
+        cdef_object new_obj = cdef_object (new cdef_object_array (arr));
+
+        new_obj.set_class (get_class ());
+
+        retval = new_obj.subsref (type, idx, nargout, skip, cls, auto_add);
+      }
       break;
 
     default:
       error ("object cannot be indexed with `%c'", type[0]);
       break;
     }
 
   return retval;
@@ -1501,91 +1506,91 @@ cdef_object_scalar::subsasgn (const std:
 {
   octave_value retval;
 
   cdef_class cls = get_class ();
 
   switch (type[0])
     {
     case '.':
-        {
-          std::string name = (idx.front ())(0).string_value ();
-
-          if (! error_state)
-            {
-              cdef_property prop = cls.find_property (name);
-
-              if (prop.ok ())
-                {
-                  if (prop.is_constant ())
-                    error ("subsasgn: cannot assign constant property: %s",
-                           name.c_str ());
-                  else
-                    {
-                      refcount++;
-
-                      cdef_object obj (this);
-
-                      if (type.length () == 1)
-                        {
-                          prop.set_value (obj, rhs, true, "subsasgn");
-
-                          if (! error_state)
-                            retval = to_ov (obj);
-                        }
-                      else
-                        {
-                          octave_value val =
-                            prop.get_value (obj, true, "subsasgn");
-
-                          if (! error_state)
-                            {
-                              std::list<octave_value_list> args (idx);
-
-                              args.erase (args.begin ());
-
-                              val = val.assign (octave_value::op_asn_eq,
-                                                type.substr (1), args, rhs);
-
-                              if (! error_state)
-                                {
-                                  if (val.class_name () != "object"
-                                      || ! to_cdef (val).is_handle_object ())
-                                    prop.set_value (obj, val, true, "subsasgn");
-
-                                  if (! error_state)
-                                    retval = to_ov (obj);
-                                }
-                            }
-                        }
-                    }
-                }
-              else
-                error ("subsasgn: unknown property: %s", name.c_str ());
-            }
-        }
+      {
+        std::string name = (idx.front ())(0).string_value ();
+
+        if (! error_state)
+          {
+            cdef_property prop = cls.find_property (name);
+
+            if (prop.ok ())
+              {
+                if (prop.is_constant ())
+                  error ("subsasgn: cannot assign constant property: %s",
+                         name.c_str ());
+                else
+                  {
+                    refcount++;
+
+                    cdef_object obj (this);
+
+                    if (type.length () == 1)
+                      {
+                        prop.set_value (obj, rhs, true, "subsasgn");
+
+                        if (! error_state)
+                          retval = to_ov (obj);
+                      }
+                    else
+                      {
+                        octave_value val =
+                          prop.get_value (obj, true, "subsasgn");
+
+                        if (! error_state)
+                          {
+                            std::list<octave_value_list> args (idx);
+
+                            args.erase (args.begin ());
+
+                            val = val.assign (octave_value::op_asn_eq,
+                                              type.substr (1), args, rhs);
+
+                            if (! error_state)
+                              {
+                                if (val.class_name () != "object"
+                                    || ! to_cdef (val).is_handle_object ())
+                                  prop.set_value (obj, val, true, "subsasgn");
+
+                                if (! error_state)
+                                  retval = to_ov (obj);
+                              }
+                          }
+                      }
+                  }
+              }
+            else
+              error ("subsasgn: unknown property: %s", name.c_str ());
+          }
+      }
       break;
 
     case '(':
-        {
-          refcount++;
-
-          cdef_object this_obj (this);
-
-          Array<cdef_object> arr (dim_vector (1, 1), this_obj);
-
-          cdef_object new_obj = cdef_object (new cdef_object_array (arr));
-
-          new_obj.set_class (get_class ());
-
-          octave_value tmp = new_obj.subsasgn (type, idx, rhs);
-
-          if (! error_state)
-            retval = tmp;
-        }
+      {
+        refcount++;
+
+        cdef_object this_obj (this);
+
+        Array<cdef_object> arr (dim_vector (1, 1), this_obj);
+
+        cdef_object new_obj = cdef_object (new cdef_object_array (arr));
+
+        new_obj.set_class (get_class ());
+
+        octave_value tmp = new_obj.subsasgn (type, idx, rhs);
+
+        if (! error_state)
+          retval = tmp;
+      }
       break;
 
     default:
       error ("subsasgn: object cannot be index with `%c'", type[0]);
       break;
     }
 
   return retval;
@@ -1615,54 +1620,54 @@ cdef_object_array::subsref (const std::s
 {
   octave_value_list retval;
 
   skip = 1;
 
   switch (type[0])
     {
     case '(':
-        {
-          const octave_value_list& ival = idx.front ();
-          bool is_scalar = true;
-          Array<idx_vector> iv (dim_vector (1, ival.length ()));
-
-          for (int i = 0; ! error_state && i < ival.length (); i++)
-            {
-              iv(i) = ival(i).index_vector ();
-              if (! error_state)
-                is_scalar = is_scalar && iv(i).is_scalar ();
-            }
-
-          if (! error_state)
-            {
-              Array<cdef_object> ires = array.index (iv, auto_add);
-
-              if (! error_state)
-                {
-                  // If resizing is enabled (auto_add = true), it's possible
-                  // indexing was out-of-bound and the result array contains
-                  // invalid cdef_objects.
-
-                  if (auto_add)
-                    fill_empty_values (ires);
-
-                  if (is_scalar)
-                    retval(0) = to_ov (ires(0));
-                  else
-                    {
-                      cdef_object array_obj (new cdef_object_array (ires));
-
-                      array_obj.set_class (get_class ());
-
-                      retval(0) = to_ov (array_obj);
-                    }
-                }
-            }
-        }
+      {
+        const octave_value_list& ival = idx.front ();
+        bool is_scalar = true;
+        Array<idx_vector> iv (dim_vector (1, ival.length ()));
+
+        for (int i = 0; ! error_state && i < ival.length (); i++)
+          {
+            iv(i) = ival(i).index_vector ();
+            if (! error_state)
+              is_scalar = is_scalar && iv(i).is_scalar ();
+          }
+
+        if (! error_state)
+          {
+            Array<cdef_object> ires = array.index (iv, auto_add);
+
+            if (! error_state)
+              {
+                // If resizing is enabled (auto_add = true), it's possible
+                // indexing was out-of-bound and the result array contains
+                // invalid cdef_objects.
+
+                if (auto_add)
+                  fill_empty_values (ires);
+
+                if (is_scalar)
+                  retval(0) = to_ov (ires(0));
+                else
+                  {
+                    cdef_object array_obj (new cdef_object_array (ires));
+
+                    array_obj.set_class (get_class ());
+
+                    retval(0) = to_ov (array_obj);
+                  }
+              }
+          }
+      }
       break;
 
     case '.':
       if (type.size () == 1 && idx.size () == 1)
         {
           Cell c (dims ());
 
           octave_idx_type n = array.numel ();
@@ -1895,23 +1900,25 @@ cdef_object_array::fill_empty_values (Ar
                 }
               else
                 arr.xelem (i) = obj.copy ();
             }
         }
     }
 }
 
-bool cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
+bool
+cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
 {
   return (is_constructed ()
           || ctor_list.find (cls) == ctor_list.end ());
 }
 
-bool cdef_object_scalar::is_partially_constructed_for (const cdef_class& cls) const
+bool
+cdef_object_scalar::is_partially_constructed_for (const cdef_class& cls) const
 {
   std::map< cdef_class, std::list<cdef_class> >::const_iterator it;
 
   if (is_constructed ())
     return true;
   else if ((it = ctor_list.find (cls)) == ctor_list.end ()
            || it->second.empty ())
     return true;
@@ -1935,19 +1942,20 @@ handle_cdef_object::~handle_cdef_object 
 value_cdef_object::~value_cdef_object (void)
 {
 #if DEBUG_TRACE
   std::cerr << "deleting " << get_class ().get_name ()
             << " object (value)" << std::endl;
 #endif
 }
 
-cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>& superclasses)
-     : cdef_meta_object_rep (), member_count (0), handle_class (false),
-       object_count (0), meta (false)
+cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>&
+                                            superclasses)
+  : cdef_meta_object_rep (), member_count (0), handle_class (false),
+    object_count (0), meta (false)
 {
   put ("SuperClasses", to_ov (superclasses));
   implicit_ctor_list = superclasses;
 }
 
 cdef_method
 cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
@@ -1992,73 +2000,73 @@ cdef_class::cdef_class_rep::find_method 
 
 class ctor_analyzer : public tree_walker
 {
 public:
   ctor_analyzer (const std::string& ctor, const std::string& obj)
     : tree_walker (), who (ctor), obj_name (obj) { }
 
   void visit_statement_list (tree_statement_list& t)
-    {
-      for (tree_statement_list::const_iterator it = t.begin ();
-           ! error_state && it != t.end (); ++it)
-        (*it)->accept (*this);
-    }
+  {
+    for (tree_statement_list::const_iterator it = t.begin ();
+         ! error_state && it != t.end (); ++it)
+      (*it)->accept (*this);
+  }
 
   void visit_statement (tree_statement& t)
-    {
-      if (t.is_expression ())
-        t.expression ()->accept (*this);
-    }
+  {
+    if (t.is_expression ())
+      t.expression ()->accept (*this);
+  }
 
   void visit_simple_assignment (tree_simple_assignment& t)
-    {
-      t.right_hand_side ()->accept (*this);
-    }
+  {
+    t.right_hand_side ()->accept (*this);
+  }
 
   void visit_multi_assignment (tree_multi_assignment& t)
-    {
-      t.right_hand_side ()->accept (*this);
-    }
+  {
+    t.right_hand_side ()->accept (*this);
+  }
 
   void visit_index_expression (tree_index_expression& t)
-    {
-      t.expression ()->accept (*this);
-    }
+  {
+    t.expression ()->accept (*this);
+  }
 
   void visit_funcall (tree_funcall& t)
-    {
-      octave_value fcn = t.function ();
-
-      if (fcn.is_function ())
-        {
-          octave_function *of = fcn.function_value (true);
-
-          if (of)
-            {
-              if (of->name () == "__superclass_reference__")
-                {
-                  octave_value_list args = t.arguments ();
-
-                  if (args(0).string_value () == obj_name)
-                    {
-                      std::string class_name = args(1).string_value ();
-
-                      cdef_class cls = lookup_class (class_name, false);
-
-                      if (cls.ok ())
-                        ctor_list.push_back (cls);
-                    }
-                }
-            }
-        }
-    }
+  {
+    octave_value fcn = t.function ();
+
+    if (fcn.is_function ())
+      {
+        octave_function *of = fcn.function_value (true);
+
+        if (of)
+          {
+            if (of->name () == "__superclass_reference__")
+              {
+                octave_value_list args = t.arguments ();
+
+                if (args(0).string_value () == obj_name)
+                  {
+                    std::string class_name = args(1).string_value ();
+
+                    cdef_class cls = lookup_class (class_name, false);
+
+                    if (cls.ok ())
+                      ctor_list.push_back (cls);
+                  }
+              }
+          }
+      }
+  }
 
   std::list<cdef_class> get_constructor_list (void) const
-    { return ctor_list; }
+  { return ctor_list; }
 
   // NO-OP
   void visit_anon_fcn_handle (tree_anon_fcn_handle&) { }
   void visit_argument_list (tree_argument_list&) { }
   void visit_binary_expression (tree_binary_expression&) { }
   void visit_break_command (tree_break_command&) { }
   void visit_colon_expression (tree_colon_expression&) { }
   void visit_continue_command (tree_continue_command&) { }
@@ -2133,18 +2141,20 @@ cdef_class::cdef_class_rep::install_meth
                   ctor_analyzer a (meth.get_name (), obj_name);
 
                   body->accept (a);
                   if (! error_state)
                     {
                       std::list<cdef_class> explicit_ctor_list
                         = a.get_constructor_list ();
 
-                      for (std::list<cdef_class>::const_iterator it = explicit_ctor_list.begin ();
-                           ! error_state && it != explicit_ctor_list.end (); ++it)
+                      for (std::list<cdef_class>::const_iterator
+                           it = explicit_ctor_list.begin ();
+                           ! error_state && it != explicit_ctor_list.end ();
+                           ++it)
                         {
 #if DEBUG_TRACE
                           std::cerr << "explicit superclass constructor: "
                                     << it->get_name () << std::endl;
 #endif
 
                           implicit_ctor_list.remove (*it);
                         }
@@ -2172,28 +2182,29 @@ cdef_class::cdef_class_rep::get_methods 
   find_methods (meths, false);
 
   if (! error_state)
     {
       Cell c (meths.size (), 1);
 
       int idx = 0;
 
-      for (std::map<std::string,cdef_method>::const_iterator it = meths.begin ();
-           it != meths.end (); ++it, ++idx)
+      for (std::map<std::string,cdef_method>::const_iterator
+            it = meths.begin (); it != meths.end (); ++it, ++idx)
         c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
 void
-cdef_class::cdef_class_rep::find_methods (std::map<std::string, cdef_method>& meths,
+cdef_class::cdef_class_rep::find_methods (std::map<std::string,
+                                          cdef_method>& meths,
                                           bool only_inherited)
 {
   load_all_methods ();
 
   method_const_iterator it;
 
   for (it = method_map.begin (); it != method_map.end (); ++it)
     {
@@ -2281,18 +2292,18 @@ cdef_class::cdef_class_rep::get_properti
   props = get_property_map (mode);
 
   if (! error_state)
     {
       Cell c (props.size (), 1);
 
       int idx = 0;
 
-      for (std::map<std::string,cdef_property>::const_iterator it = props.begin ();
-           it != props.end (); ++it, ++idx)
+      for (std::map<std::string,cdef_property>::const_iterator
+            it = props.begin (); it != props.end (); ++it, ++idx)
         c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
@@ -2302,17 +2313,18 @@ cdef_class::cdef_class_rep::get_property
   std::map<std::string,cdef_property> props;
 
   find_properties (props, mode);
 
   return props;
 }
 
 void
-cdef_class::cdef_class_rep::find_properties (std::map<std::string,cdef_property>& props,
+cdef_class::cdef_class_rep::find_properties (std::map<std::string,
+                                             cdef_property>& props,
                                              int mode)
 {
   property_const_iterator it;
 
   for (it = property_map.begin (); ! error_state && it != property_map.end ();
        ++it)
     {
       std::string nm = it->second.get_name ();
@@ -2560,17 +2572,18 @@ cdef_class::cdef_class_rep::meta_release
   cdef_manager::unregister_class (wrap ());
 }
 
 void
 cdef_class::cdef_class_rep::initialize_object (cdef_object& obj)
 {
   // Populate the object with default property values
 
-  std::list<cdef_class> super_classes = lookup_classes (get ("SuperClasses").cell_value ());
+  std::list<cdef_class> super_classes = lookup_classes (
+                                          get ("SuperClasses").cell_value ());
 
   if (! error_state)
     {
       for (std::list<cdef_class>::iterator it = super_classes.begin ();
            ! error_state && it != super_classes.end (); ++it)
         it->initialize_object (obj);
 
       if (! error_state)
@@ -2787,17 +2800,18 @@ cdef_class::make_meta_class (tree_classd
 #if DEBUG_TRACE
   std::cerr << "class: " << full_class_name << std::endl;
 #endif
 
   std::list<cdef_class> slist;
 
   if (t->superclass_list ())
     {
-      for (tree_classdef_superclass_list::iterator it = t->superclass_list ()->begin ();
+      for (tree_classdef_superclass_list::iterator it =
+             t->superclass_list ()->begin ();
            ! error_state && it != t->superclass_list ()->end (); ++it)
         {
           std::string sclass_name = (*it)->class_name ();
 
 #if DEBUG_TRACE
           std::cerr << "superclass: " << sclass_name << std::endl;
 #endif
 
@@ -2834,18 +2848,20 @@ cdef_class::make_meta_class (tree_classd
       if (! error_state && pack.ok ())
         retval.put ("ContainingPackage", to_ov (pack));
     }
 
   // Class attributes
 
   if (t->attribute_list ())
     {
-      for (tree_classdef_attribute_list::iterator it = t->attribute_list ()->begin ();
-           it != t->attribute_list ()->end (); ++it)
+      for (tree_classdef_attribute_list::iterator
+           it = t->attribute_list ()->begin ();
+           it != t->attribute_list ()->end ();
+           ++it)
         {
           std::string aname = (*it)->ident ()->name ();
           octave_value avalue = compute_attribute_value (*it);
 
 #if DEBUG_TRACE
           std::cerr << "class attribute: " << aname << " = "
                     << attribute_value_to_string (*it, avalue) << std::endl;
 #endif
@@ -2876,17 +2892,18 @@ cdef_class::make_meta_class (tree_classd
 #if DEBUG_TRACE
           std::cerr << "method block" << std::endl;
 #endif
 
           // Method attributes
 
           if ((*it)->attribute_list ())
             {
-              for (tree_classdef_attribute_list::iterator ait = (*it)->attribute_list ()->begin ();
+              for (tree_classdef_attribute_list::iterator ait =
+                     (*it)->attribute_list ()->begin ();
                    ait != (*it)->attribute_list ()->end (); ++ait)
                 {
                   std::string aname = (*ait)->ident ()->name ();
                   octave_value avalue = compute_attribute_value (*ait);
 
 #if DEBUG_TRACE
                   std::cerr << "method attribute: " << aname << " = "
                             << attribute_value_to_string (*ait, avalue)
@@ -2896,39 +2913,41 @@ cdef_class::make_meta_class (tree_classd
                   amap[aname] = avalue;
                 }
             }
 
           // Methods
 
           if ((*it)->element_list ())
             {
-              for (tree_classdef_methods_list::iterator mit = (*it)->element_list ()->begin ();
+              for (tree_classdef_methods_list::iterator mit =
+                     (*it)->element_list ()->begin ();
                    mit != (*it)->element_list ()->end (); ++mit)
                 {
                   std::string mname = mit->function_value ()->name ();
                   std::string mprefix = mname.substr (0, 4);
 
                   if (mprefix == "get.")
                     get_methods[mname.substr (4)] =
                       make_fcn_handle (*mit, full_class_name + ">" + mname);
                   else if (mprefix == "set.")
                     set_methods[mname.substr (4)] =
                       make_fcn_handle (*mit, full_class_name + ">" + mname);
                   else
                     {
                       cdef_method meth = make_method (retval, mname, *mit);
 
 #if DEBUG_TRACE
-                      std::cerr << (mname == class_name ? "constructor" : "method")
+                      std::cerr << (mname == class_name ? "constructor"
+                                                        : "method")
                                 << ": " << mname << std::endl;
 #endif
 
-                      for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
-                           ait != amap.end (); ++ait)
+                      for (std::map<std::string, octave_value>::iterator
+                           ait = amap.begin (); ait != amap.end (); ++ait)
                         meth.put (ait->first, ait->second);
 
                       retval.install_method (meth);
                     }
                 }
             }
         }
 
@@ -2940,18 +2959,20 @@ cdef_class::make_meta_class (tree_classd
           // TODO: This is an "extension" to Matlab behavior, which only
           // looks in the @-folder containing the original classdef
           // file. However, this is easier to implement it that way at
           // the moment.
 
           std::list<std::string> external_methods =
             load_path::methods (full_class_name);
 
-          for (std::list<std::string>::const_iterator it = external_methods.begin ();
-               it != external_methods.end (); ++it)
+          for (std::list<std::string>::const_iterator
+               it = external_methods.begin ();
+               it != external_methods.end ();
+               ++it)
             {
               // TODO: should we issue a warning if the method is already
               // defined in the classdef file?
 
               if (*it != class_name
                   && ! retval.find_method (*it, true).ok ())
                 {
                   // Create a dummy method that is used until the actual
@@ -2971,32 +2992,34 @@ cdef_class::make_meta_class (tree_classd
 
       // Property blocks
 
       // FIXME: default property expression should be able to call static
       //        methods of the class being constructed. A restricted CLASSNAME
       //        symbol should be added to the scope before evaluating default
       //        value expressions.
 
-      std::list<tree_classdef_properties_block *> pb_list = b->properties_list ();
+      std::list<tree_classdef_properties_block *> pb_list
+        = b->properties_list ();
 
       for (tree_classdef_body::properties_list_iterator it = pb_list.begin ();
            it != pb_list.end (); ++it)
         {
           std::map<std::string, octave_value> amap;
 
 #if DEBUG_TRACE
           std::cerr << "property block" << std::endl;
 #endif
 
           // Property attributes
 
           if ((*it)->attribute_list ())
             {
-              for (tree_classdef_attribute_list::iterator ait = (*it)->attribute_list ()->begin ();
+              for (tree_classdef_attribute_list::iterator ait =
+                     (*it)->attribute_list ()->begin ();
                    ait != (*it)->attribute_list ()->end (); ++ait)
                 {
                   std::string aname = (*ait)->ident ()->name ();
                   octave_value avalue = compute_attribute_value (*ait);
 
 #if DEBUG_TRACE
                   std::cerr << "property attribute: " << aname << " = "
                             << attribute_value_to_string (*ait, avalue)
@@ -3012,17 +3035,18 @@ cdef_class::make_meta_class (tree_classd
                     amap[aname] = avalue;
                 }
             }
 
           // Properties
 
           if ((*it)->element_list ())
             {
-              for (tree_classdef_property_list::iterator pit = (*it)->element_list ()->begin ();
+              for (tree_classdef_property_list::iterator pit =
+                     (*it)->element_list ()->begin ();
                    pit != (*it)->element_list ()->end (); ++pit)
                 {
                   std::string prop_name = (*pit)->ident ()->name ();
 
                   cdef_property prop = ::make_property (retval, prop_name);
 
 #if DEBUG_TRACE
                   std::cerr << "property: " << (*pit)->ident ()->name ()
@@ -3037,27 +3061,28 @@ cdef_class::make_meta_class (tree_classd
                       std::cerr << "property default: "
                                 << attribute_value_to_string (*pit, pvalue)
                                 << std::endl;
 #endif
 
                       prop.put ("DefaultValue", pvalue);
                     }
 
-                  // Install property attributes. This is done before assigning the
-                  // property accessors so we can do validationby using cdef_property
-                  // methods.
+                  // Install property attributes.  This is done before assigning
+                  // the property accessors so we can do validationby using
+                  // cdef_property methods.
 
                   for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
                        ait != amap.end (); ++ait)
                     prop.put (ait->first, ait->second);
 
-                  // Install property access methods, if any. Remove the accessor
-                  // methods from the temporary storage map, so we can detect which
-                  // ones are invalid and do not correspond to a defined property.
+                  // Install property access methods, if any. Remove the
+                  // accessor methods from the temporary storage map, so we can 
+                  // detect which ones are invalid and do not correspond to a
+                  // defined property.
 
                   std::map<std::string, octave_value>::iterator git =
                     get_methods.find (prop_name);
 
                   if (git != get_methods.end ())
                     {
                       make_function_of_class (retval, git->second);
                       prop.put ("GetMethod", git->second);
@@ -3474,35 +3499,35 @@ package_get_packages (const octave_value
 
       retval(0) = pack.get_packages ();
     }
 
   return retval;
 }
 
 static octave_value_list
-package_getAllPackages (const octave_value_list& /* args */,
-                        int /* nargout */)
+package_getAllPackages (const octave_value_list& /* args */, int /* nargout */)
 {
   std::map<std::string, cdef_package> toplevel_packages;
 
   std::list<std::string> names = load_path::get_all_package_names ();
 
   toplevel_packages["meta"] = cdef_manager::find_package ("meta", false,
                                                           false);
 
   for (std::list<std::string>::const_iterator it = names.begin ();
        it != names.end (); ++it)
     toplevel_packages[*it] = cdef_manager::find_package (*it, false, true);
 
   Cell c (toplevel_packages.size (), 1);
 
   int i = 0;
 
-  for (std::map<std::string, cdef_package>::const_iterator it = toplevel_packages.begin ();
+  for (std::map<std::string, cdef_package>::const_iterator it =
+         toplevel_packages.begin ();
        it != toplevel_packages.end (); ++it)
     c(i++,0) = to_ov (it->second);
 
   return octave_value_list (octave_value (c));
 }
 
 void
 cdef_package::cdef_package_rep::install_class (const cdef_class& cls,
@@ -3979,26 +4004,26 @@ DEFUN (__meta_get_package__, args, , "")
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__superclass_reference__, args, /* nargout */,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __superclass_reference__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (new octave_classdef_superclass_ref (args));
 }
 
 DEFUN (__meta_class_query__, args, /* nargout */,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __meta_class_query__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
@@ -4017,17 +4042,17 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (metaclass, args, /* nargout */,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} metaclass (obj)\n\
 Returns the meta.class object corresponding to the class of @var{obj}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -52,123 +52,123 @@ public:
 public:
   cdef_object_rep (void) : refcount (1) { }
 
   virtual ~cdef_object_rep (void) { }
 
   virtual cdef_class get_class (void) const;
 
   virtual void set_class (const cdef_class&)
-    { gripe_invalid_object ("set_class"); }
+  { gripe_invalid_object ("set_class"); }
 
   virtual cdef_object_rep* clone (void) const
-    {
-      gripe_invalid_object ("clone");
-      return new cdef_object_rep ();
-    }
+  {
+    gripe_invalid_object ("clone");
+    return new cdef_object_rep ();
+  }
 
   virtual cdef_object_rep* empty_clone (void) const
-    {
-      gripe_invalid_object ("empty_clone");
-      return new cdef_object_rep ();
-    }
+  {
+    gripe_invalid_object ("empty_clone");
+    return new cdef_object_rep ();
+  }
 
   virtual cdef_object_rep* copy (void) const
-    {
-      gripe_invalid_object ("copy");
-      return new cdef_object_rep ();
-    }
+  {
+    gripe_invalid_object ("copy");
+    return new cdef_object_rep ();
+  }
 
   virtual cdef_object_rep* make_array (void) const
-    {
-      gripe_invalid_object ("make_array");
-      return new cdef_object_rep ();
-    }
+  {
+    gripe_invalid_object ("make_array");
+    return new cdef_object_rep ();
+  }
 
   virtual bool is_array (void) const { return false; }
 
   virtual bool is_value_object (void) const { return false; }
 
   virtual bool is_handle_object (void) const { return false; }
 
   virtual bool is_meta_object (void) const { return false; }
 
   virtual Array<cdef_object> array_value (void) const
-    {
-      gripe_invalid_object ("array_value");
-      return Array<cdef_object> ();
-    }
+  {
+    gripe_invalid_object ("array_value");
+    return Array<cdef_object> ();
+  }
 
   virtual void put (const std::string&, const octave_value&)
-    { gripe_invalid_object ("put"); }
+  { gripe_invalid_object ("put"); }
 
   virtual octave_value get (const std::string&) const
-    {
-      gripe_invalid_object ("get");
-      return octave_value ();
-    }
+  {
+    gripe_invalid_object ("get");
+    return octave_value ();
+  }
 
   virtual octave_value_list
   subsref (const std::string&, const std::list<octave_value_list>&,
            int, size_t&, const cdef_class&, bool)
-    {
-      gripe_invalid_object ("subsref");
-      return octave_value_list ();
-    }
+  {
+    gripe_invalid_object ("subsref");
+    return octave_value_list ();
+  }
 
   virtual octave_value
   subsasgn (const std::string&, const std::list<octave_value_list>&,
             const octave_value&)
-    {
-      gripe_invalid_object ("subsasgn");
-      return octave_value ();
-    }
+  {
+    gripe_invalid_object ("subsasgn");
+    return octave_value ();
+  }
 
   virtual string_vector map_keys (void) const;
 
   virtual bool is_valid (void) const { return false; }
 
   std::string class_name (void) const;
 
   virtual void mark_for_construction (const cdef_class&)
-    { gripe_invalid_object ("mark_for_construction"); }
+  { gripe_invalid_object ("mark_for_construction"); }
 
   virtual bool is_constructed_for (const cdef_class&) const
-    {
-      gripe_invalid_object ("is_constructed_for");
-      return false;
-    }
+  {
+    gripe_invalid_object ("is_constructed_for");
+    return false;
+  }
 
   virtual bool is_partially_constructed_for (const cdef_class&) const
-    {
-      gripe_invalid_object ("is_partially_constructed_for");
-      return false;
-    }
+  {
+    gripe_invalid_object ("is_partially_constructed_for");
+    return false;
+  }
 
   virtual void mark_as_constructed (void)
-    { gripe_invalid_object ("mark_as_constructed"); }
+  { gripe_invalid_object ("mark_as_constructed"); }
 
   virtual void mark_as_constructed (const cdef_class&)
-    { gripe_invalid_object ("mark_as_constructed"); }
+  { gripe_invalid_object ("mark_as_constructed"); }
 
   virtual bool is_constructed (void) const
-    {
-      gripe_invalid_object ("is_constructed");
-      return false;
-    }
+  {
+    gripe_invalid_object ("is_constructed");
+    return false;
+  }
 
   virtual octave_idx_type static_count (void) const { return 0; }
 
   virtual void destroy (void) { delete this; }
 
   void release (void)
-    {
-      if (--refcount == static_count ())
-        destroy ();
-    }
+  {
+    if (--refcount == static_count ())
+      destroy ();
+  }
 
   virtual dim_vector dims (void) const { return dim_vector (); }
 
 protected:
   /* reference count */
   octave_refcount<octave_idx_type> refcount;
 
 protected:
@@ -176,170 +176,170 @@ protected:
   cdef_object_rep (const cdef_object_rep&)
     : refcount (1) { }
 
 private:
   /* No assignment */
   cdef_object_rep& operator = (const cdef_object_rep& );
 
   void gripe_invalid_object (const char *who) const
-    { error ("%s: invalid object", who); }
+  { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
   /* FIXME: use a null object */
   cdef_object (void)
-      : rep (new cdef_object_rep ()) { }
+    : rep (new cdef_object_rep ()) { }
 
   cdef_object (const cdef_object& obj)
     : rep (obj.rep)
-    {
-      rep->refcount++;
-    }
+  {
+    rep->refcount++;
+  }
 
   cdef_object (cdef_object_rep *r)
-      : rep (r) { }
+    : rep (r) { }
 
   virtual ~cdef_object (void)
-    { rep->release (); }
+  { rep->release (); }
 
   cdef_object& operator = (const cdef_object& obj)
-    {
-      if (rep != obj.rep)
-        {
-          rep->release ();
+  {
+    if (rep != obj.rep)
+      {
+        rep->release ();
 
-          rep = obj.rep;
-          rep->refcount++;
-        }
+        rep = obj.rep;
+        rep->refcount++;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   cdef_class get_class (void) const;
 
   void set_class (const cdef_class& cls) { rep->set_class (cls); }
 
   std::string class_name (void) const
-    { return rep->class_name (); }
+  { return rep->class_name (); }
 
   cdef_object clone (void) const
-    { return cdef_object (rep->clone ()); }
+  { return cdef_object (rep->clone ()); }
 
   cdef_object empty_clone (void) const
-    { return cdef_object (rep->empty_clone ()); }
+  { return cdef_object (rep->empty_clone ()); }
 
   dim_vector dims (void) const { return rep->dims (); }
 
   cdef_object make_array (void) const
-    { return cdef_object (rep->make_array ()); }
+  { return cdef_object (rep->make_array ()); }
 
   cdef_object copy (void) const
-    { return cdef_object (rep->copy ()); }
+  { return cdef_object (rep->copy ()); }
 
   bool is_array (void) const { return rep->is_array (); }
 
   bool is_value_object (void) const { return rep->is_value_object (); }
 
   bool is_handle_object (void) const { return rep->is_handle_object (); }
 
   bool is_meta_object (void) const { return rep->is_meta_object (); }
 
   Array<cdef_object> array_value (void) const { return rep->array_value (); }
 
   void put (const std::string& pname, const octave_value& val)
-    { rep->put (pname, val); }
+  { rep->put (pname, val); }
 
   octave_value get (const std::string& pname) const
-    { return rep->get (pname); }
+  { return rep->get (pname); }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context,
            bool auto_add = false)
-    { return rep->subsref (type, idx, nargout, skip, context, auto_add); }
+  { return rep->subsref (type, idx, nargout, skip, context, auto_add); }
 
   octave_value
   subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
             const octave_value& rhs, int ignore_copies = 0)
-    {
-      make_unique (ignore_copies);
-      return rep->subsasgn (type, idx, rhs);
-    }
+  {
+    make_unique (ignore_copies);
+    return rep->subsasgn (type, idx, rhs);
+  }
 
   string_vector map_keys (void) const { return rep->map_keys (); }
 
   octave_map map_value (void) const;
 
   const cdef_object_rep* get_rep (void) const { return rep; }
 
   bool ok (void) const { return rep->is_valid (); }
 
   void mark_for_construction (const cdef_class& cls)
-    { rep->mark_for_construction (cls); }
+  { rep->mark_for_construction (cls); }
 
   bool is_constructed (void) const { return rep->is_constructed (); }
 
   bool is_constructed_for (const cdef_class& cls) const
-    { return rep->is_constructed_for (cls); }
+  { return rep->is_constructed_for (cls); }
 
   bool is_partially_constructed_for (const cdef_class& cls) const
-    { return rep->is_partially_constructed_for (cls); }
+  { return rep->is_partially_constructed_for (cls); }
 
   void mark_as_constructed (void) { rep->mark_as_constructed (); }
 
   void mark_as_constructed (const cdef_class& cls)
-    { rep->mark_as_constructed (cls); }
+  { rep->mark_as_constructed (cls); }
 
   bool is (const cdef_object& obj) const { return rep == obj.rep; }
 
 protected:
   cdef_object_rep* get_rep (void) { return rep; }
 
   void make_unique (int ignore_copies)
-    {
-      if (rep->refcount > ignore_copies + 1)
-        *this = clone ();
-    }
+  {
+    if (rep->refcount > ignore_copies + 1)
+      *this = clone ();
+  }
 
 private:
   cdef_object_rep *rep;
 };
 
 class
 cdef_object_base : public cdef_object_rep
 {
 public:
   cdef_object_base (void)
     : cdef_object_rep (), klass ()
-    {
-      register_object ();
-    }
+  {
+    register_object ();
+  }
 
   ~cdef_object_base (void) { unregister_object (); }
 
   cdef_class get_class (void) const;
 
   void set_class (const cdef_class& cls);
 
   cdef_object_rep* empty_clone (void) const
-    { return new cdef_object_base (*this); }
+  { return new cdef_object_base (*this); }
 
   cdef_object_rep* make_array (void) const;
 
 protected:
   // Restricted copying!
   cdef_object_base (const cdef_object_base& obj)
     : cdef_object_rep (obj), klass (obj.klass)
-    {
-      register_object ();
-    }
+  {
+    register_object ();
+  }
 
 private:
   void register_object (void);
 
   void unregister_object (void);
 
 private:
   // The class of the object
@@ -355,17 +355,17 @@ cdef_object_array : public cdef_object_b
 {
 public:
   cdef_object_array (void) : cdef_object_base () { }
 
   cdef_object_array (const Array<cdef_object>& a)
     : cdef_object_base (), array (a) { }
 
   cdef_object_rep* clone (void) const
-    { return new cdef_object_array (*this); }
+  { return new cdef_object_array (*this); }
 
   dim_vector dims (void) const { return array.dims (); }
 
   bool is_valid (void) const { return true; }
 
   bool is_array (void) const { return true; }
 
   Array<cdef_object> array_value (void) const { return array; }
@@ -401,30 +401,30 @@ cdef_object_scalar : public cdef_object_
 public:
   cdef_object_scalar (void) : cdef_object_base () { }
 
   ~cdef_object_scalar (void) { }
 
   dim_vector dims (void) const { return dim_vector (1, 1); }
 
   void put (const std::string& pname, const octave_value& val)
-    { map.assign (pname, val); }
+  { map.assign (pname, val); }
 
   octave_value get (const std::string& pname) const
-    {
-      Cell val = map.contents (pname);
+  {
+    Cell val = map.contents (pname);
 
-      if (val.numel () > 0)
-        return val(0, 0);
-      else
-        {
-          error ("get: unknown slot: %s", pname.c_str ());
-          return octave_value ();
-        }
-    }
+    if (val.numel () > 0)
+      return val(0, 0);
+    else
+      {
+        error ("get: unknown slot: %s", pname.c_str ());
+        return octave_value ();
+      }
+  }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context,
            bool auto_add);
 
   octave_value
   subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
@@ -459,29 +459,29 @@ private:
   cdef_object_scalar& operator = (const cdef_object_scalar&);
 };
 
 class
 handle_cdef_object : public cdef_object_scalar
 {
 public:
   handle_cdef_object (void)
-      : cdef_object_scalar () { }
+    : cdef_object_scalar () { }
 
   ~handle_cdef_object (void);
 
   cdef_object_rep* clone (void) const
-    {
-      handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
-      obj->refcount++;
-      return obj;
-    }
+  {
+    handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
+    obj->refcount++;
+    return obj;
+  }
 
   cdef_object_rep* copy (void) const
-    { return new handle_cdef_object (*this); }
+  { return new handle_cdef_object (*this); }
 
   bool is_valid (void) const { return true; }
 
   bool is_handle_object (void) const { return true; }
 
 protected:
   // Restricted copying!
   handle_cdef_object (const handle_cdef_object& obj)
@@ -492,22 +492,22 @@ private:
   handle_cdef_object& operator = (const handle_cdef_object&);
 };
 
 class
 value_cdef_object : public cdef_object_scalar
 {
 public:
   value_cdef_object (void)
-      : cdef_object_scalar () { }
+    : cdef_object_scalar () { }
 
   ~value_cdef_object (void);
 
   cdef_object_rep* clone (void) const
-    { return new value_cdef_object (*this); }
+  { return new value_cdef_object (*this); }
 
   cdef_object_rep* copy (void) const { return clone (); }
 
   bool is_valid (void) const { return true; }
 
   bool is_value_object (void) const { return true; }
 
 private:
@@ -524,41 +524,41 @@ cdef_meta_object_rep : public handle_cde
 {
 public:
   cdef_meta_object_rep (void)
     : handle_cdef_object () { }
 
   ~cdef_meta_object_rep (void) { }
 
   cdef_object_rep* copy (void) const
-    { return new cdef_meta_object_rep (*this); }
+  { return new cdef_meta_object_rep (*this); }
 
   bool is_meta_object (void) const { return true; }
 
   virtual bool is_class (void) const { return false; }
 
   virtual bool is_property (void) const { return false; }
 
   virtual bool is_method (void) const { return false; }
 
   virtual bool is_package (void) const { return false; }
 
   virtual octave_value_list
   meta_subsref (const std::string& /* type */,
                 const std::list<octave_value_list>& /* idx */,
                 int /* nargout */)
-    {
-      ::error ("subsref: invalid meta object");
-      return octave_value_list ();
-    }
+  {
+    ::error ("subsref: invalid meta object");
+    return octave_value_list ();
+  }
 
   virtual void meta_release (void) { }
 
   virtual bool meta_is_postfix_index_handled (char /* type */) const
-    { return false; }
+  { return false; }
 
 protected:
   // Restricted copying!
   cdef_meta_object_rep (const cdef_meta_object_rep& obj)
     : handle_cdef_object (obj) { }
 
 private:
   // No assignment!
@@ -590,52 +590,52 @@ public:
 
   bool is_method (void) const { return get_rep ()->is_method (); }
 
   bool is_package (void) const { return get_rep ()->is_package (); }
 
   octave_value_list
   meta_subsref (const std::string& type,
                 const std::list<octave_value_list>& idx, int nargout)
-    { return get_rep ()->meta_subsref (type, idx, nargout); }
+  { return get_rep ()->meta_subsref (type, idx, nargout); }
 
   void meta_release (void) { get_rep ()->meta_release (); }
 
   bool meta_is_postfix_index_handled (char type) const
-    { return get_rep ()->meta_is_postfix_index_handled (type); }
+  { return get_rep ()->meta_is_postfix_index_handled (type); }
 
 private:
   cdef_meta_object_rep* get_rep (void)
-    { return dynamic_cast<cdef_meta_object_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<cdef_meta_object_rep *> (cdef_object::get_rep ()); }
 
   const cdef_meta_object_rep* get_rep (void) const
-    { return dynamic_cast<const cdef_meta_object_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<const cdef_meta_object_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_class : public cdef_meta_object
 {
 private:
 
   class
   cdef_class_rep : public cdef_meta_object_rep
   {
   public:
     cdef_class_rep (void)
-        : cdef_meta_object_rep (), member_count (0), handle_class (false),
-          object_count (0), meta (false) { }
+      : cdef_meta_object_rep (), member_count (0), handle_class (false),
+        object_count (0), meta (false) { }
 
     cdef_class_rep (const std::list<cdef_class>& superclasses);
 
     cdef_object_rep* copy (void) const { return new cdef_class_rep (*this); }
 
     bool is_class (void) const { return true; }
 
     std::string get_name (void) const
-      { return get ("Name").string_value (); }
+    { return get ("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
 
     bool is_abstract (void) const { return get ("Abstract").bool_value (); }
 
     bool is_sealed (void) const { return get ("Sealed").bool_value (); }
 
     cdef_method find_method (const std::string& nm, bool local = false);
@@ -662,17 +662,17 @@ private:
 
     octave_value_list
     meta_subsref (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
 
     void meta_release (void);
 
     bool meta_is_postfix_index_handled (char type) const
-      { return (type == '(' || type == '.'); }
+    { return (type == '(' || type == '.'); }
 
     octave_value construct (const octave_value_list& args);
 
     cdef_object construct_object (const octave_value_list& args);
 
     void initialize_object (cdef_object& obj);
 
     void run_constructor (cdef_object& obj, const octave_value_list& args);
@@ -683,29 +683,29 @@ private:
 
     void register_object (void) { object_count++; }
 
     void unregister_object (void) { object_count--; }
 
     octave_idx_type static_count (void) const { return member_count; }
 
     void destroy (void)
-      {
-        if (member_count)
-          {
-            refcount++;
-            cdef_class lock (this);
+    {
+      if (member_count)
+        {
+          refcount++;
+          cdef_class lock (this);
 
-            member_count = 0;
-            method_map.clear ();
-            property_map.clear ();
-          }
-        else
-          delete this;
-      }
+          member_count = 0;
+          method_map.clear ();
+          property_map.clear ();
+        }
+      else
+        delete this;
+    }
 
     void mark_as_meta_class (void) { meta = true; }
 
     bool is_meta_class (void) const { return meta; }
 
   private:
     void load_all_methods (void);
 
@@ -713,20 +713,20 @@ private:
 
     void find_properties (std::map<std::string,cdef_property>& props,
                           int mode = 0);
 
     void find_methods (std::map<std::string, cdef_method>& meths,
                        bool only_inherited);
 
     cdef_class wrap (void)
-      {
-        refcount++;
-        return cdef_class (this);
-      }
+    {
+      refcount++;
+      return cdef_class (this);
+    }
 
   private:
     // The @-directory were this class is loaded from.
     // (not used yet)
     std::string directory;
 
     // The methods defined by this class.
     std::map<std::string,cdef_method> method_map;
@@ -765,135 +765,135 @@ private:
         member_count (c.member_count), handle_class (c.handle_class),
         implicit_ctor_list (c.implicit_ctor_list),
         object_count (c.object_count), meta (c.meta) { }
   };
 
 public:
   // Create and invalid class object
   cdef_class (void)
-      : cdef_meta_object () { }
+    : cdef_meta_object () { }
 
   cdef_class (const std::string& nm,
               const std::list<cdef_class>& superclasses)
-      : cdef_meta_object (new cdef_class_rep (superclasses))
-    { get_rep ()->set_name (nm); }
+    : cdef_meta_object (new cdef_class_rep (superclasses))
+  { get_rep ()->set_name (nm); }
 
   cdef_class (const cdef_class& cls)
-      : cdef_meta_object (cls) { }
+    : cdef_meta_object (cls) { }
 
   cdef_class (const cdef_object& obj)
-      : cdef_meta_object (obj)
-    {
-      // This should never happen...
-      if (! is_class ())
-        error ("internal error: invalid assignment from %s to meta.class object",
-               class_name ().c_str ());
-    }
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_class ())
+      error ("internal error: invalid assignment from %s to meta.class object",
+             class_name ().c_str ());
+  }
 
   cdef_class& operator = (const cdef_class& cls)
-    {
-      cdef_object::operator= (cls);
+  {
+    cdef_object::operator= (cls);
 
-      return *this;
-    }
+    return *this;
+  }
 
   cdef_method find_method (const std::string& nm, bool local = false);
 
   void install_method (const cdef_method& meth)
-    { get_rep ()->install_method (meth); }
+  { get_rep ()->install_method (meth); }
 
   Cell get_methods (void) { return get_rep ()->get_methods (); }
 
   cdef_property find_property (const std::string& nm);
 
   void install_property (const cdef_property& prop)
-    { get_rep ()->install_property (prop); }
+  { get_rep ()->install_property (prop); }
 
   Cell get_properties (int mode = property_normal)
-    { return get_rep ()->get_properties (mode); }
+  { return get_rep ()->get_properties (mode); }
 
   std::map<std::string, cdef_property>
   get_property_map (int mode = property_normal)
-    { return get_rep ()->get_property_map (mode); }
+  { return get_rep ()->get_property_map (mode); }
 
   string_vector get_names (void) { return get_rep ()->get_names (); }
 
   bool is_abstract (void) const { return get_rep ()->is_abstract (); }
 
   bool is_sealed (void) const { return get_rep ()->is_sealed (); }
 
   void set_directory (const std::string& dir)
-    { get_rep ()->set_directory (dir); }
+  { get_rep ()->set_directory (dir); }
 
   std::string get_directory (void) const
-    { return get_rep ()->get_directory (); }
+  { return get_rep ()->get_directory (); }
 
   std::string get_name (void) const
-    { return get_rep ()->get_name (); }
+  { return get_rep ()->get_name (); }
 
   bool is_builtin (void) const
-    { return get_directory ().empty (); }
+  { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
-    { get_rep ()->delete_object (obj); }
+  { get_rep ()->delete_object (obj); }
 
   static cdef_class make_meta_class (tree_classdef* t,
                                      bool is_at_folder = false);
 
   octave_function* get_method_function (const std::string& nm);
 
   octave_function* get_constructor_function (void)
-    { return get_method_function (get_name ()); }
+  { return get_method_function (get_name ()); }
 
   octave_value construct (const octave_value_list& args)
-    { return get_rep ()->construct (args); }
+  { return get_rep ()->construct (args); }
 
   cdef_object construct_object (const octave_value_list& args)
-    { return get_rep ()->construct_object (args); }
+  { return get_rep ()->construct_object (args); }
 
   void initialize_object (cdef_object& obj)
-    { get_rep ()->initialize_object (obj); }
+  { get_rep ()->initialize_object (obj); }
 
   void run_constructor (cdef_object& obj, const octave_value_list& args)
-    { get_rep ()->run_constructor (obj, args); }
+  { get_rep ()->run_constructor (obj, args); }
 
   void mark_as_handle_class (void)
-    { get_rep ()->mark_as_handle_class (); }
+  { get_rep ()->mark_as_handle_class (); }
 
   bool is_handle_class (void) const
-    { return get_rep ()->is_handle_class (); }
+  { return get_rep ()->is_handle_class (); }
 
   void mark_as_meta_class (void) { get_rep ()->mark_as_meta_class (); }
 
   bool is_meta_class (void) const { return get_rep ()->is_meta_class (); }
 
   static const cdef_class& meta_class (void) { return _meta_class; }
   static const cdef_class& meta_property (void) { return _meta_property; }
   static const cdef_class& meta_method (void) { return _meta_method; }
   static const cdef_class& meta_package (void) { return _meta_package; }
 
   void register_object (void) { get_rep ()->register_object (); }
 
   void unregister_object (void) { get_rep ()->unregister_object (); }
 
 public:
   enum
-    {
-      property_normal,
-      property_inherited,
-      property_all
-    };
+  {
+    property_normal,
+    property_inherited,
+    property_all
+  };
 
 private:
   cdef_class_rep* get_rep (void)
-    { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
 
   const cdef_class_rep* get_rep (void) const
-    { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
 
 private:
   static cdef_class _meta_class;
   static cdef_class _meta_property;
@@ -924,17 +924,17 @@ cdef_property : public cdef_meta_object
 
 private:
 
   class
   cdef_property_rep : public cdef_meta_object_rep
   {
   public:
     cdef_property_rep (void)
-        : cdef_meta_object_rep () { }
+      : cdef_meta_object_rep () { }
 
     cdef_object_rep* copy (void) const { return new cdef_property_rep (*this); }
 
     bool is_property (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
@@ -958,93 +958,93 @@ private:
 
   private:
     cdef_property_rep (const cdef_property_rep& p)
       : cdef_meta_object_rep (p) { }
 
     bool is_recursive_set (const cdef_object& obj) const;
 
     cdef_property wrap (void)
-      {
-        refcount++;
-        return cdef_property (this);
-      }
+    {
+      refcount++;
+      return cdef_property (this);
+    }
   };
 
 public:
   cdef_property (void) : cdef_meta_object () { }
 
   cdef_property (const std::string& nm)
-      : cdef_meta_object (new cdef_property_rep ())
-    { get_rep ()->set_name (nm); }
+    : cdef_meta_object (new cdef_property_rep ())
+  { get_rep ()->set_name (nm); }
 
   cdef_property (const cdef_property& prop)
-      : cdef_meta_object (prop) { }
+    : cdef_meta_object (prop) { }
 
   cdef_property (const cdef_object& obj)
-      : cdef_meta_object (obj)
-    {
-      // This should never happen...
-      if (! is_property ())
-        error ("internal error: invalid assignment from %s to meta.property object",
-               class_name ().c_str ());
-    }
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_property ())
+      error ("internal error: invalid assignment from %s to meta.property object",
+             class_name ().c_str ());
+  }
 
   cdef_property& operator = (const cdef_property& prop)
-    {
-      cdef_object::operator= (prop);
+  {
+    cdef_object::operator= (prop);
 
-      return *this;
-    }
+    return *this;
+  }
 
   octave_value get_value (const cdef_object& obj, bool do_check_access = true,
                           const std::string& who = std::string ())
-    { return get_rep ()->get_value (obj, do_check_access, who); }
+  { return get_rep ()->get_value (obj, do_check_access, who); }
 
   octave_value get_value (bool do_check_access = true,
                           const std::string& who = std::string ())
-    { return get_rep ()->get_value (do_check_access, who); }
+  { return get_rep ()->get_value (do_check_access, who); }
 
   void set_value (cdef_object& obj, const octave_value& val,
                   bool do_check_access = true,
                   const std::string& who = std::string ())
-    { get_rep ()->set_value (obj, val, do_check_access, who); }
+  { get_rep ()->set_value (obj, val, do_check_access, who); }
 
   bool check_get_access (void) const
-    { return get_rep ()->check_get_access (); }
+  { return get_rep ()->check_get_access (); }
 
   bool check_set_access (void) const
-    { return get_rep ()->check_set_access (); }
+  { return get_rep ()->check_set_access (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_constant (void) const { return get_rep ()->is_constant (); }
 
 private:
   cdef_property_rep* get_rep (void)
-    { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
 
   const cdef_property_rep* get_rep (void) const
-    { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
 };
 
 class
 cdef_method : public cdef_meta_object
 {
   friend class cdef_class;
 
 private:
 
   class
   cdef_method_rep : public cdef_meta_object_rep
   {
   public:
     cdef_method_rep (void)
       : cdef_meta_object_rep (), function (), dispatch_type ()
-      { }
+    { }
 
     cdef_object_rep* copy (void) const { return new cdef_method_rep(*this); }
 
     bool is_method (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
@@ -1055,17 +1055,17 @@ private:
 
     void set_function (const octave_value& fcn) { function = fcn; }
 
     bool check_access (void) const;
 
     bool is_external (void) const { return ! dispatch_type.empty (); }
 
     void mark_as_external (const std::string& dtype)
-      { dispatch_type = dtype; }
+    { dispatch_type = dtype; }
 
     octave_value_list execute (const octave_value_list& args, int nargout,
                                bool do_check_access = true,
                                const std::string& who = std::string ());
 
     octave_value_list execute (const cdef_object& obj,
                                const octave_value_list& args, int nargout,
                                bool do_check_access = true,
@@ -1073,105 +1073,105 @@ private:
 
     bool is_constructor (void) const;
 
     octave_value_list
     meta_subsref (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
 
     bool meta_is_postfix_index_handled (char type) const
-      { return (type == '(' || type == '.'); }
+    { return (type == '(' || type == '.'); }
 
   private:
     cdef_method_rep (const cdef_method_rep& m)
       : cdef_meta_object_rep (m), function (m.function),
         dispatch_type (m.dispatch_type)
-      { }
+    { }
 
     void check_method (void);
 
     cdef_method wrap (void)
-      {
-        refcount++;
-        return cdef_method (this);
-      }
+    {
+      refcount++;
+      return cdef_method (this);
+    }
 
   private:
     octave_value function;
 
     // When non-empty, the method is externally defined and this member
     // is used to cache the dispatch type to look for the method.
     std::string dispatch_type;
   };
 
 public:
   cdef_method (void) : cdef_meta_object () { }
 
   cdef_method (const std::string& nm)
-      : cdef_meta_object (new cdef_method_rep ())
-    { get_rep ()->set_name (nm); }
+    : cdef_meta_object (new cdef_method_rep ())
+  { get_rep ()->set_name (nm); }
 
   cdef_method (const cdef_method& meth)
-      : cdef_meta_object (meth) { }
+    : cdef_meta_object (meth) { }
 
   cdef_method (const cdef_object& obj)
-      : cdef_meta_object (obj)
-    {
-      // This should never happen...
-      if (! is_method ())
-        error ("internal error: invalid assignment from %s to meta.method object",
-               class_name ().c_str ());
-    }
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_method ())
+      error ("internal error: invalid assignment from %s to meta.method object",
+             class_name ().c_str ());
+  }
 
   cdef_method& operator = (const cdef_method& meth)
-    {
-      cdef_object::operator= (meth);
+  {
+    cdef_object::operator= (meth);
 
-      return *this;
-    }
+    return *this;
+  }
 
   /* normal invokation */
   octave_value_list execute (const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
-    { return get_rep ()->execute (args, nargout, do_check_access, who); }
+  { return get_rep ()->execute (args, nargout, do_check_access, who); }
 
   /* dot-invokation: object is pushed as 1st argument */
   octave_value_list execute (const cdef_object& obj,
                              const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
-    { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
+  { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
 
   bool check_access (void) const { return get_rep ()->check_access (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   bool is_static (void) const { return get_rep ()->is_static (); }
 
   void set_function (const octave_value& fcn)
-    { get_rep ()->set_function (fcn); }
+  { get_rep ()->set_function (fcn); }
 
   octave_value get_function (void) const
-    { return get_rep ()->get_function (); }
+  { return get_rep ()->get_function (); }
 
   bool is_constructor (void) const
-    { return get_rep ()->is_constructor (); }
+  { return get_rep ()->is_constructor (); }
 
   bool is_external (void) const { return get_rep ()->is_external (); }
 
   void mark_as_external (const std::string& dtype)
-    { get_rep ()->mark_as_external (dtype); }
+  { get_rep ()->mark_as_external (dtype); }
 
 private:
   cdef_method_rep* get_rep (void)
-    { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
 
   const cdef_method_rep* get_rep (void) const
-    { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object_rep::get_class (void) const
 {
   gripe_invalid_object ("get_class");
   return cdef_class ();
 }
@@ -1277,38 +1277,38 @@ private:
 
     Cell get_functions (void) const;
 
     Cell get_packages (void) const;
 
     octave_idx_type static_count (void) const { return member_count; }
 
     void destroy (void)
-      {
-        if (member_count)
-          {
-            refcount++;
-            cdef_package lock (this);
+    {
+      if (member_count)
+        {
+          refcount++;
+          cdef_package lock (this);
 
-            member_count = 0;
-            class_map.clear ();
-            package_map.clear ();
-          }
-        else
-          delete this;
-      }
+          member_count = 0;
+          class_map.clear ();
+          package_map.clear ();
+        }
+      else
+        delete this;
+    }
 
     octave_value_list
     meta_subsref (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
 
     void meta_release (void);
 
     bool meta_is_postfix_index_handled (char type) const
-      { return (type == '.'); }
+    { return (type == '.'); }
 
     octave_value find (const std::string& nm);
 
   private:
     std::string full_name;
     std::map<std::string, cdef_class> class_map;
     std::map<std::string, octave_value> function_map;
     std::map<std::string, cdef_package> package_map;
@@ -1324,106 +1324,106 @@ private:
     typedef std::map<std::string, cdef_package>::iterator package_iterator;
     typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
 
   private:
     cdef_package_rep (const cdef_package_rep& p)
       : cdef_meta_object_rep (p), full_name (p.full_name),
         class_map (p.class_map), function_map (p.function_map),
         package_map (p.package_map), member_count (p.member_count)
-      { }
+    { }
 
     cdef_package wrap (void)
-      {
-        refcount++;
-        return cdef_package (this);
-      }
+    {
+      refcount++;
+      return cdef_package (this);
+    }
   };
 
 public:
   cdef_package (void) : cdef_meta_object () { }
 
   cdef_package (const std::string& nm)
-      : cdef_meta_object (new cdef_package_rep ())
-    { get_rep ()->set_name (nm); }
+    : cdef_meta_object (new cdef_package_rep ())
+  { get_rep ()->set_name (nm); }
 
   cdef_package (const cdef_package& pack)
     : cdef_meta_object (pack) { }
 
   cdef_package (const cdef_object& obj)
-      : cdef_meta_object (obj)
-    {
-      // This should never happen...
-      if (! is_package ())
-        error ("internal error: invalid assignment from %s to meta.package object",
-               class_name ().c_str ());
-    }
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_package ())
+      error ("internal error: invalid assignment from %s to meta.package object",
+             class_name ().c_str ());
+  }
 
   cdef_package& operator = (const cdef_package& pack)
-    {
-      cdef_object::operator= (pack);
+  {
+    cdef_object::operator= (pack);
 
-      return *this;
-    }
+    return *this;
+  }
 
   void install_class (const cdef_class& cls, const std::string& nm)
-    { get_rep ()->install_class (cls, nm); }
+  { get_rep ()->install_class (cls, nm); }
 
   void install_function (const octave_value& fcn, const std::string& nm)
-    { get_rep ()->install_function (fcn, nm); }
+  { get_rep ()->install_function (fcn, nm); }
 
   void install_package (const cdef_package& pack, const std::string& nm)
-    { get_rep ()->install_package (pack, nm); }
+  { get_rep ()->install_package (pack, nm); }
 
   Cell get_classes (void) const
-    { return get_rep ()->get_classes (); }
+  { return get_rep ()->get_classes (); }
 
   Cell get_functions (void) const
-    { return get_rep ()->get_functions (); }
+  { return get_rep ()->get_functions (); }
 
   Cell get_packages (void) const
-    { return get_rep ()->get_packages (); }
+  { return get_rep ()->get_packages (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
 
   static const cdef_package& meta (void) { return _meta; }
 
 private:
   cdef_package_rep* get_rep (void)
-    { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
 
   const cdef_package_rep* get_rep (void) const
-    { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
+  { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
 
 private:
   static cdef_package _meta;
 
   friend void install_classdef (void);
 };
 
 class
 octave_classdef : public octave_base_value
 {
 public:
   octave_classdef (void)
-      : octave_base_value (), object () { }
+    : octave_base_value (), object () { }
 
   octave_classdef (const cdef_object& obj)
-      : octave_base_value (), object (obj) { }
+    : octave_base_value (), object (obj) { }
 
   octave_classdef (const octave_classdef& obj)
-      : octave_base_value (obj), object (obj.object) { }
+    : octave_base_value (obj), object (obj.object) { }
 
   octave_base_value* clone (void) const
-    { return new octave_classdef (object.clone ()); }
+  { return new octave_classdef (object.clone ()); }
 
   octave_base_value* empty_clone (void) const
-    { return new octave_classdef (object.empty_clone ()); }
+  { return new octave_classdef (object.empty_clone ()); }
 
   cdef_object get_object (void) const { return object; }
 
   cdef_object& get_object_ref (void) { return object; }
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return false; }
@@ -1444,20 +1444,20 @@ public:
   bool is_instance_of (const std::string& cls_name) const;
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list retval = subsref (type, idx, 1);
-      return (retval.length () > 0 ? retval(0) : octave_value ());
-    }
+  {
+    octave_value_list retval = subsref (type, idx, 1);
+    return (retval.length () > 0 ? retval(0) : octave_value ());
+  }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
@@ -1542,135 +1542,135 @@ OCTINTERP_API void install_classdef (voi
 class
 cdef_manager
 {
 public:
 
   static cdef_class find_class (const std::string& name,
                                 bool error_if_not_found = true,
                                 bool load_if_not_found = true)
-    {
-      if (instance_ok ())
-        return instance->do_find_class (name, error_if_not_found,
-                                        load_if_not_found);
+  {
+    if (instance_ok ())
+      return instance->do_find_class (name, error_if_not_found,
+                                      load_if_not_found);
 
-      return cdef_class ();
-    }
+    return cdef_class ();
+  }
 
   static octave_function* find_method_symbol (const std::string& method_name,
-                                              const std::string& class_name)
-    {
-      if (instance_ok ())
-        return instance->do_find_method_symbol (method_name, class_name);
+      const std::string& class_name)
+  {
+    if (instance_ok ())
+      return instance->do_find_method_symbol (method_name, class_name);
 
-      return 0;
-    }
+    return 0;
+  }
 
   static cdef_package find_package (const std::string& name,
                                     bool error_if_not_found = true,
                                     bool load_if_not_found = true)
-    {
-      if (instance_ok ())
-        return instance->do_find_package (name, error_if_not_found,
-                                          load_if_not_found);
+  {
+    if (instance_ok ())
+      return instance->do_find_package (name, error_if_not_found,
+                                        load_if_not_found);
 
-      return cdef_package ();
-    }
+    return cdef_package ();
+  }
 
   static octave_function* find_package_symbol (const std::string& pack_name)
-    {
-      if (instance_ok ())
-        return instance->do_find_package_symbol (pack_name);
+  {
+    if (instance_ok ())
+      return instance->do_find_package_symbol (pack_name);
 
-      return 0;
-    }
+    return 0;
+  }
 
   static void register_class (const cdef_class& cls)
-    {
-      if (instance_ok ())
-        instance->do_register_class (cls);
-    }
+  {
+    if (instance_ok ())
+      instance->do_register_class (cls);
+  }
 
   static void unregister_class (const cdef_class& cls)
-    {
-      if (instance_ok ())
-        instance->do_unregister_class (cls);
-    }
+  {
+    if (instance_ok ())
+      instance->do_unregister_class (cls);
+  }
 
   static void register_package (const cdef_package& pkg)
-    {
-      if (instance_ok ())
-        instance->do_register_package (pkg);
-    }
+  {
+    if (instance_ok ())
+      instance->do_register_package (pkg);
+  }
 
   static void unregister_package (const cdef_package& pkg)
-    {
-      if (instance_ok ())
-        instance->do_unregister_package (pkg);
-    }
+  {
+    if (instance_ok ())
+      instance->do_unregister_package (pkg);
+  }
 
 private:
 
   cdef_manager (void) { }
 
   cdef_manager (const cdef_manager&);
 
   cdef_manager& operator = (const cdef_manager&);
 
   ~cdef_manager (void) { }
 
   static void create_instance (void);
 
   static bool instance_ok (void)
-    {
-      bool retval = true;
+  {
+    bool retval = true;
 
-      if (! instance)
-        create_instance ();
+    if (! instance)
+      create_instance ();
 
-      if (! instance)
-        {
-          ::error ("unable to create cdef_manager!");
+    if (! instance)
+      {
+        ::error ("unable to create cdef_manager!");
 
-          retval = false;
-        }
+        retval = false;
+      }
 
-      return retval;
-    }
+    return retval;
+  }
 
   static void cleanup_instance (void)
-    {
-      delete instance;
+  {
+    delete instance;
 
-      instance = 0;
-    }
+    instance = 0;
+  }
 
   cdef_class do_find_class (const std::string& name, bool error_if_not_found,
                             bool load_if_not_found);
 
   octave_function* do_find_method_symbol (const std::string& method_name,
                                           const std::string& class_name);
 
   cdef_package do_find_package (const std::string& name,
                                 bool error_if_not_found,
                                 bool load_if_not_found);
 
   octave_function* do_find_package_symbol (const std::string& pack_name);
 
   void do_register_class (const cdef_class& cls)
-    { all_classes[cls.get_name ()] = cls; }
+  { all_classes[cls.get_name ()] = cls; }
 
   void do_unregister_class (const cdef_class& cls)
-    { all_classes.erase(cls.get_name ()); }
+  { all_classes.erase(cls.get_name ()); }
 
   void do_register_package (const cdef_package& pkg)
-    { all_packages[pkg.get_name ()] = pkg; }
+  { all_packages[pkg.get_name ()] = pkg; }
 
   void do_unregister_package (const cdef_package& pkg)
-    { all_packages.erase(pkg.get_name ()); }
+  { all_packages.erase(pkg.get_name ()); }
 
 private:
 
   // The single cdef_manager instance
   static cdef_manager *instance;
 
   // All registered/loaded classes
   std::map<std::string, cdef_class> all_classes;
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -82,17 +82,17 @@ public:
 
   virtual bool is_subfunction (void) const { return false; }
 
   virtual bool is_class_constructor (const std::string& = std::string ()) const
   { return false; }
 
   virtual bool
   is_classdef_constructor (const std::string& = std::string ()) const
-    { return false; }
+  { return false; }
 
   virtual bool is_class_method (const std::string& = std::string ()) const
   { return false; }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
@@ -156,33 +156,33 @@ public:
 
   void mark_relative (void) { relative = true; }
 
   bool is_relative (void) const { return relative; }
 
   std::string name (void) const { return my_name; }
 
   std::string canonical_name (void) const
-    {
-      if (xpackage_name.empty ())
-        return my_name;
-      else
-        return xpackage_name + "." + my_name;
-    }
+  {
+    if (xpackage_name.empty ())
+      return my_name;
+    else
+      return xpackage_name + "." + my_name;
+  }
 
   void document (const std::string& ds) { doc = ds; }
 
   std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
   virtual void accept (tree_walker&) { }
 
   virtual bool is_postfix_index_handled (char type) const
-    { return (type == '(' || type == '{'); }
+  { return (type == '(' || type == '{'); }
 
 protected:
 
   octave_function (const std::string& nm,
                    const std::string& ds = std::string ())
     : relative (false), locked (false), private_function (false),
       xdispatch_class (), my_name (nm), my_dir_name (), doc (ds) { }
 
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -345,17 +345,17 @@ octave_float_scalar::map (unary_mapper_t
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
         return error_state ? octave_value () : str_conv.map (umap);
       }
 
     default:
-        return octave_base_value::map (umap);
+      return octave_base_value::map (umap);
     }
 }
 
 bool
 octave_float_scalar::fast_elem_insert_self (void *where,
                                             builtin_type_t btyp) const
 {
 
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -75,17 +75,18 @@ octave_float_complex::do_index_op (const
   //   a = i; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
   // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
-  octave_value tmp (new octave_float_complex_matrix (float_complex_matrix_value ()));
+  octave_value tmp (new octave_float_complex_matrix (
+                      float_complex_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
 double
 octave_float_complex::double_value (bool force_conversion) const
 {
   double retval;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -52,18 +52,20 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-shlib.h"
 #include "ov-java.h"
 #include "parse.h"
 #include "variables.h"
 
-typedef jint (JNICALL *JNI_CreateJavaVM_t) (JavaVM **pvm, JNIEnv **penv, void *args);
-typedef jint (JNICALL *JNI_GetCreatedJavaVMs_t) (JavaVM **pvm, jsize bufLen, jsize *nVMs);
+typedef jint (JNICALL *JNI_CreateJavaVM_t) (JavaVM **pvm, JNIEnv **penv,
+                                            void *args);
+typedef jint (JNICALL *JNI_GetCreatedJavaVMs_t) (JavaVM **pvm, jsize bufLen,
+                                                 jsize *nVMs);
 
 extern "C"
 {
   JNIEXPORT jboolean JNICALL
   Java_org_octave_Octave_call (JNIEnv *, jclass, jstring, jobjectArray,
                                jobjectArray);
   JNIEXPORT void JNICALL
   Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint);
@@ -452,25 +454,27 @@ initialize_jvm (void)
 
       value = octave_env::getenv ("JAVA_VERSION");
       if (value.empty ())
         {
           value = "Currentversion";
           std::string regval = read_registry_string (key,value);
 
           if (regval.empty ())
-            throw std::string ("unable to find Java Runtime Environment: ") + key + "::" + value;
+            throw std::string ("unable to find Java Runtime Environment: ")
+                  + key + "::" + value;
           value = regval;
         }
 
       key = key + "\\" + value;
       value = "RuntimeLib";
       jvm_lib_path = read_registry_string (key, value);
       if (jvm_lib_path.empty ())
-        throw std::string ("unable to find Java Runtime Environment: ") + key + "::" + value;
+        throw std::string ("unable to find Java Runtime Environment: ")
+              + key + "::" + value;
 
       std::string jvm_bin_path;
 
       value = "JavaHome";
       jvm_bin_path = read_registry_string (key, value);
       if (! jvm_bin_path.empty ())
         {
           jvm_bin_path = (jvm_bin_path + std::string ("\\bin"));
@@ -495,17 +499,18 @@ initialize_jvm (void)
 
   jsize nVMs = 0;
 
 # if !defined (__APPLE__) && !defined (__MACH__)
 
   octave_shlib lib (jvm_lib_path);
 
   if (!lib)
-    throw std::string ("unable to load Java Runtime Environment from ") + jvm_lib_path;
+    throw std::string ("unable to load Java Runtime Environment from ")
+          + jvm_lib_path;
 
 #if defined (__WIN32__)
 
   set_dll_directory ();
 
   if (! old_cwd.empty ())
     octave_env::chdir (old_cwd);
 
@@ -515,34 +520,36 @@ initialize_jvm (void)
     reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
   JNI_GetCreatedJavaVMs_t get_vm =
     reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
 
   if (!create_vm)
     throw std::string ("unable to find JNI_CreateJavaVM in ") + jvm_lib_path;
 
   if (!get_vm)
-    throw std::string ("unable to find JNI_GetCreatedJavaVMs in ") + jvm_lib_path;
+    throw std::string ("unable to find JNI_GetCreatedJavaVMs in ")
+          + jvm_lib_path;
 
   if (get_vm (&jvm, 1, &nVMs) == 0 && nVMs > 0)
 
 #else
 
   // FIXME: There exists a problem on the Mac platform that
   //   octave_shlib lib (jvm_lib_path)
   // doesn't work with 'not-bundled' *.oct files.
 
   if (JNI_GetCreatedJavaVMs (&jvm, 1, &nVMs) == 0 && nVMs > 0)
 
 #endif
 
     {
       // At least one JVM exists, try to attach to it
 
-      switch (jvm->GetEnv (reinterpret_cast<void **> (&current_env), JNI_VERSION_1_2))
+      switch (jvm->GetEnv (reinterpret_cast<void **> (&current_env),
+                           JNI_VERSION_1_2))
         {
         case JNI_EDETACHED:
           // Attach the current thread
           JavaVMAttachArgs vm_args;
           vm_args.version = JNI_VERSION_1_2;
           vm_args.name = const_cast<char *> ("octave");
           vm_args.group = 0;
           if (jvm->AttachCurrentThread (reinterpret_cast<void **> (&current_env),
@@ -566,17 +573,18 @@ initialize_jvm (void)
     {
       // No JVM exists, create one
 
       JVMArgs vm_args;
 
       vm_args.add ("-Djava.class.path=" + initial_class_path ());
       vm_args.add ("-Xrs");
       vm_args.add ("-Djava.system.class.loader=org.octave.OctClassLoader");
-      vm_args.read_java_opts (initial_java_dir () + file_ops::dir_sep_str () + "java.opts");
+      vm_args.read_java_opts (initial_java_dir () + file_ops::dir_sep_str () +
+                              "java.opts");
 
 # if !defined (__APPLE__) && !defined (__MACH__)
 
       if (create_vm (&jvm, &current_env, vm_args.to_args ()) != JNI_OK)
         throw std::string ("unable to start Java VM in ")+jvm_lib_path;
       //printf ("JVM created\n");
     }
 
@@ -709,31 +717,34 @@ find_octave_class (JNIEnv *jni_env, cons
           if (class_loader.empty ())
             {
               jclass_ref syscls (jni_env,
                                  jni_env->FindClass ("java/lang/System"));
               jmethodID mID = jni_env->GetStaticMethodID (syscls, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");
               jstring_ref js (jni_env, jni_env->NewStringUTF ("octave.class.loader"));
               js = reinterpret_cast<jstring> (jni_env->CallStaticObjectMethod (syscls, mID, jstring (js)));
               class_loader = jstring_to_string (jni_env, jstring (js));
-              std::replace (class_loader.begin (), class_loader.end (), '.', '/');
+              std::replace (class_loader.begin (), class_loader.end (),
+                            '.', '/');
             }
 
           jclass_ref uicls (jni_env, jni_env->FindClass (class_loader.c_str ()));
 
           if (! uicls)
             {
               jni_env->ExceptionClear ();
 
               /* Try the netbeans way */
-              std::replace (class_loader.begin (), class_loader.end (), '/', '.');
+              std::replace (class_loader.begin (), class_loader.end (),
+                            '/', '.');
               jclass_ref jcls2 (jni_env, jni_env->FindClass ("org/openide/util/Lookup"));
               jmethodID mID = jni_env->GetStaticMethodID (jcls2, "getDefault", "()Lorg/openide/util/Lookup;");
               jobject_ref lObj (jni_env, jni_env->CallStaticObjectMethod (jcls2, mID));
-              mID = jni_env->GetMethodID (jcls2, "lookup", "(Ljava/lang/Class;)Ljava/lang/Object;");
+              mID = jni_env->GetMethodID (jcls2, "lookup",
+                                          "(Ljava/lang/Class;)Ljava/lang/Object;");
               jclass_ref cLoaderCls (jni_env, jni_env->FindClass ("java/lang/ClassLoader"));
               jobject_ref cLoader (jni_env, jni_env->CallObjectMethod (lObj, mID, jclass (cLoaderCls)));
               mID = jni_env->GetMethodID (cLoaderCls, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");
               jstring_ref js (jni_env, jni_env->NewStringUTF (class_loader.c_str ()));
               uicls = reinterpret_cast<jclass> (jni_env->CallObjectMethod (cLoader, mID, jstring (js)));
             }
 
           if (uicls)
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -674,18 +674,18 @@ octave_range::as_mxArray (void) const
     pr[i] = p[i];
 
   return retval;
 }
 
 octave_value
 octave_range::fast_elem_extract (octave_idx_type n) const
 {
-  return (n < range.nelem ())
-    ? octave_value (range.elem (n)) : octave_value ();
+  return (n < range.nelem ()) ? octave_value (range.elem (n))
+                              : octave_value ();
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -953,17 +953,17 @@ octave_matrix::map (unary_mapper_t umap)
     case umap_xisxdigit:
     case umap_xtoascii:
       {
         octave_value str_conv = convert_to_str (true, true);
         return error_state ? octave_value () : str_conv.map (umap);
       }
 
     default:
-        return octave_base_value::map (umap);
+      return octave_base_value::map (umap);
     }
 }
 
 DEFUN (double, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -411,21 +411,21 @@ public:
 
 #if 0
   void print_symtab_info (std::ostream& os) const;
 #endif
 
 private:
 
   enum class_ctor_type
-    {
-      none,
-      legacy,
-      classdef
-    };
+  {
+    none,
+    legacy,
+    classdef
+  };
 
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   tree_parameter_list *ret_list;
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2400,39 +2400,39 @@ do_colon_op (const octave_value& base, c
 
       if (base.is_object ())
         dispatch_type = base.class_name ();
       else if (increment.is_defined () && increment.is_object ())
         dispatch_type = increment.class_name ();
       else
         dispatch_type = limit.class_name ();
 
-    octave_value meth = symbol_table::find_method ("colon", dispatch_type);
-
-    if (meth.is_defined ())
-      {
-        octave_value_list args;
-
-        if (increment.is_defined ())
-          {
-            args(2) = limit;
-            args(1) = increment;
-          }
-        else
-          args(1) = limit;
-
-        args(0) = base;
-
-        octave_value_list tmp = feval (meth.function_value (), args, 1);
-
-        if (tmp.length () > 0)
-          retval = tmp(0);
-      }
-    else
-      error ("colon method not defined for %s class", dispatch_type.c_str ());
+      octave_value meth = symbol_table::find_method ("colon", dispatch_type);
+
+      if (meth.is_defined ())
+        {
+          octave_value_list args;
+
+          if (increment.is_defined ())
+            {
+              args(2) = limit;
+              args(1) = increment;
+            }
+          else
+            args(1) = limit;
+
+          args(0) = base;
+
+          octave_value_list tmp = feval (meth.function_value (), args, 1);
+
+          if (tmp.length () > 0)
+            retval = tmp(0);
+        }
+      else
+        error ("colon method not defined for %s class", dispatch_type.c_str ());
     }
   else
     {
       bool result_is_str = (base.is_string () && limit.is_string ());
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
 
       Matrix m_base = base.matrix_value (true);
 
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -219,17 +219,17 @@ along with Octave; see the file COPYING.
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
       gripe_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     return retval; \
-  } \
+  }
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2) \
   DEFBINOP (PFX ## _el_and, T2, T2) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     return v1.T1 ## scalar_value () != Z1 && v2.T2 ## scalar_value () != Z2; \
   } \
diff --git a/libinterp/options-usage.h b/libinterp/options-usage.h
--- a/libinterp/options-usage.h
+++ b/libinterp/options-usage.h
@@ -60,17 +60,18 @@ static const char *short_opts = "+HWVdfh
 #define NO_GUI_OPTION 12
 #define NO_INIT_FILE_OPTION 13
 #define NO_INIT_PATH_OPTION 14
 #define NO_LINE_EDITING_OPTION 15
 #define NO_SITE_FILE_OPTION 16
 #define PERSIST_OPTION 17
 #define TEXI_MACROS_FILE_OPTION 18
 #define TRADITIONAL_OPTION 19
-struct option long_opts[] = {
+struct option long_opts[] =
+{
   { "braindead",                no_argument,       0, TRADITIONAL_OPTION },
   { "built-in-docstrings-file", required_argument, 0, BUILT_IN_DOCSTRINGS_FILE_OPTION },
   { "debug",                    no_argument,       0, 'd' },
   { "debug-jit",                no_argument,       0, DEBUG_JIT_OPTION },
   { "doc-cache-file",           required_argument, 0, DOC_CACHE_FILE_OPTION },
   { "echo-commands",            no_argument,       0, 'x' },
   { "eval",                     required_argument, 0, EVAL_OPTION },
   { "exec-path",                required_argument, 0, EXEC_PATH_OPTION },
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -700,17 +700,17 @@ tree_evaluator::visit_statement (tree_st
           // Skip commands issued at a debug> prompt to avoid disturbing
           // the state of the program we are debugging.
 
           if (! Vdebugging)
             octave_call_stack::set_location (stmt.line (), stmt.column ());
 
           if ((statement_context == script
                && ((Vecho_executing_commands & ECHO_SCRIPTS
-                   && octave_call_stack::all_scripts ())
+                    && octave_call_stack::all_scripts ())
                    || Vecho_executing_commands & ECHO_FUNCTIONS))
               || (statement_context == function
                   && Vecho_executing_commands & ECHO_FUNCTIONS))
             stmt.echo_code ();
         }
 
       try
         {
diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -53,18 +53,18 @@ nan_ascending_compare (const Complex& x,
   double yabs = std::abs (y);
 
   if (xabs < yabs)
     return true;
   else if (xabs == yabs)
     {
       double xarg = arg (x);
       double yarg = arg (y);
-      xarg = (xarg == -M_PI) ? M_PI : xarg; 
-      yarg = (yarg == -M_PI) ? M_PI : yarg; 
+      xarg = (xarg == -M_PI) ? M_PI : xarg;
+      yarg = (yarg == -M_PI) ? M_PI : yarg;
 
       return xarg < yarg;
     }
   else
     return false;
 }
 
 static bool
@@ -77,18 +77,18 @@ nan_descending_compare (const Complex& x
   double yabs = std::abs (y);
 
   if (xabs > yabs)
     return true;
   else if (xabs == yabs)
     {
       double xarg = arg (x);
       double yarg = arg (y);
-      xarg = (xarg == -M_PI) ? M_PI : xarg; 
-      yarg = (yarg == -M_PI) ? M_PI : yarg; 
+      xarg = (xarg == -M_PI) ? M_PI : xarg;
+      yarg = (yarg == -M_PI) ? M_PI : yarg;
 
       return xarg > yarg;
     }
   else
     return false;
 }
 
 Array<Complex>::compare_fcn_type
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -53,18 +53,18 @@ nan_ascending_compare (const FloatComple
   float yabs = std::abs (y);
 
   if (xabs < yabs)
     return true;
   else if (xabs == yabs)
     {
       float xarg = arg (x);
       float yarg = arg (y);
-      xarg = (xarg == -M_PI) ? M_PI : xarg; 
-      yarg = (yarg == -M_PI) ? M_PI : yarg; 
+      xarg = (xarg == -M_PI) ? M_PI : xarg;
+      yarg = (yarg == -M_PI) ? M_PI : yarg;
 
       return xarg < yarg;
     }
   else
     return false;
 }
 
 static bool
@@ -77,18 +77,18 @@ nan_descending_compare (const FloatCompl
   float yabs = std::abs (y);
 
   if (xabs > yabs)
     return true;
   else if (xabs == yabs)
     {
       float xarg = arg (x);
       float yarg = arg (y);
-      xarg = (xarg == -M_PI) ? M_PI : xarg; 
-      yarg = (yarg == -M_PI) ? M_PI : yarg; 
+      xarg = (xarg == -M_PI) ? M_PI : xarg;
+      yarg = (yarg == -M_PI) ? M_PI : yarg;
 
       return xarg > yarg;
     }
   else
     return false;
 }
 
 Array<FloatComplex>::compare_fcn_type
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2513,17 +2513,17 @@ Array<T>::lookup (const Array<T>&, sortm
 template <> octave_idx_type \
 Array<T>::nnz (void) const\
 { return 0; } \
 template <> Array<octave_idx_type> \
 Array<T>::find (octave_idx_type, bool) const\
 { return Array<octave_idx_type> (); } \
  \
 template <> Array<T>  \
-Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); } \
+Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); }
 
 
 template <class T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -492,17 +492,17 @@ public:
 
   void resize (const dim_vector& dv, const T& rfv);
   void resize (const dim_vector& dv) { resize (dv, resize_fill_value ()); }
   //@}
 
   //@{
   //! Indexing with possible resizing and fill
 
-  // FIXME -- this is really a corner case, that should better be
+  // FIXME: this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
 
   Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
   Array<T> index (const idx_vector& i, bool resize_ok) const
   {
     return index (i, resize_ok, resize_fill_value ());
   }
@@ -608,17 +608,18 @@ public:
   Array<octave_idx_type> lookup (const Array<T>& values,
                                  sortmode mode = UNSORTED) const;
 
   //! Count nonzero elements.
   octave_idx_type nnz (void) const;
 
   //! Find indices of (at most n) nonzero elements. If n is specified,
   //! backward specifies search from backward.
-  Array<octave_idx_type> find (octave_idx_type n = -1, bool backward = false) const;
+  Array<octave_idx_type> find (octave_idx_type n = -1,
+                               bool backward = false) const;
 
   //! Returns the n-th element in increasing order, using the same
   //! ordering as used for sort. n can either be a scalar index or a
   //! contiguous range.
   Array<T> nth_element (const idx_vector& n, int dim = 0) const;
 
   //! Get the kth super or subdiagonal. The zeroth diagonal is the
   //! ordinary diagonal.
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -80,23 +80,23 @@ PermMatrix::setup (const idx_vector& idx
 
   if (!colp)
     *this = this->transpose ();
 }
 
 PermMatrix::PermMatrix (const idx_vector& idx)
   : Array<octave_idx_type> ()
 {
-    setup (idx, false, 0);
+  setup (idx, false, 0);
 }
 
 PermMatrix::PermMatrix (const idx_vector& idx, bool colp, octave_idx_type n)
   : Array<octave_idx_type> ()
 {
-    setup (idx, colp, n);
+  setup (idx, colp, n);
 }
 
 PermMatrix::PermMatrix (octave_idx_type n)
   : Array<octave_idx_type> (dim_vector (n, 1))
 {
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = i;
 }
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
 #include "PermMatrix.h"
 
 template <class T>
 Sparse<T>::Sparse (const PermMatrix& a)
   : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
-         dimensions (dim_vector (a.rows (), a.cols ()))
+    dimensions (dim_vector (a.rows (), a.cols ()))
 {
   octave_idx_type n = a.rows ();
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
   const Array<octave_idx_type> pv = a.col_perm_vec ();
 
   for (octave_idx_type i = 0; i < n; i++)
@@ -980,17 +980,17 @@ Sparse<T>::resize (octave_idx_type r, oc
     {
       octave_idx_type *new_cidx = new octave_idx_type [c+1];
       std::copy (rep->c, rep->c + std::min (c, rep->ncols) + 1, new_cidx);
       delete [] rep->c;
       rep->c = new_cidx;
 
       if (c > rep->ncols)
         std::fill_n (rep->c + rep->ncols + 1, c - rep->ncols,
-          rep->c[rep->ncols]);
+                     rep->c[rep->ncols]);
     }
 
   rep->ncols = dimensions(1) = c;
 
   rep->change_length (rep->nnz ());
 }
 
 template <class T>
@@ -1908,19 +1908,19 @@ Sparse<T>::assign (const idx_vector& idx
                   std::copy (tmp.ridx (), tmp.ridx () + li, ridx ());
 
                   // new stuff ...
                   std::copy (rhs.data (), rhs.data () + rnz, data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
 
                   // ...tail
                   std::copy (tmp.data () + ui, tmp.data () + nz,
-                                  data () + li + rnz);
+                             data () + li + rnz);
                   std::copy (tmp.ridx () + ui, tmp.ridx () + nz,
-                                  ridx () + li + rnz);
+                             ridx () + li + rnz);
                 }
 
               cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
               // It's s(u:-1:l) = r. Reverse the assignment.
               assign (idx.sorted (), rhs.index (idx_vector (rhl - 1, 0, -1)));
@@ -2099,19 +2099,19 @@ Sparse<T>::assign (const idx_vector& idx
                   // new stuff...
                   std::copy (rhs.data (), rhs.data () + rnz, data () + li);
                   std::copy (rhs.ridx (), rhs.ridx () + rnz, ridx () + li);
                   mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1,
                                  li);
 
                   // ...tail.
                   std::copy (tmp.data () + ui, tmp.data () + nz,
-                                  data () + li + rnz);
+                             data () + li + rnz);
                   std::copy (tmp.ridx () + ui, tmp.ridx () + nz,
-                                  ridx () + li + rnz);
+                             ridx () + li + rnz);
                   mx_inline_add (nc - ub, cidx () + ub + 1,
                                  tmp.cidx () + ub + 1, new_nz - nz);
 
                   assert (nnz () == new_nz);
                 }
             }
           else if (idx_j.is_range () && idx_j.increment () == -1)
             {
@@ -2152,28 +2152,28 @@ Sparse<T>::assign (const idx_vector& idx
                   octave_idx_type l = xcidx (i);
                   octave_idx_type u = xcidx (i+1);
                   octave_idx_type j = jsav[i];
                   if (j >= 0)
                     {
                       // from rhs
                       octave_idx_type k = rhs.cidx (j);
                       std::copy (rhs.data () + k, rhs.data () + k + u - l,
-                        xdata () + l);
+                                 xdata () + l);
                       std::copy (rhs.ridx () + k, rhs.ridx () + k + u - l,
-                        xridx () + l);
+                                 xridx () + l);
                     }
                   else
                     {
                       // original
                       octave_idx_type k = tmp.cidx (i);
                       std::copy (tmp.data () + k, tmp.data () + k + u - l,
-                        xdata () + l);
+                                 xdata () + l);
                       std::copy (tmp.ridx () + k, tmp.ridx () + k + u - l,
-                        xridx () + l);
+                                 xridx () + l);
                     }
                 }
 
             }
         }
       else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
         {
           // It's just vector indexing.  The 1D assign is specialized for that.
diff --git a/liboctave/array/chMatrix.h b/liboctave/array/chMatrix.h
--- a/liboctave/array/chMatrix.h
+++ b/liboctave/array/chMatrix.h
@@ -53,24 +53,24 @@ public:
 
   charMatrix (const dim_vector& dv, char val)
     : charNDArray (dv.redim (2), val) { }
 
   charMatrix (const Array<char>& a) : charNDArray (a.as_matrix ()) { }
 
   charMatrix (const charMatrix& a) : charNDArray (a) { }
 
-  charMatrix (char c) : charNDArray (c) {}
+  charMatrix (char c) : charNDArray (c) { }
 
-  charMatrix (const char *s) : charNDArray (s) {}
+  charMatrix (const char *s) : charNDArray (s) { }
 
-  charMatrix (const std::string& s) : charNDArray (s) {}
+  charMatrix (const std::string& s) : charNDArray (s) { }
 
   charMatrix (const string_vector& s, char fill_value = '\0')
-    : charNDArray (s, fill_value) {}
+    : charNDArray (s, fill_value) { }
 
   bool operator == (const charMatrix& a) const;
   bool operator != (const charMatrix& a) const;
 
   charMatrix transpose (void) const { return Array<char>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -7255,17 +7255,18 @@ SparseMatrix::solve (const ComplexColumn
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // other operations.
 
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nnz ();
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -312,42 +312,42 @@ public:
   int num_ones (void) const;
 
   bool all_ones (void) const
   {
     return (num_ones () == length ());
   }
 
   //! Number of elements that a matrix with this dimensions would have.
-   /*!
-      Return the number of elements that a matrix with this dimension
-      vector would have, NOT the number of dimensions (elements in the
-      dimension vector).
+  /*!
+     Return the number of elements that a matrix with this dimension
+     vector would have, NOT the number of dimensions (elements in the
+     dimension vector).
   */
 
   octave_idx_type numel (int n = 0) const
   {
     int n_dims = length ();
 
     octave_idx_type retval = 1;
 
     for (int i = n; i < n_dims; i++)
       retval *= elem (i);
 
     return retval;
   }
 
-   /*!
-      The following function will throw a std::bad_alloc ()
-      exception if the requested size is larger than can be indexed by
-      octave_idx_type. This may be smaller than the actual amount of
-      memory that can be safely allocated on a system.  However, if we
-      don't fail here, we can end up with a mysterious crash inside a
-      function that is iterating over an array using octave_idx_type
-      indices.
+  /*!
+     The following function will throw a std::bad_alloc ()
+     exception if the requested size is larger than can be indexed by
+     octave_idx_type. This may be smaller than the actual amount of
+     memory that can be safely allocated on a system.  However, if we
+     don't fail here, we can end up with a mysterious crash inside a
+     function that is iterating over an array using octave_idx_type
+     indices.
   */
 
   octave_idx_type safe_numel (void) const;
 
   bool any_neg (void) const
   {
     int n_dims = length ();
     int i;
diff --git a/liboctave/numeric/bsxfun-decl.h b/liboctave/numeric/bsxfun-decl.h
--- a/liboctave/numeric/bsxfun-decl.h
+++ b/liboctave/numeric/bsxfun-decl.h
@@ -49,11 +49,11 @@ extern API boolNDArray bsxfun_ ## OP (co
   BSXFUN_OP2_DECL (pow, INT_TYPE, FloatNDArray, INT_TYPE, API)
 
 #define BSXFUN_STDREL_DECLS(ARRAY, API) \
   BSXFUN_REL_DECL (eq, ARRAY, API) \
   BSXFUN_REL_DECL (ne, ARRAY, API) \
   BSXFUN_REL_DECL (lt, ARRAY, API) \
   BSXFUN_REL_DECL (le, ARRAY, API) \
   BSXFUN_REL_DECL (gt, ARRAY, API) \
-  BSXFUN_REL_DECL (ge, ARRAY, API) \
+  BSXFUN_REL_DECL (ge, ARRAY, API)
 
 #endif
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -234,17 +234,17 @@ boolNDArray bsxfun_ ## OP (const ARRAY& 
     (x, y, LOOP, LOOP, LOOP); }
 
 #define BSXFUN_STDOP_DEFS_MXLOOP(ARRAY) \
   BSXFUN_OP_DEF_MXLOOP (add, ARRAY, mx_inline_add) \
   BSXFUN_OP_DEF_MXLOOP (sub, ARRAY, mx_inline_sub) \
   BSXFUN_OP_DEF_MXLOOP (mul, ARRAY, mx_inline_mul) \
   BSXFUN_OP_DEF_MXLOOP (div, ARRAY, mx_inline_div) \
   BSXFUN_OP_DEF_MXLOOP (min, ARRAY, mx_inline_xmin) \
-  BSXFUN_OP_DEF_MXLOOP (max, ARRAY, mx_inline_xmax) \
+  BSXFUN_OP_DEF_MXLOOP (max, ARRAY, mx_inline_xmax)
 
 #define BSXFUN_STDREL_DEFS_MXLOOP(ARRAY) \
   BSXFUN_REL_DEF_MXLOOP (eq, ARRAY, mx_inline_eq) \
   BSXFUN_REL_DEF_MXLOOP (ne, ARRAY, mx_inline_ne) \
   BSXFUN_REL_DEF_MXLOOP (lt, ARRAY, mx_inline_lt) \
   BSXFUN_REL_DEF_MXLOOP (le, ARRAY, mx_inline_le) \
   BSXFUN_REL_DEF_MXLOOP (gt, ARRAY, mx_inline_gt) \
   BSXFUN_REL_DEF_MXLOOP (ge, ARRAY, mx_inline_ge)
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -72,151 +72,151 @@ class norm_accumulator_p
 {
   R p,scl,sum;
 public:
   norm_accumulator_p () {} // we need this one for Array
   norm_accumulator_p (R pp) : p(pp), scl(0), sum(1) {}
 
   template<class U>
   void accum (U val)
-    {
-      octave_quit ();
-      R t = std::abs (val);
-      if (scl == t) // we need this to handle Infs properly
+  {
+    octave_quit ();
+    R t = std::abs (val);
+    if (scl == t) // we need this to handle Infs properly
+      sum += 1;
+    else if (scl < t)
+      {
+        sum *= std::pow (scl/t, p);
         sum += 1;
-      else if (scl < t)
-        {
-          sum *= std::pow (scl/t, p);
-          sum += 1;
-          scl = t;
-        }
-      else if (t != 0)
-        sum += std::pow (t/scl, p);
-    }
+        scl = t;
+      }
+    else if (t != 0)
+      sum += std::pow (t/scl, p);
+  }
   operator R () { return scl * std::pow (sum, 1/p); }
 };
 
 // norm accumulator for the minus p-pseudonorm
 template <class R>
 class norm_accumulator_mp
 {
   R p,scl,sum;
 public:
   norm_accumulator_mp () {} // we need this one for Array
   norm_accumulator_mp (R pp) : p(pp), scl(0), sum(1) {}
 
   template<class U>
   void accum (U val)
-    {
-      octave_quit ();
-      R t = 1 / std::abs (val);
-      if (scl == t)
+  {
+    octave_quit ();
+    R t = 1 / std::abs (val);
+    if (scl == t)
+      sum += 1;
+    else if (scl < t)
+      {
+        sum *= std::pow (scl/t, p);
         sum += 1;
-      else if (scl < t)
-        {
-          sum *= std::pow (scl/t, p);
-          sum += 1;
-          scl = t;
-        }
-      else if (t != 0)
-        sum += std::pow (t/scl, p);
-    }
+        scl = t;
+      }
+    else if (t != 0)
+      sum += std::pow (t/scl, p);
+  }
   operator R () { return scl * std::pow (sum, -1/p); }
 };
 
 // norm accumulator for the 2-norm (euclidean)
 template <class R>
 class norm_accumulator_2
 {
   R scl,sum;
   static R pow2 (R x) { return x*x; }
 public:
   norm_accumulator_2 () : scl(0), sum(1) {}
 
   void accum (R val)
-    {
-      R t = std::abs (val);
-      if (scl == t)
+  {
+    R t = std::abs (val);
+    if (scl == t)
+      sum += 1;
+    else if (scl < t)
+      {
+        sum *= pow2 (scl/t);
         sum += 1;
-      else if (scl < t)
-        {
-          sum *= pow2 (scl/t);
-          sum += 1;
-          scl = t;
-        }
-      else if (t != 0)
-        sum += pow2 (t/scl);
-    }
+        scl = t;
+      }
+    else if (t != 0)
+      sum += pow2 (t/scl);
+  }
 
   void accum (std::complex<R> val)
-    {
-      accum (val.real ());
-      accum (val.imag ());
-    }
+  {
+    accum (val.real ());
+    accum (val.imag ());
+  }
 
   operator R () { return scl * std::sqrt (sum); }
 };
 
 // norm accumulator for the 1-norm (city metric)
 template <class R>
 class norm_accumulator_1
 {
   R sum;
 public:
   norm_accumulator_1 () : sum (0) {}
   template<class U>
   void accum (U val)
-    {
-      sum += std::abs (val);
-    }
+  {
+    sum += std::abs (val);
+  }
   operator R () { return sum; }
 };
 
 // norm accumulator for the inf-norm (max metric)
 template <class R>
 class norm_accumulator_inf
 {
   R max;
 public:
   norm_accumulator_inf () : max (0) {}
   template<class U>
   void accum (U val)
-    {
-      max = std::max (max, std::abs (val));
-    }
+  {
+    max = std::max (max, std::abs (val));
+  }
   operator R () { return max; }
 };
 
 // norm accumulator for the -inf pseudonorm (min abs value)
 template <class R>
 class norm_accumulator_minf
 {
   R min;
 public:
   norm_accumulator_minf () : min (octave_Inf) {}
   template<class U>
   void accum (U val)
-    {
-      min = std::min (min, std::abs (val));
-    }
+  {
+    min = std::min (min, std::abs (val));
+  }
   operator R () { return min; }
 };
 
 // norm accumulator for the 0-pseudonorm (hamming distance)
 template <class R>
 class norm_accumulator_0
 {
   unsigned int num;
 public:
   norm_accumulator_0 () : num (0) {}
   template<class U>
   void accum (U val)
-    {
-      if (val != static_cast<U> (0)) ++num;
-    }
+  {
+    if (val != static_cast<U> (0)) ++num;
+  }
   operator R () { return num; }
 };
 
 
 // OK, we're armed :) Now let's go for the fun
 
 template <class T, class R, class ACC>
 inline void vector_norm (const Array<T>& v, R& res, ACC acc)
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -966,17 +966,17 @@ along with Octave; see the file COPYING.
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
-  SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
+  SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SMSM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_SMSM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
 // matrix by sparse matrix operations.
 
 #define SPARSE_MSM_BIN_OP_1(R, F, OP, M1, M2)   \
   R \
@@ -1172,17 +1172,17 @@ along with Octave; see the file COPYING.
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
-  SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
+  SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_MSM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_MSM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
 // sparse matrix by matrix operations.
 
 #define SPARSE_SMM_BIN_OP_1(R, F, OP, M1, M2)   \
   R \
@@ -1385,17 +1385,17 @@ along with Octave; see the file COPYING.
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
-  SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO) \
+  SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
 #define SPARSE_SMM_BOOL_OPS(M1, M2, ZERO) \
   SPARSE_SMM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
 // Avoid some code duplication.  Maybe we should use templates.
 
 #define SPARSE_CUMSUM(RET_TYPE, ELT_TYPE, FCN)  \
  \
@@ -1660,17 +1660,17 @@ along with Octave; see the file COPYING.
                         SPARSE_REDUCTION_OP_COL_EXPR (OP), \
                         INIT_VAL, MT_RESULT)
 
 
 // Don't break from this loop if the test succeeds because
 // we are looping over the rows and not the columns in the inner loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
-    tmp[ridx (i)] = TEST_TRUE_VAL; \
+    tmp[ridx (i)] = TEST_TRUE_VAL;
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
       break; \
     }
 
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -762,17 +762,17 @@ powf (const octave_int<T>& a, const floa
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const double&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const double&); \
   template OCTAVE_API octave_int<T> pow (const float&, const octave_int<T>&);  \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const float&);  \
   template OCTAVE_API octave_int<T> powf (const float&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> powf (const octave_int<T>&, const float&); \
   template OCTAVE_API octave_int<T> \
-  bitshift (const octave_int<T>&, int, const octave_int<T>&); \
+  bitshift (const octave_int<T>&, int, const octave_int<T>&);
 
 INSTANTIATE_INTTYPE (int8_t);
 INSTANTIATE_INTTYPE (int16_t);
 INSTANTIATE_INTTYPE (int32_t);
 INSTANTIATE_INTTYPE (int64_t);
 
 INSTANTIATE_INTTYPE (uint8_t);
 INSTANTIATE_INTTYPE (uint16_t);
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -1139,17 +1139,17 @@ DECLARE_EXTERNAL_LONG_DOUBLE_OPS (octave
 #define OCTAVE_INT_DOUBLE_BIN_OP0(OP) \
   template <class T> \
   inline octave_int<T> \
   operator OP (const octave_int<T>& x, const double& y) \
   { return octave_int<T> (static_cast<double> (x) OP y); } \
   template <class T> \
   inline octave_int<T> \
   operator OP (const double& x, const octave_int<T>& y) \
-  { return octave_int<T> (x OP static_cast<double> (y)); } \
+  { return octave_int<T> (x OP static_cast<double> (y)); }
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 // Handle mixed op using long double
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 #define OCTAVE_INT_DOUBLE_BIN_OP(OP, NAME) \
   OCTAVE_INT_DOUBLE_BIN_OP0(OP) \
   template <> \
   inline octave_int64 \
diff --git a/src/main.in.cc b/src/main.in.cc
--- a/src/main.in.cc
+++ b/src/main.in.cc
@@ -268,18 +268,18 @@ get_octave_archlibdir (void)
 {
   // Accept value from the environment literally, but substitute
   // OCTAVE_HOME in the configuration value OCTAVE_ARCHLIBDIR in case
   // Octave has been relocated to some installation directory other than
   // the one originally configured.
 
   std::string dir = octave_getenv ("OCTAVE_ARCHLIBDIR");
 
-  return dir.empty ()
-    ? subst_octave_home (std::string (OCTAVE_ARCHLIBDIR)) : dir;
+  return dir.empty () ? subst_octave_home (std::string (OCTAVE_ARCHLIBDIR))
+                      : dir;
 }
 
 // Adapted from libtool wrapper.
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 /* Prepares an argument vector before calling spawn().
    Note that spawn() does not by itself call the command interpreter
      (getenv ("COMSPEC") != NULL ? getenv ("COMSPEC") :
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -162,17 +162,17 @@ initialize (void)
                                         %OCTAVE_CONF_XTRA_CXXFLAGS%);
 
   vars["AR"] = get_variable ("AR", %OCTAVE_CONF_MKOCTFILE_AR%);
   vars["RANLIB"] = get_variable ("RANLIB", %OCTAVE_CONF_MKOCTFILE_RANLIB%);
 
   vars["DEPEND_FLAGS"] = get_variable ("DEPEND_FLAGS",
                                        %OCTAVE_CONF_DEPEND_FLAGS%);
   vars["DEPEND_EXTRA_SED_PATTERN"] = get_variable ("DEPEND_EXTRA_SED_PATTERN",
-                                       %OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%);
+                                                   %OCTAVE_CONF_DEPEND_EXTRA_SED_PATTERN%);
 
   vars["DL_LD"] = get_variable ("DL_LD", %OCTAVE_CONF_MKOCTFILE_DL_LD%);
   vars["DL_LDFLAGS"] = get_variable ("DL_LDFLAGS",
                                      %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%);
 
   vars["RDYNAMIC_FLAG"] = get_variable ("RDYNAMIC_FLAG",
                                         %OCTAVE_CONF_RDYNAMIC_FLAG%);
   vars["LIBOCTAVE"] = "-loctave";
@@ -588,63 +588,69 @@ main (int argc, char **argv)
 
   if (depend)
     {
       for (it = cfiles.begin (); it != cfiles.end (); ++it)
         {
           std::string f = *it, dfile = basename (f, true) + ".d", line;
 
           gnulib::unlink (dfile.c_str ());
-          std::string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
-            + vars["CPPFLAGS"] + " " + vars["ALL_CFLAGS"] + " "
-            + incflags  + " " + defs + " " + quote_path (f);
+          std::string cmd = vars["CC"] + " "
+                            + vars["DEPEND_FLAGS"] + " "
+                            + vars["CPPFLAGS"] + " "
+                            + vars["ALL_CFLAGS"] + " "
+                            + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
           while (!feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
-                    (spos == std::string::npos ? line.substr (0, pos+2)
-                                          : line.substr (spos+1, pos-spos+1));
+                    (spos == std::string::npos
+                      ? line.substr (0, pos+2)
+                      : line.substr (spos+1, pos-spos+1));
                   fo << "pic/" << ofile << " " << ofile << " "
                      << dfile << line.substr (pos) << std::endl;
                 }
               else
                 fo << line << std::endl;
             }
           pclose (fd);
           fo.close ();
         }
 
       for (it = ccfiles.begin (); it != ccfiles.end (); ++it)
         {
           std::string f = *it, dfile = basename (f, true) + ".d", line;
 
           gnulib::unlink (dfile.c_str ());
-          std::string cmd = vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
-            + vars["CPPFLAGS"] + " " + vars["ALL_CXXFLAGS"] + " "
-            + incflags  + " " + defs + " " + quote_path (f);
+          std::string cmd = vars["CC"] + " "
+                            + vars["DEPEND_FLAGS"] + " "
+                            + vars["CPPFLAGS"] + " "
+                            + vars["ALL_CXXFLAGS"] + " "
+                            + incflags  + " " + defs + " " + quote_path (f);
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
           while (!feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
-                    (spos == std::string::npos ? line.substr (0, pos+2)
-                                          : line.substr (spos+1, pos-spos+1));
+                    (spos == std::string::npos
+                      ? line.substr (0, pos+2)
+                      : line.substr (spos+1, pos-spos+1));
                   fo << "pic/" << ofile << " " << ofile << " "
                      << dfile << line.substr (pos+2) << std::endl;
                 }
               else
                 fo << line << std::endl;
             }
           pclose (fd);
           fo.close ();
@@ -664,19 +670,21 @@ main (int argc, char **argv)
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
           objfiles += (" " + o);
-          std::string cmd = vars["F77"] + " -c " + vars["FPICFLAG"] + " "
-            + vars["ALL_FFLAGS"] + " " + incflags + " " + defs + " "
-            + pass_on_options + " " + f + " -o " + o;
+          std::string cmd = vars["F77"] + " -c "
+                            + vars["FPICFLAG"] + " "
+                            + vars["ALL_FFLAGS"] + " "
+                            + incflags + " " + defs + " " + pass_on_options
+                            + " " + f + " -o " + o;
           result = run_command (cmd);
         }
       else
         {
           std::cerr << "mkoctfile: no way to compile Fortran file " << f
                     << std::endl;
           return 1;
         }
@@ -693,20 +701,22 @@ main (int argc, char **argv)
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
           objfiles += (" " + o);
-          std::string cmd = vars["CC"] + " -c " + vars["CPPFLAGS"] + " "
-            + vars["CPICFLAG"] + " " + vars["ALL_CFLAGS"] + " "
-            + pass_on_options + " " + incflags + " " + defs + " "
-            + quote_path (f) + " -o " + quote_path (o);
+          std::string cmd = vars["CC"] + " -c "
+                            + vars["CPPFLAGS"] + " "
+                            + vars["CPICFLAG"] + " " + vars["ALL_CFLAGS"] + " "
+                            + pass_on_options + " "
+                            + incflags + " " + defs + " "
+                            + quote_path (f) + " -o " + quote_path (o);
           result = run_command (cmd);
         }
       else
         {
           std::cerr << "mkoctfile: no way to compile C file " << f
                     << std::endl;
           return 1;
         }
@@ -723,62 +733,71 @@ main (int argc, char **argv)
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
           objfiles += (" " + o);
-          std::string cmd = vars["CXX"] + " -c " + vars["CPPFLAGS"] + " "
-            + vars["CXXPICFLAG"] + " " + vars["ALL_CXXFLAGS"] + " "
-            + pass_on_options + " " + incflags + " " + defs + " "
-            + quote_path (f) + " -o " + quote_path (o);
+          std::string cmd = vars["CXX"] + " -c "
+                            + vars["CPPFLAGS"] + " "
+                            + vars["CXXPICFLAG"] + " "
+                            + vars["ALL_CXXFLAGS"] + " "
+                            + pass_on_options + " "
+                            + incflags + " " + defs + " "
+                            + quote_path (f) + " -o " + quote_path (o);
           result = run_command (cmd);
         }
       else
         {
           std::cerr << "mkoctfile: no way to compile C++ file " << f
                     << std::endl;
           return 1;
         }
     }
 
   if (link && !objfiles.empty () && !result)
     {
       if (link_stand_alone)
         {
           if (!vars["LD_CXX"].empty ())
             {
-              std::string cmd = vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
-                + vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"]
-                + " " + vars["ALL_LDFLAGS"] + " "
-                + pass_on_options + " " + output_option + " "
-                + objfiles + " " + libfiles + " "
-                + ldflags + " " + vars["LFLAGS"]
-                + " -loctinterp -loctave "
-                + " " + vars["OCTAVE_LINK_OPTS"]
-                + " " + vars["OCTAVE_LINK_DEPS"];
+              std::string cmd = vars["LD_CXX"] + " "
+                                + vars["CPPFLAGS"] + " "
+                                + vars["ALL_CXXFLAGS"] + " "
+                                + vars["RDYNAMIC_FLAG"] + " "
+                                + vars["ALL_LDFLAGS"] + " "
+                                + pass_on_options + " " + output_option + " "
+                                + objfiles + " " + libfiles + " "
+                                + ldflags + " " + vars["LFLAGS"]
+                                + " -loctinterp -loctave "
+                                + " " + vars["OCTAVE_LINK_OPTS"]
+                                + " " + vars["OCTAVE_LINK_DEPS"];
               result = run_command (cmd);
             }
           else
             {
               std::cerr
                 << "mkoctfile: no way to link stand-alone executable file"
                 << std::endl;
               return 1;
             }
         }
       else
         {
-          std::string cmd = vars["DL_LD"] + " " + vars["DL_LDFLAGS"] + " "
-            + pass_on_options + " -o " + octfile + " "
-            + objfiles + " " + libfiles + " " + ldflags + " "
-            + vars["LFLAGS"] + " -loctinterp -loctave "
-            + vars["OCT_LINK_OPTS"] + " " + vars["OCT_LINK_DEPS"];
+          std::string cmd = vars["DL_LD"] + " "
+                            + vars["DL_LDFLAGS"] + " "
+                            + pass_on_options
+                            + " -o " + octfile + " "
+                            + objfiles + " " + libfiles + " "
+                            + ldflags + " "
+                            + vars["LFLAGS"] + " -loctinterp -loctave "
+                            + vars["OCT_LINK_OPTS"] + " "
+                            + vars["OCT_LINK_DEPS"];
           result = run_command (cmd);
         }
 
       if (strip)
         {
           std::string cmd = "strip " + octfile;
           result = run_command (cmd);
         }
