# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444099662 14400
#      Mon Oct 05 22:47:42 2015 -0400
# Node ID 56fee8f84fe70d212b818f631785d42e05789c6d
# Parent  0650b8431037461fd9d75761a92b7a8153fcac4d
eliminate more simple uses of error_state

* cellfun.cc, syscalls.cc, urlwrite.cc, ov.cc, pt-eval.cc:
Eliminate uses of error_state.

diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -178,29 +178,28 @@ try_cellfun_internal_ops (const octave_v
     {
       if (nargin == 3)
         {
           int d = args(2).nint_value () - 1;
 
           if (d < 0)
             error ("cellfun: K must be a positive integer");
 
-          if (! error_state)
+          NDA result (f_args.dims ());
+
+          for (octave_idx_type count = 0; count < k; count++)
             {
-              NDA result (f_args.dims ());
-              for (octave_idx_type count = 0; count < k; count++)
-                {
-                  dim_vector dv = f_args.elem (count).dims ();
-                  if (d < dv.length ())
-                    result(count) = static_cast<double> (dv(d));
-                  else
-                    result(count) = 1.0;
-                }
-              retval(0) = result;
+              dim_vector dv = f_args.elem (count).dims ();
+              if (d < dv.length ())
+                result(count) = static_cast<double> (dv(d));
+              else
+                result(count) = 1.0;
             }
+
+          retval(0) = result;
         }
       else
         error ("cellfun: not enough arguments for \"size\"");
     }
   else if (name == "isclass")
     {
       if (nargin == 3)
         {
@@ -426,44 +425,44 @@ v = cellfun (@@det, a); # faster\n\
 
       return retval;
     }
 
   if (func.is_string ())
     {
       retval = try_cellfun_internal_ops<boolNDArray,NDArray>(args, nargin);
 
-      if (error_state || ! retval.empty ())
+      if (! retval.empty ())
         return retval;
 
       // See if we can convert the string into a function.
 
       std::string name = args(0).string_value ();
 
       if (! valid_identifier (name))
         {
           std::string fcn_name = unique_symbol_name ("__cellfun_fcn__");
           std::string fname = "function y = " + fcn_name + "(x) y = ";
 
           octave_function *ptr_func
             = extract_function (args(0), "cellfun", fcn_name,
                                 fname, "; endfunction");
 
-          if (ptr_func && ! error_state)
+          if (ptr_func)
             func = octave_value (ptr_func, true);
         }
       else
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
         }
 
-      if (error_state || ! retval.empty ())
+      if (! retval.empty ())
         return retval;
     }
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
 
       bool uniform_output = true;
@@ -502,31 +501,29 @@ v = cellfun (@@det, a); # faster\n\
                 if (uniform_output)
                   retval =
                     try_cellfun_internal_ops<boolNDArray, NDArray> (tmp_args,
                                                                     nargin);
                 else
                   retval =
                     try_cellfun_internal_ops<Cell, Cell> (tmp_args, nargin);
 
-                if (error_state || ! retval.empty ())
+                if (! retval.empty ())
                   return retval;
               }
 
             //Okay, we tried, doesn't work, let's do the best we can
             //instead and avoid polymorphic calls for each element of
             //the array.
             func = f;
           }
       }
+
     nevermind:
 
-      if (error_state)
-        return octave_value_list ();
-
       // Extract cell arguments.
 
       octave_value_list inputlist (nargin, octave_value ());
 
       OCTAVE_LOCAL_BUFFER (Cell, inputs, nargin);
       OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
       // This is to prevent copy-on-write.
@@ -594,19 +591,16 @@ v = cellfun (@@det, a); # faster\n\
                   if (mask[j])
                     inputlist.xelem (j) = cinputs[j](count);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
-              if (error_state)
-                return retval;
-
               if (nargout > 0 && tmp.length () < nargout)
                 {
                   error ("cellfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
@@ -645,33 +639,27 @@ v = cellfun (@@det, a); # faster\n\
 
                               if (! retv[j].fast_elem_insert (count, val))
                                 {
                                   if (val.numel () == 1)
                                     {
                                       idx_list.front ()(0) = count + 1.0;
                                       retv[j].assign (octave_value::op_asn_eq,
                                                       idx_type, idx_list, val);
-
-                                      if (error_state)
-                                        break;
                                     }
                                   else
                                     {
                                       error ("cellfun: all values must be scalars when UniformOutput = true");
                                       break;
                                     }
                                 }
                             }
                         }
                     }
                 }
-
-              if (error_state)
-                break;
             }
 
           retval.resize (nargout1);
 
           for (int j = 0; j < nargout1; j++)
             {
               if (nargout > 0 && retv[j].is_undefined ())
                 retval(j) = NDArray (fdims);
@@ -695,19 +683,16 @@ v = cellfun (@@det, a); # faster\n\
                   if (mask[j])
                     inputlist.xelem (j) = cinputs[j](count);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
-              if (error_state)
-                return retval;
-
               if (nargout > 0 && tmp.length () < nargout)
                 {
                   error ("cellfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
@@ -1197,33 +1182,30 @@ arrayfun (@@str2num, [1234],\n\
         {
           std::string fcn_name = unique_symbol_name ("__arrayfun_fcn__");
           std::string fname = "function y = " + fcn_name + "(x) y = ";
 
           octave_function *ptr_func
             = extract_function (args(0), "arrayfun", fcn_name,
                                 fname, "; endfunction");
 
-          if (ptr_func && ! error_state)
+          if (ptr_func)
             func = octave_value (ptr_func, true);
         }
       else
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
             error_with_id ("Octave:invalid-input-arg",
                            "arrayfun: invalid function NAME: %s",
                            name.c_str ());
 
           symbol_table_lookup = true;
         }
-
-      if (error_state)
-        return retval;
     }
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
       // The following is an optimisation because the symbol table can
       // give a more specific function class, so this can result in
       // fewer polymorphic function calls as the function gets called
@@ -1251,19 +1233,16 @@ arrayfun (@@str2num, [1234],\n\
 
     nevermind:
 
       bool uniform_output = true;
       octave_value error_handler;
 
       get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
-      if (error_state)
-        return octave_value_list ();
-
       octave_value_list inputlist (nargin, octave_value ());
 
       OCTAVE_LOCAL_BUFFER (octave_value, inputs, nargin);
       OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
       octave_idx_type k = 1;
 
       dim_vector fdims (1, 1);
@@ -1320,28 +1299,22 @@ arrayfun (@@str2num, [1234],\n\
           for (octave_idx_type count = 0; count < k; count++)
             {
               idx_list.front ()(0) = count + 1.0;
 
               for (int j = 0; j < nargin; j++)
                 {
                   if (mask[j])
                     inputlist.xelem (j) = inputs[j].do_index_op (idx_list);
-
-                  if (error_state)
-                    return retval;
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
-              if (error_state)
-                return retval;
-
               if (nargout > 0 && tmp.length () < nargout)
                 {
                   error_with_id ("Octave:invalid-fun-call",
                                  "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
@@ -1382,34 +1355,28 @@ arrayfun (@@str2num, [1234],\n\
 
                               if (! retv[j].fast_elem_insert (count, val))
                                 {
                                   if (val.numel () == 1)
                                     {
                                       idx_list.front ()(0) = count + 1.0;
                                       retv[j].assign (octave_value::op_asn_eq,
                                                       idx_type, idx_list, val);
-
-                                      if (error_state)
-                                        break;
                                     }
                                   else
                                     {
                                       error_with_id ("Octave:invalid-fun-call",
                                                      "arrayfun: all values must be scalars when UniformOutput = true");
                                       break;
                                     }
                                 }
                             }
                         }
                     }
                 }
-
-              if (error_state)
-                break;
             }
 
           retval.resize (nargout1);
 
           for (int j = 0; j < nargout1; j++)
             {
               if (nargout > 0 && retv[j].is_undefined ())
                 retval(j) = NDArray (fdims);
@@ -1433,28 +1400,22 @@ arrayfun (@@str2num, [1234],\n\
           for (octave_idx_type count = 0; count < k; count++)
             {
               idx_list.front ()(0) = count + 1.0;
 
               for (int j = 0; j < nargin; j++)
                 {
                   if (mask[j])
                     inputlist.xelem (j) = inputs[j].do_index_op (idx_list);
-
-                  if (error_state)
-                    return retval;
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
-              if (error_state)
-                return retval;
-
               if (nargout > 0 && tmp.length () < nargout)
                 {
                   error_with_id ("Octave:invalid-fun-call",
                                  "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
@@ -1776,18 +1737,16 @@ do_num2cell (const NDA& array, const Arr
 
       return retval;
     }
   else
     {
       dim_vector celldv, arraydv;
       Array<int> perm;
       do_num2cell_helper (array.dims (), dimv, celldv, arraydv, perm);
-      if (error_state)
-        return Cell ();
 
       NDA parray = array.permute (perm);
 
       octave_idx_type nela = arraydv.numel ();
       octave_idx_type nelc = celldv.numel ();
       parray = parray.reshape (dim_vector (nela, nelc));
 
       Cell retval (celldv);
@@ -1829,33 +1788,27 @@ do_object2cell (const octave_value& obj,
   // FIXME: this copy is only needed because the octave_value::size
   // method is not const.
   octave_value array = obj;
 
   if (dimv.is_empty ())
     {
       dim_vector dv = get_object_dims (array);
 
-      if (! error_state)
-        {
-          retval.resize (dv);
+      retval.resize (dv);
 
-          octave_value_list idx (1);
+      octave_value_list idx (1);
 
-          for (octave_idx_type i = 0; i < dv.numel (); i++)
-            {
-              octave_quit ();
-
-              idx(0) = double (i+1);
+      for (octave_idx_type i = 0; i < dv.numel (); i++)
+        {
+          octave_quit ();
 
-              retval.xelem (i) = array.single_subsref ("(", idx);
+          idx(0) = double (i+1);
 
-              if (error_state)
-                break;
-            }
+          retval.xelem (i) = array.single_subsref ("(", idx);
         }
     }
   else
     {
       error ("num2cell (A, dim) not implemented for class objects");
     }
 
   return retval;
@@ -1904,19 +1857,17 @@ num2cell ([1,2;3,4],1)\n\
     print_usage ();
   else
     {
       octave_value array = args(0);
       Array<int> dimv;
       if (nargin > 1)
         dimv = args(1).int_vector_value (true);
 
-      if (error_state)
-        ;
-      else if (array.is_bool_type ())
+      if (array.is_bool_type ())
         retval = do_num2cell (array.bool_array_value (), dimv);
       else if (array.is_char_matrix ())
         retval = do_num2cell (array.char_array_value (), dimv);
       else if (array.is_numeric_type ())
         {
           if (array.is_integer_type ())
             {
               if (array.is_int8_type ())
@@ -2177,19 +2128,16 @@ do_mat2cell (octave_value& a, const Arra
     {
       octave_quit ();
 
       for (int i = 0; i < nd; i++)
         ra_idx(i) = idx[i][ridx[i]];
 
       retval(j) = a.do_index_op (ra_idx);
 
-      if (error_state)
-        break;
-
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 DEFUN (mat2cell, args, ,
        "-*- texinfo -*-\n\
@@ -2242,21 +2190,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
   if (nargin < 2)
     print_usage ();
   else
     {
       // Prepare indices.
       OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
 
       for (int i = 1; i < nargin; i++)
-        {
-          d[i-1] = args(i).octave_idx_type_vector_value (true);
-          if (error_state)
-            return retval;
-        }
+        d[i-1] = args(i).octave_idx_type_vector_value (true);
 
       octave_value a = args(0);
       bool sparse = a.is_sparse_type ();
       if (sparse && nargin > 3)
         {
           error ("mat2cell: sparse arguments only support 2-D indexing");
           return retval;
         }
@@ -2336,30 +2280,30 @@ do_cellslices_nda (const NDA& array,
                    int dim = -1)
 {
   octave_idx_type n = lb.numel ();
   Cell retval (1, n);
   if (array.is_vector () && (dim == -1
                              || (dim == 0 && array.columns () == 1)
                              || (dim == 1 && array.rows () == 1)))
     {
-      for (octave_idx_type i = 0; i < n && ! error_state; i++)
+      for (octave_idx_type i = 0; i < n; i++)
         retval(i) = array.index (idx_vector (lb(i) - 1, ub(i)));
     }
   else
     {
       const dim_vector dv = array.dims ();
       int ndims = dv.length ();
       if (dim < 0)
         dim = dv.first_non_singleton ();
       ndims = std::max (ndims, dim + 1);
 
       Array<idx_vector> idx (dim_vector (ndims, 1), idx_vector::colon);
 
-      for (octave_idx_type i = 0; i < n && ! error_state; i++)
+      for (octave_idx_type i = 0; i < n; i++)
         {
           idx(dim) = idx_vector (lb(i) - 1, ub(i));
           retval(i) = array.index (idx);
         }
     }
 
   return retval;
 }
@@ -2398,98 +2342,95 @@ slicing is done along the first non-sing
       int dim = -1;
       if (nargin == 4)
         {
           dim = args(3).int_value () - 1;
           if (dim < 0)
             error ("cellslices: DIM must be a valid dimension");
         }
 
-      if (! error_state)
+      if (lb.numel () != ub.numel ())
+        error ("cellslices: the lengths of LB and UB must match");
+      else
         {
-          if (lb.numel () != ub.numel ())
-            error ("cellslices: the lengths of LB and UB must match");
-          else
+          Cell retcell;
+          if (! x.is_sparse_type () && x.is_matrix_type ())
             {
-              Cell retcell;
-              if (! x.is_sparse_type () && x.is_matrix_type ())
+              // specialize for some dense arrays.
+              if (x.is_bool_type ())
+                retcell = do_cellslices_nda (x.bool_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_char_matrix ())
+                retcell = do_cellslices_nda (x.char_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_integer_type ())
                 {
-                  // specialize for some dense arrays.
-                  if (x.is_bool_type ())
-                    retcell = do_cellslices_nda (x.bool_array_value (),
+                  if (x.is_int8_type ())
+                    retcell = do_cellslices_nda (x.int8_array_value (),
                                                  lb, ub, dim);
-                  else if (x.is_char_matrix ())
-                    retcell = do_cellslices_nda (x.char_array_value (),
+                  else if (x.is_int16_type ())
+                    retcell = do_cellslices_nda (x.int16_array_value (),
+                                                 lb, ub, dim);
+                  else if (x.is_int32_type ())
+                    retcell = do_cellslices_nda (x.int32_array_value (),
                                                  lb, ub, dim);
-                  else if (x.is_integer_type ())
-                    {
-                      if (x.is_int8_type ())
-                        retcell = do_cellslices_nda (x.int8_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_int16_type ())
-                        retcell = do_cellslices_nda (x.int16_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_int32_type ())
-                        retcell = do_cellslices_nda (x.int32_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_int64_type ())
-                        retcell = do_cellslices_nda (x.int64_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_uint8_type ())
-                        retcell = do_cellslices_nda (x.uint8_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_uint16_type ())
-                        retcell = do_cellslices_nda (x.uint16_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_uint32_type ())
-                        retcell = do_cellslices_nda (x.uint32_array_value (),
-                                                     lb, ub, dim);
-                      else if (x.is_uint64_type ())
-                        retcell = do_cellslices_nda (x.uint64_array_value (),
-                                                     lb, ub, dim);
-                    }
-                  else if (x.is_complex_type ())
-                    {
-                      if (x.is_single_type ())
-                        retcell = do_cellslices_nda (x.float_complex_array_value (),
-                                                     lb, ub, dim);
-                      else
-                        retcell = do_cellslices_nda (x.complex_array_value (),
-                                                     lb, ub, dim);
-                    }
+                  else if (x.is_int64_type ())
+                    retcell = do_cellslices_nda (x.int64_array_value (),
+                                                 lb, ub, dim);
+                  else if (x.is_uint8_type ())
+                    retcell = do_cellslices_nda (x.uint8_array_value (),
+                                                 lb, ub, dim);
+                  else if (x.is_uint16_type ())
+                    retcell = do_cellslices_nda (x.uint16_array_value (),
+                                                 lb, ub, dim);
+                  else if (x.is_uint32_type ())
+                    retcell = do_cellslices_nda (x.uint32_array_value (),
+                                                 lb, ub, dim);
+                  else if (x.is_uint64_type ())
+                    retcell = do_cellslices_nda (x.uint64_array_value (),
+                                                 lb, ub, dim);
+                }
+              else if (x.is_complex_type ())
+                {
+                  if (x.is_single_type ())
+                    retcell = do_cellslices_nda (x.float_complex_array_value (),
+                                                 lb, ub, dim);
                   else
-                    {
-                      if (x.is_single_type ())
-                        retcell = do_cellslices_nda (x.float_array_value (),
-                                                     lb, ub, dim);
-                      else
-                        retcell = do_cellslices_nda (x.array_value (),
-                                                     lb, ub, dim);
-                    }
+                    retcell = do_cellslices_nda (x.complex_array_value (),
+                                                 lb, ub, dim);
                 }
               else
                 {
-                  // generic code.
-                  octave_idx_type n = lb.numel ();
-                  retcell = Cell (1, n);
-                  const dim_vector dv = x.dims ();
-                  int ndims = dv.length ();
-                  if (dim < 0)
-                    dim = dv.first_non_singleton ();
-                  ndims = std::max (ndims, dim + 1);
-                  octave_value_list idx (ndims, octave_value::magic_colon_t);
-                  for (octave_idx_type i = 0; i < n && ! error_state; i++)
-                    {
-                      idx(dim) = Range (lb(i), ub(i));
-                      retcell(i) = x.do_index_op (idx);
-                    }
+                  if (x.is_single_type ())
+                    retcell = do_cellslices_nda (x.float_array_value (),
+                                                 lb, ub, dim);
+                  else
+                    retcell = do_cellslices_nda (x.array_value (),
+                                                 lb, ub, dim);
                 }
-              if (! error_state)
-                retval = retcell;
             }
+          else
+            {
+              // generic code.
+              octave_idx_type n = lb.numel ();
+              retcell = Cell (1, n);
+              const dim_vector dv = x.dims ();
+              int ndims = dv.length ();
+              if (dim < 0)
+                dim = dv.first_non_singleton ();
+              ndims = std::max (ndims, dim + 1);
+              octave_value_list idx (ndims, octave_value::magic_colon_t);
+              for (octave_idx_type i = 0; i < n; i++)
+                {
+                  idx(dim) = Range (lb(i), ub(i));
+                  retcell(i) = x.do_index_op (idx);
+                }
+            }
+
+          retval = retcell;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -2514,32 +2455,33 @@ for i = 1:numel (X)\n\
   Y@{i@} = X@{i@}(varargin@{:@});\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   if (args.length () >= 1)
     {
       if (args(0).is_cell ())
         {
           const Cell x = args(0).cell_value ();
           NoAlias<Cell> y(x.dims ());
           octave_idx_type nel = x.numel ();
           octave_value_list idx = args.slice (1, args.length () - 1);
 
           for (octave_idx_type i = 0; i < nel; i++)
             {
               octave_quit ();
+
               octave_value tmp = x(i);
+
               y(i) = tmp.do_index_op (idx);
-              if (error_state)
-                break;
             }
 
           retval = y;
         }
       else
         error ("cellindexmat: X must be a cell");
     }
   else
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -132,30 +132,27 @@ error message.\n\
       octave_stream old_stream
         = octave_stream_list::lookup (args(0), "dup2");
 
       if (! error_state)
         {
           octave_stream new_stream
             = octave_stream_list::lookup (args(1), "dup2");
 
-          if (! error_state)
-            {
-              int i_old = old_stream.file_number ();
-              int i_new = new_stream.file_number ();
+          int i_old = old_stream.file_number ();
+          int i_new = new_stream.file_number ();
 
-              if (i_old >= 0 && i_new >= 0)
-                {
-                  std::string msg;
+          if (i_old >= 0 && i_new >= 0)
+            {
+              std::string msg;
 
-                  int status = octave_syscalls::dup2 (i_old, i_new, msg);
+              int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
-                  retval(1) = msg;
-                  retval(0) = status;
-                }
+              retval(1) = msg;
+              retval(0) = status;
             }
         }
       else
         error ("dup2: invalid stream");
     }
   else
     print_usage ();
 
@@ -218,30 +215,27 @@ error message.\n\
             }
           else
             {
               exec_args.resize (1);
 
               exec_args[0] = exec_file;
             }
 
-          if (! error_state)
-            {
-              octave_history_write_timestamp ();
+          octave_history_write_timestamp ();
 
-              if (! command_history::ignoring_entries ())
-                command_history::clean_up_and_save ();
+          if (! command_history::ignoring_entries ())
+            command_history::clean_up_and_save ();
 
-              std::string msg;
-
-              int status = octave_syscalls::execvp (exec_file, exec_args, msg);
+          std::string msg;
 
-              retval(1) = msg;
-              retval(0) = status;
-            }
+          int status = octave_syscalls::execvp (exec_file, exec_args, msg);
+
+          retval(1) = msg;
+          retval(0) = status;
         }
       else
         error ("exec: FILE must be a string");
     }
   else
     print_usage ();
 
   return retval;
@@ -334,46 +328,43 @@ exit status, it will linger until Octave
 
               arg_list[0] = exec_file;
             }
 
           if (! error_state)
             {
               bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
 
-              if (! error_state)
-                {
-                  int fildes[2];
-                  std::string msg;
-                  pid_t pid;
+              int fildes[2];
+              std::string msg;
+              pid_t pid;
 
-                  pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
-                                                 fildes, msg, interactive);
-                  if (pid >= 0)
-                    {
-                      FILE *ifile = fdopen (fildes[1], "r");
-                      FILE *ofile = fdopen (fildes[0], "w");
+              pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
+                                             fildes, msg, interactive);
+              if (pid >= 0)
+                {
+                  FILE *ifile = fdopen (fildes[1], "r");
+                  FILE *ofile = fdopen (fildes[0], "w");
 
-                      std::string nm;
+                  std::string nm;
 
-                      octave_stream is = octave_stdiostream::create (nm, ifile,
-                                                                  std::ios::in);
+                  octave_stream is = octave_stdiostream::create (nm, ifile,
+                                                                 std::ios::in);
 
-                      octave_stream os = octave_stdiostream::create (nm, ofile,
+                  octave_stream os = octave_stdiostream::create (nm, ofile,
                                                                  std::ios::out);
 
-                      Cell file_ids (1, 2);
+                  Cell file_ids (1, 2);
 
-                      retval(2) = pid;
-                      retval(1) = octave_stream_list::insert (is);
-                      retval(0) = octave_stream_list::insert (os);
-                    }
-                  else
-                    error (msg.c_str ());
+                  retval(2) = pid;
+                  retval(1) = octave_stream_list::insert (is);
+                  retval(0) = octave_stream_list::insert (os);
                 }
+              else
+                error (msg.c_str ());
             }
           else
             error ("popen2: all arguments must be strings");
         }
       else
         error ("popen2: COMMAND argument must be a string");
     }
   else
@@ -522,30 +513,27 @@ message.\n\
 
       if (! error_state)
         {
           int fid = strm.file_number ();
 
           int req = args(1).int_value (true);
           int arg = args(2).int_value (true);
 
-          if (! error_state)
+          // FIXME: Need better checking here?
+          if (fid < 0)
+            error ("fcntl: invalid file id");
+          else
             {
-              // FIXME: Need better checking here?
-              if (fid < 0)
-                error ("fcntl: invalid file id");
-              else
-                {
-                  std::string msg;
+              std::string msg;
 
-                  int status = octave_fcntl (fid, req, arg, msg);
+              int status = octave_fcntl (fid, req, arg, msg);
 
-                  retval(1) = msg;
-                  retval(0) = status;
-                }
+              retval(1) = msg;
+              retval(0) = status;
             }
         }
       else
         error ("fcntl: FID, REQUEST, and ARG must be integers");
     }
   else
     print_usage ();
 
@@ -763,30 +751,24 @@ Return 0 if successful, otherwise return
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   if (args.length () == 2)
     {
       pid_t pid = args(0).int_value (true);
 
-      if (! error_state)
-        {
-          int sig = args(1).int_value (true);
+      int sig = args(1).int_value (true);
+
+      std::string msg;
 
-          if (! error_state)
-            {
-              std::string msg;
+      int status = octave_syscalls::kill (pid, sig, msg);
 
-              int status = octave_syscalls::kill (pid, sig, msg);
-
-              retval(1) = msg;
-              retval(0) = status;
-            }
-        }
+      retval(1) = msg;
+      retval(0) = status;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("lstat", Flstat, args, ,
@@ -801,22 +783,19 @@ The function outputs are described in th
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string fname = args(0).string_value ();
 
-      if (! error_state)
-        {
-          file_stat fs (fname, false);
+      file_stat fs (fname, false);
 
-          retval = mk_stat_result (fs);
-        }
+      retval = mk_stat_result (fs);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 // FIXME: This routine also exists verbatim in file-io.cc.
@@ -883,27 +862,24 @@ error message.\n\
           if (! error_state)
             {
               if (octal_mode < 0)
                 error ("mkfifo: MODE must be a positive integer value");
               else
                 {
                   int mode = convert (octal_mode, 8, 10);
 
-                  if (! error_state)
-                    {
-                      std::string msg;
+                  std::string msg;
 
-                      int status = octave_mkfifo (name, mode, msg);
+                  int status = octave_mkfifo (name, mode, msg);
 
-                      retval(0) = status;
+                  retval(0) = status;
 
-                      if (status < 0)
-                        retval(1) = msg;
-                    }
+                  if (status < 0)
+                    retval(1) = msg;
                 }
             }
           else
             error ("mkfifo: MODE must be an integer");
         }
       else
         error ("mkfifo: FILE must be a string");
     }
@@ -1080,33 +1056,27 @@ For example:\n\
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_scalar_type ())
         {
           int fid = octave_stream_list::get_file_number (args(0));
 
-          if (! error_state)
-            {
-              file_fstat fs (fid);
+          file_fstat fs (fid);
 
-              retval = mk_stat_result (fs);
-            }
+          retval = mk_stat_result (fs);
         }
       else
         {
           std::string fname = args(0).string_value ();
 
-          if (! error_state)
-            {
-              file_stat fs (fname);
+          file_stat fs (fname);
 
-              retval = mk_stat_result (fs);
-            }
+          retval = mk_stat_result (fs);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -602,24 +602,20 @@ Undocumented internal function\n\
       host = args(0).string_value ();
 
       if (nargin > 1)
         user = args(1).string_value ();
 
       if (nargin > 2)
         passwd = args(2).string_value ();
 
-      if (! error_state)
-        {
-          curl_handle ch
-            = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
+      curl_handle ch
+        = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
-          if (! error_state)
-            retval = ch.value ();
-        }
+      retval = ch.value ();
     }
 
   return retval;
 }
 
 DEFUN (__ftp_pwd__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
@@ -631,19 +627,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         retval = curl.pwd ();
       else
         error ("__ftp_pwd__: invalid ftp handle");
     }
 
   return retval;
 }
@@ -659,19 +652,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     error ("__ftp_cwd__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string path = "";
 
           if (nargin > 1)
             path = args(1).string_value ();
 
           if (! error_state)
@@ -697,19 +687,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_dir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           if (nargout == 0)
             curl.dir ();
           else
             {
               string_vector sv = curl.list ();
               octave_idx_type n = sv.numel ();
@@ -778,19 +765,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         curl.ascii ();
       else
         error ("__ftp_ascii__: invalid ftp handle");
     }
 
   return retval;
 }
@@ -806,19 +790,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_binary__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         curl.binary ();
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
@@ -834,19 +815,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_close__: incorrect number of arguments");
   else
     {
       curl_handle h = ch_manager::lookup (args(0));
 
-      if (error_state)
-        return retval;
-
       if (h.ok ())
         ch_manager::free (h);
       else
         error ("__ftp_close__: invalid ftp handle");
     }
 
   return retval;
 }
@@ -862,19 +840,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_mode__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         retval = (curl.is_ascii () ? "ascii" : "binary");
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
@@ -890,19 +865,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ();
 
           if (! error_state)
             curl.del (file);
           else
             error ("__ftp_delete__: expecting file name as second argument");
@@ -925,19 +897,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ();
 
           if (! error_state)
             curl.rmdir (dir);
           else
             error ("__ftp_rmdir__: expecting directory name as second argument");
@@ -960,19 +929,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ();
 
           if (! error_state)
             curl.mkdir (dir);
           else
             error ("__ftp_mkdir__: expecting directory name as second argument");
@@ -995,19 +961,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string oldname = args(1).string_value ();
           std::string newname = args(2).string_value ();
 
           if (! error_state)
             curl.rename (oldname, newname);
           else
@@ -1031,19 +994,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string pat = args(1).string_value ();
 
           if (! error_state)
             {
               string_vector file_list;
 
@@ -1122,19 +1082,16 @@ Undocumented internal function\n\
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
-      if (error_state)
-        return retval;
-
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ();
           std::string target;
 
           if (nargin == 3)
             target = args(2).string_value () + file_ops::dir_sep_str ();
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1313,66 +1313,66 @@ octave_value::subsref (const std::string
     return subsref (type, idx, nargout);
 }
 
 octave_value
 octave_value::next_subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
-  if (! error_state && idx.size () > skip)
+  if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::next_subsref (int nargout, const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
-  if (! error_state && idx.size () > skip)
+  if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::next_subsref (int nargout, const std::string& type,
                             const std::list<octave_value_list>& idx,
                             const std::list<octave_lvalue> *lvalue_list,
                             size_t skip)
 {
-  if (! error_state && idx.size () > skip)
+  if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout, lvalue_list);
     }
   else
     return *this;
 }
 
 octave_value
 octave_value::next_subsref (bool auto_add, const std::string& type,
                             const std::list<octave_value_list>& idx,
                             size_t skip)
 {
-  if (! error_state && idx.size () > skip)
+  if (idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, auto_add);
     }
   else
     return *this;
@@ -1438,38 +1438,31 @@ octave_value::assign (assign_op op, cons
   octave_value t_rhs = rhs;
 
   if (op != op_asn_eq)
     {
       if (is_defined ())
         {
           octave_value t = subsref (type, idx);
 
-          if (! error_state)
-            {
-              binary_op binop = op_eq_to_binary_op (op);
-
-              if (! error_state)
-                t_rhs = do_binary_op (binop, t, rhs);
-            }
+          binary_op binop = op_eq_to_binary_op (op);
+
+          t_rhs = do_binary_op (binop, t, rhs);
         }
       else
         error ("in computed assignment A(index) OP= X, A must be defined first");
     }
 
-  if (! error_state)
-    {
-      octave_value tmp = subsasgn (type, idx, t_rhs);
-
-      if (error_state)
-        gripe_assign_failed_or_no_method (assign_op_as_string (op_asn_eq),
-                                          type_name (), rhs.type_name ());
-      else
-        *this = tmp;
-    }
+  octave_value tmp = subsasgn (type, idx, t_rhs);
+
+  if (error_state)
+    gripe_assign_failed_or_no_method (assign_op_as_string (op_asn_eq),
+                                      type_name (), rhs.type_name ());
+  else
+    *this = tmp;
 
   return *this;
 }
 
 octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
@@ -1494,23 +1487,19 @@ octave_value::assign (assign_op op, cons
           // Usually unnecessary, but may be needed (complex arrays).
           maybe_mutate ();
         }
       else
         {
 
           binary_op binop = op_eq_to_binary_op (op);
 
-          if (! error_state)
-            {
-              octave_value t = do_binary_op (binop, *this, rhs);
-
-              if (! error_state)
-                operator = (t);
-            }
+          octave_value t = do_binary_op (binop, *this, rhs);
+
+          operator = (t);
         }
     }
   else
     error ("in computed assignment A OP= X, A must be defined first");
 
   return *this;
 }
 
@@ -1543,17 +1532,17 @@ octave_value::is_equal (const octave_val
 
   // If there is no op_eq for these types, we can't compare values.
 
   if (rows () == test.rows () && columns () == test.columns ())
     {
       octave_value tmp = do_binary_op (octave_value::op_eq, *this, test);
 
       // Empty array also means a match.
-      if (! error_state && tmp.is_defined ())
+      if (tmp.is_defined ())
         retval = tmp.is_true () || tmp.is_empty ();
     }
 
   return retval;
 }
 
 Cell
 octave_value::cell_value (void) const
@@ -1680,22 +1669,19 @@ octave_value::complex_row_vector_value (
 }
 
 Array<double>
 octave_value::vector_value (bool force_string_conv,
                             bool force_vector_conversion) const
 {
   Array<double> retval = array_value (force_string_conv);
 
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "real vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "real vector"));
 }
 
 template <class T>
 static Array<int>
 convert_to_int_array (const Array<octave_int<T> >& A)
 {
   Array<int> retval (A.dims ());
   octave_idx_type n = A.numel ();
@@ -1731,46 +1717,40 @@ octave_value::int_vector_value (bool for
       else if (is_uint8_type ())
         retval = convert_to_int_array (uint8_array_value ());
       else
         retval = array_value (force_string_conv);
     }
   else
     {
       const NDArray a = array_value (force_string_conv);
-      if (! error_state)
+
+      if (require_int)
         {
-          if (require_int)
+          retval.resize (a.dims ());
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
-              retval.resize (a.dims ());
-              for (octave_idx_type i = 0; i < a.numel (); i++)
+              double ai = a.elem (i);
+              int v = static_cast<int> (ai);
+              if (ai == v)
+                retval.xelem (i) = v;
+              else
                 {
-                  double ai = a.elem (i);
-                  int v = static_cast<int> (ai);
-                  if (ai == v)
-                    retval.xelem (i) = v;
-                  else
-                    {
-                      error_with_cfn ("conversion to integer value failed");
-                      break;
-                    }
+                  error_with_cfn ("conversion to integer value failed");
+                  break;
                 }
             }
-          else
-            retval = Array<int> (a);
         }
+      else
+        retval = Array<int> (a);
     }
 
-
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "integer vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "integer vector"));
 }
 
 template <class T>
 static Array<octave_idx_type>
 convert_to_octave_idx_type_array (const Array<octave_int<T> >& A)
 {
   Array<octave_idx_type> retval (A.dims ());
   octave_idx_type n = A.numel ();
@@ -1807,60 +1787,51 @@ octave_value::octave_idx_type_vector_val
       else if (is_uint8_type ())
         retval = convert_to_octave_idx_type_array (uint8_array_value ());
       else
         retval = array_value (force_string_conv);
     }
   else
     {
       const NDArray a = array_value (force_string_conv);
-      if (! error_state)
+
+      if (require_int)
         {
-          if (require_int)
+          retval.resize (a.dims ());
+          for (octave_idx_type i = 0; i < a.numel (); i++)
             {
-              retval.resize (a.dims ());
-              for (octave_idx_type i = 0; i < a.numel (); i++)
+              double ai = a.elem (i);
+              octave_idx_type v = static_cast<octave_idx_type> (ai);
+              if (ai == v)
+                retval.xelem (i) = v;
+              else
                 {
-                  double ai = a.elem (i);
-                  octave_idx_type v = static_cast<octave_idx_type> (ai);
-                  if (ai == v)
-                    retval.xelem (i) = v;
-                  else
-                    {
-                      error_with_cfn ("conversion to integer value failed");
-                      break;
-                    }
+                  error_with_cfn ("conversion to integer value failed");
+                  break;
                 }
             }
-          else
-            retval = Array<octave_idx_type> (a);
         }
+      else
+        retval = Array<octave_idx_type> (a);
     }
 
-
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "integer vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "integer vector"));
 }
 
 Array<Complex>
 octave_value::complex_vector_value (bool force_string_conv,
                                     bool force_vector_conversion) const
 {
   Array<Complex> retval = complex_array_value (force_string_conv);
 
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "complex vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "complex vector"));
 }
 
 FloatColumnVector
 octave_value::float_column_vector_value (bool force_string_conv,
                                          bool frc_vec_conv) const
 {
   return FloatColumnVector (float_vector_value (force_string_conv,
                                                 frc_vec_conv));
@@ -1892,36 +1863,30 @@ octave_value::float_complex_row_vector_v
 }
 
 Array<float>
 octave_value::float_vector_value (bool force_string_conv,
                                   bool force_vector_conversion) const
 {
   Array<float> retval = float_array_value (force_string_conv);
 
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "real vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "real vector"));
 }
 
 Array<FloatComplex>
 octave_value::float_complex_vector_value (bool force_string_conv,
                                           bool force_vector_conversion) const
 {
   Array<FloatComplex> retval = float_complex_array_value (force_string_conv);
 
-  if (error_state)
-    return retval;
-  else
-    return retval.reshape (make_vector_dims (retval.dims (),
-                                             force_vector_conversion,
-                                             type_name (), "complex vector"));
+  return retval.reshape (make_vector_dims (retval.dims (),
+                                           force_vector_conversion,
+                                           type_name (), "complex vector"));
 }
 
 octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
@@ -2961,25 +2926,22 @@ If @var{idx} is an empty structure array
 
   if (args.length () == 2)
     {
       std::string type;
       std::list<octave_value_list> idx;
 
       decode_subscripts ("subsref", args(1), type, idx);
 
-      if (! error_state)
-        {
-          octave_value arg0 = args(0);
-
-          if (type.empty ())
-            retval = arg0;
-          else
-            retval = arg0.subsref (type, idx, nargout);
-        }
+      octave_value arg0 = args(0);
+
+      if (type.empty ())
+        retval = arg0;
+      else
+        retval = arg0.subsref (type, idx, nargout);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
@@ -3019,33 +2981,29 @@ If @var{idx} is an empty structure array
 
   if (args.length () == 3)
     {
       std::string type;
       std::list<octave_value_list> idx;
 
       decode_subscripts ("subsasgn", args(1), type, idx);
 
-      if (! error_state)
+      if (type.empty ())
         {
-          if (type.empty ())
-            {
-              // Regularize a null matrix if stored into a variable.
-
-              retval = args(2).storable_value ();
-            }
-          else
-            {
-              octave_value arg0 = args(0);
-
-              arg0.make_unique ();
-
-              if (! error_state)
-                retval= arg0.subsasgn (type, idx, args(2));
-            }
+          // Regularize a null matrix if stored into a variable.
+
+          retval = args(2).storable_value ();
+        }
+      else
+        {
+          octave_value arg0 = args(0);
+
+          arg0.make_unique ();
+
+          retval= arg0.subsasgn (type, idx, args(2));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -92,45 +92,39 @@ void
 tree_evaluator::visit_binary_expression (tree_binary_expression&)
 {
   panic_impossible ();
 }
 
 void
 tree_evaluator::visit_break_command (tree_break_command& cmd)
 {
-  if (! error_state)
-    {
-      if (debug_mode)
-        do_breakpoint (cmd.is_breakpoint ());
+  if (debug_mode)
+    do_breakpoint (cmd.is_breakpoint ());
 
-      if (statement_context == function || statement_context == script
-          || in_loop_command)
-        tree_break_command::breaking = 1;
-    }
+  if (statement_context == function || statement_context == script
+      || in_loop_command)
+    tree_break_command::breaking = 1;
 }
 
 void
 tree_evaluator::visit_colon_expression (tree_colon_expression&)
 {
   panic_impossible ();
 }
 
 void
 tree_evaluator::visit_continue_command (tree_continue_command& cmd)
 {
-  if (! error_state)
-    {
-      if (debug_mode)
-        do_breakpoint (cmd.is_breakpoint ());
+  if (debug_mode)
+    do_breakpoint (cmd.is_breakpoint ());
 
-      if (statement_context == function || statement_context == script
-          || in_loop_command)
-        tree_continue_command::continuing = 1;
-    }
+  if (statement_context == function || statement_context == script
+      || in_loop_command)
+    tree_continue_command::continuing = 1;
 }
 
 void
 tree_evaluator::reset_debug_state (void)
 {
   debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   dbstep_flag = 0;
@@ -147,33 +141,30 @@ static inline void
 do_global_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_global ();
 
-      if (! error_state)
-        {
-          octave_lvalue ult = id->lvalue ();
+      octave_lvalue ult = id->lvalue ();
 
-          if (ult.is_undefined ())
-            {
-              tree_expression *expr = elt.expression ();
+      if (ult.is_undefined ())
+        {
+          tree_expression *expr = elt.expression ();
 
-              octave_value init_val;
+          octave_value init_val;
 
-              if (expr)
-                init_val = expr->rvalue1 ();
-              else
-                init_val = Matrix ();
+          if (expr)
+            init_val = expr->rvalue1 ();
+          else
+            init_val = Matrix ();
 
-              ult.assign (octave_value::op_asn_eq, init_val);
-            }
+          ult.assign (octave_value::op_asn_eq, init_val);
         }
     }
 }
 
 static inline void
 do_static_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
@@ -207,19 +198,16 @@ tree_evaluator::do_decl_init_list (decl_
   if (init_list)
     {
       for (tree_decl_init_list::iterator p = init_list->begin ();
            p != init_list->end (); p++)
         {
           tree_decl_elt *elt = *p;
 
           fcn (*elt);
-
-          if (error_state)
-            break;
         }
     }
 }
 
 void
 tree_evaluator::visit_global_command (tree_global_command& cmd)
 {
   if (debug_mode)
@@ -250,22 +238,19 @@ tree_decl_elt::eval (void)
   bool retval = false;
 
   if (id && expr)
     {
       octave_lvalue ult = id->lvalue ();
 
       octave_value init_val = expr->rvalue1 ();
 
-      if (! error_state)
-        {
-          ult.assign (octave_value::op_asn_eq, init_val);
+      ult.assign (octave_value::op_asn_eq, init_val);
 
-          retval = true;
-        }
+      retval = true;
     }
 
   return retval;
 }
 #endif
 
 void
 tree_evaluator::visit_decl_init_list (tree_decl_init_list&)
@@ -279,33 +264,29 @@ quit_loop_now (void)
 {
   octave_quit ();
 
   // Maybe handle 'continue N' someday...
 
   if (tree_continue_command::continuing)
     tree_continue_command::continuing--;
 
-  bool quit = (error_state
-               || tree_return_command::returning
+  bool quit = (tree_return_command::returning
                || tree_break_command::breaking
                || tree_continue_command::continuing);
 
   if (tree_break_command::breaking)
     tree_break_command::breaking--;
 
   return quit;
 }
 
 void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
-  if (error_state)
-    return;
-
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
   // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
   // and cmd.maxproc_expr ();
 
   unwind_protect frame;
 
@@ -317,53 +298,50 @@ tree_evaluator::visit_simple_for_command
 
   octave_value rhs = expr->rvalue1 ();
 
 #if HAVE_LLVM
   if (tree_jit::execute (cmd, rhs))
     return;
 #endif
 
-  if (error_state || rhs.is_undefined ())
+  if (rhs.is_undefined ())
     return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
 
     octave_lvalue ult = lhs->lvalue ();
 
-    if (error_state)
-      return;
-
     tree_statement_list *loop_body = cmd.body ();
 
     if (rhs.is_range ())
       {
         Range rng = rhs.range_value ();
 
         octave_idx_type steps = rng.numel ();
 
         for (octave_idx_type i = 0; i < steps; i++)
           {
             octave_value val (rng.elem (i));
 
             ult.assign (octave_value::op_asn_eq, val);
 
-            if (! error_state && loop_body)
+            if (loop_body)
               loop_body->accept (*this);
 
             if (quit_loop_now ())
               break;
           }
       }
     else if (rhs.is_scalar_type ())
       {
         ult.assign (octave_value::op_asn_eq, rhs);
 
-        if (! error_state && loop_body)
+        if (loop_body)
           loop_body->accept (*this);
 
         // Maybe decrement break and continue states.
         quit_loop_now ();
       }
     else if (rhs.is_matrix_type () || rhs.is_cell () || rhs.is_string ()
              || rhs.is_map ())
       {
@@ -399,17 +377,17 @@ tree_evaluator::visit_simple_for_command
             for (octave_idx_type i = 1; i <= steps; i++)
               {
                 // do_index_op expects one-based indices.
                 idx(iidx) = i;
                 octave_value val = arg.do_index_op (idx);
 
                 ult.assign (octave_value::op_asn_eq, val);
 
-                if (! error_state && loop_body)
+                if (loop_body)
                   loop_body->accept (*this);
 
                 if (quit_loop_now ())
                   break;
               }
           }
       }
     else
@@ -418,33 +396,30 @@ tree_evaluator::visit_simple_for_command
                cmd.line (), cmd.column ());
       }
   }
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
-  if (error_state)
-    return;
-
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
-  if (error_state || rhs.is_undefined ())
+  if (rhs.is_undefined ())
     return;
 
   if (rhs.is_map ())
     {
       // Cycle through structure elements.  First element of id_list
       // is set to value and the second is set to the name of the
       // structure element.
 
@@ -476,17 +451,17 @@ tree_evaluator::visit_complex_for_comman
 
           octave_idx_type n = val_lst.numel ();
 
           octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
           val_ref.assign (octave_value::op_asn_eq, val);
           key_ref.assign (octave_value::op_asn_eq, key);
 
-          if (! error_state && loop_body)
+          if (loop_body)
             loop_body->accept (*this);
 
           if (quit_loop_now ())
             break;
         }
     }
   else
     error ("in statement 'for [X, Y] = VAL', VAL must be a structure");
@@ -569,23 +544,20 @@ tree_evaluator::visit_if_command_list (t
       if (statement_context == function || statement_context == script)
         octave_call_stack::set_location (tic->line (), tic->column ());
 
       if (debug_mode && ! tic->is_else_clause ())
         do_breakpoint (tic->is_breakpoint ());
 
       if (tic->is_else_clause () || expr->is_logically_true ("if"))
         {
-          if (! error_state)
-            {
-              tree_statement_list *stmt_lst = tic->commands ();
+          tree_statement_list *stmt_lst = tic->commands ();
 
-              if (stmt_lst)
-                stmt_lst->accept (*this);
-            }
+          if (stmt_lst)
+            stmt_lst->accept (*this);
 
           break;
         }
     }
 }
 
 void
 tree_evaluator::visit_index_expression (tree_index_expression&)
@@ -652,34 +624,31 @@ void
 tree_evaluator::visit_prefix_expression (tree_prefix_expression&)
 {
   panic_impossible ();
 }
 
 void
 tree_evaluator::visit_return_command (tree_return_command& cmd)
 {
-  if (! error_state)
-    {
-      if (debug_mode)
-        do_breakpoint (cmd.is_breakpoint ());
+  if (debug_mode)
+    do_breakpoint (cmd.is_breakpoint ());
 
-      // Act like dbcont.
+  // Act like dbcont.
 
-      if (Vdebugging
-          && octave_call_stack::current_frame () == current_frame)
-        {
-          Vdebugging = false;
+  if (Vdebugging
+      && octave_call_stack::current_frame () == current_frame)
+    {
+      Vdebugging = false;
 
-          reset_debug_state ();
-        }
-      else if (statement_context == function || statement_context == script
-               || in_loop_command)
-        tree_return_command::returning = 1;
+      reset_debug_state ();
     }
+  else if (statement_context == function || statement_context == script
+           || in_loop_command)
+    tree_return_command::returning = 1;
 }
 
 void
 tree_evaluator::visit_return_list (tree_return_list&)
 {
   panic_impossible ();
 }
 
@@ -740,65 +709,56 @@ tree_evaluator::visit_statement (tree_st
 
                   do_bind_ans = (! id->is_variable ());
                 }
               else
                 do_bind_ans = (! expr->is_assignment_expression ());
 
               octave_value tmp_result = expr->rvalue1 (0);
 
-              if (do_bind_ans && ! (error_state || tmp_result.is_undefined ()))
+              if (do_bind_ans && tmp_result.is_defined ())
                 bind_ans (tmp_result, expr->print_result ()
                           && statement_printing_enabled ());
 
               //              if (tmp_result.is_defined ())
               //                result_values(0) = tmp_result;
             }
         }
       catch (const std::bad_alloc&)
         {
-          // FIXME: We want to use error_with_id here so that we set
-          // the error state, give users control over this error
-          // message, and so that we set the error_state appropriately
-          // so we'll get stack trace info when appropriate.  But
-          // error_with_id will require some memory allocations.  Is
-          // there anything we can do to make those more likely to
-          // succeed?
+          // FIXME: We want to use error_with_id here so that give users
+          // control over this error message but error_with_id will
+          // require some memory allocations.  Is there anything we can
+          // do to make those more likely to succeed?
 
           error_with_id ("Octave:bad-alloc",
                          "out of memory or dimension too large for Octave's index type");
         }
     }
 }
 
 void
 tree_evaluator::visit_statement_list (tree_statement_list& lst)
 {
   static octave_value_list empty_list;
 
-  if (error_state)
-    return;
-
   tree_statement_list::iterator p = lst.begin ();
 
   if (p != lst.end ())
     {
       while (true)
         {
           tree_statement *elt = *p++;
 
           if (elt)
             {
               octave_quit ();
 
               elt->accept (*this);
 
-              if (error_state)
-                break;
-
               if (tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
 
               if (tree_return_command::returning)
                 break;
 
               if (p == lst.end ())
@@ -848,28 +808,25 @@ tree_evaluator::visit_switch_command (tr
   tree_expression *expr = cmd.switch_value ();
 
   if (expr)
     {
       octave_value val = expr->rvalue1 ();
 
       tree_switch_case_list *lst = cmd.case_list ();
 
-      if (! error_state && lst)
+      if (lst)
         {
           for (tree_switch_case_list::iterator p = lst->begin ();
                p != lst->end (); p++)
             {
               tree_switch_case *t = *p;
 
               if (t->is_default_case () || t->label_matches (val))
                 {
-                  if (error_state)
-                    break;
-
                   tree_statement_list *stmt_lst = t->commands ();
 
                   if (stmt_lst)
                     stmt_lst->accept (*this);
 
                   break;
                 }
             }
@@ -1055,32 +1012,27 @@ tree_evaluator::visit_unwind_protect_com
       catch (const octave_execution_exception&)
         {
           unwind_protect_exception = true;
 
           // Run the cleanup code on exceptions, so that it is run even in case
           // of interrupt or out-of-memory.
           do_unwind_protect_cleanup_code (cleanup_code);
 
-          // FIXME: should error_state be checked here?
-          // We want to rethrow the exception, even if error_state is set, so
-          // that interrupts continue.
+          // We want to rethrow the exception so that interrupts continue.
           throw;
         }
 
       do_unwind_protect_cleanup_code (cleanup_code);
     }
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
-  if (error_state)
-    return;
-
 #if HAVE_LLVM
   if (tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
@@ -1097,37 +1049,29 @@ tree_evaluator::visit_while_command (tre
       if (debug_mode)
         do_breakpoint (cmd.is_breakpoint ());
 
       if (expr->is_logically_true ("while"))
         {
           tree_statement_list *loop_body = cmd.body ();
 
           if (loop_body)
-            {
-              loop_body->accept (*this);
-
-              if (error_state)
-                return;
-            }
+            loop_body->accept (*this);
 
           if (quit_loop_now ())
             break;
         }
       else
         break;
     }
 }
 
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
-  if (error_state)
-    return;
-
 #if HAVE_LLVM
   if (tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
@@ -1139,22 +1083,17 @@ tree_evaluator::visit_do_until_command (
   if (! expr)
     panic_impossible ();
 
   for (;;)
     {
       tree_statement_list *loop_body = cmd.body ();
 
       if (loop_body)
-        {
-          loop_body->accept (*this);
-
-          if (error_state)
-            return;
-        }
+        loop_body->accept (*this);
 
       if (quit_loop_now ())
         break;
 
       if (debug_mode)
         do_breakpoint (cmd.is_breakpoint ());
 
       if (expr->is_logically_true ("do-until"))
