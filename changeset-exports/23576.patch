# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497220521 25200
#      Sun Jun 11 15:35:21 2017 -0700
# Node ID 00e518162fda5008a94611152ab31ae1ef2dbbca
# Parent  e95738a119dacd21bacaa03a8df626bbca895aac
maint: Deprecate is_cell and replace with iscell.

* ov.h (is_cell): Use OCTAVE_DEPRECATED macro around is_cell function.
* ov.h (iscell): New function.

* cellfun.cc, daspk.cc, dasrt.cc, dassl.cc, data.cc, debug.cc, graphics.cc,
graphics.in.h, ls-mat5.cc, lsode.cc, mex.cc, mxarray.in.h, oct-stream.cc,
regexp.cc, str2double.cc, strfind.cc, strfns.cc, utils.cc, ov-base.h,
ov-cell.cc, ov-cell.h, ov-class.cc, ov-classdef.cc, ov-java.cc, ov-struct.cc,
ov.cc, ovl.cc, bp-table.cc, pt-cell.h, pt-eval.cc, pt-exp.h, pt-idx.cc,
pt-tm-const.cc: Replace instances of is_cell with iscell.

diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -397,17 +397,17 @@ v = cellfun (@@det, a); # faster
 @seealso{arrayfun, structfun, spfun}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
-  if (! args(1).is_cell ())
+  if (! args(1).iscell ())
     error ("cellfun: C must be a cell array");
 
   octave_value_list retval;
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   octave_value func = args(0);
 
   if (func.is_string ())
@@ -511,17 +511,17 @@ v = cellfun (@@det, a); # faster
   octave_idx_type k = 1;
 
   dim_vector fdims (1, 1);
 
   // Collect arguments.  Pre-fill scalar elements of inputlist array.
 
   for (int j = 0; j < nargin; j++)
     {
-      if (! args(j+1).is_cell ())
+      if (! args(j+1).iscell ())
         error ("cellfun: arguments must be cells");
 
       inputs[j] = args(j+1).cell_value ();
       mask[j] = inputs[j].numel () != 1;
       if (! mask[j])
         inputlist(j) = cinputs[j](0);
     }
 
@@ -1821,17 +1821,17 @@ num2cell ([1,2;3,4],1)
           else
             retval = do_num2cell (array.array_value (), dimv);
         }
     }
   else if (array.is_object ())
     retval = do_object2cell (array, dimv);
   else if (array.is_map ())
     retval = do_num2cell (array.map_value (), dimv);
-  else if (array.is_cell ())
+  else if (array.iscell ())
     retval = do_num2cell (array.cell_value (), dimv);
   else
     err_wrong_type_arg ("num2cell", array);
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -274,17 +274,17 @@ parameters for @code{daspk}.
     error ("daspk: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
   daspk_fcn = 0;
   daspk_jac = 0;
 
   octave_value f_arg = args(0);
 
-  if (f_arg.is_cell ())
+  if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             daspk_fcn = c(0).function_value ();
@@ -319,17 +319,17 @@ parameters for @code{daspk}.
                     }
                 }
             }
         }
       else
         error ("daspk: incorrect number of elements in cell array");
     }
 
-  if (! daspk_fcn && ! f_arg.is_cell ())
+  if (! daspk_fcn && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         daspk_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -357,17 +357,17 @@ parameters for @code{dasrt}.
   dasrt_cf = 0;
 
   // Check all the arguments.  Are they the right animals?
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
-  if (f_arg.is_cell ())
+  if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dasrt_f = c(0).function_value ();
@@ -402,17 +402,17 @@ parameters for @code{dasrt}.
                     }
                 }
             }
         }
       else
         error ("dasrt: incorrect number of elements in cell array");
     }
 
-  if (! dasrt_f && ! f_arg.is_cell ())
+  if (! dasrt_f && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dasrt_f = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -275,17 +275,17 @@ parameters for @code{dassl}.
     error ("dassl: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
   dassl_fcn = 0;
   dassl_jac = 0;
 
   octave_value f_arg = args(0);
 
-  if (f_arg.is_cell ())
+  if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dassl_fcn = c(0).function_value ();
@@ -320,17 +320,17 @@ parameters for @code{dassl}.
                     }
                 }
             }
         }
       else
         error ("dassl: incorrect number of elements in cell array");
     }
 
-  if (! dassl_fcn && ! f_arg.is_cell ())
+  if (! dassl_fcn && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dassl_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1800,28 +1800,28 @@ do_cat (const octave_value_list& xargs, 
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
           if (all_cmplx_p && ! (args(i).is_complex_type ()
                                 || args(i).is_real_type ()))
             all_cmplx_p = false;
           if (! any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
-          if (! any_cell_p && args(i).is_cell ())
+          if (! any_cell_p && args(i).iscell ())
             any_cell_p = true;
           if (! any_class_p && args(i).is_object ())
             any_class_p = true;
         }
 
       if (any_cell_p && ! any_class_p && ! first_elem_is_struct)
         {
           int j = 0;
           for (int i = 0; i < n_args; i++)
             {
-              if (args(i).is_cell ())
+              if (args(i).iscell ())
                 args(j++) = args(i);
               else
                 {
                   if (args(i).is_empty ())
                     continue;  // Delete empty non-cell arg
                   else
                     args(j++) = Cell (args(i));
                 }
@@ -7372,17 +7372,17 @@ converted to logical.
       else if (tval.is_string () && fval.is_string ())
         {
           bool sq_string = tval.is_sq_string () || fval.is_sq_string ();
           retval = octave_value (do_merge (mask,
                                            tval.char_array_value (),
                                            fval.char_array_value ()),
                                  sq_string ? '\'' : '"');
         }
-      else if (tval.is_cell () && fval.is_cell ())
+      else if (tval.iscell () && fval.iscell ())
         {
           retval = do_merge (mask,
                              tval.cell_value (),
                              fval.cell_value ());
         }
 
       MAKE_INT_BRANCH (int8)
       MAKE_INT_BRANCH (int16)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -204,17 +204,17 @@ all breakpoints within the file are clea
           bp_table::dbstop_process_map_args (mv);
 
           // Replace mv by "bkpt", to use the processing below.
           octave_value bkpt = mv.getfield ("bkpt");
           if (bkpt.is_empty ())
             mv = octave_map ();
           else
             {
-              if (bkpt.is_cell () && bkpt.cell_value ().numel () > 0
+              if (bkpt.iscell () && bkpt.cell_value ().numel () > 0
                   && bkpt.cell_value () (0).is_map ())
                 mv = bkpt.cell_value () (0).map_value ();
               else
                 {
                   error ("dbstop: invalid 'bkpt' field");
                   mv = octave_map ();
                 }
             }
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1744,17 +1744,17 @@ callback_property::validate (const octav
 
   if (v.is_empty ())
     return true;
   else if (v.is_function_handle ())
     return true;
   else if (v.is_string ())
     // complete validation will be done at execution-time
     return true;
-  else if (v.is_cell () && (v.rows () == 1 || v.columns () == 1)
+  else if (v.iscell () && (v.rows () == 1 || v.columns () == 1)
            && v.cell_value ()(0).is_function_handle ())
     return true;
 
   return false;
 }
 
 // If TRUE, we are executing any callback function, or the functions it calls.
 // Used to determine handle visibility inside callback functions.
@@ -9892,17 +9892,17 @@ gh_manager::do_execute_callback (const g
           catch (octave::execution_exception&)
             {
               std::cerr << "execution error in graphics callback function"
                         << std::endl;
               Flasterr (ovl ("execution error in graphics callback function"));
               octave::interpreter::recover_from_exception ();
             }
         }
-      else if (cb.is_cell () && cb.length () > 0
+      else if (cb.iscell () && cb.length () > 0
                && (cb.rows () == 1 || cb.columns () == 1)
                && (cb.cell_value ()(0).is_function ()
                    || cb.cell_value ()(0).is_function_handle ()))
         {
           Cell c = cb.cell_value ();
 
           fcn = c(0).function_value ();
 
@@ -10429,17 +10429,17 @@ being @qcode{"portrait"}.
   // loop over graphics objects
   for (octave_idx_type n = 0; n < hcv.numel (); n++)
     {
       graphics_object go = gh_manager::get_object (hcv(n));
 
       if (! go)
         error ("set: invalid handle (= %g)", hcv(n));
 
-      if (nargin == 3 && args(1).iscellstr () && args(2).is_cell ())
+      if (nargin == 3 && args(1).iscellstr () && args(2).iscell ())
         {
           if (args(2).cell_value ().rows () == 1)
             go.set (args(1).cellstr_value (), args(2).cell_value (), 0);
           else if (hcv.numel () == args(2).cell_value ().rows ())
             go.set (args(1).cellstr_value (), args(2).cell_value (), n);
           else
             error ("set: number of graphics handles must match number of value rows (%d != %d)",
                    hcv.numel (), args(2).cell_value ().rows ());
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -756,17 +756,17 @@ protected:
   bool do_set (const octave_value& val)
   {
     if (val.is_string ())
       {
         value = val.string_vector_value ();
 
         stored_type = char_t;
       }
-    else if (val.is_cell ())
+    else if (val.iscell ())
       {
         Cell c = val.cell_value ();
 
         octave_idx_type nel = c.numel ();
 
         value.resize (nel);
 
         for (octave_idx_type i = 0; i < nel; i++)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2137,17 +2137,17 @@ save_mat5_element_length (const octave_v
         }
       else
         {
           const NDArray m = tc.array_value ();
           ret += save_mat5_array_length (m.fortran_vec (), m.numel (),
                                          save_as_floats);
         }
     }
-  else if (tc.is_cell ())
+  else if (tc.iscell ())
     {
       Cell cell = tc.cell_value ();
       octave_idx_type nel = cell.numel ();
 
       for (int i = 0; i < nel; i++)
         ret += 8 +
           save_mat5_element_length (cell (i), "", save_as_floats, mat7_format);
     }
@@ -2371,17 +2371,17 @@ save_mat5_binary_element (std::ostream& 
     {
       if (tc.is_single_type ())
         flags |= MAT_FILE_SINGLE_CLASS;
       else
         flags |= MAT_FILE_DOUBLE_CLASS;
     }
   else if (tc.is_map ())
     flags |= MAT_FILE_STRUCT_CLASS;
-  else if (tc.is_cell ())
+  else if (tc.iscell ())
     flags |= MAT_FILE_CELL_CLASS;
   else if (tc.is_inline_function () || tc.is_object ())
     flags |= MAT_FILE_OBJECT_CLASS;
   else
     {
       // FIXME: Should this just error out rather than warn?
       warn_wrong_type_arg ("save", tc);
       error ("save: error while writing '%s' to MAT file", name.c_str ());
@@ -2554,17 +2554,17 @@ save_mat5_binary_element (std::ostream& 
         }
       else
         {
           NDArray m = tc.array_value ();
 
           write_mat5_array (os, m, save_as_floats);
         }
     }
-  else if (tc.is_cell ())
+  else if (tc.iscell ())
     {
       Cell cell = tc.cell_value ();
 
       if (! write_mat5_cell_array (os, cell, mark_global, save_as_floats))
         error ("save: error while writing '%s' to MAT file", name.c_str ());
     }
   else if (tc.is_complex_scalar () || tc.is_complex_matrix ())
     {
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -275,17 +275,17 @@ parameters for @code{lsode}.
     error ("lsode: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
   lsode_fcn = 0;
   lsode_jac = 0;
 
   octave_value f_arg = args(0);
 
-  if (f_arg.is_cell ())
+  if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
       else if (c.numel () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             lsode_fcn = c(0).function_value ();
@@ -320,17 +320,17 @@ parameters for @code{lsode}.
                     }
                 }
             }
         }
       else
         error ("lsode: incorrect number of elements in cell array");
     }
 
-  if (! lsode_fcn && ! f_arg.is_cell ())
+  if (! lsode_fcn && ! f_arg.iscell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         lsode_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -209,17 +209,17 @@ public:
   ~mxArray_octave_value (void)
   {
     mxFree (class_name);
     mxFree (dims);
   }
 
   bool is_octave_value (void) const { return true; }
 
-  int is_cell (void) const { return val.is_cell (); }
+  int iscell (void) const { return val.iscell (); }
 
   int is_char (void) const { return val.is_string (); }
 
   int is_complex (void) const { return val.is_complex_type (); }
 
   int is_double (void) const { return val.is_double_type (); }
 
   int is_function_handle (void) const { return val.is_function_handle (); }
@@ -709,17 +709,17 @@ public:
   mxArray_matlab& operator = (const mxArray_matlab&);
 
   ~mxArray_matlab (void)
   {
     mxFree (class_name);
     mxFree (dims);
   }
 
-  int is_cell (void) const { return id == mxCELL_CLASS; }
+  int iscell (void) const { return id == mxCELL_CLASS; }
 
   int is_char (void) const { return id == mxCHAR_CLASS; }
 
   int is_complex (void) const { return 0; }
 
   int is_double (void) const { return id == mxDOUBLE_CLASS; }
 
   int is_function_handle (void) const { return id == mxFUNCTION_CLASS; }
@@ -2655,17 +2655,17 @@ mxDestroyArray (mxArray *ptr)
   if (! (mex_context && mex_context->free_value (ptr)))
     delete ptr;
 }
 
 // Type Predicates.
 bool
 mxIsCell (const mxArray *ptr)
 {
-  return ptr->is_cell ();
+  return ptr->iscell ();
 }
 
 bool
 mxIsChar (const mxArray *ptr)
 {
   return ptr->is_char ();
 }
 
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -138,17 +138,17 @@ public:
   virtual mxArray_base * dup (void) const = 0;
 
   virtual mxArray * as_mxArray (void) const { return 0; }
 
   virtual ~mxArray_base (void) = default;
 
   virtual bool is_octave_value (void) const { return false; }
 
-  virtual int is_cell (void) const = 0;
+  virtual int iscell (void) const = 0;
 
   virtual int is_char (void) const = 0;
 
   virtual int is_class (const char *name_arg) const
   {
     int retval = 0;
 
     const char *cname = get_class_name ();
@@ -363,17 +363,17 @@ public:
   mxArray (const mxArray&) = delete;
 
   mxArray& operator = (const mxArray&) = delete;
 
   ~mxArray (void);
 
   bool is_octave_value (void) const { return rep->is_octave_value (); }
 
-  int is_cell (void) const { return rep->is_cell (); }
+  int iscell (void) const { return rep->iscell (); }
 
   int is_char (void) const { return rep->is_char (); }
 
   int is_class (const char *name_arg) const { return rep->is_class (name_arg); }
 
   int is_complex (void) const { return rep->is_complex (); }
 
   int is_double (void) const { return rep->is_double (); }
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3568,17 +3568,17 @@ namespace octave
             if (args(i+1).is_string ())
               {
                 invalid = false;
                 have_delims = true;
                 delims = args(i+1).string_value ();
                 if (args(i+1).is_sq_string ())
                   delims = do_string_escapes (delims);
               }
-            else if (args(i+1).is_cell ())
+            else if (args(i+1).iscell ())
               {
                 invalid = false;
                 delim_list = args(i+1).cell_value ();
                 delim_table = " "; // non-empty, to flag non-default delim
 
                 // Check that all elements are strings, and find max length
                 for (int j = 0; j < delim_list.numel (); j++)
                   {
@@ -3601,17 +3601,17 @@ namespace octave
           }
         else if (param == "commentstyle")
           {
             if (args(i+1).is_string ())
               {
                 // check here for names like "C++", "C", "shell", ...?
                 comment_style = Cell (args(i+1));
               }
-            else if (args(i+1).is_cell ())
+            else if (args(i+1).iscell ())
               {
                 comment_style = args(i+1).cell_value ();
                 int len = comment_style.numel ();
                 if ((len >= 1 && ! comment_style (0).is_string ())
                     || (len >= 2 && ! comment_style (1).is_string ())
                     || (len >= 3))
                   error ("%s: CommentStyle must be either a string or cell array of one or two strings",
                          who.c_str ());
@@ -3631,17 +3631,17 @@ namespace octave
         else if (param == "treatasempty")
           {
             bool invalid = false;
             if (args(i+1).is_string ())
               {
                 treat_as_empty = Cell (args(i+1));
                 treat_as_empty_len = args(i+1).string_value ().size ();
               }
-            else if (args(i+1).is_cell ())
+            else if (args(i+1).iscell ())
               {
                 treat_as_empty = args(i+1).cell_value ();
                 for (int j = 0; j < treat_as_empty.numel (); j++)
                   if (! treat_as_empty (j).is_string ())
                     invalid = true;
                   else
                     {
                       int k = treat_as_empty (j).string_value ().size ();
@@ -5295,17 +5295,17 @@ namespace octave
       : values (args), val_idx (0), elt_idx (0),
         n_vals (values.length ()), n_elts (0), have_data (false),
         curr_state (ok)
     {
       for (octave_idx_type i = 0; i < values.length (); i++)
         {
           octave_value val = values(i);
 
-          if (val.is_map () || val.is_cell () || val.is_object ())
+          if (val.is_map () || val.iscell () || val.is_object ())
             err_wrong_type_arg (who, val);
         }
     }
 
     // No copying!
 
     printf_value_cache (const printf_value_cache&) = delete;
 
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -516,22 +516,22 @@ octregexp (const octave_value_list& args
 }
 
 static octave_value_list
 octcellregexp (const octave_value_list& args, int nargout,
                const std::string& who, bool case_insensitive = false)
 {
   octave_value_list retval;
 
-  if (args(0).is_cell ())
+  if (args(0).iscell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellstr = args(0).cell_value ();
-      if (args(1).is_cell ())
+      if (args(1).iscell ())
         {
           Cell cellpat = args(1).cell_value ();
 
           if (cellpat.numel () == 1)
             {
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize (cellstr.dims ());
 
@@ -601,17 +601,17 @@ octcellregexp (const octave_value_list& 
               for (int j = 0; j < nargout; j++)
                 newretval[j](i) = tmp(j);
             }
         }
 
       for (int j = 0; j < nargout; j++)
         retval(j) = octave_value (newretval[j]);
     }
-  else if (args(1).is_cell ())
+  else if (args(1).iscell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
         newretval[j].resize (cellpat.dims ());
 
@@ -842,17 +842,17 @@ are zero or more @qcode{'b'} characters 
 @seealso{regexpi, strfind, regexprep}
 @end deftypefn */)
 {
   if (args.length () < 2)
     print_usage ();
 
   octave_value_list retval;
 
-  if (args(0).is_cell () || args(1).is_cell ())
+  if (args(0).iscell () || args(1).iscell ())
     retval = (octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp"));
   else
     retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
@@ -1135,17 +1135,17 @@ Search for @var{pat} in @var{str} and re
 any matches, or empty values if there are none.  @xref{XREFregexp,,regexp},
 for details on the syntax of the search pattern.
 @seealso{regexp}
 @end deftypefn */)
 {
   if (args.length () < 2)
     print_usage ();
 
-  if (args(0).is_cell () || args(1).is_cell ())
+  if (args(0).iscell () || args(1).iscell ())
     return octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
   else
     return octregexp (args, nargout, "regexpi", true);
 }
 
 /*
 ## segfault test
 %!assert (regexpi ("abcde", "."), [1,2,3,4,5])
@@ -1363,33 +1363,33 @@ function.
 @seealso{regexp, regexpi, strrep}
 @end deftypefn */)
 {
   if (args.length () < 3)
     print_usage ();
 
   octave_value_list retval;
 
-  if (args(0).is_cell () || args(1).is_cell () || args(2).is_cell ())
+  if (args(0).iscell () || args(1).iscell () || args(2).iscell ())
     {
       Cell str, pat, rep;
       dim_vector dv0;
       dim_vector dv1 (1, 1);
 
-      if (args(0).is_cell ())
+      if (args(0).iscell ())
         str = args(0).cell_value ();
       else
         str = Cell (args(0));
 
-      if (args(1).is_cell ())
+      if (args(1).iscell ())
         pat = args(1).cell_value ();
       else
         pat = Cell (args(1));
 
-      if (args(2).is_cell ())
+      if (args(2).iscell ())
         rep = args(2).cell_value ();
       else
         rep = Cell (args(2));
 
       dv0 = str.dims ();
       if (pat.numel () != 1)
         {
           dv1 = pat.dims ();
@@ -1417,17 +1417,17 @@ function.
               if (rep.numel () != 1)
                 new_args(2) = rep(j);
               new_args(0) = octregexprep (new_args, "regexprep");
             }
 
           ret(i) = new_args(0);
         }
 
-      retval = (args(0).is_cell () ? ovl (ret) : ovl (ret(0)));
+      retval = (args(0).iscell () ? ovl (ret) : ovl (ret(0)));
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -354,17 +354,17 @@ risk of using @code{eval} on unknown dat
         retval = str2double1 (args(0).string_value ());
       else
         {
           const string_vector sv = args(0).string_vector_value ();
 
           retval = sv.map<Complex> (str2double1);
         }
     }
-  else if (args(0).is_cell ())
+  else if (args(0).iscell ())
     {
       const Cell cell = args(0).cell_value ();
 
       ComplexNDArray output (cell.dims (), octave::numeric_limits<double>::NaN ());
 
       for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
           if (cell(i).is_string ())
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -223,17 +223,17 @@ strfind (@{"abababa", "bebebe", "ab"@}, 
         if (argpat.is_empty ())
           // Return a null matrix for null pattern for MW compatibility
           retval = Matrix ();
         else
           retval = octave_value (qs_search (needle,
                                             argstr.char_array_value (),
                                             table, overlaps),
                                  true, true);
-      else if (argstr.is_cell ())
+      else if (argstr.iscell ())
         {
           const Cell argsc = argstr.cell_value ();
           Cell retc (argsc.dims ());
           octave_idx_type ns = argsc.numel ();
 
           for (octave_idx_type i = 0; i < ns; i++)
             {
               octave_value argse = argsc(i);
@@ -249,17 +249,17 @@ strfind (@{"abababa", "bebebe", "ab"@}, 
                                         true, true);
             }
 
           retval = retc;
         }
       else
         error ("strfind: first argument must be a string or cell array of strings");
     }
-  else if (argpat.is_cell ())
+  else if (argpat.iscell ())
     retval = do_simple_cellfun (Fstrfind, "strfind", args);
   else
     error ("strfind: PATTERN must be a string or cell array of strings");
 
   return retval;
 }
 
 /*
@@ -406,17 +406,17 @@ strrep ("This is a test string", "is", "
       const Array<char> rep = argrep.char_array_value ();
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
       qs_preprocess (pat, table);
 
       if (argstr.is_string ())
         retval = qs_replace (argstr.char_array_value (), pat, rep,
                              table, overlaps);
-      else if (argstr.is_cell ())
+      else if (argstr.iscell ())
         {
           const Cell argsc = argstr.cell_value ();
           Cell retc (argsc.dims ());
           octave_idx_type ns = argsc.numel ();
 
           for (octave_idx_type i = 0; i < ns; i++)
             {
               octave_value argse = argsc(i);
@@ -427,17 +427,17 @@ strrep ("This is a test string", "is", "
                 error ("strrep: each element of S must be a string");
             }
 
           retval = retc;
         }
       else
         error ("strrep: S must be a string or cell array of strings");
     }
-  else if (argpat.is_cell () || argrep.is_cell ())
+  else if (argpat.iscell () || argrep.iscell ())
     retval = do_simple_cellfun (Fstrrep, "strrep", args);
   else
     error ("strrep: PTN and REP arguments must be strings or cell arrays of strings");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -319,19 +319,19 @@ do_strcmp_fun (const octave_value& arg0,
                                  octave_idx_type),
                bool (*str_op) (const std::string&, const std::string&,
                                std::string::size_type))
 
 {
   octave_value retval;
 
   bool s1_string = arg0.is_string ();
-  bool s1_cell = arg0.is_cell ();
+  bool s1_cell = arg0.iscell ();
   bool s2_string = arg1.is_string ();
-  bool s2_cell = arg1.is_cell ();
+  bool s2_cell = arg1.iscell ();
 
   if (s1_string && s2_string)
     retval = array_op (arg0.char_array_value (), arg1.char_array_value (), n);
   else if ((s1_string && s2_cell) || (s1_cell && s2_string))
     {
       octave_value str_val, cell_val;
 
       if (s1_string)
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1438,17 +1438,17 @@ do_simple_cellfun (octave_value_list (*f
   const Cell *ccells = cells;
 
   octave_idx_type numel = 1;
   dim_vector dims (1, 1);
 
   for (int i = 0; i < nargin; i++)
     {
       octave_value arg = new_args(i);
-      iscell[i] = arg.is_cell ();
+      iscell[i] = arg.iscell ();
       if (iscell[i])
         {
           cells[i] = arg.cell_value ();
           octave_idx_type n = ccells[i].numel ();
           if (n == 1)
             {
               iscell[i] = false;
               new_args(i) = ccells[i](0);
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -334,17 +334,17 @@ public:
   virtual MatrixType matrix_type (void) const;
 
   virtual MatrixType matrix_type (const MatrixType& typ) const;
 
   virtual bool is_defined (void) const { return false; }
 
   bool is_empty (void) const { return (dims ().any_zero ()); }
 
-  virtual bool is_cell (void) const { return false; }
+  virtual bool iscell (void) const { return false; }
 
   virtual bool iscellstr (void) const { return false; }
 
   virtual bool is_real_scalar (void) const { return false; }
 
   virtual bool is_real_matrix (void) const { return false; }
 
   virtual bool is_complex_scalar (void) const { return false; }
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -78,17 +78,17 @@ octave_base_matrix<Cell>::assign (const 
 }
 
 template <>
 void
 octave_base_matrix<Cell>::assign (const octave_value_list& idx,
                                   octave_value rhs)
 {
   // FIXME: Really?
-  if (rhs.is_cell ())
+  if (rhs.iscell ())
     matrix.assign (idx, rhs.cell_value ());
   else
     matrix.assign (idx, Cell (rhs));
 }
 
 template <>
 void
 octave_base_matrix<Cell>::delete_elements (const octave_value_list& idx)
@@ -327,17 +327,17 @@ octave_cell::subsasgn (const std::string
     }
 
   switch (type[0])
     {
     case '(':
       {
         octave_value_list i = idx.front ();
 
-        if (t_rhs.is_cell ())
+        if (t_rhs.iscell ())
           octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
         else if (t_rhs.is_null_value ())
           octave_base_matrix<Cell>::delete_elements (i);
         else
           octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
         count++;
         retval = octave_value (this);
@@ -1203,17 +1203,17 @@ DEFUN (iscell, args, ,
 @deftypefn {} {} iscell (@var{x})
 Return true if @var{x} is a cell array object.
 @seealso{ismatrix, isstruct, iscellstr, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_cell ());
+  return ovl (args(0).iscell ());
 }
 
 DEFUN (cell, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} cell (@var{n})
 @deftypefnx {} {} cell (@var{m}, @var{n})
 @deftypefnx {} {} cell (@var{m}, @var{n}, @var{k}, @dots{})
 @deftypefnx {} {} cell ([@var{m} @var{n} @dots{}])
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -112,17 +112,17 @@ public:
   bool is_matrix_type (void) const { return false; }
 
   bool is_numeric_type (void) const { return false; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
-  bool is_cell (void) const { return true; }
+  bool iscell (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_cell; }
 
   bool iscellstr (void) const;
 
   bool is_true (void) const;
 
   Cell cell_value (void) const { return matrix; }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1199,17 +1199,17 @@ octave_class::load_ascii (std::istream& 
 
           // recurse to read cell elements
           std::string nm
             = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
-          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
+          Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
           m.assign (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load class");
 
       c_name = classname;
@@ -1323,17 +1323,17 @@ octave_class::load_binary (std::istream&
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
-          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
+          Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
           m.assign (nm, tcell);
         }
 
       if (is)
         {
           map = m;
 
@@ -1571,17 +1571,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = hdf5_h5g_iterate (group_hid, name, &current_item,
                                          &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
+      Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading class elements") : Cell (t2));
 
       m.assign (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -359,17 +359,17 @@ check_access (const cdef_class& cls, con
                 }
 
               return false;
             }
           else
             panic_impossible ();
         }
     }
-  else if (acc.is_cell ())
+  else if (acc.iscell ())
     {
       Cell acc_c = acc.cell_value ();
 
       cdef_class ctx = get_class_context ();
 
       // At this point, a class context is always required.
 
       if (ctx.ok ())
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1853,17 +1853,17 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
 
       BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
       if (val.is_function_handle ())
         {
           octave_function *fcn = val.function_value ();
           octave::feval (fcn, oct_args);
         }
-      else if (val.is_cell () && val.length () > 0
+      else if (val.iscell () && val.length () > 0
                && (val.rows () == 1 || val.columns () == 1)
                && val.cell_value()(0).is_function_handle ())
         {
           Cell c = val.cell_value ();
           octave_function *fcn = c(0).function_value ();
 
           for (int i=1; i<c.numel (); i++)
             oct_args(len+i-1) = c(i);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -736,17 +736,17 @@ octave_struct::load_ascii (std::istream&
 
           // recurse to read cell elements
           std::string nm
             = read_text_data (is, "", dummy, t2, j);
 
           if (! is)
             break;
 
-          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
+          Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
           m.setfield (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load structure");
 
       map = m;
@@ -849,17 +849,17 @@ octave_struct::load_binary (std::istream
 
           // recurse to read cell elements
           std::string nm = read_binary_data (is, swap, fmt, "",
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
-          Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
+          Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
           m.setfield (nm, tcell);
         }
 
       if (! is)
         error ("load: failed to load structure");
 
       map = m;
@@ -950,17 +950,17 @@ octave_struct::load_hdf5 (octave_hdf5_id
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = hdf5_h5g_iterate (loc_id, name, &current_item,
                                          &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
-      Cell tcell = (t2.is_cell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
+      Cell tcell = (t2.iscell () ? t2.xcell_value ("load: internal error loading struct elements") : Cell (t2));
 
       m.setfield (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
@@ -1731,17 +1731,17 @@ produces a struct @strong{array}.
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
   int first_dimensioned_value = 0;
 
   for (int i = 1; i < nargin; i += 2)
     {
-      if (args(i).is_cell ())
+      if (args(i).iscell ())
         {
           dim_vector argdims (args(i).dims ());
 
           if (! scalar (argdims))
             {
               if (! first_dimensioned_value)
                 {
                   dims = argdims;
@@ -1770,17 +1770,17 @@ produces a struct @strong{array}.
       maybe_warn_invalid_field_name (key, "struct");
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
 
-      if (args(i+1).is_cell ())
+      if (args(i+1).iscell ())
         {
           const Cell c (args(i+1).cell_value ());
 
           if (scalar (c.dims ()))
             map.setfield (key, Cell (dims, c(0)));
           else
             map.setfield (key, c);
         }
@@ -1875,17 +1875,17 @@ dimension is returned.
       // FIXME: should this work for all types that can do
       // structure reference operations?
       if (args(1).is_string ())
         {
           std::string key = args(1).string_value ();
 
           retval = m.isfield (key);
         }
-      else if (args(1).is_cell ())
+      else if (args(1).iscell ())
         {
           Cell c = args(1).cell_value ();
           boolNDArray bm (c.dims ());
           octave_idx_type n = bm.numel ();
 
           for (octave_idx_type i = 0; i < n; i++)
             {
               if (c(i).is_string ())
@@ -1961,17 +1961,17 @@ A(1)
 @seealso{struct2cell, cell2mat, struct}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  if (! args(0).is_cell ())
+  if (! args(0).iscell ())
     error ("cell2struct: argument CELL must be of type cell");
 
   if (! (args(1).iscellstr () || args(1).is_char_matrix ()))
     error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
 
   int dim = 0;
 
   if (nargin == 3)
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2978,17 +2978,17 @@ decode_subscripts (const char *name, con
         type_string[k] = '.';
       else
         error ("%s: invalid indexing type '%s'", name, item.c_str ());
 
       octave_value_list idx_item;
 
       if (subs(k).is_string ())
         idx_item(0) = subs(k);
-      else if (subs(k).is_cell ())
+      else if (subs(k).iscell ())
         {
           Cell subs_cell = subs(k).cell_value ();
 
           for (int n = 0; n < subs_cell.numel (); n++)
             {
               if (subs_cell(n).is_string ()
                   && subs_cell(n).string_value () == ":")
                 idx_item(n) = octave_value(octave_value::magic_colon_t);
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -523,18 +523,22 @@ public:
   { return rep->is_defined (); }
 
   bool is_undefined (void) const
   { return ! is_defined (); }
 
   bool is_empty (void) const
   { return rep->is_empty (); }
 
+  bool iscell (void) const
+  { return rep->iscell (); }
+
+  OCTAVE_DEPRECATED ("use 'iscell' instead")
   bool is_cell (void) const
-  { return rep->is_cell (); }
+  { return rep->iscell (); }
 
   bool iscellstr (void) const
   { return rep->iscellstr (); }
 
   OCTAVE_DEPRECATED ("use 'iscellstr' instead")
   bool is_cellstr (void) const
   { return iscellstr (); }
 
diff --git a/libinterp/octave-value/ovl.cc b/libinterp/octave-value/ovl.cc
--- a/libinterp/octave-value/ovl.cc
+++ b/libinterp/octave-value/ovl.cc
@@ -185,17 +185,17 @@ octave_value_list::all_scalars (void) co
 }
 
 bool
 octave_value_list::any_cell (void) const
 {
   octave_idx_type n = length ();
 
   for (octave_idx_type i = 0; i < n; i++)
-    if (elem (i).is_cell ())
+    if (elem (i).iscell ())
       return true;
 
   return false;
 }
 
 bool
 octave_value_list::has_magic_colon (void) const
 {
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -250,17 +250,17 @@ bp_table::dbstop_process_map_args (const
   Cell U = mv.contents ("errs");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
       if (W.is_empty () || W(0).is_empty ())
         Vdebug_on_error = 1;    // like "dbstop if error" with no identifier
-      else if (! W(0).is_cell ())
+      else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
               errors_that_stop.insert (V(i).string_value ());
               Vdebug_on_error = 1;
@@ -276,17 +276,17 @@ bp_table::dbstop_process_map_args (const
   U = mv.contents ("caught");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
       if (W.is_empty () || W(0).is_empty ())
         Vdebug_on_caught = 1;    // like "dbstop if caught error" with no ID
-      else if (! W(0).is_cell ())
+      else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
               caught_that_stop.insert (V(i).string_value ());
               Vdebug_on_caught = 1;
@@ -302,17 +302,17 @@ bp_table::dbstop_process_map_args (const
   U = mv.contents ("warn");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
       if (W.is_empty () || W(0).is_empty ())
         Vdebug_on_warning = 1;    // like "dbstop if warning" with no identifier
-      else if (! W(0).is_cell ())
+      else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
               warnings_that_stop.insert (V(i).string_value ());
               Vdebug_on_warning = 1;
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -906,17 +906,17 @@ assign_expr     : assign_lhs '=' express
                 | assign_lhs AND_EQ expression
                   { $$ = parser.make_assign_op (AND_EQ, $1, $2, $3); }
                 | assign_lhs OR_EQ expression
                   { $$ = parser.make_assign_op (OR_EQ, $1, $2, $3); }
                 ;
 
 expression      : simple_expr
                   {
-                    if ($1 && ($1->is_matrix () || $1->is_cell ()))
+                    if ($1 && ($1->is_matrix () || $1->iscell ()))
                       {
                         if (parser.validate_array_list ($1))
                           $$ = $1;
                         else
                           {
                             delete $1;
                             YYABORT;
                           }
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -51,17 +51,17 @@ namespace octave
     // No copying!
 
     tree_cell (const tree_cell&) = delete;
 
     tree_cell& operator = (const tree_cell&) = delete;
 
     ~tree_cell (void) = default;
 
-    bool is_cell (void) const { return true; }
+    bool iscell (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     tree_expression * dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const;
 
     void accept (tree_walker& tw)
     {
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -617,17 +617,17 @@ namespace octave
                                              const octave_value& val)
   {
     tree_expression *label = expr->case_label ();
 
     octave_value label_value = evaluate (label);
 
     if (label_value.is_defined ())
       {
-        if (label_value.is_cell ())
+        if (label_value.iscell ())
           {
             Cell cell (label_value.cell_value ());
 
             for (octave_idx_type i = 0; i < cell.rows (); i++)
               {
                 for (octave_idx_type j = 0; j < cell.columns (); j++)
                   {
                     bool match = val.is_equal (cell(i,j));
@@ -776,17 +776,17 @@ namespace octave
         ult.assign (octave_value::op_asn_eq, rhs);
 
         if (loop_body)
           loop_body->accept (*this);
 
         // Maybe decrement break and continue states.
         quit_loop_now ();
       }
-    else if (rhs.is_matrix_type () || rhs.is_cell () || rhs.is_string ()
+    else if (rhs.is_matrix_type () || rhs.iscell () || rhs.is_string ()
              || rhs.is_map ())
       {
         // A matrix or cell is reshaped to 2 dimensions and iterated by
         // columns.
 
         dim_vector dv = rhs.dims ().redim (2);
 
         octave_idx_type nrows = dv(0);
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -60,17 +60,17 @@ namespace octave
 
     virtual tree_expression * dup (symbol_table::scope_id,
                                    symbol_table::context_id context) const = 0;
 
     virtual bool is_constant (void) const { return false; }
 
     virtual bool is_matrix (void) const { return false; }
 
-    virtual bool is_cell (void) const { return false; }
+    virtual bool iscell (void) const { return false; }
 
     virtual bool is_identifier (void) const { return false; }
 
     virtual bool is_index_expression (void) const { return false; }
 
     virtual bool is_assignment_expression (void) const { return false; }
 
     virtual bool is_prefix_expression (void) const { return false; }
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -320,17 +320,17 @@ namespace octave
             break;
 
           case '.':
             {
               octave_value tidx = get_struct_index (tw, p_arg_nm, p_dyn_field);
 
               bool autoconv = (tmp.is_zero_by_zero ()
                                && (tmp.is_matrix_type () || tmp.is_string ()
-                                   || tmp.is_cell ()));
+                                   || tmp.iscell ()));
 
               if (i > 0 && type[i-1] == '(')
                 {
                   octave_value_list pidx = idx.back ();
 
                   // Use octave_map, not octave_scalar_map so that the
                   // dimensions are 0x0, not 1x1.
                   if (tmp.is_undefined ())
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -77,17 +77,17 @@ namespace octave
         if (first_elem)
           {
             if (val.is_map ())
               first_elem_is_struct = true;
 
             first_elem = false;
           }
       }
-    else if (val.is_cell ())
+    else if (val.iscell ())
       first_elem = false;
 
     append (val);
 
     if (all_str && ! val.is_string ())
       all_str = false;
 
     if (all_sq_str && ! val.is_sq_string ())
@@ -100,17 +100,17 @@ namespace octave
       some_str = true;
 
     if (all_real && ! val.is_real_type ())
       all_real = false;
 
     if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
       all_cmplx = false;
 
-    if (! any_cell && val.is_cell ())
+    if (! any_cell && val.iscell ())
       any_cell = true;
 
     if (! any_sparse && val.is_sparse_type ())
       any_sparse = true;
 
     if (! any_class && val.is_object ())
       any_class = true;
 
@@ -194,17 +194,17 @@ namespace octave
   tm_row_const::tm_row_const_rep::cellify (void)
   {
     bool elt_changed = false;
 
     for (auto& elt : *this)
       {
         octave_quit ();
 
-        if (! elt.is_cell ())
+        if (! elt.iscell ())
           {
             elt_changed = true;
 
             if (elt.is_empty ())
               elt = Cell ();
             else
               elt = Cell (elt);
           }
