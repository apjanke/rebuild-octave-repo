# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1233762983 18000
#      Wed Feb 04 10:56:23 2009 -0500
# Node ID e07e93c040809ee87ec3d8d7d80e8b885200294e
# Parent  4238f2600a17f51134754f554c0f71c35698c833
style fixes

diff --git a/examples/@polynomial/polynomial.m b/examples/@polynomial/polynomial.m
--- a/examples/@polynomial/polynomial.m
+++ b/examples/@polynomial/polynomial.m
@@ -14,15 +14,15 @@ function p = polynomial (a)
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
       p = a;
     elseif (isvector (a) && isreal (a))
       p.poly = a(:)';
       p = class (p, "polynomial");
     else
-      error ("polynomial: expecting real or complex vector")
+      error ("polynomial: expecting real or complex vector");
     endif
   else
     print_usage ();
   endif
   superiorto ("double");
 endfunction
diff --git a/examples/@polynomial/polynomial_superiorto.m b/examples/@polynomial/polynomial_superiorto.m
--- a/examples/@polynomial/polynomial_superiorto.m
+++ b/examples/@polynomial/polynomial_superiorto.m
@@ -4,15 +4,15 @@ function p = polynomial (a)
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
       p = a;
     elseif (isvector (a) && isreal (a))
       p.poly = a(:)';
       p = class (p, "polynomial");
     else
-      error ("polynomial: expecting real or complex vector")
+      error ("polynomial: expecting real or complex vector");
     endif
   else
     print_usage ();
   endif
   superiorto ("double");
 endfunction
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,31 @@
+2009-02-04  John W. Eaton  <jwe@octave.org>
+
+	* audio/wavwrite.m, deprecated/splu.m, general/bitcmp.m,
+	general/fliplr.m, general/flipud.m, general/genvarname.m,
+	general/nargchk.m, general/nargoutchk.m, general/quadgk.m,
+	general/rot90.m, geometry/griddata.m, geometry/rectint.m,
+	geometry/voronoi.m, geometry/voronoin.m,
+	help/__strip_html_tags__.m, image/brighten.m, image/imfinfo.m,
+	image/imread.m, linear-algebra/cond.m, linear-algebra/condest.m,
+	linear-algebra/dmult.m, linear-algebra/dot.m,
+	linear-algebra/expm.m, linear-algebra/housh.m,
+	linear-algebra/onenormest.m, linear-algebra/subspace.m,
+	miscellaneous/compare_versions.m, optimization/__all_opts__.m,
+	optimization/optimget.m, pkg/pkg.m, plot/__bar__.m,
+	plot/__plr2__.m, plot/ribbon.m, plot/slice.m, polynomial/pchip.m,
+	polynomial/roots.m, set/unique.m, signal/fractdiff.m,
+	signal/hurst.m, specfun/beta.m, specfun/legendre.m,
+	statistics/base/__quantile__.m, statistics/base/quantile.m,
+	statistics/tests/cor_test.m,
+	statistics/tests/kolmogorov_smirnov_test_2.m, strings/base2dec.m,
+	strings/dec2base.m, strings/strcat.m, strings/validatestring.m,
+	time/addtodate.m: Style fixes.
+
 2009-02-04  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/fsolve.m: remove redundant line.
 
 2009-02-03  Jaroslav Hajek  <highegg@gmail.com>
 	
 	* optimization/Makefile.in: Add missing source.
 
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -97,17 +97,17 @@ function wavwrite (y, varargin)
   ## open file for writing binary
 
   if (! ischar (filename))
     error ("wavwrite: expecting filename to be a character string");
   endif
     
   [fid, msg] = fopen (filename, "wb");
   if (fid < 0)
-    error ("wavwrite: %s", msg)
+    error ("wavwrite: %s", msg);
   endif
   
   ## write RIFF/WAVE header
   c = 0;
   c += fwrite (fid, "RIFF", "uchar");
 
   ## file size - 8
   c += fwrite (fid, ck_size + 36, "uint32", 0, BYTEORDER);
diff --git a/scripts/deprecated/splu.m b/scripts/deprecated/splu.m
--- a/scripts/deprecated/splu.m
+++ b/scripts/deprecated/splu.m
@@ -33,16 +33,16 @@ function varargout = splu (varargin)
     warned = true;
     warning ("Octave:deprecated-function",
 	     "splu is obsolete and will be removed from a future version of Octave; please use lu instead");
   endif
 
   for i = 2 : nargin
     arg = varargin {i};
     if (! isscalar (arg))
-      error ("splu: Can no longer treat input column permutations.");
+      error ("splu: Can no longer treat input column permutations");
     endif
   endfor
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = lu (varargin{:});
 
 endfunction
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -36,17 +36,17 @@
 
 function x = bitcmp (a, n)
   
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2 && (! isscalar (n) || (floor (n) != n)))
-    error("k must be a scalar integer")
+    error ("k must be a scalar integer");
   endif
 
   if (isa (a, "double"))
     bmax = bitmax;
     amax = ceil (log2 (bmax));
   else
     if (isa (a, "uint8"))
       amax = 8;
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -39,17 +39,17 @@
 
 function y = fliplr (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (ndims (x) > 2)
-    error ("fliplr: Only works with 2-D arrays")
+    error ("fliplr: Only works with 2-D arrays");
   endif
 
   nc = columns (x);
   y = x (:, nc:-1:1);
 
 endfunction
 
 %!assert((fliplr ([1, 2; 3, 4]) == [2, 1; 4, 3]
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -40,17 +40,17 @@
 
 function y = flipud (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (ndims (x) > 2)
-    error ("flipud: Only works with 2-d arrays")
+    error ("flipud: Only works with 2-d arrays");
   endif
 
   nr = rows (x);
   y = x (nr:-1:1, :);
 
 endfunction
 
 %!assert((flipud ([1, 2; 3, 4]) == [3, 4; 1, 2]
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -100,29 +100,29 @@
 function varname = genvarname (str, exclusions)
 
   strinput = ischar (str);
   ## Process the inputs
   if (nargin < 2)
     exclusions = {};
   elseif (ischar (exclusions))
     if (rows (exclusions) != 1)
-      error ("genvarname: if more than one exclusion is given, it must be a cellstr")
+      error ("genvarname: if more than one exclusion is given, it must be a cellstr");
     endif
     exclusions = {exclusions};
   elseif (! iscellstr (exclusions))
-    error ("genvarname: exclusions must be a string or a cellstr")
+    error ("genvarname: exclusions must be a string or a cellstr");
   endif
   if (ischar (str))
     if (rows (str) != 1)
-      error ("genvarname: if more than one str is given, it must be a cellstr")
+      error ("genvarname: if more than one str is given, it must be a cellstr");
     endif
     str = {str};
   elseif (! iscellstr (str))
-    error ("genvarname: str must be a string or a cellstr")
+    error ("genvarname: str must be a string or a cellstr");
   endif
 
   validchars = cstrcat ("A":"Z", "a":"z", "0":"9", "_");
 
   varname = cell (size (str));
   for i = 1:numel (str)
     ## Perform any modifications to the varname to make sure that it is
     ## a valid variable name.
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -56,17 +56,17 @@ function msg = nargchk (mina, maxa, narg
   if (strcmpi (outtype, "string"))
     msg = msg.message;
   else
     if (isempty (msg.message))
       msg = struct ([]);
     endif
     ## FIXME: remove the error below if error is modified to accept
     ## struct inputs
-    error ("nargchk: error does not yet support struct inputs")
+    error ("nargchk: error does not yet support struct inputs");
   endif
 
 endfunction
 
 ## Tests
 %!shared stmin, stmax
 %!  stmin = struct ("message", "not enough input arguments",
 %!                  "identifier", "Octave:nargchk:not-enough-inputs");
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -56,17 +56,17 @@ function msg = nargoutchk (mina, maxa, n
   if (strcmpi (outtype, "string"))
     msg = msg.message;
   else
     if (isempty (msg.message))
       msg = struct ([]);
     endif
     ## FIXME: remove the error below if error is modified to accept
     ## struct inputs
-    error ("nargoutchk: error does not yet support struct inputs")
+    error ("nargoutchk: error does not yet support struct inputs");
   endif
 
 endfunction
 
 ## Tests
 %!shared stmin, stmax
 %!  stmin = struct ("message", "not enough output arguments",
 %!                  "identifier", "Octave:nargoutchk:not-enough-outputs");
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -161,17 +161,17 @@ function [q, err] = quadgk (f, a, b, var
 	    else
 	      error ("quadgk: unknown property %s", str);
 	    endif
 	  else
 	    error ("quadgk: expecting property to be a string");
 	  endif
 	endwhile
 	if (idx != nargin - 2)
-	  error ("quadgk: expecting properties in pairs")
+	  error ("quadgk: expecting properties in pairs");
 	endif
       endif
     endif
 
     ## Convert function given as a string to a function handle
     if (ischar (f))
       f = @(x) feval (f, x);
     endif
@@ -280,17 +280,17 @@ function [q, err] = quadgk (f, a, b, var
       subs = [subs' ; subs(1:end-1)' + diff(subs') ./ 2, NaN](:)(1 : end - 1);
     endwhile
     subs = [subs(1:end-1), subs(2:end)];
 
     warn_state = warning ("query", "Octave:divide-by-zero");
 
     unwind_protect
       ## Singularity will cause divide by zero warnings
-      warning ("off", "Octave:divide-by-zero")
+      warning ("off", "Octave:divide-by-zero");
 
       ## Initial evaluation of the integrand on the sub-intervals
       [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       q0 = sum (q_subs);
       err0 = sum (q_errs);
     
       if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
 	myeps = eps ("single");
@@ -366,17 +366,17 @@ function [q, err] = quadgk (f, a, b, var
 	[q_subs, q_errs] = __quadgk_eval__ (f, subs);
       endwhile
 
       if (err > max (abstol, reltol * abs(q)))
 	warning ("quadgk: Error tolerance not met. Estimated error %g", err);
       endif
     unwind_protect_cleanup
       if (strcmp (warn_state.state, "on")) 
-	warning ("on", "Octave:divide-by-zero")
+	warning ("on", "Octave:divide-by-zero");
       endif
     end_unwind_protect
   endif
 endfunction
 
 function [q, err] = __quadgk_eval__ (f, subs)
   ## A (15,7) point pair of Guass-Konrod quadrature rules. The abscissa
   ## and weights are copied directly from dqk15w.f from quadpack
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -56,17 +56,17 @@
 function y = rot90 (x, k)
 
   if (nargin == 1 || nargin == 2)
     if (nargin < 2)
       k = 1;
     endif
 
     if (ndims (x) > 2)
-      error ("rot90: Only works with 2-D arrays")
+      error ("rot90: Only works with 2-D arrays");
     endif
 
     if (imag (k) != 0 || fix (k) != k)
       error ("rot90: k must be an integer");
     endif
 
     k = rem (k, 4);
 
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -63,17 +63,17 @@ function [rx, ry, rz] = griddata (x, y, 
 
   [nr, nc] = size (xi);
   
   ## Triangulate data.
   tri = delaunay (x, y);
   zi = nan (size (xi));
   
   if (strcmp (method, "cubic"))
-    error ("griddata: cubic interpolation not yet implemented")
+    error ("griddata: cubic interpolation not yet implemented");
 
   elseif (strcmp (method, "nearest"))
     ## Search index of nearest point.
     idx = dsearch (x, y, tri, xi, yi);
     valid = !isnan (idx);
     zi(valid) = z(idx(valid));
 
   elseif (strcmp (method, "linear"))
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -39,17 +39,17 @@ function area = rectint (a, b)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("rectint: expecting arguments to be 2-d arrays");
   elseif (columns (a) != 4)
     error ("rectint: a must have 4 columns");
   elseif (columns (b) != 4)
     error ("rectint: b must have 4 columns");
   elseif any ([a(:,3:4);b(:,3:4)](:) < 0)
-    error ("rectint: all widths and heights must be > 0")
+    error ("rectint: all widths and heights must be > 0");
   endif
 
   ## This runs faster if the number of rows of a is greater than the
   ## number of rows of b.  Swap them and transpose to make it run
   ## faster.
   swapinputs = false ();
   if (rows (a) > rows (b))
     tmp = a;
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -156,12 +156,12 @@ function [vvx, vvy] = voronoi (varargin)
 		       [-1, 1] * (lim (4) - lim (3))]);
     if (nargout == 1)
       vxx = h;
     endif
   elseif (nargout == 2)
     vvx = vx;
     vvy = vy;
   else
-    error ("voronoi: only two or zero output arguments supported")
+    error ("voronoi: only two or zero output arguments supported");
   endif
 
 endfunction
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -49,11 +49,11 @@ function [C, F] = voronoin (pts, opt)
       [C, F, infi] = __voronoi__ (pts);
     elseif ischar(opt)
       [C, F, infi] = __voronoi__ (pts, opt);
     else
       error ("voronoin: second argument must be a string");
     endif
 
   else
-    error ("voronoin: number of points must be greater than their dimension")
+    error ("voronoin: number of points must be greater than their dimension");
   endif
 endfunction
diff --git a/scripts/help/__strip_html_tags__.m b/scripts/help/__strip_html_tags__.m
--- a/scripts/help/__strip_html_tags__.m
+++ b/scripts/help/__strip_html_tags__.m
@@ -28,18 +28,17 @@ function [text, status] = __strip_html_t
   if (length (start) == length (stop))
     text = html_text;
     for n = length(start):-1:1
       text (start (n):stop (n)) = [];
     endfor
     text = strip_superfluous_endlines (text);
     status = 0;
   else
-    warning ("help: invalid HTML data");
-    warning ("Raw HTML source follows...");
+    warning ("help: invalid HTML data -- raw HTML source follows...");
     disp (html_text);
     text = "";
     status = 1;
   endif
 endfunction
 
 ## This function removes end-lines (\n) that makes printing look bad
 function text = strip_superfluous_endlines (text)
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -40,24 +40,24 @@ function Rmap = brighten (m, beta)
     beta = m;
     m = colormap;
     h = gcf ();
   elseif (nargin == 2)
     if (ishandle (m))
       h = m;
       m = get (h, "colormap");
     elseif (! is_matrix (m) || size (m, 2) != 3)
-      error ("First argument must be a matrix of size nx3 or a handle.");
+      error ("brighten: first argument must be an Nx3 matrix or a handle");
     endif
   else
     print_usage ();
   endif
 
   if (! isscalar (beta) || beta <= -1 || beta >= 1)
-    error ("brighten(...,beta) beta must be a scalar in the range (-1,1).");
+    error ("brighten: beta must be a scalar in the range (-1,1)");
   endif
 
   if (beta > 0)
     gamma = 1 - beta;
   else
     gamma = 1 / (1 + beta);
   endif
 
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -85,17 +85,17 @@
 
 function info = imfinfo (filename)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (!ischar (filename))
-    error ("imfinfo: filename must be a string")
+    error ("imfinfo: filename must be a string");
   endif
 
   filename = tilde_expand (filename);
 
   delete_file = false;
 
   unwind_protect
 
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -37,17 +37,17 @@
 
 function varargout = imread (filename, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (! ischar (filename))
-    error ("imread: filename must be a string")
+    error ("imread: filename must be a string");
   endif
 
   filename = tilde_expand (filename);
 
   fn = file_in_path (IMAGE_PATH, filename);
 
   if (isempty (fn))
     error ("imread: cannot find %s", filename);
@@ -66,17 +66,17 @@ function varargout = imread (filename, v
     try
       vars = load (fn);
       if (isstruct (vars))
 	img_field = isfield (vars, "img");
 	x_field = isfield (vars, "X");
 	map_field = isfield (vars, "map");
       endif
     catch
-      error ("imread: invalid image file: %s", magick_error)
+      error ("imread: invalid image file: %s", magick_error);
     end_try_catch
 
     if (map_field && (img_field || x_field))
       varargout{2} = vars.map;
       if (img_field)
 	varargout{1} = vars.img;
       else
 	varargout{1} = vars.X;
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = cond (a, p)
 
   if (nargin && nargin < 3)
     if (ndims (a) > 2)
-      error ("cond: only valid on 2-D objects")
+      error ("cond: only valid on 2-D objects");
     endif
 
     if (nargin <2)
       p = 2;
     endif
 
     if (! ischar (p) && p == 2)
       [nr, nc] = size (a);
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -114,52 +114,52 @@ function [est, v] = condest (varargin)
   have_A = false;
   have_t = false;
   have_solve = false;
 
   if (ismatrix (varargin{1}))
     A = varargin{1};
     n = issquare (A);
     if (! n)
-      error ("condest: matrix must be square.");
+      error ("condest: matrix must be square");
     endif
     have_A = true;
 
     if (nargin > 1)
       if (isscalar (varargin{2}))
 	t = varargin{2};
 	have_t = true;
       elseif (nargin > 2)
 	solve = varargin{2};
 	solve_t = varargin{3};
 	have_solve = true;
 	if (nargin > 3)
 	  t = varargin{4};
 	  have_t = true;
 	endif
       else
-	error ("condest: must supply both solve and solve_t.");
+	error ("condest: must supply both solve and solve_t");
       endif
     endif
   elseif (nargin > 4)
     apply = varargin{1};
     apply_t = varargin{2};
     solve = varargin{3};
     solve_t = varargin{4};
     have_solve = true;
     n = varargin{5};
     if (! isscalar (n))
-      error ("condest: dimension argument of implicit form must be scalar.");
+      error ("condest: dimension argument of implicit form must be scalar");
     endif
     if (nargin > 5)
       t = varargin{6};
       have_t = true;
     endif
   else
-    error ("condest: implicit form of condest requires at least 5 arguments.");
+    error ("condest: implicit form of condest requires at least 5 arguments");
   endif
 
   if (! have_t)
     t = min (n, default_t);
   endif
 
   if (! have_solve)
     if (issparse (A))
diff --git a/scripts/linear-algebra/dmult.m b/scripts/linear-algebra/dmult.m
--- a/scripts/linear-algebra/dmult.m
+++ b/scripts/linear-algebra/dmult.m
@@ -64,17 +64,17 @@ function m = dmult (a, b, ind)
     if (isvector (b) && ind > 0 && ind <= ndims (a)
 	&& length (b) == size (a, ind))
       b = b(:);
       sa = size (a); 
       sal = prod (sa(1:ind-1)); sat = prod (sa(ind+1:end));
       s = kron (ones (sat, 1), kron (b, ones (sal, 1)));
       m = reshape (s, sa) .* a;
     else
-      error ("dmult: dimensions mismatch or index out of range")
+      error ("dmult: dimensions mismatch or index out of range");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -36,19 +36,19 @@ function z = dot (x, y, dim)
   if (nargin < 3)
     if isvector (x)
       x = x(:);
     endif
     if isvector (y)
       y = y(:);
     endif
     if (! size_equal (x, y))
-      error ("dot: sizes of arguments must match")
+      error ("dot: sizes of arguments must match");
     endif
     z = sum(x .* y);
   else
     if (! size_equal (x, y))
-      error ("dot: sizes of arguments must match")
+      error ("dot: sizes of arguments must match");
     endif
     z = sum(x .* y, dim);
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -99,17 +99,17 @@
 ## @code{Dq(a)}
 ## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
 function r = expm (a)
 
   if (! ismatrix (a) || ! issquare (a))
-    error ("expm requires a square matrix")
+    error ("expm requires a square matrix");
   endif
 
   n = rows (a);
   ## Trace reduction.
   a(a == -Inf) = -realmax;
   trshift = trace (a) / length (a);
   if (trshift > 0)
     a -= trshift*eye (n);
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -58,19 +58,19 @@
 function [housv, beta, zer] = housh (x, j, z)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   ## Check for valid inputs.
   if (! isvector (x) && ! isscalar (x))
-    error ("housh: first input must be a vector")
+    error ("housh: first input must be a vector");
   elseif (! isscalar(j))
-    error ("housh: second argment must be an integer scalar")
+    error ("housh: second argment must be an integer scalar");
   else
     housv = x;
     m = max (abs (housv));
     if (m != 0.0)
       housv = housv / m;
       alpha = norm (housv);
       if (alpha > z)
         beta = 1.0 / (alpha * (alpha + abs (housv(j))));
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -97,17 +97,17 @@ function [est, v, w, iter] = onenormest 
   endif
 
   default_t = 5;
   itmax = 10;
 
   if (ismatrix (varargin{1}))
     n = size (varargin{1}, 1);
     if n != size (varargin{1}, 2),
-      error ("onenormest: matrix must be square.");
+      error ("onenormest: matrix must be square");
     endif
     apply = @(x) varargin{1} * x;
     apply_t = @(x) varargin{1}' * x;
     if (size (varargin) > 1)
       t = varargin{2};
     else
       t = min (n, default_t);
     endif
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -34,17 +34,17 @@
 
 function ang = subspace (a, b)
 
   if (nargin != 2)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("subspace: expecting A and B to be 2-dimensional arrays");
   elseif (rows (a) != rows (b))
-    error ("subspace: column dimensions of a and b must match")
+    error ("subspace: column dimensions of a and b must match");
   endif
 
   a = orth (a);
   b = orth (b);
   c = a'*b;
   scos = min (svd (c));
   if (scos^2 > 1/2)
     if (columns (a) >= columns (b))
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -73,17 +73,17 @@ function out = compare_versions (v1, v2,
   if (nargin != 3)
     print_usage ();
   endif
 
   ## Make sure that the version numbers are valid.
   if (! (ischar (v1) && ischar (v2)))
     error ("compare_versions: both version numbers must be strings");
   elseif (size (v1, 1) != 1 || size (v2, 1) != 1)
-    error ("compare_versions: version numbers must be a single row")
+    error ("compare_versions: version numbers must be a single row");
   endif
 
   ## check and make sure that the operator is valid
   if (! ischar (operator))
     error ("compare_versions: operator must be a character string");
   elseif (numel (operator) > 2)
     error("compare_versions: operator cannot be more than 2 characters long");
   endif
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -50,16 +50,16 @@ function names = __all_opts__ (varargin)
         # throw the error as a warning.
         warning (lasterr ());
       end_try_catch
     endfor
     names = unique (names);
     lnames = unique (tolower (names));
     if (length (lnames) < length (names))
       ## This is bad.
-      error ("__all_opts__: duplicate options with inconsistent case.");
+      error ("__all_opts__: duplicate options with inconsistent case");
     endif
     saved_names = names;
     recursive = false;
   endif
 
 endfunction
 
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -33,17 +33,17 @@ function retval = optimget (options, par
   endif
 
   opts = __all_opts__ ();
   idx = lookup (opts, parname, "i");
 
   if (idx > 0 && strcmpi (parname, opts{idx}))
     parname = opts{idx};
   else
-    warning ("unrecognized option: %s", parname)
+    warning ("unrecognized option: %s", parname);
   endif
   if (isfield (options, parname))
     retval = options.(parname);
   elseif (nargin > 2)
     retval = default;
   else
     retval = [];
   endif
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -872,17 +872,17 @@ function uninstall (pkgnames, handle_dep
 	endif
       endfor
       if (length (delete_idx) != length (pkgnames))
 	## FIXME: We should have a better error message.
 	warning ("some of the packages you want to uninstall are not installed");
       endif
     else
       ## FIXME: We should have a better error message.
-      warning ("some of the packages you want to uninstall are not installed.");
+      warning ("some of the packages you want to uninstall are not installed");
     endif
   endif
 
   ## Compute the packages that will remain installed.
   idx = complement (delete_idx, 1:num_packages);
   remaining_packages = {installed_pkgs_lst{idx}};
 
   ## Check dependencies.
diff --git a/scripts/plot/__bar__.m b/scripts/plot/__bar__.m
--- a/scripts/plot/__bar__.m
+++ b/scripts/plot/__bar__.m
@@ -99,17 +99,17 @@ function varargout = __bar__ (vertical, 
       endif
     endif
   endwhile
 
   xlen = size (x, 1);
   ylen = size (y, 1);
 
   if (xlen != ylen)
-    error ("%s: length of x and y must be equal", func)
+    error ("%s: length of x and y must be equal", func);
   endif
   if (any (x(2:end) < x(1:end-1)))
     error ("%s: x vector values must be in ascending order", func);
   endif
 
   ycols = size (y, 2);
   cutoff = min (diff (double(x))) / 2;
   if (group)
diff --git a/scripts/plot/__plr2__.m b/scripts/plot/__plr2__.m
--- a/scripts/plot/__plr2__.m
+++ b/scripts/plot/__plr2__.m
@@ -74,17 +74,17 @@ function retval = __plr2__ (h, theta, rh
       endif
       if (t_nr != r_nr)
         error ("__plr2__: vector and matrix sizes must match");
       endif
       x = diag (cos (theta)) * rho;
       y = diag (sin (theta)) * rho;
       retval = __plt__ ("polar", h, x, y, fmt);
     else
-      error ("__plr2__: invalid data for plotting")
+      error ("__plr2__: invalid data for plotting");
     endif
   elseif (ismatrix (theta))
     if (isvector (rho))
       [r_nr, r_nc] = size (rho);
       if (r_nr == 1)
         rho = rho';
         tmp = r_nr;
         r_nr = r_nc;
@@ -107,15 +107,15 @@ function retval = __plr2__ (h, theta, rh
     elseif (ismatrix (rho))
       if (! size_equal (rho, theta))
         error ("__plr2__: matrix dimensions must match");
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
     else
-      error ("__plr2__: invalid data for plotting")
+      error ("__plr2__: invalid data for plotting");
     endif
   else
-    error ("__plr2__: invalid data for plotting")
+    error ("__plr2__: invalid data for plotting");
   endif
 
 endfunction
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -45,23 +45,23 @@ function h = ribbon (x, y, width)
   elseif (nargin == 2)
     width = 0.75;
   elseif (nargin != 3)
     print_usage ();
   endif
 
   if (isvector (x) && isvector (y))
     if (length (x) != length (y))
-      error ("ribbon: in case of vectors, X and Y must have same length")
+      error ("ribbon: in case of vectors, X and Y must have same length");
     else
       [x, y] = meshgrid (x, y);
     endif
   else
     if (! size_equal(x, y))
-      error ("ribbon: in case of matrices, X and Y must have same size")
+      error ("ribbon: in case of matrices, X and Y must have same size");
     endif
   endif
 
   [nr, nc] = size (y);
   tmp = zeros (1, nc);
 
   for c = nc:-1:1
     zz = [y(:,c), y(:,c)];
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -97,17 +97,17 @@ function h = slice (varargin)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     if (all ([isvector(x), isvector(y), isvector(z)]))
       [x, y, z] = meshgrid (x, y, z);
     elseif (ndims (x) == 3 && size_equal (x, y, z))
       ## Do nothing.
     else
-      error ("slice: X, Y, Z size mismatch")
+      error ("slice: X, Y, Z size mismatch");
     endif
     sx = varargin{5};
     sy = varargin{6};
     sz = varargin{7};
   else
     print_usage ();
   endif
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -94,17 +94,17 @@ function ret = pchip (x, y, xi)
   endif
 
   h = diff (x);
   if (all (h < 0))
     x = flipud (x);
     h = diff (x);
     y = flipud (y);
   elseif (any (h <= 0))
-    error("pchip: x must be strictly monotonic")
+    error("pchip: x must be strictly monotonic");
   endif
 
   if (rows (y) != n)
     error("pchip: size of x and y must match");
   endif
 
   [ry, cy] = size (y);
   if (cy > 1)
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -79,17 +79,17 @@
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
   if (nargin != 1 || min (size (v)) > 1)
     print_usage ();
   elseif (any (isnan(v) | isinf(v)))
-    error ("roots: inputs must not contain Inf or NaN")
+    error ("roots: inputs must not contain Inf or NaN");
   endif
 
   n = numel (v);
   v = v(:);
 
   ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
   ## leading k zeros and n - k - l roots of the polynomial are zero.
 
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -49,19 +49,19 @@ function [y, i, j] = unique (x, varargin
 
     ## parse options
     if (iscellstr (varargin))
       varargin = unique (varargin);
       optfirst = strmatch ('first', varargin) > 0;
       optlast = strmatch ('last', varargin) > 0;
       optrows = strmatch ('rows', varargin) > 0 && size (x, 2) > 1;
       if (optfirst && optlast)
-        error ("unique: cannot specify both 'last' and 'first'.");
+        error ("unique: cannot specify both \"last\" and \"first\"");
       elseif (optfirst + optlast + optrows != nargin-1)
-        error ("unique: invalid option.");
+        error ("unique: invalid option");
       endif
     else
       error ("unique: options must be strings");
     endif
 
     if (optrows && iscell (x))
       warning ("unique: 'rows' is ignored for cell arrays");
       optrows = false;
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -30,21 +30,21 @@ function retval = fractdiff (x, d)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   N = 100;
 
   if (! isvector (x))
-    error ("fractdiff: x must be a vector")
+    error ("fractdiff: x must be a vector");
   endif
 
   if (! isscalar (d))
-    error ("fractdiff: d must be a scalar")
+    error ("fractdiff: d must be a scalar");
   endif
 
 
   if (d >= 1)
     for k = 1 : d
       x = x(2 : length (x)) - x(1 : length (x) - 1);
     endfor
   endif
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -29,17 +29,17 @@
 
 function H = hurst (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (isscalar (x))
-    error ("hurst: x must not be a scalar")
+    error ("hurst: x must not be a scalar");
   elseif (isvector (x))
     x = reshape (x, length (x), 1);
   endif
 
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -41,21 +41,21 @@
 
 function retval = beta (a, b)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (any (size (a) != size (b)) && numel (a) != 1 && numel (b) != 1)
-    error ("beta: inputs have inconsistent sizes.")
+    error ("beta: inputs have inconsistent sizes");
   endif
 
   if (! isreal (a) || ! isreal (b))
-    error ("beta: inputs must be real.")
+    error ("beta: inputs must be real");
   endif
 
   retval = real (exp (gammaln (a) + gammaln (b) - gammaln (a+b)));
 
 endfunction
 
 %!test
 %! a=[1, 1.5, 2, 3];
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -181,17 +181,17 @@ function retval = legendre (n, x, normal
 
   retval(n+1,:) = scale;
 
   if (strcmp (normalization, "sch"))
     retval(1,:) = retval(1,:) / sqrt (2);
   endif
 
   if (overflow && ! warned_overflow)
-    warning ("legendre: overflow - results may be unstable for high orders.");
+    warning ("legendre: overflow - results may be unstable for high orders");
     warned_overflow = true;
   endif
 
 endfunction
 
 %!test
 %! result = legendre (3, [-1.0 -0.9 -0.8]);
 %! expected = [
diff --git a/scripts/statistics/base/__quantile__.m b/scripts/statistics/base/__quantile__.m
--- a/scripts/statistics/base/__quantile__.m
+++ b/scripts/statistics/base/__quantile__.m
@@ -112,17 +112,17 @@ function inv = __quantile__ (x, p, metho
             ## Median unbiased .
 	    p = kron (p, m+1/3) + 1/3;
 
           case 9
             ## Approximately unbiased respecting order statistics.
 	    p = kron (p, m+0.25) + 0.375;
 
           otherwise
-            error ("quantile: Unknown method, '%d'",method)
+            error ("quantile: Unknown method, '%d'", method);
         endswitch
 
 	## Duplicate single values.
 	imm1 = mm == 1;
 	x(2,imm1) = x(1,imm1);
 
 	## Interval indices.
 	pi = max (min (floor (p), mm-1), 1);
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -96,17 +96,17 @@ function q = quantile (x, p, dim, method
     dim = 1;
   endif
 
   if (nargin < 4)
     method = 5;
   endif
 
   if (dim > ndims(x))
-    error ("quantile: invalid dimension.")
+    error ("quantile: invalid dimension");
   endif
 
   ## Set the permutation vector.
   perm = 1:ndims(x);
   perm(1) = dim;
   perm(dim) = 1;
 
   ## Permute dim to the 1st index.
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -63,17 +63,17 @@
 
 function t = cor_test (X, Y, ALTERNATIVE, METHOD)
 
   if ((nargin < 2) || (nargin > 4))
     print_usage ();
   endif
 
   if (!isvector (X) || !isvector (Y) || length (X) != length (Y))
-    error ("cor_test: X and Y must be vectors of the same length")
+    error ("cor_test: X and Y must be vectors of the same length");
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
   elseif (! ischar (ALTERNATIVE))
     error ("cor_test: ALTERNATIVE must be a string");
   endif
 
@@ -104,17 +104,17 @@ function t = cor_test (X, Y, ALTERNATIVE
   elseif (m == "s")
     rho = spearman (X, Y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
-    error ("cor_test: method `%s' not recognized", METHOD)
+    error ("cor_test: method `%s' not recognized", METHOD);
   endif
 
   if (strcmp (ALTERNATIVE, "!=") || strcmp (ALTERNATIVE, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (ALTERNATIVE, ">"))
     t.pval = 1 - cdf;
   elseif (strcmp (ALTERNATIVE, "<"))
     t.pval = cdf;
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -72,17 +72,17 @@ function [pval, ks, d] = kolmogorov_smir
   [s, i] = sort ([x; y]);
   count (find (i <= n_x)) = 1 / n_x;
   count (find (i > n_x)) = - 1 / n_y;
 
   z = cumsum (count);
   ds = diff (s);
   if (any (ds == 0))
     ## There are some ties, so keep only those changes.
-    warning ("cannot compute correct p-values with ties")
+    warning ("cannot compute correct p-values with ties");
     elems = [find(ds); n_x+n_y];
     z = z(elems);
   endif
   
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     d    = max (abs (z));
     ks   = sqrt (n) * d;
     pval = 1 - kolmogorov_smirnov_cdf (ks);
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -51,20 +51,20 @@ function out = base2dec (d, base)
     print_usage ();
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   if (ischar (base))
     symbols = base;
     base = length (symbols);
     if (any (diff (sort (toascii (symbols))) == 0))
-      error ("base2dec: symbols representing digits must be unique.");
+      error ("base2dec: symbols representing digits must be unique");
     endif
   elseif (! isscalar (base))
-    error ("base2dec: cannot convert from several bases at once.");
+    error ("base2dec: cannot convert from several bases at once");
   elseif (base < 2 || base > length (symbols))
     error ("base2dec: base must be between 2 and 36 or a string of symbols");
   else
     d = toupper (d);
   endif
 
   ## Right justify the values before anything else.
   d = strjust (d, "right");
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -50,17 +50,17 @@ function retval = dec2base (n, base, len
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (numel (n) != length (n))
     n = n(:);
   elseif (any (n < 0 | n != fix (n)))
-    error ("dec2base: can only convert non-negative integers")
+    error ("dec2base: can only convert non-negative integers");
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   if (ischar (base))
     symbols = base;
     base = length (symbols);
     if any (diff (sort (toascii (symbols))) == 0)
       error ("dec2base: symbols representing digits must be unique");
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -68,17 +68,17 @@ function st = strcat (varargin)
           varargin{nv} = cellstr (varargin{nv});
         elseif (isreal (varargin{nv}))
           varargin{nv} = cellstr (char (varargin{nv}));
         elseif (isempty (varargin{nv}))
           varargin{nv} = cellstr ('');
         elseif (iscell (varargin{nv}))
           allchar = false;
         else
-          error ("strcat: inputs must be strings or cells of strings.")
+          error ("strcat: inputs must be strings or cells of strings");
         endif
         dims{nv} = size (varargin{nv});
         numstrs(nv) = numel (varargin{nv});
       endfor
 
       ## Set all cells to a common size
       n = find (numstrs == max (numstrs), 1);
       maxstrs = numstrs (n);
@@ -91,17 +91,17 @@ function st = strcat (varargin)
 
       ## Concatenate the strings
       st = varargin{1};
       for ns = 1:maxstrs
         for nv = 2:nargin
           if (size_equal (st, varargin{nv}))
             st{ns} = [st{ns}, varargin{nv}{ns}];
           else
-            error ("strcat: arguments must be the same size, or be scalars.");
+            error ("strcat: arguments must be the same size, or be scalars");
           endif
         endfor
       endfor
 
       if (allchar)
         ## If all inputs were strings, return strings.
         st = char (st);
       endif
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -69,31 +69,31 @@ function str = validatestring (str, stra
         funname = varargin{i};
         funnameset = true;
       endif
     endif
   endfor
 
   ## Check the inputs
   if (! ischar (str))
-    error ("validatestring: str must be a character string")
+    error ("validatestring: str must be a character string");
   elseif (rows (str) != 1)
-    error ("validatestring: str must have only one row")
+    error ("validatestring: str must have only one row");
   elseif (! iscellstr (strarray))
-    error ("validatestring: strarray must be a cellstr")
+    error ("validatestring: strarray must be a cellstr");
   elseif (! ischar (funname))
-    error ("validatestring: funname must be a character string")
+    error ("validatestring: funname must be a character string");
   elseif (! isempty (funname) && (rows (funname) != 1))
-    error ("validatestring: funname must be exactly one row")
+    error ("validatestring: funname must be exactly one row");
   elseif (! ischar (varname))
-    error ("validatestring: varname must be a character string")
+    error ("validatestring: varname must be a character string");
   elseif (! isempty (varname) && (rows (varname) != 1))
-    error ("validatestring: varname must be exactly one row")
+    error ("validatestring: varname must be exactly one row");
   elseif (position < 0)
-    error ("validatestring: position must be >= 0")
+    error ("validatestring: position must be >= 0");
   endif
 
   ## make the part of the error that will use funname, varname, and
   ## position
   errstr = "";
   if (! isempty (funname))
     errstr = sprintf ("Function: %s ", funname);
   endif
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -29,17 +29,17 @@
 
 function d = addtodate (d, q, f)
 
   if (nargin != 3)
     print_usage ();
   elseif (! (ischar (f) && rows (f) == 1))
     ## FIXME: enhance the function so that it works with cellstrs of the
     ## same size as the output.
-    error ("addtodate: f must be a single row character string.")
+    error ("addtodate: f must be a single row character string");
   endif
 
   if (numel (d) == 1 && numel (q) > 1)
     ## expand d to the size of q if d only has one element to make
     ## addition later eaiser.
     d = d.*ones (size (q));
   endif
 
@@ -64,17 +64,17 @@ function d = addtodate (d, q, f)
       d = reshape (dnew, size (d));
     else
       d = reshape (dnew, size (q));
     endif
   elseif (any (strcmpi ({"day" "hour" "minute" "second"}, f)))
     mult = struct ("day", 1, "hour", 1/24, "minute", 1/1440, "second", 1/86400);
     d += q.*mult.(f);
   else
-    error ("addtodate: Invalid time unit: %s", f)
+    error ("addtodate: Invalid time unit: %s", f);
   endif
 
 endfunction
 
 ## tests
 %!shared d
 %!  d = datenum (2008, 1, 1);
 ## Identity
