# HG changeset patch
# User jwe
# Date 1028107989 0
#      Wed Jul 31 09:33:09 2002 +0000
# Node ID 27e461aed956468a21ac06e85e73f08593df4229
# Parent  a0e323e959cdab8f5eae6242dce116d2248997aa
[project @ 2002-07-31 09:33:03 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,127 @@
+2002-07-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* symtab.cc (symbol_table::clear (void)): Clear all records.
+	(symbol_table::clear (const std::string&)): Delete second arg.
+	Clear any symbol that matches, regardless of type.
+
+	* symtab.h (symbol_table::variable_name_list): New function.
+	(symbol_table::global_variable_name_list): Likewise.
+	(symbol_table::user_function_name_list): Likewise.
+
+	* symtab.h, symtab.cc (symbol_table::clear_variables): New function.
+	(symbol_table::clear_functions): Likewise.
+	(symbol_table::clear_globals): Likewise.
+	(symbol_table::clear_variable): New function.
+	(symbol_table::clear_function): Likewise.
+	(symbol_table::clear_global): Likewise.
+	(symbol_table::clear_variable_pattern): New function.
+	(symbol_table::clear_function_pattern): Likewise.
+	(symbol_table::clear_global_pattern): Likewise.
+
+	* variables.cc (name_matches_any_pattern): Rename from
+	var_matches_any_pattern.
+	(is_local_variable): New static inline function.
+	(maybe_warn_exclusive): Likewise.
+	(do_clear_all): Likewise.
+	(do_clear_functions): Likewise.
+	(do_clear_globals): Likewise.
+	(do_clear_variables): Likewise.
+	(do_clear_function): Likewise.
+	(do_clear_global): Likewise.
+	(do_clear_variable): Likewise.
+	(do_clear_symbol): Likewise.
+	(do_clear_function_pattern): Likewise.
+	(do_clear_global_pattern): Likewise.
+	(do_clear_variable_pattern): Likewise.
+	(do_clear_symbol_pattern): Likewise.
+	(do_clear_functions): Likewise.
+	(do_clear_functions): Likewise.
+	(do_clear_globals): Likewise.
+	(do_clear_variables): Likewise.
+	(do_clear_symbols): Likewise.
+	(do_matlab_compatible_clear): Likewise.
+	(CLEAR_OPTION_ERROR): New macro.
+	(Fclear): Rewrite for Matlab compatibility and to cope with new
+	symbol table semantics.
+
+2002-07-30  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* symtab.cc (symbol_table::clear): Simply clear everything.
+	(symbol_table::clear_functions, symbol_table::clear_globals,
+	symbol_table::clear_all): New functions.
+
+	* symtab.h (symbol_record::symbol_def::next_elem): Delete.
+	(symbol_record::symbol_def::symbol_def): Delete intializer.
+
+	* symtab.h, symtab.cc (symbol_record::push_def): Delete.
+	(symbol_record::remove_top_def): Delete.
+	(symbol_record::replace_all_defs): Delete.
+	(symbol_record::hides_fcn): Delete.
+	(symbol_record::hides_builtin): Delete.
+
+	* symtab.h (symbol_table::~symbol_table): Call clear before
+	deleting the table.
+
+	* variables.cc (initialize_symbol_tables): Create fbi_sym_tab too.
+	(Fexist): Look in fbi_sym_tab, not global_sym_tab.
+
+	* parse.y (function_symtab): Rename from global_symtab.
+	Set curr_sym_tab to fbi_sym_tab, not global_sym_tab.
+	Change all uses of global_symtab to be function_symtab instead.
+	(frob_function): Rename and look for function name in fbi_sym_tab,
+	not global_sym_tab.
+	(parse_fcn_file): Clear function name from fbi_sym_tab, not
+	global_sym_tab.
+
+	* load-save.cc (save_vars): Look for built-in vars in fbi_sym_tab.
+	* symtab.cc (symbol_record::link_to_builtin_variable): Likewise.
+	* variables.cc (is_builtin_variable): Likewise.
+	(bind_ans): Likewise.
+	(bind_builtin_constant): Likewise.
+	(bind_builtin_variable): Likewise.
+	(builtin_string_variable): Likewise.
+	(builtin_real_scalar_variable): Likewise.
+	(builtin_any_variable): Likewise.
+	(is_text_function_name): Likewise, for functions.
+	(force_link_to_function): Likewise.
+	(is_builtin_function_name): Likewise.
+	(is_mapper_function_name): Likewise.
+	(is_valid_function): Likewise.
+	(Fclear): Likewise.
+	(F__print_symtab_info__): Likewise.
+	* defun.cc (print_usage): Likewise.
+	(install_builtin_mapper): Likewise.
+	(install_builtin_function): Likewise.
+	(install_dld_function): Likewise.
+	(Falias): Likewise.
+	* dynamic-ld.cc (clear_function): Likewise.
+	* variables.cc (do_who): Likewise, for built-ins and functions.
+	(link_to_builtin_or_function): Likewise.
+	* help.cc (LIST_SYMBOLS): Likewise.
+	(make_name_list): Handle fbi_sym_tab too.
+
+	* variables.cc (fbi_sym_tab): New symbol table.
+	* variables.h (fbi_sym_tab): Provide decl.
+
+2002-07-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* symtab.h (symbol_record::alias): Delete unused arg force.
+	Change all callers.
+
+	* variables.cc (link_to_global_variable): Give local variable
+	global value.
+
+	* pt-id.cc (tree_identifier::link_to_global): Warn about global
+	variables that have been defined before being declared global.
+	for a global variable to be used before it is declared global.
+	* pt-decl.cc (tree_global_command::do_init): Handle possible error
+	from tree_identifier::link_to_global.
+
 2002-07-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* ov.cc (silent_functions, Vsilent_functions): Move here.
 	(octave_value::print_with_name): Don't print anything if we are
 	evaluating a function and Vsilent_functions is true.
 
 	* pt-stmt.cc: From here.
 	(symbols_of_pt_stmt): Delete.
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -38,17 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include "oct-obj.h"
 #include "pager.h"
 #include "symtab.h"
 #include "variables.h"
 
 void
 print_usage (const std::string& nm, bool just_usage)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (nm);
+  symbol_record *sym_rec = fbi_sym_tab->lookup (nm);
 
   if (sym_rec)
     {
       std::string h = sym_rec->help ();
 
       if (h.length () > 0)
 	{
 	  octave_stdout << "\n*** " << nm << ":\n\n";
@@ -78,33 +78,33 @@ check_version (const std::string& versio
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
 install_builtin_mapper (octave_mapper *mf)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (mf->name (), true);
+  symbol_record *sym_rec = fbi_sym_tab->lookup (mf->name (), true);
 
   unsigned int t
     = symbol_record::BUILTIN_FUNCTION | symbol_record::MAPPER_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (mf, t);
   sym_rec->document (mf->doc_string ());
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (name, true);
+  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::BUILTIN_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::TEXT_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_builtin (f, name, doc), t);
@@ -129,39 +129,39 @@ install_builtin_variable (const std::str
   bind_builtin_variable (name, value, protect, eternal, chg_fcn, doc);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (name, true);
+  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::DLD_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::TEXT_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_dld_function (f, shl, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
-  symbol_record *sr_name = global_sym_tab->lookup (name);
+  symbol_record *sr_name = fbi_sym_tab->lookup (name);
 
   if (! sr_name)
     panic ("can't alias to undefined name!");
 
-  symbol_record *sr_alias = global_sym_tab->lookup (alias, true);
+  symbol_record *sr_alias = fbi_sym_tab->lookup (alias, true);
 
   if (sr_alias)
     sr_alias->alias (sr_name);
   else
     panic ("can't find symbol record for builtin function `%s'",
 	   alias.c_str ());
 }
 
@@ -182,17 +182,17 @@ DEFUN (alias, args, ,
       string name = args(1).string_value ();
 
       if (! error_state)
 	{
 	  symbol_record *sr_name = lookup_by_name (name, false);
 
 	  if (sr_name && sr_name->is_function ())
 	    {
-	      symbol_record *sr_alias = global_sym_tab->lookup (alias, true);
+	      symbol_record *sr_alias = fbi_sym_tab->lookup (alias, true);
 
 	      if (sr_alias)
 		sr_alias->alias (sr_name);
 	      else
 		error ("alias: unable to insert `%s' in symbol table",
 		       alias.c_str ());
 	    }
 	  else
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -198,17 +198,17 @@ void clear_function (const std::string& 
   if (Vwarn_reload_forces_clear)
     warning ("  %s", fcn_name.c_str ());
 
   curr_sym_tab->clear (fcn_name);
 
   if (curr_sym_tab != top_level_sym_tab)
     top_level_sym_tab->clear (fcn_name);
 
-  global_sym_tab->clear (fcn_name);
+  fbi_sym_tab->clear (fcn_name);
 }
 
 bool
 octave_dynamic_loader::do_load (const std::string& fcn_name)
 {
   bool retval = false;
 
   octave_shlib oct_file;
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -342,41 +342,47 @@ keyword_help (void)
 // It's not likely that this does the right thing now.  XXX FIXME XXX
 
 string_vector
 make_name_list (void)
 {
   string_vector key = names (keyword_help ());
   int key_len = key.length ();
 
+  string_vector fbi = fbi_sym_tab->name_list ();
+  int fbi_len = fbi.length ();
+
   string_vector glb = global_sym_tab->name_list ();
   int glb_len = glb.length ();
 
   string_vector top = top_level_sym_tab->name_list ();
   int top_len = top.length ();
 
   string_vector lcl;
   if (top_level_sym_tab != curr_sym_tab)
     lcl = curr_sym_tab->name_list ();
   int lcl_len = lcl.length ();
 
   string_vector ffl = octave_fcn_file_name_cache::list_no_suffix ();
   int ffl_len = ffl.length ();
 
-  int total_len = key_len + glb_len + top_len + lcl_len + ffl_len;
+  int total_len = key_len + fbi_len + glb_len + top_len + lcl_len + ffl_len;
 
   string_vector list (total_len);
 
   // Put all the symbols in one big list.
 
   int j = 0;
   int i = 0;
   for (i = 0; i < key_len; i++)
     list[j++] = key[i];
 
+  for (i = 0; i < fbi_len; i++)
+    list[j++] = fbi[i];
+
   for (i = 0; i < glb_len; i++)
     list[j++] = glb[i];
 
   for (i = 0; i < top_len; i++)
     list[j++] = top[i];
 
   for (i = 0; i < lcl_len; i++)
     list[j++] = lcl[i];
@@ -433,17 +439,17 @@ display_symtab_names (std::ostream& os, 
 
 #ifdef LIST_SYMBOLS
 #undef LIST_SYMBOLS
 #endif
 #define LIST_SYMBOLS(type, msg) \
   do \
     { \
       string_vector names \
-	= global_sym_tab->name_list (string_vector (), true, type); \
+	= fbi_sym_tab->name_list (string_vector (), true, type); \
       display_symtab_names (octave_stdout, names, msg); \
     } \
   while (0)
 
 static void
 simple_help (void)
 {
   octave_stdout << "Help is available for the topics listed below.\n";
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -4691,17 +4691,17 @@ save_vars (std::ostream& os, const std::
       do_save (os, vars (i), fmt, save_as_floats, infnan_warned);
 
       if (error_state)
 	break;
     }
 
   if (! error_state && save_builtins)
     {
-      vars = global_sym_tab->glob
+      vars = fbi_sym_tab->glob
 	(pattern, symbol_record::BUILTIN_VARIABLE, SYMTAB_ALL_SCOPES);
 
       int count = vars.length ();
 
       saved += count;
 
       for (int i = 0; i < count; i++)
 	{
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1065,18 +1065,18 @@ save_symtab	: // empty
 		  {
 		    if (symtab_context)
 		      panic_impossible ();
 
 		    symtab_context = curr_sym_tab;
 		  }
 		;
 		   
-global_symtab	: // empty
-		  { curr_sym_tab = global_sym_tab; }
+function_symtab	: // empty
+		  { curr_sym_tab = fbi_sym_tab; }
 		;
 
 local_symtab	: // empty
 		  { curr_sym_tab = tmp_local_sym_tab; }
 		;
 
 in_return_list	: // empty
 		  { lexer_flags.looking_at_return_list = true; }
@@ -1182,24 +1182,24 @@ return_list1	: identifier
 		  { $$ = new tree_parameter_list ($1); }
 		| return_list1 ',' identifier
 		  {
 		    $1->append ($3);
 		    $$ = $1;
 		  }
 		;
 
-return_list_end	: global_symtab ']'
+return_list_end	: function_symtab ']'
 		;
 
 // ===================
 // Function definition
 // ===================
 
-function_beg	: save_symtab FCN stash_comment global_symtab
+function_beg	: save_symtab FCN stash_comment function_symtab
 		  { $$ = $3; }
 		;
 
 function	: function_beg function2
 		  {
 		    $2->stash_leading_comment ($1);
 		    recover_from_parsing_function ();
 		    $$ = 0;
@@ -1213,17 +1213,17 @@ function	: function_beg function2
 		| function_beg return_list function1
 		  {
 		    finish_function ($2, $3, $1);
 		    recover_from_parsing_function ();
 		    $$ = 0;
 		  }
 		;
 
-function1	: global_symtab '=' function2
+function1	: function_symtab '=' function2
 		  { $$ = $3; }
 		;
 
 function2	: identifier local_symtab parsed_fcn_name function3
 		  {
 		    if (! ($$ = frob_function ($1, $4)))
 		      ABORT_PARSE;
 		  }
@@ -2473,17 +2473,17 @@ frob_function (tree_identifier *id, octa
   if (reading_fcn_file)
     {
       if (curr_fcn_file_name != id_name)
 	{
 	  if (Vwarn_function_name_clash)
 	    warning ("function name `%s' does not agree with function\
  file name `%s'", id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
-	  global_sym_tab->rename (id_name, curr_fcn_file_name);
+	  fbi_sym_tab->rename (id_name, curr_fcn_file_name);
 
 	  if (error_state)
 	    return 0;
 
 	  id_name = id->name ();
 	}
 
       octave_time now;
@@ -2508,17 +2508,17 @@ frob_function (tree_identifier *id, octa
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   top_level_sym_tab->clear (id_name);
 
-  symbol_record *sr = global_sym_tab->lookup (id_name);
+  symbol_record *sr = fbi_sym_tab->lookup (id_name);
 
   if (sr)
     fcn->stash_symtab_ptr (sr);
   else
     panic_impossible ();
 
   id->define (fcn, symbol_record::USER_FUNCTION);
 
@@ -3219,17 +3219,17 @@ parse_fcn_file (const std::string& ff, b
 	  gobble_leading_white_space (ffile, false, true, false);
 
 	  int status = yyparse ();
 
 	  if (status != 0)
 	    {
 	      error ("parse error while reading function file %s",
 		     ff.c_str ());
-	      global_sym_tab->clear (curr_fcn_file_name);
+	      fbi_sym_tab->clear (curr_fcn_file_name);
 	    }
 	}
       else if (exec_script)
 	{
 	  // The value of `reading_fcn_file' will be restored to the
 	  // proper value when we unwind from this frame.
 	  reading_fcn_file = old_reading_fcn_file_state;
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -97,30 +97,34 @@ void
 tree_global_command::do_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->link_to_global ();
 
-      octave_lvalue ult = id->lvalue ();
+      if (! error_state)
+	{
+	  octave_lvalue ult = id->lvalue ();
 
-      if (ult.is_undefined ())
-	{
-	  tree_expression *expr = elt.expression ();
+	  if (ult.is_undefined ())
+	    {
+	      tree_expression *expr = elt.expression ();
 
-	  octave_value init_val;
+	      octave_value init_val;
 
-	  if (expr)
-	    init_val = expr->rvalue ();
-	  else if (Vinitialize_global_variables)
-	    init_val = builtin_any_variable ("default_global_variable_value");
+	      if (expr)
+		init_val = expr->rvalue ();
+	      else if (Vinitialize_global_variables)
+		init_val
+		  = builtin_any_variable ("default_global_variable_value");
 
-	  ult.assign (octave_value::op_asn_eq, init_val);
+	      ult.assign (octave_value::op_asn_eq, init_val);
+	    }
 	}
     }
 }
 
 void
 tree_global_command::eval (void)
 {
   if (init_list)
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -114,17 +114,25 @@ tree_identifier::do_lookup (bool& script
 
   return script_file_executed ? foo : sym->def ();
 }
 
 void
 tree_identifier::link_to_global (void)
 {
   if (sym)
-    link_to_global_variable (sym);
+    {
+      if (! sym->is_linked_to_global ())
+	{
+	  if (sym->is_defined () && sym->is_variable ())
+	    warning ("local variable value may have changed to match global");
+
+	  link_to_global_variable (sym);
+	}
+    }
 }
 
 void
 tree_identifier::mark_as_static (void)
 {
   if (sym)
     sym->mark_as_static ();
 }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -197,29 +197,16 @@ symbol_record::rename (const std::string
     nm = new_name;
 }
 
 void
 symbol_record::define (const octave_value& v, unsigned int sym_type)
 {
   if (! (is_variable () && read_only_error ("redefine")))
     {
-      if (is_function () || is_constant ())
-	{
-	  if (Vvariables_can_hide_functions)
-	    {
-	      push_def (new symbol_def ());
-
-	      if (Vvariables_can_hide_functions < 0)
-		warning ("variable `%s' hides function", nm.c_str ());
-	    }
-	  else
-	    error ("variable `%s' hides function", nm.c_str ());
-	}
-
       if (definition->type () == symbol_record::BUILTIN_VARIABLE)
 	sym_type = symbol_record::BUILTIN_VARIABLE;
 
       definition->define (v, sym_type);
     }
 }
 
 void
@@ -250,51 +237,50 @@ bool
 symbol_record::define (octave_function *f, unsigned int sym_type)
 {
   bool retval = false;
 
   if (! read_only_error ("redefine"))
     {
       octave_value tmp (f);
 
-      replace_all_defs (new symbol_def (tmp, sym_type));
+      delete definition;
+
+      definition = new symbol_def (tmp, sym_type);
 
       retval = true;
     }
 
   return retval;
 }
 
 void
 symbol_record::clear (void)
 {
-  if (linked_to_global)
+  if (! tagged_static)
     {
       if (--definition->count <= 0)
 	delete definition;
 
       definition = new symbol_def ();
+    }
 
-      linked_to_global = 0;
-    }
-  else if (! tagged_static)
-    {
-      remove_top_def ();
-
-      if (! definition)
-	definition = new symbol_def ();
-    }
+  if (linked_to_global)
+    linked_to_global = 0;
 }
 
 void
-symbol_record::alias (symbol_record *s, bool /* force */)
+symbol_record::alias (symbol_record *s)
 {
   chg_fcn = s->chg_fcn;
 
-  replace_all_defs (s->definition);
+  if (--definition->count <= 0)
+    delete definition;
+
+  definition = (s->definition);
 
   definition->count++;
 }
 
 void
 symbol_record::mark_as_formal_parameter (void)
 {
   if (is_linked_to_global ())
@@ -324,60 +310,28 @@ symbol_record::mark_as_static (void)
   if (is_linked_to_global ())
     error ("can't make global variable `%s' static", nm.c_str ());
   else if (is_formal_parameter ())
     error ("can't make formal parameter `%s' static", nm.c_str ());
   else
     tagged_static = 1;
 }
 
-bool
-symbol_record::hides_fcn (void) const
-{
-  bool retval = false;
-
-  if (is_variable () && is_defined ())
-    {
-      symbol_def *hidden_def = definition->next_elem;
-
-      if (hidden_def && hidden_def->is_user_function ())
-	retval = true;
-    }
-
-  return retval;
-}
-
-bool
-symbol_record::hides_builtin (void) const
-{
-  bool retval = false;
-
-  if (is_variable () && is_defined ())
-    {
-      symbol_def *hidden_def = definition->next_elem;
-
-      if (hidden_def && hidden_def->is_builtin_function ())
-	retval = true;
-    }
-
-  return retval;
-}
-
 octave_value&
 symbol_record::variable_value (void)
 {
   static octave_value foo;
 
   return is_variable () ? def () : foo;
 }
 
 inline void
 symbol_record::link_to_builtin_variable (void)
 {
-  symbol_record *tmp_sym = global_sym_tab->lookup (name ());
+  symbol_record *tmp_sym = fbi_sym_tab->lookup (name ());
 
   if (tmp_sym && tmp_sym->is_builtin_variable ())
     alias (tmp_sym);
 }
 
 
 octave_lvalue
 symbol_record::variable_reference (void)
@@ -432,30 +386,30 @@ void
 symbol_record::pop_context (void)
 {
   // It is possible for context to be empty if new symbols have been
   // inserted in the symbol table during recursive calls.  This can
   // happen as a result of calls to eval() and feval().
 
   if (! context.empty ())
     {
-      replace_all_defs (context.pop ());
+      if (--definition->count <= 0)
+	delete definition;
+
+      definition = context.pop ();
 
       linked_to_global = global_link_context.pop ();
     }
 }
 
 void
 symbol_record::print_symbol_info_line (std::ostream& os) const
 {
   os << (is_read_only () ? " r-" : " rw")
      << (is_eternal () ? "-" : "d")
-#if 0
-     << (hides_fcn () ? "f" : (hides_builtin () ? "F" : "-"))
-#endif
      << "  "
      << std::setiosflags (std::ios::left) << std::setw (24)
      << type_name () . c_str ();
 
   os << std::resetiosflags (std::ios::left);
 
   int nr = rows ();
   int nc = columns ();
@@ -497,52 +451,16 @@ symbol_record::read_only_error (const ch
 	::error ("can't %s read-only symbol `%s'", action, nm.c_str ());
 
       return true;
     }
   else
     return false;
 }
 
-void
-symbol_record::push_def (symbol_def *sd)
-{
-  if (! sd)
-    return;
-
-  assert (definition == 0 || definition->next_elem == 0);
-
-  sd->next_elem = definition;
-
-  definition = sd;
-}
-
-void
-symbol_record::remove_top_def (void)
-{
-  symbol_def *top = definition;
-
-  definition = definition->next_elem;
-
-  if (--top->count <= 0)
-    delete top;
-}
-
-void
-symbol_record::replace_all_defs (symbol_def *sd)
-{
-  while (definition)
-    remove_top_def ();
-
-  if (! sd)
-    sd = new symbol_def ();
-
-  push_def (sd);
-}
-
 // A symbol table.
 
 symbol_record *
 symbol_table::lookup (const std::string& nm, bool insert, bool warn)
 {
   unsigned int index = hash (nm);
 
   symbol_record *ptr = table[index].next ();
@@ -600,60 +518,265 @@ symbol_table::rename (const std::string&
       prev = ptr;
       ptr = ptr->next ();
     }
 
   error ("unable to rename `%s' to `%s'", old_name.c_str (),
 	 new_name.c_str ());
 }
 
+// XXX FIXME XXX -- it would be nice to eliminate a lot of the
+// following duplicate code.
+
 void
-symbol_table::clear (bool clear_user_functions)
+symbol_table::clear (void)
+{
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  ptr->clear ();
+
+	  ptr = ptr->next ();
+	}
+    }
+}
+
+void
+symbol_table::clear_variables (void)
+{
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  if (ptr->is_user_variable ())
+	    ptr->clear ();
+
+	  ptr = ptr->next ();
+	}
+    }
+}
+
+// Really only clear functions that can be reloaded.
+
+void
+symbol_table::clear_functions (void)
 {
   for (unsigned int i = 0; i < table_size; i++)
     {
       symbol_record *ptr = table[i].next ();
 
       while (ptr)
 	{
-	  if (ptr->is_user_variable ()
-	      || (clear_user_functions
-		  && (ptr->is_user_function () || ptr->is_dld_function ())))
-	    {
-	      ptr->clear ();
-	    }
+	  if (ptr->is_user_function () || ptr->is_dld_function ())
+	    ptr->clear ();
+
+	  ptr = ptr->next ();
+	}
+    }
+}
+
+void
+symbol_table::clear_globals (void)
+{
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  if (ptr->is_user_variable () && ptr->is_linked_to_global ())
+	    ptr->clear ();
 
 	  ptr = ptr->next ();
 	}
     }
 }
 
 bool
-symbol_table::clear (const std::string& nm, bool clear_user_functions)
+symbol_table::clear (const std::string& nm)
+{
+  unsigned int index = hash (nm);
+
+  symbol_record *ptr = table[index].next ();
+
+  while (ptr)
+    {
+      if (ptr->name () == nm)
+	{
+	  ptr->clear ();
+	  return true;
+	}
+      ptr = ptr->next ();
+    }
+
+  return false;
+}
+
+bool
+symbol_table::clear_variable (const std::string& nm)
+{
+  unsigned int index = hash (nm);
+
+  symbol_record *ptr = table[index].next ();
+
+  while (ptr)
+    {
+      if (ptr->name () == nm && ptr->is_user_variable ())
+	{
+	  ptr->clear ();
+	  return true;
+	}
+      ptr = ptr->next ();
+    }
+
+  return false;
+}
+
+bool
+symbol_table::clear_global (const std::string& nm)
 {
   unsigned int index = hash (nm);
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm
-	  && (ptr->is_user_variable ()
-	      || (clear_user_functions
-		  && (ptr->is_user_function () || ptr->is_dld_function ()))))
+	  && ptr->is_user_variable ()
+	  && ptr->is_linked_to_global ())
+	{
+	  ptr->clear ();
+	  return true;
+	}
+      ptr = ptr->next ();
+    }
+
+  return false;
+}
+
+// Really only clear functions that can be reloaded.
+
+bool
+symbol_table::clear_function (const std::string& nm)
+{
+  unsigned int index = hash (nm);
+
+  symbol_record *ptr = table[index].next ();
+
+  while (ptr)
+    {
+      if (ptr->name () == nm
+	  && (ptr->is_user_function () || ptr->is_dld_function ()))
 	{
 	  ptr->clear ();
 	  return true;
 	}
       ptr = ptr->next ();
     }
 
   return false;
 }
 
+bool
+symbol_table::clear_variable_pattern (const std::string& pat)
+{
+  bool retval = false;
+
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  if (ptr->is_user_variable ())
+	    {
+	      glob_match pattern (pat);
+
+	      if (pattern.match (ptr->name ()))
+		{
+		  ptr->clear ();
+
+		  retval = true;
+		}
+	    }
+
+	  ptr = ptr->next ();
+	}
+    }
+
+  return retval;
+}
+
+bool
+symbol_table::clear_global_pattern (const std::string& pat)
+{
+  bool retval = false;
+
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  if (ptr->is_user_variable () && ptr->is_linked_to_global ())
+	    {
+	      glob_match pattern (pat);
+
+	      if (pattern.match (ptr->name ()))
+		{
+		  ptr->clear ();
+
+		  retval = true;
+		}
+	    }
+
+	  ptr = ptr->next ();
+	}
+    }
+
+  return retval;
+}
+
+// Really only clear functions that can be reloaded.
+
+bool
+symbol_table::clear_function_pattern (const std::string& pat)
+{
+  bool retval = false;
+
+  for (unsigned int i = 0; i < table_size; i++)
+    {
+      symbol_record *ptr = table[i].next ();
+
+      while (ptr)
+	{
+	  if (ptr->is_user_function () || ptr->is_dld_function ())
+	    {
+	      glob_match pattern (pat);
+
+	      if (pattern.match (ptr->name ()))
+		{
+		  ptr->clear ();
+
+		  retval = true;
+		}
+	    }
+
+	  ptr = ptr->next ();
+	}
+    }
+
+  return retval;
+}
+
 int
 symbol_table::size (void) const
 {
   int count = 0;
 
   for (unsigned int i = 0; i < table_size; i++)
     {
       symbol_record *ptr = table[i].next ();
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -74,17 +74,17 @@ private:
 
   class symbol_def
   {
   public:
 
     symbol_def (const octave_value& val = octave_value (),
 		unsigned int sym_type = 0)
       : symbol_type (sym_type), eternal (0), read_only (0), help_string (),
-	definition (val), next_elem (0), count (1) { }
+	definition (val), count (1) { }
 
     ~symbol_def (void) { }
 
     bool is_constant (void) const
       { return (symbol_type & symbol_record::BUILTIN_CONSTANT); }
 
     bool is_variable (void) const
       {
@@ -192,21 +192,16 @@ private:
     unsigned int read_only : 1;
 
     // The doc string associated with this variable.
     std::string help_string;
 
     // The value of this definition.  See ov.h and related files.
     octave_value definition;
 
-    // Pointer to next definition in chain.  This is used so that
-    // variables can hide function definitions, and so that the function
-    // definitions can reappear if the variable is cleared.
-    symbol_def *next_elem;
-
     // Reference count.
     int count;
 
     void print_info (std::ostream& os,
 		     const std::string& prefix = std::string ()) const;
 
     // No copying!
 
@@ -298,30 +293,27 @@ public:
   bool define_builtin_const (const octave_value& v);
 
   bool define (octave_function *f, unsigned int sym_type);
 
   void document (const std::string& h) { definition->document (h); }
 
   void clear (void);
 
-  void alias (symbol_record *s, bool force = false);
+  void alias (symbol_record *s);
 
   void mark_as_formal_parameter (void);
   bool is_formal_parameter (void) const { return formal_param; }
 
   void mark_as_linked_to_global (void);
   bool is_linked_to_global (void) const { return linked_to_global; }
 
   void mark_as_static (void);
   bool is_static (void) const { return tagged_static; }
 
-  bool hides_fcn (void) const;
-  bool hides_builtin (void) const;
-
   int rows (void) const { return definition->rows (); }
   int columns (void) const { return definition->columns (); }
 
   std::string type_name (void) const { return definition->type_name (); }
 
   std::string type_as_string (void) const
     { return definition->type_as_string (); }
 
@@ -361,22 +353,16 @@ private:
 
   // This should maybe be one stack with a structure containing all the
   // items we need to save for recursive calls...
   SLStack <symbol_def *> context;
   SLStack <unsigned int> global_link_context;
 
   bool read_only_error (const char *action);
 
-  void push_def (symbol_def *sd);
-
-  void remove_top_def (void);
-
-  void replace_all_defs (symbol_def *sd);
-
   void link_to_builtin_variable (void);
 
   // No copying!
 
   symbol_record (const symbol_record& s);
 
   symbol_record& operator = (const symbol_record& s);
 };
@@ -402,46 +388,82 @@ private:
 
 class
 symbol_table
 {
 public:
 
   symbol_table (unsigned int tab_size = 128)
     : table_size (tab_size), table (new symbol_record [table_size])
-  {
-    assert ((tab_size % 2) == 0);
-  }
+    {
+      assert ((tab_size % 2) == 0);
+    }
 
   ~symbol_table (void)
-  {
-    delete [] table;
-  }
+    {
+      clear ();
+      delete [] table;
+    }
 
   symbol_record *lookup (const std::string& nm, bool insert = false,
 			 bool warn = false);
 
   void rename (const std::string& old_name, const std::string& new_name);
 
-  void clear (bool clear_user_functions = true);
-  bool clear (const std::string& nm, bool clear_user_functions = true);
+  void clear (void);
+
+  void clear_variables (void);
+  void clear_functions (void);
+  void clear_globals (void);
+
+  bool clear (const std::string& nm);
+
+  bool clear_variable (const std::string& nm);
+  bool clear_function (const std::string& nm);
+  bool clear_global (const std::string& nm);
+
+  bool clear_variable_pattern (const std::string& pat);
+  bool clear_function_pattern (const std::string& pat);
+  bool clear_global_pattern (const std::string& pat);
 
   int size (void) const;
 
   Array<symbol_record *>
   symbol_list (const string_vector& pats = string_vector (),
 	       unsigned int type = SYMTAB_ALL_TYPES,
 	       unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
 
   string_vector
   name_list (const string_vector& pats = string_vector (),
 	     bool sort = false, unsigned int type = SYMTAB_ALL_TYPES,
 	     unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
+  string_vector
+  user_function_name_list (void) const
+    {
+      return name_list
+	(string_vector (), false,
+	 symbol_record::USER_FUNCTION|symbol_record::DLD_FUNCTION,
+	 SYMTAB_ALL_SCOPES);
+    }
+
+  string_vector
+  global_variable_name_list (void) const
+    {
+      return name_list
+	(string_vector (), false, SYMTAB_VARIABLES, SYMTAB_GLOBAL_SCOPE);
+    }
+
+  string_vector
+  variable_name_list (void) const
+    {
+      return name_list
+	(string_vector (), false, SYMTAB_VARIABLES, SYMTAB_LOCAL_SCOPE);
+    }
 
   int maybe_list (const char *header, const string_vector& argv,
 		  std::ostream& os, bool show_verbose,
 		  unsigned type, unsigned scope);
   
   Array<symbol_record *> glob (const std::string& pat = std::string ("*"),
 			       unsigned int type = SYMTAB_ALL_TYPES,
 			       unsigned int scope = SYMTAB_ALL_SCOPES) const;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -62,68 +62,74 @@ static int Vignore_function_time_stamp;
 symbol_table *top_level_sym_tab = 0;
 
 // Symbol table for the current scope.
 symbol_table *curr_sym_tab = 0;
 
 // Symbol table for global symbols.
 symbol_table *global_sym_tab = 0;
 
+// Symbol table for functions and built-in symbols.
+symbol_table *fbi_sym_tab = 0;
+
 // Initialization.
 
 // Create the initial symbol tables and set the current scope at the
 // top level.
 
 void
 initialize_symbol_tables (void)
 {
+  if (! fbi_sym_tab)
+    fbi_sym_tab = new symbol_table (2048);
+
   if (! global_sym_tab)
     global_sym_tab = new symbol_table (2048);
 
   if (! top_level_sym_tab)
     top_level_sym_tab = new symbol_table (4096);
 
   curr_sym_tab = top_level_sym_tab;
 }
 
 // Attributes of variables and functions.
 
 // Is this variable a builtin?
 
 bool
 is_builtin_variable (const std::string& name)
 {
-  symbol_record *sr = global_sym_tab->lookup (name);
+  symbol_record *sr = fbi_sym_tab->lookup (name);
   return (sr && sr->is_builtin_variable ());
 }
 
 // Is this a text-style function?
 
 bool
 is_text_function_name (const std::string& s)
 {
-  symbol_record *sr = global_sym_tab->lookup (s);
+  symbol_record *sr = fbi_sym_tab->lookup (s);
   return (sr && sr->is_text_function ());
 }
 
 // Is this a built-in function?
 
 bool
 is_builtin_function_name (const std::string& s)
 {
-  symbol_record *sr = global_sym_tab->lookup (s);
+  symbol_record *sr = fbi_sym_tab->lookup (s);
   return (sr && sr->is_builtin_function ());
 }
 
 // Is this a mapper function?
 
 bool
 is_mapper_function_name (const std::string& s)
 {
-  symbol_record *sr = global_sym_tab->lookup (s);
+  symbol_record *sr = fbi_sym_tab->lookup (s);
   return (sr && sr->is_mapper_function ());
 }
 
 // Is this function globally in this scope?
 
 bool
 is_globally_visible (const std::string& name)
 {
@@ -137,17 +143,17 @@ octave_function *
 is_valid_function (const std::string& fcn_name, const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
   symbol_record *sr = 0;
 
   if (! fcn_name.empty ())
     {
-      sr = global_sym_tab->lookup (fcn_name, true);
+      sr = fbi_sym_tab->lookup (fcn_name, true);
 
       lookup (sr, false);
     }
 
   if (sr)
     {
       octave_value tmp = sr->def ();
       ans = tmp.function_value (true);
@@ -367,17 +373,17 @@ appending @samp{.m}) is a function file 
 6 is the name is a built-in constant.  Otherwise, return 0.\n\
 \n\
 This function also returns 2 if a regular file called @var{name}\n\
 exists in Octave's @code{LOADPATH}.  If you want information about\n\
 other types of files, you should use some combination of the functions\n\
 @code{file_in_path} and @code{stat} instead.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  octave_value retval = 0.0;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
@@ -396,39 +402,44 @@ other types of files, you should use som
   size_t pos = name.find ('.');
 
   if (pos != NPOS && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
 
+  // We shouldn't need to look in the global symbol table, since any
+  // name that is visible in the current scope will be in the local
+  // symbol table.
+
   symbol_record *sr = curr_sym_tab->lookup (symbol_name);
-  if (! (sr && (sr->is_defined ()
-		|| (curr_sym_tab != top_level_sym_tab))))
-    sr = global_sym_tab->lookup (symbol_name);
 
-  retval = 0.0;
+  if (! (sr && sr->is_defined ()))
+    sr = fbi_sym_tab->lookup (symbol_name);
 
-  if (sr && sr->is_variable () && sr->is_defined ())
+  if (sr && sr->is_defined ())
     {
-      if (struct_elts.empty () || sr->is_map_element (struct_elts))
-	retval = 1.0;
-    }
-  else if (sr && sr->is_builtin_function ())
-    {
-      retval = 5.0;
-    }
-  else if (sr && sr->is_builtin_constant ())
-    {
-      retval = 6.0;
-    }
-  else if (sr && sr->is_user_function ())
-    {
-      retval = 2.0;
+      if (sr->is_variable ())
+	{
+	  if (struct_elts.empty () || sr->is_map_element (struct_elts))
+	    retval = 1.0;
+	}
+      else if (sr->is_builtin_function ())
+	{
+	  retval = 5.0;
+	}
+      else if (sr->is_builtin_constant ())
+	{
+	  retval = 6.0;
+	}
+      else if (sr->is_user_function ())
+	{
+	  retval = 2.0;
+	}
     }
   else
     {
       std::string path = fcn_file_in_path (name);
 
       if (path.length () > 0)
 	{
 	  retval = 2.0;
@@ -584,17 +595,17 @@ set_global_value (const std::string& nm,
 // Variable values.
 
 // Look for the given name in the global symbol table.  If it refers
 // to a string, return a new copy.  If not, return 0;
 
 std::string
 builtin_string_variable (const std::string& name)
 {
-  symbol_record *sr = global_sym_tab->lookup (name);
+  symbol_record *sr = fbi_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   std::string retval;
 
   octave_value val = sr->def ();
@@ -608,17 +619,17 @@ builtin_string_variable (const std::stri
 // Look for the given name in the global symbol table.  If it refers
 // to a real scalar, place the value in d and return 1.  Otherwise,
 // return 0.
 
 int
 builtin_real_scalar_variable (const std::string& name, double& d)
 {
   int status = 0;
-  symbol_record *sr = global_sym_tab->lookup (name);
+  symbol_record *sr = fbi_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   octave_value val = sr->def ();
 
   if (! error_state && val.is_scalar_type ())
@@ -630,17 +641,17 @@ builtin_real_scalar_variable (const std:
   return status;
 }
 
 // Look for the given name in the global symbol table.
 
 octave_value
 builtin_any_variable (const std::string& name)
 {
-  symbol_record *sr = global_sym_tab->lookup (name);
+  symbol_record *sr = fbi_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   return sr->def ();
 }
 
@@ -658,43 +669,38 @@ link_to_global_variable (symbol_record *
       sr->mark_as_linked_to_global ();
 
       if (! error_state)
 	{
 	  std::string nm = sr->name ();
 
 	  symbol_record *gsr = global_sym_tab->lookup (nm, true);
 
-	  // There must be a better way to do this.   XXX FIXME XXX
-
-	  if (sr->is_variable ())
-	    gsr->define (sr->def ());
-
 	  // Make sure this symbol is a variable.
 
-	  if (! gsr->is_variable ())
+	  if (! gsr->is_user_variable ())
 	    gsr->define (octave_value ());
 
-	  sr->alias (gsr, 1);
+	  sr->alias (gsr);
 	}
     }
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable, constant, or function, or user
 // function of the same name, provided that the name has not been used
 // as a formal parameter.
 
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
-  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name ());
+  symbol_record *tmp_sym = fbi_sym_tab->lookup (sr->name ());
 
   if (tmp_sym
       && (tmp_sym->is_builtin_variable ()
 	  || tmp_sym->is_builtin_constant ()
 	  || tmp_sym->is_function ())
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
 }
@@ -705,22 +711,22 @@ link_to_builtin_or_function (symbol_reco
 // being defined.
 //
 // Return without doing anything if there isn't a function with the
 // given name defined in the global symbol table.
 
 void
 force_link_to_function (const std::string& id_name)
 {
-  symbol_record *gsr = global_sym_tab->lookup (id_name, true);
-  if (gsr->is_function ())
+  symbol_record *fsr = fbi_sym_tab->lookup (id_name, true);
+  if (fsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
       symbol_record *csr = curr_sym_tab->lookup (id_name, true);
-      csr->alias (gsr);
+      csr->alias (fsr);
     }
 }
 
 DEFUN (document, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} document (@var{symbol}, @var{text})\n\
 Set the documentation string for @var{symbol} to @var{text}.\n\
 @end deftypefn")
@@ -820,32 +826,32 @@ do_who (int argc, const string_vector& a
       show_functions = (curr_sym_tab == top_level_sym_tab);
       show_variables = 1;
     }
 
   int pad_after = 0;
 
   if (show_builtins)
     {
-      pad_after += global_sym_tab->maybe_list
+      pad_after += fbi_sym_tab->maybe_list
 	("*** built-in constants:", pats, octave_stdout,
 	 show_verbose, symbol_record::BUILTIN_CONSTANT, SYMTAB_ALL_SCOPES);
 
-      pad_after += global_sym_tab->maybe_list
+      pad_after += fbi_sym_tab->maybe_list
 	("*** built-in variables:", pats, octave_stdout,
 	 show_verbose, symbol_record::BUILTIN_VARIABLE, SYMTAB_ALL_SCOPES);
 
-      pad_after += global_sym_tab->maybe_list
+      pad_after += fbi_sym_tab->maybe_list
 	("*** built-in functions:", pats, octave_stdout,
 	 show_verbose, symbol_record::BUILTIN_FUNCTION, SYMTAB_ALL_SCOPES);
     }
 
   if (show_functions)
     {
-      pad_after += global_sym_tab->maybe_list
+      pad_after += fbi_sym_tab->maybe_list
 	("*** currently compiled functions:", pats,
 	 octave_stdout, show_verbose, symbol_record::USER_FUNCTION,
 	 SYMTAB_ALL_SCOPES);
     }
 
   if (show_variables)
     {
       pad_after += curr_sym_tab->maybe_list
@@ -943,17 +949,17 @@ See who.\n\
   return retval;
 }
 
 // Defining variables.
 
 void
 bind_ans (const octave_value& val, bool print)
 {
-  static symbol_record *sr = global_sym_tab->lookup ("ans", true);
+  static symbol_record *sr = fbi_sym_tab->lookup ("ans", true);
 
   if (val.is_defined ())
     {
       sr->define (val);
 
       if (print)
 	val.print_with_name (octave_stdout, "ans");
     }
@@ -964,17 +970,17 @@ bind_ans (const octave_value& val, bool 
 
 // How is this different than install_builtin_constant?  Are both
 // functions needed?
 
 void
 bind_builtin_constant (const std::string& name, const octave_value& val,
 		       bool protect, bool eternal, const std::string& help)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (name, true);
+  symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
   sym_rec->unprotect ();
 
   std::string tmp_help = help.empty () ? sym_rec->help () : help;
 
   sym_rec->define_builtin_const (val);
 
   sym_rec->document (tmp_help);
 
@@ -992,17 +998,17 @@ bind_builtin_constant (const std::string
 // functions needed?
 
 void
 bind_builtin_variable (const std::string& varname, const octave_value& val,
 		       bool protect, bool eternal,
 		       symbol_record::change_function chg_fcn,
 		       const std::string& help)
 {
-  symbol_record *sr = global_sym_tab->lookup (varname, true);
+  symbol_record *sr = fbi_sym_tab->lookup (varname, true);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
   assert (sr);
 
   sr->unprotect ();
 
@@ -1022,18 +1028,18 @@ bind_builtin_variable (const std::string
     sr->make_eternal ();
 
   sr->document (help);
 }
 
 // Deleting names from the symbol tables.
 
 static inline bool
-var_matches_any_pattern (const std::string& nm,
-			 const string_vector& argv, int argc, int idx)
+name_matches_any_pattern (const std::string& nm,
+			  const string_vector& argv, int argc, int idx)
 {
   bool retval = false;
 
   for (int k = idx; k < argc; k++)
     {
       std::string patstr = argv[k];
 
       if (! patstr.empty ())
@@ -1046,16 +1052,319 @@ var_matches_any_pattern (const std::stri
 	      break;
 	    }
 	}
     }
 
   return retval;
 }
 
+static inline bool
+is_local_variable (const std::string& nm)
+{
+  symbol_record *sr = curr_sym_tab->lookup (nm);
+
+  return (sr && sr->is_variable ());
+}
+
+static inline void
+maybe_warn_exclusive (bool exclusive)
+{
+  if (exclusive)
+    warning ("clear: ignoring --exclusive option");
+}
+
+static inline void
+do_clear_all (void)
+{
+  curr_sym_tab->clear ();
+  fbi_sym_tab->clear_functions ();
+  global_sym_tab->clear ();
+}
+
+static inline void
+do_clear_functions (void)
+{
+  curr_sym_tab->clear_functions ();
+  fbi_sym_tab->clear_functions ();
+}
+
+static inline void
+do_clear_globals (void)
+{
+  curr_sym_tab->clear_globals ();
+  global_sym_tab->clear ();
+}
+
+static inline void
+do_clear_variables (void)
+{
+  curr_sym_tab->clear ();
+}
+
+static inline bool
+do_clear_function (const std::string& nm)
+{
+  bool b1 = curr_sym_tab->clear_function (nm);
+
+  bool b2 = fbi_sym_tab->clear_function (nm);
+
+  return b1 || b2;
+}
+
+static inline bool
+do_clear_global (const std::string& nm)
+{
+  bool b1 = curr_sym_tab->clear_global (nm);
+
+  bool b2 = global_sym_tab->clear_variable (nm);
+
+  return b1 || b2;
+}
+
+static inline bool
+do_clear_variable (const std::string& nm)
+{
+  return curr_sym_tab->clear_variable (nm);
+}
+
+static inline bool
+do_clear_symbol (const std::string& nm)
+{
+  bool cleared = curr_sym_tab->clear_variable (nm);
+
+  if (! cleared)
+    cleared = do_clear_function (nm);
+
+  return cleared;
+}
+
+static inline bool
+do_clear_function_pattern (const std::string& pat)
+{
+  bool b1 = curr_sym_tab->clear_function_pattern (pat);
+
+  bool b2 = fbi_sym_tab->clear_function_pattern (pat);
+
+  return b1 || b2;
+}
+
+static inline bool
+do_clear_global_pattern (const std::string& pat)
+{
+  bool b1 = curr_sym_tab->clear_global_pattern (pat);
+
+  bool b2 = global_sym_tab->clear_variable_pattern (pat);
+
+  return b1 || b2;
+}
+
+static inline bool
+do_clear_variable_pattern (const std::string& pat)
+{
+  return curr_sym_tab->clear_variable_pattern (pat);
+}
+
+static inline bool
+do_clear_symbol_pattern (const std::string& pat)
+{
+  // XXX FIXME XXX -- if we have a variable v1 and a function v2 and
+  // someone says clear v*, we will clear the variable but not the
+  // function.  Is that really what should happen?  (I think it is
+  // what Matlab does.)
+
+  bool cleared = curr_sym_tab->clear_variable_pattern (pat);
+
+  if (! cleared)
+    cleared = do_clear_function_pattern (pat);
+
+  return cleared;
+}
+
+static inline void
+do_clear_functions (const string_vector& argv, int argc, int idx,
+		    bool exclusive = false)
+{
+  if (idx == argc)
+    do_clear_functions ();
+  else
+    {
+      if (exclusive)
+	{
+	  string_vector lfcns = curr_sym_tab->user_function_name_list ();
+
+	  int lcount = lfcns.length ();
+
+	  for (int i = 0; i < lcount; i++)
+	    {
+	      std::string nm = lfcns[i];
+
+	      if (! name_matches_any_pattern (nm, argv, argc, idx))
+		do_clear_function (nm);
+	    }
+
+	  string_vector fcns = fbi_sym_tab->user_function_name_list ();
+
+	  int fcount = fcns.length ();
+
+	  for (int i = 0; i < fcount; i++)
+	    {
+	      std::string nm = fcns[i];
+
+	      if (! name_matches_any_pattern (nm, argv, argc, idx))
+		do_clear_function (nm);
+	    }
+	}
+      else
+	{
+	  while (idx < argc)
+	    do_clear_function_pattern (argv[idx++]);
+	}
+    }
+}
+
+static inline void
+do_clear_globals (const string_vector& argv, int argc, int idx,
+		  bool exclusive = false)
+{
+  if (idx == argc)
+    do_clear_globals ();
+  else
+    {
+      if (exclusive)
+	{
+	  string_vector lvars = curr_sym_tab->global_variable_name_list ();
+
+	  int lcount = lvars.length ();
+
+	  for (int i = 0; i < lcount; i++)
+	    {
+	      std::string nm = lvars[i];
+
+	      if (! name_matches_any_pattern (nm, argv, argc, idx))
+		do_clear_global (nm);
+	    }
+
+	  string_vector gvars = global_sym_tab->global_variable_name_list ();
+
+	  int gcount = gvars.length ();
+
+	  for (int i = 0; i < gcount; i++)
+	    {
+	      std::string nm = gvars[i];
+
+	      if (! name_matches_any_pattern (nm, argv, argc, idx))
+		do_clear_global (nm);
+	    }
+	}
+      else
+	{
+	  while (idx < argc)
+	    do_clear_global_pattern (argv[idx++]);
+	}
+    }
+}
+
+static inline void
+do_clear_variables (const string_vector& argv, int argc, int idx,
+		    bool exclusive = false)
+{
+  if (idx == argc)
+    do_clear_variables ();
+  else
+    {
+      if (exclusive)
+	{
+	  string_vector lvars = curr_sym_tab->variable_name_list ();
+
+	  int lcount = lvars.length ();
+
+	  for (int i = 0; i < lcount; i++)
+	    {
+	      std::string nm = lvars[i];
+
+	      if (! name_matches_any_pattern (nm, argv, argc, idx))
+		do_clear_variable (nm);
+	    }
+	}
+      else
+	{
+	  while (idx < argc)
+	    do_clear_variable_pattern (argv[idx++]);
+	}
+    }
+}
+
+static inline void
+do_clear_symbols (const string_vector& argv, int argc, int idx,
+		  bool exclusive = false)
+{
+  if (idx == argc)
+    do_clear_variables ();
+  else
+    {
+      if (exclusive)
+	{
+	  // XXX FIXME XXX -- is this really what we want, or do we
+	  // somehow want to only clear the functions that are not
+	  // shadowed by local variables?  It seems that would be a
+	  // bit harder to do.
+
+	  do_clear_variables (argv, argc, idx, exclusive);
+	  do_clear_functions (argv, argc, idx, exclusive);
+	}
+      else
+	{
+	  while (idx < argc)
+	    do_clear_symbol_pattern (argv[idx++]);
+	}
+    }
+}
+
+static void
+do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
+{
+  // This is supposed to be mostly Matlab compatible.
+
+  for (; idx < argc; idx++)
+    {
+      if (argv[idx] == "all" && ! is_local_variable ("all"))
+	{
+	  do_clear_all ();
+	}
+      else if (argv[idx] == "functions" && ! is_local_variable ("functions"))
+	{
+	  do_clear_functions (argv, argc, ++idx);
+	}
+      else if (argv[idx] == "global" && ! is_local_variable ("global"))
+	{
+	  do_clear_globals (argv, argc, ++idx);
+	}
+      else if (argv[idx] == "variables" && ! is_local_variable ("variables"))
+	{
+	  do_clear_variables ();
+	}
+      else
+	{
+	  do_clear_symbol_pattern (argv[idx]);
+	}
+    }
+}
+
+#define CLEAR_OPTION_ERROR(cond) \
+  do \
+    { \
+      if (cond) \
+        { \
+          print_usage ("clear"); \
+          return retval; \
+        } \
+    } \
+  while (0)
+
 DEFUN_TEXT (clear, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} clear [-x] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.  The\n\
 pattern may contain the following special characters:\n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
@@ -1096,157 +1405,107 @@ This command may not be used within a fu
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("clear");
 
-  if (error_state)
-    return retval;
-
-  // Always clear the local table, but don't clear currently compiled
-  // functions unless we are at the top level.  (Allowing that to
-  // happen inside functions would result in pretty odd behavior...)
-
-  bool clear_user_functions = (curr_sym_tab == top_level_sym_tab);
-
-  if (argc == 1)
-    {
-      curr_sym_tab->clear ();
-      global_sym_tab->clear (clear_user_functions);
-    }
-  else
+  if (! error_state)
     {
-      int exclusive = 0;
-
-      int idx = 1;
-
-      if (argc > 1)
-	{
-	  if (argv[idx] == "-x")
-	    {
-	      idx++;
-	      exclusive = 1;
-	    }
-	}
-
-      string_vector lvars;
-      string_vector gvars;
-      string_vector fcns;
-
-      if (argc > 0)
+      if (argc == 1)
 	{
-	  string_vector tmp;
-
-	  lvars = curr_sym_tab->name_list
-	    (tmp, false, SYMTAB_VARIABLES, SYMTAB_LOCAL_SCOPE);
-
-	  gvars = curr_sym_tab->name_list
-	    (tmp, false, SYMTAB_VARIABLES, SYMTAB_GLOBAL_SCOPE);
-
-	  fcns = global_sym_tab->name_list
-	    (tmp, false,
-	     symbol_record::USER_FUNCTION|symbol_record::DLD_FUNCTION,
-	     SYMTAB_ALL_SCOPES);
-	}
-
-      // XXX FIXME XXX -- this needs to be optimized to avoid the
-      // pattern matching code if the string doesn't contain any
-      // globbing patterns.
-
-      if (exclusive)
-	{
-	  int lcount = lvars.length ();
-
-	  for (int i = 0; i < lcount; i++)
-	    {
-	      std::string nm = lvars[i];
-
-	      if (! var_matches_any_pattern (nm, argv, argc, idx))
-		curr_sym_tab->clear (nm);
-	    }
-
-	  int gcount = gvars.length ();
-
-	  for (int i = 0; i < gcount; i++)
-	    {
-	      std::string nm = gvars[i];
-
-	      if (! var_matches_any_pattern (nm, argv, argc, idx))
-		{
-		  int count = curr_sym_tab->clear (nm);
-
-		  if (count > 0)
-		    global_sym_tab->clear (nm, clear_user_functions);
-		}
-	    }
-
-	  int fcount = fcns.length ();
-
-	  for (int i = 0; i < fcount; i++)
-	    {
-	      std::string nm = fcns[i];
-
-	      if (! var_matches_any_pattern (nm, argv, argc, idx))
-		{
-		  curr_sym_tab->clear (nm);
-
-		  global_sym_tab->clear (nm, clear_user_functions);
-		}
-	    }
+	  do_clear_variables ();
 	}
       else
 	{
-	  for (int k = idx; k < argc; k++)
-	    {
-	      std::string patstr = argv[k];
+	  int idx = 0;
+
+	  bool clear_all = false;
+	  bool clear_functions = false;
+	  bool clear_globals = false;
+	  bool clear_variables = false;
+	  bool exclusive = false;
+	  bool have_dash_option = false;
 
-	      if (! patstr.empty ())
+	  while (++idx < argc)
+	    {
+	      if (argv[idx] == "--all" || argv[idx] == "-a")
 		{
-		  glob_match pattern (patstr);
+		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  int lcount = lvars.length ();
+		  have_dash_option = true;
+		  clear_all = true;
+		}
+	      else if (argv[idx] == "--exclusive" || argv[idx] == "-x")
+		{
+		  have_dash_option = true;
+		  exclusive = true;
+		}
+	      else if (argv[idx] == "--functions" || argv[idx] == "-f")
+		{
+		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		  for (int i = 0; i < lcount; i++)
-		    {
-		      std::string nm = lvars[i];
+		  have_dash_option = true;
+		  clear_functions = true;
+		}
+	      else if (argv[idx] == "--global" || argv[idx] == "-g")
+		{
+		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
+
+		  have_dash_option = true;
+		  clear_globals = true;
+		}
+	      else if (argv[idx] == "--variables" || argv[idx] == "-v")
+		{
+		  CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
-		      if (pattern.match (nm))
-			curr_sym_tab->clear (nm);
-		    }
+		  have_dash_option = true;
+		  clear_variables = true;
+		}
+	      else
+		break;
+	    }
 
-		  int gcount = gvars.length ();
-
-		  for (int i = 0; i < gcount; i++)
+	  if (idx < argc)
+	    {
+	      if (! have_dash_option)
+		{
+		  do_matlab_compatible_clear (argv, argc, idx);
+		}
+	      else
+		{
+		  if (clear_all)
 		    {
-		      std::string nm = gvars[i];
+		      maybe_warn_exclusive (exclusive);
 
-		      if (pattern.match (nm))
-			{
-			  int count = curr_sym_tab->clear (nm);
-
-			  if (count > 0)
-			    global_sym_tab->clear (nm, clear_user_functions);
-			}
-		    }
+		      if (++idx < argc)
+			warning
+			  ("clear: ignoring extra arguments after --all");
 
-		  int fcount = fcns.length ();
-
-		  for (int i = 0; i < fcount; i++)
+		      curr_sym_tab->clear ();
+		      fbi_sym_tab->clear_functions ();
+		      global_sym_tab->clear ();
+		    }
+		  else if (clear_functions)
+		    {
+		      do_clear_functions (argv, argc, idx, exclusive);
+		    }
+		  else if (clear_globals)
 		    {
-		      std::string nm = fcns[i];
-
-		      if (pattern.match (nm))
-			{
-			  curr_sym_tab->clear (nm);
-
-			  global_sym_tab->clear (nm, clear_user_functions);
-			}
+		      do_clear_globals (argv, argc, idx, exclusive);
+		    }
+		  else if (clear_variables)
+		    {
+		      do_clear_variables (argv, argc, idx, exclusive);
+		    }
+		  else
+		    {
+		      do_clear_symbols (argv, argc, idx, exclusive);
 		    }
 		}
 	    }
 	}
     }
 
   return retval;
 }
@@ -1260,27 +1519,29 @@ Print raw symbol table statistices.\n\
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
-      if (arg == "global")
+      if (arg == "fbi")
+	fbi_sym_tab->print_info (octave_stdout);
+      else if (arg == "global")
 	global_sym_tab->print_info (octave_stdout);
       else if (arg == "top-level")
 	top_level_sym_tab->print_info (octave_stdout);
       else
 	{
-	  symbol_record *gsr = global_sym_tab->lookup (arg, true);
+	  symbol_record *fsr = fbi_sym_tab->lookup (arg, true);
 
-	  if (gsr && gsr->is_user_function ())
+	  if (fsr && fsr->is_user_function ())
 	    {
-	      octave_value tmp = gsr->def ();
+	      octave_value tmp = fsr->def ();
 	      const octave_value& rep = tmp.get_rep ();
 	      
 	      const octave_user_function& fcn
 		= static_cast<const octave_user_function&> (rep);
 
 	      fcn.print_symtab_info (octave_stdout);
 	    }
 	  else
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -110,15 +110,18 @@ bind_builtin_variable (const std::string
 extern symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 extern symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
 extern symbol_table *global_sym_tab;
 
+// Symbol table for functions and built-in symbols.
+extern symbol_table *fbi_sym_tab;
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
