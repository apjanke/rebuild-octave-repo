# HG changeset patch
# User jwe
# Date 1144987300 0
#      Fri Apr 14 04:01:40 2006 +0000
# Node ID 8d7162924bd3ace3592994ba9398a736655e04de
# Parent  ce79d238f142ec5a505636139cc0fd4b95ff7586
[project @ 2006-04-14 04:01:37 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,13 @@
+2006-04-13  John W. Eaton  <jwe@octave.org>
+
+	* configure.in (CONST_CAST, DYNAMIC_CAST, REINTERPRET_CAST,
+	STATIC_CAST): Delete.
+
 2006-04-12  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: If using g++, also add -Wold-style-cast to CXXFLAGS.
 
 2006-03-28  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: Don't check for MPI libraries.
 
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.506 $)
+AC_REVISION($Revision: 1.507 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1643,24 +1643,16 @@ AH_BOTTOM([
 #define GCC_ATTR_NORETURN __attribute__ ((__noreturn__))
 #define GCC_ATTR_UNUSED __attribute__ ((__unused__))
 #else
 #define GCC_ATTR_DEPRECATED
 #define GCC_ATTR_NORETURN
 #define GCC_ATTR_UNUSED
 #endif
 
-#define CONST_CAST(T, E) (T) (E)
-
-#define DYNAMIC_CAST(T, E) (T) (E)
-
-#define REINTERPRET_CAST(T, E) (T) (E)
-
-#define STATIC_CAST(T, E) (T) (E)
-
 #define X_CAST(T, E) (T) (E)
 
 #if defined(HAVE_F2C) && !defined(F77_FUNC)
 #  define F77_FUNC(x,X) x ## _
 #  define F77_FUNC_(x,X) x ## __
 #endif
 
 #if !defined(HAVE_DEV_T)
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,14 @@
+2006-04-13  John W. Eaton  <jwe@octave.org>
+
+	* misc/quit.h BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_1,
+	END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE): Omit unnecessary casts.
+	* misc/f77-fcn.h (F77_XFCN, F77_CHAR_ARG_LEN): Likewise.
+
 2006-04-03  David Bateman  <dbateman@free.fr>
 
 	* ranlib/wrap.f (dgenexp, dgengam, dignpoi): New functions.
 
 2006-03-21  John W. Eaton  <jwe@octave.org>
 
 	* misc/f77-fcn.h (F77_XFCN): Save octave_interrupt_immediately and
 	restore it if an exception occurs that causes a longjmp.
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -50,34 +50,34 @@ extern "C" {
    after this macro is used. */
 
 #define F77_XFCN(f, F, args) \
   do \
     { \
       octave_jmp_buf saved_context; \
       f77_exception_encountered = 0; \
       sig_atomic_t saved_octave_interrupt_immediately = octave_interrupt_immediately; \
-      octave_save_current_context ((char *) saved_context); \
+      octave_save_current_context (saved_context); \
       if (octave_set_current_context) \
 	{ \
 	  octave_interrupt_immediately = saved_octave_interrupt_immediately; \
-          octave_restore_current_context ((char *) saved_context); \
+          octave_restore_current_context (saved_context); \
 	  if (f77_exception_encountered) \
 	    F77_XFCN_ERROR (f, F); \
           else if (octave_allocation_error) \
             octave_throw_bad_alloc (); \
           else \
             octave_throw_interrupt_exception (); \
 	} \
       else \
         { \
 	  octave_interrupt_immediately++; \
 	  F77_FUNC (f, F) args; \
 	  octave_interrupt_immediately--; \
-          octave_restore_current_context ((char *) saved_context); \
+          octave_restore_current_context (saved_context); \
         } \
     } \
   while (0)
 
 /* So we can check to see if an exception has occurred. */
 extern int f77_exception_encountered;
 
 #if !defined (F77_FCN)
@@ -164,17 +164,17 @@ octave_make_cray_const_ftn_ch_dsc (const
 
 /* Assume f2c-compatible calling convention.  */
 
 #define F77_CHAR_ARG(x) x
 #define F77_CONST_CHAR_ARG(x) F77_CHAR_ARG (x)
 #define F77_CHAR_ARG2(x, l) x
 #define F77_CONST_CHAR_ARG2(x, l) F77_CHAR_ARG2 (x, l)
 #define F77_CXX_STRING_ARG(x) F77_CONST_CHAR_ARG2 (x.c_str (), x.length ())
-#define F77_CHAR_ARG_LEN(l) , (long) l
+#define F77_CHAR_ARG_LEN(l) , l
 #define F77_CHAR_ARG_DECL char *
 #define F77_CONST_CHAR_ARG_DECL const char *
 #define F77_CHAR_ARG_LEN_DECL , long
 #define F77_RET_T int
 #define F77_RETURN(retval) return retval;
 
 #endif
 
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
--- a/libcruft/misc/quit.h
+++ b/libcruft/misc/quit.h
@@ -129,31 +129,31 @@ extern void octave_throw_bad_alloc (void
   octave_throw_interrupt_exception (); \
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_2
 
 #define BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_1 \
   do \
     { \
       octave_jmp_buf saved_context; \
  \
-      octave_save_current_context ((char *) saved_context); \
+      octave_save_current_context (saved_context); \
  \
       if (octave_set_current_context) \
 	{ \
-	  octave_restore_current_context ((char *) saved_context)
+	  octave_restore_current_context (saved_context)
 
 #define BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_2 \
 	} \
       else \
 	{ \
 	  octave_interrupt_immediately++
 
 #define END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE \
 	  octave_interrupt_immediately--; \
-          octave_restore_current_context ((char *) saved_context); \
+          octave_restore_current_context (saved_context); \
         } \
     } \
   while (0)
 
 #ifdef __cplusplus
 
 #define BEGIN_INTERRUPT_WITH_EXCEPTIONS \
   sig_atomic_t saved_octave_interrupt_immediately = octave_interrupt_immediately; \
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1042,24 +1042,24 @@ SparseComplexMatrix::determinant (octave
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-				    X_CAST (const double *, Ax), 
-				    NULL, 1, control);
+				     reinterpret_cast<const double *> (Ax), 
+				     NULL, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic) 
-	(nr, nc, Ap, Ai, X_CAST (const double *, Ax), NULL, 
+	(nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), NULL, 
 	 NULL, &Symbolic, control, info);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexMatrix::determinant symbolic factorization failed");
 
 	  UMFPACK_ZNAME (report_status) (control, status);
@@ -1067,19 +1067,20 @@ SparseComplexMatrix::determinant (octave
 
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
 	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
-	  status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				       X_CAST (const double *, Ax), NULL,
-				       Symbolic, &Numeric, control, info) ;
+	  status
+	    = UMFPACK_ZNAME (numeric) (Ap, Ai,
+				       reinterpret_cast<const double *> (Ax),
+				       NULL, Symbolic, &Numeric, control, info) ;
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  rcond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseComplexMatrix::determinant numeric factorization failed");
@@ -1092,17 +1093,17 @@ SparseComplexMatrix::determinant (octave
 	  else
 	    {
 	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
 	      Complex d[2];
 	      double d_exponent;
 
 	      status = UMFPACK_ZNAME (get_determinant) 
-		(X_CAST (double *, &d[0]), NULL, &d_exponent,
+		(reinterpret_cast<double *> (&d[0]), NULL, &d_exponent,
 		 Numeric, info);
 	      d[1] = d_exponent;
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexMatrix::determinant error calculating determinant");
 		  
@@ -5522,23 +5523,24 @@ SparseComplexMatrix::factorize (octave_i
 
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-			    X_CAST (const double *, Ax), NULL, 1, control);
+				 reinterpret_cast<const double *> (Ax),
+				 NULL, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-				     X_CAST (const double *, Ax), 
+				     reinterpret_cast<const double *> (Ax), 
 				     NULL, NULL, &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
@@ -5547,17 +5549,17 @@ SparseComplexMatrix::factorize (octave_i
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				   X_CAST (const double *, Ax), NULL, 
+				   reinterpret_cast<const double *> (Ax), NULL, 
 				   Symbolic, &Numeric, control, info) ;
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
 	rcond = Info (UMFPACK_RCOND);
       else
 	rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
@@ -5636,17 +5638,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -5801,32 +5803,34 @@ SparseComplexMatrix::fsolve (SparseType 
 #endif
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai, X_CAST (const double *, Ax), 
+					     Ai,
+					     reinterpret_cast<const double *> (Ax), 
 					     NULL,
-					     X_CAST (double *, &Xx[iidx]), 
+					     reinterpret_cast<double *> (&Xx[iidx]), 
 					     NULL,
 					     &Bx[iidx], Bz, Numeric, 
 					     control, info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai, X_CAST (const double *, Ax), 
+					     Ai,
+					     reinterpret_cast<const double *> (Ax), 
 					     NULL,
-					     X_CAST (double *, &Xx[iidx]), 
+					     reinterpret_cast<double *>, (&Xx[iidx]), 
 					     NULL,
-					     X_CAST (const double *, Bz),
+					     reinterpret_cast<const double *> (Bz),
 					     NULL, Numeric, 
 					     control, info);
 #endif
 
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
@@ -5891,17 +5895,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6087,30 +6091,34 @@ SparseComplexMatrix::fsolve (SparseType 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai, X_CAST (const double *, Ax),
+					     Ai,
+					     reinterpret_cast<const double *> (Ax),
 					     NULL,
-					     X_CAST (double *, Xx), NULL, 
+					     reinterpret_cast<double *> (Xx),
+					     NULL, 
 					     Bx, Bz, Numeric, control, 
 					     info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
-					     X_CAST (const double *, Ax),
+					     reinterpret_cast<const double *> (Ax),
 					     NULL,
-					     X_CAST (double *, Xx), NULL, 
-					     X_CAST (double *, Bz), NULL,
+					     reinterpret_cast<double *> (Xx),
+					     NULL,
+					     reinterpret_cast<double *> (Bz),
+					     NULL,
 					     Numeric, control, 
 					     info);
 #endif
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
@@ -6195,17 +6203,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6357,19 +6365,21 @@ SparseComplexMatrix::fsolve (SparseType 
 
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 	      
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 		  status = 
 		    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
-				      X_CAST (const double *, Ax), 
-				      NULL, X_CAST (double *, &Xx[iidx]), 
-				      NULL, X_CAST (const double *, &Bx[iidx]), 
+				      reinterpret_cast<const double *> (Ax), 
+				      NULL,
+				      reinterpret_cast<double *> (&Xx[iidx]), 
+				      NULL,
+				      reinterpret_cast<const double *> (&Bx[iidx]), 
 				      NULL, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
 		      UMFPACK_ZNAME (report_status) (control, status);
@@ -6432,17 +6442,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6619,19 +6629,22 @@ SparseComplexMatrix::fsolve (SparseType 
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b (i,j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-					     Ai, X_CAST (const double *, Ax), 
-					     NULL, X_CAST (double *, Xx), 
-					     NULL, X_CAST (double *, Bx), 
+					     Ai,
+					     reinterpret_cast<const double *> (Ax),
+					     NULL,
+					     reinterpret_cast<double *> (Xx),
+					     NULL,
+					     reinterpret_cast<double *> (Bx),
 					     NULL, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
 		      UMFPACK_ZNAME (report_status) (control, status);
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,43 @@
+2006-04-13  David Bateman  <dbateman@free.fr>
+
+        * Sparse.cc (assign (Sparse<LT>&, const Sparse<RT>&)):
+	Optimize assignment.
+
+2006-04-13  John W. Eaton  <jwe@octave.org>
+
+        * Sparse.cc (assign (Sparse<LT>&, const Sparse<RT>&)):
+	Eliminate unnecessary casts.
+	* SparsedbleLU.cc (SparseLU::SparseLU): Likewise.
+
+	* kpse.cc (fopen): Use reinterpret_cast instead of C-style cast.
+	(log_search, dir_links): Use static_cast instead of C-style cast.
+
+	* prog-args.cc (args::getopt): Use reinterpret_cast instead of X_CAST.
+	* oct-alloc.cc (allocator::grow): Likewise.
+	* CSparse.cc (SparseComplexMatrix::determinant,
+	SparseComplexMatrix::factorize, SparseComplexMatrix::fsolve):
+	Likewise.
+	* SparseCmplxLU.cc (SparseComplexLU::SparseComplexLU): Likewise.
+
+	* oct-sort.cc (roundupsize, octave_sort<T>::merge_getmem):
+	Use static_cast instead of C-style cast.
+	* CSparse.cc (SparseComplexMatrix::fsolve): Likewise.
+	* dSparse.cc (SparseMatrix::fsolve): Likewise.
+
+	* data-conv.cc (LS_DO_WRITE): Use static_cast for value conversion.
+	Use OCTAVE_LOCAL_BUFFER instead of new/delete.
+	(LS_DO_READ): Allocate local buffer to avoid pointer tricks.
+	(write_doubles, read_doubles, LS_DO_WRITE, LS_DO_READ):
+	Use reinterpret_cast instead of X_CAST.
+
+	* DiagArray2.h (DiagArray2::Proxy::operator&): No need to cast
+	return value here.
+
 2006-04-12  Rafael Laboissiere  <rafael@debian.org>
 
 	* ArrayN.h (ArrayN::ArrayN): Qualify fill with Array<T> base class.
 	* DiagArray2.h (DiagArray2::DiagArray2): Likewise.
 
 2006-04-03  David Bateman  <dbateman@free.fr>
 
 	* Sparse.cc (Sparse<T>::resize): Use xcidx rather than cdix, etc
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -89,17 +89,17 @@ private:
       }
 
   private:
 
     // XXX FIXME XXX -- this is declared private to keep the user from
     // taking the address of a Proxy.  Maybe it should be implemented
     // by means of a companion function in the DiagArray2 class.
 
-    T *operator& () const { assert (0); return (T *) 0; }
+    T *operator& () const { assert (0); return 0; }
 
     octave_idx_type i;
     octave_idx_type j;
 
     DiagArray2<T> *object;
 
   };
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -2487,43 +2487,42 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
 			    {
 			      octave_idx_type iii = 0;
 			      octave_idx_type ii = idx_i.elem (iii);
-			      for (octave_idx_type i = 0; i < new_nr; i++)
+			      octave_idx_type ppp = 0;
+			      octave_idx_type ppi = lhs.cidx(j+1) - 
+				lhs.cidx(j); 
+			      octave_idx_type pp = (ppp < ppi ? 
+						    lhs.ridx(lhs.cidx(j)+ppp) :
+						    new_nr);
+			      while (ppp < ppi || iii < n)
 				{
-				  OCTAVE_QUIT;
-
-				  if (iii < n && ii == i)
+				  if (iii < n && ii <= pp)
 				    {
 				      if (scalar != RT ())
 					{
 					  stmp.data(kk) = scalar;
-					  stmp.ridx(kk++) = i;
+					  stmp.ridx(kk++) = ii;
 					}
+				      if (ii == pp)
+					pp = (++ppp < ppi ? lhs.ridx(lhs.cidx(j)+ppp) : new_nr);					
 				      if (++iii < n)
 					ii = idx_i.elem(iii);
 				    }
-				  else if (j < lhs.cols()) 
+				  else
 				    {
-				      for (octave_idx_type k = lhs.cidx(j); 
-					   k < lhs.cidx(j+1); k++)
-					{
-					  if (lhs.ridx(k) == i)
-					    {
-					      stmp.data(kk) = lhs.data(k);
-					      stmp.ridx(kk++) = i;
-					    }
-					  if (lhs.ridx(k) >= i)
-					    break;
-					}
+				      stmp.data(kk) = 
+					lhs.data(lhs.cidx(j)+ppp);
+				      stmp.ridx(kk++) = pp;
+				      pp = (++ppp < ppi ? lhs.ridx(lhs.cidx(j)+ppp) : new_nr);
 				    }
 				}
 			      if (++jji < m)
 				jj = idx_j.elem(jji);
 			    }
 			  else if (j < lhs.cols()) 
 			    {
 			      for (octave_idx_type i = lhs.cidx(j); 
@@ -2625,88 +2624,59 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			    }
 
 			  idx_j = idx_vector (new_idx);
 			}
 		      else
 			for (octave_idx_type i = 0; i < m; i++)
 			  rhs_idx_j[i] = i;
 
-		      // Count the number of non-zero terms
-		      octave_idx_type new_nzmx = lhs.nnz ();
-		      for (octave_idx_type j = 0; j < m; j++)
-			{
-			  octave_idx_type jj = idx_j.elem (j);
-			  for (octave_idx_type i = 0; i < n; i++)
-			    {
-			      OCTAVE_QUIT;
-
-			      if (jj < lhs_nc)
-				{
-				  octave_idx_type ii = idx_i.elem (i);
-			      
-				  if (ii < lhs_nr)
-				    {
-				      for (octave_idx_type k = lhs.cidx(jj); 
-					   k < lhs.cidx(jj+1); k++)
-					{
-					  if (lhs.ridx(k) == ii)
-					    new_nzmx--;
-					  if (lhs.ridx(k) >= ii)
-					    break;
-					}
-				    }
-				}
-			      
-			      if (rhs.elem(rhs_idx_i[i],rhs_idx_j[j]) != RT ())
-				new_nzmx++;
-			    }
-			}
+		      // Maximum number of non-zero elements
+		      octave_idx_type new_nzmx = lhs.nnz() + rhs.nnz();
 
 		      Sparse<LT> stmp (new_nr, new_nc, new_nzmx);
 
 		      octave_idx_type jji = 0;
 		      octave_idx_type jj = idx_j.elem (jji);
 		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
 			    {
 			      octave_idx_type iii = 0;
 			      octave_idx_type ii = idx_i.elem (iii);
-			      for (octave_idx_type i = 0; i < new_nr; i++)
+			      octave_idx_type ppp = 0;
+			      octave_idx_type ppi = lhs.cidx(j+1) -
+				lhs.cidx(j);
+			      octave_idx_type pp = (ppp < ppi ? 
+						    lhs.ridx(lhs.cidx(j)+ppp) :
+						    new_nr);
+			      while (ppp < ppi || iii < n)
 				{
-				  OCTAVE_QUIT;
-
-				  if (iii < n && ii == i)
+				  if (iii < n && ii <= pp)
 				    {
 				      RT rtmp = rhs.elem (rhs_idx_i[iii], 
 							  rhs_idx_j[jji]);
 				      if (rtmp != RT ())
 					{
 					  stmp.data(kk) = rtmp;
-					  stmp.ridx(kk++) = i;
+					  stmp.ridx(kk++) = ii;
 					}
+				      if (ii == pp)
+					pp = (++ppp < ppi ? lhs.ridx(lhs.cidx(j)+ppp) : new_nr);					
 				      if (++iii < n)
 					ii = idx_i.elem(iii);
 				    }
-				  else if (j < lhs.cols()) 
+				  else
 				    {
-				      for (octave_idx_type k = lhs.cidx(j); 
-					   k < lhs.cidx(j+1); k++)
-					{
-					  if (lhs.ridx(k) == i)
-					    {
-					      stmp.data(kk) = lhs.data(k);
-					      stmp.ridx(kk++) = i;
-					    }
-					  if (lhs.ridx(k) >= i)
-					    break;
-					}
+				      stmp.data(kk) = 
+					lhs.data(lhs.cidx(j)+ppp);
+				      stmp.ridx(kk++) = pp;
+				      pp = (++ppp < ppi ? lhs.ridx(lhs.cidx(j)+ppp) : new_nr);
 				    }
 				}
 			      if (++jji < m)
 				jj = idx_j.elem(jji);
 			    }
 			  else if (j < lhs.cols()) 
 			    {
 			      for (octave_idx_type i = lhs.cidx(j); 
@@ -2714,16 +2684,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 				{
 				  stmp.data(kk) = lhs.data(i);
 				  stmp.ridx(kk++) = lhs.ridx(i);
 				}
 			    }
 			  stmp.cidx(j+1) = kk;
 			}
 
+		      stmp.maybe_compress();
 		      lhs = stmp;
 		    }
 		}
 	      else if (n == 0 && m == 0)
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
 			 || (rhs_nr == 0 || rhs_nc == 0)))
 		    {
@@ -2783,44 +2754,44 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			  octave_idx_type idx_nc = idx_i.orig_columns ();
 
 			  if (! (rhs_nr == idx_nr && rhs_nc == idx_nc))
 			    (*current_liboctave_warning_handler)
 			      ("A(I) = X: X does not have same shape as I");
 			}
 		    }
 
-		  if (! assign1 ((Sparse<LT>&) lhs, (Sparse<RT>&) rhs))
+		  if (! assign1 (lhs, rhs))
 		    retval = 0;
 		}
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nr == 1)
 	{
 	  idx_i.freeze (lhs_nc, "vector", true, liboctave_wrore_flag);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
-	      else if (! assign1 ((Sparse<LT>&) lhs, (Sparse<RT>&) rhs))
+	      else if (! assign1 (lhs, rhs))
 		retval = 0;
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else if (lhs_nc == 1)
 	{
 	  idx_i.freeze (lhs_nr, "vector", true, liboctave_wrore_flag);
 
 	  if (idx_i)
 	    {
 	      if (rhs_nr == 0 && rhs_nc == 0)
 		lhs.maybe_delete_elements (idx_i);
-	      else if (! assign1 ((Sparse<LT>&) lhs, (Sparse<RT>&) rhs))
+	      else if (! assign1 (lhs, rhs))
 		retval = 0;
 	    }
 	  // idx_vector::freeze() printed an error message for us.
 	}
       else
 	{
 	  if (liboctave_wfi_flag
 	      && ! (idx_i.is_colon ()
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -81,24 +81,26 @@ SparseComplexLU::SparseComplexLU (const 
 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
   const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-			    X_CAST (const double *, Ax), NULL, 1, control);
+				 reinterpret_cast<const double *> (Ax),
+				 NULL, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-				     X_CAST (const double *, Ax), NULL, NULL,
-				     &Symbolic, control, info);
+					  reinterpret_cast<const double *> (Ax),
+					  NULL, NULL,
+					  &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
@@ -106,18 +108,19 @@ SparseComplexLU::SparseComplexLU (const 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				   X_CAST (const double *, Ax), NULL, 
-				   Symbolic, &Numeric, control, info) ;
+					reinterpret_cast<const double *> (Ax),
+					NULL, Symbolic, &Numeric, control,
+					info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU numeric factorization failed");
@@ -172,42 +175,43 @@ SparseComplexLU::SparseComplexLU (const 
 	      P.resize (nr);
 	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      octave_idx_type *q = Q.fortran_vec ();
 
 	      octave_idx_type do_recip;
 	      status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
-					       X_CAST (double *, Ltx), NULL, Up, Uj,
-					       X_CAST (double *, Ux), NULL, p, 
-					       q, NULL, NULL, &do_recip,
-					       NULL, Numeric) ;
+						    reinterpret_cast<double *> (Ltx),
+						    NULL, Up, Uj,
+						    reinterpret_cast <double *> (Ux),
+						    NULL, p, q, NULL, NULL,
+						    &do_recip, NULL, Numeric);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0 || do_recip)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
 		  UMFPACK_ZNAME (report_status) (control, status);
 		}
 	      else
 		{
 		  Lfact = Lfact.transpose ();
 
 		  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
 					    Lfact.cidx (), Lfact.ridx (), 
-					    X_CAST (double *, Lfact.data()), 
+					    reinterpret_cast<double *> (Lfact.data()), 
 					    NULL, 1, control);
 
 		  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
 					    Ufact.cidx (), Ufact.ridx (), 
-					    X_CAST (double *, Ufact.data()), 
+					    reinterpret_cast<double *> (Ufact.data()), 
 					    NULL, 1, control);
 		  UMFPACK_ZNAME (report_perm) (nr, p, control);
 		  UMFPACK_ZNAME (report_perm) (nc, q, control);
 		}
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 	    }
 	}
@@ -273,34 +277,34 @@ SparseComplexLU::SparseComplexLU (const 
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-				X_CAST (const double *, Ax), NULL,
+				reinterpret_cast<const double *> (Ax), NULL,
 				1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
 	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
 	for (octave_idx_type i = 0; i < nc; i++)
 	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
 	status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-				       X_CAST (const double *, Ax),
+				       reinterpret_cast<const double *> (Ax),
 				       NULL, qinit, &Symbolic, control, 
 				       info);
       } while (0);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
@@ -311,17 +315,17 @@ SparseComplexLU::SparseComplexLU (const 
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
 	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
 	  status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
-				       X_CAST (const double *, Ax), NULL,
+				       reinterpret_cast<const double *> (Ax), NULL,
 				       Symbolic, &Numeric, control, info) ;
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  cond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
@@ -378,19 +382,19 @@ SparseComplexLU::SparseComplexLU (const 
 		  octave_idx_type *p = P.fortran_vec ();
 
 		  Q.resize (nc);
 		  octave_idx_type *q = Q.fortran_vec ();
 
 		  octave_idx_type do_recip;
 		  status = 
 		    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
-					    X_CAST (double *, Ltx),
+					    reinterpret_cast<double *> (Ltx),
 					    NULL, Up, Uj,
-					    X_CAST (double *, Ux), 
+					    reinterpret_cast<double *> (Ux), 
 					    NULL, p, q, NULL, NULL, 
 					    &do_recip, NULL, Numeric) ;
 
 		  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0 || do_recip)
 		    {
 		      (*current_liboctave_error_handler) 
@@ -401,23 +405,23 @@ SparseComplexLU::SparseComplexLU (const 
 		    }
 		  else
 		    {
 		      Lfact = Lfact.transpose ();
 
 		      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
 						Lfact.cidx (), 
 						Lfact.ridx (), 
-						X_CAST (double *, Lfact.data()), 
+						reinterpret_cast<double *> (Lfact.data()), 
 						NULL, 1, control);
 
 		      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
 						Ufact.cidx (), 
 						Ufact.ridx (), 
-						X_CAST (double *, Ufact.data()), 
+						reinterpret_cast<double *> (Ufact.data()), 
 						NULL, 1, control);
 		      UMFPACK_ZNAME (report_perm) (nr, p, control);
 		      UMFPACK_ZNAME (report_perm) (nc, q, control);
 		    }
 
 		  UMFPACK_ZNAME (report_info) (control, info);
 		}
 	    }
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -169,18 +169,18 @@ SparseLU::SparseLU (const SparseMatrix& 
 	      P.resize (nr);
 	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      octave_idx_type *q = Q.fortran_vec ();
 
 	      octave_idx_type do_recip;
 	      status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
-					       Up, Uj, Ux, p, q, (double *) NULL,
-					       &do_recip, (double *) NULL, 
+					       Up, Uj, Ux, p, q, NULL,
+					       &do_recip, NULL, 
 					       Numeric) ;
 
 	      UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0 || do_recip)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseLU::SparseLU extracting LU factors failed");
@@ -366,20 +366,18 @@ SparseLU::SparseLU (const SparseMatrix& 
 		  octave_idx_type *p = P.fortran_vec ();
 
 		  Q.resize (nc);
 		  octave_idx_type *q = Q.fortran_vec ();
 
 		  octave_idx_type do_recip;
 		  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
 						   Ltx, Up, Uj, Ux, p, q, 
-						   (double *) NULL,
-						   &do_recip, 
-						   (double *) NULL, 
-						   Numeric) ;
+						   NULL, &do_recip, 
+						   NULL, Numeric) ;
 
 		  UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0 || do_recip)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseLU::SparseLU extracting LU factors failed");
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -5857,17 +5857,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6088,17 +6088,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6367,17 +6367,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -6618,17 +6618,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  double spu = Voctave_sparse_controls.get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
 	      cm->print_function = NULL;
 	    }
 	  else
 	    {
-	      cm->print = (int)spu + 2;
+	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
 	  cm->complex_divide = CHOLMOD_NAME(divcomplex);
 	  cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -23,16 +23,17 @@ 02110-1301, USA.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 
 #include <iostream>
+#include <vector>
 
 #include "byte-swap.h"
 #include "data-conv.h"
 #include "lo-error.h"
 
 #if defined HAVE_LONG_LONG_INT
 #define FIND_SIZED_INT_TYPE(VAL, BITS, TQ, Q) \
   do \
@@ -464,43 +465,40 @@ oct_data_conv::data_type_as_string (oct_
   return retval;
 }
 
 #define LS_DO_READ(TYPE, swap, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
 	{ \
-	  volatile TYPE *ptr = X_CAST (volatile TYPE *, data); \
-	  stream.read (X_CAST (char *, ptr), size * len); \
+	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
+	  stream.read (reinterpret_cast<char *>  (ptr), size * len); \
 	  if (swap) \
 	    swap_bytes< size > (ptr, len); \
-	  TYPE tmp = ptr[0]; \
-	  for (int i = len - 1; i > 0; i--) \
+	  for (int i = 0; i < len; i++) \
 	    data[i] = ptr[i]; \
-	  data[0] = tmp; \
 	} \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define LS_DO_WRITE(TYPE, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
 	{ \
-	  char tmp_type = static_cast<char> (type); \
+	  char tmp_type = type; \
 	  stream.write (&tmp_type, 1); \
-	  TYPE *ptr = new TYPE [len]; \
+	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
 	  for (int i = 0; i < len; i++) \
-	    ptr[i] = X_CAST (TYPE, data[i]); \
-	  stream.write (X_CAST (char *, ptr), size * len); \
-	  delete [] ptr ; \
+	    ptr[i] = static_cast <TYPE> (data[i]);	   \
+	  stream.write (reinterpret_cast<char *> (ptr), size * len); \
 	} \
     } \
   while (0)
 
 // Loading variables from files.
 
 static void
 gripe_unrecognized_float_fmt (void)
@@ -1022,28 +1020,26 @@ read_doubles (std::istream& is, double *
       break;
 
     case LS_INT:
       LS_DO_READ (FOUR_BYTE_INT, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
-	volatile float *ptr = X_CAST (float *, data);
-	is.read (X_CAST (char *, data), 4 * len);
-	do_float_format_conversion (data, len, fmt);
-	float tmp = ptr[0];
-	for (int i = len - 1; i > 0; i--)
+	OCTAVE_LOCAL_BUFFER (float, ptr, len);
+	is.read (reinterpret_cast<char *> (ptr), 4 * len);
+	do_float_format_conversion (ptr, len, fmt);
+	for (int i = 0; i < len; i++)
 	  data[i] = ptr[i];
-	data[0] = tmp;
       }
       break;
 
     case LS_DOUBLE: // No conversion necessary.
-      is.read (X_CAST (char *, data), 8 * len);
+      is.read (reinterpret_cast<char *> (data), 8 * len);
       do_double_format_conversion (data, len, fmt);
       break;
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
@@ -1078,19 +1074,19 @@ write_doubles (std::ostream& os, const d
       break;
 
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
-	char tmp_type = X_CAST (char, type);
+	char tmp_type = static_cast<char> (type);
 	os.write (&tmp_type, 1);
-	os.write (X_CAST (char *, data), 8 * len);
+	os.write (reinterpret_cast <const char *> (data), 8 * len);
       }
       break;
 
     default:
       (*current_liboctave_error_handler)
 	("unrecognized data format requested");
       break;
     }
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -673,17 +673,18 @@ log_search (const string_vector& filenam
     {
       /* FILENAMES should never be null, but safety doesn't hurt.  */
       for (int e = 0; e < filenames.length () && ! filenames[e].empty (); e++)
 	{
 	  std::string filename = filenames[e];
 
 	  /* Only record absolute filenames, for privacy.  */
 	  if (log_file && kpse_absolute_p (filename.c_str (), false))
-	    fprintf (log_file, "%lu %s\n", (long unsigned) time (0),
+	    fprintf (log_file, "%lu %s\n",
+		     static_cast<unsigned long> (time (0)),
 		     filename.c_str ());
 
 	  /* And show them online, if debugging.  We've already started
 	     the debugging line in `search', where this is called, so
 	     just print the filename here, don't use DEBUGF.  */
 	  if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
 	    fputs (filename.c_str (), stderr);
 	}
@@ -2134,17 +2135,17 @@ dir_links (const std::string& fn)
 
   if (link_table.find (fn) != link_table.end ())
     ret = link_table[fn];
   else
     {
       struct stat stats;
 
       ret = stat (fn.c_str (), &stats) == 0 && S_ISDIR (stats.st_mode)
-            ? stats.st_nlink : (unsigned) -1;
+	? stats.st_nlink : static_cast<unsigned> (-1);
 
       link_table[fn] = ret;
 
 #ifdef KPSE_DEBUG
       if (KPSE_DEBUG_P (KPSE_DEBUG_STAT))
         DEBUGF2 ("dir_links (%s) => %ld\n", fn.c_str (), ret);
 #endif
     }
@@ -2413,17 +2414,18 @@ xclosedir (DIR *d)
 
 static FILE *
 fopen (const char *filename, const char *mode)
 {
 #undef fopen
   FILE *ret = fopen (filename, mode);
 
   if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
-    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode, (unsigned long) ret);
+    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode,
+	     reinterpret_cast<unsigned long> (ret));
 
   return ret;
 }
 
 #endif
 
 /* Implementation of a linked list of strings.  */
 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -74,23 +74,24 @@ octave_allocator::grow (void)
   if (start)
     {
       char *last = &start[(grow_size - 1) * item_size];
 
       char *p = start;
       while (p < last)
 	{
 	  char *next = p + item_size;
-	  (X_CAST (link *, p)) -> next = X_CAST (link *, next);
+	  (reinterpret_cast<link *> (p)) -> next
+	    = reinterpret_cast<link *> (next);
 	  p = next;
 	}
 
-      (X_CAST (link *, last)) -> next = 0;
+      (reinterpret_cast<link *> (last)) -> next = 0;
 
-      head = X_CAST (link *, start);
+      head = reinterpret_cast<link *> (start);
     }
   else
     {
       typedef void (*error_handler_function) (void);
 
       error_handler_function f = std::set_new_handler (0);
       std::set_new_handler (f);
 
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -432,17 +432,17 @@ octave_sort<T>::merge_freemem(void)
   ms.alloced = 0;
   ms.a = NULL;
 }
 
 static inline int
 roundupsize(int n)
 {
   unsigned int nbits = 3;
-  unsigned int n2 = (unsigned int)n >> 8;
+  unsigned int n2 = static_cast<unsigned int> (n) >> 8;
 
   /* Round up:
    * If n <       256, to a multiple of        8.
    * If n <      2048, to a multiple of       64.
    * If n <     16384, to a multiple of      512.
    * If n <    131072, to a multiple of     4096.
    * If n <   1048576, to a multiple of    32768.
    * If n <   8388608, to a multiple of   262144.
@@ -478,17 +478,17 @@ octave_sort<T>::merge_getmem(int need)
   if (need <= ms.alloced)
     return 0;
 
   need = roundupsize(need); 
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   merge_freemem( );
-  ms.a = (T *) malloc (need * sizeof (T));
+  ms.a = static_cast <T *> (malloc (need * sizeof (T)));
   if (ms.a) {
     ms.alloced = need;
     return 0;
   }
   merge_freemem( );	/* reset to sane state */
   return -1;
 }
 
diff --git a/liboctave/prog-args.cc b/liboctave/prog-args.cc
--- a/liboctave/prog-args.cc
+++ b/liboctave/prog-args.cc
@@ -28,18 +28,19 @@ 02110-1301, USA.
 #include "oct-getopt.h"
 
 #include "prog-args.h"
 
 int
 prog_args::getopt (void)
 {
   if (long_opts)
-    return ::octave_getopt_long (xargc, xargv, short_opts,
-				 X_CAST (const struct option *, long_opts), 0);
+    return ::octave_getopt_long
+      (xargc, xargv, short_opts,
+       reinterpret_cast<const struct option *> (long_opts), 0);
   else
     return ::octave_getopt (xargc, xargv, short_opts);
 }
 
 const char *
 prog_args::optarg (void)
 {
   return ::optarg;
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -102,17 +102,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   double spu = Voctave_sparse_controls.get_key ("spumoni");
   if (spu == 0.)
     {
       cm->print = -1;
       cm->print_function = 0;
     }
   else
     {
-      cm->print = (int)spu + 2;
+      cm->print = static_cast<int> (spu) + 2;
       cm->print_function =&SparseCholPrint;
     }
 
   cm->error_handler = &SparseCholError;
   cm->complex_divide = CHOLMOD_NAME(divcomplex);
   cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -66,18 +66,18 @@ string_vector::string_vector (const char
 {
   for (octave_idx_type i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 int
 string_vector::compare (const void *a_arg, const void *b_arg)
 {
-  const std::string *a = (const std::string *) a_arg;
-  const std::string *b = (const std::string *) b_arg;
+  const std::string *a = static_cast<const std::string *>  (a_arg);
+  const std::string *b = static_cast<const std::string *> (b_arg);
 
   return a->compare (*b);
 }
 
 string_vector&
 string_vector::uniq (void)
 {
   octave_idx_type len = length ();
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,166 @@
 2006-04-13  John W. Eaton  <jwe@octave.org>
 
+	* Makefile.in (lex.o parse.o pic/lex.o pic/parse.o): Omit
+	-Wold-style-cast from CXXFLAGS.
+
+	* ls-mat5.cc (READ_INTEGER_DATA): Allocate local buffer to avoid
+	pointer tricks.
+
+	* DLD-FUNCTIONS/regexp.cc (octregexp): Use OCTAVE_LOCAL_BUFFER
+	instead of allocting memory with malloc.
+
+	* DLD-FUNCTIONS/sparse.cc (Fsparse): Use octave_value extractors
+	instead of using get_rep.
+
+	* DLD-FUNCTIONS/dispatch.cc (dispatch_record): Use dynamic_cast,
+	not reinterpret_cast.
+
+	* DLD-FUNCTIONS/besselj.cc (Fairy): Use int_value instead of
+	double_value and cast to extract kind arg.
+	(int_arrayN_to_array): Arg is ArrayN<octave_idx_type>, not ArrayN<int>.
+
+	* OPERATORS/op-cm-scm.cc, OPERATORS/op-cm-sm.cc,
+	OPERATORS/op-cs-scm.cc, OPERATORS/op-cs-sm.cc,
+	OPERATORS/op-m-scm.cc, OPERATORS/op-m-sm.cc,
+	OPERATORS/op-s-scm.cc, OPERATORS/op-s-sm.cc,
+	OPERATORS/op-scm-cm.cc, OPERATORS/op-scm-cs.cc,
+	OPERATORS/op-scm-m.cc, OPERATORS/op-scm-s.cc,
+	OPERATORS/op-scm-scm.cc, OPERATORS/op-scm-sm.cc,
+	OPERATORS/op-sm-cm.cc, OPERATORS/op-sm-cs.cc,
+	OPERATORS/op-sm-m.cc, OPERATORS/op-sm-s.cc,
+	OPERATORS/op-sm-scm.cc, OPERATORS/op-sm-sm.cc: No need to cast
+	away const just to cache sparse type.
+	* ov-base-sparse.h (octave_base_sparse::typ): Now mutable.
+	(octave_base_sparse::sparse_type): Now const.
+
+	* OPERATORS/op-cm-scm.cc (DEFBINOP(div)): Explicitly cast args
+	here instead of using CAST_BINOP_ARGS.
+
+	* OPERATORS/op-streamoff.cc (STREAMOFF_COMP_OP): Second arg to 
+	CAST_BINOP_ARGS is also const.
+
+	* DLD-FUNCTIONS/chol.cc (Fcholinv, Fchol2inv): Eliminate nargout
+	arg to avoid unused variable warnings.
+
+	* unwind-prot.h, unwind-prot.cc (unwind_protect::save_bool,
+	unwind_protect::save_int, unwind_protect::save_str,
+	unwind_protect::save_ptr, unwind_protect::save_var):
+	Pointer args now const.
+	(unwind_protect_const_ptr): New macro.
+
+	* symtab.cc (maybe_list_cmp_fcn): Use static_cast instead of X_CAST.
+	* variables.cc (symbol_record_name_compare): Likewise.
+	* ls-mat5.cc (MAT5_DO_WRITE, save_mat5_binary_element): Likewise.
+
+	* ov-fcn-handle.cc (octave_fcn_handle::save_hdf5,
+	octave_fcn_handle::load_hdf5): Eliminate unnecessary casts.
+	* ov-fcn-inline.cc (octave_fcn_inline::save_hdf5,
+	octave_fcn_inline::load_hdf5): Likewise.
+	* ov-str-mat.cc (octave_char_matrix_str::save_hdf5,
+	octave_char_matrix_str::load_hdf5): Likewise.
+	* ov-bool-sparse.cc (octave_sparse_bool_matrix::save_hdf5,
+	octave_sparse_bool_matrix::load_hdf5): Likewise.
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::save_hdf5,
+	octave_sparse_complex_matrix::load_hdf5): Likewise.
+	* ov-re-sparse.cc (octave_sparse_matrix::save_hdf5,
+	octave_sparse_matrix::load_hdf5): Likewise.
+	* ov-str-mat.cc (octave_char_matrix_str::save_ascii,
+	octave_char_matrix_str::load_ascii): Likewise.
+	* mappers.cc (xtoascii): Likewise.
+	* load-save.cc (read_binary_file_header, write_header): Likewise.
+	* parse.y (get_help_from_file, parse_fcn_file): Likewise.
+	* DLD-FUNCTIONS/rand.cc (do_rand): Likewise.
+	* ls-hdf5.cc (read_hdf5_data, hdf5_add_attr, save_hdf5_empty,
+	load_hdf5_empty add_hdf5_data): Likewise.
+	* ls-mat4.cc (read_mat_binary_data): Likewise.
+	* ls-mat5.cc (read_mat5_binary_element): Likewise.
+
+	* oct-stream.cc (expand_char_class, octave_base_stream::do_gets):
+	Use static_cast instead of C-style cast.
+	* oct-procbuf.cc (kluge_procbuf_delay): Likewise.
+	* parse.y (gobble_leading_white_space,: Likewise.
+	* DLD-FUNCTIONS/besselj.cc (int_array2_to_matrix,
+	int_arrayN_to_array): Likewise.
+	* DLD-FUNCTIONS/colamd.cc (Fcolamd, Fsymamd): Likewise.
+	* DLD-FUNCTIONS/ccolamd.cc (Fcsymamd): Likewise.
+	* pt-pr-code.cc (tree_print_code::print_comment_elt): Likewise.
+	* DLD-FUNCTIONS/besselj.cc (do_bessel): Likewise.
+	* DLD-FUNCTIONS/spchol.cc (Fsymfact): Likewise.
+	* DLD-FUNCTIONS/sparse.cc (sparse_find): Likewise.
+	* DLD-FUNCTIONS/sort.cc (FloatFlip): Likewise.
+	* DLD-FUNCTIONS/matrix_type.cc (Fmatrix_type): Likewise.
+	* ls-mat5.cc (read_mat5_binary_element, OCTAVE_MAT5_INTEGER_READ,
+	read_mat5_binary_element, save_mat5_binary_element): Likewise.
+
+	* DLD-FUNCTIONS/splu.cc (Fspinv): Use dynamic_cast instead of
+	C-style cast.
+	* DLD-FUNCTIONS/matrix_type.cc (Fmatrix_type): Likewise.
+
+	* DLD-FUNCTIONS/sort.cc (mx_sort): Use reinterpret_cast instead of
+	C-style cast.
+	* ls-mat5.cc (write_mat5_tag): Likewise.
+
+	* ov-typeinfo.h (octave_value_typeinfo::octave_value_typeinfo):
+	Eliminate unnecessary casts in constructor initializers.
+
+	* ops.h (CAST_CONV_ARG, CAST_UNOP_ARG, CAST_BINOP_ARGS,
+	DEFASSIGNANYOP_FN): Use C++ dynamic_cast instead of DYNAMIC_CAST macro.
+
+	* unwind-prot.h (unwind_protect_ptr): Use combination of
+	reinterpret_cast and const_cast instead of X_CAST.
+
+	* dynamic-ld.cc (loader::do_load): Use reinterpret_cast instead of
+	X_CAST.
+	* ov-base-int.cc (octave_base_int_matrix<T>::save_binary,
+	octave_base_int_matrix<T>::load_binary,
+	octave_base_int_scalar<T>::save_binary,
+	octave_base_int_scalar<T>::load_binary): Likewise.
+	* ov-bool-mat.cc (octave_bool_matrix::save_binary,
+	octave_bool_matrix::load_binary): Likewise.
+	* ov-bool-sparse.cc (octave_sparse_bool_matrix::save_binary,
+	octave_sparse_bool_matrix::load_binary): Likewise.
+	* ov-bool.cc (octave_bool::save_binary, octave_bool::load_binary):
+	Likewise.
+	* ov-cell.cc (octave_cell::save_binary, octave_cell::load_binary):
+	Likewise.
+	* ov-complex.cc (octave_complex::save_binary,
+	octave_complex::load_binary): Likewise.
+	* ov-cx-mat.cc (octave_matrix::save_binary,
+	octave_matrix::load_binary): Likewise.
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::save_binary,
+	octave_sparse_complex_matrix::load_binary): Likewise.
+	* ov-fcn-handle.cc (octave_fcn_handle::save_binary,
+	octave_fcn_handle::load_binary): Likewise.
+	* ov-fcn-inline.cc (octave_fcn_inline::save_binary,
+	octave_fcn_inline::load_binary): Likewise.
+	* ov-list.cc (octave_list::save_binary, octave_list::load_binary):
+	Likewise.
+	* ov-range.cc (octave_range::save_binary, octave_range::load_binary): 
+	Likewise.
+	* ov-re-mat.cc (octave_matrix::save_binary,
+	octave_matrix::load_binary): Likewise.
+	* ov-re-sparse.cc (octave_sparse_matrix::save_binary,
+	octave_sparse_matrix::load_binary): Likewise.
+	* ov-scalar.cc (octave_scalar::save_binary,
+	octave_scalar::load_binary): Likewise.
+	* ov-str-mat.cc (octave_char_matrix_str::save_binary,
+	(octave_char_matrix_str::load_binary): Likewise.
+	* ov-struct.cc (octave_struct::save_binary,
+	octave_struct::load_binary): Likewise.
+	* ls-oct-binary.cc (save_binary_data, read_binary_data): Likewise.
+	* ls-mat4.cc (read_mat_file_header, save_mat_binary_data): Likewise.
+	* ls-mat5.cc (read_mat5_tag, read_mat5_binary_element,
+	read_mat5_binary_element, read_mat5_binary_file_header,
+	MAT5_DO_WRITE, write_mat5_array, write_mat5_integer_data,
+	save_mat5_binary_element, READ_INTEGER_DATA): Likewise.
+
+2006-04-12  John W. Eaton  <jwe@octave.org>
+
 	* ov.h (OV_REP_TYPE): New macro.
 
 	* DLD-FUNCTIONS/sparse.cc (MINMAX_BODY): No need to cast arg1 to
 	const octave_sparse_matrix&.
 
 	* ov-base.cc (print_answer_id_name, warn_resize_on_range_error,
 	warn_num_to_str, silent_functions): Move here, from ov.cc.
 	(Vwarn_resize_on_range_error, Vsilent_functions): Likewise.
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -87,35 +87,35 @@ int_array2_to_matrix (const Array2<octav
 
   Matrix retval (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 
-	retval(i,j) = (double) (a(i,j));
+	retval(i,j) = static_cast<double> (a(i,j));
       }
 
   return retval;
 }
 
 static inline NDArray
-int_arrayN_to_array (const ArrayN<int>& a)
+int_arrayN_to_array (const ArrayN<octave_idx_type>& a)
 {
   dim_vector dv = a.dims ();
   int nel = dv.numel ();
 
   NDArray retval (dv);
 
   for (int i = 0; i < nel; i++)
     {
       OCTAVE_QUIT;
       
-      retval(i) = (double) (a(i));
+      retval(i) = static_cast<double> (a(i));
     }
 
   return retval;
 }
 
 static void
 gripe_bessel_arg (const char *fn, const char *arg)
 {
@@ -150,17 +150,17 @@ do_bessel (enum bessel_type type, const 
 		  if (! error_state)
 		    {
 		      octave_idx_type ierr;
 		      octave_value result;
 
 		      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 		      if (nargout > 1)
-			retval(1) = (double) ierr;
+			retval(1) = static_cast<double> (ierr);
 
 		      retval(0) = result;
 		    }
 		  else
 		    gripe_bessel_arg (fn, "second");
 		}
 	      else
 		{
@@ -458,22 +458,20 @@ return @code{NaN}.\n\
       bool scale = (nargin == 3);
 
       int kind = 0;
 
       ComplexNDArray z;
 
       if (nargin > 1)
 	{
-	  double d_kind = args(0).double_value ();
+	  kind = args(0).int_value ();
 
 	  if (! error_state)
 	    {
-	      kind = (int) d_kind;
-
 	      if (kind < 0 || kind > 3)
 		error ("airy: expecting K = 0, 1, 2, or 3");
 	    }	      
 	  else
 	    error ("airy: expecting integer value for K");
 	}
 
       if (! error_state)
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -405,17 +405,17 @@ colamd, symamd, and other related orderi
 	  NDArray User_knobs = args(1).array_value ();
 	  int nel_User_knobs = User_knobs.length ();
 	  
 	  if (nel_User_knobs > 0) 
 	    knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
 	  if (nel_User_knobs > 0) 
 	    knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
 	  if (nel_User_knobs > 1) 
-	    spumoni = (int) User_knobs (2);
+	    spumoni = static_cast<int> (User_knobs (2));
 
 	  // print knob settings if spumoni is set
 	  if (spumoni)
 	    {
 	      octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
 			    <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
 	      if (knobs [CCOLAMD_DENSE_ROW] >= 0)
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -113,17 +113,17 @@ r' * r = a.\n\
   else
     {
       gripe_wrong_type_arg ("chol", arg);
     }
 
   return retval;
 }
 
-DEFUN_DLD (cholinv, args, nargout,
+DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{a})\n\
 Use the Cholesky factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{a}.\n\
 @seealso{chol, chol2inv}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -174,17 +174,17 @@ symmetric positive definite matrix @var{
 	}
     }
   else
     print_usage ("chol");
 
   return retval;
 }
 
-DEFUN_DLD (chol2inv, args, nargout,
+DEFUN_DLD (chol2inv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} chol2inv (@var{u})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
 decomposition, @var{u}.  Note that @var{u} should be an upper-triangular\n\
 matrix with positive diagonal elements.  @code{chol2inv (@var{u})}\n\
 provides @code{inv (@var{u}'*@var{u})} but it is much faster than\n\
 using @code{inv}.\n\
 @seealso{chol, cholinv}\n\
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -287,17 +287,17 @@ Ng, Oak Ridge National Laboratory. (see\
 	  NDArray User_knobs = args(1).array_value ();
 	  int nel_User_knobs = User_knobs.length ();
 	  
 	  if (nel_User_knobs > 0) 
 	    knobs [COLAMD_DENSE_ROW] = User_knobs (0);
 	  if (nel_User_knobs > 1) 
 	    knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
 	  if (nel_User_knobs > 2) 
-	    spumoni = (int) User_knobs (2);
+	    spumoni = static_cast<int> (User_knobs (2));
 
 	  // print knob settings if spumoni is set
 	  if (spumoni)
 	    {
 
 	      octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
 			    <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
@@ -521,17 +521,17 @@ Ng, Oak Ridge National Laboratory. (see\
       if (nargin == 2)
 	{
 	  NDArray User_knobs = args(1).array_value ();
 	  int nel_User_knobs = User_knobs.length ();
 	  
 	  if (nel_User_knobs > 0) 
 	    knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
 	  if (nel_User_knobs > 1) 
-	    spumoni = (int) User_knobs (1);
+	    spumoni = static_cast<int> (User_knobs (1));
 	}
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
 	octave_stdout << "symamd: dense row/col fraction: " 
 		      << knobs [COLAMD_DENSE_ROW] << std::endl;
       
       octave_idx_type n_row, n_col, nnz;
diff --git a/src/DLD-FUNCTIONS/dispatch.cc b/src/DLD-FUNCTIONS/dispatch.cc
--- a/src/DLD-FUNCTIONS/dispatch.cc
+++ b/src/DLD-FUNCTIONS/dispatch.cc
@@ -393,17 +393,17 @@ dispatch_record (const std::string &f, c
       sr->document ("\n\n@noindent\nOverloaded function:\n");
       sr->make_eternal (); // XXX FIXME XXX why??
       sr->mark_as_static ();
       sr->protect ();
     }
 
   // clear/replace/extend the map with the new type-function pair
   const octave_dispatch& rep
-    = reinterpret_cast<const octave_dispatch&> (sr->def().get_rep ());
+    = dynamic_cast<const octave_dispatch&> (sr->def().get_rep ());
 
   if (t.empty ())
     // XXX FIXME XXX should return the list if nargout > 1
     rep.print (octave_stdout);
   else if (n.empty ())
     {
       // XXX FIXME XXX should we eliminate the dispatch function if
       // there are no more elements?
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -107,45 +107,49 @@ matrix type.\n\
     error ("matrix_type: incorrect number of arguments");
   else
     {
       if (args(0).is_sparse_type ())
 	{
 	  if (nargin == 1)
 	    {
 	      SparseType mattyp;
-	      const octave_base_value& rep = args(0).get_rep ();
 
 	      if (args(0).type_name () == "sparse complex matrix" ) 
 		{
-		  mattyp = 
-		    ((const octave_sparse_complex_matrix &)rep).sparse_type ();
+		  const octave_sparse_complex_matrix& rep
+		    = dynamic_cast<const octave_sparse_complex_matrix&> (args(0).get_rep ());
+
+		  mattyp = rep.sparse_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
 		      SparseComplexMatrix m = 
 			args(0).sparse_complex_matrix_value ();
 		      if (!error_state)
 			{
 			  mattyp = SparseType (m);
-			    ((octave_sparse_complex_matrix &)rep).sparse_type (mattyp);
+			  rep.sparse_type (mattyp);
 			}
 		    }
 		}
 	      else
 		{
-		  mattyp = ((const octave_sparse_matrix &)rep).sparse_type ();
+		  const octave_sparse_matrix& rep
+		    = dynamic_cast<const octave_sparse_matrix&> (args(0).get_rep ());
+
+		  mattyp = rep.sparse_type ();
 
 		  if (mattyp.is_unknown ())
 		    {
 		      SparseMatrix m = args(0).sparse_matrix_value ();
 		      if (!error_state)
 			{
 			  mattyp = SparseType (m);
-			  ((octave_sparse_matrix &)rep).sparse_type (mattyp);
+			  rep.sparse_type (mattyp);
 			}
 		    }
 		}
 
 	      int typ = mattyp.type ();
 
 	      if (typ == SparseType::Diagonal)
 		retval = octave_value ("Diagonal");
@@ -262,17 +266,17 @@ matrix type.\n\
 			      
 			      if (len != dv(0))
 				error ("matrix_type: Invalid permutation vector");
 			      else
 				{
 				  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
 				  for (octave_idx_type i = 0; i < len; i++)
-				    p[i] = (octave_idx_type) (perm (i)) - 1; 
+				    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
 
 				  if (str_typ == "upper")
 				    mattyp.mark_as_permuted (len, p);
 				  else
 				    mattyp.mark_as_permuted (len, p);
 				}
 			    }
 			}
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -245,17 +245,17 @@ do_rand (const octave_value_list& args, 
 	      error ("%s: unrecognized string argument", fcn);
 	  }
 	else
 	  {
 	    dims.resize (nargin);
 
 	    for (int i = 0; i < nargin; i++)
 	      {
-		dims(i) = (octave_idx_type)args(idx+i).int_value ();
+		dims(i) = args(idx+i).int_value ();
 
 		if (error_state)
 		  {
 		    error ("%s: expecting integer arguments", fcn);
 		    goto done;
 		  }
 	      }
 
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -308,28 +308,20 @@ octregexp (const octave_value_list &args
       pcre_free(re);
 #else
       regex_t compiled;
       int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED | 
 		      (case_insensitive ? REG_ICASE : 0));
       if (err)
 	{
 	  int len = regerror(err, &compiled, NULL, 0);
-	  char *errmsg = (char *)malloc(len);
-	  if (errmsg)
-	    {
-	      regerror(err, &compiled, errmsg, len);
-	      error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
-		    pattern.c_str());
-	      free(errmsg);
-	    }
-	  else
-	    {
-	      error("out of memory");
-	    }
+	  OCTAVE_LOCAL_BUFFER (char, errmsg, len);
+	  regerror(err, &compiled, errmsg, len);
+	  error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
+		pattern.c_str());
 	  regfree(&compiled);
 	  return retval;
 	}
 
       int subexpr = 1;
       int idx = 0;
       int sz = 0;
       for (unsigned int i=0; i < pattern.length(); i++)
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -241,17 +241,17 @@ mx_sort_indexed (ArrayN<T> &m, int dim, 
 // bit of magic we can automatically sort the NaN's correctly.
 
 #if defined (HAVE_IEEE754_DATA_FORMAT) && defined (EIGHT_BYTE_INT)
 
 static inline unsigned EIGHT_BYTE_INT
 FloatFlip (unsigned EIGHT_BYTE_INT f)
 {
   unsigned EIGHT_BYTE_INT mask
-    = -(EIGHT_BYTE_INT)(f >> 63) | 0x8000000000000000ULL;
+    = -static_cast<EIGHT_BYTE_INT>(f >> 63) | 0x8000000000000000ULL;
 
   return f ^ mask;
 }
 
 static inline unsigned EIGHT_BYTE_INT
 IFloatFlip (unsigned EIGHT_BYTE_INT f)
 {
   unsigned EIGHT_BYTE_INT mask = ((f >> 63) - 1) | 0x8000000000000000ULL;
@@ -345,27 +345,27 @@ mx_sort (ArrayN<double> &m, int dim, sor
 	  // sorted to the beginning of the vector and the other
 	  // to the end.  If it will be sorted incorrectly, fix
 	  // things up.
 
 	  if (lo_ieee_signbit (octave_NaN))
 	    if (mode == UNDEFINED || mode == ASCENDING)
 	      {
 		octave_idx_type i = 0;
-		double *vtmp = (double *)p;
+		double *vtmp = reinterpret_cast<double *> (p);
 		while (xisnan (vtmp[i++]) && i < ns);
 		for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		  vtmp[l] = vtmp[l+i-1];
 		for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		  vtmp[l] = octave_NaN;
 	      }
 	    else
 	      {
 		octave_idx_type i = ns;
-		double *vtmp = (double *)p;
+		double *vtmp = reinterpret_cast<double *> (p);
 		while (xisnan (vtmp[--i]) && i > 0);
 		for (octave_idx_type l = i; l >= 0; l--)
 		  vtmp[l-i+ns-1] = vtmp[l];
 		for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		  vtmp[l] = octave_NaN;
 	      }
 
 	  p += ns;
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -144,33 +144,27 @@ which case they are expanded to all have
 		       args(1).is_scalar_type()))
      {
        octave_value arg = args (0);
 
        if (is_sparse (arg))
 	 {
 	   if (use_complex) 
 	     {
-	       SparseComplexMatrix sm (((const octave_sparse_complex_matrix&) arg
-					.get_rep ())
-				       .sparse_complex_matrix_value ());
+	       SparseComplexMatrix sm = arg.sparse_complex_matrix_value ();
 	       retval = new octave_sparse_complex_matrix (sm);
 	     }
 	   else if (use_bool) 
 	     {
-	       SparseBoolMatrix sm (((const octave_sparse_bool_matrix&) arg
-					.get_rep ())
-				       .sparse_bool_matrix_value ());
+	       SparseBoolMatrix sm = arg.sparse_bool_matrix_value ();
 	       retval = new octave_sparse_bool_matrix (sm);
 	     }
 	   else
 	     {
-	       SparseMatrix sm (((const octave_sparse_matrix&) arg
-				 .get_rep ())
-				.sparse_matrix_value ());
+	       SparseMatrix sm = arg.sparse_matrix_value ();
 	       retval = new octave_sparse_matrix (sm);
 	     }
 	 }
        else
 	 {
 	   if (use_complex) 
 	     {
 	       SparseComplexMatrix sm (args (0).complex_matrix_value ());
@@ -375,20 +369,21 @@ DEFUN_DLD (full, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})\n\
  returns a full storage matrix from a sparse one\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length() < 1) {
-     print_usage ("full");
-     return retval;
-  }
+  if (args.length() < 1)
+    {
+      print_usage ("full");
+      return retval;
+    }
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).type_name () == "sparse matrix") 
 	retval = args(0).matrix_value ();
       else if (args(0).type_name () == "sparse complex matrix")
 	retval = args(0).complex_matrix_value ();
       else if (args(0).type_name () == "sparse bool matrix")
@@ -425,28 +420,29 @@ sparse_find (const SparseMatrix& v)
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = v.data(j);
 	  cx++;
 	}
     }
 
   if (dv(0) == 1)
     {
-      retval(0)= I.transpose ();
-      retval(1)= J.transpose ();
-      retval(2)= S.transpose ();
+      retval(0) = I.transpose ();
+      retval(1) = J.transpose ();
+      retval(2) = S.transpose ();
     }
   else
     {
-      retval(0)= I;
-      retval(1)= J;
-      retval(2)= S;
+      retval(0) = I;
+      retval(1) = J;
+      retval(2) = S;
     }
-  retval(3)= (double) nr;
-  retval(4)= (double) nc;
+  retval(3) = static_cast<double> (nr);
+  retval(4) = static_cast<double> (nc);
+
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseComplexMatrix& v)
 {
   octave_value_list retval;
   octave_idx_type nnz = v.nnz ();
@@ -466,28 +462,29 @@ sparse_find (const SparseComplexMatrix& 
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = v.data(j);
 	  cx++;
 	}
     }
 
   if (dv(0) == 1)
     {
-      retval(0)= I.transpose ();
-      retval(1)= J.transpose ();
-      retval(2)= S.transpose ();
+      retval(0) = I.transpose ();
+      retval(1) = J.transpose ();
+      retval(2) = S.transpose ();
     }
   else
     {
-      retval(0)= I;
-      retval(1)= J;
-      retval(2)= S;
+      retval(0) = I;
+      retval(1) = J;
+      retval(2) = S;
     }
-  retval(3)= (double) nr;
-  retval(4)= (double) nc;
+  retval(3) = static_cast<double> (nr);
+  retval(4) = static_cast<double> (nc);
+
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseBoolMatrix& v)
 {
   octave_value_list retval;
   octave_idx_type nnz = v.nnz ();
@@ -507,28 +504,29 @@ sparse_find (const SparseBoolMatrix& v)
 	  J (cx) = static_cast<double> (i + 1);
 	  S (cx) = static_cast<double> (v.data(j));
 	  cx++;
 	}
     }
 
   if (dv(0) == 1)
     {
-      retval(0)= I.transpose ();
-      retval(1)= J.transpose ();
-      retval(2)= S.transpose ();
+      retval(0) = I.transpose ();
+      retval(1) = J.transpose ();
+      retval(2) = S.transpose ();
     }
   else
     {
-      retval(0)= I;
-      retval(1)= J;
-      retval(2)= S;
+      retval(0) = I;
+      retval(1) = J;
+      retval(2) = S;
     }
-  retval(3)= (double) nr;
-  retval(4)= (double) nc;
+  retval(3) = static_cast<double> (nr);
+  retval(4) = static_cast<double> (nc);
+
   return retval;
 }
 
 // PKG_ADD: dispatch ("find", "spfind", "sparse matrix");
 // PKG_ADD: dispatch ("find", "spfind", "sparse complex matrix");
 // PKG_ADD: dispatch ("find", "spfind", "sparse bool matrix");
 DEFUN_DLD (spfind, args, nargout ,
     "-*- texinfo -*-\n\
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -401,17 +401,17 @@ factorization as determined by @var{typ}
   double spu = Voctave_sparse_controls.get_key ("spumoni");
   if (spu == 0.)
     {
       cm->print = -1;
       cm->print_function = NULL;
     }
   else
     {
-      cm->print = (int)spu + 2;
+      cm->print = static_cast<int> (spu) + 2;
       cm->print_function =&SparseCholPrint;
     }
 
   cm->error_handler = &SparseCholError;
   cm->complex_divide = CHOLMOD_NAME(divcomplex);
   cm->hypotenuse = CHOLMOD_NAME(hypot);
 
 #ifdef HAVE_METIS
@@ -647,17 +647,17 @@ factorization as determined by @var{typ}
 
       if (nargout > 1)
 	{
 	  /* compute the elimination tree height */
 	  octave_idx_type height = 0 ;
 	  for (int i = 0 ; i < n ; i++)
 	    height = (height > Level[i] ? height : Level[i]);
 	  height++ ;
-	  retval(1) = (double)height;
+	  retval(1) = static_cast<double> (height);
 	}
 
       for (octave_idx_type i = 0; i < n; i++)
 	tmp(i) = ColCount[i];
       retval(0) = tmp;
     }
 
  symbfact_error:
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -416,17 +416,16 @@ than @code{@var{y} = spinv (@var{a}) * @
 
   if (nargin != 1)
     {
       print_usage ("inv");
       return retval;
     }
 
   octave_value arg = args(0);
-  const octave_base_value& rep = arg.get_rep ();
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("spinverse", nr, nc);
 
   if (arg_is_empty < 0)
     return retval;
@@ -441,21 +440,26 @@ than @code{@var{y} = spinv (@var{a}) * @
 
   if (arg.is_real_type ())
     {
       
       SparseMatrix m = arg.sparse_matrix_value ();      
 
       if (! error_state)
 	{
+	  const octave_sparse_matrix& rep
+	    = dynamic_cast<const octave_sparse_matrix&> (arg.get_rep ());
+
+	  SparseType mattyp = rep.sparse_type ();
+
 	  octave_idx_type info;
 	  double rcond = 0.0;
-	  SparseType mattyp = ((octave_sparse_matrix &)rep).sparse_type ();
 	  SparseMatrix result = m.inverse (mattyp, info, rcond, 1);
-	  ((octave_sparse_matrix &)(arg.get_rep())).sparse_type (mattyp);
+
+	  rep.sparse_type (mattyp);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
 
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
@@ -465,23 +469,26 @@ than @code{@var{y} = spinv (@var{a}) * @
 	}
     }
   else if (arg.is_complex_type ())
     {
       SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
       if (! error_state)
 	{
+	  const octave_sparse_complex_matrix& rep
+	    = dynamic_cast<const octave_sparse_complex_matrix&> (arg.get_rep ());
+	  SparseType mattyp = rep.sparse_type ();
+
 	  octave_idx_type info;
 	  double rcond = 0.0;
 
-	  SparseType mattyp = 
-	    ((octave_sparse_complex_matrix &)rep).sparse_type ();
 	  SparseComplexMatrix result = m.inverse (mattyp, info, rcond, 1);
-	  ((octave_sparse_matrix &)rep).sparse_type (mattyp);
+
+	  rep.sparse_type (mattyp);
 
 	  if (nargout > 1)
 	    retval(1) = rcond;
 
 	  retval(0) = result;
 
 	  volatile double xrcond = rcond;
 	  xrcond += 1.0;
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -261,16 +261,18 @@ DISTFILES = Makefile.in ChangeLog mkdefs
 	oct-gperf.h parse.cc lex.cc y.tab.h __gnuplot_raw__.cc \
 	$(INCLUDES) $(DIST_SRC) $(OPT_HANDLERS) $(EXTRAS)
 
 all: octave$(EXEEXT) $(OCT_FILES) PKG_ADD DOCSTRINGS
 .PHONY: all
 
 objects: $(OBJECTS)
 
+lex.o parse.o pic/lex.o pic/parse.o : ALL_CXXFLAGS := $(filter-out -Wold-style-cast, $(ALL_CXXFLAGS))
+
 XERBLA = ../libcruft/blas-xtra/xerbla.o
 ifdef FPICFLAG
   PIC_XERBLA = ../libcruft/blas-xtra/pic/xerbla.o
 else
   PIC_XERBLA = $(XERBLA)
 endif
 
 ifeq ($(SHARED_LIBS), true)
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -42,17 +42,18 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix,+)
 DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix,-)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
+		   const octave_sparse_complex_matrix&);
   
   SparseType typ = v2.sparse_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
 			    v2.sparse_complex_matrix_value (), typ);
 
   v2.sparse_type (typ);
   return ret;
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -42,17 +42,17 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
   
   SparseType typ = v2.sparse_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
 			    v2.sparse_matrix_value (), typ);
 
   v2.sparse_type (typ);
   return ret;
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -40,17 +40,17 @@ Boston, MA 02110-1301, USA.
 // complex scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   SparseType typ = v2.sparse_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
   v2.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -42,17 +42,17 @@ Boston, MA 02110-1301, USA.
 // complex by sparse matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
   SparseType typ = v2.sparse_type ();
   ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
   v2.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -43,17 +43,17 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
   SparseType typ = v2.sparse_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (), 
 			    v2.sparse_complex_matrix_value (), typ);
 
   v2.sparse_type (typ);
   return ret;
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -42,17 +42,17 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
   SparseType typ = v2.sparse_type ();
 
   Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
 
   v2.sparse_type (typ);
   return ret;
 }
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -43,17 +43,17 @@ Boston, MA 02110-1301, USA.
 // scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
   SparseType typ = v2.sparse_type ();
   Matrix m1 = Matrix (1, 1, v1.scalar_value ());
   SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
   ComplexMatrix ret = xdiv (m1, m2, typ);
   v2.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -39,17 +39,17 @@ Boston, MA 02110-1301, USA.
 // scalar by sparse matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
   SparseType typ = v2.sparse_type ();
   Matrix m1 = Matrix (1, 1, v1.double_value ());
   SparseMatrix m2 = v2.sparse_matrix_value ();
   Matrix ret = xdiv (m1, m2, typ);
   v2.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -56,17 +56,17 @@ DEFBINOP (div, sparse_complex_matrix, co
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
   SparseType typ = v1.sparse_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				v2.complex_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -67,17 +67,17 @@ DEFBINOP (pow, sparse_complex_matrix, co
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.scalar_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
   SparseType typ = v1.sparse_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -57,17 +57,17 @@ DEFBINOP (div, sparse_complex_matrix, ma
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
   
   SparseType typ = v1.sparse_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				v2.matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -75,17 +75,17 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
   SparseType typ = v1.sparse_type ();
   SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -91,34 +91,34 @@ DEFUNOP (decr, sparse_complex_matrix)
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
-		   octave_sparse_complex_matrix&);
+		   const octave_sparse_complex_matrix&);
   SparseType typ = v2.sparse_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
 				  v2.sparse_complex_matrix_value (), typ);
   
   v2.sparse_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
   SparseType typ = v1.sparse_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				      v2.sparse_complex_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -41,34 +41,34 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
   SparseType typ = v2.sparse_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
 				  v2.sparse_matrix_value (), typ);
   
   v2.sparse_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
   SparseType typ = v1.sparse_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
 				      v2.sparse_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -56,17 +56,17 @@ DEFBINOP (div, sparse_matrix, complex_ma
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
   SparseType typ = v1.sparse_type ();
 
   ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 				v2.complex_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -67,17 +67,17 @@ DEFBINOP (div, sparse_matrix, complex)
 DEFBINOP (pow, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   SparseType typ = v1.sparse_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -55,17 +55,17 @@ DEFBINOP (div, sparse_matrix, matrix)
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
   SparseType typ = v1.sparse_type ();
 
   Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
 			       v2.matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -69,17 +69,17 @@ DEFBINOP (pow, sparse_matrix, scalar)
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_matrix_value (), tmp);
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_scalar&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   SparseType typ = v1.sparse_type ();
   SparseMatrix m1 = v1.sparse_matrix_value ();
   Matrix m2 = Matrix (1, 1, v2.scalar_value ());
   Matrix ret = xleftdiv (m1, m2, typ);
   v1.sparse_type (typ);
 
   return ret;
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -41,34 +41,34 @@ Boston, MA 02110-1301, USA.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
   SparseType typ = v2.sparse_type ();
   SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
 				  v2.sparse_complex_matrix_value (), typ);
   
   v2.sparse_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
   SparseType typ = v1.sparse_type ();
 
   SparseComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 				      v2.sparse_complex_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -51,34 +51,34 @@ DEFUNOP (transpose, sparse_matrix)
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
   SparseType typ = v2.sparse_type ();
   SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
 			   v2.sparse_matrix_value (), typ);
   
   v2.sparse_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
   SparseType typ = v1.sparse_type ();
 
   SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
 			       v2.sparse_matrix_value (), typ);
 
   v1.sparse_type (typ);
   return ret;
 }
diff --git a/src/OPERATORS/op-streamoff.cc b/src/OPERATORS/op-streamoff.cc
--- a/src/OPERATORS/op-streamoff.cc
+++ b/src/OPERATORS/op-streamoff.cc
@@ -65,17 +65,17 @@ DEFNDBINOP_OP (add_so_s, streamoff, scal
 DEFNDBINOP_OP (sub_so_s, streamoff, scalar, streamoff_array, streamoff, -)
 
 DEFNDBINOP_OP (add_s_so, scalar, streamoff, streamoff, streamoff_array, +)
 DEFNDBINOP_OP (sub_s_so, scalar, streamoff, streamoff, streamoff_array, +)
 
 #define STREAMOFF_COMP_OP(FN, OP, T1, T2) \
   DEFBINOP (FN, T1, T2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1&, octave_ ## T2&); \
+    CAST_BINOP_ARGS (const octave_ ## T1&, const octave_ ## T2&); \
  \
     streamoff_array cm1 = v1.streamoff_array_value (); \
     streamoff_array cm2 = v2.streamoff_array_value (); \
  \
     if (! error_state) \
       { \
 	if (cm1.rows () == 1 && cm1.columns () == 1) \
 	  { \
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -264,17 +264,17 @@ octave_dynamic_loader::do_load (const st
 		}
 	    }
 	}
     }
 
   if (function)
     {
       octave_dld_fcn_installer f
-	= X_CAST (octave_dld_fcn_installer, function);
+	= reinterpret_cast<octave_dld_fcn_installer> (function);
 
       retval = f (oct_file);
 
       if (! retval)
 	::error ("failed to install dld function `%s'", fcn_name.c_str ());
     }
   
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -281,32 +281,32 @@ matches_patterns (const string_vector& p
 }
 
 int
 read_binary_file_header (std::istream& is, bool& swap,
 			 oct_mach_info::float_format& flt_fmt, bool quiet)
 {
   const int magic_len = 10;
   char magic[magic_len+1];
-  is.read (X_CAST (char *, magic), magic_len);
+  is.read (magic, magic_len);
   magic[magic_len] = '\0';
 
   if (strncmp (magic, "Octave-1-L", magic_len) == 0)
     swap = oct_mach_info::words_big_endian ();
   else if (strncmp (magic, "Octave-1-B", magic_len) == 0)
     swap = ! oct_mach_info::words_big_endian ();
   else
     {
       if (! quiet)
 	error ("load: unable to read read binary file");
       return -1;
     }
 	
   char tmp = 0;
-  is.read (X_CAST (char *, &tmp), 1);
+  is.read (&tmp, 1);
 
   flt_fmt = mopt_digit_to_float_format (tmp);
 
   if (flt_fmt == oct_mach_info::flt_fmt_unknown)
     {
       if (! quiet)
         error ("load: unrecognized binary format!");
 
@@ -319,17 +319,17 @@ read_binary_file_header (std::istream& i
 #ifdef HAVE_ZLIB
 static bool
 check_gzip_magic (const std::string& fname)
 {
   bool retval = false;
   std::ifstream file (fname.c_str ());
   OCTAVE_LOCAL_BUFFER (unsigned char, magic, 2);
 
-  if (file.read (X_CAST (char *, magic), 2) && magic[0] == 0x1f && 
+  if (file.read (reinterpret_cast<char *> (magic), 2) && magic[0] == 0x1f && 
       magic[1] == 0x8b)
     retval = true;
 
   file.close ();
   return retval;
 } 
 #endif
 
@@ -1207,19 +1207,19 @@ write_header (std::ostream& os, load_sav
     case LS_BINARY:
       {
 	os << (oct_mach_info::words_big_endian ()
 	       ? "Octave-1-B" : "Octave-1-L");
 
 	oct_mach_info::float_format flt_fmt =
 	  oct_mach_info::native_float_format ();
 
-	char tmp = (char) float_format_to_mopt_digit (flt_fmt);
+	char tmp = static_cast<char> (float_format_to_mopt_digit (flt_fmt));
 
-	os.write (X_CAST (char *, &tmp), 1);
+	os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
 	char const * versionmagic;
 	TWO_BYTE_INT number = *(TWO_BYTE_INT *)"\x00\x01";
@@ -1227,17 +1227,17 @@ write_header (std::ostream& os, load_sav
 	time_t now;
 	char headertext[128];
 
 	time (&now);
 	bdt = *gmtime (&now);
 	memset (headertext, ' ', 124);
 	// ISO 8601 format date
 	strftime (headertext, 124, "MATLAB 5.0 MAT-file, written by Octave "
-		 OCTAVE_VERSION ", %Y-%m-%d %T UTC", &bdt);
+		  OCTAVE_VERSION ", %Y-%m-%d %T UTC", &bdt);
 
 	// The first pair of bytes give the version of the MAT file
 	// format.  The second pair of bytes form a magic number which
 	// signals a MAT file.  MAT file data are always written in
 	// native byte order.  The order of the bytes in the second
 	// pair indicates whether the file was written by a big- or
 	// little-endian machine.  However, the version number is
 	// written in the *opposite* byte order from everything else!
@@ -1261,17 +1261,17 @@ write_header (std::ostream& os, load_sav
 
 	std::string comment_string = now.strftime (Vsave_header_format_string);
 
 	if (! comment_string.empty ())
 	  {
 #ifdef HAVE_HDF5
 	    if (format == LS_HDF5)
 	      {
-		hdf5_ofstream& hs = (hdf5_ofstream&) os;
+		hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
 		H5Gset_comment (hs.file_id, "/", comment_string.c_str ());
 	      }
 	    else
 #endif /* HAVE_HDF5 */
 	      os << comment_string << "\n";
 	  }
       }
     break;
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -261,17 +261,17 @@ hdf5_read_next_data (hid_t group_id, con
 
 	  OCTAVE_LOCAL_BUFFER (char, typ, slen);
 
 	  // create datatype for (null-terminated) string to read into:
 	  hid_t st_id = H5Tcopy (H5T_C_S1);
 	  H5Tset_size (st_id, slen);
 
 	  if (H5Dread (data_id, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
-		       (void *) typ) < 0)
+		       typ) < 0)
 	    goto done;
 
 	  H5Tclose (st_id);
 	  H5Dclose (data_id);
 
 	  d->tc = octave_value_typeinfo::lookup_type (typ);
 
 	  retval = (d->tc.load_hdf5 (subgroup_id, "value", 
@@ -523,17 +523,17 @@ hdf5_read_next_data (hid_t group_id, con
 std::string
 read_hdf5_data (std::istream& is, const std::string& /* filename */, 
 		bool& global, octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   doc.resize (0);
 
-  hdf5_ifstream& hs = (hdf5_ifstream&) is;
+  hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
   // Versions of HDF5 prior to 1.2.2 had a bug in H5Giterate where it
   // would return the index of the last item processed instead of the
   // next item to be processed, forcing us to increment the index manually.
 
   unsigned int vers_major, vers_minor, vers_release;
 
@@ -597,17 +597,17 @@ hdf5_add_attr (hid_t loc_id, const char 
     {
       hid_t a_id = H5Acreate (loc_id, attr_name,
 			      H5T_NATIVE_UCHAR, as_id, H5P_DEFAULT);
 
       if (a_id >= 0)
 	{
 	  unsigned char attr_val = 1;
 
-	  retval = H5Awrite (a_id, H5T_NATIVE_UCHAR, (void*) &attr_val);
+	  retval = H5Awrite (a_id, H5T_NATIVE_UCHAR, &attr_val);
 
 	  H5Aclose (a_id);
 	}
       else
 	retval = a_id;
 
       H5Sclose (as_id);
     }
@@ -634,29 +634,29 @@ save_hdf5_empty (hid_t loc_id, const cha
       dims[i] = d(i);
       if (dims[i] < 1)
 	empty = true;
     }
 
   if (!empty)
     return 0;
 
-  space_hid = H5Screate_simple (1, &sz, (hsize_t *) 0);
+  space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
 
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return data_hid;
     }
   
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) dims) >= 0;
+		     H5P_DEFAULT, dims) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   if (retval >= 0)
     retval = hdf5_add_attr (loc_id, "OCTAVE_EMPTY_MATRIX");
   
   return (retval == 0 ? 1 : retval);
@@ -676,17 +676,17 @@ load_hdf5_empty (hid_t loc_id, const cha
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t space_id = H5Dget_space (data_hid);
   H5Sget_simple_extent_dims (space_id, &hdims, &maxdims);
   int retval;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, hdims);
 
   retval = H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-		    H5P_DEFAULT, (void *) dims);
+		    H5P_DEFAULT, dims);
   if (retval >= 0)
     {
       d.resize (hdims);
       for (hsize_t i = 0; i < hdims; i++)
 	d(i) = dims[i];
     }
 
   H5Sclose (space_id);
@@ -756,23 +756,23 @@ add_hdf5_data (hid_t loc_id, const octav
     goto error_cleanup;
 
   // attach the type of the variable
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
   if (type_id < 0)
     goto error_cleanup;
 
   dims[0] = 0;
-  space_id = H5Screate_simple (0 , dims, (hsize_t*) 0);
+  space_id = H5Screate_simple (0 , dims, 0);
   if (space_id < 0)
     goto error_cleanup;
 
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, H5P_DEFAULT);
   if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, H5S_ALL, H5S_ALL, 
-				    H5P_DEFAULT, (void*) t.c_str ()) < 0)
+				    H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
 
   // Now call the real function to save the variable
   retval = val.save_hdf5 (data_id, "value", save_as_floats);
 
   // attach doc string as comment:
   if (retval && doc.length () > 0
       && H5Gset_comment (loc_id, name.c_str (), doc.c_str ()) < 0)
@@ -809,17 +809,17 @@ add_hdf5_data (hid_t loc_id, const octav
 // Write data from TC in HDF5 (binary) format to the stream OS,
 // which must be an hdf5_ofstream, returning true on success.
 
 bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
 		const std::string& name, const std::string& doc,
 		bool mark_as_global, bool save_as_floats)
 {
-  hdf5_ofstream& hs = (hdf5_ofstream&) os;
+  hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
 
   return add_hdf5_data (hs.file_id, tc, name, doc,
 			mark_as_global, save_as_floats);
 }
 
 #endif
 
 /*
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -116,30 +116,30 @@ read_mat_file_header (std::istream& is, 
 		      int quiet)
 {
   swap = false;
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another mopt value should not result in an
   // error.
 
-  is.read (X_CAST (char *, &mopt), 4);
+  is.read (reinterpret_cast<char *> (&mopt), 4);
   if (! is)
     return 1;
 
-  if (! is.read (X_CAST (char *, &nr), 4))
+  if (! is.read (reinterpret_cast<char *> (&nr), 4))
     goto data_read_error;
 
-  if (! is.read (X_CAST (char *, &nc), 4))
+  if (! is.read (reinterpret_cast<char *> (&nc), 4))
     goto data_read_error;
 
-  if (! is.read (X_CAST (char *, &imag), 4))
+  if (! is.read (reinterpret_cast<char *> (&imag), 4))
     goto data_read_error;
 
-  if (! is.read (X_CAST (char *, &len), 4))
+  if (! is.read (reinterpret_cast<char *> (&len), 4))
     goto data_read_error;
 
 // If mopt is nonzero and the byte order is swapped, mopt will be
 // bigger than we expect, so we swap bytes.
 //
 // If mopt is zero, it means the file was written on a little endian
 // machine, and we only need to swap if we are running on a big endian
 // machine.
@@ -318,17 +318,17 @@ read_mat_binary_data (std::istream& is, 
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it, but apparently not all files do.  Either
   // way, I think this should work.
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
     name[len] = '\0';
-    if (! is.read (X_CAST (char *, name), len))
+    if (! is.read (name, len))
       goto data_read_error;
     retval = name;
 
     dlen = nr * nc;
     if (dlen < 0)
       goto data_read_error;
 
     if (order)
@@ -394,35 +394,35 @@ save_mat_binary_data (std::ostream& os, 
 
   mopt += tc.is_string () ? 1 : 0;
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();;
 
   mopt += 1000 * float_format_to_mopt_digit (flt_fmt);
 
-  os.write (X_CAST (char *, &mopt), 4);
+  os.write (reinterpret_cast<char *> (&mopt), 4);
   
   FOUR_BYTE_INT nr = tc.rows ();
-  os.write (X_CAST (char *, &nr), 4);
+  os.write (reinterpret_cast<char *> (&nr), 4);
 
   FOUR_BYTE_INT nc = tc.columns ();
-  os.write (X_CAST (char *, &nc), 4);
+  os.write (reinterpret_cast<char *> (&nc), 4);
 
   octave_idx_type len = nr * nc;
 
   FOUR_BYTE_INT imag = tc.is_complex_type () ? 1 : 0;
-  os.write (X_CAST (char *, &imag), 4);
+  os.write (reinterpret_cast<char *> (&imag), 4);
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it.
 
   FOUR_BYTE_INT name_len = name.length () + 1;
 
-  os.write (X_CAST (char *, &name_len), 4);
+  os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name << '\0';
 
   if (tc.is_string ())
     {
       unwind_protect::begin_frame ("save_mat_binary_data");
 
       charMatrix chm = tc.char_matrix_value ();
 
@@ -434,54 +434,54 @@ save_mat_binary_data (std::ostream& os, 
       for (octave_idx_type i = 0; i < nrow; i++)
       	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 	  
 	  for (octave_idx_type j = 0; j < ncol; j++)
 	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
        	}
-      os.write ((char *)buf, nrow*ncol*sizeof(double));
+      os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
       
       unwind_protect::run_frame ("save_mat_binary_data");
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
 	{
 	  double x = base + i * inc;
-	  os.write (X_CAST (char *, &x), 8);
+	  os.write (reinterpret_cast<char *> (&x), 8);
 	}
     }
   else if (tc.is_real_scalar ())
     {
       double tmp = tc.double_value ();
-      os.write (X_CAST (char *, &tmp), 8);
+      os.write (reinterpret_cast<char *> (&tmp), 8);
     }
   else if (tc.is_real_matrix ())
     {
       Matrix m = tc.matrix_value ();
-      os.write (X_CAST (char *, m.data ()), 8 * len);
+      os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
     }
   else if (tc.is_complex_scalar ())
     {
       Complex tmp = tc.complex_value ();
-      os.write (X_CAST (char *, &tmp), 16);
+      os.write (reinterpret_cast<char *> (&tmp), 16);
     }
   else if (tc.is_complex_matrix ())
     {
       ComplexMatrix m_cmplx = tc.complex_matrix_value ();
       Matrix m = ::real (m_cmplx);
-      os.write (X_CAST (char *, m.data ()), 8 * len);
+      os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
       m = ::imag (m_cmplx);
-      os.write (X_CAST (char *, m.data ()), 8 * len);
+      os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
   return os;
 }
 
 /*
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -174,24 +174,22 @@ read_mat5_integer_data (std::istream& is
 			mat5_data_type type)
 {
 
 #define READ_INTEGER_DATA(TYPE, swap, data, size, len, stream)	\
   do \
     { \
       if (len > 0) \
 	{ \
-	  volatile TYPE *ptr = X_CAST (volatile TYPE *, data); \
-	  stream.read (X_CAST (char *, ptr), size * len); \
+	  OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
+	  stream.read (reinterpret_cast<char *> (ptr), size * len); \
 	  if (swap) \
 	    swap_bytes< size > (ptr, len); \
-	  TYPE tmp = ptr[0]; \
-	  for (int i = len - 1; i > 0; i--) \
+	  for (int i = 0; i < len; i++) \
 	    data[i] = ptr[i]; \
-	  data[0] = tmp; \
 	} \
     } \
   while (0)
 
   switch (type)
     {
     case miINT8:
       READ_INTEGER_DATA (signed char, swap, m, 1, count, is);
@@ -284,17 +282,17 @@ template void read_mat5_integer_data (st
 	  { \
 	    error ("load: reading matrix data for `%s'", retval.c_str ()); \
 	    goto data_read_error; \
 	  } \
   \
 	int n = re.length (); \
 	tmp_pos = is.tellg (); \
 	read_mat5_integer_data (is, re.fortran_vec (), n, swap,	\
-				(enum mat5_data_type) type); \
+				static_cast<enum mat5_data_type> (type)); \
   \
 	if (! is || error_state) \
 	  { \
 	    error ("load: reading matrix data for `%s'", retval.c_str ()); \
 	    goto data_read_error; \
 	  } \
   \
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len))); \
@@ -308,17 +306,17 @@ template void read_mat5_integer_data (st
 	      { \
 		error ("load: reading matrix data for `%s'", \
 		       retval.c_str ()); \
 		goto data_read_error; \
 	      } \
   \
 	    n = im.length (); \
 	    read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
-				   (enum mat5_data_type) type, flt_fmt); \
+				   static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
 	    if (! is || error_state) \
 	      { \
 		error ("load: reading imaginary matrix data for `%s'", \
 		       retval.c_str ()); \
 		goto data_read_error; \
 	      } \
   \
@@ -337,33 +335,33 @@ template void read_mat5_integer_data (st
 // place the type code in TYPE and the byte count in BYTES
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int& type, int& bytes)
 {
   unsigned int upper;
   FOUR_BYTE_INT temp;
 
-  if (! is.read (X_CAST (char *, &temp), 4 ))
+  if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
     goto data_read_error;
 
   if (swap)
     swap_bytes<4> (&temp);
 
   upper = (temp >> 16) & 0xffff;
   type = temp & 0xffff;
 
   if (upper)
     {
       // "compressed" format
       bytes = upper;
     }
   else
     {
-      if (! is.read (X_CAST (char *, &temp), 4 ))
+      if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
 	goto data_read_error;
       if (swap)
 	swap_bytes<4> (&temp);
       bytes = temp;
     }
 
   return 0;
 
@@ -433,30 +431,31 @@ read_mat5_binary_element (std::istream& 
 
       OCTAVE_LOCAL_BUFFER (char, inbuf, element_length);
       is.read (inbuf, element_length);
 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
-      if (uncompress (X_CAST (Bytef *, tmp), &destLen, 
-		      X_CAST (Bytef *, inbuf), element_length) !=  Z_MEM_ERROR)
+      if (uncompress (reinterpret_cast<Bytef *> (tmp), &destLen, 
+		      reinterpret_cast<Bytef *> (inbuf), element_length)
+	  !=  Z_MEM_ERROR)
 	{
 	  // Why should I have to initialize outbuf as I'll just overwrite!!
 	  if (swap)
 	    swap_bytes<4> (tmp, 2);
 
 	  destLen = tmp[1] + 8;
 	  std::string outbuf (destLen, ' '); 
 
-	  int err = uncompress (X_CAST (Bytef *, outbuf.c_str ()), &destLen, 
-			    X_CAST ( Bytef *, inbuf), element_length);
-	  //if (uncompress (X_CAST (Bytef *, outbuf.c_str ()), &destLen, 
-	  //		  X_CAST ( Bytef *, inbuf), element_length) != Z_OK)
+	  // XXX FIXME XXX -- find a way to avoid casting away const here!
+
+	  int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())), &destLen, 
+				reinterpret_cast<Bytef *> (inbuf), element_length);
 
 	  if (err != Z_OK)
 	    error ("load: error uncompressing data element");
 	  else
 	    {
 	      ISSTREAM gz_is (outbuf);
 	      retval = read_mat5_binary_element (gz_is, filename, 
 						 swap, global, tc);
@@ -489,17 +488,17 @@ read_mat5_binary_element (std::istream& 
       error ("load: invalid array flags subelement");
       goto early_read_error;
     }
 
   read_int (is, swap, flags);
   imag = (flags & 0x0800) != 0;	// has an imaginary part?
   global = (flags & 0x0400) != 0; // global variable?
   logicalvar = (flags & 0x0200) != 0; // boolean ?
-  arrayclass = (arrayclasstype)(flags & 0xff);
+  arrayclass = static_cast<arrayclasstype> (flags & 0xff);
   read_int (is, swap, nzmax);	// max number of non-zero in sparse
   
   // dimensions array subelement
   {
     FOUR_BYTE_INT dim_len;
 
     if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
       {
@@ -530,17 +529,17 @@ read_mat5_binary_element (std::istream& 
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
     // Structure field subelements have zero-length array name subelements.
 
     std::streampos tmp_pos = is.tellg ();
 
     if (len)
       {
-	if (! is.read (X_CAST (char *, name), len ))
+	if (! is.read (name, len ))
 	  goto data_read_error;
 	
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
       }
 
     name[len] = '\0';
     retval = name;
   }
@@ -618,17 +617,17 @@ read_mat5_binary_element (std::istream& 
 	  {
 	    error ("load: reading sparse row data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	tmp_pos = is.tellg ();
 
 	read_mat5_integer_data (is, ridx, nzmax, swap,
-				(enum mat5_data_type) type);
+				static_cast<enum mat5_data_type> (type));
 
 	if (! is || error_state)
 	  {
 	    error ("load: reading sparse row data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
@@ -638,17 +637,17 @@ read_mat5_binary_element (std::istream& 
 	  {
 	    error ("load: reading sparse column data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	tmp_pos = is.tellg ();
 
 	read_mat5_integer_data (is, cidx, nc + 1, swap,
-				(enum mat5_data_type) type);
+				static_cast<enum mat5_data_type> (type));
 
 	if (! is || error_state)
 	  {
 	    error ("load: reading sparse column data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
@@ -665,17 +664,17 @@ read_mat5_binary_element (std::istream& 
 	if (imag)
 	  {
 	    re = NDArray (dim_vector (static_cast<int> (nnz)));
 	    data = re.fortran_vec ();
 	  }
 
 	tmp_pos = is.tellg ();
 	read_mat5_binary_data (is, data, nnz, swap,
-			       (enum mat5_data_type) type, flt_fmt);
+			       static_cast<enum mat5_data_type> (type), flt_fmt);
 
 	if (! is || error_state)
 	  {
 	    error ("load: reading sparse matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
@@ -687,17 +686,17 @@ read_mat5_binary_element (std::istream& 
 	  
 	    if (read_mat5_tag (is, swap, type, len))
 	      {
 		error ("load: reading sparse matrix data for `%s'", retval.c_str ());
 		goto data_read_error;
 	      }
 
 	    read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
-				   (enum mat5_data_type) type, flt_fmt);
+				   static_cast<enum mat5_data_type> (type), flt_fmt);
 
 	    if (! is || error_state)
 	      {
 		error ("load: reading imaginary sparse matrix data for `%s'",
 		       retval.c_str ());
 		goto data_read_error;
 	      }
 
@@ -729,17 +728,17 @@ read_mat5_binary_element (std::istream& 
 	// that eventually someone will recognize that's a waste of
 	// space.
 	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
 	  {
 	    error ("load: invalid field name subelement");
 	    goto data_read_error;
 	  }
 
-	if (! is.read (X_CAST (char *, &field_name_length), fn_len ))
+	if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len ))
 	  goto data_read_error;
 
 	if (swap)
 	  swap_bytes<4> (&field_name_length);
 
 	// field name subelement.  The length of this subelement tells
 	// us how many fields there are.
 	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT8)
@@ -853,17 +852,17 @@ read_mat5_binary_element (std::istream& 
 	  {
 	    error ("load: reading matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	int n = re.length ();
 	tmp_pos = is.tellg ();
 	read_mat5_binary_data (is, re.fortran_vec (), n, swap,
-			       (enum mat5_data_type) type, flt_fmt);
+			       static_cast<enum mat5_data_type> (type), flt_fmt);
 
 	if (! is || error_state)
 	  {
 	    error ("load: reading matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
 	is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
@@ -889,17 +888,17 @@ read_mat5_binary_element (std::istream& 
 	    if (read_mat5_tag (is, swap, type, len))
 	      {
 		error ("load: reading matrix data for `%s'", retval.c_str ());
 		goto data_read_error;
 	      }
 
 	    n = im.length ();
 	    read_mat5_binary_data (is, im.fortran_vec (), n, swap,
-				   (enum mat5_data_type) type, flt_fmt);
+				   static_cast<enum mat5_data_type> (type), flt_fmt);
 
 	    if (! is || error_state)
 	      {
 		error ("load: reading imaginary matrix data for `%s'",
 		       retval.c_str ());
 		goto data_read_error;
 	      }
 
@@ -972,18 +971,18 @@ read_mat5_binary_element (std::istream& 
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet)
 {
   TWO_BYTE_INT version=0, magic=0;
 
   is.seekg (124, std::ios::beg);
-  is.read (X_CAST (char *, &version), 2);
-  is.read (X_CAST (char *, &magic), 2);
+  is.read (reinterpret_cast<char *> (&version), 2);
+  is.read (reinterpret_cast<char *> (&magic), 2);
 
   if (magic == 0x4d49)
     swap = 0;
   else if (magic == 0x494d)
     swap = 1;
   else
     {
       if (! quiet)
@@ -1006,22 +1005,22 @@ write_mat5_tag (std::ostream& is, int ty
 {
   FOUR_BYTE_INT temp;
 
   if (bytes <= 4)
     temp = (bytes << 16) + type;
   else
     {
       temp = type;
-      if (! is.write ((char *)&temp, 4))
+      if (! is.write (reinterpret_cast<char *> (&temp), 4))
 	goto data_write_error;
       temp = bytes;
     }
 
-  if (! is.write ((char *)&temp, 4))
+  if (! is.write (reinterpret_cast<char *> (&temp), 4))
     goto data_write_error;
 
   return 0;
 
  data_write_error:
   return 1;
 }
 
@@ -1036,24 +1035,24 @@ write_mat5_array (std::ostream& os, cons
   mat5_data_type mst;
   int size;
   unsigned len;
   const double *data = m.data ();
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
-#define MAT5_DO_WRITE(TYPE, data, count, stream)			\
-  do									\
-    {									\
-      OCTAVE_LOCAL_BUFFER (TYPE, ptr, count);                           \
-      for (int i = 0; i < count; i++)					\
-        ptr[i] = X_CAST (TYPE, data[i]);				\
-      stream.write (X_CAST (char *, ptr), count * sizeof (TYPE));	\
-    }									\
+#define MAT5_DO_WRITE(TYPE, data, count, stream) \
+  do \
+    { \
+      OCTAVE_LOCAL_BUFFER (TYPE, ptr, count); \
+      for (int i = 0; i < count; i++) \
+        ptr[i] = static_cast<TYPE> (data[i]); \
+      stream.write (reinterpret_cast<char *> (ptr), count * sizeof (TYPE)); \
+    } \
   while (0)
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
@@ -1122,17 +1121,17 @@ write_mat5_array (std::ostream& os, cons
 	break;
 #endif
 
       case LS_FLOAT:
 	MAT5_DO_WRITE (float, data, nel, os);
 	break;
 
       case LS_DOUBLE: // No conversion necessary.
-	os.write (X_CAST (char *, data), len);
+	os.write (reinterpret_cast<const char *> (data), len);
 	break;
 
       default:
 	(*current_liboctave_error_handler)
 	  ("unrecognized data format requested");
 	break;
       }
   }
@@ -1181,17 +1180,17 @@ write_mat5_integer_data (std::ostream& o
       mst = miINT64;
       size = - size;
       break;
     }
 
   len = nel*size;
   write_mat5_tag (os, mst, len);
 
-  os.write (X_CAST(char *, m), len);
+  os.write (reinterpret_cast<const char *> (m), len);
 
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
@@ -1480,20 +1479,20 @@ save_mat5_binary_element (std::ostream& 
 	  OSSTREAM_FREEZE (buf);
       
 	  // destLen must be at least 0.1% larger than source buffer 
 	  // + 12 bytes. Reality is it must be larger again than that.
 	  uLongf srcLen = OSSTREAM_STR (buf).length ();
 	  uLongf destLen = srcLen * 101 / 100 + 12; 
 	  OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
-	  if (compress (X_CAST (Bytef *, out_buf), &destLen, 
-			X_CAST (Bytef *, OSSTREAM_C_STR (buf)), srcLen) == Z_OK)
+	  if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen, 
+			reinterpret_cast<const Bytef *> (OSSTREAM_C_STR (buf)), srcLen) == Z_OK)
 	    {
-	      write_mat5_tag (os, miCOMPRESSED, X_CAST(int, destLen)); 
+	      write_mat5_tag (os, miCOMPRESSED, static_cast<int> (destLen)); 
 	      os.write (out_buf, destLen);
 	    }
 	  else
 	    {
 	      error ("save: error compressing data element");
 	      ret = false;
 	    }
 	}
@@ -1564,30 +1563,30 @@ save_mat5_binary_element (std::ostream& 
   else if (tc.is_cell ())
     flags |= mxCELL_CLASS;
   else
     {
       gripe_wrong_type_arg ("save", tc, false);
       goto error_cleanup;
     }
 
-  os.write ((char *)&flags, 4);
-  os.write ((char *)&nnz, 4);
+  os.write (reinterpret_cast<char *> (&flags), 4);
+  os.write (reinterpret_cast<char *> (&nnz), 4);
 
   {
     dim_vector dv = tc.dims ();
     int nd = tc.ndims ();
     int dim_len = 4*nd;
 
     write_mat5_tag (os, miINT32, dim_len);
 
     for (int i = 0; i < nd; i++)
       {
 	FOUR_BYTE_INT n = dv(i);
-	os.write ((char *)&n, 4);
+	os.write (reinterpret_cast<char *> (&n), 4);
       }
 
     if (PAD (dim_len) > dim_len)
       {
 	static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
 	os.write (buf, PAD (dim_len) - dim_len);
       }
   }
@@ -1623,20 +1622,20 @@ save_mat5_binary_element (std::ostream& 
       for (int i = 0; i < nr; i++)
 	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 
 	  for (int j = 0; j < nc; j++)
 	    buf[j*nr+i] = *s++ & 0x00FF;
 	}
-      os.write ((char *)buf, nr*nc*2);
+      os.write (reinterpret_cast<char *> (buf), nr*nc*2);
       
       if (paddedlength > len)
-	os.write ((char *)buf, paddedlength - len);
+	os.write (reinterpret_cast<char *> (buf), paddedlength - len);
     }
   else if (cname == "sparse")
     {
       if (tc.is_complex_type ())
 	{
 	  SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 	  int nc = m.cols ();
 
@@ -1757,17 +1756,17 @@ save_mat5_binary_element (std::ostream& 
 	char buf[64];
 	FOUR_BYTE_INT maxfieldnamelength = max_namelen + 1;
 	int fieldcnt = 0;
 
 	for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
 	  fieldcnt++;
 
 	write_mat5_tag (os, miINT32, 4);
-	os.write ((char *)&maxfieldnamelength, 4);
+	os.write (reinterpret_cast<char *> (&maxfieldnamelength), 4);
 	write_mat5_tag (os, miINT8, fieldcnt*maxfieldnamelength);
 
 	for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
 	  {
 	    // write the name of each element
 	    std::string tstr = m.key (i);
 	    memset (buf, 0, max_namelen + 1);
 	    strncpy (buf, tstr.c_str (), max_namelen); // only 31 or 63 char names permitted
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -145,50 +145,50 @@ read_binary_data (std::istream& is, bool
   FOUR_BYTE_INT name_len = 0;
   FOUR_BYTE_INT doc_len = 0;
 
   doc.resize (0);
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another name should not result in an error.
 
-  is.read (X_CAST (char *, &name_len), 4);
+  is.read (reinterpret_cast<char *> (&name_len), 4);
   if (! is)
     return retval;
   if (swap)
     swap_bytes<4> (&name_len);
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, name_len+1);
     name[name_len] = '\0';
-    if (! is.read (X_CAST (char *, name), name_len))
+    if (! is.read (reinterpret_cast<char *> (name), name_len))
       goto data_read_error;
     retval = name;
   }
 
-  is.read (X_CAST (char *, &doc_len), 4);
+  is.read (reinterpret_cast<char *> (&doc_len), 4);
   if (! is)
     goto data_read_error;
   if (swap)
     swap_bytes<4> (&doc_len);
 
   {
     OCTAVE_LOCAL_BUFFER (char, tdoc, doc_len+1);
     tdoc[doc_len] = '\0';
-    if (! is.read (X_CAST (char *, tdoc), doc_len))
+    if (! is.read (reinterpret_cast<char *> (tdoc), doc_len))
       goto data_read_error;
     doc = tdoc;
   }
 
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     goto data_read_error;
   global = tmp ? 1 : 0;
 
   tmp = 0;
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     goto data_read_error;
 
   // All cases except 255 kept for backwards compatibility
   switch (tmp)
     {
     case 1:
       tc = octave_value_typeinfo::lookup_type ("scalar");
       break;
@@ -206,22 +206,22 @@ read_binary_data (std::istream& is, bool
       break;
 
     case 5:
       {
 	// XXX FIXME XXXX
 	// This is cruft, since its for a save type that is old. Maybe
 	// this is taking backward compatability too far!!
 	FOUR_BYTE_INT len;
-	if (! is.read (X_CAST (char *, &len), 4))
+	if (! is.read (reinterpret_cast<char *> (&len), 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_bytes<4> (&len);
 	OCTAVE_LOCAL_BUFFER (char, s, len+1);
-	if (! is.read (X_CAST (char *, s), len))
+	if (! is.read (reinterpret_cast<char *> (s), len))
 	  goto data_read_error;
 	s[len] = '\0';
 	tc = s;
 
 	// Early return, since don't want rest of this function
 	return retval;
       }
       break;
@@ -233,22 +233,22 @@ read_binary_data (std::istream& is, bool
     case 7:
       tc = octave_value_typeinfo::lookup_type ("string");
       break;
 
     case 255:
       {
 	// Read the saved variable type
 	FOUR_BYTE_INT len;
-	if (! is.read (X_CAST (char *, &len), 4))
+	if (! is.read (reinterpret_cast<char *> (&len), 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_bytes<4> (&len);
 	OCTAVE_LOCAL_BUFFER (char, s, len+1);
-	if (! is.read (X_CAST (char *, s), len))
+	if (! is.read (s, len))
 	  goto data_read_error;
 	s[len] = '\0';
 	std::string typ = s;
 	tc = octave_value_typeinfo::lookup_type (typ);
       }
       break;
     default:
       goto data_read_error;
@@ -270,39 +270,39 @@ read_binary_data (std::istream& is, bool
 
 bool
 save_binary_data (std::ostream& os, const octave_value& tc,
 		  const std::string& name, const std::string& doc,
 		  bool mark_as_global, bool save_as_floats) 
 {
   FOUR_BYTE_INT name_len = name.length ();
 
-  os.write (X_CAST (char *, &name_len), 4);
+  os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name;
 
   FOUR_BYTE_INT doc_len = doc.length ();
 
-  os.write (X_CAST (char *, &doc_len), 4);
+  os.write (reinterpret_cast<char *> (&doc_len), 4);
   os << doc;
 
   unsigned char tmp;
 
   tmp = mark_as_global;
-  os.write (X_CAST (char *, &tmp), 1);
+  os.write (reinterpret_cast<char *> (&tmp), 1);
 
   // 255 flags the new binary format
   tmp = 255;
-  os.write (X_CAST (char *, &tmp), 1);
+  os.write (reinterpret_cast<char *> (&tmp), 1);
 
   // Write the string corresponding to the octave_value type
   std::string typ = tc.type_name ();
   FOUR_BYTE_INT len = typ.length ();
-  os.write (X_CAST (char *, &len), 4);
+  os.write (reinterpret_cast<char *> (&len), 4);
   const char *btmp = typ.data ();
-  os.write (X_CAST (char *, btmp), len);
+  os.write (btmp, len);
       
   // The octave_value of tc is const. Make a copy...
   octave_value val = tc;
 
   // Call specific save function
   bool success = val.save_binary (os, save_as_floats);
 
   return (os && success);
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -116,17 +116,17 @@ static int
 xisxdigit (int c)
 {
   return isxdigit (c);
 }
 
 static int
 xtoascii (int c)
 {
-  return toascii ((int) ((unsigned char) c));
+  return toascii (c);
 }
 
 static int
 xtolower (int c)
 {
   return tolower (c);
 }
 
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -236,17 +236,17 @@ octave_procbuf::close (void)
 static int
 kluge_procbuf_delay (void)
 {
   double val;
   if (builtin_real_scalar_variable ("__kluge_procbuf_delay__", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
+      if (ival >= 0 && static_cast<double> (ival) == val)
 	{
 	  Vkluge_procbuf_delay = ival;
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("__kluge_procbuf_delay__");
   return -1;
 }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -283,17 +283,17 @@ expand_char_class (const std::string& s)
 
   size_t i = 0;
 
   while (i < len)
     {
       unsigned char c = s[i++];
 
       if (c == '-' && i > 1 && i < len
-	  && (unsigned char) s[i-2] <= (unsigned char) s[i])
+	  && static_cast<unsigned char> (s[i-2]) <= static_cast<unsigned char> (s[i]))
 	{
 	  // Add all characters from the range except the first (we
 	  // already added it below).
 
 	  for (c = s[i-2]+1; c < s[i]; c++)
 	    retval += c;
 	}
       else
@@ -985,24 +985,24 @@ octave_base_stream::do_gets (octave_idx_
 
       while (is && (c = is.get ()) != EOF)
 	{
 	  char_count++;
 
 	  if (c == '\n')
 	    {
 	      if (! strip_newline)
-		buf << (char) c;
+		buf << static_cast<char> (c);
 	      else
 		newline_stripped = 1;
 
 	      break;
 	    }
 	  else
-	    buf << (char) c;
+	    buf << static_cast<char> (c);
 
 	  if (max_len > 0 && char_count == max_len)
 	    break;
 	}
 
       if (is.good () || (is.eof () && char_count > 0))
 	{
 	  buf << OSSTREAM_ENDS;
@@ -1449,17 +1449,17 @@ do_scanf_conv (std::istream&, const scan
   int width = elt->width ? elt->width : 1; \
  \
   char *tbuf = new char[width + 1]; \
  \
   int c = EOF; \
   int n = 0; \
  \
   while (is && n < width && (c = is.get ()) != EOF) \
-    tbuf[n++] = (char) c; \
+    tbuf[n++] = static_cast<char> (c);		    \
  \
   tbuf[n] = '\0'; \
  \
   if (n > 0 && c == EOF) \
     is.clear (); \
  \
   std::string tmp = tbuf; \
  \
@@ -1543,23 +1543,23 @@ do_scanf_conv (std::istream&, const scan
 	  std::string char_class = elt->char_class; \
  \
 	  int c = EOF; \
  \
 	  if (elt->type == '[') \
 	    { \
 	      while (is && (c = is.get ()) != EOF \
 		     && char_class.find (c) != NPOS) \
-		buf << (char) c; \
+		buf << static_cast<char> (c);	     \
 	    } \
 	  else \
 	    { \
 	      while (is && (c = is.get ()) != EOF \
 		     && char_class.find (c) == NPOS) \
-		buf << (char) c; \
+		buf << static_cast<char> (c);		     \
 	    } \
  \
 	  if (c != EOF) \
 	    is.putback (c); \
  \
 	  buf << OSSTREAM_ENDS; \
 	  tmp = OSSTREAM_STR (buf); \
 	  OSSTREAM_FREEZE (buf); \
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -132,24 +132,24 @@ extern void install_ops (void);
 				   m2_nr, m2_nc); \
 	      return boolMatrix (); \
 	    } \
 	} \
     } \
   while (0)
 
 #define CAST_UNOP_ARG(t) \
-  t v = DYNAMIC_CAST (t, a)
+  t v = dynamic_cast<t> (a)
 
 #define CAST_BINOP_ARGS(t1, t2) \
-  t1 v1 = DYNAMIC_CAST (t1, a1); \
-  t2 v2 = DYNAMIC_CAST (t2, a2)
+  t1 v1 = dynamic_cast<t1> (a1);		\
+  t2 v2 = dynamic_cast<t2> (a2)
 
 #define CAST_CONV_ARG(t) \
-  t v = DYNAMIC_CAST (t, a)
+  t v = dynamic_cast<t> (a)
 
 #define ASSIGNOPDECL(name) \
   static octave_value \
   oct_assignop_ ## name (octave_base_value& a1, \
 			 const octave_value_list& idx, \
 			 const octave_base_value& a2)
 
 #define ASSIGNANYOPDECL(name) \
@@ -177,17 +177,17 @@ extern void install_ops (void);
  \
     v1.f (idx, v2.e ## _value ()); \
     return octave_value (); \
   }
 
 #define DEFASSIGNANYOP_FN(name, t1, f) \
   ASSIGNANYOPDECL (name) \
   { \
-    octave_ ## t1& v1 = DYNAMIC_CAST (octave_ ## t1&, a1); \
+    octave_ ## t1& v1 = dynamic_cast<octave_ ## t1&> (a1); \
  \
     v1.f (idx, a2); \
     return octave_value (); \
   }
 
 #define CONVDECL(name) \
   static octave_base_value * \
   oct_conv_ ## name (const octave_base_value& a)
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -130,49 +130,49 @@ bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
-  os.write (X_CAST(char *, this->matrix.data()), this->byte_size());
+  os.write (reinterpret_cast<const char *> (this->matrix.data()), this->byte_size());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
 					oct_mach_info::float_format )
 {
   FOUR_BYTE_INT mdims;
-  if (! is.read (X_CAST (char *, &mdims), 4))
+  if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   mdims = - mdims;
   FOUR_BYTE_INT di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
-      if (! is.read (X_CAST (char *, &di), 4))
+      if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&di);
       dv(i) = di;
     }
 
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
@@ -183,17 +183,17 @@ octave_base_int_matrix<T>::load_binary (
       mdims = 2;
       dv.resize (mdims);
       dv(1) = dv(0);
       dv(0) = 1;
     }
 
   T m (dv);
 
-  if (! is.read (X_CAST (char *, m.data ()), m.byte_size ()))
+  if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = dv.numel ();
       int bytes = nel / m.byte_size();
       for (int i = 0; i < nel; i++) 
 	switch (bytes)
@@ -349,27 +349,27 @@ octave_base_int_scalar<T>::load_ascii (s
     }
   return true;
 }
 
 template <class T>
 bool 
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
-  os.write (X_CAST(char *, &(this->scalar)), this->byte_size());
+  os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size());
   return true;
 }
 
 template <class T>
 bool 
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
 					oct_mach_info::float_format)
 {
   T tmp;
-  if (! is.read (X_CAST (char *, &tmp), this->byte_size()))
+  if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size()))
     return false;
 
   if (swap)
     switch (this->byte_size())
       {
       case 8:
 	swap_bytes<8> (&tmp);
 	break;
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -113,17 +113,17 @@ octave_base_sparse : public octave_base_
     { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   SparseType sparse_type (void) const { return typ; }
-  SparseType sparse_type (const SparseType& _typ) 
+  SparseType sparse_type (const SparseType& _typ) const
     { SparseType ret = typ; typ = _typ; return ret; }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_sparse_type (void) const { return true; }
 
@@ -147,17 +147,17 @@ octave_base_sparse : public octave_base_
 		 bool strip_nan_and_inf);
 
   bool load_ascii (std::istream& is);
 
 protected:
 
   T matrix;
 
-  SparseType typ;
+  mutable SparseType typ;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -282,21 +282,21 @@ octave_bool_matrix::save_binary (std::os
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
   bool *mtmp = m.fortran_vec ();
   octave_idx_type nel = m.nelem ();
   OCTAVE_LOCAL_BUFFER (char, htmp, nel);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -307,34 +307,34 @@ octave_bool_matrix::save_binary (std::os
   return true;
 }
 
 bool 
 octave_bool_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format /* fmt */)
 {
   FOUR_BYTE_INT mdims;
-  if (! is.read (X_CAST (char *, &mdims), 4))
+  if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   // mdims is negative for consistency with other matrices, where it is
   // negative to allow the positive value to be used for rows/cols for
   // backward compatibility
   mdims = - mdims;
   FOUR_BYTE_INT di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
-      if (! is.read (X_CAST (char *, &di), 4))
+      if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&di);
       dv(i) = di;
     }
   
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -205,41 +205,41 @@ octave_sparse_bool_matrix::save_binary (
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nz;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
   for (int i = 0; i < nc+1; i++)  
     {
       OCTAVE_QUIT;
       itmp = matrix.cidx(i);
-      os.write (X_CAST (char *, &itmp), 4);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   for (int i = 0; i < nz; i++) 
     {
       OCTAVE_QUIT;
       itmp = matrix.ridx(i); 
-      os.write (X_CAST (char *, &itmp), 4);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   for (int i = 0; i < nz; i++)
     htmp[i] = (matrix.data (i) ? 1 : 0);
    
   os.write (htmp, nz);
@@ -247,59 +247,59 @@ octave_sparse_bool_matrix::save_binary (
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
 					oct_mach_info::float_format /* fmt */)
 {
   FOUR_BYTE_INT nz, nc, nr, tmp;
-  if (! is.read (X_CAST (char *, &tmp), 4))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
     error("load: only 2D sparse matrices are supported");
     return false;
   }
 
-  if (! is.read (X_CAST (char *, &nr), 4))
+  if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nc), 4))
+  if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nz), 4))
+  if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
 		      static_cast<octave_idx_type> (nc),
 		      static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (error_state || ! is)
     return false;
@@ -334,55 +334,54 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, (hsize_t*) 0);
+  space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
-  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
-  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+		     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -392,17 +391,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+		     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -425,17 +424,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) itmp) >= 0;
+		     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -458,17 +457,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) itmp) >= 0;
+		     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -481,17 +480,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
       return false;
     }
   
   hbool_t htmp[m.nzmax ()];
   for (int i = 0; i < m.nzmax (); i++)
     htmp[i] = m.xdata(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) htmp) >= 0;
+		     H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
@@ -518,18 +517,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nr) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -539,18 +537,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nc) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
   
@@ -560,18 +557,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nz) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -601,18 +597,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -637,18 +632,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -674,18 +668,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hbool_t htmp[nz];
   bool retval = false;
-  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) htmp) >= 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0) 
     {
       retval = true;
 
       for (int i = 0; i < nz; i++)
 	m.xdata(i) = htmp[i];
 
       matrix = m;
     }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -157,27 +157,27 @@ octave_bool::load_ascii (std::istream& i
 
   return true;
 }
 
 bool 
 octave_bool::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = (scalar ? 1 : 0);
-  os.write (X_CAST (char *, &tmp), 1);
+  os.write (reinterpret_cast<char *> (&tmp), 1);
 
   return true;
 }
 
 bool 
 octave_bool::load_binary (std::istream& is, bool /* swap */,
 			  oct_mach_info::float_format /* fmt */)
 {
   char tmp;
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   scalar = (tmp ? 1 : 0);
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -618,21 +618,21 @@ bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
   FOUR_BYTE_INT di = - d.length();
-  os.write (X_CAST (char *, &di), 4);
+  os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
-      os.write (X_CAST (char *, &di), 4);
+      os.write (reinterpret_cast<char *> (&di), 4);
     }
   
   Cell tmp = cell_value ();
       
   for (octave_idx_type i = 0; i < d.numel (); i++)
     {
       octave_value o_val = tmp.elem (i);
 
@@ -648,31 +648,31 @@ octave_cell::save_binary (std::ostream& 
 }
 
 bool 
 octave_cell::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   bool success = true;
   FOUR_BYTE_INT mdims;
-  if (! is.read (X_CAST (char *, &mdims), 4))
+  if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   mdims = -mdims;
   FOUR_BYTE_INT di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
-      if (! is.read (X_CAST (char *, &di), 4))
+      if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&di);
       dv(i) = di;
     }
   
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -227,35 +227,35 @@ octave_complex::load_ascii (std::istream
 
   return true;
 }
 
 
 bool 
 octave_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
-  char tmp = (char) LS_DOUBLE;
-  os.write (X_CAST (char *, &tmp), 1);
+  char tmp = static_cast<char> (LS_DOUBLE);
+  os.write (reinterpret_cast<char *> (&tmp), 1);
   Complex ctmp = complex_value ();
-  os.write (X_CAST (char *, &ctmp), 16);
+  os.write (reinterpret_cast<char *> (&ctmp), 16);
 
   return true;
 }
 
 bool 
 octave_complex::load_binary (std::istream& is, bool swap,
 			     oct_mach_info::float_format fmt)
 {
   char tmp;
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   Complex ctmp;
-  read_doubles (is, X_CAST (double *, &ctmp), X_CAST (save_type, tmp), 2, 
-		swap, fmt);
+  read_doubles (is, reinterpret_cast<double *> (&ctmp),
+		static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -379,21 +379,21 @@ bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
 	{
@@ -407,41 +407,41 @@ octave_complex_matrix::save_binary (std:
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
 
   const Complex *mtmp = m.data ();
-  write_doubles (os, X_CAST (const double *, mtmp), st, 2 * d.numel ());
+  write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
 bool 
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   char tmp;
   FOUR_BYTE_INT mdims;
-  if (! is.read (X_CAST (char *, &mdims), 4))
+  if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       FOUR_BYTE_INT di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
-	  if (! is.read (X_CAST (char *, &di), 4))
+	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&di);
 	  dv(i) = di;
 	}
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
@@ -450,42 +450,42 @@ octave_complex_matrix::load_binary (std:
       if (mdims == 1)
 	{
 	  mdims = 2;
 	  dv.resize (mdims);
 	  dv(1) = dv(0);
 	  dv(0) = 1;
 	}
 
-      if (! is.read (X_CAST (char *, &tmp), 1))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
 
       ComplexNDArray m(dv);
       Complex *im = m.fortran_vec ();
-      read_doubles (is, X_CAST (double *, im), X_CAST (save_type, tmp), 
-		    2 * dv.numel (), swap, fmt);
+      read_doubles (is, reinterpret_cast<double *> (im),
+		    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   else
     {
       FOUR_BYTE_INT nr, nc;
       nr = mdims;
-      if (! is.read (X_CAST (char *, &nc), 4))
+      if (! is.read (reinterpret_cast<char *> (&nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
-      if (! is.read (X_CAST (char *, &tmp), 1))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
       ComplexMatrix m (nr, nc);
       Complex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
-      read_doubles (is, X_CAST (double *, im),
-		    X_CAST (save_type, tmp), 2*len, swap, fmt);
+      read_doubles (is, reinterpret_cast<double *> (im),
+		    static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -211,26 +211,26 @@ octave_sparse_complex_matrix::save_binar
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nz;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
@@ -246,92 +246,92 @@ octave_sparse_complex_matrix::save_binar
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
        OCTAVE_QUIT;
        itmp = matrix.cidx(i);
-       os.write (X_CAST (char *, &itmp), 4);
+       os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++) 
      {
        OCTAVE_QUIT;
        itmp = matrix.ridx(i); 
-       os.write (X_CAST (char *, &itmp), 4);
+       os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   write_doubles (os, X_CAST (const double *, matrix.data()), st, 2 * nz);
+   write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
 				   oct_mach_info::float_format fmt)
 {
   FOUR_BYTE_INT nz, nc, nr, tmp;
   char ctmp;
 
-  if (! is.read (X_CAST (char *, &tmp), 4))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
     error("load: only 2D sparse matrices are supported");
     return false;
   }
 
-  if (! is.read (X_CAST (char *, &nr), 4))
+  if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nc), 4))
+  if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nz), 4))
+  if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
 			 static_cast<octave_idx_type> (nc),
 			 static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
-  if (! is.read (X_CAST (char *, &ctmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
-  read_doubles (is, X_CAST(double *, m.data()), X_CAST (save_type, ctmp), 
-		2 * nz, swap, fmt);
+  read_doubles (is, reinterpret_cast<double *> (m.data ()),
+		static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
@@ -353,17 +353,17 @@ octave_sparse_complex_matrix::save_hdf5 
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, (hsize_t*) 0);
+  space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
@@ -371,17 +371,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+		     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -391,17 +391,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+		     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -411,17 +411,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) &tmp) >= 0;
+		     H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -444,17 +444,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) itmp) >= 0;
+		     H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -476,18 +476,17 @@ octave_sparse_complex_matrix::save_hdf5 
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) itmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -518,34 +517,33 @@ octave_sparse_complex_matrix::save_hdf5 
   hid_t type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, 
-			H5P_DEFAULT);
+  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, H5P_DEFAULT);
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   retval = false;
   if (complex_type_hid >= 0) 
     {
       Complex * ctmp = m.xdata ();
 
       retval = H5Dwrite (data_hid, complex_type_hid, H5S_ALL, H5S_ALL,
-			 H5P_DEFAULT, (void*) ctmp) >= 0;
+			 H5P_DEFAULT, ctmp) >= 0;
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
@@ -575,18 +573,17 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nr) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -596,18 +593,17 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nc) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
   
@@ -617,18 +613,17 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nz) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -658,18 +653,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -694,18 +688,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -743,18 +736,17 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   Complex *ctmp = m.xdata ();
   bool retval = false;
-  if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       (void *) ctmp) >= 0) 
+  if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT, ctmp) >= 0) 
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -213,51 +213,51 @@ octave_fcn_handle::load_ascii (std::istr
 
   return true;
 }
 
 bool
 octave_fcn_handle::save_binary (std::ostream& os, bool&)
 {
   FOUR_BYTE_INT tmp = nm.length ();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (nm.c_str (), nm.length ());
   if (nm == "@<anonymous>")
     {
       OSSTREAM buf;
       print_raw (buf, true);
       std::string stmp = OSSTREAM_STR (buf);
       OSSTREAM_FREEZE (buf);
       tmp = stmp.length ();
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
     }
   return true;
 }
 
 bool
 octave_fcn_handle::load_binary (std::istream& is, bool swap,
 				oct_mach_info::float_format)
 {
   FOUR_BYTE_INT tmp;
-  if (! is.read (X_CAST (char *, &tmp), 4))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
   if (swap)
     swap_bytes<4> (&tmp);
 
   OCTAVE_LOCAL_BUFFER (char, ctmp1, tmp+1);
   is.read (ctmp1, tmp);
   nm = std::string (ctmp1);
 
   if (! is)
     return false;
 
   if (nm == "@<anonymous>")
     {
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.read (ctmp2, tmp);
 
       int parse_status;
@@ -302,28 +302,27 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
     {
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
   hdims[0] = 0;
   hdims[1] = 0;
-  space_hid = H5Screate_simple (0 , hdims, (hsize_t*) 0);
+  space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT,
-				X_CAST (void *, nm.c_str ())) < 0)
+				H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -340,18 +339,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	{
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
       data_hid = H5Dcreate (group_hid, "fcn",  type_hid, space_hid,
 			    H5P_DEFAULT);
       if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				    H5P_DEFAULT,
-				    X_CAST (void *, stmp.c_str ())) < 0)
+				    H5P_DEFAULT, stmp.c_str ()) < 0)
 	{
 	  H5Sclose (space_hid);
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
 
       H5Dclose (data_hid);
@@ -417,18 +415,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
     }
 
   OCTAVE_LOCAL_BUFFER (char, nm_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       X_CAST (void *, nm_tmp)) < 0)
+  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, nm_tmp) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
@@ -478,18 +475,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 	}
 
       OCTAVE_LOCAL_BUFFER (char, fcn_tmp, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
-      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		   X_CAST (void *, fcn_tmp)) < 0)
+      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, fcn_tmp) < 0)
 	{
 	  H5Sclose (space_hid);
 	  H5Tclose (type_hid);
 	  H5Gclose (group_hid);
 	  return false;
 	}
       H5Dclose (data_hid);
       H5Tclose (st_id);
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -152,76 +152,76 @@ octave_fcn_inline::load_ascii (std::istr
   else
     return false;
 }
 
 bool
 octave_fcn_inline::save_binary (std::ostream& os, bool&)
 {
   FOUR_BYTE_INT tmp = ifargs.length ();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < ifargs.length (); i++)
     {
       tmp = ifargs(i).length ();
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (ifargs(i).c_str (), ifargs(i).length ());
     }
   tmp = nm.length ();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (nm.c_str (), nm.length ());
   tmp = iftext.length ();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (iftext.c_str (), iftext.length ());
   return true;
 }
 
 bool
 octave_fcn_inline::load_binary (std::istream& is, bool swap,
 				oct_mach_info::float_format)
 {
   FOUR_BYTE_INT nargs;
-  if (! is.read (X_CAST (char *, &nargs), 4))
+  if (! is.read (reinterpret_cast<char *> (&nargs), 4))
     return false;
   if (swap)
     swap_bytes<4> (&nargs);
 
   if (nargs < 1)
     return false;
   else
     {
       FOUR_BYTE_INT tmp;
       ifargs.resize (nargs);
       for (int i = 0; i < nargs; i++)
 	{
-	  if (! is.read (X_CAST (char *, &tmp), 4))
+	  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&tmp);
 
 	  OCTAVE_LOCAL_BUFFER (char, ctmp, tmp+1);
 	  is.read (ctmp, tmp);
 	  ifargs(i) = std::string (ctmp);
 
 	  if (! is)
 	    return false;
 	}
 
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp1, tmp+1);
       is.read (ctmp1, tmp);
       nm = std::string (ctmp1);
 
       if (! is)
 	return false;
 
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.read (ctmp2, tmp);
       iftext = std::string (ctmp2);
 
@@ -304,27 +304,27 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   H5Tset_size (type_hid, nm.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   hdims[0] = 0;
-  space_hid = H5Screate_simple (0 , hdims, (hsize_t*) 0);
+  space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT, (void*) nm.c_str ()) < 0)
+				H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Dclose (data_hid);
 
@@ -334,17 +334,17 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
     {
       H5Gclose (group_hid);
       return false;
     }
 
   data_hid = H5Dcreate (group_hid, "iftext",  type_hid, space_hid,
 			H5P_DEFAULT);
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
-				H5P_DEFAULT, (void*) iftext.c_str ()) < 0)
+				H5P_DEFAULT, iftext.c_str ()) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -444,18 +444,17 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
     }
 
   OCTAVE_LOCAL_BUFFER (char, nm_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       X_CAST (void *, nm_tmp)) < 0)
+  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, nm_tmp) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
@@ -503,18 +502,17 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
     }
 
   OCTAVE_LOCAL_BUFFER (char, iftext_tmp, slen);
 
   // create datatype for (null-terminated) string to read into:
   st_id = H5Tcopy (H5T_C_S1);
   H5Tset_size (st_id, slen);
 
-  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-	       X_CAST (void *, iftext_tmp)) < 0)
+  if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, iftext_tmp) < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
   H5Tclose (st_id);
   H5Dclose (data_hid);
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -613,17 +613,17 @@ octave_list::load_ascii (std::istream& i
 }
 
 bool 
 octave_list::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_value_list lst = list_value ();
 
   FOUR_BYTE_INT len = lst.length();
-  os.write (X_CAST (char *, &len), 4);
+  os.write (reinterpret_cast<char *> (&len), 4);
   
   for (int i = 0; i < lst.length (); i++)
     {
       // should we use lst.name_tags () to label the elements?
 
       OSSTREAM buf;
       buf << "_" << i << OSSTREAM_ENDS;
       std::string s = OSSTREAM_STR (buf);
@@ -637,20 +637,20 @@ octave_list::save_binary (std::ostream& 
 	return false;
     }
   
   return true;
 }
 
 bool 
 octave_list::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+			  oct_mach_info::float_format fmt)
 {
   FOUR_BYTE_INT len;
-  if (! is.read (X_CAST (char *, &len), 4))
+  if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       octave_value_list lst;
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -321,46 +321,46 @@ octave_range::load_ascii (std::istream& 
     }
 
   return true;
 }
 
 bool 
 octave_range::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
-  char tmp = (char) LS_DOUBLE;
-  os.write (X_CAST (char *, &tmp), 1);
+  char tmp = LS_DOUBLE;
+  os.write (reinterpret_cast<char *> (&tmp), 1);
   Range r = range_value ();
   double bas = r.base ();
   double lim = r.limit ();
   double inc = r.inc ();
-  os.write (X_CAST (char *, &bas), 8);
-  os.write (X_CAST (char *, &lim), 8);
-  os.write (X_CAST (char *, &inc), 8);
+  os.write (reinterpret_cast<char *> (&bas), 8);
+  os.write (reinterpret_cast<char *> (&lim), 8);
+  os.write (reinterpret_cast<char *> (&inc), 8);
 
   return true;
 }
 
 bool 
 octave_range::load_binary (std::istream& is, bool swap,
 			   oct_mach_info::float_format /* fmt */)
 {
   char tmp;
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   double bas, lim, inc;
-  if (! is.read (X_CAST (char *, &bas), 8))
+  if (! is.read (reinterpret_cast<char *> (&bas), 8))
     return false;
   if (swap)
     swap_bytes<8> (&bas);
-  if (! is.read (X_CAST (char *, &lim), 8))
+  if (! is.read (reinterpret_cast<char *> (&lim), 8))
     return false;
   if (swap)
     swap_bytes<8> (&lim);
-  if (! is.read (X_CAST (char *, &inc), 8))
+  if (! is.read (reinterpret_cast<char *> (&inc), 8))
     return false;
   if (swap)
     swap_bytes<8> (&inc);
   Range r (bas, lim, inc);
   range = r;
   return true;
 }
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -428,21 +428,21 @@ octave_matrix::save_binary (std::ostream
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
 	{
@@ -466,30 +466,30 @@ octave_matrix::save_binary (std::ostream
 }
 
 bool 
 octave_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   char tmp;
   FOUR_BYTE_INT mdims;
-  if (! is.read (X_CAST (char *, &mdims), 4))
+  if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
       FOUR_BYTE_INT di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
-	  if (! is.read (X_CAST (char *, &di), 4))
+	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&di);
 	  dv(i) = di;
 	}
 
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
@@ -498,40 +498,40 @@ octave_matrix::load_binary (std::istream
       if (mdims == 1)
 	{
 	  mdims = 2;
 	  dv.resize (mdims);
 	  dv(1) = dv(0);
 	  dv(0) = 1;
 	}
 
-      if (! is.read (X_CAST (char *, &tmp), 1))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
 
       NDArray m(dv);
       double *re = m.fortran_vec ();
-      read_doubles (is, re, X_CAST (save_type, tmp), dv.numel (), swap, fmt);
+      read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   else
     {
       FOUR_BYTE_INT nr, nc;
       nr = mdims;
-      if (! is.read (X_CAST (char *, &nc), 4))
+      if (! is.read (reinterpret_cast<char *> (&nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
-      if (! is.read (X_CAST (char *, &tmp), 1))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
       Matrix m (nr, nc);
       double *re = m.fortran_vec ();
       octave_idx_type len = nr * nc;
-      read_doubles (is, re, X_CAST (save_type, tmp), len, swap, fmt);
+      read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -256,26 +256,26 @@ octave_sparse_matrix::save_binary (std::
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nz;
-  os.write (X_CAST (char *, &itmp), 4);
+  os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
@@ -291,91 +291,91 @@ octave_sparse_matrix::save_binary (std::
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)  
      {
        OCTAVE_QUIT;
        itmp = matrix.cidx(i);
-       os.write (X_CAST (char *, &itmp), 4);
+       os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++) 
      {
        OCTAVE_QUIT;
        itmp = matrix.ridx(i); 
-       os.write (X_CAST (char *, &itmp), 4);
+       os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, matrix.data(), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
 				   oct_mach_info::float_format fmt)
 {
   FOUR_BYTE_INT nz, nc, nr, tmp;
   char ctmp;
 
-  if (! is.read (X_CAST (char *, &tmp), 4))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
     error("load: only 2D sparse matrices are supported");
     return false;
   }
 
-  if (! is.read (X_CAST (char *, &nr), 4))
+  if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nc), 4))
+  if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
-  if (! is.read (X_CAST (char *, &nz), 4))
+  if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
   if (swap)
     {
       swap_bytes<4> (&nr);
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
 		  static_cast<octave_idx_type> (nc),
 		  static_cast<octave_idx_type> (nz));
 
   for (int i = 0; i < nc+1; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.xcidx(i) = tmp;
     }
 
   for (int i = 0; i < nz; i++) 
     {
       OCTAVE_QUIT;
-      if (! is.read (X_CAST (char *, &tmp), 4))
+      if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
       m.xridx(i) = tmp;
     }
 
-  if (! is.read (X_CAST (char *, &ctmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
-  read_doubles (is, m.xdata (), X_CAST (save_type, ctmp), nz, swap, fmt);
+  read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
@@ -397,17 +397,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, (hsize_t*) 0);
+  space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
     }
 
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
 			H5P_DEFAULT);
@@ -415,17 +415,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     (void*) &tmp) >= 0;
+		     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -435,17 +435,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     (void*) &tmp) >= 0;
+		     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -455,17 +455,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     (void*) &tmp) >= 0;
+		     &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -488,17 +488,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     (void*) itmp) >= 0;
+		     itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
@@ -521,17 +521,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-		     (void*) itmp) >= 0;
+		     itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -565,55 +565,55 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
-		     H5P_DEFAULT, (void*) dtmp) >= 0;
+		     H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::load_hdf5 (hid_t loc_id, const char *name,
-				      bool /* have_h5giterate_bug */)
+				 bool /* have_h5giterate_bug */)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
   
   group_hid = H5Gopen (loc_id, name);
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0) return false;
 
   data_hid = H5Dopen (group_hid, "nr");
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nr) < 0)
+	       H5P_DEFAULT, &nr) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -624,17 +624,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nc) < 0)
+	       H5P_DEFAULT, &nc) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
   
@@ -645,17 +645,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   if (rank != 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) &nz) < 0)
+	       H5P_DEFAULT, &nz) < 0)
     { 
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -686,17 +686,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+	       H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -721,17 +721,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) itmp) < 0) 
+	       H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -756,17 +756,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, (void *) dtmp) < 0) 
+	       H5P_DEFAULT, dtmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -201,34 +201,34 @@ octave_scalar::load_ascii (std::istream&
     }
 
   return true;
 }
 
 bool 
 octave_scalar::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
-  char tmp = (char) LS_DOUBLE;
-  os.write (X_CAST (char *, &tmp), 1);
+  char tmp = LS_DOUBLE;
+  os.write (reinterpret_cast<char *> (&tmp), 1);
   double dtmp = double_value ();
-  os.write (X_CAST (char *, &dtmp), 8);
+  os.write (reinterpret_cast<char *> (&dtmp), 8);
 
   return true;
 }
 
 bool 
 octave_scalar::load_binary (std::istream& is, bool swap,
 			    oct_mach_info::float_format fmt)
 {
   char tmp;
-  if (! is.read (X_CAST (char *, &tmp), 1))
+  if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   double dtmp;
-  read_doubles (is, &dtmp, X_CAST (save_type, tmp), 1, swap, fmt);
+  read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = dtmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -282,17 +282,17 @@ octave_char_matrix_str::save_ascii (std:
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << d.length () << "\n";
       for (int i=0; i < d.length (); i++)
 	os << " " << d (i);
       os << "\n";
-      os.write (X_CAST (char *, tmp.fortran_vec ()), d.numel ());
+      os.write (tmp.fortran_vec (), d.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatiability. Makes load_ascii much more complex!!
       charMatrix chm = char_matrix_value ();
       octave_idx_type elements = chm.rows ();
@@ -300,17 +300,17 @@ octave_char_matrix_str::save_ascii (std:
       for (octave_idx_type i = 0; i < elements; i++)
 	{
 	  unsigned len = chm.cols ();
 	  os << "# length: " << len << "\n";
 	  std::string tstr = chm.row_as_string (i, false, true);
 	  const char *tmp = tstr.data ();
 	  if (tstr.length () > len)
 	    panic_impossible ();
-	  os.write (X_CAST (char *, tmp), len);
+	  os.write (tmp, len);
 	  os << "\n";
 	}
     }
 
   return true;
 }
 
 bool 
@@ -376,17 +376,17 @@ octave_char_matrix_str::load_ascii (std:
 	      for (int i = 0; i < elements; i++)
 		{
 		  int len;
 		  if (extract_keyword (is, "length", len) && len >= 0)
 		    {
 		      OCTAVE_LOCAL_BUFFER (char, tmp, len+1);
 		  
 		      if (len > 0 && ! 
-			  is.read (X_CAST (char *, tmp), len))
+			  is.read (tmp, len))
 			{
 			  error ("load: failed to load string constant");
 			  success = false;
 			  break;
 			}
 		      else
 			{
 			  tmp [len] = '\0';
@@ -421,17 +421,17 @@ octave_char_matrix_str::load_ascii (std:
       
 	  if (len >= 0)
 	    {
 	      // This is cruft for backward compatiability, 
 	      // but relatively harmless.
 
 	      OCTAVE_LOCAL_BUFFER (char, tmp, len+1);
 
-	      if (len > 0 && ! is.read (X_CAST (char *, tmp), len))
+	      if (len > 0 && ! is.read (tmp, len))
 		{
 		  error ("load: failed to load string constant");
 		}
 	      else
 		{
 		  tmp [len] = '\0';
 		  
 		  if (is)
@@ -458,48 +458,48 @@ octave_char_matrix_str::save_binary (std
 				     bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   FOUR_BYTE_INT tmp = - d.length();
-  os.write (X_CAST (char *, &tmp), 4);
+  os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
-      os.write (X_CAST (char *, &tmp), 4);
+      os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
   os.write (m.fortran_vec (), d.numel ());
   return true;
 }
 
 bool 
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
 				     oct_mach_info::float_format /* fmt */)
 {
   FOUR_BYTE_INT elements;
-  if (! is.read (X_CAST (char *, &elements), 4))
+  if (! is.read (reinterpret_cast<char *> (&elements), 4))
     return false;
   if (swap)
     swap_bytes<4> (&elements);
 
   if (elements < 0)
     {
       FOUR_BYTE_INT mdims = - elements;
       FOUR_BYTE_INT di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
-	  if (! is.read (X_CAST (char *, &di), 4))
+	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&di);
 	  dv(i) = di;
 	}
       
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
@@ -523,22 +523,22 @@ octave_char_matrix_str::load_binary (std
     }
   else
     {
       charMatrix chm (elements, 0);
       int max_len = 0;
       for (int i = 0; i < elements; i++)
 	{
 	  FOUR_BYTE_INT len;
-	  if (! is.read (X_CAST (char *, &len), 4))
+	  if (! is.read (reinterpret_cast<char *> (&len), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&len);
 	  OCTAVE_LOCAL_BUFFER (char, btmp, len+1);
-	  if (! is.read (X_CAST (char *, btmp), len))
+	  if (! is.read (reinterpret_cast<char *> (btmp), len))
 	    return false;
 	  if (len > max_len)
 	    {
 	      max_len = len;
 	      chm.resize (elements, max_len, 0);
 	    }
 	  btmp [len] = '\0';
 	  chm.insert (btmp, i, 0);
@@ -675,18 +675,17 @@ octave_char_matrix_str::load_hdf5 (hid_t
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (char, s, slen);
 	      // create datatype for (null-terminated) string
 	      // to read into:
 	      hid_t st_id = H5Tcopy (H5T_C_S1);
 	      H5Tset_size (st_id, slen);
-	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, 
-			   H5P_DEFAULT, (void *) s) < 0)
+	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
 		{
 		  H5Tclose (st_id);
 		  H5Tclose (type_hid);
 		  H5Sclose (space_hid);
 		  H5Dclose (data_hid);
 		  return false;
 		}
 
@@ -720,18 +719,17 @@ octave_char_matrix_str::load_hdf5 (hid_t
 	  
 	      OCTAVE_LOCAL_BUFFER (char, s, elements * slen);
 
 	      // create datatype for (null-terminated) string
 	      // to read into:
 	      hid_t st_id = H5Tcopy (H5T_C_S1);
 	      H5Tset_size (st_id, slen);
 
-	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, 
-			   H5P_DEFAULT, (void *) s) < 0)
+	      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
 		{
 		  H5Tclose (st_id);
 		  H5Tclose (type_hid);
 		  H5Sclose (space_hid);
 		  H5Dclose (data_hid);
 		  return false;
 		}
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1103,17 +1103,17 @@ octave_struct::load_ascii (std::istream&
 }
 
 bool 
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   Octave_map m = map_value ();
 
   FOUR_BYTE_INT len = m.length();
-  os.write (X_CAST (char *, &len), 4);
+  os.write (reinterpret_cast<char *> (&len), 4);
   
   Octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
       
@@ -1123,21 +1123,21 @@ octave_struct::save_binary (std::ostream
       i++;
     }
 
   return true;
 }
 
 bool 
 octave_struct::load_binary (std::istream& is, bool swap,
-				 oct_mach_info::float_format fmt)
+			    oct_mach_info::float_format fmt)
 {
   bool success = true;
   FOUR_BYTE_INT len;
-  if (! is.read (X_CAST (char *, &len), 4))
+  if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       Octave_map m (map);
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -149,30 +149,25 @@ public:
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
     : num_types (0), types (init_tab_sz, std::string ()),
       vals (init_tab_sz),
-      unary_ops (octave_value::num_unary_ops, init_tab_sz,
-		 (unary_op_fcn) 0),
-      non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz,
-			   (non_const_unary_op_fcn) 0),
-      binary_ops (octave_value::num_binary_ops, init_tab_sz,
-		  init_tab_sz, (binary_op_fcn) 0),
-      cat_ops (init_tab_sz, init_tab_sz, (cat_op_fcn) 0),
-      assign_ops (octave_value::num_assign_ops, init_tab_sz,
-		  init_tab_sz, (assign_op_fcn) 0),
-      assignany_ops (octave_value::num_assign_ops, init_tab_sz,
-		     (assignany_op_fcn) 0),
+      unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
+      non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz, 0),
+      binary_ops (octave_value::num_binary_ops, init_tab_sz, init_tab_sz, 0),
+      cat_ops (init_tab_sz, init_tab_sz, 0),
+      assign_ops (octave_value::num_assign_ops, init_tab_sz, init_tab_sz, 0),
+      assignany_ops (octave_value::num_assign_ops, init_tab_sz, 0),
       pref_assign_conv (init_tab_sz, init_tab_sz, -1),
-      type_conv_ops (init_tab_sz, init_tab_sz, (octave_base_value::type_conv_fcn) 0),
-      widening_ops (init_tab_sz, init_tab_sz, (octave_base_value::type_conv_fcn) 0)  { }
+      type_conv_ops (init_tab_sz, init_tab_sz, 0),
+      widening_ops (init_tab_sz, init_tab_sz, 0)  { }
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
   int num_types;
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3108,17 +3108,17 @@ gobble_leading_white_space (FILE *ffile,
 	    begin_comment = false;
 	}
 
       if (in_comment)
 	{
 	  if (! have_help_text)
 	    {
 	      first_comments_seen = true;
-	      help_txt += (char) c;
+	      help_txt += static_cast<char> (c);
 	    }
 
 	  if (c == '\n')
 	    {
 	      if (update_pos)
 		{
 		  input_line_number++;
 		  current_input_column = 0;
@@ -3208,17 +3208,17 @@ get_help_from_file (const std::string& n
   if (! file.empty ())
     {
       symbol_found = true;
 
       FILE *fptr = fopen (file.c_str (), "r");
 
       if (fptr)
 	{
-	  unwind_protect::add (safe_fclose, (void *) fptr);
+	  unwind_protect::add (safe_fclose, fptr);
 
 	  retval = gobble_leading_white_space (fptr, true, true, false);
 
 	  if (! retval.empty () && include_file_info)
 	    retval = nm + " is the file: " + file + "\n\n" + retval;
 
 	  unwind_protect::run ();
 	}
@@ -3325,18 +3325,18 @@ parse_fcn_file (const std::string& ff, b
 	  Vsaving_history = false;
 	  reading_fcn_file = true;
 	  get_input_from_eval_string = false;
 	  parser_end_of_input = false;
 
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
-	  unwind_protect::add (restore_input_buffer, (void *) old_buf);
-	  unwind_protect::add (delete_input_buffer, (void *) new_buf);
+	  unwind_protect::add (restore_input_buffer, old_buf);
+	  unwind_protect::add (delete_input_buffer, new_buf);
 
 	  switch_to_buffer (new_buf);
 
 	  unwind_protect_ptr (curr_sym_tab);
 
 	  reset_parser ();
 
 	  std::string txt
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -166,17 +166,17 @@ tree_argument_list::convert_to_const_vec
 		       && object
 		       && ! (object->is_function ()
 			     || object->is_function_handle ()));
 
   if (stash_object)
     {
       unwind_protect::begin_frame ("convert_to_const_vector");
 
-      unwind_protect_ptr (indexed_object);
+      unwind_protect_const_ptr (indexed_object);
 
       indexed_object = object;
     }
 
   int len = length ();
 
   // XXX FIXME XXX -- would be nice to know in advance how largs args
   // needs to be even when we have a list containing an all_va_args
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -1183,17 +1183,17 @@ tree_print_code::print_comment_elt (cons
 	      indent ();
 
 	      os << "##";
 
 	      if (! (isspace (c) || c == '!'))
 		os << " ";
 	    }
 
-	  os << (char) c;
+	  os << static_cast<char> (c);
 
 	  prev_char_was_newline = false;
 	}
     }
 
   if (printed_something && ! beginning_of_line)
     newline ();
 }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1205,18 +1205,18 @@ symbol_table::name_list (const string_ve
     names.qsort ();
 
   return names;
 }
 
 static int
 maybe_list_cmp_fcn (const void *a_arg, const void *b_arg)
 {
-  const symbol_record *a = *(X_CAST (const symbol_record **, a_arg));
-  const symbol_record *b = *(X_CAST (const symbol_record **, b_arg));
+  const symbol_record *a = static_cast<const symbol_record *> (a_arg);
+  const symbol_record *b = static_cast<const symbol_record *> (b_arg);
 
   std::string a_nm = a->name ();
   std::string b_nm = b->name ();
 
   return a_nm.compare (b_nm);
 }
 
 void
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -74,17 +74,17 @@ private:
       void *gen_ptr;
       void **ptr_to_gen_ptr;
     };
 
   union
     {
       bool bool_value;
       int int_value;
-      const std::string *str_value;
+      std::string *str_value;
       void *gen_ptr_value;
     };
 
   var_type type_tag;
 
   size_t size;
 };
 
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -117,17 +117,22 @@ public:
 
 #define unwind_protect_int(i) \
   unwind_protect::save_int (&(i), (i))
 
 #define unwind_protect_str(s) \
   unwind_protect::save_str (&(s), (s))
 
 #define unwind_protect_ptr(p) \
-  unwind_protect::save_ptr (X_CAST (void **, &(p)), X_CAST (void *, (p)))
+  unwind_protect::save_ptr (reinterpret_cast<void **> (&(p)), \
+                            reinterpret_cast<void *> (p))
+
+#define unwind_protect_const_ptr(p) \
+  unwind_protect::save_ptr (const_cast<void **> (reinterpret_cast<const void **> (&(p))), \
+                            const_cast<void *> (reinterpret_cast<const void *> (p)))
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1458,18 +1458,18 @@ Set the documentation string for @var{sy
 }
 
 // XXX FIXME XXX -- this function is duplicated in symtab.cc with the
 // name maybe_list_cmp_fcn.
 
 static int
 symbol_record_name_compare (const void *a_arg, const void *b_arg)
 {
-  const symbol_record *a = *(X_CAST (const symbol_record **, a_arg));
-  const symbol_record *b = *(X_CAST (const symbol_record **, b_arg));
+  const symbol_record *a = static_cast<const symbol_record *> (a_arg);
+  const symbol_record *b = static_cast<const symbol_record *> (b_arg);
 
   std::string a_nm = a->name ();
   std::string b_nm = b->name ();
 
   return a_nm.compare (b_nm);
 }
 
 static octave_value
