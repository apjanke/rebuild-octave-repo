# HG changeset patch
# User Rik <rik@octave.org>
# Date 1430801457 25200
#      Mon May 04 21:50:57 2015 -0700
# Branch stable
# Node ID f1d0f506ee781472899d16f06f8a6a9ddd8187c6
# Parent  df437a52bcafee34a46b23f44191d352e83c6bb5
doc: Update more docstrings to have one sentence summary as first line.
Reviewed optimization, polynomial, signal script directories.

* scripts/optimization/fminbnd.m, scripts/optimization/fminsearch.m,
scripts/optimization/fminunc.m, scripts/optimization/fsolve.m,
scripts/optimization/fzero.m, scripts/optimization/glpk.m,
scripts/optimization/lsqnonneg.m, scripts/optimization/pqpnonneg.m,
scripts/optimization/qp.m, scripts/optimization/sqp.m,
scripts/polynomial/compan.m, scripts/polynomial/mkpp.m,
scripts/polynomial/mpoles.m, scripts/polynomial/pchip.m,
scripts/polynomial/poly.m, scripts/polynomial/polyaffine.m,
scripts/polynomial/polyder.m, scripts/polynomial/polyeig.m,
scripts/polynomial/polyfit.m, scripts/polynomial/polygcd.m,
scripts/polynomial/polyint.m, scripts/polynomial/polyout.m,
scripts/polynomial/polyval.m, scripts/polynomial/ppder.m,
scripts/polynomial/ppint.m, scripts/polynomial/ppjumps.m,
scripts/polynomial/ppval.m, scripts/polynomial/residue.m,
scripts/polynomial/roots.m, scripts/polynomial/spline.m,
scripts/polynomial/splinefit.m, scripts/polynomial/unmkpp.m,
scripts/signal/arch_fit.m, scripts/signal/arch_rnd.m,
scripts/signal/arma_rnd.m, scripts/signal/autoreg_matrix.m,
scripts/signal/bartlett.m, scripts/signal/blackman.m, scripts/signal/detrend.m,
scripts/signal/diffpara.m, scripts/signal/durbinlevinson.m,
scripts/signal/fftconv.m, scripts/signal/fftfilt.m, scripts/signal/fftshift.m,
scripts/signal/filter2.m, scripts/signal/freqz.m, scripts/signal/hamming.m,
scripts/signal/hanning.m, scripts/signal/hurst.m, scripts/signal/ifftshift.m,
scripts/signal/periodogram.m, scripts/signal/sinc.m, scripts/signal/sinetone.m,
scripts/signal/sinewave.m, scripts/signal/spectral_adf.m,
scripts/signal/spectral_xdf.m, scripts/signal/spencer.m, scripts/signal/stft.m,
scripts/signal/synthesis.m, scripts/signal/unwrap.m,
scripts/signal/yulewalker.m:
Update more docstrings to have one sentence summary as first line.

diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -24,36 +24,37 @@
 ##
 ## @var{fun} should be a function handle or name.  @var{a}, @var{b} specify a
 ## starting interval.  @var{options} is a structure specifying additional
 ## options.  Currently, @code{fminbnd} recognizes these options:
 ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
 ## @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.  For a description of these
 ## options, see @ref{XREFoptimset,,optimset}.
 ##
-## On exit, the function returns @var{x}, the approximate minimum point
-## and @var{fval}, the function value thereof.
+## On exit, the function returns @var{x}, the approximate minimum point and
+## @var{fval}, the function value thereof.
+##
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ## The algorithm converged to a solution.
 ##
 ## @item 0
 ## Maximum number of iterations or function evaluations has been exhausted.
 ##
 ## @item -1
 ## The algorithm has been terminated from user output function.
 ## @end itemize
 ##
-## Notes: The search for a minimum is restricted to be in the interval
-## bound by @var{a} and @var{b}.  If you only have an initial point
-## to begin searching from you will need to use an unconstrained
-## minimization algorithm such as @code{fminunc} or @code{fminsearch}.
-## @code{fminbnd} internally uses a Golden Section search strategy.
+## Notes: The search for a minimum is restricted to be in the interval bound by
+## @var{a} and @var{b}.  If you only have an initial point to begin searching
+## from you will need to use an unconstrained minimization algorithm such as
+## @code{fminunc} or @code{fminsearch}.  @code{fminbnd} internally uses a
+## Golden Section search strategy.
 ## @seealso{fzero, fminunc, fminsearch, optimset}
 ## @end deftypefn
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
 ## Richard Brent: Algorithms For Minimization Without Derivatives,
 ## Prentice-Hall (1973)
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -18,29 +18,29 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} fminsearch (@var{fun}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} fminsearch (@var{fun}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}] =} fminsearch (@dots{})
 ##
 ## Find a value of @var{x} which minimizes the function @var{fun}.
+##
 ## The search begins at the point @var{x0} and iterates using the
 ## @nospell{Nelder & Mead} Simplex algorithm (a derivative-free method).  This
 ## algorithm is better-suited to functions which have discontinuities or for
 ## which a gradient-based search such as @code{fminunc} fails.
 ##
-## Options for the search are provided in the parameter @var{options} using
-## the function @code{optimset}.  Currently, @code{fminsearch} accepts the
-## options: @qcode{"TolX"}, @qcode{"MaxFunEvals"}, @qcode{"MaxIter"},
-## @qcode{"Display"}.  For a description of these options, see
-## @code{optimset}.
+## Options for the search are provided in the parameter @var{options} using the
+## function @code{optimset}.  Currently, @code{fminsearch} accepts the options:
+## @qcode{"TolX"}, @qcode{"MaxFunEvals"}, @qcode{"MaxIter"}, @qcode{"Display"}.
+## For a description of these options, see @code{optimset}.
 ##
-## On exit, the function returns @var{x}, the minimum point,
-## and @var{fval}, the function value thereof.
+## On exit, the function returns @var{x}, the minimum point, and @var{fval},
+## the function value thereof.
 ##
 ## Example usages:
 ##
 ## @example
 ## @group
 ## fminsearch (@@(x) (x(1)-5).^2+(x(2)-8).^4, [0;0])
 ##
 ## fminsearch (inline ("(x(1)-5).^2+(x(2)-8).^4", "x"), [0;0])
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -20,41 +20,44 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fminunc (@var{fcn}, @var{x0})
 ## @deftypefnx {Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}, @var{grad}, @var{hess}] =} fminunc (@var{fcn}, @dots{})
 ## Solve an unconstrained optimization problem defined by the function
 ## @var{fcn}.
 ##
-## @var{fcn} should accept a vector (array) defining the unknown variables,
-## and return the objective function value, optionally with gradient.
+## @var{fcn} should accept a vector (array) defining the unknown variables, and
+## return the objective function value, optionally with gradient.
 ## @code{fminunc} attempts to determine a vector @var{x} such that
-## @code{@var{fcn} (@var{x})} is a local minimum.  @var{x0} determines a
-## starting guess.  The shape of @var{x0} is preserved in all calls to
-## @var{fcn}, but otherwise is treated as a column vector.
-## @var{options} is a structure specifying additional options.
-## Currently, @code{fminunc} recognizes these options:
+## @code{@var{fcn} (@var{x})} is a local minimum.
+##
+## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved in
+## all calls to @var{fcn}, but otherwise is treated as a column vector.
+##
+## @var{options} is a structure specifying additional options.  Currently,
+## @code{fminunc} recognizes these options:
 ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
 ## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
-## @qcode{"GradObj"}, @qcode{"FinDiffType"},
-## @qcode{"TypicalX"}, @qcode{"AutoScaling"}.
+## @qcode{"GradObj"}, @qcode{"FinDiffType"}, @qcode{"TypicalX"},
+## @qcode{"AutoScaling"}.
 ##
-## If @qcode{"GradObj"} is @qcode{"on"}, it specifies that @var{fcn},
-## when called with 2 output arguments, also returns the Jacobian matrix
-## of partial first derivatives at the requested point.
-## @code{TolX} specifies the termination tolerance for the unknown variables
-## @var{x}, while @code{TolFun} is a tolerance for the objective function
-## value @var{fval}.  The default is @code{1e-7} for both options.
+## If @qcode{"GradObj"} is @qcode{"on"}, it specifies that @var{fcn}, when
+## called with 2 output arguments, also returns the Jacobian matrix of partial
+## first derivatives at the requested point.  @code{TolX} specifies the
+## termination tolerance for the unknown variables @var{x}, while @code{TolFun}
+## is a tolerance for the objective function value @var{fval}.  The default is
+## @code{1e-7} for both options.
 ##
 ## For a description of the other options, see @code{optimset}.
 ##
 ## On return, @var{x} is the location of the minimum and @var{fval} contains
-## the value of the objective function at @var{x}.  @var{info} may be one of the
-## following values:
+## the value of the objective function at @var{x}.
+##
+## @var{info} may be one of the following values:
 ##
 ## @table @asis
 ## @item 1
 ## Converged to a solution point.  Relative gradient error is less than
 ## specified by @code{TolFun}.
 ##
 ## @item 2
 ## Last relative step size was less than @code{TolX}.
@@ -72,21 +75,23 @@
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
 ## Optionally, @code{fminunc} can return a structure with convergence statistics
 ## (@var{output}), the output gradient (@var{grad}) at the solution @var{x},
 ## and approximate Hessian (@var{hess}) at the solution @var{x}.
 ##
-## Notes: If have only a single nonlinear equation of one variable then using
-## @code{fminbnd} is usually a much better idea.  The algorithm used is a
-## gradient search which depends on the objective function being differentiable.
-## If the function has discontinuities it may be better to use a derivative-free
-## algorithm such as @code{fminsearch}.
+## Application Notes: If have only a single nonlinear equation of one variable
+## then using @code{fminbnd} is usually a better choice.
+##
+## The algorithm used by @code{fminsearch} is a gradient search which depends
+## on the objective function being differentiable.  If the function has
+## discontinuities it may be better to use a derivative-free algorithm such as
+## @code{fminsearch}.
 ## @seealso{fminbnd, fminsearch, optimset}
 ## @end deftypefn
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminunc");
 
 function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
 
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -17,58 +17,63 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fsolve (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{fjac}] =} fsolve (@var{fcn}, @dots{})
 ## Solve a system of nonlinear equations defined by the function @var{fcn}.
+##
 ## @var{fcn} should accept a vector (array) defining the unknown variables,
 ## and return a vector of left-hand sides of the equations.  Right-hand sides
-## are defined to be zeros.
-## In other words, this function attempts to determine a vector @var{x} such
-## that @code{@var{fcn} (@var{x})} gives (approximately) all zeros.
+## are defined to be zeros.  In other words, this function attempts to
+## determine a vector @var{x} such that @code{@var{fcn} (@var{x})} gives
+## (approximately) all zeros.
+##
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
-## @var{options} is a structure specifying additional options.
-## Currently, @code{fsolve} recognizes these options:
+##
+## @var{options} is a structure specifying additional options.  Currently,
+## @code{fsolve} recognizes these options:
 ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
 ## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
 ## @qcode{"Jacobian"}, @qcode{"Updating"}, @qcode{"ComplexEqn"}
 ## @qcode{"TypicalX"}, @qcode{"AutoScaling"} and @qcode{"FinDiffType"}.
 ##
-## If @qcode{"Jacobian"} is @qcode{"on"}, it specifies that @var{fcn},
-## called with 2 output arguments, also returns the Jacobian matrix
-## of right-hand sides at the requested point.  @qcode{"TolX"} specifies
-## the termination tolerance in the unknown variables, while
-## @qcode{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
-## for both @qcode{"TolX"} and @qcode{"TolFun"}.
+## If @qcode{"Jacobian"} is @qcode{"on"}, it specifies that @var{fcn}, called
+## with 2 output arguments also returns the Jacobian matrix of right-hand sides
+## at the requested point.  @qcode{"TolX"} specifies the termination tolerance
+## in the unknown variables, while @qcode{"TolFun"} is a tolerance for
+## equations.  Default is @code{1e-7} for both @qcode{"TolX"} and
+## @qcode{"TolFun"}.
 ##
 ## If @qcode{"AutoScaling"} is on, the variables will be automatically scaled
 ## according to the column norms of the (estimated) Jacobian.  As a result,
-## TolF becomes scaling-independent.  By default, this option is off, because
+## TolF becomes scaling-independent.  By default, this option is off because
 ## it may sometimes deliver unexpected (though mathematically correct) results.
 ##
 ## If @qcode{"Updating"} is @qcode{"on"}, the function will attempt to use
 ## @nospell{Broyden} updates to update the Jacobian, in order to reduce the
 ## amount of Jacobian calculations.  If your user function always calculates the
-## Jacobian (regardless of number of output arguments), this option provides
+## Jacobian (regardless of number of output arguments) then this option provides
 ## no advantage and should be set to false.
 ##
 ## @qcode{"ComplexEqn"} is @qcode{"on"}, @code{fsolve} will attempt to solve
-## complex equations in complex variables, assuming that the equations possess a
-## complex derivative (i.e., are holomorphic).  If this is not what you want,
-## should unpack the real and imaginary parts of the system to get a real
+## complex equations in complex variables, assuming that the equations possess
+## a complex derivative (i.e., are holomorphic).  If this is not what you want,
+## you should unpack the real and imaginary parts of the system to get a real
 ## system.
 ##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
-## evaluated at @var{x}, and @var{info} may be one of the following values:
+## evaluated at @var{x}.
+##
+## @var{info} may be one of the following values:
 ##
 ## @table @asis
 ## @item 1
 ## Converged to a solution point.  Relative residual error is less than
 ## specified by TolFun.
 ##
 ## @item 2
 ## Last relative step size was less that TolX.
@@ -82,18 +87,18 @@
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
 ## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fzero} is usually a much better idea.
 ##
 ## Note about user-supplied Jacobians:
-## As an inherent property of the algorithm, Jacobian is always requested for a
-## solution vector whose residual vector is already known, and it is the last
+## As an inherent property of the algorithm, a Jacobian is always requested for
+## a solution vector whose residual vector is already known, and it is the last
 ## accepted successful step.  Often this will be one of the last two calls, but
 ## not always.  If the savings by reusing intermediate results from residual
 ## calculation in Jacobian calculation are significant, the best strategy is to
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
 ## called with that vector, then the intermediate results should be saved for
 ## future Jacobian evaluation, and should be kept until a Jacobian evaluation
 ## is requested or until OutputFcn is called with a different vector, in which
 ## case they should be dropped in favor of this most recent vector.  A short
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -19,38 +19,41 @@
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fzero (@var{fun}, @var{x0})
 ## @deftypefnx {Function File} {} fzero (@var{fun}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@dots{})
 ## Find a zero of a univariate function.
 ##
-## @var{fun} is a function handle, inline function, or string
-## containing the name of the function to evaluate.
+## @var{fun} is a function handle, inline function, or string containing the
+## name of the function to evaluate.
+##
 ## @var{x0} should be a two-element vector specifying two points which
 ## bracket a zero.  In other words, there must be a change in sign of the
 ## function between @var{x0}(1) and @var{x0}(2).  More mathematically, the
 ## following must hold
 ##
 ## @example
 ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
 ## @end example
 ##
-## If @var{x0} is a single scalar then several nearby and distant
-## values are probed in an attempt to obtain a valid bracketing.  If this
-## is not successful, the function fails.
-## @var{options} is a structure specifying additional options.
-## Currently, @code{fzero}
-## recognizes these options: @qcode{"FunValCheck"}, @qcode{"OutputFcn"},
-## @qcode{"TolX"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.
+## If @var{x0} is a single scalar then several nearby and distant values are
+## probed in an attempt to obtain a valid bracketing.  If this is not
+## successful, the function fails.
+##
+## @var{options} is a structure specifying additional options.  Currently,
+## @code{fzero} recognizes these options:
+## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+## @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.
 ## For a description of these options, see @ref{XREFoptimset,,optimset}.
 ##
-## On exit, the function returns @var{x}, the approximate zero point
-## and @var{fval}, the function value thereof.
+## On exit, the function returns @var{x}, the approximate zero point and
+## @var{fval}, the function value thereof.
+##
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ##  The algorithm converged to a solution.
 ##
 ## @item 0
 ##  Maximum number of iterations or function evaluations has been reached.
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -14,18 +14,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{errnum}, @var{extra}] =} glpk (@var{c}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
-## Solve a linear program using the GNU @sc{glpk} library.  Given three
-## arguments, @code{glpk} solves the following standard LP:
+## Solve a linear program using the GNU @sc{glpk} library.
+##
+## Given three arguments, @code{glpk} solves the following standard LP:
 ## @tex
 ## $$
 ##   \min_x C^T x
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
@@ -85,33 +86,31 @@
 ## @table @var
 ## @item c
 ## A column array containing the objective function coefficients.
 ##
 ## @item A
 ## A matrix containing the constraints coefficients.
 ##
 ## @item b
-## A column array containing the right-hand side value for each constraint
-## in the constraint matrix.
+## A column array containing the right-hand side value for each constraint in
+## the constraint matrix.
 ##
 ## @item lb
-## An array containing the lower bound on each of the variables.  If
-## @var{lb} is not supplied, the default lower bound for the variables is
-## zero.
+## An array containing the lower bound on each of the variables.  If @var{lb}
+## is not supplied, the default lower bound for the variables is zero.
 ##
 ## @item ub
-## An array containing the upper bound on each of the variables.  If
-## @var{ub} is not supplied, the default upper bound is assumed to be
-## infinite.
+## An array containing the upper bound on each of the variables.  If @var{ub}
+## is not supplied, the default upper bound is assumed to be infinite.
 ##
 ## @item ctype
 ## An array of characters containing the sense of each constraint in the
-## constraint matrix.  Each element of the array may be one of the
-## following values
+## constraint matrix.  Each element of the array may be one of the following
+## values
 ##
 ## @table @asis
 ## @item @qcode{"F"}
 ## A free (unbounded) constraint (the constraint is ignored).
 ##
 ## @item @qcode{"U"}
 ## An inequality constraint with an upper bound (@code{A(i,:)*x <= b(i)}).
 ##
@@ -133,24 +132,24 @@
 ## @item @qcode{"C"}
 ## A continuous variable.
 ##
 ## @item @qcode{"I"}
 ## An integer variable.
 ## @end table
 ##
 ## @item sense
-## If @var{sense} is 1, the problem is a minimization.  If @var{sense} is
-## -1, the problem is a maximization.  The default value is 1.
+## If @var{sense} is 1, the problem is a minimization.  If @var{sense} is -1,
+## the problem is a maximization.  The default value is 1.
 ##
 ## @item param
 ## A structure containing the following parameters used to define the
 ## behavior of solver.  Missing elements in the structure take on default
-## values, so you only need to set the elements that you wish to change
-## from the default.
+## values, so you only need to set the elements that you wish to change from
+## the default.
 ##
 ## Integer parameters:
 ##
 ## @table @code
 ## @item msglev (default: 1)
 ## Level of messages output by solver routines:
 ##
 ## @table @asis
@@ -215,19 +214,18 @@
 ## @end table
 ##
 ## @item itlim (default: intmax)
 ## Simplex iterations limit.  It is decreased by one each time when one simplex
 ## iteration has been performed, and reaching zero value signals the solver to
 ## stop the search.
 ##
 ## @item outfrq (default: 200)
-## Output frequency, in iterations.  This parameter specifies how
-## frequently the solver sends information about the solution to the
-## standard output.
+## Output frequency, in iterations.  This parameter specifies how frequently
+## the solver sends information about the solution to the standard output.
 ##
 ## @item branch (default: 4)
 ## Branching technique option (for MIP only):
 ##
 ## @table @asis
 ## @item 1 (@w{@code{GLP_BR_FFV}})
 ## First fractional variable.
 ##
@@ -288,63 +286,62 @@
 ## Harris' two-pass ratio test.
 ## @end table
 ##
 ## @item tmlim (default: intmax)
 ## Searching time limit, in milliseconds.
 ##
 ## @item outdly (default: 0)
 ## Output delay, in seconds.  This parameter specifies how long the solver
-## should delay sending information about the solution to the standard
-## output.
+## should delay sending information about the solution to the standard output.
 ##
 ## @item save (default: 0)
-## If this parameter is nonzero, save a copy of the problem in
-## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
-## way to change the name of the output file.
+## If this parameter is nonzero, save a copy of the problem in CPLEX LP
+## format to the file @file{"outpb.lp"}.  There is currently no way to change
+## the name of the output file.
 ## @end table
 ##
 ## Real parameters:
 ##
 ## @table @code
 ## @item tolbnd (default: 1e-7)
 ## Relative tolerance used to check if the current basic solution is primal
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ##
 ## @item toldj (default: 1e-7)
 ## Absolute tolerance used to check if the current basic solution is dual
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ##
 ## @item tolpiv (default: 1e-10)
-## Relative tolerance used to choose eligible pivotal elements of the
-## simplex table.  It is not recommended that you change this parameter unless
-## you have a detailed understanding of its purpose.
+## Relative tolerance used to choose eligible pivotal elements of the simplex
+## table.  It is not recommended that you change this parameter unless you have
+## a detailed understanding of its purpose.
 ##
 ## @item objll (default: -DBL_MAX)
-## Lower limit of the objective function.  If the objective
-## function reaches this limit and continues decreasing, the solver stops
-## the search.  This parameter is used in the dual simplex method only.
+## Lower limit of the objective function.  If the objective function reaches
+## this limit and continues decreasing, the solver stops the search.  This
+## parameter is used in the dual simplex method only.
 ##
 ## @item objul (default: +DBL_MAX)
-## Upper limit of the objective function.  If the objective
-## function reaches this limit and continues increasing, the solver stops
-## the search.  This parameter is used in the dual simplex only.
+## Upper limit of the objective function.  If the objective function reaches
+## this limit and continues increasing, the solver stops the search.  This
+## parameter is used in the dual simplex only.
 ##
 ## @item tolint (default: 1e-5)
 ## Relative tolerance used to check if the current basic solution is integer
-## feasible.  It is not recommended that you change this parameter unless
-## you have a detailed understanding of its purpose.
+## feasible.  It is not recommended that you change this parameter unless you
+## have a detailed understanding of its purpose.
 ##
 ## @item tolobj (default: 1e-7)
-## Relative tolerance used to check if the value of the objective function
-## is not better than in the best known integer feasible solution.  It is
-## not recommended that you change this parameter unless you have a
-## detailed understanding of its purpose.
+## Relative tolerance used to check if the value of the objective function is
+## not better than in the best known integer feasible solution.  It is not
+## recommended that you change this parameter unless you have a detailed
+## understanding of its purpose.
 ## @end table
 ## @end table
 ##
 ## Output values:
 ##
 ## @table @var
 ## @item xopt
 ## The optimizer (the value of the decision variables at the optimum).
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -23,39 +23,43 @@
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
 ## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
-## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
-## optional initial guess for @var{x}.
-## Currently, @code{lsqnonneg}
-## recognizes these options: @qcode{"MaxIter"}, @qcode{"TolX"}.
-## For a description of these options, see @ref{XREFoptimset,,optimset}.
+## @code{@var{x} >= 0}.
+##
+## @var{c} and @var{d} must be real.
+##
+## @var{x0} is an optional initial guess for @var{x}.
+##
+## Currently, @code{lsqnonneg} recognizes these options: @qcode{"MaxIter"},
+## @qcode{"TolX"}.  For a description of these options, see
+## @ref{XREFoptimset,,optimset}.
 ##
 ## Outputs:
 ##
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm (@var{c}*@var{x}-@var{d})^2
 ##
 ## @item residual
 ##
 ## The residual: @var{d}-@var{c}*@var{x}
 ##
 ## @item exitflag
 ##
-## An indicator of convergence.  0 indicates that the iteration count
-## was exceeded, and therefore convergence was not reached; >0 indicates
-## that the algorithm converged.  (The algorithm is stable and will
-## converge given enough iterations.)
+## An indicator of convergence.  0 indicates that the iteration count was
+## exceeded, and therefore convergence was not reached; >0 indicates that the
+## algorithm converged.  (The algorithm is stable and will converge given
+## enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
 ##
 ## @itemize @bullet
 ## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
 ##
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -20,33 +20,36 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pqpnonneg (@var{c}, @var{d})
 ## @deftypefnx {Function File} {@var{x} =} pqpnonneg (@var{c}, @var{d}, @var{x0})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}] =} pqpnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}] =} pqpnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}] =} pqpnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}, @var{lambda}] =} pqpnonneg (@dots{})
-## Minimize @code{1/2*x'*c*x + d'*x} subject to @code{@var{x} >= 0}.  @var{c}
-## and @var{d} must be real, and @var{c} must be symmetric and positive
-## definite.  @var{x0} is an optional initial guess for @var{x}.
+## Minimize @code{1/2*x'*c*x + d'*x} subject to @code{@var{x} >= 0}.
+##
+## @var{c} ## and @var{d} must be real, and @var{c} must be symmetric and
+## positive definite.
+##
+## @var{x0} is an optional initial guess for @var{x}.
 ##
 ## Outputs:
 ##
 ## @itemize @bullet
 ## @item minval
 ##
 ## The minimum attained model value, 1/2*xmin'*c*xmin + d'*xmin
 ##
 ## @item exitflag
 ##
-## An indicator of convergence.  0 indicates that the iteration count
-## was exceeded, and therefore convergence was not reached; >0 indicates
-## that the algorithm converged.  (The algorithm is stable and will
-## converge given enough iterations.)
+## An indicator of convergence.  0 indicates that the iteration count was
+## exceeded, and therefore convergence was not reached; >0 indicates that the
+## algorithm converged.  (The algorithm is stable and will converge given
+## enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
 ##
 ## @itemize @bullet
 ## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
 ##
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -19,17 +19,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H})
 ## @deftypefnx {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q})
 ## @deftypefnx {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b})
 ## @deftypefnx {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b}, @var{lb}, @var{ub})
 ## @deftypefnx {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb}, @var{A_in}, @var{A_ub})
 ## @deftypefnx {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@dots{}, @var{options})
-## Solve the quadratic program
+## Solve a quadratic program (QP).
+##
+## Solve the quadratic program defined by
 ## @tex
 ## $$
 ##  \min_x {1 \over 2} x^T H x + x^T q
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
@@ -55,26 +57,26 @@
 ## A_lb <= A_in*x <= A_ub
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a null-space active-set method.
 ##
-## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb},
-## @var{A_ub}) may be set to the empty matrix (@code{[]}) if not
-## present.  If the initial guess is feasible the algorithm is faster.
+## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb}, @var{A_ub})
+## may be set to the empty matrix (@code{[]}) if not present.  If the initial
+## guess is feasible the algorithm is faster.
 ##
 ## @table @var
 ## @item options
-## An optional structure containing the following
-## parameter(s) used to define the behavior of the solver.  Missing elements
-## in the structure take on default values, so you only need to set the
-## elements that you wish to change from the default.
+## An optional structure containing the following parameter(s) used to define
+## the behavior of the solver.  Missing elements in the structure take on
+## default values, so you only need to set the elements that you wish to
+## change from the default.
 ##
 ## @table @code
 ## @item MaxIter (default: 200)
 ## Maximum number of iterations.
 ## @end table
 ## @end table
 ##
 ## @table @var
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -19,16 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{obj}, @var{info}, @var{iter}, @var{nf}, @var{lambda}] =} sqp (@var{x0}, @var{phi})
 ## @deftypefnx {Function File} {[@dots{}] =} sqp (@var{x0}, @var{phi}, @var{g})
 ## @deftypefnx {Function File} {[@dots{}] =} sqp (@var{x0}, @var{phi}, @var{g}, @var{h})
 ## @deftypefnx {Function File} {[@dots{}] =} sqp (@var{x0}, @var{phi}, @var{g}, @var{h}, @var{lb}, @var{ub})
 ## @deftypefnx {Function File} {[@dots{}] =} sqp (@var{x0}, @var{phi}, @var{g}, @var{h}, @var{lb}, @var{ub}, @var{maxiter})
 ## @deftypefnx {Function File} {[@dots{}] =} sqp (@var{x0}, @var{phi}, @var{g}, @var{h}, @var{lb}, @var{ub}, @var{maxiter}, @var{tol})
+## Minimize an objective function using sequential quadratic programming (SQP).
+##
 ## Solve the nonlinear program
 ## @tex
 ## $$
 ## \min_x \phi (x)
 ## $$
 ## @end tex
 ## @ifnottex
 ##
@@ -57,41 +59,39 @@
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## using a sequential quadratic programming method.
 ##
 ## The first argument is the initial guess for the vector @var{x0}.
 ##
-## The second argument is a function handle pointing to the objective
-## function @var{phi}.  The objective function must accept one vector
-## argument and return a scalar.
-##
-## The second argument may also be a 2- or 3-element cell array of
-## function handles.  The first element should point to the objective
-## function, the second should point to a function that computes the
-## gradient of the objective function, and the third should point to a
-## function that computes the Hessian of the objective function.  If the
-## gradient function is not supplied, the gradient is computed by finite
-## differences.  If the Hessian function is not supplied, a BFGS update
-## formula is used to approximate the Hessian.
+## The second argument is a function handle pointing to the objective function
+## @var{phi}.  The objective function must accept one vector argument and
+## return a scalar.
 ##
-## When supplied, the gradient function @code{@var{phi}@{2@}} must accept
-## one vector argument and return a vector.  When supplied, the Hessian
-## function @code{@var{phi}@{3@}} must accept one vector argument and
-## return a matrix.
+## The second argument may also be a 2- or 3-element cell array of function
+## handles.  The first element should point to the objective function, the
+## second should point to a function that computes the gradient of the
+## objective function, and the third should point to a function that computes
+## the Hessian of the objective function.  If the gradient function is not
+## supplied, the gradient is computed by finite differences.  If the Hessian
+## function is not supplied, a BFGS update formula is used to approximate the
+## Hessian.
 ##
-## The third and fourth arguments @var{g} and @var{h} are function
-## handles pointing to functions that compute the equality constraints
-## and the inequality constraints, respectively.  If the problem does
-## not have equality (or inequality) constraints, then use an empty
-## matrix ([]) for @var{g} (or @var{h}).  When supplied, these equality
-## and inequality constraint functions must accept one vector argument
-## and return a vector.
+## When supplied, the gradient function @code{@var{phi}@{2@}} must accept one
+## vector argument and return a vector.  When supplied, the Hessian function
+## @code{@var{phi}@{3@}} must accept one vector argument and return a matrix.
+##
+## The third and fourth arguments @var{g} and @var{h} are function handles
+## pointing to functions that compute the equality constraints and the
+## inequality constraints, respectively.  If the problem does not have
+## equality (or inequality) constraints, then use an empty matrix ([]) for
+## @var{g} (or @var{h}).  When supplied, these equality and inequality
+## constraint functions must accept one vector argument and return a vector.
 ##
 ## The third and fourth arguments may also be 2-element cell arrays of
 ## function handles.  The first element should point to the constraint
 ## function and the second should point to a function that computes the
 ## gradient of the constraint function:
 ## @tex
 ## $$
 ##  \Bigg( {\partial f(x) \over \partial x_1},
@@ -105,30 +105,29 @@
 ## @group
 ##             [ d f(x)   d f(x)        d f(x) ]
 ## transpose ( [ ------   -----   ...   ------ ] )
 ##             [  dx_1     dx_2          dx_N  ]
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## The fifth and sixth arguments, @var{lb} and @var{ub}, contain lower
-## and upper bounds on @var{x}.  These must be consistent with the
-## equality and inequality constraints @var{g} and @var{h}.  If the
-## arguments are vectors then @var{x}(i) is bound by @var{lb}(i) and
-## @var{ub}(i).  A bound can also be a scalar in which case all elements
-## of @var{x} will share the same bound.  If only one bound (lb, ub) is
-## specified then the other will default to (-@var{realmax},
-## +@var{realmax}).
+## The fifth and sixth arguments, @var{lb} and @var{ub}, contain lower and
+## upper bounds on @var{x}.  These must be consistent with the equality and
+## inequality constraints @var{g} and @var{h}.  If the arguments are vectors
+## then @var{x}(i) is bound by @var{lb}(i) and @var{ub}(i).  A bound can also
+## be a scalar in which case all elements of @var{x} will share the same
+## bound.  If only one bound (lb, ub) is specified then the other will
+## default to (-@var{realmax}, +@var{realmax}).
 ##
 ## The seventh argument @var{maxiter} specifies the maximum number of
 ## iterations.  The default value is 100.
 ##
-## The eighth argument @var{tol} specifies the tolerance for the
-## stopping criteria.  The default value is @code{sqrt (eps)}.
+## The eighth argument @var{tol} specifies the tolerance for the stopping
+## criteria.  The default value is @code{sqrt (eps)}.
 ##
 ## The value returned in @var{info} may be one of the following:
 ##
 ## @table @asis
 ## @item 101
 ## The algorithm terminated normally.
 ## All constraints meet the specified tolerance.
 ##
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} compan (@var{c})
-## Compute the companion matrix corresponding to polynomial coefficient
-## vector @var{c}.
+## Compute the companion matrix corresponding to polynomial coefficient vector
+## @var{c}.
 ##
 ## The companion matrix is
 ## @tex
 ## $$
 ## A = \left[\matrix{
 ##  -c_2/c_1 & -c_3/c_1 & \cdots & -c_N/c_1 & -c_{N+1}/c_1\cr
 ##      1    &     0    & \cdots &     0    &         0   \cr
 ##      0    &     1    & \cdots &     0    &         0   \cr
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -16,34 +16,34 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
 ##
 ## Construct a piecewise polynomial (pp) structure from sample points
-## @var{breaks} and coefficients @var{coefs}.  @var{breaks} must be a vector of
-## strictly increasing values.  The number of intervals is given by
-## @code{@var{ni} = length (@var{breaks}) - 1}.
-## When @var{m} is the polynomial order @var{coefs} must be of
-## size: @var{ni} x @var{m} + 1.
+## @var{breaks} and coefficients @var{coefs}.
 ##
-## The i-th row of @var{coefs},
-## @code{@var{coefs} (@var{i},:)}, contains the coefficients for the polynomial
-## over the @var{i}-th interval, ordered from highest (@var{m}) to
-## lowest (@var{0}).
+## @var{breaks} must be a vector of strictly increasing values.  The number of
+## intervals is given by @code{@var{ni} = length (@var{breaks}) - 1}.
+## 
+## When @var{m} is the polynomial order @var{coefs} must be of size:
+## @var{ni} x @var{m} + 1.
+##
+## The i-th row of @var{coefs}, @code{@var{coefs} (@var{i},:)}, contains the
+## coefficients for the polynomial over the @var{i}-th interval, ordered from
+## highest (@var{m}) to lowest (@var{0}).
 ##
 ## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
 ## or array-valued polynomial.  In that case the polynomial order is defined
-## by the length of the last dimension of @var{coefs}.
-## The size of first dimension(s) are given by the scalar or
-## vector @var{d}.  If @var{d} is not given it is set to @code{1}.
-## In any case @var{coefs} is reshaped to a 2-D matrix of
-## size @code{[@var{ni}*prod(@var{d} @var{m})] }
+## by the length of the last dimension of @var{coefs}.  The size of first
+## dimension(s) are given by the scalar or vector @var{d}.  If @var{d} is not
+## given it is set to @code{1}.  In any case @var{coefs} is reshaped to a 2-D
+## matrix of size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
 ## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
   ## check number of arguments
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -15,27 +15,27 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p})
 ## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol})
 ## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
-## Identify unique poles in @var{p} and their associated multiplicity.  The
-## output is ordered from largest pole to smallest pole.
+## Identify unique poles in @var{p} and their associated multiplicity.
 ##
-## If the relative difference of two poles is less than @var{tol} then
-## they are considered to be multiples.  The default value for @var{tol}
-## is 0.001.
+## The output is ordered from largest pole to smallest pole.
+##
+## If the relative difference of two poles is less than @var{tol} then they are
+## considered to be multiples.  The default value for @var{tol} is 0.001.
 ##
 ## If the optional parameter @var{reorder} is zero, poles are not sorted.
 ##
-## The output @var{multp} is a vector specifying the multiplicity of the
-## poles.  @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
+## The output @var{multp} is a vector specifying the multiplicity of the poles.
+## @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
 ## @code{@var{p}(@var{idxp}(n))}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## p = [2 3 1 1 2];
 ## [m, n] = mpoles (p)
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -19,42 +19,44 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} pchip (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} pchip (@var{x}, @var{y}, @var{xi})
 ## Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
 ## points @var{x} and @var{y}.
 ##
 ## If called with two arguments, return the piecewise polynomial @var{pp}
 ## that may be used with @code{ppval} to evaluate the polynomial at specific
-## points.  When called with a third input argument, @code{pchip} evaluates
-## the pchip polynomial at the points @var{xi}.  The third calling form is
-## equivalent to @code{ppval (pchip (@var{x}, @var{y}), @var{xi})}.
+## points.
+##
+## When called with a third input argument, @code{pchip} evaluates the pchip
+## polynomial at the points @var{xi}.  The third calling form is equivalent to
+## @code{ppval (pchip (@var{x}, @var{y}), @var{xi})}.
 ##
-## The variable @var{x} must be a strictly monotonic vector (either
-## increasing or decreasing) of length @var{n}.  @var{y} can be either a
-## vector or array.  If @var{y} is a vector then it must be the same length
-## @var{n} as @var{x}.  If @var{y} is an array then the size of @var{y} must
-## have the form
+## The variable @var{x} must be a strictly monotonic vector (either increasing
+## or decreasing) of length @var{n}.
+##
+## @var{y} can be either a vector or array.  If @var{y} is a vector then it
+## must be the same length @var{n} as @var{x}.  If @var{y} is an array then
+## the size of @var{y} must have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
-## The array is reshaped internally to a matrix where the leading
-## dimension is given by
+## The array is reshaped internally to a matrix where the leading dimension is
+## given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row of this matrix is then treated separately.  Note that this
-## is exactly opposite to @code{interp1} but is done for @sc{matlab}
-## compatibility.
+## and each row of this matrix is then treated separately.  Note that this is
+## exactly opposite to @code{interp1} but is done for @sc{matlab} compatibility.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date: 9. mar 2001
 ##
 ## S_k = a_k + b_k*x + c_k*x^2 + d_k*x^3; (spline polynom)
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -16,38 +16,40 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} poly (@var{A})
 ## @deftypefnx {Function File} {} poly (@var{x})
 ## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
-## the characteristic polynomial of @var{A}.  For example,
-## the following code finds the eigenvalues of @var{A} which are the roots of
-## @code{poly (@var{A})}.
+## the characteristic polynomial of @var{A}.
+##
+## For example, the following code finds the eigenvalues of @var{A} which are
+## the roots of @code{poly (@var{A})}.
 ##
 ## @example
 ## @group
 ## roots (poly (eye (3)))
 ##     @result{} 1.00001 + 0.00001i
 ##        1.00001 - 0.00001i
 ##        0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
 ## coefficients of the polynomial whose roots are the elements of @var{x}.
-## That is, if @var{c} is a polynomial, then the elements of @code{@var{d} =
-## roots (poly (@var{c}))} are contained in @var{c}.  The vectors @var{c} and
-## @var{d} are not identical, however, due to sorting and numerical errors.
+## That is, if @var{c} is a polynomial, then the elements of
+## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.  The
+## vectors @var{c} and @var{d} are not identical, however, due to sorting and
+## numerical errors.
 ## @seealso{roots, eig}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function y = poly (x)
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -14,19 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyaffine (@var{f}, @var{mu})
 ## Return the coefficients of the polynomial vector @var{f} after an affine
-## transformation.  If @var{f} is the vector representing the polynomial f(x),
-## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
-## representing:
+## transformation.
+##
+## If @var{f} is the vector representing the polynomial f(x), then
+## @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector representing:
 ##
 ## @example
 ## g(x) = f( (x - @var{mu}(1)) / @var{mu}(2) )
 ## @end example
 ##
 ## @seealso{polyval, polyfit}
 ## @end deftypefn
 
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -16,18 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyder (@var{p})
 ## @deftypefnx {Function File} {[@var{k}] =} polyder (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
-## coefficients are given by the vector @var{p}.  If a pair of polynomials
-## is given, return the derivative of the product @math{@var{a}*@var{b}}.
+## coefficients are given by the vector @var{p}.
+##
+## If a pair of polynomials is given, return the derivative of the product
+## @math{@var{a}*@var{b}}.
+## 
 ## If two inputs and two outputs are given, return the derivative of the
 ## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
 ## in @var{q} and the denominator in @var{d}.
 ## @seealso{polyint, polyval, polyreduce}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -18,18 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{z} =} polyeig (@var{C0}, @var{C1}, @dots{}, @var{Cl})
 ## @deftypefnx {Function File} {[@var{v}, @var{z}] =} polyeig (@var{C0}, @var{C1}, @dots{}, @var{Cl})
 ##
 ## Solve the polynomial eigenvalue problem of degree @var{l}.
 ##
 ## Given an @var{n*n} matrix polynomial
+##
 ## @code{@var{C}(s) = @var{C0} + @var{C1} s + @dots{} + @var{Cl} s^l}
-## polyeig solves the eigenvalue problem
+##
+## @code{polyeig} solves the eigenvalue problem
+##
 ## @code{(@var{C0} + @var{C1} + @dots{} + @var{Cl})v = 0}.
 ##
 ## Note that the eigenvalues @var{z} are the zeros of the matrix polynomial.
 ## @var{z} is a row vector with @var{n*l} elements.  @var{v} is a matrix
 ## (@var{n} x @var{n}*@var{l}) with columns that correspond to the
 ## eigenvectors.
 ##
 ## @seealso{eig, eigs, compan}
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -17,19 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit to the points
-## @code{[@var{x}, @var{y}]}.  If @var{n} is a logical vector, it is used
-## as a mask to selectively force the corresponding polynomial
-## coefficients to be used or ignored.
+## @code{[@var{x}, @var{y}]}.
+##
+## If @var{n} is a logical vector, it is used as a mask to selectively force
+## the corresponding polynomial coefficients to be used or ignored.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
 ## @item R
 ## Triangular factor R from the QR@tie{}decomposition.
@@ -49,25 +50,28 @@
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
 ## @end table
 ##
 ## The second output may be used by @code{polyval} to calculate the
 ## statistical error limits of the predicted values.  In particular, the
-## standard deviation of @var{p} coefficients is given by @*
+## standard deviation of @var{p} coefficients is given by
+##
 ## @code{sqrt (diag (s.C)/s.df)*s.normr}.
 ##
-## When the third output, @var{mu}, is present the
-## coefficients, @var{p}, are associated with a polynomial in
-## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
-## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
-## This linear transformation of @var{x} improves the numerical
-## stability of the fit.
+## When the third output, @var{mu}, is present the coefficients, @var{p}, are
+## associated with a polynomial in
+##
+## @code{@var{xhat} = (@var{x} - @var{mu}(1)) / @var{mu}(2)} @*
+## where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
+##
+## This linear transformation of @var{x} improves the numerical stability of
+## the fit.
 ## @seealso{polyval, polyaffine, roots, vander, zscore}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 ## Modified on 20120204 by P. Dupuis; added the ability to specify a
 ## polynomial mask instead of a polynomial degree.
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -15,19 +15,22 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
-## Find the greatest common divisor of two polynomials.  This is equivalent
-## to the polynomial found by multiplying together all the common roots.
-## Together with deconv, you can reduce a ratio of two polynomials.
+## Find the greatest common divisor of two polynomials.
+##
+## This is equivalent to the polynomial found by multiplying together all the
+## common roots.  Together with deconv, you can reduce a ratio of two
+## polynomials.
+##
 ## The tolerance @var{tol} defaults to @code{sqrt (eps)}.
 ##
 ## @strong{Caution:} This is a numerically unstable algorithm and should not
 ## be used on large polynomials.
 ##
 ## Example code:
 ##
 ## @example
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -15,18 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyint (@var{p})
 ## @deftypefnx {Function File} {} polyint (@var{p}, @var{k})
 ## Return the coefficients of the integral of the polynomial whose
-## coefficients are represented by the vector @var{p}.  The variable
-## @var{k} is the constant of integration, which by default is set to zero.
+## coefficients are represented by the vector @var{p}.
+##
+## The variable @var{k} is the constant of integration, which by default is
+## set to zero.
 ## @seealso{polyder, polyval}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function retval = polyint (p, k)
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -15,29 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyout (@var{c})
 ## @deftypefnx {Function File} {} polyout (@var{c}, @var{x})
 ## @deftypefnx {Function File} {@var{str} =} polyout (@dots{})
-## Write formatted polynomial
+## Display a formatted version of the polynomial @var{c}.
+##
+## The formatted polynomial
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
-## and return it as a string or write it to the screen (if @var{nargout} is
-## zero).  @var{x} defaults to the string @qcode{"s"}.
+## is returned as a string or written to the screen if @code{nargout} is zero.
+##
+## The second argument @var{x} specifies the variable name to use for each term
+## and defaults to the string @qcode{"s"}.
 ## @seealso{polyreduce}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -17,27 +17,29 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ##
-## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
-## @var{mu} is present, evaluate the polynomial for
-## (@var{x}-@var{mu}(1))/@var{mu}(2).
+## Evaluate the polynomial @var{p} at the specified values of @var{x}.
+##
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
 ##
-## In addition to evaluating the polynomial, the second output
-## represents the prediction interval, @var{y} +/- @var{dy}, which
-## contains at least 50% of the future predictions.  To calculate the
-## prediction interval, the structured variable @var{s}, originating
-## from @code{polyfit}, must be supplied.
+## When @var{mu} is present, evaluate the polynomial for
+## (@var{x}-@var{mu}(1))/@var{mu}(2).
+##
+## In addition to evaluating the polynomial, the second output represents the
+## prediction interval, @var{y} +/- @var{dy}, which contains at least 50% of
+## the future predictions.  To calculate the prediction interval, the
+## structured variable @var{s}, originating from @code{polyfit}, must be
+## supplied.
 ##
 ## @seealso{polyvalm, polyaffine, polyfit, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -15,17 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {ppd =} ppder (pp)
 ## @deftypefnx {Function File} {ppd =} ppder (pp, m)
 ## Compute the piecewise @var{m}-th derivative of a piecewise polynomial
-## struct @var{pp}.  If @var{m} is omitted the first derivative is calculated.
+## struct @var{pp}.
+##
+## If @var{m} is omitted the first derivative is calculated.
 ## @seealso{mkpp, ppval, ppint}
 ## @end deftypefn
 
 function ppd = ppder (pp, m = 1)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -15,16 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{ppi} =} ppint (@var{pp})
 ## @deftypefnx {Function File} {@var{ppi} =} ppint (@var{pp}, @var{c})
 ## Compute the integral of the piecewise polynomial struct @var{pp}.
+##
 ## @var{c}, if given, is the constant of integration.
 ## @seealso{mkpp, ppval, ppder}
 ## @end deftypefn
 
 function ppi = ppint (pp, c)
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -14,16 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{jumps} =} ppjumps (@var{pp})
 ## Evaluate the boundary jumps of a piecewise polynomial.
+##
 ## If there are @math{n} intervals, and the dimensionality of @var{pp} is
 ## @math{d}, the resulting array has dimensions @code{[d, n-1]}.
 ## @seealso{mkpp}
 ## @end deftypefn
 
 function jumps = ppjumps (pp)
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -14,21 +14,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
 ## Evaluate the piecewise polynomial structure @var{pp} at the points @var{xi}.
-## If @var{pp} describes a scalar polynomial function, the result is an
-## array of the same shape as @var{xi}.
-## Otherwise, the size of the result is @code{[pp.dim, length(@var{xi})]} if
-## @var{xi} is a vector, or @code{[pp.dim, size(@var{xi})]} if it is a
-## multi-dimensional array.
+##
+## If @var{pp} describes a scalar polynomial function, the result is an array
+## of the same shape as @var{xi}.  Otherwise, the size of the result is
+## @code{[pp.dim, length(@var{xi})]} if @var{xi} is a vector, or
+## @code{[pp.dim, size(@var{xi})]} if it is a multi-dimensional array.
 ## @seealso{mkpp, unmkpp, spline, pchip}
 ## @end deftypefn
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -18,38 +18,40 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{r}, @var{p}, @var{k}, @var{e}] =} residue (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k})
 ## @deftypefnx {Function File} {[@var{b}, @var{a}] =} residue (@var{r}, @var{p}, @var{k}, @var{e})
 ## The first calling form computes the partial fraction expansion for the
 ## quotient of the polynomials, @var{b} and @var{a}.
+##
+## The quotient is defined as
 ## @tex
 ## $$
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-## B(s)    M       r(m)         N
-## ---- = SUM -------------  + SUM k(i)*s^(N-i)
-## A(s)   m=1 (s-p(m))^e(m)    i=1
+## B(s)    M       r(m)        N
+## ---- = SUM ------------- + SUM k(i)*s^(N-i)
+## A(s)   m=1 (s-p(m))^e(m)   i=1
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
-## where @math{M} is the number of poles (the length of the @var{r},
-## @var{p}, and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
-## representing the direct contribution, and the @var{e} vector specifies
-## the multiplicity of the m-th residue's pole.
+## where @math{M} is the number of poles (the length of the @var{r}, @var{p},
+## and @var{e}), the @var{k} vector is a polynomial of order @math{N-1}
+## representing the direct contribution, and the @var{e} vector specifies the
+## multiplicity of the m-th residue's pole.
 ##
 ## For example,
 ##
 ## @example
 ## @group
 ## b = [1, 1, 1];
 ## a = [1, -5, 8, -4];
 ## [r, p, k, e] = residue (b, a)
@@ -74,21 +76,21 @@
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## The second calling form performs the inverse operation and computes
-## the reconstituted quotient of polynomials, @var{b}(s)/@var{a}(s),
-## from the partial fraction expansion; represented by the residues,
-## poles, and a direct polynomial specified by @var{r}, @var{p} and
-## @var{k}, and the pole multiplicity @var{e}.
+## The second calling form performs the inverse operation and computes the
+## reconstituted quotient of polynomials, @var{b}(s)/@var{a}(s), from the
+## partial fraction expansion; represented by the residues, poles, and a direct
+## polynomial specified by @var{r}, @var{p} and @var{k}, and the pole
+## multiplicity @var{e}.
 ##
 ## If the multiplicity, @var{e}, is not explicitly specified the multiplicity is
 ## determined by the function @code{mpoles}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -12,29 +12,31 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} roots (@var{v})
+## @deftypefn {Function File} {} roots (@var{c})
 ##
-## For a vector @var{v} with @math{N} components, return
-## the roots of the polynomial
+## Compute the roots of the polynomial @var{c}.
+##
+## For a vector @var{c} with @math{N} components, return the roots of the
+## polynomial
 ## @tex
 ## $$
-## v_1 z^{N-1} + \cdots + v_{N-1} z + v_N.
+## c_1 x^{N-1} + \cdots + c_{N-1} x + c_N.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## v(1) * z^(N-1) + @dots{} + v(N-1) * z + v(N)
+## c(1) * x^(N-1) + @dots{} + c(N-1) * x + c(N)
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## As an example, the following code finds the roots of the quadratic
 ## polynomial
 ## @tex
 ## $$ p(x) = x^2 - 5. $$
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -19,28 +19,31 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
 ## Return the cubic spline interpolant of points @var{x} and @var{y}.
 ##
 ## When called with two arguments, return the piecewise polynomial @var{pp}
 ## that may be used with @code{ppval} to evaluate the polynomial at specific
-## points.  When called with a third input argument, @code{spline} evaluates
-## the spline at the points @var{xi}.  The third calling form @code{spline
-## (@var{x}, @var{y}, @var{xi})} is equivalent to @code{ppval (spline
-## (@var{x}, @var{y}), @var{xi})}.
+## points.
+##
+## When called with a third input argument, @code{spline} evaluates the spline
+## at the points @var{xi}.  The third calling form
+## @code{spline (@var{x}, @var{y}, @var{xi})} is equivalent to
+## @code{ppval (spline (@var{x}, @var{y}), @var{xi})}.
 ##
-## The variable @var{x} must be a vector of length @var{n}.  @var{y} can be
-## either a vector or array.  If @var{y} is a vector it must have a length of
-## either @var{n} or @code{@var{n} + 2}.  If the length of @var{y} is
-## @var{n}, then the "not-a-knot" end condition is used.  If the length of
-## @var{y} is @code{@var{n} + 2}, then the first and last values of the
-## vector @var{y} are the values of the first derivative of the cubic spline
-## at the endpoints.
+## The variable @var{x} must be a vector of length @var{n}.
+##
+## @var{y} can be either a vector or array.  If @var{y} is a vector it must
+## have a length of either @var{n} or @code{@var{n} + 2}.  If the length of
+## @var{y} is @var{n}, then the "not-a-knot" end condition is used.  If the
+## length of @var{y} is @code{@var{n} + 2}, then the first and last values of
+## the vector @var{y} are the values of the first derivative of the cubic
+## spline at the endpoints.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
@@ -54,18 +57,18 @@
 ## The array is reshaped internally to a matrix where the leading
 ## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row of this matrix is then treated separately.  Note that this
-## is exactly opposite to @code{interp1} but is done for @sc{matlab}
+## and each row of this matrix is then treated separately.  Note that this is
+## exactly the opposite of @code{interp1} but is done for @sc{matlab}
 ## compatibility.
 ##
 ## @seealso{pchip, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## This code is based on csape.m from octave-forge, but has been
 ## modified to use the sparse solver code in octave that itself allows
 ## special casing of tri-diagonal matrices, modified for NDArrays and
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -21,50 +21,51 @@
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{p})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "periodic", @var{periodic})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "robust", @var{robust})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "beta", @var{beta})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "order", @var{order})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
 ##
 ## Fit a piecewise cubic spline with breaks (knots) @var{breaks} to the
-## noisy data, @var{x} and @var{y}.  @var{x} is a vector, and @var{y}
-## is a vector or N-D array.  If @var{y} is an N-D array, then @var{x}(j)
-## is matched to @var{y}(:,@dots{},:,j).
+## noisy data, @var{x} and @var{y}.
 ##
-## The fitted spline is returned as a piecewise polynomial, @var{pp}, and
-## may be evaluated using @code{ppval}.
+## @var{x} is a vector, and @var{y} is a vector or N-D array.  If @var{y} is an
+## N-D array, then @var{x}(j) is matched to @var{y}(:,@dots{},:,j).
 ##
 ## @var{p} is a positive integer defining the number of intervals along @var{x},
 ## and @var{p}+1 is the number of breaks.  The number of points in each interval
 ## differ by no more than 1.
 ##
 ## The optional property @var{periodic} is a logical value which specifies
 ## whether a periodic boundary condition is applied to the spline.  The
 ## length of the period is @code{max (@var{breaks}) - min (@var{breaks})}.
 ## The default value is @code{false}.
 ##
 ## The optional property @var{robust} is a logical value which specifies
 ## if robust fitting is to be applied to reduce the influence of outlying
 ## data points.  Three iterations of weighted least squares are performed.
 ## Weights are computed from previous residuals.  The sensitivity of outlier
 ## identification is controlled by the property @var{beta}.  The value of
-## @var{beta} is stricted to the range, 0 < @var{beta} < 1.  The default
+## @var{beta} is restricted to the range, 0 < @var{beta} < 1.  The default
 ## value is @var{beta} = 1/2.  Values close to 0 give all data equal
 ## weighting.  Increasing values of @var{beta} reduce the influence of
 ## outlying data.  Values close to unity may cause instability or rank
 ## deficiency.
 ##
+## The fitted spline is returned as a piecewise polynomial, @var{pp}, and
+## may be evaluated using @code{ppval}.
+##
 ## The splines are constructed of polynomials with degree @var{order}.
 ## The default is a cubic, @var{order}=3.  A spline with P pieces has
 ## P+@var{order} degrees of freedom.  With periodic boundary conditions
 ## the degrees of freedom are reduced to P.
 ##
-## The optional property, @var{constaints}, is a structure specifying
-## linear constraints on the fit.  The structure has three fields, @qcode{"xc"},
+## The optional property, @var{constaints}, is a structure specifying linear
+## constraints on the fit.  The structure has three fields, @qcode{"xc"},
 ## @qcode{"yc"}, and @qcode{"cc"}.
 ##
 ## @table @asis
 ## @item @qcode{"xc"}
 ## Vector of the x-locations of the constraints.
 ##
 ## @item @qcode{"yc"}
 ## Constraining values at the locations @var{xc}.
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -15,28 +15,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{p}, @var{n}, @var{k}, @var{d}] =} unmkpp (@var{pp})
 ##
 ## Extract the components of a piecewise polynomial structure @var{pp}.
+##
 ## The components are:
 ##
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ##
 ## @item @var{p}
-## Polynomial coefficients for points in sample interval.  @code{@var{p}
-## (@var{i}, :)} contains the coefficients for the polynomial over
-## interval @var{i} ordered from highest to lowest.  If @code{@var{d} >
-## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coefficients for
-## the r-th polynomial defined on interval @var{i}.
+## Polynomial coefficients for points in sample interval.
+## @code{@var{p} (@var{i}, :)} contains the coefficients for the polynomial 
+## over interval @var{i} ordered from highest to lowest.  If
+## @code{@var{d} > 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the
+## coefficients for the r-th polynomial defined on interval @var{i}.
 ##
 ## @item @var{n}
 ## Number of polynomial pieces.
 ##
 ## @item @var{k}
 ## Order of the polynomial plus 1.
 ##
 ## @item @var{d}
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -13,43 +13,45 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{b}] =} arch_fit (@var{y}, @var{x}, @var{p}, @var{iter}, @var{gamma}, @var{a0}, @var{b0})
-## Fit an ARCH regression model to the time series @var{y} using the
-## scoring algorithm in @nospell{Engle's} original ARCH paper.  The model is
+## Fit an ARCH regression model to the time series @var{y} using the scoring
+## algorithm in @nospell{Engle's} original ARCH paper.
+##
+## The model is
 ##
 ## @example
 ## @group
 ## y(t) = b(1) * x(t,1) + @dots{} + b(k) * x(t,k) + e(t),
 ## h(t) = a(1) + a(2) * e(t-1)^2 + @dots{} + a(p+1) * e(t-p)^2
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## in which @math{e(t)} is @math{N(0, h(t))}, given a time-series vector
-## @var{y} up to time @math{t-1} and a matrix of (ordinary) regressors
-## @var{x} up to @math{t}.  The order of the regression of the residual
-## variance is specified by @var{p}.
+## @var{y} up to time @math{t-1} and a matrix of (ordinary) regressors @var{x}
+## up to @math{t}.  The order of the regression of the residual variance is
+## specified by @var{p}.
 ##
-## If invoked as @code{arch_fit (@var{y}, @var{k}, @var{p})} with a
-## positive integer @var{k}, fit an ARCH(@var{k}, @var{p}) process,
-## i.e., do the above with the @math{t}-th row of @var{x} given by
+## If invoked as @code{arch_fit (@var{y}, @var{k}, @var{p})} with a positive
+## integer @var{k}, fit an ARCH(@var{k}, @var{p}) process, i.e., do the above
+## with the @math{t}-th row of @var{x} given by
 ##
 ## @example
 ## [1, y(t-1), @dots{}, y(t-k)]
 ## @end example
 ##
 ## Optionally, one can specify the number of iterations @var{iter}, the
-## updating factor @var{gamma}, and initial values @math{a0} and
-## @math{b0} for the scoring algorithm.
+## updating factor @var{gamma}, and initial values @math{a0} and @math{b0}
+## for the scoring algorithm.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, x, p, iter, gamma, a0, b0)
 
   if (nargin < 3 || nargin == 6 || nargin > 7)
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -13,19 +13,20 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} arch_rnd (@var{a}, @var{b}, @var{t})
-## Simulate an ARCH sequence of length @var{t} with AR
-## coefficients @var{b} and CH coefficients @var{a}.  I.e., the result
-## @math{y(t)} follows the model
+## Simulate an ARCH sequence of length @var{t} with AR coefficients @var{b} and
+## CH coefficients @var{a}.
+##
+## The result @math{y(t)} follows the model
 ## @c Set example in small font to prevent overfull line
 ##
 ## @smallexample
 ## y(t) = b(1) + b(2) * y(t-1) + @dots{} + b(lb) * y(t-lb+1) + e(t),
 ## @end smallexample
 ##
 ## @noindent
 ## where @math{e(t)}, given @var{y} up to time @math{t-1}, is
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -13,34 +13,36 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} arma_rnd (@var{a}, @var{b}, @var{v}, @var{t}, @var{n})
-## Return a simulation of the ARMA model
+## Return a simulation of the ARMA model.
+##
+## The ARMA model is defined by
 ##
 ## @example
 ## @group
 ## x(n) = a(1) * x(n-1) + @dots{} + a(k) * x(n-k)
 ##      + e(n) + b(1) * e(n-1) + @dots{} + b(l) * e(n-l)
 ## @end group
 ## @end example
 ##
 ## @noindent
-## in which @var{k} is the length of vector @var{a}, @var{l} is the
-## length of vector @var{b} and @var{e} is Gaussian white noise with
-## variance @var{v}.  The function returns a vector of length @var{t}.
+## in which @var{k} is the length of vector @var{a}, @var{l} is the length of
+## vector @var{b} and @var{e} is Gaussian white noise with variance @var{v}. 
+## The function returns a vector of length @var{t}.
 ##
-## The optional parameter @var{n} gives the number of dummy
-## @var{x}(@var{i}) used for initialization, i.e., a sequence of length
-## @var{t}+@var{n} is generated and @var{x}(@var{n}+1:@var{t}+@var{n})
-## is returned.  If @var{n} is omitted, @var{n} = 100 is used.
+## The optional parameter @var{n} gives the number of dummy @var{x}(@var{i})
+## used for initialization, i.e., a sequence of length @var{t}+@var{n} is
+## generated and @var{x}(@var{n}+1:@var{t}+@var{n}) is returned.  If @var{n}
+## is omitted, @var{n} = 100 is used.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   if (nargin == 4)
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -13,22 +13,24 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autoreg_matrix (@var{y}, @var{k})
-## Given a time series (vector) @var{y}, return a matrix with ones in the
-## first column and the first @var{k} lagged values of @var{y} in the
-## other columns.  I.e., for @var{t} > @var{k}, @code{[1,
-## @var{y}(@var{t}-1), @dots{}, @var{y}(@var{t}-@var{k})]} is the t-th row
-## of the result.  The resulting matrix may be used as a regressor matrix
-## in autoregressions.
+## Given a time series (vector) @var{y}, return a matrix with ones in the first
+## column and the first @var{k} lagged values of @var{y} in the other columns.
+##
+## In other words, for @var{t} > @var{k},
+## @code{[1, @var{y}(@var{t}-1), @dots{}, @var{y}(@var{t}-@var{k})]} is the
+## t-th row of the result.
+##
+## The resulting matrix may be used as a regressor matrix in autoregressions.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -13,20 +13,20 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bartlett (@var{m})
-## Return the filter coefficients of a Bartlett (triangular) window of
-## length @var{m}.
+## Return the filter coefficients of a Bartlett (triangular) window of length
+## @var{m}.
 ##
-## For a definition of the Bartlett window, see e.g.,
+## For a definition of the Bartlett window see, e.g.,
 ## @nospell{A.V. Oppenheim & R. W. Schafer},
 ## @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} blackman (@var{m}, "symmetric")
 ## Return the filter coefficients of a Blackman window of length @var{m}.
 ##
 ## If the optional argument @qcode{"periodic"} is given, the periodic form
 ## of the window is returned.  This is equivalent to the window of length
 ## @var{m}+1 with the last coefficient removed.  The optional argument
 ## @qcode{"symmetric"} is equivalent to not specifying a second argument.
 ##
-## For a definition of the Blackman window, see e.g.,
+## For a definition of the Blackman window, see, e.g.,
 ## @nospell{A.V. Oppenheim & R. W. Schafer},
 ## @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Blackman window
 
 function c = blackman (m, opt)
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -19,23 +19,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} detrend (@var{x}, @var{p})
 ## If @var{x} is a vector, @code{detrend (@var{x}, @var{p})} removes the
 ## best fit of a polynomial of order @var{p} from the data @var{x}.
 ##
 ## If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
 ## for each column in @var{x}.
 ##
-## The second argument is optional.  If it is not specified, a value of 1
-## is assumed.  This corresponds to removing a linear trend.
+## The second argument @var{p} is optional.  If it is not specified, a value of
+## 1 is assumed.  This corresponds to removing a linear trend.
 ##
 ## The order of the polynomial can also be given as a string, in which case
-## @var{p} must be either @qcode{"constant"} (corresponds to
-## @code{@var{p}=0}) or
-## @qcode{"linear"} (corresponds to @code{@var{p}=1}).
+## @var{p} must be either @qcode{"constant"} (corresponds to @code{@var{p}=0})
+## or @qcode{"linear"} (corresponds to @code{@var{p}=1}).
 ## @seealso{polyfit}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 October 1994
 ## Adapted-By: jwe
 
 function y = detrend (x, p = 1)
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -18,24 +18,25 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{d}, @var{dd}] =} diffpara (@var{x}, @var{a}, @var{b})
 ## Return the estimator @var{d} for the differencing parameter of an
 ## integrated time series.
 ##
 ## The frequencies from @math{[2*pi*a/t, 2*pi*b/T]} are used for the
 ## estimation.  If @var{b} is omitted, the interval
-## @math{[2*pi/T, 2*pi*a/T]} is used.  If both @var{b} and @var{a} are
-## omitted then @math{a = 0.5 * sqrt (T)} and @math{b = 1.5 * sqrt (T)}
-## is used, where @math{T} is the sample size.  If @var{x} is a matrix,
-## the differencing parameter of each column is estimated.
+## @math{[2*pi/T, 2*pi*a/T]} is used.  If both @var{b} and @var{a} are omitted
+## then @math{a = 0.5 * sqrt (T)} and @math{b = 1.5 * sqrt (T)} is used, where
+## @math{T} is the sample size.  If @var{x} is a matrix, the differencing
+## parameter of each column is estimated.
 ##
-## The estimators for all frequencies in the intervals
-## described above is returned in @var{dd}.  The value of @var{d} is
-## simply the mean of @var{dd}.
+## The estimators for all frequencies in the intervals described above is
+## returned in @var{dd}.
+##
+## The value of @var{d} is simply the mean of @var{dd}.
 ##
 ## Reference: @nospell{P.J. Brockwell & R.A. Davis}. @cite{Time Series:
 ## Theory and Methods}. Springer 1987.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the fractional differencing parameter
 
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -15,23 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} durbinlevinson (@var{c}, @var{oldphi}, @var{oldv})
 ## Perform one step of the @nospell{Durbin-Levinson} algorithm.
 ##
-## The vector @var{c} specifies the autocovariances @code{[gamma_0, @dots{},
-## gamma_t]} from lag 0 to @var{t}, @var{oldphi} specifies the
-## coefficients based on @var{c}(@var{t}-1) and @var{oldv} specifies the
-## corresponding error.
+## The vector @var{c} specifies the autocovariances
+## @code{[gamma_0, @dots{}, gamma_t]} from lag 0 to @var{t}, @var{oldphi}
+## specifies the coefficients based on @var{c}(@var{t}-1) and @var{oldv}
+## specifies the corresponding error.
 ##
-## If @var{oldphi} and @var{oldv} are omitted, all steps from 1 to
-## @var{t} of the algorithm are performed.
+## If @var{oldphi} and @var{oldv} are omitted, all steps from 1 to @var{t} of
+## the algorithm are performed.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Perform one step of the Durbin-Levinson algorithm
 
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
 
   if (nargin != 1 && nargin != 3)
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fftconv (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} fftconv (@var{x}, @var{y}, @var{n})
 ## Convolve two vectors using the FFT for computation.
 ##
 ## @code{c = fftconv (@var{x}, @var{y})} returns a vector of length equal to
-## @code{length (@var{x}) + length (@var{y}) - 1}.
-## If @var{x} and @var{y} are the coefficient vectors of two polynomials, the
-## returned value is the coefficient vector of the product polynomial.
+## @code{length (@var{x}) + length (@var{y}) - 1}.  If @var{x} and @var{y}
+## are the coefficient vectors of two polynomials, the returned value is the
+## coefficient vector of the product polynomial.
 ##
 ## The computation uses the FFT by calling the function @code{fftfilt}.  If
 ## the optional argument @var{n} is specified, an N-point FFT is used.
 ## @seealso{deconv, conv, conv2}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -14,28 +14,26 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fftfilt (@var{b}, @var{x})
 ## @deftypefnx {Function File} {} fftfilt (@var{b}, @var{x}, @var{n})
+## Filter @var{x} with the FIR filter @var{b} using the FFT.
 ##
-## With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
-## @var{b} using the FFT.
+## If @var{x} is a matrix, filter each column of the matrix.
 ##
 ## Given the optional third argument, @var{n}, @code{fftfilt} uses the
-## overlap-add method to filter @var{x} with @var{b} using an N-point
-## FFT@.  The FFT size must be an even power of 2 and must be greater than
-## or equal to the length of @var{b}.  If the specified @var{n} does not
-## meet these criteria, it is automatically adjusted to the nearest value
-## that does.
+## overlap-add method to filter @var{x} with @var{b} using an N-point FFT@.
+## The FFT size must be an even power of 2 and must be greater than or equal to
+## the length of @var{b}.  If the specified @var{n} does not meet these
+## criteria, it is automatically adjusted to the nearest value that does.
 ##
-## If @var{x} is a matrix, filter each column of the matrix.
 ## @seealso{filter, filter2}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function y = fftfilt (b, x, n)
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -14,36 +14,37 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fftshift (@var{x})
 ## @deftypefnx {Function File} {} fftshift (@var{x}, @var{dim})
-## Perform a shift of the vector @var{x}, for use with the @code{fft}
-## and @code{ifft} functions, in order the move the frequency 0 to the
-## center of the vector or matrix.
+## Perform a shift of the vector @var{x}, for use with the @code{fft} and
+## @code{ifft} functions, in order the move the frequency 0 to the center of
+## the vector or matrix.
 ##
-## If @var{x} is a vector of @math{N} elements corresponding to @math{N}
-## time samples spaced by @nospell{@math{dt}}, then
+## If @var{x} is a vector of @math{N} elements corresponding to @math{N} time
+## samples spaced by @nospell{@math{dt}}, then
 ## @code{fftshift (fft (@var{x}))} corresponds to frequencies
 ##
 ## @example
 ## f = [ -(ceil((N-1)/2):-1:1)*df 0 (1:floor((N-1)/2))*df ]
 ## @end example
 ##
 ## @noindent
 ## where @nospell{@math{df} = 1 / @math{dt}}.
 ##
-## If @var{x} is a matrix, the same holds for rows and columns.  If
-## @var{x} is an array, then the same holds along each dimension.
+## If @var{x} is a matrix, the same holds for rows and columns.  If @var{x}
+## is an array, then the same holds along each dimension.
 ##
-## The optional @var{dim} argument can be used to limit the dimension
-## along which the permutation occurs.
+## The optional @var{dim} argument can be used to limit the dimension along
+## which the permutation occurs.
+## @seealso{ifftshift}
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
 ## Adapted-By: jwe
 
 function retval = fftshift (x, dim)
 
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -14,33 +14,34 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
-## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
-## @var{shape} is specified, return an array of the desired shape.
-## Possible values are:
+## Apply the 2-D FIR filter @var{b} to @var{x}.
+##
+## If the argument @var{shape} is specified, return an array of the desired
+## shape.  Possible values are:
 ##
 ## @table @asis
 ## @item @qcode{"full"}
 ## pad @var{x} with zeros on all sides before filtering.
 ##
 ## @item @qcode{"same"}
 ## unpadded @var{x} (default)
 ##
 ## @item @qcode{"valid"}
 ## trim @var{x} after filtering so edge effects are no included.
 ## @end table
 ##
-## Note this is just a variation on convolution, with the parameters
-## reversed and @var{b} rotated 180 degrees.
+## Note this is just a variation on convolution, with the parameters reversed
+## and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## 2001-02-08
 ##    * initial release
 
 function y = filter2 (b, x, shape)
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -22,34 +22,34 @@
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a})
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n})
 ## @deftypefnx {Function File} {@var{h} =} freqz (@var{b}, @var{a}, @var{w})
 ## @deftypefnx {Function File} {[@var{h}, @var{w}] =} freqz (@dots{}, @var{Fs})
 ## @deftypefnx {Function File} {} freqz (@dots{})
 ##
 ## Return the complex frequency response @var{h} of the rational IIR filter
 ## whose numerator and denominator coefficients are @var{b} and @var{a},
-## respectively.  The response is evaluated at @var{n} angular frequencies
-## between 0 and
+## respectively.
+##
+## The response is evaluated at @var{n} angular frequencies between 0 and
 ## @ifnottex
 ## 2*pi.
 ## @end ifnottex
 ## @tex
 ## $2\pi$.
 ## @end tex
 ##
 ## @noindent
 ## The output value @var{w} is a vector of the frequencies.
 ##
 ## If @var{a} is omitted, the denominator is assumed to be 1 (this
 ## corresponds to a simple FIR filter).
 ##
-## If @var{n} is omitted, a value of 512 is assumed.
-## For fastest computation, @var{n} should factor into a small number of
-## small primes.
+## If @var{n} is omitted, a value of 512 is assumed.  For fastest computation,
+## @var{n} should factor into a small number of small primes.
 ##
 ## If the fourth argument, @qcode{"whole"}, is omitted the response is
 ## evaluated at frequencies between 0 and
 ## @ifnottex
 ## pi.
 ## @end ifnottex
 ## @tex
 ## $\pi$.
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} hamming (@var{m}, "symmetric")
 ## Return the filter coefficients of a Hamming window of length @var{m}.
 ##
 ## If the optional argument @qcode{"periodic"} is given, the periodic form
 ## of the window is returned.  This is equivalent to the window of length
 ## @var{m}+1 with the last coefficient removed.  The optional argument
 ## @qcode{"symmetric"} is equivalent to not specifying a second argument.
 ##
-## For a definition of the Hamming window, see e.g.,
+## For a definition of the Hamming window see, e.g.,
 ## @nospell{A.V. Oppenheim & R. W. Schafer},
 ## @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hamming window
 
 function c = hamming (m, opt)
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} hanning (@var{m}, "symmetric")
 ## Return the filter coefficients of a Hanning window of length @var{m}.
 ##
 ## If the optional argument @qcode{"periodic"} is given, the periodic form
 ## of the window is returned.  This is equivalent to the window of length
 ## @var{m}+1 with the last coefficient removed.  The optional argument
 ## @qcode{"symmetric"} is equivalent to not specifying a second argument.
 ##
-## For a definition of the Hanning window, see e.g.,
+## For a definition of the Hanning window see, e.g.,
 ## @nospell{A.V. Oppenheim & R. W. Schafer},
 ## @cite{Discrete-Time Signal Processing}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hanning window
 
 function c = hanning (m, opt)
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -14,18 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hurst (@var{x})
 ## Estimate the Hurst parameter of sample @var{x} via the rescaled range
-## statistic.  If @var{x} is a matrix, the parameter is estimated for
-## every single column.
+## statistic.
+##
+## If @var{x} is a matrix, the parameter is estimated for every column.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the Hurst parameter
 
 function H = hurst (x)
 
   if (nargin != 1)
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -14,19 +14,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ifftshift (@var{x})
 ## @deftypefnx {Function File} {} ifftshift (@var{x}, @var{dim})
-## Undo the action of the @code{fftshift} function.  For even length
-## @var{x}, @code{fftshift} is its own inverse, but odd lengths differ
-## slightly.
+## Undo the action of the @code{fftshift} function.
+##
+## For even length @var{x}, @code{fftshift} is its own inverse, but odd lengths
+## differ slightly.
+## @seealso{fftshift}
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
 ## Adapted-By: jwe
 ## Modified-By: Paul Kienzle, converted from fftshift
 ## Modified-By: David Bateman, add NDArray capability and option dim arg
 
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -20,17 +20,16 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{Pxx}, @var{w}] =} periodogram (@var{x})
 ## @deftypefnx {Function File} {[@var{Pxx}, @var{w}] =} periodogram (@var{x}, @var{win})
 ## @deftypefnx {Function File} {[@var{Pxx}, @var{w}] =} periodogram (@var{x}, @var{win}, @var{nfft})
 ## @deftypefnx {Function File} {[@var{Pxx}, @var{f}] =} periodogram (@var{x}, @var{win}, @var{nfft}, @var{Fs})
 ## @deftypefnx {Function File} {[@var{Pxx}, @var{f}] =} periodogram (@dots{}, "@var{range}")
 ## @deftypefnx {Function File} {} periodogram (@dots{})
-##
 ## Return the periodogram (Power Spectral Density) of @var{x}.
 ##
 ## The possible inputs are:
 ##
 ## @table @var
 ## @item x
 ##
 ## data vector.  If @var{x} is real-valued a one-sided spectrum is estimated.
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -13,16 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinc (@var{x})
+## Compute the sinc function.
+##
 ## Return
 ## @tex
 ## $ \sin (\pi x)/(\pi x)$.
 ## @end tex
 ## @ifnottex
 ##  sin (pi*x) / (pi*x).
 ## @end ifnottex
 ## @end deftypefn
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -13,21 +13,23 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinetone (@var{freq}, @var{rate}, @var{sec}, @var{ampl})
-## Return a sinetone of frequency @var{freq} with length of @var{sec}
+## Return a sinetone of frequency @var{freq} with a length of @var{sec}
 ## seconds at sampling rate @var{rate} and with amplitude @var{ampl}.
+##
 ## The arguments @var{freq} and @var{ampl} may be vectors of common size.
 ##
-## Defaults are @var{rate} = 8000, @var{sec} = 1 and @var{ampl} = 64.
+## The defaults are @var{rate} = 8000, @var{sec} = 1, and @var{ampl} = 64.
+## @seealso{sinewave}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute a sine tone
 
 function retval = sinetone (freq, rate = 8000, sec = 1, ampl = 64)
 
   if (nargin < 1 || nargin > 4)
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -16,18 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinewave (@var{m}, @var{n}, @var{d})
 ## Return an @var{m}-element vector with @var{i}-th element given by
 ## @code{sin (2 * pi * (@var{i}+@var{d}-1) / @var{n})}.
 ##
-## The default value for @var{d} is 0 and the default value for @var{n}
-## is @var{m}.
+## The default value for @var{d} is 0 and the default value for @var{n} is
+## @var{m}.
+## @seealso{sinetone}
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Compute a sine wave
 
 function x = sinewave (m, n, d)
 
   if (nargin > 0 && nargin < 4)
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -15,25 +15,25 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} spectral_adf (@var{c})
 ## @deftypefnx {Function File} {} spectral_adf (@var{c}, @var{win})
 ## @deftypefnx {Function File} {} spectral_adf (@var{c}, @var{win}, @var{b})
-## Return the spectral density estimator given a vector of
-## autocovariances @var{c}, window name @var{win}, and bandwidth,
-## @var{b}.
+## Return the spectral density estimator given a vector of autocovariances
+## @var{c}, window name @var{win}, and bandwidth, @var{b}.
 ##
 ## The window name, e.g., @qcode{"triangle"} or @qcode{"rectangle"} is
 ## used to search for a function called @code{@var{win}_lw}.
 ##
-## If @var{win} is omitted, the triangle window is used.  If @var{b} is
-## omitted, @code{1 / sqrt (length (@var{x}))} is used.
+## If @var{win} is omitted, the triangle window is used.
+##
+## If @var{b} is omitted, @code{1 / sqrt (length (@var{x}))} is used.
 ## @seealso{spectral_xdf}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
 function retval = spectral_adf (c, win, b)
 
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -15,24 +15,25 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} spectral_xdf (@var{x})
 ## @deftypefnx {Function File} {} spectral_xdf (@var{x}, @var{win})
 ## @deftypefnx {Function File} {} spectral_xdf (@var{x}, @var{win}, @var{b})
-## Return the spectral density estimator given a data vector @var{x},
-## window name @var{win}, and bandwidth, @var{b}.
+## Return the spectral density estimator given a data vector @var{x}, window
+## name @var{win}, and bandwidth, @var{b}.
 ##
-## The window name, e.g., @qcode{"triangle"} or @qcode{"rectangle"} is
-## used to search for a function called @code{@var{win}_sw}.
+## The window name, e.g., @qcode{"triangle"} or @qcode{"rectangle"} is used to
+## search for a function called @code{@var{win}_sw}.
 ##
-## If @var{win} is omitted, the triangle window is used.  If @var{b} is
-## omitted, @code{1 / sqrt (length (@var{x}))} is used.
+## If @var{win} is omitted, the triangle window is used.
+##
+## If @var{b} is omitted, @code{1 / sqrt (length (@var{x}))} is used.
 ## @seealso{spectral_adf}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
 function retval = spectral_xdf (x, win, b)
 
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -13,18 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spencer (@var{x})
-## Return Spencer's 15 point moving average of each column of
-## @var{x}.
+## Return Spencer's 15 point moving average of each column of @var{x}.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Apply Spencer's 15-point MA filter
 
 function retval = spencer (x)
 
   if (nargin != 1)
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -42,24 +42,23 @@
 ## @end table
 ##
 ## The window names can be passed as strings or by the @var{win_type} number.
 ##
 ## The following defaults are used for unspecified arguments:
 ## @var{win_size} = 80, @var{inc} = 24, @var{num_coef} = 64, and
 ## @var{win_type} = 1.
 ##
-## @code{@var{y} = stft (@var{x}, @dots{})} returns the absolute values
-## of the Fourier coefficients according to the @var{num_coef} positive
-## frequencies.
+## @code{@var{y} = stft (@var{x}, @dots{})} returns the absolute values of the
+## Fourier coefficients according to the @var{num_coef} positive frequencies.
 ##
-## @code{[@var{y}, @var{c}] = stft (@code{x}, @dots{})} returns the
-## entire STFT-matrix @var{y} and a 3-element vector @var{c} containing
-## the window size, increment, and window type, which is needed by the
-## @code{synthesis} function.
+## @code{[@var{y}, @var{c}] = stft (@code{x}, @dots{})} returns the entire
+## STFT-matrix @var{y} and a 3-element vector @var{c} containing the window
+## size, increment, and window type, which is needed by the @code{synthesis}
+## function.
 ## @seealso{synthesis}
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Short-Time Fourier Transform
 
 function [y, c] = stft (x, win_size = 80, inc = 24, num_coef = 64, win_type = 1)
 
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -14,18 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} synthesis (@var{y}, @var{c})
 ## Compute a signal from its short-time Fourier transform @var{y} and a
-## 3-element vector @var{c} specifying window size, increment, and
-## window type.
+## 3-element vector @var{c} specifying window size, increment, and window type.
 ##
 ## The values @var{y} and @var{c} can be derived by
 ##
 ## @example
 ## [@var{y}, @var{c}] = stft (@var{x} , @dots{})
 ## @end example
 ## @seealso{stft}
 ## @end deftypefn
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -16,18 +16,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{b} =} unwrap (@var{x})
 ## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol})
 ## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol}, @var{dim})
 ##
-## Unwrap radian phases by adding multiples of 2*pi as appropriate to
-## remove jumps greater than @var{tol}.  @var{tol} defaults to pi.
+## Unwrap radian phases by adding multiples of 2*pi as appropriate to remove
+## jumps greater than @var{tol}.
+##
+## @var{tol} defaults to pi.
 ##
 ## Unwrap will work along the dimension @var{dim}.  If @var{dim}
 ## is unspecified it defaults to the first non-singleton dimension.
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 
 function retval = unwrap (x, tol, dim)
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{v}] =} yulewalker (@var{c})
-## Fit an AR (p)-model with Yule-Walker estimates given a vector @var{c}
-## of autocovariances @code{[gamma_0, @dots{}, gamma_p]}.
+## Fit an AR (p)-model with Yule-Walker estimates given a vector @var{c} of
+## autocovariances @code{[gamma_0, @dots{}, gamma_p]}.
 ##
-## Returns the AR coefficients, @var{a}, and the variance of white
-## noise, @var{v}.
+## Returns the AR coefficients, @var{a}, and the variance of white noise,
+## @var{v}.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Fit AR model by Yule-Walker method
 
 function [a, v] = yulewalker (c)
 
   if (nargin != 1)
