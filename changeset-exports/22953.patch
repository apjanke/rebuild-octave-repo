# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1482806644 18000
#      Mon Dec 26 21:44:04 2016 -0500
# Node ID fd649fd3db75f6eb7675dbb9c81c0b2083895ecc
# Parent  7c9492d3b42135df89a60bea342b578ddc66d15b
use F77_INT instead of octave_idx_type for liboctave EIG classes

* EIG.cc, fEIG.cc: Use F77_INT instead of octave_idx_type for integer
data passed to Fortran subroutines.

diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -35,58 +35,59 @@ EIG::init (const Matrix& a, bool calc_re
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_rev, calc_lev);
 
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   Array<double> wr (dim_vector (n, 1));
   double *pwr = wr.fortran_vec ();
 
   Array<double> wi (dim_vector (n, 1));
   double *pwi = wi.fortran_vec ();
 
-  octave_idx_type tnvr = calc_rev ? n : 0;
+  F77_INT tnvr = calc_rev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
-  octave_idx_type tnvl = calc_lev ? n : 0;
+  F77_INT tnvl = calc_lev ? n : 0;
   Matrix vl (tnvl, tnvl);
   double *pvl = vl.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   double dummy_work;
 
-  octave_idx_type ilo;
-  octave_idx_type ihi;
+  F77_INT ilo;
+  F77_INT ihi;
 
   Array<double> scale (dim_vector (n, 1));
   double *pscale = scale.fortran_vec ();
 
   double abnrm;
 
   Array<double> rconde (dim_vector (n, 1));
   double *prconde = rconde.fortran_vec ();
 
   Array<double> rcondv (dim_vector (n, 1));
   double *prcondv = rcondv.fortran_vec ();
 
-  octave_idx_type dummy_iwork;
+  F77_INT dummy_iwork;
 
   F77_XFCN (dgeevx, DGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, tmp_data, n, pwr, pwi, pvl,
                              n, pvr, n, ilo, ihi, pscale,
                              abnrm, prconde, prcondv, &dummy_work,
@@ -94,17 +95,17 @@ EIG::init (const Matrix& a, bool calc_re
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dgeevx workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dgeevx, DGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, tmp_data, n, pwr, pwi, pvl,
@@ -118,91 +119,92 @@ EIG::init (const Matrix& a, bool calc_re
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeevx");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dgeevx failed to converge");
 
   lambda.resize (n);
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   v.resize (nvr, nvr);
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   w.resize (nvl, nvl);
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     {
       if (wi.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (wr.elem (j));
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
 
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
           lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
 
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             {
               double real_part = vr.elem (i, j);
               double imag_part = vr.elem (i, j+1);
               v.elem (i, j) = Complex (real_part, imag_part);
               v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
 
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             {
               double real_part = vl.elem (i, j);
               double imag_part = vl.elem (i, j+1);
               w.elem (i, j) = Complex (real_part, imag_part);
               w.elem (i, j+1) = Complex (real_part, -imag_part);
             }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dsyev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
@@ -225,46 +227,47 @@ EIG::init (const ComplexMatrix& a, bool 
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_rev, calc_lev);
 
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ComplexColumnVector wr (n);
   Complex *pw = wr.fortran_vec ();
 
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   ComplexMatrix vrtmp (nvr, nvr);
   Complex *pvr = vrtmp.fortran_vec ();
 
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   ComplexMatrix vltmp (nvl, nvl);
   Complex *pvl = vltmp.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   Complex dummy_work;
 
-  octave_idx_type lrwork = 2*n;
+  F77_INT lrwork = 2*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
-  octave_idx_type ilo;
-  octave_idx_type ihi;
+  F77_INT ilo;
+  F77_INT ihi;
 
   Array<double> scale (dim_vector (n, 1));
   double *pscale = scale.fortran_vec ();
 
   double abnrm;
 
   Array<double> rconde (dim_vector (n, 1));
   double *prconde = rconde.fortran_vec ();
@@ -284,17 +287,17 @@ EIG::init (const ComplexMatrix& a, bool 
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zgeevx workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgeevx, ZGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, F77_DBLE_CMPLX_ARG (tmp_data), n,
@@ -318,48 +321,49 @@ EIG::init (const ComplexMatrix& a, bool 
   w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   Complex dummy_work;
 
-  octave_idx_type lrwork = 3*n;
+  F77_INT lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr,
                            F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zheev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr,
                            F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
@@ -381,26 +385,29 @@ EIG::hermitian_init (const ComplexMatrix
 octave_idx_type
 EIG::init (const Matrix& a, const Matrix& b, bool calc_rev, bool calc_lev,
            bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+    
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   Matrix tmp = b;
   double *tmp_data = tmp.fortran_vec ();
 
   if (! force_qz)
     {
       F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                                  n, tmp_data, n,
@@ -421,40 +428,40 @@ EIG::init (const Matrix& a, const Matrix
   double *par = ar.fortran_vec ();
 
   Array<double> ai (dim_vector (n, 1));
   double *pai = ai.fortran_vec ();
 
   Array<double> beta (dim_vector (n, 1));
   double *pbeta = beta.fortran_vec ();
 
-  octave_idx_type tnvr = calc_rev ? n : 0;
+  F77_INT tnvr = calc_rev ? n : 0;
   Matrix vr (tnvr, tnvr);
   double *pvr = vr.fortran_vec ();
 
-  octave_idx_type tnvl = calc_lev ? n : 0;
+  F77_INT tnvl = calc_lev ? n : 0;
   Matrix vl (tnvl, tnvl);
   double *pvl = vl.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   double dummy_work;
 
   F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            pvl, n, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dggev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            pvl, n, pvr, n,
@@ -464,50 +471,50 @@ EIG::init (const Matrix& a, const Matrix
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("dggev failed to converge");
 
   lambda.resize (n);
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   v.resize (nvr, nvr);
 
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   w.resize (nvl, nvl);
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     {
       if (ai.elem (j) == 0.0)
         {
           lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j));
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
                                      ai.elem (j) / beta.elem (j));
           lambda.elem (j+1) = Complex (ar.elem (j+1) / beta.elem (j+1),
                                        ai.elem (j+1) / beta.elem (j+1));
 
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             {
               double real_part = vr.elem (i, j);
               double imag_part = vr.elem (i, j+1);
               v.elem (i, j) = Complex (real_part, imag_part);
               v.elem (i, j+1) = Complex (real_part, -imag_part);
             }
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             {
               double real_part = vl.elem (i, j);
               double imag_part = vl.elem (i, j+1);
               w.elem (i, j) = Complex (real_part, imag_part);
               w.elem (i, j+1) = Complex (real_part, -imag_part);
             }
           j++;
         }
@@ -515,51 +522,54 @@ EIG::init (const Matrix& a, const Matrix
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_rev,
                      bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   Matrix atmp = a;
   double *atmp_data = atmp.fortran_vec ();
 
   Matrix btmp = b;
   double *btmp_data = btmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("dsygv workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<double> work (dim_vector (lwork, 1));
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, pwork, lwork, info
@@ -582,26 +592,29 @@ EIG::symmetric_init (const Matrix& a, co
 octave_idx_type
 EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_rev,
            bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
   if (! force_qz)
     {
       F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                                  n, F77_DBLE_CMPLX_ARG (tmp_data), n,
@@ -619,28 +632,28 @@ EIG::init (const ComplexMatrix& a, const
   Complex *btmp_data = btmp.fortran_vec ();
 
   ComplexColumnVector alpha (n);
   Complex *palpha = alpha.fortran_vec ();
 
   ComplexColumnVector beta (n);
   Complex *pbeta = beta.fortran_vec ();
 
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   ComplexMatrix vrtmp (nvr, nvr);
   Complex *pvr = vrtmp.fortran_vec ();
 
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   ComplexMatrix vltmp (nvl, nvl);
   Complex *pvl = vltmp.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   Complex dummy_work;
 
-  octave_idx_type lrwork = 8*n;
+  F77_INT lrwork = 8*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            F77_DBLE_CMPLX_ARG (palpha),
@@ -649,17 +662,17 @@ EIG::init (const ComplexMatrix& a, const
                            F77_DBLE_CMPLX_ARG (pvr), n,
                            F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n,  F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            F77_DBLE_CMPLX_ARG (palpha),
@@ -673,69 +686,72 @@ EIG::init (const ComplexMatrix& a, const
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zggev failed to converge");
 
   lambda.resize (n);
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
   v = vrtmp;
   w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b,
                      bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *atmp_data = atmp.fortran_vec ();
 
   ComplexMatrix btmp = b;
   Complex *btmp_data = btmp.fortran_vec ();
 
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   Complex dummy_work;
 
-  octave_idx_type lrwork = 3*n;
+  F77_INT lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            pwr, F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            pwr, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -36,58 +36,59 @@ FloatEIG::init (const FloatMatrix& a, bo
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_rev, calc_lev);
 
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
   Array<float> wr (dim_vector (n, 1));
   float *pwr = wr.fortran_vec ();
 
   Array<float> wi (dim_vector (n, 1));
   float *pwi = wi.fortran_vec ();
 
-  volatile octave_idx_type nvr = calc_rev ? n : 0;
+  volatile F77_INT nvr = calc_rev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
-  volatile octave_idx_type nvl = calc_lev ? n : 0;
+  volatile F77_INT nvl = calc_lev ? n : 0;
   FloatMatrix vl (nvl, nvl);
   float *pvl = vl.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   float dummy_work;
 
-  octave_idx_type ilo;
-  octave_idx_type ihi;
+  F77_INT ilo;
+  F77_INT ihi;
 
   Array<float> scale (dim_vector (n, 1));
   float *pscale = scale.fortran_vec ();
 
   float abnrm;
 
   Array<float> rconde (dim_vector (n, 1));
   float *prconde = rconde.fortran_vec ();
 
   Array<float> rcondv (dim_vector (n, 1));
   float *prcondv = rcondv.fortran_vec ();
 
-  octave_idx_type dummy_iwork;
+  F77_INT dummy_iwork;
 
   F77_XFCN (sgeevx, SGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, tmp_data, n, pwr, pwi,
                              pvl, n, pvr, n,
                              ilo, ihi, pscale, abnrm, prconde, prcondv,
@@ -95,17 +96,17 @@ FloatEIG::init (const FloatMatrix& a, bo
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("sgeevx workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (sgeevx, SGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, tmp_data, n, pwr, pwi,
@@ -122,85 +123,86 @@ FloatEIG::init (const FloatMatrix& a, bo
 
   if (info > 0)
     (*current_liboctave_error_handler) ("sgeevx failed to converge");
 
   lambda.resize (n);
   v.resize (nvr, nvr);
   w.resize (nvl, nvl);
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     {
       if (wi.elem (j) == 0.0)
         {
           lambda.elem (j) = FloatComplex (wr.elem (j));
           for (octave_idx_type i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
 
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
           lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
 
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             {
               float real_part = vr.elem (i, j);
               float imag_part = vr.elem (i, j+1);
               v.elem (i, j) = FloatComplex (real_part, imag_part);
               v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             {
               float real_part = vl.elem (i, j);
               float imag_part = vl.elem (i, j+1);
               w.elem (i, j) = FloatComplex (real_part, imag_part);
               w.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
           j++;
         }
     }
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   float dummy_work;
 
   F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("ssyev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (ssyev, SSYEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, tmp_data, n, pwr, pwork, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
@@ -224,46 +226,47 @@ FloatEIG::init (const FloatComplexMatrix
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_rev, calc_lev);
 
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
   FloatComplexColumnVector wr (n);
   FloatComplex *pw = wr.fortran_vec ();
 
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   FloatComplexMatrix vrtmp (nvr, nvr);
   FloatComplex *pvr = vrtmp.fortran_vec ();
 
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   FloatComplexMatrix vltmp (nvl, nvl);
   FloatComplex *pvl = vltmp.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   FloatComplex dummy_work;
 
-  octave_idx_type lrwork = 2*n;
+  F77_INT lrwork = 2*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
-  octave_idx_type ilo;
-  octave_idx_type ihi;
+  F77_INT ilo;
+  F77_INT ihi;
 
   Array<float> scale (dim_vector (n, 1));
   float *pscale = scale.fortran_vec ();
 
   float abnrm;
 
   Array<float> rconde (dim_vector (n, 1));
   float *prconde = rconde.fortran_vec ();
@@ -282,17 +285,17 @@ FloatEIG::init (const FloatComplexMatrix
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cgeevx workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cgeevx, CGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw),
@@ -316,48 +319,49 @@ FloatEIG::init (const FloatComplexMatrix
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a, bool calc_rev,
                           bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT a_nc = to_f77_int (a.cols ());
 
-  if (n != a.cols ())
+  if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   FloatComplex dummy_work;
 
-  octave_idx_type lrwork = 3*n;
+  F77_INT lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (tmp_data), n, pwr,
                            F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cheev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (tmp_data), n, pwr,
                            F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
@@ -379,26 +383,29 @@ FloatEIG::hermitian_init (const FloatCom
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_rev,
                 bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatMatrix tmp = b;
   float *tmp_data = tmp.fortran_vec ();
   if (! force_qz)
     {
       F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                                  n, tmp_data, n,
                                  info
@@ -418,40 +425,40 @@ FloatEIG::init (const FloatMatrix& a, co
   float *par = ar.fortran_vec ();
 
   Array<float> ai (dim_vector (n, 1));
   float *pai = ai.fortran_vec ();
 
   Array<float> beta (dim_vector (n, 1));
   float *pbeta = beta.fortran_vec ();
 
-  volatile octave_idx_type nvr = calc_rev ? n : 0;
+  volatile F77_INT nvr = calc_rev ? n : 0;
   FloatMatrix vr (nvr, nvr);
   float *pvr = vr.fortran_vec ();
 
-  volatile octave_idx_type nvl = calc_lev ? n : 0;
+  volatile F77_INT nvl = calc_lev ? n : 0;
   FloatMatrix vl (nvl, nvl);
   float *pvl = vl.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   float dummy_work;
 
   F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            pvl, n, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("sggev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            pvl, n, pvr, n,
@@ -465,45 +472,45 @@ FloatEIG::init (const FloatMatrix& a, co
   if (info > 0)
     (*current_liboctave_error_handler) ("sggev failed to converge");
 
   lambda.resize (n);
   v.resize (nvr, nvr);
   w.resize (nvl, nvl);
 
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     {
       if (ai.elem (j) == 0.0)
         {
           lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j));
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             v.elem (i, j) = vr.elem (i, j);
 
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             w.elem (i, j) = vl.elem (i, j);
         }
       else
         {
           if (j+1 >= n)
             (*current_liboctave_error_handler) ("EIG: internal error");
 
           lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
                                           ai.elem (j) / beta.elem (j));
           lambda.elem (j+1) = FloatComplex (ar.elem (j+1) / beta.elem (j+1),
                                             ai.elem (j+1) / beta.elem (j+1));
 
-          for (octave_idx_type i = 0; i < nvr; i++)
+          for (F77_INT i = 0; i < nvr; i++)
             {
               float real_part = vr.elem (i, j);
               float imag_part = vr.elem (i, j+1);
               v.elem (i, j) = FloatComplex (real_part, imag_part);
               v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
-          for (octave_idx_type i = 0; i < nvl; i++)
+          for (F77_INT i = 0; i < nvl; i++)
             {
               float real_part = vl.elem (i, j);
               float imag_part = vl.elem (i, j+1);
               w.elem (i, j) = FloatComplex (real_part, imag_part);
               w.elem (i, j+1) = FloatComplex (real_part, -imag_part);
             }
           j++;
         }
@@ -511,51 +518,54 @@ FloatEIG::init (const FloatMatrix& a, co
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
                           bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatMatrix atmp = a;
   float *atmp_data = atmp.fortran_vec ();
 
   FloatMatrix btmp = b;
   float *btmp_data = btmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   float dummy_work;
 
   F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("ssygv workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work);
+  lwork = static_cast<F77_INT> (dummy_work);
   Array<float> work (dim_vector (lwork, 1));
   float *pwork = work.fortran_vec ();
 
   F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, atmp_data, n,
                            btmp_data, n,
                            pwr, pwork, lwork, info
@@ -578,26 +588,29 @@ FloatEIG::symmetric_init (const FloatMat
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                 bool calc_rev, bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
   if (! force_qz)
     {
       F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
                                  n, F77_CMPLX_ARG (tmp_data), n,
@@ -615,45 +628,45 @@ FloatEIG::init (const FloatComplexMatrix
   FloatComplex *btmp_data = btmp.fortran_vec ();
 
   FloatComplexColumnVector alpha (n);
   FloatComplex *palpha = alpha.fortran_vec ();
 
   FloatComplexColumnVector beta (n);
   FloatComplex *pbeta = beta.fortran_vec ();
 
-  octave_idx_type nvr = calc_rev ? n : 0;
+  F77_INT nvr = calc_rev ? n : 0;
   FloatComplexMatrix vrtmp (nvr, nvr);
   FloatComplex *pvr = vrtmp.fortran_vec ();
 
-  octave_idx_type nvl = calc_lev ? n : 0;
+  F77_INT nvl = calc_lev ? n : 0;
   FloatComplexMatrix vltmp (nvl, nvl);
   FloatComplex *pvl = vltmp.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   FloatComplex dummy_work;
 
-  octave_idx_type lrwork = 8*n;
+  F77_INT lrwork = 8*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta),
                            F77_CMPLX_ARG (pvl), n, F77_CMPLX_ARG (pvr), n,
                            F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta),
@@ -665,70 +678,73 @@ FloatEIG::init (const FloatComplexMatrix
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cggev failed to converge");
 
   lambda.resize (n);
 
-  for (octave_idx_type j = 0; j < n; j++)
+  for (F77_INT j = 0; j < n; j++)
     lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
   v = vrtmp;
   w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a,
                           const FloatComplexMatrix& b,
                           bool calc_rev, bool calc_lev)
 {
-  octave_idx_type n = a.rows ();
-  octave_idx_type nb = b.rows ();
+  F77_INT n = to_f77_int (a.rows ());
+  F77_INT nb = to_f77_int (b.rows ());
 
-  if (n != a.cols () || nb != b.cols ())
+  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT b_nc = to_f77_int (b.cols ());
+
+  if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
-  octave_idx_type info = 0;
+  F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *atmp_data = atmp.fortran_vec ();
 
   FloatComplexMatrix btmp = b;
   FloatComplex *btmp_data = btmp.fortran_vec ();
 
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
-  octave_idx_type lwork = -1;
+  F77_INT lwork = -1;
   FloatComplex dummy_work;
 
-  octave_idx_type lrwork = 3*n;
+  F77_INT lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            pwr, F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
-  lwork = static_cast<octave_idx_type> (dummy_work.real ());
+  lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
                            n, F77_CMPLX_ARG (atmp_data), n,
                            F77_CMPLX_ARG (btmp_data), n,
                            pwr, F77_CMPLX_ARG (pwork), lwork, prwork, info
