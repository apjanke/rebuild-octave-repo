# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1327263202 18000
#      Sun Jan 22 15:13:22 2012 -0500
# Branch gui
# Node ID 14d602c4f6e82802bb53053611688058e659d8be
# Parent  995c69c217e579a964757e29e1746985196ed418
# Parent  27abe77158d6142f80e73d9df2210f770c1394aa
Merge default onto gui

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-ff549c078493ea86e7bd87526db276a1b94a411a gnulib
+f9813bce2c06a6130a68db4478d1b16ddadaf276 gnulib
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -48,8 +48,14 @@ 79a56d0a6a0d693ebf461c456951b20dfbcde140
 229675bb7647f7e7e499bcb5acacc8eabe7f3697 ss-3-3-52
 6c69a7c39039bccd5a2fe481fcc7f896c82b160b ss-3-3-53
 3cbc0d77db48aec32bcb202d09a036d2cb9cc3b9 ss-3-3-53
 bd2643f0ce57d070963bedd48857405f6924aa85 ss-3-3-54
 695141f1c05cf1b240592bdd18e7a1503bb2a539 ss-3-3-55
 901d466ee55ac902a875ec0ade6f1eccef0841dc release-3-4-1
 3666e8e6f96e6899b8306d6ea9614aadf0500d67 release-3-4-2
 b0e70a71647b671ebcfa7a79af1ae6d3c0f52065 release-3-4-3
+3781981be535e80d44c85373b8fdaa60ca5cd097 ss-3-5-90
+ff5588774680d4f54567311fc109c8e351950f1c ss-3-5-91
+a737b3fb9c4d89d3694da6b4e623aeee64b212e1 ss-3-5-92
+72aebe6196414e38ef802469ff6e238f914f04c9 rc-3-6-0-0
+64d9f33313cc8c691974bcd123357e24bccbabdc rc-3-6-0-1
+704f7895eef03008dd79848eb9da4bfb40787d73 release-3.6.0
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,146 +1,198 @@
 Summary of important user-visible changes for version 4.0:
 ---------------------------------------------------------
 
  ** A new GUI is now available with Octave.
 
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
- ** The PCRE library is now required to build Octave.
+ ** The PCRE library is now required to build Octave.  If a pre-compiled
+    package does not exist for your system, you can find PCRE sources
+    at http://www.pcre.org
 
- ** The following binary elementwise operators and functions now perform
-    Numpy-like broadcasting (a.k.a. binary singleton expansion):
+ ** The ARPACK library is no longer distributed with Octave.
+    If you need the eigs or svds functions you must provide an
+    external ARPACK through a package manager or by compiling it
+    yourself.  If a pre-compiled package does not exist for your system,
+    you can find the current ARPACK sources at
+    http://forge.scilab.org/index.php/p/arpack-ng
 
-    plus      ldivide   rem    eq    gt     xor
-    minus     power     mod    ne    ge
-    times     max       atan2  lt    and
-    rdivide   min       hypot  le    or
+ ** Many of Octave's binary operators (.*, .^, +, -, ...) now perform
+    automatic broadcasting for array operations that allows you to use
+    operator notation instead of calling bsxfun or expanding arrays (and
+    unnecessarily wasting memory) with repmat or similar idioms.  For
+    example, to scale the columns of a matrix by the elements of a row
+    vector, you may now write
+
+      rv .* M
+
+    In this expression, the number of elements of rv must match the
+    number of columns of M.  The following operators are affected:
 
-    +         .*        &
-    -         ./        |
-    .+        .\
-    .-        .^
+      plus      +  .+
+      minus     -  .-
+      times     .*
+      rdivide   ./
+      ldivide   .\
+      power     .^  .**
+      lt        <
+      le        <=
+      eq        ==
+      gt        >
+      ge        >=
+      ne        !=  ~=
+      and       &
+      or        |
+      atan2
+      hypot
+      max
+      min
+      mod
+      rem
+      xor
 
-    +=        .*=       &=
-    -=        ./=       |=
-    .+=       .\=
-    .-=       .^=
+    additionally, since the A op= B assginment operators are equivalent
+    to A = A op B, the following operators are also affected:
 
-    This makes the bsxfun function mostly redundant except for
-    user-defined functions.  A new section in the manual has been written
-    to explain and clarify this change.
+      +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
+
+    See the "Broadcasting" section in the new "Vectorization and Faster
+    Code Execution" chapter of the manual for more details.
 
  ** Octave now features a profiler, thanks to the work of Daniel Kraft
     under the Google Summer of Code mentorship program.  The manual has
     been updated to reflect this addition.  The new user-visible
-    functions are profexplore, profile, and profshow.
+    functions are profile, profshow, and profexplore.
 
  ** Overhaul of statistical distribution functions
 
     Functions now return "single" outputs for inputs of class "single".
 
     75% reduction in memory usage through use of logical indexing.
 
-    Random sample functions now use the same syntax as rand() and accept
+    Random sample functions now use the same syntax as rand and accept
     a comma separated list of dimensions or a dimension vector.
 
     Functions have been made Matlab-compatible with regard to special
     cases (probability on boundaries, probabilities for values outside
     distribution, etc.).  This may cause subtle changes to existing
     scripts.
 
-    negative binomial function has been extended to real, non-integer inputs.
-    discrete_inv() now returns v(1) for 0 instead of NaN.
-    nbincdf() recoded to use closed form solution with betainc().
+    negative binomial function has been extended to real, non-integer
+    inputs.  The discrete_inv fucntion now returns v(1) for 0 instead of
+    NaN.  The nbincdf fucntion has bbeen recoded to use a closed form
+    solution with betainc.
 
  ** strread, textscan, and textread have been completely revamped.
 
     They now support nearly all Matlab functionality including:
 
-    * ML-compatible whitespace and delimiter defaults
+      * Matlab-compatible whitespace and delimiter defaults
+
+      * Matlab-compatible options: 'whitespace', treatasempty', format
+        string repeat count, user-specified comment style, uneven-length
+        output arrays, %n and %u conversion specifiers (provisionally)
 
-    * ML-compatible options: 'whitespace', treatasempty',
-    format string repeat count, user-specified comment style, uneven-length
-    output arrays, %n and %u conversion specifiers (provisionally)
+ ** All .m string functions have been modified for better performance or
+    greater Matlab compatibility.  Performance gains of 15X-30X have
+    been demonstrated.  Operations on cell array of strings no longer pay
+    quite as high a penalty as those on 2-D character arrays.
 
- ** All .m string functions have been modified for better performance or greater
-    Matlab compatibility.  Performance gains of 15X-30X have been demonstrated.
-    Operations on cell array of strings no longer pay quite as high a penalty
-    as those on 2-D character arrays.
+      deblank:  Now requires character or cellstr input.
+
+      strtrim:  Now requires character or cellstr input.
+                No longer trims nulls ("\0") from string for Matlab
+                compatibility.
 
-    deblank:  Now requires character or cellstr input.
-    strtrim:  Now requires character or cellstr input.
-              No longer trims nulls ("\0") from string for ML compatibility.
-    strmatch: Follows documentation precisely and ignores trailing spaces
-              in pattern and in string.  Note that Matlab documents this 
-              behavior but the implementation does *not* always follow it.
-    substr:   Now possible to specify a negative LEN option which extracts
-              to within LEN of the end of the string.
-    strtok:   Now accepts cellstr input.
-    base2dec, bin2dec, hex2dec: Now accept cellstr inputs.
-    dec2base, dec2bin, dec2hex: Now accept cellstr inputs.
-    index, rindex: Now accept 2-D character array input.
-    strsplit: Now accepts 2-D character array input.
+      strmatch: Follows documentation precisely and ignores trailing spaces
+                in pattern and in string.  Note that this is documented
+                Matlab behavior but the implementation apparently does
+                not always follow it.
+
+      substr:   Now possible to specify a negative LEN option which
+                extracts to within LEN of the end of the string.
+
+      strtok:   Now accepts cellstr input.
+
+      base2dec, bin2dec, hex2dec:
+                Now accept cellstr inputs.
+
+      dec2base, dec2bin, dec2hex:
+                Now accept cellstr inputs.
+
+      index, rindex:
+                Now accept 2-D character array input.
+
+      strsplit: Now accepts 2-D character array input.
 
  ** Geometry functions derived from Qhull (convhull, delaunay, voronoi)
-    have been revamped.  The options passed to the underlying qhull command
-    have been changed for better results or for Matlab compatibility.
+    have been revamped.  The options passed to the underlying qhull
+    command have been changed for better results or for Matlab
+    compatibility.
+
+      convhull: Default options are "Qt" for 2D, 3D, 4D inputs
+                Default options are "Qt Qx" for 5D and higher
+
+      delaunay: Default options are "Qt Qbb Qc Qz" for 2D and 3D inputs
+                Default options are "Qt Qbb Qc Qx" for 4D and higher
 
-    convhull : Default options are "Qt" for 2D, 3D, 4D inputs
-               Default options are "Qt Qx" for 5D and higher
-    delaunay : Default options are "Qt Qbb Qc Qz" for 2D and 3D inputs
-               Default options are "Qt Qbb Qc Qx" for 4D and higher
-    voronoi  : No default arguments
+      voronoi:  No default arguments
+
+ ** Date/Time functions updated.  Millisecond support with FFF format
+    string now supported.
 
- ** Date/Time functions updated.
-    Millisecond support with FFF format string now supported.
+    datestr: Numerical formats 21, 22, 29 changed to match Matlab.
+             Now accepts cellstr inputs.
 
-    datestr : Numerical formats 21, 22, 29 changed to match Matlab.
-              Now accepts cellstr inputs.
+ ** The following warning IDs have been removed:
 
- ** Octave warning IDs updated
-    "associativity-change": removed
-    "complex-cmp-ops"     : removed
-    "empty-list-elements" : removed
-    "fortran-indexing"    : removed
-    "precedence-change"   : removed
-    "string-concat"       : renamed to "mixed-string-concat"
+      Octave:associativity-change
+      Octave:complex-cmp-ops
+      Octave:empty-list-elements
+      Octave:fortran-indexing
+      Octave:precedence-change
+      
+ ** The warning ID Octave:string-concat has been renamed to
+    Octave:mixed-string-concat.
 
- ** Matlab-compatible preference functions added:
+ ** Octave now includes the following Matlab-compatible preference
+    functions:
 
-    addpref  getpref  ispref  rmpref  setpref
+      addpref  getpref  ispref  rmpref  setpref
 
- ** Matlab-compatible handle graphics functions added:
+ ** The following Matlab-compatible handle graphics functions have been
+    added:
 
-    guidata         uipanel        uitoolbar
-    guihandles      uipushtool     uiwait
-    uicontextmenu   uiresume       waitfor
-    uicontrol       uitoggletool
+      guidata         uipanel        uitoolbar
+      guihandles      uipushtool     uiwait
+      uicontextmenu   uiresume       waitfor
+      uicontrol       uitoggletool
 
     The uiXXX functions above are experimental.
 
-    Except for uiwait and uiresume, the uiXXX functions are not supported on
-    the FLTK backend.
+    Except for uiwait and uiresume, the uiXXX functions are not
+    supported with the the FLTK+OpenGL graphics toolkit.
 
-    The gnuplot backend does not support any of the uiXXX functions nor
-    the waitfor function.
+    The gnuplot graphics toolkit does not support any of the uiXXX
+    functions nor the waitfor function.
 
- ** New keyword parfor
-
-    parfor (parallel for loop) is now recognized as a valid keyword.
-    Implementation, however, is still mapped to an ordinary for loop.
+ ** New keyword parfor (parallel for loop) is now recognized as a valid
+    keyword.  Implementation, however, is still mapped to an ordinary
+    for loop.
 
  ** Other new functions added in 3.6.0:
 
-    is_dq_string    nthargout    usejava     
-    is_sq_string    python       waitbar
-    narginchk       recycle      zscore            
-    
+      bicg                       nthargout                   usejava
+      is_dq_string               narginchk                   waitbar
+      is_sq_string               python                      zscore
+      is_function_handle         register_graphics_toolkit 
+      loaded_graphics_toolkits   recycle                   
+
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
       iscommand           spcumsum     spmin
@@ -154,19 +206,19 @@ Summary of important user-visible change
       spchol2inv          split        unmark_rawcommand
 
     The following functions have been deprecated in Octave 3.6 and will
     be removed from Octave 3.10 (or whatever version is the second major
     release after 3.6):
 
       cut                is_duplicate_entry
       cor                polyderiv
-      corrcoef           studentize
-      __error_text__     sylvester_matrix
-      error_text
+      corrcoef           shell_cmd 
+      __error_text__     studentize
+      error_text         sylvester_matrix
 
 Summary of important user-visible changes for version 3.4.3:
 -----------------------------------------------------------
 
  ** Octave 3.4.3 is a bug fixing release.
      
 Summary of important user-visible changes for version 3.4.2:
 -----------------------------------------------------------
@@ -357,18 +409,18 @@ Summary of important user-visible change
     also try to do the operation in-place if it's argument is a
     temporary expression.
 
  ** The effect of comparison operators (<, >, <=, and >=) applied to
     complex numbers has changed to be consistent with the strict
     ordering defined by the `max', `min', and `sort' functions.  More
     specifically, complex numbers are compared by lexicographical
     comparison of the pairs `[abs(z), arg(z)]'.  Previously, only real
-    parts were compared; this can be trivially achieved by wrapping the
-    operands in real().
+    parts were compared; this can be trivially achieved by converting
+    the operands to real values with the `real' function.
 
  ** The automatic simplification of complex computation results has
     changed.  Octave will now simplify any complex number with a zero
     imaginary part or any complex matrix with all elements having zero
     imaginary part to a real value.  Previously, this was done only for
     positive zeros.  Note that the behavior of the complex function is
     unchanged and it still produces a complex value even if the
     imaginary part is zero.
@@ -478,26 +530,26 @@ Summary of important user-visible change
     important cases.
 
     Further, it is now possible to pre-allocate a sparse matrix and
     subsequently fill it by assignments, provided they meet certain
     conditions.  For more information, consult the `spalloc' function,
     which is no longer a mere dummy.  Consequently, nzmax and nnz are no
     longer always equal in Octave.  Octave may also produce a matrix
     with nnz < nzmax as a result of other operations, so you should
-    consistently use nnz unless you really want to use nzmax (i.e. the
+    consistently use nnz unless you really want to use nzmax (i.e., the
     space allocated for nonzero elements).
 
     Sparse concatenation is also affected, and concatenating sparse 
     matrices, especially larger collections, is now significantly more 
     efficient.  This applies to both the [] operator and the 
     cat/vertcat/horzcat functions.
 
  ** It is now possible to optionally employ the xGESDD LAPACK drivers
-    for computing the singular value decomposition using svd(), instead
+    for computing the singular value decomposition using svd, instead
     of the default xGESVD, using the configuration pseudo-variable
     svd_driver.  The xGESDD driver can be up to 6x times faster when
     singular vectors are requested, but is reported to be somewhat less
     robust on highly ill-conditioned matrices.
 
  ** Configuration pseudo-variables, such as page_screen_output or 
     confirm_recursive_rmdir (or the above mentioned svd_driver), now 
     accept a "local" option as second argument, requesting the change 
@@ -515,17 +567,17 @@ Summary of important user-visible change
     it calls.
 
  ** pkg now accepts a -forge option for downloading and installing
     packages from Octave Forge automatically.  For example, 
     
       pkg install -forge general
     
     will automatically download the latest release of the general
-    package and attempt to install it. No automatic resolving of
+    package and attempt to install it.  No automatic resolving of
     dependencies is provided.  Further,
 
       pkg list -forge
     
     can be used to list all available packages.
 
  ** The internal data representation of structs has been completely
     rewritten to make certain optimizations feasible.  The field data
@@ -672,17 +724,17 @@ Summary of important user-visible change
     have been added to these group objects such that
 
            x = 0:0.1:10;
            y = sin (x);
            plot (x, y, "ydatasource", "y");
            for i = 1 : 100
              pause(0.1)
              y = sin (x + 0.1 * i);
-             refreshdata();
+             refreshdata ();
            endfor
 
     works as expected.  This capability has be used to introduce
     stem-series, bar-series, etc., objects for better Matlab
     compatibility.
 
  ** New graphics functions:
 
@@ -888,17 +940,17 @@ Summary of important user-visible change
     function is now a built-in function performing a binary search,
     optimized for long runs of close elements.  Lookup also works with
     cell arrays of strings.
 
  ** Range arithmetics
 
     For some operations on ranges, Octave will attempt to keep the
     result as a range.  These include negation, adding a scalar,
-    subtracting a scalar, and multiplying by a scalar. Ranges with zero
+    subtracting a scalar, and multiplying by a scalar.  Ranges with zero
     increment are allowed and can be constructed using the built-in
     function `ones'.
 
  ** Various performance improvements.
 
     Performance of a number of other built-in operations and functions
     was improved, including:
 
diff --git a/README b/README
--- a/README
+++ b/README
@@ -1,11 +1,11 @@
 GNU Octave -- a high-level language for numerical computations.
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 Overview
 --------
 
 GNU Octave is a high-level language, primarily intended for numerical
 computations.  It provides a convenient command line interface for
 solving linear and nonlinear problems numerically.
 
diff --git a/autogen.sh b/autogen.sh
--- a/autogen.sh
+++ b/autogen.sh
@@ -32,8 +32,22 @@ echo "generating doc/interpreter/images.
 
 echo "generating src/DLD-FUNCTIONS/module.mk..."
 
 (cd src/DLD-FUNCTIONS; ./config-module.sh)
 
 echo "bootstrapping..."
 
 build-aux/bootstrap "$@"
+
+## G77 is obsolete, but it is still the first option in the autoconf Fortran
+## macros.  We should avoid it, because mixing old versions of g77 with modern
+## gcc and g++ causes trouble.  The following will make it harder (but not
+## impossible) for users to make this mistake.
+##
+## FIXME -- we should really work to fix autoconf so that it prefers gfortran
+## over g77 even when searching for a Fortran 77 compiler.
+
+echo "replacing all occurrences of g77 with gfortran in configure script..."
+
+sed 's/g77/gfortran/g' configure > configure.t
+mv configure.t configure
+chmod 755 configure
diff --git a/build-aux/bootstrap b/build-aux/bootstrap
--- a/build-aux/bootstrap
+++ b/build-aux/bootstrap
@@ -1,15 +1,15 @@
 #! /bin/sh
 # Print a version string.
 scriptversion=2011-08-11.17; # UTC
 
 # Bootstrap this package from checked-out sources.
 
-# Copyright (C) 2003-2011 Free Software Foundation, Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -1,11 +1,11 @@
 # Bootstrap configuration.
 
-# Copyright (C) 2006-2007, 2009-2011 Free Software Foundation, Inc.
+# Copyright (C) 2006-2007, 2009-2012 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -31,29 +31,33 @@ gnulib_modules="
   fflush
   fseek
   ftell
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
+  isatty
   link
   lstat
   mkdir
   mkfifo
+  mkostemp
   mkstemp
   mktime
   nanosleep
   nproc
   opendir
   pathmax
   progname
+  readdir
   readlink
   rename
+  rewinddir
   rmdir
   round
   roundf
   sigaction
   signal
   sigprocmask
   sleep
   sleep
@@ -68,17 +72,17 @@ gnulib_modules="
   sys_times
   time
   times
   tmpfile
   trunc
   truncf
   unistd
   unlink
-  vsnprintf
+  vasprintf
 "
 
 # Additional xgettext options to use.  Use "\\\newline" to break lines.
 XGETTEXT_OPTIONS=$XGETTEXT_OPTIONS'\\\
  --from-code=UTF-8\\\
  --flag=asprintf:2:c-format --flag=vasprintf:2:c-format\\\
  --flag=asnprintf:3:c-format --flag=vasnprintf:3:c-format\\\
  --flag=wrapf:1:c-format\\\
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -238,16 +238,20 @@ OPENGL_LIBS = @OPENGL_LIBS@
 
 QRUPDATE_CPPFLAGS = @QRUPDATE_CPPFLAGS@
 QRUPDATE_LDFLAGS = @QRUPDATE_LDFLAGS@
 QRUPDATE_LIBS = @QRUPDATE_LIBS@
 
 READLINE_LIBS = @READLINE_LIBS@
 TERM_LIBS = @TERM_LIBS@
 
+ARPACK_CPPFLAGS = @ARPACK_CPPFLAGS@
+ARPACK_LDFLAGS = @ARPACK_LDFLAGS@
+ARPACK_LIBS = @ARPACK_LIBS@
+
 DL_LIBS = @DL_LIBS@
 LIBS = @LIBS@
 
 ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS)
 
 SPARSE_XCPPFLAGS = \
   $(CHOLMOD_CPPFLAGS) $(UMFPACK_CPPFLAGS) \
   $(AMD_CPPFLAGS) $(CAMD_CPPFLAGS) $(COLAMD_CPPFLAGS) \
@@ -447,16 +451,19 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_ALL_CXXFLAGS%|\"${ALL_CXXFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_ALL_FFLAGS%|\"${ALL_FFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_ALL_LDFLAGS%|\"${ALL_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_CPPFLAGS%|\"${AMD_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_LDFLAGS%|\"${AMD_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_AMD_LIBS%|\"${AMD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_AR%|\"${AR}\"|" \
   -e "s|%OCTAVE_CONF_ARFLAGS%|\"${ARFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_CPPFLAGS%|\"${ARPACK_CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_LDFLAGS%|\"${ARPACK_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_ARPACK_LIBS%|\"${ARPACK_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_BLAS_LIBS%|\"${BLAS_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_CPPFLAGS%|\"${CAMD_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_LDFLAGS%|\"${CAMD_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_CAMD_LIBS%|\"${CAMD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CANONICAL_HOST_TYPE%|\"${canonical_host_type}\"|" \
   -e "s|%OCTAVE_CONF_CARBON_LIBS%|\"${CARBON_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_CC%|\"${CC}\"|" \
   -e "s|%OCTAVE_CONF_CC_VERSION%|\"${CC_VERSION}\"|" \
diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -1,11 +1,11 @@
 #! /usr/bin/perl -w
 #
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1,13 +1,13 @@
 dnl configure.in
 dnl
 dnl Process this file with autoconf to produce a configure script.
 dnl
-dnl Copyright (C) 1993-2011 John W. Eaton
+dnl Copyright (C) 1993-2012 John W. Eaton
 ### 
 ### This file is part of Octave.
 ### 
 ### Octave is free software; you can redistribute it and/or modify it
 ### under the terms of the GNU General Public License as published by the
 ### Free Software Foundation; either version 3 of the License, or (at
 ### your option) any later version.
 ### 
@@ -22,24 +22,24 @@ dnl Copyright (C) 1993-2011 John W. Eato
 
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
-AC_INIT([GNU Octave], [3.5.0+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.6.0], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
-OCTAVE_API_VERSION_NUMBER="45"
+OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2011-01-22"
-OCTAVE_COPYRIGHT="Copyright (C) 2011 John W. Eaton and others."
+OCTAVE_RELEASE_DATE="2012-01-15"
+OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 AC_REVISION($Revision: 1.603 $)
 AC_PREREQ([2.62])
@@ -166,21 +166,30 @@ AC_ARG_ENABLE(bounds-check,
 if $BOUNDS_CHECKING; then
   AC_DEFINE(BOUNDS_CHECKING, 1, [Define to use internal bounds checking.])
 fi
 
 USE_OCTAVE_ALLOCATOR=false
 AC_ARG_ENABLE(octave-allocator,
   [AS_HELP_STRING([--enable-octave-allocator],
      [use the obsolete octave_allocator class for many of Octave's objects (mostly octave_value types).  You probably do NOT want to enable this feature.  (default is no)])],
-  [if test "$enableval" = yes; then USE_ALLOCATOR=true; fi], [])
+  [if test "$enableval" = yes; then USE_OCTAVE_ALLOCATOR=true; fi], [])
 if $USE_OCTAVE_ALLOCATOR; then
   AC_DEFINE(USE_OCTAVE_ALLOCATOR, 1, [Define to use octave_allocator class.])
 fi
 
+USE_ATOMIC_REFCOUNT=false
+AC_ARG_ENABLE(atomic-refcount,
+  [AS_HELP_STRING([--enable-atomic-refcount],
+     [use atomic operations for internal reference counting. This is required for thread-safe behavior.  (default is no)])],
+  [if test "$enableval" = yes; then USE_ATOMIC_REFCOUNT=true; fi], [])
+if $USE_ATOMIC_REFCOUNT; then
+  AC_DEFINE(USE_ATOMIC_REFCOUNT, 1, [Define to use atomic operations for reference counting.])
+fi
+
 ### Make it possible to disable running Make in the doc directory.
 ### Useful for building on systems without TeX, for example.
 DOCDIR=doc
 AC_ARG_ENABLE(docs,
   [AS_HELP_STRING([--enable-docs], [build documentation (default is yes)])],
   [if test "$enableval" = no; then
      DOCDIR=
      warn_docs="building documentation disabled; make dist will fail"
@@ -635,35 +644,40 @@ OCTAVE_IEEE754_DATA_FORMAT
 
 OCTAVE_CXX_COMPLEX_SETTERS
 OCTAVE_CXX_COMPLEX_REFERENCE_ACCESSORS
 
 ### Check for the QHull library
 
 OCTAVE_CHECK_LIBRARY(qhull, QHull,
   [Qhull library not found -- this will result in loss of functionality of some geometry functions.],
-  [qhull/qhull_a.h], [qh_qhull], [], [],
+  [qhull/libqhull.h libqhull.h qhull/qhull.h qhull.h], [qh_qhull], [], [],
   [warn_qhull=
    OCTAVE_CHECK_QHULL_VERSION
    OCTAVE_CHECK_QHULL_OK([TEXINFO_QHULL="@set HAVE_QHULL"
      AC_DEFINE(HAVE_QHULL, 1, [Define if QHull is available.])], [
      warn_qhull="Qhull library found, but seems not to work properly -- this will result in loss of functionality of some geometry functions.  Please try recompiling the library with -fno-strict-aliasing."])])
 
 ### Check for pcre regex library.
 
 REGEX_LIBS=
 
 pcre_fail_msg="to build Octave, you must have the PCRE library and header files installed"
 
-## NB: no need to do separate check for pcre.h header -- checking
-## macros is good enough
+AC_CHECK_HEADERS([pcre.h pcre/pcre.h])
+
 AC_CACHE_CHECK([whether pcre.h defines the macros we need],
   [ac_cv_pcre_h_macros_present],
   [AC_EGREP_CPP([PCRE_HAS_MACROS_WE_NEED], [
+#if defined (HAVE_PCRE_H)
 #include <pcre.h>
+#elif defined (HAVE_PCRE_PCRE_H)
+#include <pcre.h>
+#error "NO PCRE HEADER"
+#endif
 #if defined (PCRE_INFO_NAMECOUNT) \
   && defined (PCRE_INFO_NAMEENTRYSIZE) \
   && defined (PCRE_INFO_NAMETABLE)
 PCRE_HAS_MACROS_WE_NEED
 #endif], ac_cv_pcre_h_macros_present=yes, ac_cv_pcre_h_macros_present=no)])
 
 if test $ac_cv_pcre_h_macros_present = yes; then
   ## check for pcre-config, and if so, set XTRA_CXXFLAGS appropriately
@@ -1668,16 +1682,29 @@ fi
 
 if test -n "$UMFPACK_LIBS"; then
   save_LIBS="$LIBS";
   LIBS="$UMFPACK_LIBS $AMD_LIBS $BLAS_LIBS $FLIBS $LIBS"
   OCTAVE_UMFPACK_SEPERATE_SPLIT
   LIBS="$save_LIBS"
 fi
 
+save_LIBS="$LIBS"
+LIBS="$LAPACK_LIBS $BLAS_LIBS $FLIBS $LIBS"
+OCTAVE_CHECK_LIBRARY(arpack, ARPACK,
+  [ARPACK not found.  The eigs function will be disabled.],
+  [],
+  [dseupd],
+  [Fortran 77], [don't use the ARPACK library, disable eigs function],
+  [warn_arpack=
+   OCTAVE_CHECK_ARPACK_OK([
+     AC_DEFINE(HAVE_ARPACK, 1, [Define if ARPACK is available.])], [
+     warn_arpack="ARPACK library found, but seems not to work properly -- disabling eigs function"])])
+LIBS="$save_LIBS"
+
 ### Enable dynamic linking.  --enable-shared implies this, so
 ### --enable-dl is only need if you are only building static libraries
 ### and want to try dynamic linking too (works on some systems, for
 ### example, OS X and Windows).
 
 AC_ARG_ENABLE([dl],
   [AS_HELP_STRING([--enable-dl],
     [allow loading of dynamically linked modules (not all systems)])], [
@@ -1994,17 +2021,17 @@ case "$canonical_host_type" in
   *-*-msdosmsvc*)
     AC_CHECK_LIB(dirent, opendir)
     LIBS="$LIBS -ladvapi32 -lgdi32 -lws2_32 -luser32 -lkernel32"
   ;;
 esac
 
 AC_ARG_ENABLE([no-undefined],
   [AS_HELP_STRING([--enable-no-undefined],
-    [pass -no-undefined to libtool when linking linking Octave and its shared libraries (on by default)])],
+    [pass -no-undefined to libtool when linking Octave and its shared libraries (on by default)])],
   [case "${enableval}" in
     yes) NO_UNDEFINED_LDFLAG="-no-undefined" ;;
     no)  NO_UNDEFINED_LDFLAG="" ;;
     *) AC_MSG_ERROR([bad value ${enableval} for --enable-link-all-depenencies]) ;;
    esac], [NO_UNDEFINED_LDFLAG="-no-undefined"])
 AC_SUBST(NO_UNDEFINED_LDFLAG)
 
 AC_ARG_ENABLE([link-all-dependencies],
@@ -2108,17 +2135,17 @@ else
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(basename canonicalize_file_name \
   chmod dup2 endgrent endpwent execvp expm1 expm1f fork \
   getegid geteuid getgid getgrent getgrgid getgrnam getpgrp getpid \
-  getppid getpwent getpwuid getuid getwd _kbhit kill \
+  getppid getpwent getpwuid getuid getwd _kbhit \
   lgamma lgammaf lgamma_r lgammaf_r localtime_r log1p log1pf \
   mkstemp pipe putenv \
   realpath resolvepath rindex roundl select setgrent setlocale \
   setpwent setvbuf siglongjmp \
   strsignal tempnam tgammaf umask \
   uname utime waitpid \
   _chmod x_utime _utime32)
 
@@ -2598,16 +2625,19 @@ typedef unsigned long ino_t;
 #define OCTGRAPHICS_API OCTAVE_IMPORT
 #endif
 
 /* oct-types.h */
 
 typedef OCTAVE_IDX_TYPE octave_idx_type;
 
 #include <stdint.h>
+
+/* Tag indicating octave config.h has been included */
+#define OCTAVE_CONFIG_INCLUDED 1
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_SUBST(ac_config_files)
 AC_SUBST(ac_config_headers)
 
 AC_CONFIG_FILES([
@@ -2642,16 +2672,19 @@ Octave is now configured for $canonical_
   Fortran compiler:            $F77 $FFLAGS
   Fortran libraries:           $FLIBS
   Lex libraries:               $LEXLIB
   LIBS:                        $LIBS
 
   AMD CPPFLAGS:                $AMD_CPPFLAGS
   AMD LDFLAGS:                 $AMD_LDFLAGS
   AMD libraries:               $AMD_LIBS
+  ARPACK CPPFLAGS:             $ARPACK_CPPFLAGS
+  ARPACK LDFLAGS:              $ARPACK_LDFLAGS
+  ARPACK libraries:            $ARPACK_LIBS
   BLAS libraries:              $BLAS_LIBS
   CAMD CPPFLAGS:               $CAMD_CPPFLAGS
   CAMD LDFLAGS:                $CAMD_LDFLAGS
   CAMD libraries:              $CAMD_LIBS
   CARBON libraries:            $CARBON_LIBS
   CCOLAMD CPPFLAGS:            $CCOLAMD_CPPFLAGS
   CCOLAMD LDFLAGS:             $CCOLAMD_LDFLAGS
   CCOLAMD libraries:           $CCOLAMD_LIBS
@@ -2887,17 +2920,17 @@ if $USE_64_BIT_IDX_T; then
   AC_MSG_WARN([Are you sure that is what you want to do?])
   AC_MSG_WARN([])
   AC_MSG_WARN([Your Fortran compiler must have an option to generate])
   AC_MSG_WARN([code with 8 byte signed INTEGER values.  This option])
   AC_MSG_WARN([should be specified in the F77_INTEGER_8_FLAG variable])
   AC_MSG_WARN([Make.  This should work automatically for gfortran.  If])
   AC_MSG_WARN([you use another compiler, you will need to set this])
   AC_MSG_WARN([variable on the configure command line.  You must also])
-  AC_MSG_WARN([compile the BLAS, LAPACK, QRUPDATE, and SuiteSparse])
+  AC_MSG_WARN([compile the ARPACK, BLAS, LAPACK, QRUPDATE, and SuiteSparse])
   AC_MSG_WARN([libraries to use 8 byte signed integers for array indexing.])
   AC_MSG_WARN([])
   warn_msg_printed=true
 fi
 
 if $USE_OPENMP; then
   AC_MSG_WARN([])
   AC_MSG_WARN([You used the EXPERIMENTAL --enable-openmp option.])
@@ -2974,15 +3007,31 @@ if test -n "$warn_gnuplot"; then
   AC_MSG_WARN([at the Octave prompt.])
   AC_MSG_WARN([])
   AC_MSG_WARN([Setting default value to $GNUPLOT])
   AC_MSG_WARN([])
 
   warn_msg_printed=true
 fi
 
+if $USE_ATOMIC_REFCOUNT; then
+  AC_MSG_WARN([])
+  AC_MSG_WARN([Using atomic reference counting.])
+  AC_MSG_WARN([This feature allows to access octave data safely from])
+  AC_MSG_WARN([another thread, for instance from a GUI. However this])
+  AC_MSG_WARN([results in a small performance penalty in the octave])
+  AC_MSG_WARN([interpreter.])
+  AC_MSG_WARN([])
+  if $USE_OCTAVE_ALLOCATOR; then
+    AC_MSG_WARN([Thread-safe behavior is not guaranteed unless you also])
+    AC_MSG_WARN([disable the use of the octave_allocator class.])
+    AC_MSG_WARN([])
+  fi
+  warn_msg_printed=true
+fi
+
 if $warn_msg_printed; then
   AC_MSG_NOTICE([])
   AC_MSG_NOTICE([NOTE: libraries may be skipped if a library is not found OR])
   AC_MSG_NOTICE([NOTE: if the library on your system is missing required features.])
 fi
 
 ### End of configure.
diff --git a/doc/Makefile.am b/doc/Makefile.am
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/interpreter directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/faq/Makefile.am b/doc/faq/Makefile.am
--- a/doc/faq/Makefile.am
+++ b/doc/faq/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/faq directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1997-2011 John W. Eaton
+% Copyright (C) 1997-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 %
diff --git a/doc/icons/Makefile.am b/doc/icons/Makefile.am
--- a/doc/icons/Makefile.am
+++ b/doc/icons/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/icons directory
 #
-# Copyright (C) 2011 John W. Eaton
+# Copyright (C) 2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/interpreter directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -143,17 +143,18 @@ MUNGED_TEXI_SRC = \
   signal.texi \
   sparse.texi \
   stats.texi \
   stmt.texi \
   strings.texi \
   system.texi \
   testfun.texi \
   tips.texi \
-  var.texi
+  var.texi \
+  vectorize.texi
 
 TXI_SRC = $(MUNGED_TEXI_SRC:.texi=.txi)
 
 info_TEXINFOS = octave.texi
 
 octave_TEXINFOS = \
   contributors.texi \
   $(MUNGED_TEXI_SRC)
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -184,20 +184,16 @@ cos (pi/2)
 @DOCSTRING(prod)
 
 @DOCSTRING(cumsum)
 
 @DOCSTRING(cumprod)
 
 @DOCSTRING(sumsq)
 
-@DOCSTRING(accumarray)
-
-@DOCSTRING(accumdim)
-
 @node Utility Functions
 @section Utility Functions
 
 @DOCSTRING(ceil)
 
 @DOCSTRING(fix)
 
 @DOCSTRING(floor)
diff --git a/doc/interpreter/audio.txi b/doc/interpreter/audio.txi
--- a/doc/interpreter/audio.txi
+++ b/doc/interpreter/audio.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 Kurt Hornik
+@c Copyright (C) 1996-2012 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -1054,17 +1054,17 @@ endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
 lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
-(excepting whitespace) in order to to be parsed correctly.
+(excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
 @cindex help, user-defined functions
 
 The @code{help} command (@pxref{Getting Help}) is able to find the first
diff --git a/doc/interpreter/bugs.txi b/doc/interpreter/bugs.txi
--- a/doc/interpreter/bugs.txi
+++ b/doc/interpreter/bugs.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -369,17 +369,18 @@ in.call1
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 @cindex dynamic naming
 
 Besides the index operator ".", Octave can use dynamic naming "(var)" or the
 @code{struct} function to create structures.  Dynamic naming uses the string
-value of a variable as the field name.  For example,
+value of a variable as the field name.  For example:
+
 @example
 @group
 a = "field2";
 x.a = 1;
 x.(a) = 2;
 x
      @result{} x =
         @{
@@ -501,19 +502,17 @@ Other functions that can manipulate the 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
 @subsection Processing Data in Structures
 
 The simplest way to process data in a structure is within a @code{for}
 loop (@pxref{Looping Over Structure Elements}).  A similar effect can be
 achieved with the @code{structfun} function, where a user defined
-function is applied to each field of the structure.
-
-@DOCSTRING(structfun)
+function is applied to each field of the structure.  @xref{doc-structfun}.
 
 Alternatively, to process the data in a structure, the structure might
 be converted to another type of container before being treated.
 
 @DOCSTRING(struct2cell)
 
 @node Cell Arrays
 @section Cell Arrays
@@ -881,19 +880,17 @@ cell array of strings.
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
 
 Data that is stored in a cell array can be processed in several ways
 depending on the actual data.  The simplest way to process that data
 is to iterate through it using one or more @code{for} loops.  The same
 idea can be implemented more easily through the use of the @code{cellfun}
 function that calls a user-specified function on all elements of a cell
-array.
-
-@DOCSTRING(cellfun)
+array.  @xref{doc-cellfun}.
 
 An alternative is to convert the data to a different container, such as
 a matrix or a data structure.  Depending on the data this is possible
 using the @code{cell2mat} and @code{cell2struct} functions.
 
 @DOCSTRING(cell2mat)
 
 @DOCSTRING(cell2struct)
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -1,9 +1,10 @@
-@c Copyright (C) 2008-2011 Jaroslav Hajek
+@c Copyright (C) 2012 John W. Eaton
+@c Copyright (C) 2008-2012 Jaroslav Hajek
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c
@@ -20,32 +21,114 @@
 @appendix Contributing Guidelines
 @cindex coding standards
 @cindex Octave development
 
 This chapter is dedicated to those who wish to contribute code to Octave.
 
 @menu
 * How to Contribute::
+* Building the Development Sources::
+* Basics of Generating a Changeset::
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 @end menu
 
 @node How to Contribute
 @section How to Contribute
 The mailing list for Octave development discussion and sending
 contributions is @email{maintainers@@octave.org}.  This concerns the
 development of Octave core, i.e., code that goes to Octave directly.
 You may consider developing and publishing a package instead; a great
 place for this is the allied Octave-Forge project
 (@url{http://octave.sf.net}).  Note that the Octave project is
 inherently more conservative and follows narrower rules.
 
+@node Building the Development Sources
+@section Building the Development Sources
+
+In addition to all the tools (both optional and required) that are
+listed in @ref{Build Dependencies} you will need:
+
+@table @asis
+@item Mercurial
+Distributed version control system (@url{http://mercurial.selenic.com}).
+Octave's sources are stored in a Mercurial archive.
+
+@item Git
+Distributed version control system (@url{http://git-scm.com}).  The
+gnulib sources that Octave depends on are stored in a Git archive.
+@end table
+
+Once you have the required tools installed, you can build Octave by
+doing
+
+@itemize @bullet
+@item
+Check out a copy of the Octave sources:
+@example
+hg clone http://hg.savannah.gnu.org/hgweb/octave
+@end example
+
+@item
+Change to the top-level directory of the newly checked out sources:
+@example
+cd octave
+@end example
+
+@item
+Generate the necessary configuration files:
+@example
+./autogen.sh
+@end example
+
+@item
+Create a build directory and change to it:
+@example
+mkdir build
+cd build
+@end example
+By using a separate build directory, you will keep the source directory
+clean and it will be easy to completely remove all files generated by
+the build.  You can also have parallel build trees for different
+purposes that all share the same sources.  For example, one build tree
+may be configured to disable compiler optimization in order to allow for
+easier debugging while another may be configured to test building with
+other specialized compiler flags.
+
+@item
+Run Octave's configure script from the build directory:
+@example
+../configure
+@end example
+
+@item
+Run make in the build directory:
+@example
+make
+@end example
+@end itemize
+
+Once the build is finished, you will see a message like the following:
+
+@example
+@group
+Octave successfully built.  Now choose from the following:
+
+   ./run-octave    - to run in place to test before installing
+   make check      - to run the tests
+   make install    - to install (PREFIX=...)
+@end group
+@end example
+
+@node Basics of Generating a Changeset
+@section Basics of Generating a Changeset
+
 The preferable form of contribution is creating a Mercurial changeset
 and sending it via e-mail to the octave-maintainers mailing list.
 Mercurial is the source code management system currently used to develop
 Octave.  Other forms of contributions (e.g., simple diff patches) are
 also acceptable, but they slow down the review process.  If you want to
 make more contributions, you should really get familiar with Mercurial.
 A good place to start is
 @url{http://www.selenic.com/mercurial/wiki/index.cgi/Tutorial}.  There
@@ -66,17 +149,17 @@ hg commit -m "make Octave the coolest so
 hg export -o ../cool.diff tip
                              # export the changeset to a diff
                              # file
 # send ../cool.diff via email
 @end group
 @end example
 
 You may want to get familiar with Mercurial queues to manage your
-changesets. Here is a slightly more complex example using Mercurial
+changesets.  Here is a slightly more complex example using Mercurial
 queues, where work on two unrelated changesets is done in parallel and
 one of the changesets is updated after discussion on the maintainers
 mailing list:
 
 @example
 hg qnew nasty_bug            # create a new patch
 # change sources@dots{}
 hg qref                      # save the changes into the patch
@@ -110,17 +193,17 @@ hg export -o ../nasty2.diff tip
 
 All Octave's sources are distributed under the General Public License
 (GPL).  Currently, Octave uses GPL version 3.  For details about this
 license, see @url{http://www.gnu.org/licenses/gpl.html}.  Therefore,
 whenever you create a new source file, it should have the following
 comment header (use appropriate year, name and comment marks):
 
 @example
-## Copyright (C) 1996-2011 John W. Eaton <jwe@@octave.org>
+## Copyright (C) 1996-2012 John W. Eaton <jwe@@octave.org>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or
 ## modify it under the terms of the GNU General Public
 ## License as published by the Free Software Foundation;
 ## either version 3 of the License, or (at your option) any
 ## later version.
@@ -149,17 +232,17 @@ several parts of one file, you should en
 following the GNU coding standards on changelogs, like the following
 example:
 
 @example
 @group
 look for methods before constructors
 
 * symtab.cc (symbol_table::fcn_info::fcn_info_rep::find):
-Look for class methods before constructors, contrary to Matlab
+Look for class methods before constructors, contrary to @sc{matlab}
 documentation.
 
 * test/ctor-vs-method: New directory of test classes.
 * test/test_ctor_vs_method.m: New file.
 * test/Makefile.am: Include ctor-vs-method/module.mk.
 (FCN_FILES): Include test_ctor_vs_method.m in the list.
 @end group
 @end example
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -1,54 +1,63 @@
 Ben Abbott
 Andy Adler
 Giles Anderson
 Joel Andersson
 Muthiah Annamalai
+Marco Atzeri
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
 Roman Belov
 Karl Berry
 David Billinghurst
 Don Bindner
 Jakub Bogusz
 Moritz Borgmann
+Paul Boven
 Richard Bovey
+John Bradshaw
 Marcus Brinkmann
 Remy Bruno
+Ansgar Burchard
 Marco Caliari
 Daniel Calvelo
 John C. Campbell
+Juan Pablo Carbajal
 Jean-Francois Cardoso
 Joao Cardoso
 Larrie Carr
 David Castelow
 Vincent Cautaerts
 Clinton Chee
 Albert Chin-A-Young
 Carsten Clark
 J. D. Cole
 Martin Costabel
 Michael Creel
 Jeff Cunningham
 Martin Dalecki
 Jorge Barros de Abreu
 Carlo de Falco
+Jacob Dawid
 Thomas D. Dean
 Philippe Defert
 Bill Denney
+Fabian Deutsch
 Christos Dimitrakakis
 David M. Doolin
+Carn√´ Draug
 Pascal A. Dupuis
 John W. Eaton
 Dirk Eddelbuettel
+Pieter Eendebak
 Paul Eggert
 Stephen Eglen
 Peter Ekberg
 Rolf Fabian
 Gunnar Farneb√§ck
 Stephen Fegan
 Ramon Garcia Fernandez
 Torsten Finke
@@ -66,16 +75,17 @@ Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
 Steffen Groot
 Etienne Grossmann
 David Grundberg
 Peter Gustafson
 Kai Habel
+Patrick H√§cker
 William P. Y. Hadisoeseno
 Jaroslav Hajek
 Benjamin Hall
 Kim Hansen
 S√∏ren Hauberg
 Dave Hawthorne
 Daniel Heiserer
 Martin Helm
@@ -93,71 +103,78 @@ Christopher Hulbert
 Cyril Humbert
 Teemu Ikonen
 Alan W. Irwin
 Geoff Jacobsen
 Mats Jansson
 Cai Jianming
 Steven G. Johnson
 Heikki Junes
+Matthias J√ºschke
 Atsushi Kajita
 Jarkko Kaleva
 Mohamed Kamoun
 Lute Kamstra
 Fotios Kasolis
 Thomas Kasper
 Joel Keay
 Mumit Khan
 Paul Kienzle
 Aaron A. King
 Arno J. Klaassen
+Alexander Klein
 Geoffrey Knauth
 Heine Kolltveit
 Ken Kouno
 Kacper Kowalik
 Daniel Kraft
+Aravindh Krishnamoorthy
 Oyvind Kristiansen
 Piotr Krzyzanowski
 Volker Kuhlmann
 Tetsuro Kurita
 Miroslaw Kwasniak
 Rafael Laboissiere
 Kai Labusch
 Claude Lacoursiere
 Walter Landry
 Bill Lash
 Dirk Laurie
 Maurice LeBrun
 Friedrich Leisch
+Jyh-miin Lin
 Timo Lindfors
 Benjamin Lindner
 Ross Lippert
 David Livings
+Sebastien Loisel
 Erik de Castro Lopo
 Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
 James Macnicol
 Jens-Uwe Mager
+Rob Mahurin
 Ricardo Marranita
 Orestes Mas
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 J√∫lio Hoffimann Mendes
 Thorsten Meyer
 Petr Mikulik
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
 Hannes M√ºller
 Victor Munoz
+Iain Murray
 Carmen Navarrete
 Todd Neal
 Philip Nienhuis
 Al Niessner
 Rick Niles
 Takuji Nishimura
 Kai Noda
 Eric Norum
@@ -170,92 +187,106 @@ Luis F. Ortiz
 Scott Pakin
 Gabriele Pannocchia
 Sylvain Pelissier
 Per Persson
 Primozz Peterlin
 Jim Peterson
 Danilo Piazzalunga
 Nicholas Piper
+Elias Pipping
 Robert Platt
 Hans Ekkehard Plesser
 Tom Poage
 Orion Poplawski
 Ondrej Popp
 Jef Poskanzer
-Francesco Potorti
+Francesco Potort√¨
 Konstantinos Poulios
+Jarno Rajahalme
 James B. Rawlings
 Eric S. Raymond
 Balint Reczey
+Joshua Redstone
+Lukas Reichlin
 Michael Reifenberger
+Anthony Richardson
 Jason Riedy
+E. Joshua Rigler
 Petter Risholm
 Matthew W. Roberts
 Andrew Ross
 Mark van Rossum
+Joe Rothweiler
 Kevin Ruland
 Kristian Rumberg
 Ryan Rusaw
 Olli Saarela
 Toni Saarela
 Juhani Saastamoinen
 Radek Salac
 Ben Sapp
 Aleksej Saushev
-Alois Schloegl
+Alois Schl√∂gl
 Michel D. Schmid
 Julian Schnidder
 Nicol N. Schraudolph
 Sebastian Schubert
 Ludwig Schwardt
 Thomas L. Scofield
 Daniel J. Sebald
 Dmitri A. Sergatskov
 Vanya Sergeev
 Baylis Shanks
 Andriy Shinkarchuck
+Robert T. Short
 Joseph P. Skudlarek
 John Smith
 Julius Smith
 Shan G. Smith
+Peter L. Sondergaard
 Joerg Specht
 Quentin H. Spencer
 Christoph Spiel
 Richard Stallman
 Russell Standish
+Brett Stewart
 Doug Stewart
 Jonathan Stickel
 Judd Storrs
 Thomas Stuart
 Ivan Sutoris
 John Swensen
 Daisuke Takago
 Ariel Tankus
+Matthew Tenny
 Georg Thimm
 Duncan Temple Lang
 Kris Thielemans
 Olaf Till
 Christophe Tournery
 Thomas Treichl
+Karsten Trulsen
 Frederick Umminger
 Utkarsh Upadhyay
 Stefan van der Walt
-David Wells
 Peter Van Wieren
 James R. Van Zandt
 Gregory Vanuxem
 Ivana Varekova
 Thomas Walter
+Andreas Weber
 Olaf Weber
 Thomas Weber
 Rik Wehbring
 Bob Weigel
 Andreas Weingessel
+Martin Weiser
 Michael Weitzel
+David Wells
 Fook Fah Yap
 Sean Young
 Michael Zeising
 Federico Zenith
 Alex Zvoleff
 Valentin Ortega-Clavero
 Jacob Dawid
 J√∫lio Hoffimann
diff --git a/doc/interpreter/cp-idx.txi b/doc/interpreter/cp-idx.txi
--- a/doc/interpreter/cp-idx.txi
+++ b/doc/interpreter/cp-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -185,65 +185,64 @@ the commands @code{dbstep}.
 
 @DOCSTRING(dbdown)
 
 @node Profiling
 @section Profiling
 @cindex profiler
 @cindex code profiling
 
-Octave supports profiling of code execution on a per-function level. If
+Octave supports profiling of code execution on a per-function level.  If
 profiling is enabled, each call to a function (supporting built-ins,
 operators, functions in oct- and mex-files, user-defined functions in
 Octave code and anonymous functions) is recorded while running Octave
-code. After that, this data can aid in analyzing the code behavior, and
+code.  After that, this data can aid in analyzing the code behavior, and
 is in particular helpful for finding ``hot spots'' in the code which use
 up a lot of computation time and are the best targets to spend
 optimization efforts on.
 
 The main command for profiling is @code{profile}, which can be used to
 start or stop the profiler and also to query collected data afterwards.
 The data is returned in an Octave data structure which can then be
 examined or further processed by other routines or tools.
 
 @DOCSTRING(profile)
 
 An easy way to get an overview over the collected data is
-@code{profshow}. This function takes the profiler data returned by
+@code{profshow}.  This function takes the profiler data returned by
 @code{profile} as input and prints a flat profile, for instance:
 
 @example
 @group
  Function Attr     Time (s)        Calls
 ----------------------------------------
    >myfib    R        2.195        13529
 binary <=             0.061        13529
  binary -             0.050        13528
  binary +             0.026         6764
 @end group
 @end example
 
 This shows that most of the run time was spent executing the function
 @samp{myfib}, and some minor proportion evaluating the listed binary
-operators. Furthermore, it is shown how often the function was called
+operators.  Furthermore, it is shown how often the function was called
 and the profiler also records that it is recursive.
 
 @DOCSTRING(profshow)
 
 @DOCSTRING(profexplore)
 
 @node Profiler Example
 @section Profiler Example
 
-Below, we will give a short example of a profiler session. See also
+Below, we will give a short example of a profiler session.  See also
 @ref{Profiling} for the documentation of the profiler functions in
-detail. Consider the code:
+detail.  Consider the code:
 
 @example
-@group
 global N A;
 
 N = 300;
 A = rand (N, N);
 
 function xt = timesteps (steps, x0, expM)
   global N;
 
@@ -269,34 +268,33 @@ endfunction
 
 function fib = bar (N)
   if (N <= 2)
     fib = 1;
   else
     fib = bar (N - 1) + bar (N - 2);
   endif
 endfunction
-@end group
 @end example
 
 If we execute the two main functions, we get:
 
 @example
 @group
 tic; foo; toc;
 @result{} Elapsed time is 2.37338 seconds.
 
 tic; bar (20); toc;
 @result{} Elapsed time is 2.04952 seconds.
 @end group
 @end example
 
 But this does not give much information about where this time is spent;
 for instance, whether the single call to @code{expm} is more expensive
-or the recursive time-stepping itself. To get a more detailed picture,
+or the recursive time-stepping itself.  To get a more detailed picture,
 we can use the profiler.
 
 @example
 @group
 profile on;
 foo;
 profile off;
 
@@ -321,96 +319,98 @@ This prints a table like:
   34      norm             0.011            1
   40  binary -             0.004          101
   33   balance             0.003            1
 @end group
 @end example
 
 The entries are the individual functions which have been executed (only
 the 10 most important ones), together with some information for each of
-them. The entries like @samp{binary *} denote operators, while other
-entries are ordinary functions. They include both built-ins like
-@code{expm} and our own routines (for instance @code{timesteps}). From
+them.  The entries like @samp{binary *} denote operators, while other
+entries are ordinary functions.  They include both built-ins like
+@code{expm} and our own routines (for instance @code{timesteps}).  From
 this profile, we can immediately deduce that @code{expm} uses up the
 largest proportion of the processing time, even though it is only called
-once. The second expensive operation is the matrix-vector product in the
-routine @code{timesteps}. @footnote{We only know it is the binary
+once.  The second expensive operation is the matrix-vector product in the
+routine @code{timesteps}.  @footnote{We only know it is the binary
 multiplication operator, but fortunately this operator appears only at
 one place in the code and thus we know which occurrence takes so much
-time. If there were multiple places, we would have to use the
+time.  If there were multiple places, we would have to use the
 hierarchical profile to find out the exact place which uses up the time
 which is not covered in this example.}
 
 Timing, however, is not the only information available from the profile.
 The attribute column shows us that @code{timesteps} calls itself
-recursively. This may not be that remarkable in this example (since it's
-clear anyway), but could be helpful in a more complex setting. As to the
+recursively.  This may not be that remarkable in this example (since it's
+clear anyway), but could be helpful in a more complex setting.  As to the
 question of why is there a @samp{binary \} in the output, we can easily
-shed some light on that too. Note that @code{data} is a structure array
+shed some light on that too.  Note that @code{data} is a structure array
 (@ref{Structure Arrays}) which contains the field @code{FunctionTable}.
-This stores the raw data for the profile shown. The number in the first
+This stores the raw data for the profile shown.  The number in the first
 column of the table gives the index under which the shown function can
-be found there. Looking up @code{data.FunctionTable(41)} gives:
+be found there.  Looking up @code{data.FunctionTable(41)} gives:
 
 @example
 @group
   scalar structure containing the fields:
 
     FunctionName = binary \
     TotalTime =  0.18765
     NumCalls =  1
     IsRecursive = 0
     Parents =  7
     Children = [](1x0)
 @end group
 @end example
 
 Here we see the information from the table again, but have additional
-fields @code{Parents} and @code{Children}. Those are both arrays, which
+fields @code{Parents} and @code{Children}.  Those are both arrays, which
 contain the indices of functions which have directly called the function
 in question (which is entry 7, @code{expm}, in this case) or been called
-by it (no functions). Hence, the backslash operator has been used
+by it (no functions).  Hence, the backslash operator has been used
 internally by @code{expm}.
 
-Now let's take a look at @code{bar}. For this, we start a fresh
+Now let's take a look at @code{bar}.  For this, we start a fresh
 profiling session (@code{profile on} does this; the old data is removed
 before the profiler is restarted):
 
 @example
 @group
 profile on;
 bar (20);
 profile off;
 
 profshow (profile ('info'));
 @end group
 @end example
 
 This gives:
 
 @example
+@group
    #            Function Attr     Time (s)        Calls
 -------------------------------------------------------
    1                 bar    R        2.091        13529
    2           binary <=             0.062        13529
    3            binary -             0.042        13528
    4            binary +             0.023         6764
    5             profile             0.000            1
    8               false             0.000            1
    6              nargin             0.000            1
    7           binary !=             0.000            1
    9 __profiler_enable__             0.000            1
+@end group
 @end example
 
-Unsurprisingly, @code{bar} is also recursive. It has been called 13,529
+Unsurprisingly, @code{bar} is also recursive.  It has been called 13,529
 times in the course of recursively calculating the Fibonacci number in a
 suboptimal way, and most of the time was spent in @code{bar} itself.
 
 Finally, let's say we want to profile the execution of both @code{foo}
-and @code{bar} together. Since we already have the run-time data
+and @code{bar} together.  Since we already have the run-time data
 collected for @code{bar}, we can restart the profiler without clearing
 the existing data and collect the missing statistics about @code{foo}.
 This is done by:
 
 @example
 @group
 profile resume;
 foo;
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2009-2011 Jaroslav Hajek
+@c Copyright (C) 2009-2012 Jaroslav Hajek
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -33,21 +33,23 @@ AutoCAD
 Autoconf
 autocorrelations
 autocovariances
 autoload
 Autoload
 autoloaded
 autoloading
 Autoloading
+Automake
 autoregression
 autoregressions
 autoscaled
 AutoScaling
 AWK
+awt
 backend
 Backends
 backends
 bartlett
 Bateman
 BDF
 bdf
 betacdf
@@ -76,17 +78,19 @@ boolMatrix
 boxerrorbars
 boxoff
 boxon
 boxxyerrorbars
 bracketx
 brackety
 breakpoint
 Brenan
+broadcastable
 Brockwell
+BSX
 builtin
 builtins
 ButtonDownFcn
 BV
 bz
 BZ
 bzip
 CallbackObject
@@ -156,16 +160,20 @@ courseware
 cov
 CPLEX
 CreateFcn
 CRLF
 csymamd
 ctranspose
 CTRL
 CTS
+cummax
+cummin
+cumprod
+cumsum
 cURL
 Cuthill
 cxsparse
 Cygwin
 DAE
 DAEs
 daspk
 dasrt
@@ -220,16 +228,17 @@ dx
 dy
 EastOutside
 EIDORS
 eigenpairs
 eigenvector
 eigenvectors
 eigs
 Ekerdt
+elementwise
 Elfers
 elseif
 emacs
 emptyvalue
 endfunction
 endian
 Endian
 endif
@@ -293,16 +302,17 @@ fontname
 forall
 foregroundcolor
 formfeed
 Fortran
 fpdf
 fprintf
 FreeBSD
 freespacing
+FreeType
 freetype
 frnd
 frob
 Frobenius
 Fs
 FSF
 FunValCheck
 gamcdf
@@ -327,34 +337,37 @@ gesvd
 gfortan
 Ghostscript
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
+gnulib
 gnuplot
 Gnuplot
 gnuplot's
 Golub
 Gonnet
 goto
 Goto
 gotos
 GPL
+GPLK
 gplot
 grabdemo
 GradObj
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
 gswin
+GUIs
 gunzipped
 gz
 gzip
 gzipped
 Hackbusch
 Hadamard
 Haddad
 Hankel
@@ -390,16 +403,17 @@ Huhdanpaa
 hygecdf
 hygeinv
 hygepdf
 hygernd
 Hyndman
 Hypergeometric
 hypergeometric
 IEEE
+ifelse
 iff
 ifft
 ifftn
 ignorecase
 IIP
 ij
 Im
 imag
@@ -433,16 +447,17 @@ isvector
 ith
 iy
 Jacobian
 Jacobians
 ji
 jpeg
 JPEG
 jpg
+jvm
 keybindings
 keypress
 Kolmogorov
 kolmogorov
 Konrod
 Krishnamurthy
 kron
 kruskal
@@ -470,16 +485,17 @@ leq
 Levinson
 LF
 lfloor
 li
 libcruft
 libcurl
 liblapack
 liboctave
+Libtool
 licensors
 lineanchors
 linefeeds
 linesearch
 linespec
 linespoints
 linkprop
 literalspacing
@@ -534,39 +550,44 @@ Mendelsohn
 Mersenne
 meshgrid
 meshgridded
 metafile
 Metafile
 metafiles
 Metafont
 mex
+mget
 Michelsen
 Microsystems
+MinGW
 minima
 Minimizers
 Minitab
 minval
 MIP
 miscompiled
 Misra
+mkdir
 mkoctfile
 mldivide
 mmd
 MMM
 mmm
 mmmm
 mmmyy
 mmmyyyy
 modelled
 Moler
 Montanet
 mpoles
 mpower
+mput
 mrdivide
+MSYS
 mtimes
 Multi
 multi
 multibyte
 multiline
 multipledelimsasone
 MultiSelect
 mxArray
@@ -593,31 +614,33 @@ Ng
 ni
 Nishimura
 NLP
 nnls
 nnz
 nocompute
 nolabel
 noncommercially
+nonconformant
 nonsmooth
 nonzeros
 noperm
 normcdf
 normest
 norminv
 normpdf
 normrnd
 NorthOutside
 noscal
 noshare
 notin
 nthargout
 NTSC
 nul
+Numpy
 Nx
 nzmax
 oct
 octaverc
 ODEPACK
 OLS
 onCleanup
 online
@@ -728,32 +751,35 @@ readline
 recursing
 reentrant
 regex
 regressor
 reimported
 Reindent
 relicensing
 ren
+renderer
+repelems
 repmat
 resampled
 resampling
 Resize
 resize
 resized
 resnorm
 resparsify
 RET
 returnonerror
 rfloor
 RGB
 Riccati
 Rightarrow
 rightarrow
 rline
+rmdir
 RMS
 rnd
 roffset
 Rosser
 Rossum
 rpath
 RPMs
 rr
@@ -763,26 +789,28 @@ Sandia
 SAS
 sB
 Schafer
 schar
 Schur
 SCO
 screenful
 se
+sed
 seealso
 semidefinite
 Sep
 Shampine
 shiftdim
 si
 signum
 SIGNUM
 sim
 SIMAX
+SIMD
 simplechol
 simplecholperm
 simplematrix
 simplices
 sinetone
 sm
 smirnov
 Smirnov
@@ -856,16 +884,17 @@ Subscripted
 subscripted
 subscripting
 subseteq
 subsindex
 subsref
 substring
 substrings
 SuiteSparse
+sumsq
 SunOS
 superiorto
 supradiagonal
 supset
 supseteq
 SV
 SVD
 svd
@@ -889,16 +918,17 @@ textscan
 th
 ths
 tif
 Tikhonov
 TikZ
 tinv
 Tisseur
 Tisseur's
+tmp
 Toeplitz
 tokenExtents
 TolF
 TolFun
 TolX
 toolkits
 Toolkits
 tp
@@ -973,16 +1003,18 @@ vectorizing
 vee
 versa
 vertcat
 vertices
 Villadsen
 voronoi
 Voronoi
 Wa
+waitbar
+waitbars
 wallis
 wblcdf
 wblinv
 wblpdf
 wblrnd
 Weibull
 Welch
 welch
@@ -1024,18 +1056,20 @@ xu
 xwd
 xy
 xyerrorbar
 xyerrorbars
 xyz
 ydata
 yerrorbar
 yerrorbars
+ylim
 yy
 YY
 yyyy
 YYYY
 yyyymmdd
 yyyymmddTHHMMSS
 Zechner
 zer
 Ziggurat
 zlib
+zlim
diff --git a/doc/interpreter/doccheck/mk_undocumented_list b/doc/interpreter/doccheck/mk_undocumented_list
--- a/doc/interpreter/doccheck/mk_undocumented_list
+++ b/doc/interpreter/doccheck/mk_undocumented_list
@@ -4,17 +4,17 @@
 # Get a list from Octave of all visible functions
 @octave_output = <<`_END_OCT_SCRIPT_`;
 ../../run-octave --norc --silent --no-history --eval '\
  funclist  = vertcat (__list_functions__ , __builtins__) \
  disp("#!-separator-!#") \
  where = cellfun (\@which, funclist, \"UniformOutput\", 0)'
 _END_OCT_SCRIPT_
 
-die "Unable to invoke 'run-octave'.  Exiting\n" unless (@octave_output);
+unless (@octave_output) { die "Unable to invoke 'run-octave'.  Exiting\n" ;}
 
 ################################################################################
 # Winnow list of functions that require a DOCSTRING
 
 $idx = 0;
 while (($_ = $octave_output[$idx++]) !~ /^#!-separator-!#$/)
 {
    push(@all_functions, $1) if (/] = (\w+)$/);
@@ -81,19 +81,19 @@ bug_report
 chdir
 comma
 debug
 dbnext
 exit
 F_DUPFD
 F_GETFD
 F_GETFL
+fact
 finite
 fmod
-fntests
 F_SETFD
 F_SETFL
 gammaln
 home
 i
 ifelse
 inf
 inverse
@@ -115,17 +115,16 @@ O_RDWR
 O_SYNC
 O_TRUNC
 O_WRONLY
 paren
 SEEK_CUR
 SEEK_END
 semicolon
 setenv
-shell_cmd
 toc
 triu
 unimplemented
 upper
 ylabel
 ylim
 zlabel
 zlim
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton and David Bateman
+@c Copyright (C) 2007-2012 John W. Eaton and David Bateman
 @c Copyright (C) 2007 Paul Thomas and Christoph Spiel
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 Kurt Hornik
+@c Copyright (C) 1996-2012 Kurt Hornik
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -50,158 +50,247 @@ combinations of these with various opera
 @opindex :
 
 An @dfn{index expression} allows you to reference or extract selected
 elements of a matrix or vector.
 
 Indices may be scalars, vectors, ranges, or the special operator
 @samp{:}, which may be used to select entire rows or columns.
 
-Vectors are indexed using a single index expression.  Matrices may be
-indexed using one or two indices.  When using a single index
-expression, the elements of the matrix are taken in column-first order;
-the dimensions of the output match those of the index expression.  For
-example,
+Vectors are indexed using a single index expression.  Matrices (2-D)
+and higher multi-dimensional arrays are indexed using either one index
+or @math{N} indices where @math{N} is the dimension of the array.
+When using a single index expression to index 2-D or higher data the
+elements of the array are taken in column-first order (like Fortran).
+
+The output from indexing assumes the dimensions of the index
+expression.  For example:
 
 @example
 @group
-a(2)       # a scalar
-a(1:2)     # a row vector
-a([1; 2])  # a column vector
+a(2)       # result is a scalar
+a(1:2)     # result is a row vector
+a([1; 2])  # result is a column vector
 @end group
 @end example
 
 As a special case, when a colon is used as a single index, the output
-is a column vector containing all the elements of the vector or matrix.
-For example:
+is a column vector containing all the elements of the vector or
+matrix.  For example:
 
 @example
-a(:)       # a column vector
+@group
+a(:)       # result is a column vector
+a(:)'      # result is a row vector
+@end group
 @end example
 
+The above two code idioms are often used in place of @code{reshape}
+when a simple vector, rather than an arbitrarily sized array, is
+needed.
+
 Given the matrix
 
 @example
 a = [1, 2; 3, 4]
 @end example
 
 @noindent
-all of the following expressions are equivalent
+all of the following expressions are equivalent and select the first
+row of the matrix.
 
 @example
 @group
-a(1, [1, 2])
-a(1, 1:2)
-a(1, :)
+a(1, [1, 2])  # row 1, columns 1 and 2
+a(1, 1:2)     # row 1, columns in range 1-2
+a(1, :)       # row 1, all columns
+@end group
+@end example
+
+@cindex @code{end}, indexing
+@cindex :end
+
+In index expressions the keyword @code{end} automatically refers to
+the last entry for a particular dimension.  This magic index can also
+be used in ranges and typically eliminates the needs to call
+@code{size} or @code{length} to gather array bounds before indexing.
+For example:
+
+@example
+@group
+a = [1, 2, 3, 4];
+
+a(1:end/2)        # first half of a => [1, 2]
+a(end + 1) = 5;   # append element 
+a(end) = [];      # delete element 
+a(1:2:end)        # odd elements of a => [1, 3]
+a(2:2:end)        # even elements of a => [2, 4]
+a(end:-1:1)       # reversal of a => [4, 3, 2 , 1]
 @end group
 @end example
 
-@noindent
-and select the first row of the matrix.
+@menu
+* Advanced Indexing::
+@end menu
+
+@node Advanced Indexing
+@subsection Advanced Indexing
+
+An array with @samp{n} dimensions can be indexed using @samp{m}
+indices.  More generally, the set of index tuples determining the
+result is formed by the Cartesian product of the index vectors (or
+ranges or scalars).
+
+For the ordinary and most common case, @w{@code{m == n}}, and each
+index corresponds to its respective dimension.  If @w{@code{m < n}}
+and every index is less than the size of the array in the
+@math{i^{th}} dimension, @code{m(i) < n(i)}, then the index expression
+is padded with trailing singleton dimensions (@code{[ones (m-n, 1)]}).
+If @w{@code{m < n}} but one of the indices @code{m(i)} is outside the
+size of the current array, then the last @w{@code{n-m+1}} dimensions
+are folded into a single dimension with an extent equal to the product
+of extents of the original dimensions.  This is easiest to understand
+with an example.
 
-In general, an array with @samp{n} dimensions can be indexed using @samp{m}
-indices.  If @code{n == m}, each index corresponds to its respective dimension.
-The set of index tuples determining the result is formed by the Cartesian
-product of the index vectors (or ranges or scalars).  If @code{n < m}, then the
-array is padded by trailing singleton dimensions.  If @code{n > m}, the last
-@code{n-m+1} dimensions are folded into a single dimension with extent equal to
-product of extents of the original dimensions.
+@example
+a = reshape (1:8, 2, 2, 2)  # Create 3-D array
+a =
+
+ans(:,:,1) =
+
+   1   3
+   2   4
+
+ans(:,:,2) =
+
+   5   7
+   6   8
 
-@c FIXED -- sections on variable prefer_zero_one_indexing were removed
+a(2,1,2);   # Case (m == n): ans = 6
+a(2,1);     # Case (m < n), idx within array:
+            # equivalent to a(2,1,1), ans = 2
+a(2,4);     # Case (m < n), idx outside array:
+            # Dimension 2 & 3 folded into new dimension of size 2x2 = 4
+            # Select 2nd row, 4th element of [2, 4, 6, 8], ans = 8
+@end example
 
-Indexing a scalar with a vector of ones can be used to create a
-vector the same size as the index vector, with each element equal to
-the value of the original scalar.  For example, the following statements
+One advanced use of indexing is to create arrays filled with a single
+value.  This can be done by using an index of ones on a scalar value.
+The result is an object with the dimensions of the index expression
+and every element equal to the original scalar.  For example, the
+following statements
 
 @example
 @group
 a = 13;
 a(ones (1, 4))
 @end group
 @end example
 
 @noindent
 produce a vector whose four elements are all equal to 13.
 
-Similarly, indexing a scalar with two vectors of ones can be used to
-create a matrix.  For example the following statements
+Similarly, by indexing a scalar with two vectors of ones it is
+possible to create a matrix.  The following statements
 
 @example
 @group
 a = 13;
 a(ones (1, 2), ones (1, 3))
 @end group
 @end example
 
 @noindent
-create a 2 by 3 matrix with all elements equal to 13.
+create a 2x3 matrix with all elements equal to 13.
 
 The last example could also be written as
 
 @example
 @group
-13 (ones (2, 3))
+13(ones (2, 3))
 @end group
 @end example
 
-It should be, noted that @code{ones (1, n)} (a row vector of ones) results in a
-range (with zero increment), and is therefore more efficient when used in index
-expression than other forms of @dfn{ones}.  In particular, when @samp{r} is a
-row vector, the expressions
+It is more efficient to use indexing rather than the code construction
+@code{scalar * ones (N, M, @dots{})} because it avoids the unnecessary
+multiplication operation.  Moreover, multiplication may not be
+defined for the object to be replicated whereas indexing an array is
+always defined.  The following code shows how to create a 2x3 cell
+array from a base unit which is not itself a scalar.
+
+@example
+@group
+@{"Hello"@}(ones (2, 3))
+@end group
+@end example
+
+It should be, noted that @code{ones (1, n)} (a row vector of ones)
+results in a range (with zero increment).  A range is stored
+internally as a starting value, increment, end value, and total number
+of values; hence, it is more efficient for storage than a vector or
+matrix of ones whenever the number of elements is greater than 4.  In
+particular, when @samp{r} is a row vector, the expressions
 
 @example
   r(ones (1, n), :)
 @end example
 
 @example
   r(ones (n, 1), :)
 @end example
 
 @noindent
-will produce identical results, but the first one will be significantly
-faster, at least for @samp{r} and @samp{n} large enough.  The reason is that
-in the first case the index is kept in a compressed form, which allows Octave
-to choose a more efficient algorithm to handle the expression.
+will produce identical results, but the first one will be
+significantly faster, at least for @samp{r} and @samp{n} large enough.
+In the first case the index is held in compressed form as a range
+which allows Octave to choose a more efficient algorithm to handle the
+expression.
 
-In general, for an user unaware of these subtleties, it is best to use
-the function @dfn{repmat} for spreading arrays into bigger ones.
+A general recommendation, for a user unaware of these subtleties, is
+to use the function @code{repmat} for replicating smaller arrays into
+bigger ones.
 
-It is also possible to create a matrix with different values.  The
-following example creates a 10 dimensional row vector @math{a} containing
-the values
+A second use of indexing is to speed up code.  Indexing is a fast
+operation and judicious use of it can reduce the requirement for
+looping over individual array elements which is a slow operation.
+
+Consider the following example which creates a 10-element row vector
+@math{a} containing the values
 @tex
 $a_i = \sqrt{i}$.
 @end tex
 @ifnottex
 a(i) = sqrt(i).
 @end ifnottex
 
 @example
 @group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
 @end group
 @end example
 
 @noindent
-Note that it is quite inefficient to create a vector using a loop like
-the one shown in the example above.  In this particular case, it would
-have been much more efficient to use the expression
+It is quite inefficient to create a vector using a loop like this.  In
+this case, it would have been much more efficient to use the
+expression
 
 @example
 a = sqrt (1:10);
 @end example
 
 @noindent
-thus avoiding the loop entirely.  In cases where a loop is still
-required, or a number of values must be combined to form a larger
-matrix, it is generally much faster to set the size of the matrix first,
-and then insert elements using indexing commands.  For example, given a
-matrix @code{a},
+which avoids the loop entirely.
+
+In cases where a loop cannot be avoided, or a number of values must be
+combined to form a larger matrix, it is generally faster to set the
+size of the matrix first (pre-allocate storage), and then insert
+elements using indexing commands.  For example, given a matrix
+@code{a},
 
 @example
 @group
 [nr, nc] = size (a);
 x = zeros (nr, n * nc);
 for i = 1:n
   x(:,(i-1)*nc+1:i*nc) = a;
 endfor
@@ -216,18 +305,18 @@ is considerably faster than
 x = a;
 for i = 1:n-1
   x = [x, a];
 endfor
 @end group
 @end example
 
 @noindent
-particularly for large matrices because Octave does not have to
-repeatedly resize the result.
+because Octave does not have to repeatedly resize the intermediate
+result.
 
 @DOCSTRING(sub2ind)
 
 @DOCSTRING(ind2sub)
 
 @DOCSTRING(isindex)
 
 @DOCSTRING(allow_noninteger_range_as_index)
@@ -418,46 +507,49 @@ the recursion depth and prevents Octave 
 @cindex unary minus
 @cindex exponentiation
 @cindex transpose
 @cindex Hermitian operator
 @cindex transpose, complex-conjugate
 @cindex complex-conjugate transpose
 
 The following arithmetic operators are available, and work on scalars
-and matrices.
+and matrices.  The element-by-element operators and functions broadcast
+(@pxref{Broadcasting}).
 
 @table @asis
 @item @var{x} + @var{y}
 @opindex +
 Addition.  If both operands are matrices, the number of rows and columns
-must both agree.  If one operand is a scalar, its value is added to
-all the elements of the other operand.
+must both agree, or they must be broadcastable to the same shape.
 
 @item @var{x} .+ @var{y}
 @opindex .+
-Element by element addition.  This operator is equivalent to @code{+}.
+Element-by-element addition.  This operator is equivalent to @code{+}.
 
 @item @var{x} - @var{y}
 @opindex -
 Subtraction.  If both operands are matrices, the number of rows and
-columns of both must agree.
+columns of both must agree, or they must be broadcastable to the same
+shape.
 
 @item @var{x} .- @var{y}
-Element by element subtraction.  This operator is equivalent to @code{-}.
+Element-by-element subtraction.  This operator is equivalent to @code{-}.
 
 @item @var{x} * @var{y}
 @opindex *
-Matrix multiplication.  The number of columns of @var{x} must agree
-with the number of rows of @var{y}.
+Matrix multiplication.  The number of columns of @var{x} must agree with
+the number of rows of @var{y}, or they must be broadcastable to the same
+shape.
 
 @item @var{x} .* @var{y}
 @opindex .*
-Element by element multiplication.  If both operands are matrices, the
-number of rows and columns must both agree.
+Element-by-element multiplication.  If both operands are matrices, the
+number of rows and columns must both agree, or they must be
+broadcastable to the same shape.
 
 @item @var{x} / @var{y}
 @opindex /
 Right division.  This is conceptually equivalent to the expression
 
 @example
 (inverse (y') * x')'
 @end example
@@ -465,17 +557,17 @@ Right division.  This is conceptually eq
 @noindent
 but it is computed without forming the inverse of @var{y'}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} ./ @var{y}
 @opindex ./
-Element by element right division.
+Element-by-element right division.
 
 @item @var{x} \ @var{y}
 @opindex \
 Left division.  This is conceptually equivalent to the expression
 
 @example
 inverse (x) * y
 @end example
@@ -483,17 +575,17 @@ inverse (x) * y
 @noindent
 but it is computed without forming the inverse of @var{x}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} .\ @var{y}
 @opindex .\
-Element by element left division.  Each element of @var{y} is divided
+Element-by-element left division.  Each element of @var{y} is divided
 by each corresponding element of @var{x}.
 
 @item @var{x} ^ @var{y}
 @itemx @var{x} ** @var{y}
 @opindex **
 @opindex ^
 Power operator.  If @var{x} and @var{y} are both scalars, this operator
 returns @var{x} raised to the power @var{y}.  If @var{x} is a scalar and
@@ -504,18 +596,23 @@ expansion if @var{y} is not an integer. 
 @var{x} and @var{y} are matrices.
 
 The implementation of this operator needs to be improved.
 
 @item @var{x} .^ @var{y}
 @itemx @var{x} .** @var{y}
 @opindex .**
 @opindex .^
-Element by element power operator.  If both operands are matrices, the
-number of rows and columns must both agree.
+Element-by-element power operator.  If both operands are matrices, the
+number of rows and columns must both agree, or they must be
+broadcastable to the same shape.  If several complex results are
+possible, the one with smallest non-negative argument (angle) is taken.
+This rule may return a complex root even when a real root is also possible.
+Use @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a
+real result is preferred.
 
 @item -@var{x}
 @opindex -
 Negation.
 
 @item +@var{x}
 @opindex +
 Unary plus.  This operator has no effect on the operand.
@@ -530,17 +627,17 @@ equivalent to the expression
 conj (x.')
 @end example
 
 @item @var{x}.'
 @opindex .'
 Transpose.
 @end table
 
-Note that because Octave's element by element operators begin with a
+Note that because Octave's element-by-element operators begin with a
 @samp{.}, there is a possible ambiguity for statements like
 
 @example
 1./m
 @end example
 
 @noindent
 because the period could be interpreted either as part of the constant
@@ -621,29 +718,30 @@ useful in this case.
 @cindex equality, tests for
 
 @dfn{Comparison operators} compare numeric values for relationships
 such as equality.  They are written using
 @emph{relational operators}.
 
 All of Octave's comparison operators return a value of 1 if the
 comparison is true, or 0 if it is false.  For matrix values, they all
-work on an element-by-element basis.  For example:
+work on an element-by-element basis.  Broadcasting rules apply.
+@xref{Broadcasting}.  For example:
 
 @example
 @group
 [1, 2; 3, 4] == [1, 3; 2, 4]
      @result{}  1  0
          0  1
 @end group
 @end example
 
-If one operand is a scalar and the other is a matrix, the scalar is
-compared to each element of the matrix in turn, and the result is the
-same size as the matrix.
+According to broadcasting rules, if one operand is a scalar and the
+other is a matrix, the scalar is compared to each element of the matrix
+in turn, and the result is the same size as the matrix.
 
 @table @code
 @item @var{x} < @var{y}
 @opindex <
 True if @var{x} is less than @var{y}.
 
 @item @var{x} <= @var{y}
 @opindex <=
@@ -768,28 +866,28 @@ of @var{boolean1} or @var{boolean2} is t
 @item ! @var{boolean}
 @itemx ~ @var{boolean}
 @opindex ~
 @opindex !
 Each element of the result is true if the corresponding element of
 @var{boolean} is false.
 @end table
 
-For matrix operands, these operators work on an element-by-element
-basis.  For example, the expression
+These operators work on an element-by-element basis.  For example, the
+expression
 
 @example
 [1, 0; 0, 1] & [1, 0; 2, 3]
 @end example
 
 @noindent
 returns a two by two identity matrix.
 
-For the binary operators, the dimensions of the operands must conform if
-both are matrices.  If one of the operands is a scalar and the other a
+For the binary operators, broadcasting rules apply.  @xref{Broadcasting}.
+In particular, if one of the operands is a scalar and the other a
 matrix, the operator is applied to the scalar and each element of the
 matrix.
 
 For the binary element-by-element boolean operators, both subexpressions
 @var{boolean1} and @var{boolean2} are evaluated before computing the
 result.  This can make a difference when the expressions have side
 effects.  For example, in the expression
 
diff --git a/doc/interpreter/fn-idx.txi b/doc/interpreter/fn-idx.txi
--- a/doc/interpreter/fn-idx.txi
+++ b/doc/interpreter/fn-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -285,18 +285,18 @@ endfunction
 
 In this particular case, the two values could have been returned as
 elements of a single array, but that is not always possible or
 convenient.  The values to be returned may not have compatible
 dimensions, and it is often desirable to give the individual return
 values distinct names.
 
 It is possible to use the @code{nthargout} function to obtain only some
-of the return values or several at once in a cell array. @ref{Cell Array
-Objects}
+of the return values or several at once in a cell array.
+@ref{Cell Array Objects}
 
 @DOCSTRING(nthargout)
 
 In addition to setting @code{nargin} each time a function is called,
 Octave also automatically initializes @code{nargout} to the number of
 values that are expected to be returned.  This allows you to write
 functions that behave differently depending on the number of values that
 the user of the function has requested.  The implicit assignment to the
@@ -1140,16 +1140,18 @@ list.  If there are no arguments, you mu
 f = @@sin;
 feval (f, pi/4)
     @result{} 0.70711
 f (pi/4)
     @result{} 0.70711
 @end group
 @end example
 
+@DOCSTRING(is_function_handle)
+
 @DOCSTRING(functions)
 
 @DOCSTRING(func2str)
 
 @DOCSTRING(str2func)
 
 @node Anonymous Functions
 @subsection Anonymous Functions
@@ -1220,18 +1222,16 @@ After this it is possible to evaluate @m
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
 @DOCSTRING(argnames)
 
 @DOCSTRING(formula)
 
-@DOCSTRING(vectorize)
-
 @DOCSTRING(symvar)
 
 @node Commands
 @section Commands
 
 Commands are a special class of functions that only accept string
 input arguments.  A command can be called as an ordinary function, but
 it can also be called without the parentheses.  For example,
@@ -1345,16 +1345,19 @@ Functions to manage the directory path O
 Package manager for installing external packages of functions in Octave.
 
 @item plot
 Functions for displaying and printing two- and three-dimensional graphs.
 
 @item polynomial
 Functions for manipulating polynomials.
 
+@item prefs
+Functions implementing user-defined preferences.
+
 @item set
 Functions for creating and manipulating sets of unique values.
 
 @item signal
 Functions for signal processing applications.
 
 @item sparse
 Functions for handling sparse matrices.
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton and David Bateman
+@c Copyright (C) 2007-2012 John W. Eaton and David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2011 Rik Wehbring
+@c Copyright (C) 2012 Rik Wehbring
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -39,17 +39,251 @@ derived file.
 
 @node Installation
 @chapter Installing Octave
 @end ifset
 
 @cindex installing Octave
 
 The procedure for installing Octave from source on a Unix-like system is
-described below.  Building on other platforms will follow similar steps.
+described below.  Building on other platforms will follow similar
+steps.  Note that this description applies to Octave releases.  Building
+the development sources from the Mercurial archive requires additional
+steps as described in @ref{Building the Development Sources}.
+
+@menu
+* Build Dependencies::
+* Running Configure and Make::
+* Compiling Octave with 64-bit Indexing::
+* Installation Problems::
+@end menu
+
+@node Build Dependencies
+@section Build Dependencies
+
+Octave is a fairly large program with many build dependencies.  You may
+be able to find pre-packaged versions of the dependencies distributed as
+part of your system, or you may have to build some or all of them
+yourself.
+
+@menu
+* Tips for Specific Systems::
+* Build Tools::
+* External Packages::
+@end menu
+
+@node Tips for Specific Systems
+@subsection Tips for Specific Systems
+
+The names of pre-compiled packages vary by system and do not always
+match exactly the names listed above.
+
+You will usually need the development version of an external dependency
+so that you get the libraries and header files for building software,
+not just for running already compiled programs.  These packages
+typically have names that end with the suffix @code{-dev} or @code{-devel}.
+
+On systems with @code{apt-get} (Debian, Ubuntu, etc.), you may be able
+to install most of the tools and external packages using a command
+similar to
+
+@example
+apt-get build-dep octave
+@end example
+
+@noindent
+The specific package name may be @code{octave3.2} or @code{octave3.4}.
+The set of required tools and external dependencies does not change
+frequently, so it is not important that the version match exactly, but
+you should use the most recent one available.
+
+On systems with @code{yum} (Fedora, Red Hat, etc.), you may be able to
+install most of the tools and external packages using a command similar to
+
+@example
+yum-builddep octave
+@end example
+
+@noindent
+The @code{yum-builddep} utility is part of the @code{yum-utils} package.
+
+For either type of system, the package name may include a version
+number.  The set of required tools and external dependencies does not
+change frequently, so it is not important that the version exactly match
+the version you are installing, but you should use the most recent one
+available.
+
+@node Build Tools
+@subsection Build Tools
+
+The following tools are required:
+
+@table @asis
+@item C++, C, and Fortran compilers
+The Octave sources are primarily written in C++, but some portions are
+also written in C and Fortran.  The Octave sources are intended to be
+portable.  Recent versions of the GNU compiler collection (GCC) should
+work (@url{http://gcc.gnu.org}).  If you use GCC, you should avoid
+mixing versions.  For example, be sure that you are not using the
+obsolete @code{g77} Fortran compiler with modern versions of @code{gcc}
+and @code{g++}.
+
+@item GNU Make
+Tool for building software (@url{http://www.gnu.org/software/make}).
+Octave's build system requires GNU Make.  Other versions of Make will
+not work.  Fortunately, GNU Make is highly portable and easy to install.
+
+@item AWK, sed, and other Unix utilities
+Basic Unix system utilities are required for building Octave.  All will
+be available with any modern Unix system and also on Windows with either
+Cygwin or MinGW and MSYS.
+@end table
+
+Additionally, the following tools may be needed:
+
+@table @asis
+@item Bison
+Parser generator (@url{http://www.gnu.org/software/bison}).
+You will need Bison if you modify the @code{oct-parse.yy} source file or
+if you delete the files that are generated from it.
+
+@item Flex
+Lexer analyzer (@url{http://www.gnu.org/software/flex}).  You will need
+Flex if you modify the @code{lex.ll} source file or if you delete the
+files that are generated from it.
+
+@item Autoconf
+Package for software configuration
+(@url{http://www.gnu.org/software/autoconf}).  Autoconf is required if
+you modify Octave's @code{configure.ac} file or other files that it
+requires.
+
+@item Automake
+Package for Makefile generation
+(@url{http://www.gnu.org/software/automake}).  Automake is required if
+you modify Octave's @code{Makefile.am} files or other files that they
+depend on.
+
+@item Libtool
+Package for building software libraries
+(@url{http://www.gnu.org/software/libtool}).  Libtool is required by
+Automake.
+@end table
+
+@node External Packages
+@subsection External Packages
+
+The following external packages are required:
+
+@table @asis
+@item BLAS
+Basic Linear Algebra Subroutine library
+(@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
+ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
+better performance.
+@item LAPACK
+Linear Algebra Package (@url{http://www.netlib.org/lapack}).
+@item PCRE
+The Perl Compatible Regular Expression library (http://www.pcre.org).
+@end table
+
+The following external package is optional but strongly recommended:
+
+@table @asis
+@item GNU Readline
+Command-line editing library (@url{www.gnu.org/s/readline}).
+@end table
+
+If you wish to build Octave without GNU readline installed, you must use
+the @code{--disable-readline} option when running the configure script.
+
+The following external software packages are optional but recommended:
+
+@table @asis
+@item ARPACK
+Library for the solution of large-scale eigenvalue problems
+(@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
+required to provide the functions @code{eigs} and @code{svds}.
+
+@item cURL
+Library for transferring data with URL syntax
+(@url{http://curl.haxx.se}).  cURL is required to provide the
+@code{urlread} and @code{urlwrite} functions and the @code{ftp} class.
+
+@item FFTW3
+Library for computing discrete Fourier transforms
+(@url{http://www.fftw.org}).  FFTW3 is used to provide better
+performance for functions that compute discrete Fourier transforms
+(@code{fft}, @code{ifft}, @code{fft2}, etc.)
+
+@item FLTK
+Portable GUI toolkit (@url{http://www.fltk.org}).  FLTK is currently
+used to provide windows for Octave's OpenGL-based graphics functions.
+
+@item fontconfig
+Library for configuring and customizing font access
+(@url{http://www.freedesktop.org/wiki/Software/fontconfig}).  Fontconfig
+is used to manage fonts for Octave's OpenGL-based graphics functions.
+
+@item FreeType
+Portable font engine (@url{http://www.freetype.org}).  FreeType is used
+to perform font rendering for Octave's OpenGL-based graphics functions.
+
+@item GLPK
+GNU Linear Programming Kit (@url{http://www.gnu.org/software/glpk}).
+GPLK is required for the function @code{glpk}.
+
+@item gnuplot
+Interactive graphics program (@url{http://www.gnuplot.info}).  gnuplot
+is currently the default graphics renderer for Octave.
+
+@item GraphicsMagick++
+Image processing library (@url{http://www.graphicsmagick.org}).
+GraphicsMagick++ is used to provide the @code{imread} and @code{imwrite}
+functions.
+
+@item HDF5
+Library for manipulating portable data files
+(@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
+@code{load} and @code{save} commands to read and write HDF data files.
+
+@item OpenGL
+API for portable 2D and 3D graphics (@url{http://www.opengl.org}).  An
+OpenGL implementation is required to provide Octave's OpenGL-based
+graphics functions.  Octave's OpenGL-based graphics functions usually
+outperform the gnuplot-based graphics functions because plot data can be
+rendered directly instead of sending data and commands to gnuplot for
+interpretation and rendering.
+
+@item Qhull
+Computational geometry library (@url{http://www.qhull.org}).  Qhull is
+required to provide the functions @code{convhull}, @code{convhulln}, 
+@code{delaunay}, @code{delaunay3}, @code{delaunayn}, @code{voronoi}, and
+@code{voronoin}.
+
+@item QRUPDATE
+QR factorization updating library
+(@url{http://sourceforge.net/projects/qrupdate}).  QRUPDATE is used to
+provide improved performance for the functions @code{qrdelete},
+@code{qrinsert}, @code{qrshift}, and @code{qrupdate}.
+
+@item SuiteSparse
+Sparse matrix factorization library
+(@url{http://www.cise.ufl.edu/research/sparse/SuiteSparse}).
+SuiteSparse is required to provide sparse matrix factorizations and
+solution of linear equations for sparse systems.
+
+@item zlib
+Data compression library (@url{http://zlib.net}).  The zlib library is
+required for Octave's @code{load} and @code{save} commands to handle
+compressed data, including @sc{Matlab} v5 MAT files.
+@end table
+
+@node Running Configure and Make
+@section Running Configure and Make
 
 @itemize @bullet
 @item
 Run the shell script @file{configure}.  This will determine the features
 your system has (or doesn't have) and create a file named
 @file{Makefile} from each of the files named @file{Makefile.in}.
 
 Here is a summary of the configure options that are most frequently used
@@ -77,17 +311,17 @@ about building Octave with this option.
 Enable bounds checking for indexing operators in the internal array
 classes.  This option is primarily used for debugging Octave.  Building
 Octave with this option has a negative impact on performance and is not
 recommended for general use.
 
 @item --disable-docs
 Disable building all forms of the documentation (Info, PDF, HTML).  The
 default is to build documentation, but your system will need functioning
-Texinfo and Tex installs for this to succeed.
+Texinfo and @TeX{} installs for this to succeed.
 
 @item --enable-float-truncate
 This option allows for truncation of intermediate floating point results
 in calculations.  It is only necessary for certain platforms.
 
 @item --enable-readline
 Use the readline library to provide for editing of the command line in
 terminal environments.  This option is on by default.
@@ -309,23 +543,18 @@ Executables to be run by Octave rather t
 @item @var{prefix}/lib/octave/@var{version}/oct/@var{arch}
 Object files that will be dynamically loaded.
 
 @item @var{prefix}/share/octave/@var{version}/imagelib
 Image files that are distributed with Octave.
 @end table
 @end itemize
 
-@menu
-* Compiling Octave with 64-bit Indexing::       
-* Installation Problems::       
-@end menu
-
 @node Compiling Octave with 64-bit Indexing  
-@appendixsec Compiling Octave with 64-bit Indexing
+@section Compiling Octave with 64-bit Indexing
 
 Note: the following only applies to systems that have 64-bit pointers.
 Configuring Octave with @option{--enable-64} cannot magically make a
 32-bit system have a 64-bit address space.
 
 On 64-bit systems, Octave is limited to (approximately) the following
 array sizes when using the default 32-bit indexing mode:
 
@@ -580,17 +809,17 @@ please submit a bug report.
 @item fontconfig
 
 @item fltk
 @end itemize
 
 @end itemize
 
 @node Installation Problems
-@appendixsec Installation Problems
+@section Installation Problems
 
 This section contains a list of problems (and some apparent problems
 that don't really mean anything is wrong) that may show up during
 installation of Octave.
 
 @itemize @bullet
 @item
 On some SCO systems, @code{info} fails to compile if
@@ -742,17 +971,17 @@ On NeXT systems, if you get errors like 
 @end group
 @end example
 
 @noindent
 when compiling @file{Array.cc} and @file{Matrix.cc}, try recompiling
 these files without @option{-g}.
 
 @item
-Some people have reported that calls to shell_cmd and the pager do not
+Some people have reported that calls to system() and the pager do not
 work on SunOS systems.  This is apparently due to having
 @w{@code{G_HAVE_SYS_WAIT}} defined to be 0 instead of 1 when compiling
 @code{libg++}.
 
 @item
 On NeXT systems, linking to @file{libsys_s.a} may fail to resolve the
 following functions
 
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 John W. Eaton
+@c Copyright (C) 2007-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -557,17 +557,19 @@ The description follows on succeeding li
 
 In a function description, the name of the function being described
 appears first.  It is followed on the same line by a list of parameters.
 The names used for the parameters are also used in the body of the
 description.
 
 Here is a description of an imaginary function @code{foo}:
 
-@deftypefn {Function} {} foo (@var{x}, @var{y}, @dots{})
+@deftypefn  {Function File} {} foo (@var{x})
+@deftypefnx {Function File} {} foo (@var{x}, @var{y})
+@deftypefnx {Function File} {} foo (@var{x}, @var{y}, @dots{})
 The function @code{foo} subtracts @var{x} from @var{y}, then adds the
 remaining arguments to the result.  If @var{y} is not supplied, then the
 number 19 is used by default.
 
 @example
 @group
 foo (1, [3, 5], 3, 9)
      @result{} [ 14, 16 ]
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -577,32 +577,32 @@ Print an integer as an unsigned octal nu
 Conversions}, for details.
 
 @item @samp{%u}
 Print an integer as an unsigned decimal number.  @xref{Integer
 Conversions}, for details.
 
 @item @samp{%x}, @samp{%X}
 Print an integer as an unsigned hexadecimal number.  @samp{%x} uses
-lower-case letters and @samp{%X} uses upper-case.  @xref{Integer
+lowercase letters and @samp{%X} uses uppercase.  @xref{Integer
 Conversions}, for details.
 
 @item @samp{%f}
 Print a floating-point number in normal (fixed-point) notation.
 @xref{Floating-Point Conversions}, for details.
 
 @item @samp{%e}, @samp{%E}
 Print a floating-point number in exponential notation.  @samp{%e} uses
-lower-case letters and @samp{%E} uses upper-case.  @xref{Floating-Point
+lowercase letters and @samp{%E} uses uppercase.  @xref{Floating-Point
 Conversions}, for details.
 
 @item @samp{%g}, @samp{%G}
 Print a floating-point number in either normal (fixed-point) or
 exponential notation, whichever is more appropriate for its magnitude.
-@samp{%g} uses lower-case letters and @samp{%G} uses upper-case.
+@samp{%g} uses lowercase letters and @samp{%G} uses uppercase.
 @xref{Floating-Point Conversions}, for details.
 
 @item @samp{%c}
 Print a single character.  @xref{Other Output Conversions}.
 
 @item @samp{%s}
 Print a string.  @xref{Other Output Conversions}.
 
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -24,17 +24,16 @@ elements of a matrix meet some condition
 elements of a matrix.  For example, Octave can easily tell you if all
 the elements of a matrix are finite, or are less than some specified
 value.  Octave can also rotate the elements, extract the upper- or
 lower-triangular parts, or sort the columns of a matrix.
 
 @menu
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 @end menu
 
 @node Finding Elements and Checking Conditions
 @section Finding Elements and Checking Conditions
 
 The functions @code{any} and @code{all} are useful for determining
@@ -135,23 +134,16 @@ its elements may have, consult @ref{Stat
 @DOCSTRING(prepad)
 
 @DOCSTRING(postpad)
 
 @DOCSTRING(diag)
 
 @DOCSTRING(blkdiag)
 
-@node Applying a Function to an Array
-@section Applying a Function to an Array
-
-@DOCSTRING(arrayfun)
-
-@DOCSTRING(bsxfun)
-
 @node Special Utility Matrices
 @section Special Utility Matrices
 
 @DOCSTRING(eye)
 
 @DOCSTRING(ones)
 
 @DOCSTRING(zeros)
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 John W. Eaton
+## Copyright (C) 2009-2012 John W. Eaton
 ##
 ## This program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 2000-2011 Dirk Eddelbuettel
+.\" Copyright (C) 2000-2012 Dirk Eddelbuettel
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
--- a/doc/interpreter/munge-texi.cc
+++ b/doc/interpreter/munge-texi.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/obsolete.txi b/doc/interpreter/obsolete.txi
--- a/doc/interpreter/obsolete.txi
+++ b/doc/interpreter/obsolete.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2010-2011 John W. Eaton
+@c Copyright (C) 2010-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/octave-config.1 b/doc/interpreter/octave-config.1
--- a/doc/interpreter/octave-config.1
+++ b/doc/interpreter/octave-config.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 2003-2011 Dirk Eddelbuettel
+.\" Copyright (C) 2003-2012 Dirk Eddelbuettel
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/octave.1 b/doc/interpreter/octave.1
--- a/doc/interpreter/octave.1
+++ b/doc/interpreter/octave.1
@@ -1,9 +1,9 @@
-.\" Copyright (C) 1996-2011 John W. Eaton
+.\" Copyright (C) 1996-2012 John W. Eaton
 .\"
 .\" This file is part of Octave.
 .\"
 .\" Octave is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
 .\" Free Software Foundation; either version 3 of the License, or (at
 .\" your option) any later version.
 .\"
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 % 
@@ -192,18 +192,19 @@ It corresponds to GNU Octave version @va
 * Statements::                  Looping and program flow control.
 * Functions and Scripts::       
 * Errors and Warnings::              
 * Debugging::
 * Input and Output::            
 * Plotting::                    
 * Matrix Manipulation::         
 * Arithmetic::                  
-* Linear Algebra::              
-* Nonlinear Equations::         
+* Linear Algebra::
+* Vectorization and Faster Code Execution::
+* Nonlinear Equations::
 * Diagonal and Permutation Matrices::
 * Sparse Matrices::
 * Numerical Integration::                  
 * Differential Equations::      
 * Optimization::                
 * Statistics::                  
 * Sets::                        
 * Polynomial Manipulations::    
@@ -378,16 +379,20 @@ Expressions
 * Calling Functions::           
 * Arithmetic Ops::              
 * Comparison Ops::              
 * Boolean Expressions::         
 * Assignment Ops::              
 * Increment Ops::               
 * Operator Precedence::         
 
+Index Expressions
+
+* Advanced Indexing::
+
 Calling Functions
 
 * Call by Value::               
 * Recursion::                   
 
 Boolean Expressions
 
 * Element-by-element Boolean Operators::  
@@ -467,28 +472,29 @@ Handling Warnings
 
 Debugging
 
 * Entering Debug Mode::
 * Leaving Debug Mode::
 * Breakpoints::
 * Debug Mode::
 * Call Stack::
+* Profiling::
+* Profiler Example::
 
 Input and Output
 
 * Basic Input and Output::      
 * C-Style I/O Functions::       
 
 Basic Input and Output
 
 * Terminal Output::             
 * Terminal Input::              
 * Simple File I/O::             
-* Rational Approximations::
 
 Terminal Output
 
 * Paging Screen Output::
 
 Simple File I/O
 
 * Saving Data on Unexpected Exits::
@@ -536,17 +542,17 @@ High-Level Plotting
 Two-Dimensional Plots
 
 * Axis Configuration::  
 * Two-dimensional Function Plotting::  
 * Two-dimensional Geometric Shapes::  
 
 Three-Dimensional Plots
 
-* Aspect Ratio::  
+* Aspect Ratio::
 * Three-dimensional Function Plotting::  
 * Three-dimensional Geometric Shapes::  
 
 Graphics Data Structures
 
 * Introduction to Graphics Structures::  
 * Graphics Objects::            
 * Graphics Object Properties::  
@@ -565,17 +571,17 @@ Graphics Object Properties
 * Surface Properties::          
 
 Advanced Plotting
 
 * Colors::                      
 * Line Styles::                 
 * Marker Styles::               
 * Callbacks::                   
-* Application-defined Data
+* Application-defined Data::
 * Object Groups::               
 * Graphics Toolkits::           
 
 Object Groups
 
 * Data Sources in Object Groups::  
 * Area Series::                 
 * Bar Series::                  
@@ -585,23 +591,22 @@ Object Groups
 * Quiver Group::                
 * Scatter Group::               
 * Stair Group::                 
 * Stem Series::                 
 * Surface Group::               
 
 Graphics Toolkits
 
-* Customizing Toolkit Behavior::
+* Customizing Toolkit Behavior::    
 
 Matrix Manipulation
 
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
-* Applying a Function to an Array::
 * Special Utility Matrices::    
 * Famous Matrices::             
 
 Arithmetic
 
 * Exponents and Logarithms::
 * Complex Arithmetic::          
 * Trigonometry::                
@@ -615,20 +620,29 @@ Arithmetic
 Linear Algebra
 
 * Techniques Used for Linear Algebra::
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 * Specialized Solvers::
 
+Vectorization and Faster Code Execution
+
+* Basic Vectorization::        Basic techniques for code optimization
+* Broadcasting::               Broadcasting operations
+* Function Application::       Applying functions to arrays, cells, and structs
+* Accumulation::               Accumulation functions
+* Miscellaneous Techniques::   Other techniques for speeding up code
+* Examples::
+
 Nonlinear Equations
 
 * Solvers::
-* Minimizers::
+* Minimizers::          
 
 Diagonal and Permutation Matrices
 
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
 * Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
 * Example Codes::        Some Examples of Usage
 * Zeros Treatment::      The Differences in Treatment of Zero Elements
@@ -687,17 +701,17 @@ Optimization
 * Nonlinear Programming::       
 * Linear Least Squares::        
 
 Statistics
 
 * Descriptive Statistics::
 * Basic Statistical Functions:: 
 * Statistical Plots:: 
-* Correlation and Regression Analysis::
+* Correlation and Regression Analysis::                      
 * Distributions::     
 * Tests::                       
 * Random Number Generation::          
 
 Sets
 
 * Set Operations::
 
@@ -754,17 +768,17 @@ Overloading Objects
 * Operator Overloading::
 * Precedence of Objects::
 
 GUI Development
 
 * I/O Dialogs::       
 * Progress Bar::       
 * GUI Utility Functions::       
-* User-Defined Preferences::
+* User-Defined Preferences::       
 
 System Utilities
 
 * Timing Utilities::            
 * Filesystem Utilities::        
 * File Archiving Utilities::
 * Networking Utilities::
 * Controlling Subprocesses::    
@@ -835,45 +849,55 @@ Mex-Files
 Test and Demo Functions
 
 * Test Functions::
 * Demonstration Functions::
 
 Tips and Standards
 
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 
 Contributing Guidelines
 
 * How to Contribute::
+* Building the Development Sources::
+* Basics of Generating a Changeset::
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 
 Trouble
 
 * Actual Bugs::                 Bugs we will fix later.
 * Reporting Bugs::              
 * Service::                     
 
 Reporting Bugs
 
 * Bug Criteria::                
-* Bug Tracker::                 Where to submit your bug report.
-* Bug Reporting::               How to report a bug effectively.
-* Sending Patches::             How to send a patch for Octave.
+* Bug Tracker::        Where to submit your bug report.
+* Bug Reporting::      How to report a bug effectively.
+* Sending Patches::    How to send a patch for Octave.
 
 Installation
 
-* Installation Problems::       
+* Build Dependencies::
+* Running Configure and Make::
+* Compiling Octave with 64-bit Indexing::
+* Installation Problems::
+
+Build Dependencies
+
+* Tips for Specific Systems::
+* Build Tools::
+* External Packages::
 
 Emacs Octave Support
 
 * Installing EOS::              
 * Using Octave Mode::           
 * Running Octave from Within Emacs::  
 * Using the Emacs Info Reader for Octave::  
 
@@ -901,16 +925,17 @@ Grammar and Parser
 @include func.texi
 @include errors.texi
 @include debug.texi
 @include io.texi
 @include plot.texi
 @include matrix.texi
 @include arith.texi
 @include linalg.texi
+@include vectorize.texi
 @include nonlin.texi
 @include diagperm.texi
 @include sparse.texi
 @include quad.texi
 @include diffeq.texi
 @include optim.texi
 @include stats.texi
 @include set.texi
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2008-2011 David Bateman
+@c Copyright (C) 2008-2012 David Bateman
 @c Copyright (C) 2009 VZLU Prague
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
@@ -49,28 +49,28 @@ functions.
 We use in the following text a polynomial class to demonstrate the use
 of object oriented programming within Octave.  This class was chosen as
 it is simple, and so doesn't distract unnecessarily from the
 discussion of the programming features of Octave.  However, even still
 a small understand of the polynomial class itself is necessary to
 fully grasp the techniques described.
 
 The polynomial class is used to represent polynomials of the form
+@tex
+$$
+a_0 + a_1 x + a_2 x^2 + \ldots a_n x^n
+$$
+@end tex
+@ifnottex
 
 @example
-@group
-@tex
-$a_0 + a_1 x + a_2 x^2 + \ldots a_n x^n$
-@end tex
-@ifnottex
 a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
-@end ifnottex
-@end group
 @end example
 
+@end ifnottex
 @noindent
 where
 @tex
 $a_0$, $a_1$, etc. are elements of $\Re$.
 @end tex
 @ifnottex
 a0, a1, etc. are real scalars.
 @end ifnottex
@@ -125,19 +125,19 @@ class.
 
 To check where a variable is a user class, the @code{isobject} and
 @code{isa} functions can be used.  For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 isobject (p)
-@result{} 1
+  @result{} 1
 isa (p, "polynomial")
-@result{} 1
+  @result{} 1
 @end group
 @end example
 
 @DOCSTRING(isobject)
 
 @noindent
 The available methods of a class can be displayed with the
 @code{methods} function.
@@ -152,17 +152,17 @@ To inquire whether a particular method i
 
 @noindent
 For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 ismethod (p, "roots")
-@result{} 1
+  @result{} 1
 @end group
 @end example
 
 @node Manipulating Classes
 @section Manipulating Classes
 
 There are a number of basic classes methods that can be defined to allow
 the contents of the classes to be queried and set.  The most basic of
@@ -314,17 +314,17 @@ look like
 which is a fairly generic @code{end} method that has a behavior similar to
 the @code{end} keyword for Octave Array classes.  It can then be used as 
 follows:
 
 @example
 @group
 p = polynomial([1,2,3,4]);
 p(end-1)
-@result{} 3
+  @result{} 3
 @end group
 @end example
 
 Objects can also be used as the index in a subscripted expression themselves
 and this is controlled with the @code{subsindex} function.
 
 @DOCSTRING(subsindex)
 
diff --git a/doc/interpreter/op-idx.txi b/doc/interpreter/op-idx.txi
--- a/doc/interpreter/op-idx.txi
+++ b/doc/interpreter/op-idx.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/optim.txi b/doc/interpreter/optim.txi
--- a/doc/interpreter/optim.txi
+++ b/doc/interpreter/optim.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2011 SÔøΩren Hauberg
+@c Copyright (C) 2007-2012 SÔøΩren Hauberg
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -201,17 +201,17 @@ package source files.
 This is an optional file describing the functions provided by the
 package.  If this file is not given then one with be created
 automatically from the functions in the package and the
 @code{Categories} keyword in the @file{DESCRIPTION} file.
 @xref{The INDEX File}, for details on this file.
 
 @item package/NEWS
 This is an optional file describing all user-visible changes worth
-mentioning. As this file increases on size, old entries can be moved
+mentioning.  As this file increases on size, old entries can be moved
 into @file{package/ONEWS}.
 
 @item package/ONEWS
 This is an optional file describing old entries from the @file{NEWS} file.
 
 @anchor{doc-PKG_ADD}
 @item package/PKG_ADD
 An optional file that includes commands that are run when the package
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c
@@ -3278,16 +3278,20 @@ Data source variables.
 @subsection Graphics Toolkits
 @cindex graphics toolkits
 @cindex toolkits, graphics
 
 @DOCSTRING(graphics_toolkit)
 
 @DOCSTRING(available_graphics_toolkits)
 
+@DOCSTRING(loaded_graphics_toolkits)
+
+@DOCSTRING(register_graphics_toolkit)
+
 @menu
 * Customizing Toolkit Behavior::    
 @end menu
 
 @node Customizing Toolkit Behavior
 @subsubsection Customizing Toolkit Behavior
 @cindex toolkit customization
 
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton and David Bateman
+## Copyright (C) 2007-2012 John W. Eaton and David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -102,31 +102,29 @@ for a definition), and then finding its 
 @DOCSTRING(polygcd)
 
 @DOCSTRING(residue)
 
 @node Derivatives / Integrals / Transforms
 @section Derivatives / Integrals / Transforms
 
 Octave comes with functions for computing the derivative and the integral
-of a polynomial.  The functions @code{polyderiv} and @code{polyint}
+of a polynomial.  The functions @code{polyder} and @code{polyint}
 both return new polynomials describing the result.  As an example we'll
 compute the definite integral of @math{p(x) = x^2 + 1} from 0 to 3.
 
 @example
 @group
 c = [1, 0, 1];
 integral = polyint(c);
 area = polyval(integral, 3) - polyval(integral, 0)
 @result{} 12
 @end group
 @end example
 
-@DOCSTRING(polyderiv)
-
 @DOCSTRING(polyder)
 
 @DOCSTRING(polyint)
 
 @DOCSTRING(polyaffine)
 
 @node Polynomial Interpolation
 @section Polynomial Interpolation
diff --git a/doc/interpreter/preface.txi b/doc/interpreter/preface.txi
--- a/doc/interpreter/preface.txi
+++ b/doc/interpreter/preface.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -27,39 +27,39 @@ undergraduate-level textbook on chemical
 James B. Rawlings of the University of Wisconsin-Madison and John
 G. Ekerdt of the University of Texas.
 
 Clearly, Octave is now much more than just another `courseware' package
 with limited utility beyond the classroom.  Although our initial goals
 were somewhat vague, we knew that we wanted to create something that
 would enable students to solve realistic problems, and that they could
 use for many things other than chemical reactor design problems.
-
-There are those who would say that we should be teaching the students
-Fortran instead, because that is the computer language of engineering,
-but every time we have tried that, the students have spent far too much
-time trying to figure out why their Fortran code crashes and not enough
-time learning about chemical engineering.  With Octave, most students
-pick up the basics quickly, and are using it confidently in just a few
-hours.
+We find that most students pick up the basics of Octave quickly, and are
+using it confidently in just a few hours.
 
 Although it was originally intended to be used to teach reactor design,
 it has been used in several other undergraduate and graduate
 courses in the Chemical Engineering Department at the University of
 Texas, and the math department at the University of Texas has been using
-it for teaching differential equations and linear algebra as well.  If
-you find it useful, please let us know.  We are always interested to
-find out how Octave is being used in other places.
+it for teaching differential equations and linear algebra as well.
+More recently, Octave has been used as the primary computational tool
+for teaching Stanford's online Machine Learning class
+(@url{ml-class.org}) taught by Andrew Ng.  Tens of thousands of students
+participated in the course.
+
+If you find Octave useful, please let us know.  We are always interested
+to find out how Octave is being used.
 
 Virtually everyone thinks that the name Octave has something to do with
-music, but it is actually the name of a former professor of mine who
-wrote a famous textbook on chemical reaction engineering, and who was
-also well known for his ability to do quick `back of the envelope'
-calculations.  We hope that this software will make it possible for many
-people to do more ambitious computations just as easily.
+music, but it is actually the name of one of John W. Eaton's former
+professors who wrote a famous textbook on chemical reaction engineering,
+and who was also well known for his ability to do quick `back of the
+envelope' calculations.  We hope that this software will make it
+possible for many people to do more ambitious computations just as
+easily.
 
 Everyone is encouraged to share this software with others under the
 terms of the GNU General Public License (@pxref{Copying}).  You are 
 also encouraged to help make Octave more useful by writing and 
 contributing additional functions for it, and by reporting any problems
 you may have.
 
 @menu
@@ -157,16 +157,34 @@ high-quality code for solving new proble
 available for others to use.  @xref{Contributing Guidelines}, for detailed 
 information on contributing new code.
 
 If you find Octave useful, consider providing additional funding to
 continue its development.  Even a modest amount of additional funding
 could make a significant difference in the amount of time that is
 available for development and support.
 
+Donations supporting Octave development may be made on the web at
+@url{https://my.fsf.org/donate/working-together/octave}.  These
+donations also help to support the Free Software Foundation
+
+If you'd prefer to pay by check or money order, you can do so by sending
+a check to the FSF at the following address:
+
+@quotation
+Free Software Foundation@*
+51 Franklin Street, Suite 500@*
+Boston, MA 02110-1335@*
+USA
+@end quotation
+
+@noindent
+If you pay by check, please be sure to write ``GNU Octave'' in the memo
+field of your check.
+
 If you cannot provide funding or contribute code, you can still help
 make Octave better and more reliable by reporting any bugs you find and
 by offering suggestions for ways to improve Octave.  @xref{Trouble}, for
 tips on how to write useful bug reports.
 
 @node Distribution
 @unnumberedsec Distribution
 @cindex distribution of Octave
@@ -175,23 +193,12 @@ Octave is @dfn{free} software.  This mea
 use it and free to redistribute it on certain conditions.  Octave 
 is not, however, in the public domain.  It is copyrighted and there are
 restrictions on its distribution, but the restrictions are designed to 
 ensure that others will have the same freedom to use and redistribute 
 Octave that you have.  The precise conditions can be found in the 
 GNU General Public License that comes with Octave and that also appears 
 in @ref{Copying}.
 
-Octave is available on CD-ROM, with various collections of other free
-software, from the Free Software Foundation.  Ordering a copy of
-Octave from the Free Software Foundation helps to fund the development
-of more free software.  For more information, write to
+To download a copy of Octave, please visit
+@url{http://www.octave.org/download.html}.
 
-@quotation
-Free Software Foundation@*
-51 Franklin Street, Fifth Floor@*
-Boston, MA 02110-1301--1307@*
-USA
-@end quotation
-
-Octave can also be downloaded from @url{http://www.octave.org}, where
-additional information is available.
 @end ifclear
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2004-2011 David Bateman
+@c Copyright (C) 2004-2012 David Bateman
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -218,18 +218,16 @@ s = diag (sparse(randn(1,n)), -1);
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
 @DOCSTRING(speye)
 
-@DOCSTRING(spfun)
-
 @DOCSTRING(spones)
 
 @DOCSTRING(sprand)
 
 @DOCSTRING(sprandn)
 
 @DOCSTRING(sprandsym)
 
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -113,18 +113,16 @@ initial steps to prepare a data set for 
 different measures from those of the basic descriptive statistics.
 
 @DOCSTRING(center)
 
 @DOCSTRING(zscore)
 
 @DOCSTRING(histc)
 
-@DOCSTRING(cut)
-
 @c FIXME: really want to put a reference to unique here
 @c @DOCSTRING(values)
 
 @DOCSTRING(nchoosek)
 
 @DOCSTRING(perms)
 
 @DOCSTRING(ranks)
@@ -300,19 +298,19 @@ alphabetical order).
   @tab @code{nbinpdf}
   @tab @code{nbincdf}
   @tab @code{nbininv}
 @item Poisson Distribution
   @tab @code{poisspdf}
   @tab @code{poisscdf}
   @tab @code{poissinv}
 @item Standard Normal Distribution
-  @tab @code{stdtormal_pdf}
-  @tab @code{stdtormal_cdf}
-  @tab @code{stdtormal_inv}
+  @tab @code{stdnormal_pdf}
+  @tab @code{stdnormal_cdf}
+  @tab @code{stdnormal_inv}
 @item t (Student) Distribution
   @tab @code{tpdf}
   @tab @code{tcdf}
   @tab @code{tinv}
 @item Univariate Discrete Distribution
   @tab @code{unidpdf}
   @tab @code{unidcdf}
   @tab @code{unidinv}
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -261,26 +261,44 @@ status information on files; and for man
 * URL Manipulation::
 @end menu
 
 @DOCSTRING(gethostname)
 
 @node FTP Objects
 @subsection FTP Objects
 
+Octave supports the FTP protocol through an object-oriented interface.
+Use the function @code{ftp} to create an FTP object which represents the
+connection.  All FTP functions take an FTP object as the first argument.
+
 @DOCSTRING(@ftp/ftp)
 
+@DOCSTRING(@ftp/close)
+
 @DOCSTRING(@ftp/mget)
 
 @DOCSTRING(@ftp/mput)
 
+@DOCSTRING(@ftp/cd)
+
+@DOCSTRING(@ftp/dir)
+
 @DOCSTRING(@ftp/ascii)
 
 @DOCSTRING(@ftp/binary)
 
+@DOCSTRING(@ftp/delete)
+
+@DOCSTRING(@ftp/rename)
+
+@DOCSTRING(@ftp/mkdir)
+
+@DOCSTRING(@ftp/rmdir)
+
 @node URL Manipulation
 @subsection URL Manipulation
 
 @DOCSTRING(urlread)
 
 @DOCSTRING(urlwrite)
 
 @node Controlling Subprocesses
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2005-2011 David Bateman
+@c Copyright (C) 2005-2012 David Bateman
 @c Copyright (C) 2002-2005 Paul Kienzle
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
@@ -29,233 +29,261 @@ and demonstration code in the source cod
 * Demonstration Functions::
 @end menu
 
 @node Test Functions
 @section Test Functions
 
 @DOCSTRING(test)
 
-@code{test} scans the named script file looking for lines which
-start with @code{%!}.  The prefix is stripped off and the rest of the
-line is processed through the Octave interpreter.  If the code
+@code{test} scans the named script file looking for lines which start
+with the identifier @samp{%!}.  The prefix is stripped off and the rest
+of the line is processed through the Octave interpreter.  If the code
 generates an error, then the test is said to fail.
 
 Since @code{eval()} will stop at the first error it encounters, you must
 divide your tests up into blocks, with anything in a separate
 block evaluated separately.  Blocks are introduced by the keyword
-@code{test} immediately following the @code{%!}.  For example:
+@code{test} immediately following @samp{%!}.  For example:
 
 @example
 @group
-   %!test error ("this test fails!");
-   %!test "test doesn't fail. it doesn't generate an error";
+%!test error ("this test fails!");
+%!test "test doesn't fail. it doesn't generate an error";
 @end group
 @end example
 
 When a test fails, you will see something like:
 
 @example
 @group
-     ***** test error ('this test fails!')
-   !!!!! test failed
-   this test fails!
+  ***** test error ("this test fails!")
+!!!!! test failed
+this test fails!
 @end group
 @end example
 
 Generally, to test if something works, you want to assert that it
 produces a correct value.  A real test might look something like
 
 @example
 @group
-   %!test
-   %! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
-   %! expect = [ @var{a} ; 2*@var{a} ];
-   %! get = kron (@var{b}, @var{a});
-   %! if (any(size(expect) != size(get)))
-   %!    error ("wrong size: expected %d,%d but got %d,%d",
-   %!           size(expect), size(get));
-   %! elseif (any(any(expect!=get)))
-   %!    error ("didn't get what was expected.");
-   %! endif
+%!test
+%! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
+%! expect = [ @var{a} ; 2*@var{a} ];
+%! get = kron (@var{b}, @var{a});
+%! if (any (size (expect) != size (get)))
+%!   error ("wrong size: expected %d,%d but got %d,%d",
+%!          size(expect), size(get));
+%! elseif (any (any (expect != get)))
+%!   error ("didn't get what was expected.");
+%! endif
 @end group
 @end example
 
 To make the process easier, use the @code{assert} function.  For example,
 with @code{assert} the previous test is reduced to:
 
 @example
 @group
-   %!test
-   %! @var{a} = [1, 2, 3; 4, 5, 6]; @var{b} = [1; 2];
-   %! assert (kron (@var{b}, @var{a}), [ @var{a}; 2*@var{a} ]);
+%!test
+%! @var{a} = [1, 2, 3; 4, 5, 6]; @var{b} = [1; 2];
+%! assert (kron (@var{b}, @var{a}), [ @var{a}; 2*@var{a} ]);
 @end group
 @end example
 
 @code{assert} can accept a tolerance so that you can compare results
 absolutely or relatively.  For example, the following all succeed:
 
 @example
 @group
-   %!test assert (1+eps, 1, 2*eps)          # absolute error
-   %!test assert (100+100*eps, 100, -2*eps) # relative error
+%!test assert (1+eps, 1, 2*eps)          # absolute error
+%!test assert (100+100*eps, 100, -2*eps) # relative error
 @end group
 @end example
 
 You can also do the comparison yourself, but still have assert
 generate the error:
 
 @example
 @group
-   %!test assert (isempty([]))
-   %!test assert ([ 1,2; 3,4 ] > 0)
+%!test assert (isempty ([]))
+%!test assert ([1, 2; 3, 4] > 0)
 @end group
 @end example
 
 Because @code{assert} is so frequently used alone in a test block, there
 is a shorthand form:
 
 @example
-   %!assert (@dots{})
+%!assert (@dots{})
 @end example
 
 @noindent
 which is equivalent to:
 
 @example
-   %!test assert (@dots{})
+%!test assert (@dots{})
 @end example
 
+Occasionally a block of tests will depend on having optional
+functionality in Octave.  Before testing such blocks the availability of
+the required functionality must be checked.  A @code{%!testif HAVE_XXX}
+block will only be run if Octave was compiled with functionality
+@samp{HAVE_XXX}.  For example, the sparse single value decomposition,
+@code{svds()}, depends on having the @sc{arpack} library.  All of the tests
+for @code{svds} begin with
+
+@example
+%!testif HAVE_ARPACK
+@end example
+
+@noindent
+Review @file{config.h} or @code{octave_config_info ("DEFS")} to see some
+of the possible values to check.
+
 Sometimes during development there is a test that should work but is
 known to fail.  You still want to leave the test in because when the
 final code is ready the test should pass, but you may not be able to
 fix it immediately.  To avoid unnecessary bug reports for these known
 failures, mark the block with @code{xtest} rather than @code{test}:
 
 @example
 @group
-   %!xtest assert (1==0)
-   %!xtest fail ('success=1','error'))
+%!xtest assert (1==0)
+%!xtest fail ("success=1", "error")
 @end group
 @end example
 
-Another use of @code{xtest} is for statistical tests which should
-pass most of the time but are known to fail occasionally.
+@noindent
+In this case, the test will run and any failure will be reported.
+However, testing is not aborted and subsequent test blocks will be
+processed normally.  Another use of @code{xtest} is for statistical
+tests which should pass most of the time but are known to fail
+occasionally.
 
 Each block is evaluated in its own function environment, which means
 that variables defined in one block are not automatically shared
 with other blocks.  If you do want to share variables, then you
 must declare them as @code{shared} before you use them.  For example, the
 following declares the variable @var{a}, gives it an initial value (default
-is empty), then uses it in several subsequent tests.
+is empty), and then uses it in several subsequent tests.
 
 @example
 @group
-   %!shared @var{a}
-   %! @var{a} = [1, 2, 3; 4, 5, 6];
-   %!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ]);
-   %!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ]);
-   %!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ]);
+%!shared @var{a}
+%! @var{a} = [1, 2, 3; 4, 5, 6];
+%!assert (kron ([1; 2], @var{a}), [ @var{a}; 2*@var{a} ]);
+%!assert (kron ([1, 2], @var{a}), [ @var{a}, 2*@var{a} ]);
+%!assert (kron ([1,2; 3,4], @var{a}), [ @var{a},2*@var{a}; 3*@var{a},4*@var{a} ]);
 @end group
 @end example
 
 You can share several variables at the same time:
 
 @example
-   %!shared @var{a}, @var{b}
+%!shared @var{a}, @var{b}
 @end example
 
 You can also share test functions:
 
 @example
 @group
-   %!function @var{a} = fn (@var{b})
-   %!  @var{a} = 2*@var{b};
-   %!endfunction
-   %!assert (@var{fn}(2), 4);
+%!function @var{a} = fn (@var{b})
+%!  @var{a} = 2*@var{b};
+%!endfunction
+%!assert (fn(2), 4);
 @end group
 @end example
 
 Note that all previous variables and values are lost when a new 
 shared block is declared.
 
 Error and warning blocks are like test blocks, but they only succeed 
 if the code generates an error.  You can check the text of the error
 is correct using an optional regular expression @code{<pattern>}.  
 For example:
 
 @example
-   %!error <passes!> error('this test passes!');
+%!error <passes!> error ("this test passes!");
 @end example
 
 If the code doesn't generate an error, the test fails.  For example:
 
 @example
-   %!error "this is an error because it succeeds.";
+%!error "this is an error because it succeeds.";
 @end example
 
 @noindent
 produces
 
 @example
 @group
-   ***** error "this is an error because it succeeds.";
-   !!!!! test failed: no error
+  ***** error "this is an error because it succeeds.";
+!!!!! test failed: no error
 @end group
 @end example
 
 It is important to automate the tests as much as possible, however
 some tests require user interaction.  These can be isolated into
 demo blocks, which if you are in batch mode, are only run when 
-called with @code{demo} or @code{verbose}.  The code is displayed before
-it is executed.  For example,
+called with @code{demo} or the @code{verbose} option to @code{test}.
+The code is displayed before it is executed.  For example,
 
 @example
 @group
-   %!demo
-   %! @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   %! plot(@var{t},@var{x});
-   %! you should now see a sine wave in your figure window
+%!demo
+%! @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+%! plot (@var{t}, @var{x});
+%! # you should now see a sine wave in your figure window
 @end group
 @end example
 
 @noindent
 produces
 
 @example
 @group
-   > @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   > plot(@var{t},@var{x});
-   > you should now see a sine wave in your figure window
-   Press <enter> to continue: 
+funcname example 1:
+ @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+ plot (@var{t}, @var{x});
+ # you should now see a sine wave in your figure window
+
+Press <enter> to continue: 
 @end group
 @end example
 
 Note that demo blocks cannot use any shared variables.  This is so
 that they can be executed by themselves, ignoring all other tests.
 
 If you want to temporarily disable a test block, put @code{#} in place
 of the block type.  This creates a comment block which is echoed
-in the log file, but is not executed.  For example:
+in the log file but not executed.  For example:
 
 @example
 @group
-   %!#demo
-   %! @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
-   %! plot(@var{t},@var{x});
-   %! you should now see a sine wave in your figure window
+%!#demo
+%! @var{t} = [0:0.01:2*pi]; @var{x} = sin (@var{t});
+%! plot (@var{t}, @var{x});
+%! # you should now see a sine wave in your figure window
 @end group
 @end example
 
-Block type summary:
+@subsubheading Block type summary:
 
 @table @code
 @item %!test
 check that entire block is correct
 
+@item %!testif HAVE_XXX
+check block only if Octave was compiled with feature HAVE_XXX.
+
+@item %!xtest
+check block, report a test failure but do not abort testing.
+
 @item %!error
 check for correct error message
 
 @item %!warning
 check for correct warning message
 
 @item %!demo
 demo only executes in interactive mode
@@ -272,57 +300,53 @@ define a function for use in multiple te
 @item %!endfunction
 close a function definition
 
 @item %!assert (x, y, tol)
 shorthand for @code{%!test assert (x, y, tol)}
 @end table
 
 You can also create test scripts for builtins and your own C++
-functions.  Just put a file of the function name on your path without
-any extension and it will be picked up by the test procedure.  You
-can even embed tests directly in your C++ code:
+functions.  To do so put a file with the bare function name (no .m
+extension) in a directory in the load path and it will be discovered by
+the @code{test} function.  Alternatively, you can embed tests directly in your
+C++ code:
 
 @example
 @group
-   #if 0
-   %!test disp('this is a test')
-   #endif
+/*
+%!test disp ("this is a test")
+*/
 @end group
 @end example
 
 @noindent
 or
 
 @example
 @group
-   /*
-   %!test disp('this is a test')
-   */
+#if 0
+%!test disp ("this is a test")
+#endif
 @end group
 @end example
 
 @noindent
-but then the code will have to be on the load path and the user 
-will have to remember to type test('name.cc').  Conversely, you
-can separate the tests from normal Octave script files by putting
-them in plain files with no extension rather than in script files.
-@c DO I WANT TO INCLUDE THE EDITOR SPECIFIC STATEMENT BELOW???
-@c Don't forget to tell emacs that the plain text file you are using
-@c is actually octave code, using something like:
-@c   -*-octave-*-
+However, in this case the raw source code will need to be on the load
+path and the user will have to remember to type
+@code{test ("funcname.cc")}.
 
 @DOCSTRING(assert)
 
 @DOCSTRING(fail)
 
 @node Demonstration Functions
 @section Demonstration Functions
 
 @DOCSTRING(demo)
 
+@DOCSTRING(example)
+
 @DOCSTRING(rundemos)
 
 @DOCSTRING(runtests)
 
-@DOCSTRING(example)
-
 @DOCSTRING(speed)
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -23,17 +23,16 @@
 @cindex coding standards
 
 This chapter describes no additional features of Octave.  Instead it
 gives advice on making effective use of the features described in the
 previous chapters.
 
 @menu
 * Style Tips::                  Writing clean and robust programs.
-* Coding Tips::                 Making code run faster.
 * Comment Tips::                Conventions for writing comments.
 * Function Headers::            Standard headers for functions.
 * Documentation Tips::          Writing readable documentation strings.
 @end menu
 
 @node Style Tips
 @section Writing Clean Octave Programs
 
@@ -70,213 +69,16 @@ return.
 
 @item
 Please put a copyright notice on the file if you give copies to anyone.
 Use the same lines that appear at the top of the function files
 distributed with Octave.  If you have not signed papers to assign the
 copyright to anyone else, then place your name in the copyright notice.
 @end itemize
 
-@node Coding Tips
-@section Tips for Making Code Run Faster.
-@cindex execution speed
-@cindex speedups
-
-Here are some ways of improving the execution speed of Octave programs.
-
-@itemize @bullet
-@item
-Vectorize loops.  For instance, rather than
-
-@example
-@group
-for i = 1:n-1
-  a(i) = b(i+1) - b(i);
-endfor
-@end group
-@end example
-
-@noindent
-write
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-This is especially important for loops with "cheap" bodies.  Often it suffices
-to vectorize just the innermost loop to get acceptable performance.  A general
-rule of thumb is that the "order" of the vectorized body should be greater or
-equal to the "order" of the enclosing loop.
-
-@item
-Use built-in and library functions if possible.  Built-in and compiled functions
-are very fast.  Even with a m-file library function, chances are good that it is
-already optimized, or will be optimized more in a future release.
-
-For instance, even better than
-
-@example
-a = b(2:n) - b(1:n-1);
-@end example
-
-@noindent
-is
-
-@example
-a = diff (b);
-@end example
-
-
-@item
-Avoid computing costly intermediate results multiple times.  Octave currently
-does not eliminate common subexpressions.
-Also, certain internal computation results are cached for variables.
-For instance, if a matrix variable is used multiple times as an index,
-checking the indices (and internal conversion to integers) is only done once.
-
-@item
-Be aware of lazy copies (copy-on-write).  When a copy of an object
-is created, the data is not immediately copied, but rather shared.  The actual
-copying is postponed until the copied data needs to be modified.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a; # no copying done here
-b(1) = 1; # copying done here
-@end group
-@end example
-
-Lazy copying applies to whole Octave objects such as matrices, cells, struct,
-and also individual cell or struct elements (not array elements).
-
-Additionally, index expressions also use lazy copying when Octave can determine
-that the indexed portion is contiguous in memory.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100); # no copying done here
-b = a(10:100,:); # copying done here
-@end group
-@end example
-
-This applies to arrays (matrices), cell arrays, and structs indexed using ().
-Index expressions generating cs-lists can also benefit of shallow copying
-in some cases.  In particular, when @var{a} is a struct array, expressions like
-@code{@{a.x@}, @{a(:,2).x@}} will use lazy copying, so that data can be shared
-between a struct array and a cell array.
-
-Most indexing expressions do not live longer than their `parent' objects.
-In rare cases, however, a lazily copied slice outlasts its parent, in which
-case it becomes orphaned, still occupying unnecessarily more memory than needed.
-To provide a remedy working in most real cases,
-Octave checks for orphaned lazy slices at certain situations, when a value
-is stored into a "permanent" location, such as a named variable or cell or
-struct element, and possibly economizes them.  For example:
-
-@example
-@group
-a = zeros (1000); # create a 1000x1000 matrix
-b = a(:,10:100);  # lazy slice
-a = []; # the original a array is still allocated
-c@{1@} = b; # b is reallocated at this point
-@end group
-@end example
-
-@item
-Avoid deep recursion.  Function calls to m-file functions carry a relatively
-significant overhead, so rewriting a recursion as a loop often helps.  Also,
-note that the maximum level of recursion is limited.
-
-@item
-Avoid resizing matrices unnecessarily.  When building a single result
-matrix from a series of calculations, set the size of the result matrix
-first, then insert values into it.  Write
-
-@example
-@group
-result = zeros (big_n, big_m)
-for i = over:and_over
-  r1 = @dots{}
-  r2 = @dots{}
-  result (r1, r2) = new_value ();
-endfor
-@end group
-@end example
-
-@noindent
-instead of
-
-@example
-@group
-result = [];
-for i = ever:and_ever
-  result = [ result, new_value() ];
-endfor
-@end group
-@end example
-
-Sometimes the number of items can't be computed in advance, and stack-like
-operations are needed.  When elements are being repeatedly inserted at/removed
-from the end of an array, Octave detects it as stack usage and attempts to use a
-smarter memory management strategy pre-allocating the array in bigger chunks. 
-Likewise works for cell and struct arrays.
-
-@example
-@group
-a = [];
-while (condition)
-  @dots{}
-  a(end+1) = value; # "push" operation
-  @dots{}
-  a(end) = []; # "pop" operation
-  @dots{}
-endwhile
-@end group
-@end example
-
-@item
-Use @code{cellfun} intelligently.  The @code{cellfun} function is a useful tool
-for avoiding loops.  @xref{Processing Data in Cell Arrays}.
-@code{cellfun} is often used with anonymous function handles; however, calling
-an anonymous function involves an overhead quite comparable to the overhead
-of an m-file function.  Passing a handle to a built-in function is faster,
-because the interpreter is not involved in the internal loop.  For example:
-
-@example
-@group
-a = @{@dots{}@}
-v = cellfun (@@(x) det(x), a); # compute determinants
-v = cellfun (@@det, a); # faster
-@end group
-@end example
-
-@item
-Octave includes a number of other functions that can replace common types of
-loops, including @code{bsxfun}, @code{arrayfun}, @code{structfun},
-@code{accumarray}.  These functions can take an arbitrary function as a handle.
-Be sure to get familiar with them if you want to become an Octave expert.
-
-@item
-Avoid calling @code{eval} or @code{feval} excessively, because
-they require Octave to parse input or look up the name of a function in
-the symbol table.
-
-If you are using @code{eval} as an exception handling mechanism and not
-because you need to execute some arbitrary text, use the @code{try}
-statement instead.  @xref{The @code{try} Statement}.
-
-@item
-If you are calling lots of functions but none of them will need to
-change during your run, set the variable
-@code{ignore_function_time_stamp} to @code{"all"} so that Octave doesn't
-waste a lot of time checking to see if you have updated your function
-files.
-@end itemize
 
 @node Comment Tips
 @section Tips on Writing Comments
 
 Here are the conventions to follow when writing comments.
 
 @table @samp
 @item #
@@ -684,107 +486,184 @@ Help text in Texinfo format.
 
 Many complete examples of Texinfo documentation can be taken from the
 help strings for the Octave functions themselves.  A relatively complete
 example of which is the @code{nchoosek} function.  The Texinfo
 documentation string for @code{nchoosek} is
 
 @example
 -*- texinfo -*-
-@@deftypefn @{Function File@} @{@} nchoosek (@@var@{n@}, @@var@{k@})
+@@deftypefn  @{Function File@} @{@@var@{c@} =@} nchoosek (@@var@{n@}, @@var@{k@})
+@@deftypefnx @{Function File@} @{@@var@{c@} =@} nchoosek (@@var@{set@}, @@var@{k@})
 
-Compute the binomial coefficient or all combinations of 
-@@var@{n@}.  If @@var@{n@} is a scalar then, calculate the
-binomial coefficient of @@var@{n@} and @@var@{k@}, defined as
+Compute the binomial coefficient or all combinations of a set of items.
 
+If @@var@{n@} is a scalar then calculate the binomial coefficient
+of @@var@{n@} and @@var@{k@} which is defined as
 @@tex
 $$
  @{n \choose k@} = @{n (n-1) (n-2) \cdots (n-k+1) \over k!@}
+               = @{n! \over k! (n-k)!@}
 $$
 @@end tex
 @@ifnottex
 
 @@example
 @@group
  /   \
- | n |    n (n-1) (n-2) @dots{} (n-k+1)
- |   |  = -------------------------
- | k |               k!
+ | n |    n (n-1) (n-2) @@dots@{@} (n-k+1)       n!
+ |   |  = ------------------------- =  ---------
+ | k |               k!                k! (n-k)!
  \   /
 @@end group
 @@end example
+
 @@end ifnottex
+@@noindent
+This is the number of combinations of @@var@{n@} items taken in groups of
+size @@var@{k@}.
+
+If the first argument is a vector, @@var@{set@}, then generate all
+combinations of the elements of @@var@{set@}, taken @@var@{k@} at a time, with
+one row per combination.  The result @@var@{c@} has @@var@{k@} columns and
+@@w@{@@code@{nchoosek (length (@@var@{set@}), @@var@{k@})@}@} rows.
+
+For example:
+
+How many ways can three items be grouped into pairs?
 
-If @@var@{n@} is a vector, this generates all combinations
-of the elements of @@var@{n@}, taken @@var@{k@} at a time,
-one row per combination.  The resulting @@var@{c@} has size
-@@code@{[nchoosek (length (@@var@{n@}),@@var@{k@}), @@var@{k@}]@}.
+@@example
+@@group
+nchoosek (3, 2)
+   @@result@{@} 3
+@@end group
+@@end example
+
+What are the possible pairs?
 
-@@code@{nchoosek@} works only for non-negative integer arguments; use
-@@code@{bincoeff@} for non-integer scalar arguments and for using vector
-arguments to compute many coefficients at once.
+@@example
+@@group
+nchoosek (1:3, 2)
+   @@result@{@}  1   2
+       1   3
+       2   3
+@@end group
+@@end example
 
-@@seealso@{bincoeff@}
+@@code@{nchoosek@} works only for non-negative, integer arguments.  Use
+@@code@{bincoeff@} for non-integer and negative scalar arguments, or for
+computing many binomial coefficients at once with vector inputs
+for @@var@{n@} or @@var@{k@}.
+
+@@seealso@{bincoeff, perms@}
 @@end deftypefn
 @end example
-
+@noindent
 which demonstrates most of the concepts discussed above.
 @iftex
 This documentation string renders as
 
-@c Note actually use the output of info below rather than try and 
-@c reproduce it here to prevent it looking different than how it would
+@c Note: use the actual output of info below, rather than try and 
+@c reproduce it here to prevent it looking different from how it would
 @c appear with info.
 @example
-@group
  -- Function File: C = nchoosek (N, K)
-     Compute the binomial coefficient or all combinations
-     of N.  If N is a scalar then, calculate the binomial
-     coefficient of N and K, defined as
+ -- Function File: C = nchoosek (SET, K)
+     Compute the binomial coefficient or all combinations of a set of
+     items.
+
+     If N is a scalar then calculate the binomial coefficient of N and
+     K which is defined as
 
            /   \
-           | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
+           | n |    n (n-1) (n-2) ... (n-k+1)       n!
            |   |  = ------------------------- =  ---------
            | k |               k!                k! (n-k)!
            \   /
 
-     If N is a vector generate all combinations of the
-     elements of N, taken K at a time, one row per
-     combination.  The resulting C has size `[nchoosek
-     (length (N), K), K]'.
+     This is the number of combinations of N items taken in groups of
+     size K.
+
+     If the first argument is a vector, SET, then generate all
+     combinations of the elements of SET, taken K at a time, with one
+     row per combination.  The result C has K columns and
+     `nchoosek (length (SET), K)' rows.
 
-     `nchoosek' works only for non-negative integer
-     arguments; use `bincoeff' for non-integer scalar 
-     arguments and for using vector arguments to compute
-     many coefficients at once.
+     For example:
+
+     How many ways can three items be grouped into pairs?
+
+          nchoosek (3, 2)
+             => 3
+
+     What are the possible pairs?
 
-     See also: bincoeff.
-@end group
-@end example
+          nchoosek (1:3, 2)
+             =>  1   2
+                 1   3
+                 2   3
+
+     `nchoosek' works only for non-negative, integer arguments.  Use
+     `bincoeff' for non-integer and negative scalar arguments, or for
+     computing many binomial coefficients at once with vector inputs
+     for N or K.
 
-using info, whereas in a printed documentation using @TeX{} it will appear
-as
+     See also: bincoeff, perms
+@end example
+@noindent
+using info, whereas in a printed documentation using @TeX{} it will
+appear as
 
-@deftypefn {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+@deftypefn  {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+@deftypefnx {Function File} {@var{c} =} nchoosek (@var{set}, @var{k})
 
-Compute the binomial coefficient or all combinations of @var{n}.
-If @var{n} is a scalar then, calculate the binomial coefficient
-of @var{n} and @var{k}, defined as
+Compute the binomial coefficient or all combinations of a set of items.
+
+If @var{n} is a scalar then calculate the binomial coefficient
+of @var{n} and @var{k} which is defined as
 
 @tex
 $$
  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
+               = {n! \over k! (n-k)!}
 $$
 @end tex
 
-If @var{n} is a vector generate all combinations of the elements
-of @var{n}, taken @var{k} at a time, one row per combination.  The 
-resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
-@var{k}), @var{k}]}.
+@noindent
+This is the number of combinations of @var{n} items taken in groups of
+size @var{k}.
+
+If the first argument is a vector, @var{set}, then generate all
+combinations of the elements of @var{set}, taken @var{k} at a time, with
+one row per combination.  The result @var{c} has @var{k} columns and
+@w{@code{nchoosek (length (@var{set}), @var{k})}} rows.
+
+For example:
+
+How many ways can three items be grouped into pairs?
 
-@code{nchoosek} works only for non-negative integer arguments; use
-@code{bincoeff} for non-integer scalar arguments and for using vector
-arguments to compute many coefficients at once.
+@example
+@group
+nchoosek (3, 2)
+   @result{} 3
+@end group
+@end example
+
+What are the possible pairs?
 
-@seealso{bincoeff}
+@example
+@group
+nchoosek (1:3, 2)
+   @result{}  1   2
+       1   3
+       2   3
+@end group
+@end example
+
+@code{nchoosek} works only for non-negative, integer arguments.  Use
+@code{bincoeff} for non-integer and negative scalar arguments, or for
+computing many binomial coefficients at once with vector inputs for @var{n}
+or @var{k}.
+
+@seealso{bincoeff, perms}
 @end deftypefn
 
 @end iftex
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/vectorize.txi
@@ -0,0 +1,678 @@
+@c Copyright (C) 2012 Jordi Guti√©rrez Hermoso
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+@c for more details.
+@c
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING. If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@node Vectorization and Faster Code Execution
+@chapter Vectorization and Faster Code Execution
+@cindex vectorization
+@cindex vectorize
+
+Vectorization is a programming technique that uses vector operations
+instead of element-by-element loop-based operations.  Besides frequently
+producing more succinct Octave code, vectorization also allows for better
+optimization in the subsequent implementation.  The optimizations may occur
+either in Octave's own Fortran, C, or C++ internal implementation, or even at a
+lower level depending on the compiler and external numerical libraries used to
+build Octave.  The ultimate goal is to make use of your hardware's vector
+instructions if possible or to perform other optimizations in software.
+
+Vectorization is not a concept unique to Octave, but it is particularly
+important because Octave is a matrix-oriented language.  Vectorized
+Octave code will see a dramatic speed up (10X--100X) in most cases.
+
+This chapter discusses vectorization and other techniques for writing faster
+code.
+
+@menu
+* Basic Vectorization::        Basic techniques for code optimization
+* Broadcasting::               Broadcasting operations
+* Function Application::       Applying functions to arrays, cells, and structs
+* Accumulation::               Accumulation functions
+* Miscellaneous Techniques::   Other techniques for speeding up code
+* Examples::
+@end menu
+
+@node Basic Vectorization
+@section Basic Vectorization
+
+To a very good first approximation, the goal in vectorization is to
+write code that avoids loops and uses whole-array operations.  As a
+trivial example, consider
+
+@example
+@group
+for i = 1:n
+  for j = 1:m
+    c(i,j) = a(i,j) + b(i,j);
+  endfor
+endfor
+@end group
+@end example
+
+@noindent
+compared to the much simpler
+
+@example
+c = a + b;
+@end example
+
+@noindent
+This isn't merely easier to write; it is also internally much easier to
+optimize.  Octave delegates this operation to an underlying
+implementation which, among other optimizations, may use special vector
+hardware instructions or could conceivably even perform the additions in
+parallel.  In general, if the code is vectorized, the underlying
+implementation has more freedom about the assumptions it can make
+in order to achieve faster execution.
+
+This is especially important for loops with "cheap" bodies.  Often it
+suffices to vectorize just the innermost loop to get acceptable
+performance.  A general rule of thumb is that the "order" of the
+vectorized body should be greater or equal to the "order" of the
+enclosing loop.
+
+As a less trivial example, instead of
+
+@example
+@group
+for i = 1:n-1
+  a(i) = b(i+1) - b(i);
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+This shows an important general concept about using arrays for indexing
+instead of looping over an index variable.  @xref{Index Expressions}.
+Also use boolean indexing generously.  If a condition needs to be tested,
+this condition can also be written as a boolean index.  For instance,
+instead of
+
+@example
+@group
+for i = 1:n
+  if a(i) > 5
+    a(i) -= 20
+  endif
+endfor
+@end group
+@end example
+
+@noindent
+write
+
+@example
+a(a>5) -= 20;
+@end example
+
+@noindent
+which exploits the fact that @code{a > 5} produces a boolean index.
+
+Use elementwise vector operators whenever possible to avoid looping
+(operators like @code{.*} and @code{.^}).  @xref{Arithmetic Ops}.  For
+simple inline functions, the @code{vectorize} function can do this
+automatically.
+
+@DOCSTRING(vectorize)
+
+Also exploit broadcasting in these elementwise operators both to avoid
+looping and unnecessary intermediate memory allocations.
+@xref{Broadcasting}.
+
+Use built-in and library functions if possible.  Built-in and compiled
+functions are very fast.  Even with an m-file library function, chances
+are good that it is already optimized, or will be optimized more in a
+future release.
+
+For instance, even better than
+
+@example
+a = b(2:n) - b(1:n-1);
+@end example
+
+@noindent
+is
+
+@example
+a = diff (b);
+@end example
+
+Most Octave functions are written with vector and array arguments in
+mind.  If you find yourself writing a loop with a very simple operation,
+chances are that such a function already exists.  The following functions
+occur frequently in vectorized code:
+
+@itemize @bullet
+@item
+Index manipulation
+
+@itemize
+@item
+find
+
+@item
+sub2ind
+
+@item
+ind2sub
+
+@item
+sort
+
+@item
+unique
+
+@item
+lookup
+
+@item
+ifelse / merge
+@end itemize
+
+@item
+Repetition
+@itemize
+@item
+repmat
+
+@item
+repelems
+@end itemize
+
+@item
+Vectorized arithmetic
+@itemize
+@item
+sum
+
+@item
+prod
+
+@item
+cumsum
+
+@item
+cumprod
+
+@item
+sumsq
+
+@item
+diff
+
+@item
+dot
+
+@item
+cummax
+
+@item
+cummin
+@end itemize
+
+@item
+Shape of higher dimensional arrays
+@itemize
+@item
+reshape
+
+@item
+resize
+
+@item
+permute
+
+@item
+squeeze
+
+@item
+deal
+@end itemize
+
+@end itemize
+
+@node Broadcasting
+@section Broadcasting
+@cindex broadcast
+@cindex broadcasting
+@cindex BSX
+@cindex recycling
+@cindex SIMD
+
+Broadcasting refers to how Octave binary operators and functions behave
+when their matrix or array operands or arguments differ in size.  Since
+version 3.6.0, Octave now automatically broadcasts vectors, matrices,
+and arrays when using elementwise binary operators and functions.
+Broadly speaking, smaller arrays are ``broadcast'' across the larger
+one, until they have a compatible shape.  The rule is that corresponding
+array dimensions must either
+
+@enumerate
+@item
+be equal, or
+
+@item
+one of them must be 1.
+@end enumerate
+
+@noindent
+In case all dimensions are equal, no broadcasting occurs and ordinary
+element-by-element arithmetic takes place.  For arrays of higher
+dimensions, if the number of dimensions isn't the same, then missing
+trailing dimensions are treated as 1.  When one of the dimensions is 1,
+the array with that singleton dimension gets copied along that dimension
+until it matches the dimension of the other array.  For example, consider
+
+@example
+@group
+x = [1 2 3;
+     4 5 6;
+     7 8 9];
+
+y = [10 20 30];
+
+x + y
+@end group
+@end example
+
+@noindent
+Without broadcasting, @code{x + y} would be an error because the dimensions
+do not agree.  However, with broadcasting it is as if the following
+operation were performed:
+
+@example
+@group
+x = [1 2 3
+     4 5 6
+     7 8 9];
+
+y = [10 20 30
+     10 20 30
+     10 20 30];
+
+x + y
+@result{}    11   22   33
+      14   25   36
+      17   28   39
+@end group
+@end example
+
+@noindent
+That is, the smaller array of size @code{[1 3]} gets copied along the
+singleton dimension (the number of rows) until it is @code{[3 3]}.  No
+actual copying takes place, however.  The internal implementation reuses
+elements along the necessary dimension in order to achieve the desired
+effect without copying in memory.
+
+Both arrays can be broadcast across each other, for example, all
+pairwise differences of the elements of a vector with itself:
+
+@example
+@group
+y - y'
+@result{}    0   10   20
+    -10    0   10
+    -20  -10    0
+@end group
+@end example
+
+@noindent
+Here the vectors of size @code{[1 3]} and @code{[3 1]} both get
+broadcast into matrices of size @code{[3 3]} before ordinary matrix
+subtraction takes place.
+
+A special case of broadcasting that may be familiar is when all
+dimensions of the array being broadcast are 1, i.e. the array is a
+scalar. Thus for example, operations like @code{x - 42} and @code{max
+(x, 2)} are basic examples of broadcasting.
+
+For a higher-dimensional example, suppose @code{img} is an RGB image of
+size @code{[m n 3]} and we wish to multiply each color by a different
+scalar.  The following code accomplishes this with broadcasting,
+
+@example
+img .*= permute ([0.8, 0.9, 1.2], [1, 3, 2]);
+@end example
+
+@noindent
+Note the usage of permute to match the dimensions of the
+@code{[0.8, 0.9, 1.2]} vector with @code{img}.
+
+For functions that are not written with broadcasting semantics,
+@code{bsxfun} can be useful for coercing them to broadcast.
+
+@DOCSTRING(bsxfun)
+
+Broadcasting is only applied if either of the two broadcasting
+conditions hold.  As usual, however, broadcasting does not apply when two
+dimensions differ and neither is 1:
+
+@example
+@group
+x = [1 2 3
+     4 5 6];
+y = [10 20
+     30 40];
+x + y
+@end group
+@end example
+
+@noindent
+This will produce an error about nonconformant arguments.
+
+Besides common arithmetic operations, several functions of two arguments
+also broadcast.  The full list of functions and operators that broadcast
+is
+
+@example
+      plus      +  .+
+      minus     -  .-
+      times     .*
+      rdivide   ./
+      ldivide   .\
+      power     .^  .**
+      lt        <
+      le        <=
+      eq        ==
+      gt        >
+      ge        >=
+      ne        !=  ~=
+      and       &
+      or        |
+      atan2
+      hypot
+      max
+      min
+      mod
+      rem
+      xor
+
+      +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
+@end example
+
+Beware of resorting to broadcasting if a simpler operation will suffice.
+For matrices @var{a} and @var{b}, consider the following:
+
+@example
+@var{c} = sum (permute (@var{a}, [1, 3, 2]) .* permute (@var{b}, [3, 2, 1]), 3);
+@end example
+
+@noindent
+This operation broadcasts the two matrices with permuted dimensions
+across each other during elementwise multiplication in order to obtain a
+larger 3-D array, and this array is then summed along the third dimension.
+A moment of thought will prove that this operation is simply the much
+faster ordinary matrix multiplication, @code{@var{c} = @var{a}*@var{b};}.
+
+A note on terminology: ``broadcasting'' is the term popularized by the
+Numpy numerical environment in the Python programming language.  In other
+programming languages and environments, broadcasting may also be known
+as @emph{binary singleton expansion} (BSX, in @sc{matlab}, and the
+origin of the name of the @code{bsxfun} function), @emph{recycling} (R
+programming language), @emph{single-instruction multiple data} (SIMD),
+or @emph{replication}.
+
+@subsection Broadcasting and Legacy Code
+
+The new broadcasting semantics almost never affect code that worked
+in previous versions of Octave.  Consequently, all code inherited from
+@sc{matlab} that worked in previous versions of Octave should still work
+without change in Octave.  The only exception is code such as
+
+@example
+@group
+try
+  c = a.*b;
+catch
+  c = a.*a;
+end_try_catch
+@end group
+@end example
+
+@noindent
+that may have relied on matrices of different size producing an error.
+Due to how broadcasting changes semantics with older versions of Octave,
+by default Octave warns if a broadcasting operation is performed.  To
+disable this warning, refer to its ID (@pxref{doc-warning_ids}):
+
+@example
+warning ("off", "Octave:broadcast");
+@end example
+
+@noindent
+If you want to recover the old behavior and produce an error, turn this
+warning into an error:
+
+@example
+warning ("error", "Octave:broadcast");
+@end example
+
+@noindent
+For broadcasting on scalars that worked in previous versions of Octave,
+this warning will not be emitted.
+
+@node Function Application
+@section Function Application
+@cindex map
+@cindex apply
+@cindex function application
+
+As a general rule, functions should already be written with matrix
+arguments in mind and should consider whole matrix operations in a
+vectorized manner.  Sometimes, writing functions in this way appears
+difficult or impossible for various reasons.  For those situations,
+Octave provides facilities for applying a function to each element of an
+array, cell, or struct.
+
+@DOCSTRING(arrayfun)
+
+@DOCSTRING(spfun)
+
+@DOCSTRING(cellfun)
+
+@DOCSTRING(structfun)
+
+@node Accumulation
+@section Accumulation
+
+Whenever it's possible to categorize according to indices the elements
+of an array when performing a computation, accumulation functions can be
+useful.
+
+@DOCSTRING(accumarray)
+
+@DOCSTRING(accumdim)
+
+@node Miscellaneous Techniques
+@section Miscellaneous Techniques
+@cindex execution speed
+@cindex speedups
+@cindex optimization
+
+Here are some other ways of improving the execution speed of Octave
+programs.
+
+@itemize @bullet
+
+@item Avoid computing costly intermediate results multiple times.
+Octave currently does not eliminate common subexpressions.  Also, certain
+internal computation results are cached for variables.  For instance, if
+a matrix variable is used multiple times as an index, checking the
+indices (and internal conversion to integers) is only done once.
+
+@item Be aware of lazy copies (copy-on-write).  
+@cindex copy-on-write
+@cindex COW
+@cindex memory management
+When a copy of an object is created, the data is not immediately copied, but
+rather shared.  The actual copying is postponed until the copied data needs to
+be modified.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a; # no copying done here
+b(1) = 1; # copying done here
+@end group
+@end example
+
+Lazy copying applies to whole Octave objects such as matrices, cells,
+struct, and also individual cell or struct elements (not array
+elements).
+
+Additionally, index expressions also use lazy copying when Octave can
+determine that the indexed portion is contiguous in memory.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # no copying done here
+b = a(10:100,:);  # copying done here
+@end group
+@end example
+
+This applies to arrays (matrices), cell arrays, and structs indexed
+using @samp{()}.  Index expressions generating comma-separated lists can also
+benefit from shallow copying in some cases.  In particular, when @var{a} is a
+struct array, expressions like @code{@{a.x@}, @{a(:,2).x@}} will use lazy
+copying, so that data can be shared between a struct array and a cell array.
+
+Most indexing expressions do not live longer than their parent
+objects.  In rare cases, however, a lazily copied slice outlasts its
+parent, in which case it becomes orphaned, still occupying unnecessarily
+more memory than needed.  To provide a remedy working in most real cases,
+Octave checks for orphaned lazy slices at certain situations, when a
+value is stored into a "permanent" location, such as a named variable or
+cell or struct element, and possibly economizes them.  For example:
+
+@example
+@group
+a = zeros (1000); # create a 1000x1000 matrix
+b = a(:,10:100);  # lazy slice
+a = []; # the original a array is still allocated
+c@{1@} = b; # b is reallocated at this point
+@end group
+@end example
+
+@item Avoid deep recursion.
+Function calls to m-file functions carry a relatively significant overhead, so
+rewriting a recursion as a loop often helps.  Also, note that the maximum level
+of recursion is limited.
+
+@item Avoid resizing matrices unnecessarily.
+When building a single result matrix from a series of calculations, set the
+size of the result matrix first, then insert values into it.  Write
+
+@example
+@group
+result = zeros (big_n, big_m)
+for i = over:and_over
+  ridx = @dots{}
+  cidx = @dots{}
+  result(ridx, cidx) = new_value ();
+endfor
+@end group
+@end example
+
+@noindent
+instead of
+
+@example
+@group
+result = [];
+for i = ever:and_ever
+  result = [ result, new_value() ];
+endfor
+@end group
+@end example
+
+Sometimes the number of items can not be computed in advance, and
+stack-like operations are needed.  When elements are being repeatedly
+inserted or removed from the end of an array, Octave detects it as stack
+usage and attempts to use a smarter memory management strategy by
+pre-allocating the array in bigger chunks.  This strategy is also applied
+to cell and struct arrays.
+
+@example
+@group
+a = [];
+while (condition)
+  @dots{}
+  a(end+1) = value; # "push" operation
+  @dots{}
+  a(end) = []; # "pop" operation
+  @dots{}
+endwhile
+@end group
+@end example
+
+@item Avoid calling @code{eval} or @code{feval} excessively.
+Parsing input or looking up the name of a function in the symbol table are
+relatively expensive operations.
+
+If you are using @code{eval} merely as an exception handling mechanism, and not
+because you need to execute some arbitrary text, use the @code{try}
+statement instead.  @xref{The @code{try} Statement}.
+
+@item Use @code{ignore_function_time_stamp} when appropriate.
+If you are calling lots of functions, and none of them will need to change
+during your run, set the variable @code{ignore_function_time_stamp} to
+@code{"all"}.  This will stop Octave from checking the time stamp of a function
+file to see if it has been updated while the program is being run.
+@end itemize
+
+@node Examples
+@section Examples
+
+The following are examples of vectorization questions asked by actual
+users of Octave and their solutions.
+
+@c FIXME: We need a lot more examples here.
+
+@itemize @bullet
+@item
+For a vector @code{A}, the following loop
+
+@example
+@group
+n = length (A);
+B = zeros (n, 2);
+for i = 1:length(A)
+  ## this will be two columns, the first is the difference and
+  ## the second the mean of the two elements used for the diff.
+  B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
+endfor
+@end group
+@end example
+
+@noindent
+can be turned into the following one-liner:
+
+@example
+B = [diff(A)(:), 0.5*(A(1:end-1)+A(2:end))(:)]
+@end example
+
+Note the usage of colon indexing to flatten an intermediate result into
+a column vector.  This is a common vectorization trick.
+
+@end itemize
diff --git a/doc/liboctave/array.texi b/doc/liboctave/array.texi
--- a/doc/liboctave/array.texi
+++ b/doc/liboctave/array.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/bugs.texi b/doc/liboctave/bugs.texi
--- a/doc/liboctave/bugs.texi
+++ b/doc/liboctave/bugs.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/cp-idx.texi b/doc/liboctave/cp-idx.texi
--- a/doc/liboctave/cp-idx.texi
+++ b/doc/liboctave/cp-idx.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/dae.texi b/doc/liboctave/dae.texi
--- a/doc/liboctave/dae.texi
+++ b/doc/liboctave/dae.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/diffeq.texi b/doc/liboctave/diffeq.texi
--- a/doc/liboctave/diffeq.texi
+++ b/doc/liboctave/diffeq.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/error.texi b/doc/liboctave/error.texi
--- a/doc/liboctave/error.texi
+++ b/doc/liboctave/error.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/factor.texi b/doc/liboctave/factor.texi
--- a/doc/liboctave/factor.texi
+++ b/doc/liboctave/factor.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/fn-idx.texi b/doc/liboctave/fn-idx.texi
--- a/doc/liboctave/fn-idx.texi
+++ b/doc/liboctave/fn-idx.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/gpl.texi b/doc/liboctave/gpl.texi
--- a/doc/liboctave/gpl.texi
+++ b/doc/liboctave/gpl.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/install.texi b/doc/liboctave/install.texi
--- a/doc/liboctave/install.texi
+++ b/doc/liboctave/install.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/intro.texi b/doc/liboctave/intro.texi
--- a/doc/liboctave/intro.texi
+++ b/doc/liboctave/intro.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/liboctave.texi b/doc/liboctave/liboctave.texi
--- a/doc/liboctave/liboctave.texi
+++ b/doc/liboctave/liboctave.texi
@@ -1,9 +1,9 @@
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at
 % your option) any later version.
 % 
diff --git a/doc/liboctave/matvec.texi b/doc/liboctave/matvec.texi
--- a/doc/liboctave/matvec.texi
+++ b/doc/liboctave/matvec.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/nleqn.texi b/doc/liboctave/nleqn.texi
--- a/doc/liboctave/nleqn.texi
+++ b/doc/liboctave/nleqn.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/nlfunc.texi b/doc/liboctave/nlfunc.texi
--- a/doc/liboctave/nlfunc.texi
+++ b/doc/liboctave/nlfunc.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1997-2011 John W. Eaton
+@c Copyright (C) 1997-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/ode.texi b/doc/liboctave/ode.texi
--- a/doc/liboctave/ode.texi
+++ b/doc/liboctave/ode.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/optim.texi b/doc/liboctave/optim.texi
--- a/doc/liboctave/optim.texi
+++ b/doc/liboctave/optim.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/preface.texi b/doc/liboctave/preface.texi
--- a/doc/liboctave/preface.texi
+++ b/doc/liboctave/preface.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/quad.texi b/doc/liboctave/quad.texi
--- a/doc/liboctave/quad.texi
+++ b/doc/liboctave/quad.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/liboctave/range.texi b/doc/liboctave/range.texi
--- a/doc/liboctave/range.texi
+++ b/doc/liboctave/range.texi
@@ -1,9 +1,9 @@
-@c Copyright (C) 1996-2011 John W. Eaton
+@c Copyright (C) 1996-2012 John W. Eaton
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
diff --git a/doc/refcard/Makefile.am b/doc/refcard/Makefile.am
--- a/doc/refcard/Makefile.am
+++ b/doc/refcard/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's doc/refcard directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/doc/refcard/refcard-a4.tex b/doc/refcard/refcard-a4.tex
--- a/doc/refcard/refcard-a4.tex
+++ b/doc/refcard/refcard-a4.tex
@@ -1,13 +1,13 @@
 % refcard-a4.tex
 %
 % Make a reference card that will fit on A4 paper.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard-legal.tex b/doc/refcard/refcard-legal.tex
--- a/doc/refcard/refcard-legal.tex
+++ b/doc/refcard/refcard-legal.tex
@@ -1,13 +1,13 @@
 % refcard-legal.tex
 %
 % Make a reference card that will fit on US legal paper.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard-letter.tex b/doc/refcard/refcard-letter.tex
--- a/doc/refcard/refcard-letter.tex
+++ b/doc/refcard/refcard-letter.tex
@@ -1,14 +1,14 @@
 % refcard-letter.tex
 %
 % Make a reference card that will fit on US letter paper
 % (8-1/2 by 11 inches).
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -1,13 +1,13 @@
 % refcard.tex
 %
 % This file is TeX source for a reference card describing Octave.
 %
-% Copyright (C) 1996-2011 John W. Eaton
+% Copyright (C) 1996-2012 John W. Eaton
 %
 % This file is part of Octave.
 %
 % Octave is free software; you can redistribute it and/or modify it
 % under the terms of the GNU General Public License as published by the
 % Free Software Foundation; either version 3 of the License, or (at your
 % option) any later version.
 %
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -184,17 +184,17 @@ John W. Eaton
 jwe@octave.org
 
 
 Last updated: Tue Nov 22 20:51:34 PST 2011
 
 
 ################################################################################
 
-Copyright (C) 2009,2011 John W. Eaton
+Copyright (C) 2009,2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/etc/README.Cygwin b/etc/README.Cygwin
--- a/etc/README.Cygwin
+++ b/etc/README.Cygwin
@@ -2,50 +2,88 @@ Starting with version 3.0.1, Octave is o
 net distribution of Cygwin, available from http://www.cygwin.com.  
 
 It is possible to build Octave from source on Windows systems with Cygwin,
 but with the old gcc-3.4.4-3 compiler there are some performance
 problems related to the way C++ exception handling is implemented.
 This is a known problem with a long history and it is STRONGLY 
 encouraged to use gcc-4.3.2-1 or later.
 
-Current binary versions are built with gcc-4.3.4-3 while 
-binary version 3.0.2-2 was built with gcc-4.3.2-1.
+Current binary versions are built with gcc-4.5.3-3.  
+
 
-The latest development Octave development sources (octave-3.3.54+)
+------- SUGGESTED CONFIGURATION  ---------------------------
+
+The latest development Octave development sources (octave-3.5.91+)
 are built with:
 
 configure --enable-shared \
           --enable-float-truncate \
           CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4 
           lt_cv_deplibs_check_method=pass_all \
-          LDFLAGS=-no-undefined 
+          LDFLAGS=-Wl,-no-undefined 
 
 "--enable-float-truncate" is needed for the following bug:
 http://thread.gmane.org/gmane.comp.gnu.octave.bugs/12361/focus=12404
 Without it, one of the quadgk test will fail as
 "a=a" could be false due to truncation problems with 
 complex numbers. 
 
 "lt_cv_deplibs_check_method=pass_all"  is needed to bypass
 incorrect libtool detection of system capabilities and
 to allow shared libs building.
 
+"LDFLAGS=-Wl,-no-undefined" is better than previous 
+"LDFLAGS=-no-undefined" as gcc-4 is now complaining about
+unknown command and the "undefined" is for the linker.
+
+The additional patch used for 3.4.3-3 package can also be 
+needed for 3.6.x (see below).
+
+------- SUGGESTION FOR FORK ISSUE --------------------------
+
+The build process can fails in building images for documentation 
+due to fork issue of the octave dll just built. In such case 
+I suggest to rebase the built dll's with:
+
+$ find build_tree -name "*.dll"  > rebase_list
+
+and after closing all cygwin process, from a dash shell
+
+$ rebaseall -s 'dll|so|oct' -T /full_path/rebase_list
+
+After rebasing the "make" should be able to complete the
+creation of the images and the documentation. 
+
+------------------------------------------------------ 
+
+Octave-3.4.3-3 package was built using:
+
+configure --libexecdir=/usr/lib \
+          --enable-shared \
+          --enable-float-truncate \
+          F77=gfortran-4 \
+          lt_cv_deplibs_check_method=pass_all \
+          LDFLAGS=-no-undefined    
+
+plus and additional patch to solve a specific cygwin 
+fltk print issue, see:
+https://savannah.gnu.org/bugs/?31641
 
 Octave-3.2.4 was built using:
 
 configure --enable-shared \
           --without-fltk \
           --without-framework-opengl \
           CC=gcc-4 F77=gfortran-4 CXX=g++-4 CPP=cpp-4
           CFLAGS="-Dtimezone=_timezone"
 
-
+------------------------------------------------------
 Current Cygwin package maintainer for Octave:
 
   Marco Atzeri
   http://matzeri.altervista.org
 
 Marco Atzeri
-marco_atzeri@yahoo.it
+marco.atzeri@gmail.com
 Italy
 
-Last updated: Mon Jan  3 18:53:41 WEST 2011
+Last updated: Tue Jan  3 14:40:58 WEST 2012
diff --git a/examples/@FIRfilter/FIRfilter.m b/examples/@FIRfilter/FIRfilter.m
--- a/examples/@FIRfilter/FIRfilter.m
+++ b/examples/@FIRfilter/FIRfilter.m
@@ -1,14 +1,12 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} FIRfilter ()
+## @deftypefn  {Function File} {} FIRfilter ()
 ## @deftypefnx {Function File} {} FIRfilter (@var{p})
-## Creates an FIR filter with polynomial @var{p} as
-## coefficient vector.
-##
+## Create a FIR filter with polynomial @var{p} as coefficient vector.
 ## @end deftypefn
 
 function f = FIRfilter (p)
 
   f.polynomial = [];
   if (nargin == 0)
     p = @polynomial ([1]);
   elseif (nargin == 1)
diff --git a/examples/@FIRfilter/FIRfilter_aggregation.m b/examples/@FIRfilter/FIRfilter_aggregation.m
--- a/examples/@FIRfilter/FIRfilter_aggregation.m
+++ b/examples/@FIRfilter/FIRfilter_aggregation.m
@@ -1,14 +1,12 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} FIRfilter ()
+## @deftypefn  {Function File} {} FIRfilter ()
 ## @deftypefnx {Function File} {} FIRfilter (@var{p})
-## Creates an FIR filter with polynomial @var{p} as
-## coefficient vector.
-##
+## Create a FIR filter with polynomial @var{p} as coefficient vector.
 ## @end deftypefn
 
 function f = FIRfilter (p)
 
   if (nargin == 0)
     f.polynomial = @polynomial ([1]);
   elseif (nargin == 1)
     if (isa (p, "polynomial"))
diff --git a/examples/@polynomial/polynomial.m b/examples/@polynomial/polynomial.m
--- a/examples/@polynomial/polynomial.m
+++ b/examples/@polynomial/polynomial.m
@@ -1,18 +1,19 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polynomial ()
+## @deftypefn  {Function File} {} polynomial ()
 ## @deftypefnx {Function File} {} polynomial (@var{a})
-## Creates a polynomial object representing the polynomial
+## Create a polynomial object representing the polynomial
 ##
 ## @example
 ## a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
 ## @end example
 ##
-## from a vector of coefficients [a0 a1 a2 ... an].
+## @noindent
+## from a vector of coefficients [a0 a1 a2 @dots{} an].
 ## @end deftypefn
 
 function p = polynomial (a)
   if (nargin == 0)
     p.poly = [0];
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
diff --git a/examples/@polynomial/polynomial_superiorto.m b/examples/@polynomial/polynomial_superiorto.m
--- a/examples/@polynomial/polynomial_superiorto.m
+++ b/examples/@polynomial/polynomial_superiorto.m
@@ -1,18 +1,19 @@
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polynomial ()
+## @deftypefn  {Function File} {} polynomial ()
 ## @deftypefnx {Function File} {} polynomial (@var{a})
-## Creates a polynomial object representing the polynomial
+## Create a polynomial object representing the polynomial
 ##
 ## @example
 ## a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
 ## @end example
 ##
-## from a vector of coefficients [a0 a1 a2 ... an].
+## @noindent
+## from a vector of coefficients [a0 a1 a2 @dots{} an].
 ## @end deftypefn
 
 function p = polynomial (a)
   if (nargin == 0)
     p.poly = [0];
     p = class (p, "polynomial");
   elseif (nargin == 1)
     if (strcmp (class (a), "polynomial"))
diff --git a/examples/Makefile.am b/examples/Makefile.am
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's examples directory
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's libcruft directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
@@ -38,17 +38,17 @@ include link-deps.mk
 
 libcruft_la_LIBADD = \
   libranlib.la \
   ../libgnu/libgnu.la \
   $(LIBCRUFT_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool
 # manual:
-libcruft_current = 0
+libcruft_current = 1
 libcruft_revision = 0
 libcruft_age = 0
 
 libcruft_version_info = $(libcruft_current):$(libcruft_revision):$(libcruft_age)
 
 libcruft_la_LDFLAGS = \
   -version-info $(libcruft_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
@@ -64,17 +64,16 @@ libranlib_la_SOURCES =
 
 libranlib_la_DEPENDENCIES = ranlib.def
 
 octinclude_HEADERS =
 
 EXTRA_DIST =
 
 include amos/module.mk
-include arpack/module.mk
 include blas-xtra/module.mk
 include daspk/module.mk
 include dasrt/module.mk
 include dassl/module.mk
 include fftpack/module.mk
 include lapack-xtra/module.mk
 include misc/module.mk
 include odepack/module.mk
diff --git a/libcruft/arpack/LICENSE b/libcruft/arpack/LICENSE
deleted file mode 100644
--- a/libcruft/arpack/LICENSE
+++ /dev/null
@@ -1,35 +0,0 @@
-BSD Software License
-
-Pertains to ARPACK and P_ARPACK
-
-Copyright (c) 1996-2008 Rice University.  
-Developed by D.C. Sorensen, R.B. Lehoucq, C. Yang, and K. Maschhoff.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-- Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer. 
-  
-- Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer listed
-  in this license in the documentation and/or other materials
-  provided with the distribution.
-  
-- Neither the name of the copyright holders nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-  
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
diff --git a/libcruft/arpack/README b/libcruft/arpack/README
deleted file mode 100644
--- a/libcruft/arpack/README
+++ /dev/null
@@ -1,120 +0,0 @@
-1. You have successfully unbundled ARPACK and are now in the ARPACK 
-   directory that was created for you.
-
-2. Recent bug fixes are included in patch.tar.gz and ppatch.tar.gz 
-   If you have not retrieved these files, please do so and place them in 
-   the directory right above the current directory.  (They should
-   be in the same directory where arpack96.tar and parpack96.tar reside).
-   Use uncompress or gunzip to unzip the tar files, and use 'tar -xvf '
-   to unbundle these patches.  The source codes in these patches will 
-   overwrite those contained in arpack96.tar and parpack96.tar.
-
-3. Upon executing the 'ls | more ' command you should see
-
-      BLAS
-      DOCUMENTS
-      EXAMPLES
-      LAPACK
-      README
-      SRC
-      UTIL
-      Makefile
-      ARmake.inc
-      ARMAKES
-      PARPACK
-
-   The following entries are directories:
-
-      ARMAKES, BLAS, DOCUMENTS, EXAMPLES, LAPACK, SRC, UTIL, PARPACK
-
-   The directory SRC contains the top level routines including 
-   the highest level reverse communication interface routines
-
-      ssaupd, dsaupd - symmetric single and double precision
-      snaupd, dnaupd - non-symmetric single and double precision
-      cnaupd, znaupd - complex non-symmetric single and double precision
-
-   The headers of these routines contain full documentation of calling
-   sequence and usage.  Additional information is in the DOCUMENTS directory.
-
-   The directory PARPACK contains the Parallel ARPACK routines.
-     
-
-3. Example driver programs that illustrate all the computational modes,
-   data types and precisions may be found in the EXAMPLES directory.
-   Upon executing the 'ls EXAMPLES | more ' command you should see
-
-      BAND
-      COMPLEX
-      NONSYM
-      README
-      SIMPLE
-      SVD
-      SYM
-
-   Example programs for banded, complex, nonsymmetric, symmetric,
-   and singular value decomposition may be found in the directories
-   BAND, COMPLEX, NONSYM, SYM, SVD respectively.  Look at the README
-   file for further information.  To get started, get into the SIMPLE
-   directory to see example programs that illustrate the use of ARPACK in
-   the simplest modes of operation for the most commonly posed 
-   standard eigenvalue problems.  
-
-
-   Example programs for Parallel ARPACK may be found in the directory
-   PARPACK/EXAMPLES. Look at the README file for further information.
-
-   The following instructions explain how to make the ARPACK library.
-
-4. Before you can compile anything, you must first edit and correct the file
-   ARmake.inc. Sample ARmake.inc's can be found in the ARMAKES directory.
-   If you plan on using Parallel ARPACK you will need to use those sample
-   files which contain either BLACS or MPI in their name. For example,
-   ARmake.MPI-$(PLAT) or ARmake.BLACS-$(PLAT).
-   Edit "ARmake.inc" and change the definition "home" to the root of the
-   source tree (Top level of ARPACK directory)
-
-   The makefile is set up to build a self-contained library which includes
-   the needed BLAS 1/2/3 and LAPACK routines.  If you already have the
-   BLAS and LAPACK libraries installed on your system you might want to
-   change the definition of DIRS as indicated in the ARmake.inc file. 
-
-   *** NOTE ***  The LAPACK library on your system MUST be the public release.
-   The current release is version 2.0. If you are not certain if the public 
-   release has been installed, we strongly recommend that you compile and link 
-   to the subset of LAPACK included here. 
-
-
-5. You will also need to change the file "second.f" in the UTIL directory
-   to whatever is appropriate for timing on your system.  The "second" routine
-   provided works on most workstations.  If you are running on a Cray,
-   copy the file "second.f.CRAYT3D" to "second.f"  to use the rtf system 
-   function. 
-
-
-6. Do "make lib" in the current directory to build the standard library 
-   "libarpack_$(PLAT).a" (serial code)
- 
-   To build the the parallel library, "parpack_$(COMMLIB)-$(PLAT).a",
-   type "make plib". When using the parallel routines you must link to 
-   both the serial library and the parallel library.
-
-
-7. Within DOCUMENTS directory there are three files 
-
-   ex-sym.doc 
-   ex-nonsym.doc and
-   ex-complex.doc
-
-   for templates on how to invoke the computational modes of ARPACK.
-   Also look in the README file for explanations concerning the 
-   other documents.
-
-
-   Danny Sorensen   at  sorensen@caam.rice.edu
-   Richard Lehoucq  at  rblehou@sandia.gov
-   Chao Yang        at  cyang@lbl.gov
-   Kristi Maschhoff at  kristyn@tera.com
-
- Good luck and enjoy.
-
diff --git a/libcruft/arpack/docs/README b/libcruft/arpack/docs/README
deleted file mode 100644
--- a/libcruft/arpack/docs/README
+++ /dev/null
@@ -1,18 +0,0 @@
-
-  There are five documents within the DOCUMENT subdirectory.
-  In summary,
-
-  ex-nonsym.doc, ex-sym.doc  and ex-complex.doc
-  -------------  ----------      --------------
-  Example Templates of how to invoke the different computational
-  modes offered by [D,S]NAUPD, [D,S]SAUPD and [C,Z]NAUPD.
-
-  stat.doc
-  --------
-  File that gets timing statistics for the different parts
-  of the Arnoldi update iteration codes within ARPACK. 
-
-  debug.doc
-  ---------
-  File that explains the different printing options of the
-  Arnoldi update iteration codes within ARPACK. 
diff --git a/libcruft/arpack/docs/debug.doc b/libcruft/arpack/docs/debug.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/debug.doc
+++ /dev/null
@@ -1,339 +0,0 @@
- ARPACK provides a means to trace the progress of the computation
- as it proceeds.  Various levels of output may be specified
- from no output, level = 0, to voluminous, level = 3.
- The following statements may be used within the calling program to 
- initiate and request this output.
-
-      include 'debug.h'
-      ndigit = -3
-      logfil = 6
-      msgets = 0
-      msaitr = 0
-      msapps = 0
-      msaupd = 1
-      msaup2 = 0
-      mseigt = 0
-      mseupd = 0
-
- The parameter "logfil" specifies the logical unit number of the output 
- file.  The parameter "ndigit" specifies the number of decimal digits 
- and the width of the output lines. A positive value of "ndigit"
- specifies that 132 columns are used during output and a negative 
- value specifies eighty columns are to be used. The values of the remaining 
- parameters indicate the output levels from the indicated routines.  
-
- For the above example, "msaitr" indicates the level of output requested 
- for the subroutine ssaitr or dsaitr.  The above configuration will
- give a breakdown of the number of matrix vector products required,
- the total number of iterations, the number of re-orthogonalization
- steps and an estimate of the time spent in each routine and phase of the 
- computation.  The following output is produced:   
-
----------------------------------------------------------------------
-     ==========================================
-     = Symmetric implicit Arnoldi update code =
-     = Version Number: 2.1                    =
-     = Version Date:   11/15/95               =
-     ==========================================
-     = Summary of timing statistics           =
-     ==========================================
-
-
-     Total number update iterations             =     8
-     Total number of OP*x operations            =   125
-     Total number of B*x operations             =     0
-     Total number of reorthogonalization steps  =   125
-     Total number of iterative refinement steps =     0
-     Total number of restart steps              =     0
-     Total time in user OP*x operation          =     0.020002
-     Total time in user B*x operation           =     0.000000
-     Total time in Arnoldi update routine       =     0.210021
-     Total time in ssaup2 routine               =     0.190019
-     Total time in basic Arnoldi iteration loop =     0.110011
-     Total time in reorthogonalization phase    =     0.070007
-     Total time in (re)start vector generation  =     0.000000
-     Total time in trid eigenvalue subproblem   =     0.040004
-     Total time in getting the shifts           =     0.000000
-     Total time in applying the shifts          =     0.040004
-     Total time in convergence testing          =     0.000000
-
----------------------------------------------------------------------
-
- The user is encouraged to experiment with the other settings 
- once some familiarity has been gained with the routines. 
-
- The include statement sets up the storage declarations that are
- solely associated with this trace debugging feature. "debug.h"
- has the following structure:
-
----------------------------------------------------------------------
-c
-c\SCCS Information: @(#) 
-c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c     %---------------------------------%
-c     | See debug.doc for documentation |
-c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
----------------------------------------------------------------------
-
-
- The parameters "msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd"
- are for the symmetric codes, while 
- "mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd" are for the 
- nonsymmetric codes and, finally, 
- "mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd" are for the complex
- arithmetic codes. A comprehensive break down of each parameter is given
- below.
-
- ==========================================================
- === Common to symmetric, nonsymmetric and complex code ===
- ==========================================================
-
-
- logfil:     unit number where the logfile (debug) is written
-
- ndigit:     number of digits used in the debug output
- ndigit < 0: printing is done with  72 columns.
- ndigit > 0: printing is done with 132 columns.
-
- mgetv0 > 0: print residual vector generated.
-
-             ======================================
-             === Specific to the symmetric code ===
-             ======================================
-
- msaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues,
-              final Ritz values and corresponding Ritz estimates.
-             *Print various timing statistics.
-
- msaup2 > 0: *Print major iteration number, 
-             number of "converged" Ritz values on exit,
-             B-norm of the residual vector of length NCV factorization,
-             B-norm of the residual vector of length NEV factorization,
-             residual norm before exit,
-             Ritz values and corresponding Ritz estimates before exit.
- msaup2 > 1: print number of unreduced submatrices,
-             Ritz values and corresponding Ritz estimates of the current 
-             T matrix, actual values for NEV and NP,
-             wanted Ritz values and corresponding Ritz estimates,
-             shifts selected.
- msaup2 > 2: print "unwanted" Ritz values and corresponding Ritz
-             estimates, order NCV matrix T (diagonal and off-diagonal),
-             unwanted Ritz values and error bounds.
-
- msaitr > 0: print iteration number, residual norm, restart info
-             print if an off diagonal element of T became negative.
- msaitr > 1: print the final matrix T.
- msaitr > 2: print Arnoldi vector no. generate at iteration j,
-             b-norm of residual vector at each iteration,
-             print rnorm and rnorm1 for iterative refinement,
-             print wnorm and rnorm used for Re-orthogonalization,
-             V^T * B * (resid/B-norm(resid)),
-             print the results of whether the current residual vector is 
-             orthogonal to the current Lanczos basis.
- msaitr > 3: print the matrix T at each iteration.
-             print the residual vector and arnoldi vectors.
-
- mseigt > 0: print the current matrix T.
-
- msgets > 0: print NEV and NP,
-             eigenvalues of and corresponding Ritz estimates of the 
-             current T matrix.
-
- msapps > 0: print information about deflation at row/column no.
- msapps > 1: print initial matrix T
-             print sigmak, betak and matrix T after all shifts
- msapps > 2: print the matrix T after the application of each shift.
- msapps > 3: updated residual for next iteration.
-
- mseupd > 1: print eigenvalues of the final T matrix,
-             the last row of the eigenvector matrix for T,
-             if reordered, reordered last row of the eigenvector matrix,
-             reordered NCV Ritz values of the final T matrix,
-             if type = 'REGULAR', untransformed "converged" Ritz values 
-             and corresponding Ritz estimates,
-             NCV Ritz values of the final T matrix,
-             last row of the eigenvector matrix for T,
-             if reordered, reordered last row of the eigenvector matrix,
-             reordered NCV Ritz values of the final T.
-
- mseupd > 2: print the matrix T.
-
-              =========================================
-              === Specific to the nonsymmetric code ===
-              =========================================
-
- mnaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues,
-              real and imaginary parts of the converged Ritz values
-              and their corresponding Ritz estimates,
-             *Print various timing statistics.
-
- mnaup2 > 0: *Print major iteration number.
-             *Print the number of "converged" Ritz values on exit,
-              and the real and imaginary parts of the "converged" Ritz
-              values and corresponding Ritz estimates.
- mnaup2 > 1: *Print the length of the Arnoldi Factorization,
-              and the B-norm of its residual vector.
-             *Print NEV and NP, real and imaginary parts of the "wanted"
-              Ritz values and associated Ritz estimates at each
-              iteration.
-             *Print the B-norm of the residual of the compressed
-              factorization and the compressed upper Hessenberg matrix H.
- mnaup2 > 2: *Print the real and imaginary parts of all the Ritz values
-              and associated Ritz estimates, NEV, NP, NUMCNV, NCONV.
-             *Print the real and imaginary parts of the shifts. If the
-              exact shift strategy is used, print the associated Ritz
-              estimates of the shifts.
-             *Print the real and imaginary parts of the Ritz values
-              and the corresponding Ritz estimates obtained from _neigh.
-
- mnaitr > 0: *Print if a restart is needed.
- mnaitr > 1: *Print the number of Arnoldi vector being generated and
-              the B-norm of the current residual.
- mnaitr > 2: *Print j-th column of the Hessenberg matrix H.
-             *Print reorthogonalization and iterative refinement information,
-             *Print the final upper Hessenberg matrix of order K+NEV.
- mnaitr > 3: *Print V^T*B*resid/(B-norm(resid)).
- mnaitr > 4: *Print current upper Hessenberg matrix.
- mnaitr > 5: *Print updated arnoldi vectors and the residual vector.
-
- mneigh > 1: *Print the last row of the Schur matrix for H, and
-             the last row of the eigenvector matrix for H.
- mneigh > 2: *Print the entering upper Hessenberg matrix.
-             *Print the real and imaginary part of eigenvalues
-              of the current Hessenberg matrix, and associated 
-              Ritz estimates. 
-
- mngets > 0: *Print the real and imaginary parts of the Ritz values
-              of the Hessenberg matrix and their the corresponding 
-              error bounds, KEV, NP.
-
- mnapps > 0: *Print information about where deflation occured.
- mnapps > 1: *Print sigmak, betak, order of the final Hessenberg matrix,
-              and the final compressed upper Hessenberg matrix.
- mnapps > 2: *Print implicit application of shift number, real and imaginary 
-              part of the shift.
-             *Print the indices of the submatrix that the shift is applied.
- mnapps > 3: *Print the matrix H before and after the application of 
-              each shift, updated residual for next iteration.
- mnapps > 4: *Print the accumulated orthogonal Hessenberg matrix Q,
-              updated matrix of Arnoldi vectors.
- 
- mneupd > 0: *Print the number of converged Ritz values, B-norm of the 
-              residual, all NCV Ritz values and error bounds.
- mneupd > 1: *Print the final upper Hessenberg matrix computed by _naupd.
-             *If Ritz vectors are requested, print real and imaginary parts 
-              of the eigenvalues and the last row of the Schur vectors as 
-              computed by _neupd. 
- mneupd > 2: *If Ritz vectors are requested, print the threshold eigenvalue 
-              used for re-ordering.
-             *If Ritz vectors are requested, print the number of eigenvalues
-              to reorder and the number of converged Ritz values.
-             *If Ritz vectors are requested, print the upper quasi-matrix
-              computed by _neupd.
-             *If Ritz vectors are requested, print the real and imaginary
-              part of the Ritz values.
-             *If Ritz vectors are requested, print the last row of the 
-              eigenvector matrix.
-             *Print the NCV Ritz estimates in the original system.
- mneupd > 3: *Print the integer array of pointers.
-             *If Ritz vectors are requested, print the eigenvector matrix.
-             *If Ritz vectors are requested, print the reordered upper 
-              quasi-triangular matrix.
- mneupd > 4: *If Ritz vectors are requested, print the Q matrix of the QR 
-              factorization of the matrix representing the wanted invariant 
-              subspace. 
-             *If Ritz vectors are requested, print the Schur vectors.
-             *If Ritz vectors are requested, print the reordered Schur vectors.
-
-              
-             ====================================
-             === Specific to the complex code ===
-             ====================================
-
- mcaupd > 0: *Print the number of iterations taken, 
-              number of "converged" eigenvalues, the converged Ritz values
-              and their corresponding Ritz estimates,
-             *Print various timing statistics.
-
- mcaup2 > 0: *Print major iteration number.
-             *Print the number of "converged" Ritz values on exit, and the 
-              "converged" Ritz values and corresponding Ritz estimates.
- mcaup2 > 1: *Print the length of the Arnoldi Factorization,
-              and the B-norm of its residual vector.
-             *Print NEV and NP, the "wanted" Ritz values and associated Ritz 
-              estimates at each iteration.
-             *Print the B-norm of the residual of the compressed
-              factorization and the compressed upper Hessenberg matrix H.
- mcaup2 > 2: *Print the all the Ritz values and associated Ritz estimates, 
-              NEV, NP, NUMCNV, NCONV.
-             *Print the shifts. If the exact shift strategy is used, print the 
-              associated Ritz estimates of the shifts.
-             *Print the Ritz values and the corresponding Ritz estimates obtained 
-              from _neigh.
-
- mcaitr > 0: *Print if a restart is needed.
- mcaitr > 1: *Print the number of Arnoldi vector being generated and
-              the B-norm of the current residual.
- mcaitr > 2: *Print j-th column of the Hessenberg matrix H.
-             *Print reorthogonalization and iterative refinement information,
-             *Print the final upper Hessenberg matrix of order K+NEV.
- mcaitr > 3: *Print V^T*B*resid/(B-norm(resid)).
- mcaitr > 4: *Print current upper Hessenberg matrix.
- mcaitr > 5: *Print updated Arnoldi vectors and the residual vector.
-
- mceigh > 1: *Print the last row of the Schur matrix for H, and
-             the last row of the eigenvector matrix for H.
- mceigh > 2: *Print the entering upper Hessenberg matrix.
-             *Print the eigenvalues of the current Hessenberg matrix, and 
-              associated Ritz estimates. 
-
- mcgets > 0: *Print the real and imaginary parts of the Ritz values
-              of the Hessenberg matrix and their the corresponding 
-              error bounds, KEV, NP.
-
- mcapps > 0: *Print information about where deflation occured.
- mcapps > 1: *Print sigmak, betak, order of the final Hessenberg matrix,
-              and the final compressed upper Hessenberg matrix.
- mcapps > 2: *Print implicit application of shift number, the shift.
-             *Print the indices of the submatrix that the shift is applied.
- mcapps > 3: *Print the matrix H before and after the application of 
-              each shift, updated residual for next iteration.
- mcapps > 4: *Print the accumulated unitary Hessenberg matrix Q, and the
-              updated matrix of Arnoldi vectors.
- 
- mceupd > 0: *Print the number of converged Ritz values, B-norm of the 
-              residual, all NCV Ritz values and error bounds.
- mceupd > 1: *Print the final upper Hessenberg matrix computed by _naupd.
-             *If Ritz vectors are requested, print the eigenvalues and the 
-              last row of the Schur vectors as computed by _neupd. 
- mceupd > 2: *If Ritz vectors are requested, print the threshold eigenvalue 
-              used for re-ordering.
-             *If Ritz vectors are requested, print the number of eigenvalues
-              to reorder and the number of converged Ritz values.
-             *If Ritz vectors are requested, print the upper quasi-matrix
-              computed by _neupd.
-             *If Ritz vectors are requested, print the Ritz values.
-             *If Ritz vectors are requested, print the last row of the 
-              eigenvector matrix.
-             *Print the NCV Ritz estimates in the original system.
- mceupd > 3: *Print the integer array of pointers.
-             *If Ritz vectors are requested, print the eigenvector matrix.
- mceupd > 4: *If Ritz vectors are requested, print the Q matrix of the QR 
-              factorization of the matrix representing the wanted invariant 
-              subspace. 
-             *If Ritz vectors are requested, print the Schur vectors.
-
-
-
diff --git a/libcruft/arpack/docs/ex-complex.doc b/libcruft/arpack/docs/ex-complex.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-complex.doc
+++ /dev/null
@@ -1,152 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I] and B = I
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iaparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in workl starting from the position
-c        ... pointed by ipntr(14).
-c        np = iparam(8)
-c        call scopy (np, shifts, 1, workl(ipntr(14), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = inv[A - sigma*M]*M and B = M
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, rwork, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, rwork, info )
-c     stop
-c     end 
-c\EndDoc
diff --git a/libcruft/arpack/docs/ex-nonsym.doc b/libcruft/arpack/docs/ex-nonsym.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-nonsym.doc
+++ /dev/null
@@ -1,256 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I] and B = I, sigma has zero 
-c     ... imaginary part
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iaparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in workl starting from the position
-c        ... pointed by ipntr(14).
-c        np = iparam(8)
-c        call scopy (np, shifts, 1, workl(ipntr(14), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = inv[A - sigma*M]*M and B = M, sigma has zero 
-c     ... imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, 
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     stop
-c     end 
-c
-c\Example-5
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... So OP = Real_Part{inv[A-SIGMA*M]*M and B=M, sigma has 
-c     ... nonzero imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... in complex  arithmetic
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve(n, temp_array, complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = real(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = real(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess.
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     ... Use Rayleigh quotient to transform d(:,1) and d(:,2)
-c         to the approximation to the original problem.
-c     stop
-c     end 
-c
-c\Example-6
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... So OP = Imaginary_Part{inv[A-SIGMA*M]*M and B=M, sigma must
-c     ... have nonzero imaginary part
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... in complex  arithmetic
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _naupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv,
-c    &              iparam, ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve(n, temp_array, complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = aimag(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), complex_array)
-c        do i = 1, n
-c           workd(ipntr(2)+i-1) = aimag(complex_array(i))
-c        end do
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _neupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c         call _neupd ( rvec, 'All', select, d, d(1,2), v, ldv,
-c    &          sigmar, sigmai, workev, bmat, n, which, nev, tol,
-c    &          resid, ncv, v, ldv, iparam, ipntr, workd, workl,
-c    &          lworkl, info )
-c     ... Use Rayleigh quotient to transform d(:,1) and d(:,2)
-c         to the Ritz approximation to the original problem.
-c     stop
-c     end
-c        
-c\EndDoc
-
diff --git a/libcruft/arpack/docs/ex-sym.doc b/libcruft/arpack/docs/ex-sym.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/ex-sym.doc
+++ /dev/null
@@ -1,234 +0,0 @@
-c-----------------------------------------------------------------------
-c        
-c\Example-1
-c     ... Suppose want to solve A*x = lambda*x in regular mode
-c     ... so OP = A  and  B = I.
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 1
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if 
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... Call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c     stop
-c     end
-c
-c\Example-2
-c     ... Suppose want to solve A*x = lambda*x in shift-invert mode
-c     ... so OP = inv[A - sigma*I]  and  B = I.
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*I]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'I', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call solve (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... Call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c\Example-3
-c     ... Suppose want to solve A*x = lambda*M*x in regular mode
-c     ... so OP = inv[M]*A  and  B = M.
-c     ... Assume "call matvecM(n,x,y)"  computes y = M*x
-c     ... Assume "call matvecA(n,x,y)"  computes y = A*x
-c     ... Assume "call solveM(n,rhs,x)" solves   M*x = rhs
-c     ... Assume user will supplied shifts
-c     ...
-c     ido = 0
-c     iparam(7) = 2
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1 .or. ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call _scopy (n, temp_array, 1, workd(ipntr(1)), 1)
-c        call solveM  (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c
-c     ... delete this last conditional if want to use exact shifts
-c     else if (ido .eq. 3) then
-c        ... compute shifts and put in the first np locations of work
-c        np = iparam(8)
-c        call _copy (np, shifts, 1, workl(ipntr(11), 1)
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess 
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end
-c
-c\Example-4
-c     ... Suppose want to solve A*x = lambda*M*x in shift-invert mode
-c     ... so OP = (inv[A - sigma*M])*M  and  B = M.
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 3
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), temp_array)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10  
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c
-c     stop
-c     end 
-c        
-c\Example-5
-c     ... Suppose want to solve K*x = lambda*KG*x in Buckling mode
-c     ... so OP = (inv[K - sigma*KG])*K  and  B = K.
-c     ... Assume "call matvecM(n,x,y)" computes y = KG*x
-c     ... Assume "call matvecA(n,x,y)" computes y = K*x
-c     ... Assume "call solve(n,rhs,x)" solves [K - sigma*KG]*x = rhs
-c     ... Assume exact shifts are used
-c
-c     ido = 0
-c     iparam(7) = 4
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess 
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end
-c
-c\Example-6
-c     ... Suppose want to solve A*x = lambda*M*x in Cayley mode
-c     ... so OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c     ... Assume "call matvecM(n,x,y)" computes y = M*x
-c     ... Assume "call matvecA(n,x,y)" computes y = A*x
-c     ... Assume "call solve(n,rhs,x)" solves [A - sigma*M]*x = rhs
-c     ... Assume exact shifts are used
-c     ...
-c     ido = 0
-c     iparam(7) = 5
-c
-c     %------------------------------------%
-c     | Beginning of reverse communication |
-c     %------------------------------------%
-c 10  continue
-c     call _saupd ( ido, 'G', n, which, nev, tol, resid, ncv, v, ldv, iparam,
-c    &              ipntr, workd, workl, lworkl, info )
-c     if (ido .eq. -1) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        call matvecA (n, workd(ipntr(1)), temp_array)
-c        call _axpy (n, sigma, workd(inptr(2)), 1, temp_array, 1)
-c        call solve (n, temp_array, workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 1) then
-c        call matvecA (n, workd(ipntr(1)), workd(ipntr(2)))
-c        call _axpy (n, sigma, workd(inptr(3)), 1, workd(ipntr(2)), 1)
-c        call _copy (n, workd(inptr(2)), 1, workd(ipntr(3)), 1)
-c        call solve (n, workd(ipntr(3)), workd(ipntr(2)))
-c        go to 10
-c     else if (ido .eq. 2) then
-c        call matvecM (n, workd(ipntr(1)), workd(ipntr(2)))
-c        go to 10
-c     end if
-c     %------------------------------%
-c     | End of Reverse communication |
-c     %------------------------------%
-c
-c     ... call _seupd to postprocess
-c     ... want the Ritz vectors set rvec = .true. else rvec = .false.
-c     call _seupd ( rvec, 'All', select, d, z, ldz, sigma, bmat,
-c    &              n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-c    &              ipntr, workd, workl, lworkl, info )
-c     stop
-c     end 
-c\EndDoc
-c
diff --git a/libcruft/arpack/docs/stat.doc b/libcruft/arpack/docs/stat.doc
deleted file mode 100644
--- a/libcruft/arpack/docs/stat.doc
+++ /dev/null
@@ -1,80 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c  Include this file to get timing statistics for the different parts
-c  of the Arnoldi update iteration.  An easy way to initialize all the
-c  timing information to zero at the beginning is by:
-c
-c     call sstats  <-- symmetric code
-c     call sstatn  <-- nonsymmetric code
-c     call cstatn  <-- complex code
-c
-c-----------------------------------------------------------------------
-c
-c  nopx   = total number of user OP*x operation
-c  nbx    = total number of user B*x operation (same as copy when B = I)
-c  nrorth = total number of reorthogonalization steps taken
-c  nitref = total number of it. refinement steps in reorthogonalization
-c  nrstrt = total number of restart steps
-c
-c-----------------------------------------------------------------------
-c
-c========================================================
-c===  Common to both symmetric and nonsymmetric code  ===
-c========================================================
-c
-c  tgetv0 = total time spent in generating starting vector and 
-c           restarted vector for the Arnoldi sequence.
-c  titref = total time spent in iterative refinement phase in SSAITR.
-c  trvec  = total time spent in computing the Ritz vectors before exit.
-c
-c====================================
-c===  Specific to symmetric code  ===
-c====================================
-c
-c  tsaupd = total time spent in SSAUPD.
-c  tsaup2 = total time spent in SSAUP2.
-c  tsaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in SSAITR.
-c  tseigt = total time spent in computing the tridiagonal eigenvalue
-c           subproblem at each iteration.
-c  tsgets = total time spent in getting the shifts at each iteration.
-c  tsapps = total time spent in applying the shifts at each iteration.
-c  tsconv = total time spent in convergence test at each iteration.
-c
-c=======================================
-c===  Specific to nonsymmetric code  ===
-c=======================================
-c
-c  tnaupd = total time spent in SNAUPD.
-c  tnaup2 = total time spent in SNAUP2.
-c  tnaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in SNAITR.
-c  tneigh = total time spent in computing the Hessenberg eigenvalue
-c           subproblem at each iteration.
-c  tngets = total time spent in getting the shifts at each iteration.
-c  tnapps = total time spent in applying the shifts at each iteration.
-c  tnconv = total time spent in convergence test at each iteration.
-c
-c==================================
-c===  Specific to complex code  ===
-c==================================
-c
-c  tcaupd = total time spent in CNAUPD.
-c  tcaup2 = total time spent in CNAUP2.
-c  tcaitr = total time spent in the basic Arnoldi iteration loop,
-c           including iterative refinement in CNAITR.
-c  tceigh = total time spent in computing the Hessenberg eigenvalue
-c           subproblem at each iteration.
-c  tcgets = total time spent in getting the shifts at each iteration.
-c  tcapps = total time spent in applying the shifts at each iteration.
-c  tcconv = total time spent in convergence test at each iteration.
-c
-c==================
-c=== User time  ===
-c==================
-c
-c  tmvopx = total time spent in computing Y = OP * X
-c  tmvbx  = total time spent in computing Y = B * X
-c
-c=======================================================================
-c
diff --git a/libcruft/arpack/module.mk b/libcruft/arpack/module.mk
deleted file mode 100644
--- a/libcruft/arpack/module.mk
+++ /dev/null
@@ -1,99 +0,0 @@
-EXTRA_DIST += \
-  arpack/LICENSE \
-  arpack/README \
-  arpack/docs/README \
-  arpack/docs/debug.doc \
-  arpack/docs/ex-complex.doc \
-  arpack/docs/ex-nonsym.doc \
-  arpack/docs/ex-sym.doc \
-  arpack/docs/stat.doc \
-  arpack/module.mk \
-  arpack/src/debug.h \
-  arpack/src/stat.h \
-  arpack/src/version.h
-
-libcruft_la_SOURCES += \
-  arpack/src/cgetv0.f \
-  arpack/src/cnaitr.f \
-  arpack/src/cnapps.f \
-  arpack/src/cnaup2.f \
-  arpack/src/cnaupd.f \
-  arpack/src/cneigh.f \
-  arpack/src/cneupd.f \
-  arpack/src/cngets.f \
-  arpack/src/csortc.f \
-  arpack/src/cstatn.f \
-  arpack/src/dgetv0.f \
-  arpack/src/dlaqrb.f \
-  arpack/src/dnaitr.f \
-  arpack/src/dnapps.f \
-  arpack/src/dnaup2.f \
-  arpack/src/dnaupd.f \
-  arpack/src/dnaupe.f \
-  arpack/src/dnconv.f \
-  arpack/src/dneigh.f \
-  arpack/src/dneupd.f \
-  arpack/src/dngets.f \
-  arpack/src/dsaitr.f \
-  arpack/src/dsapps.f \
-  arpack/src/dsaup2.f \
-  arpack/src/dsaupd.f \
-  arpack/src/dsconv.f \
-  arpack/src/dseigt.f \
-  arpack/src/dsesrt.f \
-  arpack/src/dseupd.f \
-  arpack/src/dsgets.f \
-  arpack/src/dsortc.f \
-  arpack/src/dsortr.f \
-  arpack/src/dstatn.f \
-  arpack/src/dstats.f \
-  arpack/src/dstqrb.f \
-  arpack/src/sgetv0.f \
-  arpack/src/slaqrb.f \
-  arpack/src/snaitr.f \
-  arpack/src/snapps.f \
-  arpack/src/snaup2.f \
-  arpack/src/snaupd.f \
-  arpack/src/snaupe.f \
-  arpack/src/snconv.f \
-  arpack/src/sneigh.f \
-  arpack/src/sneupd.f \
-  arpack/src/sngets.f \
-  arpack/src/ssaitr.f \
-  arpack/src/ssapps.f \
-  arpack/src/ssaup2.f \
-  arpack/src/ssaupd.f \
-  arpack/src/ssconv.f \
-  arpack/src/sseigt.f \
-  arpack/src/ssesrt.f \
-  arpack/src/sseupd.f \
-  arpack/src/ssgets.f \
-  arpack/src/ssortc.f \
-  arpack/src/ssortr.f \
-  arpack/src/sstatn.f \
-  arpack/src/sstats.f \
-  arpack/src/sstqrb.f \
-  arpack/src/zgetv0.f \
-  arpack/src/znaitr.f \
-  arpack/src/znapps.f \
-  arpack/src/znaup2.f \
-  arpack/src/znaupd.f \
-  arpack/src/zneigh.f \
-  arpack/src/zneupd.f \
-  arpack/src/zngets.f \
-  arpack/src/zsortc.f \
-  arpack/src/zstatn.f \
-  arpack/util/cmout.f \
-  arpack/util/cvout.f \
-  arpack/util/dmout.f \
-  arpack/util/dvout.f \
-  arpack/util/icnteq.f \
-  arpack/util/icopy.f \
-  arpack/util/iset.f \
-  arpack/util/iswap.f \
-  arpack/util/ivout.f \
-  arpack/util/second.f \
-  arpack/util/smout.f \
-  arpack/util/svout.f \
-  arpack/util/zmout.f \
-  arpack/util/zvout.f
diff --git a/libcruft/arpack/src/cgetv0.f b/libcruft/arpack/src/cgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/cgetv0.f
+++ /dev/null
@@ -1,414 +0,0 @@
-c\BeginDoc
-c
-c\Name: cgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call cgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to cgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that cgetv0 is called.  
-c          It should be set to 1 on the initial call to cgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c     clarnv  LAPACK routine for generating a random vector. 
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &            rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      Complex
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgemv, clarnv, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2, slapy2
-      Complex
-     &           cdotc
-      external   cdotc, scnrm2, slapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call clarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call ccopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %----------------------------------------%
-c     | Back from computing B*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call ccopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = cdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = scnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call cgemv ('C', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call cgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call ccopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         cnorm = cdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = scnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnaitr.f b/libcruft/arpack/src/cnaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in cnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call cnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See cnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clascl  LAPACK routine for careful scaling of a matrix.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number. 
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in cnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rone, rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0), 
-     &           rone = 1.0E+0, rzero = 0.0E+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Real
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real            
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cscal, csscal, cgemv, cgetv0, 
-     &           slabad, cvout, cmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex
-     &           cdotc 
-      Real            
-     &           slamch,  scnrm2, clanhs, slapy2
-      external   cdotc, scnrm2, clanhs, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real, max, sqrt 
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine clahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         cgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call cgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call ccopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call csscal (n, temp1, v(1,j), 1)
-             call csscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine clascl               |
-c            %-----------------------------------------%
-c
-             call clascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call clascl ('General', i, i, rnorm, rone,  
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call ccopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call ccopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             cnorm = cdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = scnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = cmplx(betaj, rzero)
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            cnorm = cdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call svout (logfil, 2, rtemp, ndigit, 
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call cvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call caxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             cnorm  = cdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = scnrm2(n, resid, 1)
-         end if
-c 
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call svout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue 
-            rnorm = rzero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine clahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = slapy2(real(h(i,i)),aimag(h(i,i)))
-     &              + slapy2(real(h(i+1,i+1)), aimag(h(i+1,i+1)))
-               if( tst1.eq.real(zero) )
-     &              tst1 = clanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( slapy2(real(h(i+1,i)),aimag(h(i+1,i))) .le. 
-     &                    max( ulp*tst1, smlnum ) ) 
-     &             h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call cmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cnaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnapps.f b/libcruft/arpack/src/cnapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call cnapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW. 
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Complex KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clartg  LAPACK Givens rotation construction routine.
-c     claset  LAPACK matrix initialization routine.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine clahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           h(ldh,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Real             
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cgemv, cscal, clacpy, clartg, 
-     &           cvout, claset, slabad, cmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real                 
-     &           clanhs, slamch, slapy2
-      external   clanhs, slamch, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, aimag, conjg, cmplx, max, min, real
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Real     
-     &           cabs1
-      cabs1( cdum ) = abs( real( cdum ) ) + abs( aimag( cdum ) )
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine clahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c 
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call claset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call cvout (logfil, 1, sigma, ndigit, 
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine clahqr    |
-c           %----------------------------------------%
-c
-            tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = clanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(real(h(i+1,i))) 
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call cvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c 
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call clartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t   
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t   
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t   
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c 
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( real( h(j+1,j) ) .lt. rzero .or.
-     &        aimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / slapy2(real(h(j+1,j)),aimag(h(j+1,j)))
-            call cscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call cscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call cscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = cmplx( real( h(j+1,j) ), rzero )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine clahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = clanhs( '1', kev, h, ldh, workl )
-         if( real( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call cgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call cgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call ccopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call clacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call ccopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call cscal (n, q(kplusp,kev), resid, 1)
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call caxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call cvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call cvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call cmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of cnapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cnaup2.f b/libcruft/arpack/src/cnaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaup2
-c
-c\Description: 
-c  Intermediate level interface called by cnaupd.
-c
-c\Usage:
-c  call cnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, 
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in cnaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in cnaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV 
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Complex  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to 
-c          the computed Ritz values.
-c          
-c  Q       Complex  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex  work array of length at least 
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in CNAUPD.
-c
-c  RWORK   Real    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.  
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex 
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK initial vector generation routine. 
-c     cnaitr  ARPACK Arnoldi factorization routine.
-c     cnapps  ARPACK application of implicit shifts routine.
-c     cneigh  ARPACK compute Ritz values and error bounds routine. 
-c     cngets  ARPACK reorder Ritz values and error bounds routine.
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     cswap   Level 1 BLAS that swaps two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real   
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex 
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), 
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np), 
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Real   
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      Real 
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) ,
-     &           rzero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv, 
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j    
-      Complex 
-     &           cmpnorm
-      Real 
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift, 
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgetv0, cnaitr, cneigh, cngets, cnapps,
-     &           csortc, cswap, cmout, cvout, ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex 
-     &           cdotc
-      Real   
-     &           scnrm2, slamch, slapy2
-      external   cdotc, scnrm2, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-         call arscnd (t0)
-c 
-         msglvl = mcaup2
-c 
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c 
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call cgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call cnaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine cnapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call cnaitr(ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call cneigh (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          | 
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from cneigh.             |
-c        %--------------------------------------------------%
-c
-         call ccopy(kplusp,ritz,1,workl(kplusp**2+1),1)
-         call ccopy(kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call cngets (ishift, which, nev, np, ritz, bounds)
-c 
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, slapy2( real (ritz(np+i)),
-     &                                  aimag(ritz(np+i)) ) ) 
-            if ( slapy2(real (bounds(np+i)),aimag(bounds(np+i))) 
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c 
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit, 
-     &                  '_naup2: NEV, NP, NCONV are')
-            call cvout (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call cvout (logfil, kplusp, bounds, ndigit, 
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c     
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call cvout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call cvout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to cneupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = cmplx(rnorm,rzero)
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call csortc(wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0 
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call csortc(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call csortc(which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call cvout (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call cvout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c     
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call cngets (ishift, which, nev, np, ritz, bounds)
-c
-         end if              
-c     
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit, 
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit, 
-     &              '_naup2: NEV and NP are')
-               call cvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call cvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c 
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call ccopy (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then 
-            call ivout (logfil, 1, np, ndigit, 
-     &                  '_naup2: The number of shifts to apply ')
-            call cvout (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 ) 
-     &          call cvout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call cnapps (n, nev, np, ritz, v, ldv, 
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to cnaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            cmpnorm = cdotc (n, resid, 1, workd, 1)
-            rnorm = sqrt(slapy2(real (cmpnorm),aimag(cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call cmout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c     
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c     
- 9000 continue
-c
-c     %---------------%
-c     | End of cnaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/cnaupd.f b/libcruft/arpack/src/cnaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/cnaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaupd
-c
-c\Description: 
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a 
-c  complex linear operator OP with respect to a semi-inner product defined 
-c  by a hermitian positive semi-definite real matrix B. B may be the identity 
-c  matrix.  NOTE: if both OP and B are real, then ssaupd or snaupd should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  cnaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M. 
-c           ===> shift-and-invert mode 
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c  
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call cnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to cnaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          cnaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first 
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in 
-c          the "shift-and-invert" mode, the vector M * X is already 
-c          available and does not need to be recomputed in forming OP*X.
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = slamch('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine slamch).
-c
-c  RESID   Complex  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Arnoldi vectors are generated, the algorithm generates 
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update 
-c          iteration. Most of the cost in generating each Arnoldi vector is 
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors. 
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of 
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to 
-c                      restarting the iteration from the beginning 
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the 
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced 
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.  
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of cnaupd for the 
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by cneupd. See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the 
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.  
-c
-c  WORKL   Complex  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Real   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration 
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues 
-c     of the original problem may be obtained with the ARPACK subroutine cneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz 
-c     values is needed, the user must call cneupd immediately following 
-c     completion of cnaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically. 
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note: 
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c  
-c  CM2/CM5 syntax:
-c  ==============
-c  
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex 
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     cnaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     cstatn  ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     cvout   ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Real   
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cnaup2, cvout, ivout, arscnd, cstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real  
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call cstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0E+0  )			tol = slamch('EpsMach')
-         if (ishift .ne. 0  .and.  
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c 
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine cneigh called   |
-c        | by cnaup2. Subroutine cneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call cnaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz), 
-     &     workl(bounds), workl(iq), ldq, workl(iw), 
-     &     ipntr, workd, rwork, info )
-c 
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within cnaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call cvout (logfil, np, workl(ritz), ndigit, 
-     &               '_naupd: The final Ritz values')
-         call cvout (logfil, np, workl(bounds), ndigit, 
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of cnaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cneigh.f b/libcruft/arpack/src/cneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/cneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: cneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call cneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Real  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end. 
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from clahqr or ctrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     ccopy   Level 1 BLAS that copies one vector to another. 
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cneigh (rnorm, n, h, ldh, ritz, bounds, 
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3)) 
-      Real 
-     &           rwork(n)
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex     
-     &           one, zero
-      Real
-     &           rone
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rone = 1.0E+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex     
-     &           vl(1)
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   clacpy, clahqr, ctrevc, ccopy, 
-     &           csscal, cmout, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2
-      external   scnrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c 
-      if (msglvl .gt. 2) then
-          call cmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    clahqr returns the full Schur form of H               | 
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call clacpy ('All', n, n, h, ldh, workl, n)
-      call claset ('All', n, n, zero, one, q, ldq)
-      call clahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call ccopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ctrevc ('Right', 'Back', select, n, workl, n, vl, n, q, 
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ctrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = scnrm2( n, q(1,j), 1 )
-            call csscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call ccopy(n, q(n,1), ldq, workl, 1)
-         call cvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call ccopy(n, q(n,1), n, bounds, 1)
-      call csscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cneupd.f b/libcruft/arpack/src/cneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/cneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c 
-c\Name: cneupd 
-c 
-c\Description: 
-c  This subroutine returns the converged approximations to eigenvalues 
-c  of A*z = lambda*B*z and (optionally): 
-c 
-c      (1) The corresponding approximate eigenvectors; 
-c 
-c      (2) An orthonormal basis for the associated approximate 
-c          invariant subspace; 
-c 
-c      (3) Both.  
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal 
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied). 
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to CNAUPD.  CNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such 
-c  in the comments that follow.   The computed orthonormal basis for the 
-c  invariant subspace corresponding to these Ritz values is referred to as a 
-c  Schur basis. 
-c 
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of CNAUPD.  For a brief 
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of CNAUPD.
-c
-c\Usage:
-c  call cneupd 
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, 
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized 
-c          but it is used as internal workspace.
-c
-c  D       Complex  array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations 
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex  N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required, 
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi 
-c          basis array V computed by CNAUPD.  In this case the Arnoldi basis 
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.  
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex   (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex  work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to CNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments 
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, 
-c           WORKD, WORKL, LWORKL, RWORK, INFO 
-c
-c         must be passed directly to CNEUPD following the last call 
-c         to CNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to CNAUPD and the call to CNEUPD.
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by CNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          cnaupd.  They are not changed by cneupd.
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of 
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by cneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ctrsen.
-c                Re-enter subroutine cneupd with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ctrevc.
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: CNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: CNEUPD got a different count of the number of converged
-c                 Ritz values than CNAUPD got.  This indicates the user
-c                 probably made an error in passing data from CNAUPD to
-c                 CNEUPD or that the data was modified before entering
-c                 CNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673. 
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     cgeqr2  LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ctrsen  LAPACK routine that re-orders the Schur form.
-c     cunm2r  LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     slamch  LAPACK routine that determines machine constants.
-c     ctrmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     cgeru   Level 2 BLAS rank one update to a matrix.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented. 
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the 
-c     upper triangular matrix stored workl(ipntr(12)). 
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas 
-c     Dept. of Computational & 
-c     Applied Mathematics 
-c     Rice University 
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine cneupd(rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex      
-     &           sigma
-      Real  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real 
-     &           rwork(ncv)
-      Complex 
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev), 
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex 
-     &           one, zero
-      parameter  (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex 
-     &           rnorm, temp, vl(1)
-      Real 
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy , cgeru, cgeqr2, clacpy, cmout,
-     &           cunm2r, ctrmm, cvout, ivout,
-     &           clahqr
-c  
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           scnrm2, slamch, slapy2
-      external   scnrm2, slamch, slapy2
-c
-      Complex 
-     &           cdotc
-      external   cdotc
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by CNEUPD.                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call cvout(logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call cvout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call cngets(ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call cvout (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call cvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 slapy2 ( real (workl(irz+ncv-j)),
-     &                          aimag(workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          slapy2( real (workl(ibd+jj-1)),
-     &          aimag(workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine clahqr to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by CNAUPD.   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call ccopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call claset('All', ncv, ncv          , 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call clahqr(.true., .true.       , ncv          , 
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call cvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call cmout (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ctrsen('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2       , conds        , sep         , 
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call cmout(logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c 
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call ccopy(nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call cgeqr2(ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using cunm2r.                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       | 
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call cunm2r('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call clacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( real ( workl(invsub+(j-1)*ldq+j-1) ) .lt. 
-     &                  real (zero) ) then
-               call cscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call cscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ctrevc('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ctrevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = scnrm2(ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = real (one) / rtemp
-                  call csscal ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c 
-                  workev(j) = cdotc(j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call ccopy(nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call cmout(logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c 
-            call ccopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ctrmm('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if 
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed CNAUPD into D.    |
-c        %--------------------------------------------------%
-c
-         call ccopy(nconv, workl(ritz), 1, d, 1)
-         call ccopy(nconv, workl(ritz), 1, workl(iheig), 1)
-         call ccopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c      
-      else
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec) 
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c    
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c  
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c    
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call cgeru (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of cneupd|
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cngets.f b/libcruft/arpack/src/cngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/cngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: cngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call cngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cvout,  csortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mcgets
-c 
-      call csortc (which, .true., kev+np, ritz, bounds)
-c     
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine cnapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call csortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c     
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call cvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call cvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of cngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/csortc.f b/libcruft/arpack/src/csortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/csortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: csortc
-c
-c\Description:
-c  Sorts the Complex array in X into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  Real  array Y. 
-c
-c\Usage:
-c  call csortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order 
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine csortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex     
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex     
-     &           temp
-      Real 
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           real, aimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (real(x(j)).gt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (real(x(j)).lt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (aimag(x(j)).gt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (aimag(x(j)).lt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of csortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/cstatn.f b/libcruft/arpack/src/cstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/cstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine cstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tcaupd = 0.0E+0
-      tcaup2 = 0.0E+0
-      tcaitr = 0.0E+0
-      tceigh = 0.0E+0
-      tcgets = 0.0E+0
-      tcapps = 0.0E+0
-      tcconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
- 
-      return
-c
-c     %---------------%
-c     | End of cstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/debug.h b/libcruft/arpack/src/debug.h
deleted file mode 100644
--- a/libcruft/arpack/src/debug.h
+++ /dev/null
@@ -1,16 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c     %---------------------------------%
-c     | See debug.doc for documentation |
-c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/libcruft/arpack/src/dgetv0.f b/libcruft/arpack/src/dgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/dgetv0.f
+++ /dev/null
@@ -1,419 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call dgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that dgetv0 is called.  
-c          It should be set to 1 on the initial call to dgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Double precision N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Double precision work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine for vector output.
-c     dlarnv  LAPACK routine for generating a random vector.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dlarnv, dvout, dcopy, dgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2
-      external   ddot, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call dlarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call dcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call dcopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = ddot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call dgemv ('T', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call dgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call dcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         rnorm = ddot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = dnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call dvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dlaqrb.f b/libcruft/arpack/src/dlaqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/dlaqrb.f
+++ /dev/null
@@ -1,521 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dlaqrb
-c
-c\Description:
-c  Compute the eigenvalues and the Schur decomposition of an upper 
-c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
-c  last component of the Schur vectors are computed.
-c
-c  This is mostly a modification of the LAPACK routine dlahqr.
-c  
-c\Usage:
-c  call dlaqrb
-c     ( WANTT, N, ILO, IHI, H, LDH, WR, WI,  Z, INFO )
-c
-c\Arguments
-c  WANTT   Logical variable.  (INPUT)
-c          = .TRUE. : the full Schur form T is required;
-c          = .FALSE.: only eigenvalues are required.
-c
-c  N       Integer.  (INPUT)
-c          The order of the matrix H.  N >= 0.
-c
-c  ILO     Integer.  (INPUT)
-c  IHI     Integer.  (INPUT)
-c          It is assumed that H is already upper quasi-triangular in
-c          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
-c          ILO = 1). SLAQRB works primarily with the Hessenberg
-c          submatrix in rows and columns ILO to IHI, but applies
-c          transformations to all of H if WANTT is .TRUE..
-c          1 <= ILO <= max(1,IHI); IHI <= N.
-c
-c  H       Double precision array, dimension (LDH,N).  (INPUT/OUTPUT)
-c          On entry, the upper Hessenberg matrix H.
-c          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
-c          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
-c          standard form. If WANTT is .FALSE., the contents of H are
-c          unspecified on exit.
-c
-c  LDH     Integer.  (INPUT)
-c          The leading dimension of the array H. LDH >= max(1,N).
-c
-c  WR      Double precision array, dimension (N).  (OUTPUT)
-c  WI      Double precision array, dimension (N).  (OUTPUT)
-c          The real and imaginary parts, respectively, of the computed
-c          eigenvalues ILO to IHI are stored in the corresponding
-c          elements of WR and WI. If two eigenvalues are computed as a
-c          complex conjugate pair, they are stored in consecutive
-c          elements of WR and WI, say the i-th and (i+1)th, with
-c          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
-c          eigenvalues are stored in the same order as on the diagonal
-c          of the Schur form returned in H, with WR(i) = H(i,i), and, if
-c          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
-c          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
-c
-c  Z       Double precision array, dimension (N).  (OUTPUT)
-c          On exit Z contains the last components of the Schur vectors.
-c
-c  INFO    Integer.  (OUPUT)
-c          = 0: successful exit
-c          > 0: SLAQRB failed to compute all the eigenvalues ILO to IHI
-c               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
-c               elements i+1:ihi of WR and WI contain those eigenvalues
-c               which have been successfully computed.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dlanv2  LAPACK routine that computes the Schur factorization of
-c             2 by 2 nonsymmetric matrix in standard form.
-c     dlarfg  LAPACK Householder reflection construction routine.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     drot    Level 1 BLAS that applies a rotation to a 2 by 2 matrix.
-
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine dlahqr so that only the
-c               last component of the Schur vectors are computed.
-c
-c\SCCS Information: @(#) 
-c FILE: laqrb.F   SID: 2.2   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dlaqrb ( wantt, n, ilo, ihi, h, ldh, wr, wi,
-     &                    z, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      logical    wantt
-      integer    ihi, ilo, info, ldh, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h( ldh, * ), wi( * ), wr( * ), z( * )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           zero, one, dat1, dat2
-      parameter (zero = 0.0D+0, one = 1.0D+0, dat1 = 7.5D-1, 
-     &           dat2 = -4.375D-1)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, i1, i2, itn, its, j, k, l, m, nh, nr
-      Double precision
-     &           cs, h00, h10, h11, h12, h21, h22, h33, h33s,
-     &           h43h34, h44, h44s, ovfl, s, smlnum, sn, sum,
-     &           t1, t2, t3, tst1, ulp, unfl, v1, v2, v3
-      Double precision
-     &           v( 3 ), work( 1 )
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch, dlanhs
-      external   dlamch, dlanhs
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dlabad, dlanv2, dlarfg, drot
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      info = 0
-c
-c     %--------------------------%
-c     | Quick return if possible |
-c     %--------------------------%
-c
-      if( n.eq.0 )
-     &   return
-      if( ilo.eq.ihi ) then
-         wr( ilo ) = h( ilo, ilo )
-         wi( ilo ) = zero
-         return
-      end if
-c 
-c     %---------------------------------------------%
-c     | Initialize the vector of last components of |
-c     | the Schur vectors for accumulation.         |
-c     %---------------------------------------------%
-c
-      do 5 j = 1, n-1
-         z(j) = zero
-  5   continue 
-      z(n) = one
-c 
-      nh = ihi - ilo + 1
-c
-c     %-------------------------------------------------------------%
-c     | Set machine-dependent constants for the stopping criterion. |
-c     | If norm(H) <= sqrt(OVFL), overflow should not occur.        |
-c     %-------------------------------------------------------------%
-c
-      unfl = dlamch( 'safe minimum' )
-      ovfl = one / unfl
-      call dlabad( unfl, ovfl )
-      ulp = dlamch( 'precision' )
-      smlnum = unfl*( nh / ulp )
-c
-c     %---------------------------------------------------------------%
-c     | I1 and I2 are the indices of the first row and last column    |
-c     | of H to which transformations must be applied. If eigenvalues |
-c     | only are computed, I1 and I2 are set inside the main loop.    |
-c     | Zero out H(J+2,J) = ZERO for J=1:N if WANTT = .TRUE.          |
-c     | else H(J+2,J) for J=ILO:IHI-ILO-1 if WANTT = .FALSE.          |
-c     %---------------------------------------------------------------%
-c
-      if( wantt ) then
-         i1 = 1
-         i2 = n
-         do 8 i=1,i2-2
-            h(i1+i+1,i) = zero
- 8       continue
-      else
-         do 9 i=1, ihi-ilo-1
-            h(ilo+i+1,ilo+i-1) = zero
- 9       continue
-      end if
-c 
-c     %---------------------------------------------------%
-c     | ITN is the total number of QR iterations allowed. |
-c     %---------------------------------------------------%
-c
-      itn = 30*nh
-c 
-c     ------------------------------------------------------------------
-c     The main loop begins here. I is the loop index and decreases from
-c     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
-c     with the active submatrix in rows and columns L to I.
-c     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
-c     H(L,L-1) is negligible so that the matrix splits.
-c     ------------------------------------------------------------------
-c 
-      i = ihi
-   10 continue
-      l = ilo
-      if( i.lt.ilo )
-     &   go to 150
- 
-c     %--------------------------------------------------------------%
-c     | Perform QR iterations on rows and columns ILO to I until a   |
-c     | submatrix of order 1 or 2 splits off at the bottom because a |
-c     | subdiagonal element has become negligible.                   |
-c     %--------------------------------------------------------------%
- 
-      do 130 its = 0, itn
-c
-c        %----------------------------------------------%
-c        | Look for a single small subdiagonal element. |
-c        %----------------------------------------------%
-c
-         do 20 k = i, l + 1, -1
-            tst1 = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
-            if( tst1.eq.zero )
-     &         tst1 = dlanhs( '1', i-l+1, h( l, l ), ldh, work )
-            if( abs( h( k, k-1 ) ).le.max( ulp*tst1, smlnum ) )
-     &         go to 30
-   20    continue
-   30    continue
-         l = k
-         if( l.gt.ilo ) then
-c
-c           %------------------------%
-c           | H(L,L-1) is negligible |
-c           %------------------------%
-c
-            h( l, l-1 ) = zero
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | Exit from loop if a submatrix of order 1 or 2 has split off |
-c        %-------------------------------------------------------------%
-c
-         if( l.ge.i-1 )
-     &      go to 140
-c
-c        %---------------------------------------------------------%
-c        | Now the active submatrix is in rows and columns L to I. |
-c        | If eigenvalues only are being computed, only the active |
-c        | submatrix need be transformed.                          |
-c        %---------------------------------------------------------%
-c
-         if( .not.wantt ) then
-            i1 = l
-            i2 = i
-         end if
-c 
-         if( its.eq.10 .or. its.eq.20 ) then
-c
-c           %-------------------%
-c           | Exceptional shift |
-c           %-------------------%
-c
-            s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
-            h44 = dat1*s
-            h33 = h44
-            h43h34 = dat2*s*s
-c
-         else
-c
-c           %-----------------------------------------%
-c           | Prepare to use Wilkinson's double shift |
-c           %-----------------------------------------%
-c
-            h44 = h( i, i )
-            h33 = h( i-1, i-1 )
-            h43h34 = h( i, i-1 )*h( i-1, i )
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Look for two consecutive small subdiagonal elements |
-c        %-----------------------------------------------------%
-c
-         do 40 m = i - 2, l, -1
-c
-c           %---------------------------------------------------------%
-c           | Determine the effect of starting the double-shift QR    |
-c           | iteration at row M, and see if this would make H(M,M-1) |
-c           | negligible.                                             |
-c           %---------------------------------------------------------%
-c
-            h11 = h( m, m )
-            h22 = h( m+1, m+1 )
-            h21 = h( m+1, m )
-            h12 = h( m, m+1 )
-            h44s = h44 - h11
-            h33s = h33 - h11
-            v1 = ( h33s*h44s-h43h34 ) / h21 + h12
-            v2 = h22 - h11 - h33s - h44s
-            v3 = h( m+2, m+1 )
-            s = abs( v1 ) + abs( v2 ) + abs( v3 )
-            v1 = v1 / s
-            v2 = v2 / s
-            v3 = v3 / s
-            v( 1 ) = v1
-            v( 2 ) = v2
-            v( 3 ) = v3
-            if( m.eq.l )
-     &         go to 50
-            h00 = h( m-1, m-1 )
-            h10 = h( m, m-1 )
-            tst1 = abs( v1 )*( abs( h00 )+abs( h11 )+abs( h22 ) )
-            if( abs( h10 )*( abs( v2 )+abs( v3 ) ).le.ulp*tst1 )
-     &         go to 50
-   40    continue
-   50    continue
-c
-c        %----------------------%
-c        | Double-shift QR step |
-c        %----------------------%
-c
-         do 120 k = m, i - 1
-c 
-c           ------------------------------------------------------------
-c           The first iteration of this loop determines a reflection G
-c           from the vector V and applies it from left and right to H,
-c           thus creating a nonzero bulge below the subdiagonal.
-c
-c           Each subsequent iteration determines a reflection G to
-c           restore the Hessenberg form in the (K-1)th column, and thus
-c           chases the bulge one step toward the bottom of the active
-c           submatrix. NR is the order of G.
-c           ------------------------------------------------------------
-c 
-            nr = min( 3, i-k+1 )
-            if( k.gt.m )
-     &         call dcopy( nr, h( k, k-1 ), 1, v, 1 )
-            call dlarfg( nr, v( 1 ), v( 2 ), 1, t1 )
-            if( k.gt.m ) then
-               h( k, k-1 ) = v( 1 )
-               h( k+1, k-1 ) = zero
-               if( k.lt.i-1 )
-     &            h( k+2, k-1 ) = zero
-            else if( m.gt.l ) then
-               h( k, k-1 ) = -h( k, k-1 )
-            end if
-            v2 = v( 2 )
-            t2 = t1*v2
-            if( nr.eq.3 ) then
-               v3 = v( 3 )
-               t3 = t1*v3
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 60 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-                  h( k+2, j ) = h( k+2, j ) - sum*t3
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 70 j = i1, min( k+3, i )
-                  sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-                  h( j, k+2 ) = h( j, k+2 ) - sum*t3
-   70          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 ) + v3*z( k+2 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-               z( k+2 ) = z( k+2 ) - sum*t3
- 
-            else if( nr.eq.2 ) then
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 90 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-   90          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 100 j = i1, i
-                  sum = h( j, k ) + v2*h( j, k+1 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-  100          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-            end if
-  120    continue
- 
-  130 continue
-c
-c     %-------------------------------------------------------%
-c     | Failure to converge in remaining number of iterations |
-c     %-------------------------------------------------------%
-c
-      info = i
-      return
- 
-  140 continue
- 
-      if( l.eq.i ) then
-c
-c        %------------------------------------------------------%
-c        | H(I,I-1) is negligible: one eigenvalue has converged |
-c        %------------------------------------------------------%
-c
-         wr( i ) = h( i, i )
-         wi( i ) = zero
-
-      else if( l.eq.i-1 ) then
-c
-c        %--------------------------------------------------------%
-c        | H(I-1,I-2) is negligible;                              |
-c        | a pair of eigenvalues have converged.                  |
-c        |                                                        |
-c        | Transform the 2-by-2 submatrix to standard Schur form, |
-c        | and compute and store the eigenvalues.                 |
-c        %--------------------------------------------------------%
-c
-         call dlanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),
-     &                h( i, i ), wr( i-1 ), wi( i-1 ), wr( i ), wi( i ),
-     &                cs, sn )
- 
-         if( wantt ) then
-c
-c           %-----------------------------------------------------%
-c           | Apply the transformation to the rest of H and to Z, |
-c           | as required.                                        |
-c           %-----------------------------------------------------%
-c
-            if( i2.gt.i )
-     &         call drot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,
-     &                    cs, sn )
-            call drot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
-            sum      = cs*z( i-1 ) + sn*z( i )
-            z( i )   = cs*z( i )   - sn*z( i-1 )
-            z( i-1 ) = sum
-         end if
-      end if
-c
-c     %---------------------------------------------------------%
-c     | Decrement number of remaining iterations, and return to |
-c     | start of the main loop with new value of I.             |
-c     %---------------------------------------------------------%
-c
-      itn = itn - its
-      i = l - 1
-      go to 10
- 
-  150 continue
-      return
-c
-c     %---------------%
-c     | End of dlaqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnaitr.f b/libcruft/arpack/src/dnaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See dnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c 
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl, 
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dlabad, 
-     &           dvout, dmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlanhs, dlamch
-      external   ddot, dnrm2, dlanhs, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine dlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determing whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             wnorm = ddot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit, 
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call dvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call daxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine dlahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = dlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) 
-     &              h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call dmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dnaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnapps.f b/libcruft/arpack/src/dnapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnapps.f
+++ /dev/null
@@ -1,647 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge chage sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dnapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only 
-c          updated on ouput when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Double precision array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to dnapps, the shifts must be sorted so that the 
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlamch  LAPACK routine that determines machine constants. 
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     dlarfg  LAPACK Householder reflection construction routine.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine dlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Double precision
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai, 
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlarfg, dlarf,
-     &           dlaset, dlabad, arscnd, dlartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch, dlanhs, dlapy2
-      external   dlamch, dlanhs, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine dlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call dvout (logfil, 1, sigmar, ndigit, 
-     &               '_napps: The real part of the shift ')
-            call dvout (logfil, 1, sigmai, ndigit, 
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine dlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = dlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call dvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero ) 
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c 
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Contruct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call dlartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t   
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t   
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp ) 
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t   
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c 
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = dlapy2 ( sigmar, sigmai ) 
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s 
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call dlarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call dlarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call dlarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call dlarf ('Right', kplusp, nr, u, 1, tau, 
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c 
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call dscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call dscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call dscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine dlahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = dlanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call dgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call dlacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call daxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call dvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call dmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c 
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dnapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnaup2.f b/libcruft/arpack/src/dnaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaup2.f
+++ /dev/null
@@ -1,835 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaup2
-c
-c\Description:
-c  Intermediate level interface called by dnaupd .
-c
-c\Usage:
-c  call dnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dnaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dnaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Double precision  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from dneigh .
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0   ARPACK initial vector generation routine.
-c     dnaitr   ARPACK Arnoldi factorization routine.
-c     dnapps   ARPACK application of implicit shifts routine.
-c     dnconv   ARPACK convergence of Ritz values routine.
-c     dneigh   ARPACK compute Ritz values and error bounds routine.
-c     dngets   ARPACK reorder Ritz values and error bounds routine.
-c     dsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dswap    Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Double precision
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Double precision
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dgetv0 , dnaitr , dnconv , dneigh ,
-     &           dngets , dnapps , dvout  , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot , dnrm2 , dlapy2 , dlamch
-      external   ddot , dnrm2 , dlapy2 , dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call dnaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine dnapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dnaitr  (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call dneigh  (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from dneigh .                       |
-c        %----------------------------------------------------%
-c
-         call dcopy (kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call dcopy (kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call dcopy (kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of dngets  are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy  (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call dnconv  (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call dvout  (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call dvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with dngets , we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in dngets     |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call dsortc  (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call dsortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call dsortc (wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call dsortc (which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call dvout  (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call dvout  (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call dvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call dvout  (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call dvout  (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call dvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse comminucation to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call dcopy  (np, workl,       1, ritzr, 1)
-             call dcopy  (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call dvout  (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call dvout  (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call dvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call dnapps  (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dnaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot  (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call dmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of dnaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/dnaupd.f b/libcruft/arpack/src/dnaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs
-c  of a linear operator "OP" with respect to a semi-inner product defined by
-c  a symmetric positive semi-definite real matrix B. B may be the identity
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric
-c  with respect to the real positive semi-definite symmetric matrix B,
-c  i.e. B*OP = (OP`)*B, then subroutine dsaupd  should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dnaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M
-c                 amu == 1/(lambda-sigma).
-c
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dnaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dnaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x.
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz
-c          values are kept together. (See remark 4 below)
-c
-c  V       Double precision  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL
-c                      array corresponding to RITZR and RITZI. See remark
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of dnaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dnaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by dneupd . See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine dneupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine dneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call dneupd  immediately following
-c     completion of dnaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs
-c     must be placed in consecutive locations. The real part of the
-c     eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Double precision  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Double precision   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     dnaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dnaup2 , dvout , ivout, arscnd, dstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine dneigh  called   |
-c        | by dnaup2 . Subroutine dneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dnaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr),
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dnaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call dvout  (logfil, np, workl(ritzr), ndigit,
-     &               '_naupd: Real part of the final Ritz values')
-         call dvout  (logfil, np, workl(ritzi), ndigit,
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call dvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dnaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dnaupe.f b/libcruft/arpack/src/dnaupe.f
deleted file mode 100644
diff --git a/libcruft/arpack/src/dnconv.f b/libcruft/arpack/src/dnconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/dnconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnconv
-c
-c\Description: 
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dnconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Double precision arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Double precision
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dlamch
-      external   dlapy2, dlamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, dlapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c 
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dnconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dneigh.f b/libcruft/arpack/src/dneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/dneigh.f
+++ /dev/null
@@ -1,314 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call dneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Double precision N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real 
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Double precision N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dlaqrb or dtrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dlaqrb  ARPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dtrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds, 
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision     
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Double precision     
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dlacpy, dlaqrb, dtrevc, dvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dnrm2
-      external   dlapy2, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c 
-      if (msglvl .gt. 2) then
-          call dmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | dlaqrb returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call dlacpy ('All', n, n, h, ldh, workl, n)
-      call dlaqrb (.true., n, 1, n, workl, n, ritzr, ritzi, bounds,
-     &             ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call dtrevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | dtrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            temp = dnrm2( n, q(1,i), 1 )
-            call dscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = dlapy2( dnrm2( n, q(1,i), 1 ), 
-     &                        dnrm2( n, q(1,i+1), 1 ) )
-               call dscal ( n, one / temp, q(1,i), 1 )
-               call dscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if         
-   10 continue
-c
-      call dgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * dlapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call dvout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dneupd.f b/libcruft/arpack/src/dneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dneupd.f
+++ /dev/null
@@ -1,1068 +0,0 @@
-c\BeginDoc
-c
-c\Name: dneupd 
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to DNAUPD .  DNAUPD  must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine DNAUPD  for 
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of 
-c  IPARAM(7), MODE and WHICH in the documentation of DNAUPD .
-c
-c\Usage:
-c  call dneupd  
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, 
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether a basis for the invariant subspace corresponding 
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below. 
-c 
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors; 
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains 
-c          the real part of the Ritz  approximations to the eigenvalues of 
-c          A*z = lambda*B*z. 
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by 
-c          DNAUPD . A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by DNAUPD  to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value 
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex 
-c                conjugate pairs.  If eigenvectors are requested, the 
-c                corresponding Ritz vectors will also come in conjugate 
-c                pairs and the real and imaginary parts of these are 
-c                represented in two consecutive columns of the array Z 
-c                (see below).
-c
-c  Z       Double precision  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem 
-c          A*z = lambda*B*z. 
-c 
-c          The complex Ritz vector associated with the Ritz value 
-c          with positive imaginary part is stored in two consecutive 
-c          columns.  The first column holds the real part of the Ritz 
-c          vector and the second column holds the imaginary part.  The 
-c          Ritz vector associated with the Ritz value with negative 
-c          imaginary part is simply the complex conjugate of the Ritz vector 
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by DNAUPD .  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Double precision  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DNAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DNEUPD  following the last call
-c         to DNAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DNAUPD  and the call to DNEUPD .
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Double precision  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by DNAUPD  .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          dnaupd .  They are not changed by dneupd .
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by dneupd .
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine dlahqr 
-c                could not be reordered by LAPACK routine dtrsen .
-c                Re-enter subroutine dneupd  with IPARAM(5)=NCV and 
-c                increase the size of the arrays DR and DI to have 
-c                dimension at least dimension NCV and allocate at least NCV 
-c                columns for Z. NOTE: Not necessary if Z and V share 
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine dlahqr .
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine dtrevc .
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: DNAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlahqr   LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlaset   LAPACK matrix initialization routine.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     dtrevc   LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     dtrsen   LAPACK routine that re-orders the Schur form.
-c     dtrmm    Level 3 BLAS matrix times an upper triangular matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately 
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the 
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; 
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by DNAUPD  for OP to those of A*z = lambda*B*z. 
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute 
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I), 
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I), 
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics          
-c     Rice University           
-c     Houston, Texas            
-c 
-c\SCCS Information: @(#) 
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dneupd (rvec , howmny, select, dr    , di,    
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision      
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision 
-     &           dr(nev+1)    , di(nev+1), resid(n)  , 
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n), 
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision 
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   , 
-     &           iheigr, iheigi, iconj , nconv   , 
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Double precision 
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy , 
-     &           dlahqr , dlaset , dmout  , dorm2r , 
-     &           dtrevc , dtrmm  , dtrsen , dscal  , 
-     &           dvout  , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dlapy2 , dnrm2 , dlamch , ddot 
-      external   dlapy2 , dnrm2 , dlamch , ddot 
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by DNEUPD .                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c     
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dngets (ishift       , which     , nev       , 
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 dlapy2 ( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine dlahqr  to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by DNAUPD .        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c     
-         call dcopy (ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call dlaset ('All', ncv, ncv, 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call dlahqr (.true., .true.       , ncv, 
-     &                1     , ncv          , workl(iuptri), 
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub), 
-     &                ldq   , ierr)
-         call dcopy (ncv         , workl(invsub+ncv-1), ldq, 
-     &               workl(ihbds), 1)
-c     
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c     
-         if (msglvl .gt. 1) then
-            call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call dmout (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if 
-c
-         if (reord) then
-c     
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. | 
-c           %-----------------------------------------------------%
-c     
-            call dtrsen ('None'       , 'V'          , 
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          , 
-     &                   workl(invsub), ldq          , 
-     &                   workl(iheigr), workl(iheigi), 
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) , 
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-
-            if (msglvl .gt. 2) then
-                call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call dmout (logfil       , ncv, ncv   , 
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c     
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call dcopy (ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then 
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-         end if
-c     
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c     
-         call dgeqr2 (ncv, nconv , workl(invsub), 
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using dorm2r .                     |   
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c     
-         call dorm2r ('Right', 'Notranspose', n            , 
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            , 
-     &                ldv   , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c     
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c     
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call dscal (nconv, -one, workl(iuptri+j-1), ldq)
-               call dscal (nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c     
- 20      continue
-c     
-         if (howmny .eq. 'A') then
-c     
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T | 
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c     
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call dtrevc ('Right', 'Select'     , select       , 
-     &                   ncv    , workl(iuptri), ldq          , 
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c     
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | dtrevc  returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c     
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c     
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c     
-                  temp = dnrm2 ( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call dscal ( ncv, one / temp, 
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c     
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = dlapy2 (dnrm2 (ncv, 
-     &                                   workl(invsub+(j-1)*ldq), 
-     &                                   1),
-     &                             dnrm2 (ncv, 
-     &                                   workl(invsub+j*ldq),
-     &                                   1))  
-                     call dscal (ncv, one/temp, 
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call dscal (ncv, one/temp, 
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call dgemv ('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = dlapy2 (workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call dcopy (ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call dmout (logfil, ncv, ncv, workl(invsub), ldq, 
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call dcopy (nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c     
-            call dgeqr2 (ncv, nconv , workl(invsub), 
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c     
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |   
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  | 
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c     
-            call dorm2r ('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c     
-            call dtrmm ('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c     
-         end if
-c     
-      else 
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed DNAUPD  into DR and DI |
-c        %------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritzr), 1, dr, 1)
-         call dcopy (nconv, workl(ritzi), 1, di, 1)
-         call dcopy (nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call dcopy (nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call dcopy (nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c 
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call dscal (ncv, rnorm, workl(ihbds), 1)     
-c     
-      else 
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec) 
-     &         call dscal (ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) ) 
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c     
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.| 
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp 
-     &                           + sigmar   
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai   
- 80         continue
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz valuess.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz valuess.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if (workl(iheigi+j-1) .eq. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = dlapy2 ( workl(iheigr+j-1), workl(iheigi+j-1) )
-               workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                       workl(iheigr+j-1) +
-     &                       workl(invsub+j*ldq+ncv-1) * 
-     &                       workl(iheigi+j-1) ) / temp / temp
-               workev(j+1) = ( workl(invsub+j*ldq+ncv-1) * 
-     &                         workl(iheigr+j-1) -
-     &                         workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                         workl(iheigi+j-1) ) / temp / temp
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call dger (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of DNEUPD  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dngets.f b/libcruft/arpack/src/dngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/dngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary 
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortc  ARPACK sorting routine.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np), 
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dsortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mngets
-c 
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call dsortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call dsortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c      
-      call dsortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c     
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c     
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine dnapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call dsortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c     
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call dvout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call dvout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call dvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of dngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/dsaitr.f b/libcruft/arpack/src/dsaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dsaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dsaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See dsaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some 
-c          computation at the first step. 
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dsaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, 
-     &           infol, jj
-      Double precision
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dvout, dmout,
-     &           dlascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = dlamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c 
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c 
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_saitr: generating Arnoldi vector no.')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determing whether a |
-c        | j-step Arnoldi factorization is present.                |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c 
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000
-   50    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call dcopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = ddot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then         
-            wnorm = ddot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call dgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero, 
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call dgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero, 
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call dgemv('N', n, j, -one, v, ldv, workd(irj), 1, one, 
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c 
-         orth1 = .true.
-         iter  = 0
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit, 
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c 
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then 
-               call dscal(n, -one, v(1,j+1), 1)
-            else
-               call dscal(n, -one, resid, 1)
-            end if
-         end if
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, k+np, h(1,2), ndigit, 
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call dvout (logfil, k+np-1, h(2,1), ndigit, 
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsapps.f b/libcruft/arpack/src/dsapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsapps.f
+++ /dev/null
@@ -1,516 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of 
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi 
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dsapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Double precision array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the 
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers. 
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it 
-c     comes from. This routine assumes that the subdiagonal elements 
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Double precision
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlartg, dlaset, dvout, 
-     &           ivout, arscnd, dgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = dlamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c 
-      kplusp = kev + np 
-c 
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c 
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c 
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_sapps: occured before shift number.')
-                  call dvout (logfil, 1, h(i+1,1), ndigit, 
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c 
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call dlartg (f, g, c, s, r)
-c 
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2) 
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c 
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c 
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call dlartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c 
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c 
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c 
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c 
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call dscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |                               
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit, 
-     &              '_sapps: deflation at row/column no.')
-               call dvout (logfil, 1, h(i+1,1), ndigit, 
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &   call dgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c 
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |    
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call dlacpy ('All', n, kev, v(1,np+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &     call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero) 
-     &   call daxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit, 
-     &      '_sapps: sigmak of the updated residual vector')
-         call dvout (logfil, 1, h(kev+1,1), ndigit, 
-     &      '_sapps: betak of the updated residual vector')
-         call dvout (logfil, kev, h(1,2), ndigit, 
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call dvout (logfil, kev-1, h(2,1), ndigit, 
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c 
- 9000 continue 
-      return
-c
-c     %---------------%
-c     | End of dsapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsaup2.f b/libcruft/arpack/src/dsaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaup2.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaup2
-c
-c\Description: 
-c  Intermediate level interface called by dsaupd.
-c
-c\Usage:
-c  call dsaup2 
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dsaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dsaupd.
-c  
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during 
-c          each Arnoldi/Lanczos iteration.  
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration 
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector 
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number 
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Double precision (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting 
-c          at H(2,1).  The main diagonal is stored in the arscnd column
-c          of H starting at H(1,2). If dsaup2 converges store the 
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Double precision array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Double precision (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the 
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c          
-c  WORKL   Double precision array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the 
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user 
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of  
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in dsaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.  
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP. 
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     dgetv0  ARPACK initial vector generation routine. 
-c     dsaitr  ARPACK Lanczos factorization routine.
-c     dsapps  ARPACK application of implicit shifts routine.
-c     dsconv  ARPACK convergence of Ritz values routine.
-c     dseigt  ARPACK compute Ritz values and error bounds routine.
-c     dsgets  ARPACK reorder Ritz values and error bounds routine.
-c     dsortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#) 
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n), 
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n), 
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0, 
-     &           np0, nptemp, nevd2, nevm2, kp(3) 
-      Double precision
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dgetv0, dsaitr, dscal, dsconv, dseigt, dsgets, 
-     &           dsapps, dsortr, dvout, ivout, arscnd, dswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0/3.0D+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c 
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call dsaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c 
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | dsaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c 
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dsaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v, 
-     &                ldv, h, ldh, ipntr, workd, info)
-c 
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | dsaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |  
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call dseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call dcopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call dcopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call dsgets (ishift, which, nev, np, ritz, bounds, workl)
-c 
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call dsconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call dvout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call dvout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c 
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2 
-               if ( nev .gt. 1 ) then
-                  call dswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call dswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call dsortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call dsortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call dsortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call dvout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call dsgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call dvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call dvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c 
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c 
-c 
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, dsgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call dvout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call dvout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After dsapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call dsapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dsaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            rnorm = ddot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call dvout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call dvout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c 
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c 
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaup2 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsaupd.f b/libcruft/arpack/src/dsaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaupd
-c
-c\Description:
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos
-c  method.  This method has been designed to compute approximations to a
-c  few eigenpairs of a linear operator OP that is real and symmetric
-c  with respect to a real positive semi-definite symmetric matrix B,
-c  i.e.
-c
-c       B*OP = (OP`)*B.
-c
-c  Another way to express this condition is
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c
-c  In the standard eigenproblem B is the identity matrix.
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dsaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M.
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dsaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dsaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dsaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues.
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Double precision  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Lanczos vectors are generated, the algorithm generates
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Double precision  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced
-c                      tridiagonal matrix T.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of Ritz vectors
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of dsaupd  for the
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dsaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by dseupd . See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine dseupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatable.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence,
-c     approximate eigenvalues of the original problem may be obtained
-c     with the ARPACK subroutine dseupd .
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call dseupd  immediately following completion
-c     of dsaupd . This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse commuication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) shifts in locations:
-c     1   WORKL(IPNTR(11))
-c     2   WORKL(IPNTR(11)+1)
-c                        .
-c                        .
-c                        .
-c     NP  WORKL(IPNTR(11)+NP-1).
-c
-c     The eigenvalues of the current tridiagonal matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     dsaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     dstats   ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dsaup2 ,  dvout , ivout, arscnd, dstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dsaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dsaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call dvout  (logfil, np, workl(Ritz), ndigit,
-     &               '_saupd: final Ritz values')
-         call dvout  (logfil, np, workl(Bounds), ndigit,
-     &               '_saupd: corresponding error bounds')
-      end if
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dsaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsconv.f b/libcruft/arpack/src/dsconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsconv
-c
-c\Description: 
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dsconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Double precision array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = dlamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c 
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of dsconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dseigt.f b/libcruft/arpack/src/dseigt.f
deleted file mode 100644
--- a/libcruft/arpack/src/dseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dseigt
-c
-c\Description: 
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call dseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Double precision N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the 
-c          subdiagonal in the first column starting at H(2,1) and the 
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  EIG     Double precision array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly 
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Double precision work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dseigt 
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           zero
-      parameter (zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dstqrb, dvout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------% 
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call dvout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call dcopy  (n, h(1,2), 1, eig, 1)
-      call dcopy  (n-1, h(2,1), 1, workl, 1)
-      call dstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c 
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dseigt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsesrt.f b/libcruft/arpack/src/dsesrt.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally 
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call dsesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Double precision array of length NA by N.  (INPUT/OUTPUT)
-c         
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     dswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and 
-c               the ARPACK code dsortr
-c
-c\SCCS Information: @(#) 
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsesrt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dseupd.f b/libcruft/arpack/src/dseupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/dseupd.f
+++ /dev/null
@@ -1,857 +0,0 @@
-c\BeginDoc
-c
-c\Name: dseupd 
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost 
-c  of n*nev if both are requested (in this case a separate array Z must be 
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by DSAUPD  for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in DSAUPD  documentation.)  DSAUPD  must be called before
-c  this routine is called. These approximate eigenvalues and vectors are 
-c  commonly called Ritz values and Ritz vectors respectively.  They are 
-c  referred to as such in the comments that follow.   The computed orthonormal 
-c  basis for the invariant subspace corresponding to these Ritz values is 
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine DSAUPD  for a definition 
-c  of OP as well as other terms and the relation of computed Ritz values 
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.  
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call dseupd  
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether Ritz vectors corresponding to the Ritz value 
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Double precision  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by dsaupd  transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If 
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same 
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Double precision  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the 
-c          Arnoldi/Lanczos basis array V computed by DSAUPD .
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Double precision   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DSAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DSEUPD  following the last call
-c         to DSAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DSAUPD  and the call to DSEUPD .
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          dsaupd .  They are not changed by dseupd .
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by dseupd .
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: DSAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: DSEUPD  got a different count of the number of converged
-c                 Ritz values than DSAUPD  got.  This indicates the user
-c                 probably made an error in passing data from DSAUPD  to
-c                 DSEUPD  or that the data was modified before entering 
-c                 DSEUPD .
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing 
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it. 
-c
-c\Routines called:
-c     dsesrt   ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     dsortr   dsortr   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     dsteqr   LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c     dswap    Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational & 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dseupd (rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision      
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Double precision 
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision 
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Double precision 
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy , dorm2r , dscal , 
-     &           dsesrt , dsteqr , dswap  , dvout  , ivout , dsortr 
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dnrm2 , dlamch 
-      external   dnrm2 , dlamch 
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14 
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) 
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else 
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c     
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       dsaupd  stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by dsaupd  and is not      |
-c     |       modified by dseupd .                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by dseupd .              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       dsteqr . Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by dsteqr  and by dseupd .      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine') 
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of dsaupd  WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = dnrm2 (n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dsgets (ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call dcopy (ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call dcopy (ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call dsteqr ('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call dcopy (ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call dvout (logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call dvout (logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call dcopy (ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call dcopy (ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call dcopy (ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-         end if
-c
- 30      if (msglvl .gt. 2) then
-             call dvout  (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritz), 1, d, 1)
-         call dcopy (ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else 
-c 
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by dsaupd .  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call dcopy  (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then 
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) / 
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c 
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-         call dsortr ('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-            call dscal (ncv, bnorm2/rnorm, workl(ihb), 1)
-            call dsortr ('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if 
-c 
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c    
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c     
-         call dgeqr2 (ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |   
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c     
-         call dorm2r ('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero 
-  65     continue
-         workl(ihb+ncv-1) = one
-         call dorm2r ('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by dsaupd .             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call dscal  (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) ) 
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if 
-c
-      if (type .ne. 'REGULR')
-     &   call dger  (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dseupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsgets.f b/libcruft/arpack/src/dsgets.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsgets
-c
-c\Description: 
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors 
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in 
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dsgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues 
-c          are in the first NP locations and the wanted part is in 
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Double precision array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order 
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap, dcopy, dsortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c 
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call dsortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2 
-         if ( kev .gt. 1 ) then
-            call dswap ( min(kevd2,np), ritz, 1, 
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call dswap ( min(kevd2,np), bounds, 1, 
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call dsortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine dsapps.                     |
-c        %-------------------------------------------------------%
-c     
-         call dsortr ('SM', .true., np, bounds, ritz)
-         call dcopy (np, ritz, 1, shifts, 1)
-      end if
-c 
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
-         call dvout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call dvout (logfil, kev+np, bounds, ndigit, 
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c 
-      return
-c
-c     %---------------%
-c     | End of dsgets |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsortc.f b/libcruft/arpack/src/dsortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call dsortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Double precision array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Double precision array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision     
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision     
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision     
-     &           dlapy2
-      external   dlapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dsortr.f b/libcruft/arpack/src/dsortr.f
deleted file mode 100644
--- a/libcruft/arpack/src/dsortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally 
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call dsortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Double precision array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dstatn.f b/libcruft/arpack/src/dstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\SCCS Information: @(#) 
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine dstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c 
-      tnaupd = 0.0D+0
-      tnaup2 = 0.0D+0
-      tnaitr = 0.0D+0
-      tneigh = 0.0D+0
-      tngets = 0.0D+0
-      tnapps = 0.0D+0
-      tnconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
-c 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
-c 
-      return
-c
-c
-c     %---------------%
-c     | End of dstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/dstats.f b/libcruft/arpack/src/dstats.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
- 
-      subroutine dstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tsaupd = 0.0D+0
-      tsaup2 = 0.0D+0
-      tsaitr = 0.0D+0
-      tseigt = 0.0D+0
-      tsgets = 0.0D+0
-      tsapps = 0.0D+0
-      tsconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
- 
-      return
-c
-c     End of dstats
-c
-      end
diff --git a/libcruft/arpack/src/dstqrb.f b/libcruft/arpack/src/dstqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/dstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine dsteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call dstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Double precision array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Double precision array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Double precision array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal 
-c          eigenvector matrix of the symmetric tridiagonal matrix.  
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Double precision array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for 
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     dlae2   LAPACK routine that computes the eigenvalues of a 2-by-2 
-c             symmetric matrix.
-c     dlaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric 
-c             matrix.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanst  LAPACK routine that computes the norm of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlaset  LAPACK matrix initialization routine.
-c     dlasr   LAPACK routine that applies an orthogonal transformation to 
-c             a matrix.
-c     dlasrt  LAPACK sorting routine.
-c     dsteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commeted out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Double precision               
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0D+0, one = 1.0D+0, 
-     &                     two = 2.0D+0, three = 3.0D+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Double precision               
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Double precision
-     &                   dlamch, dlanst, dlapy2
-      external           lsame, dlamch, dlanst, dlapy2
-c     ..
-c     .. external subroutines ..
-      external           dlae2, dlaev2, dlartg, dlascl, dlaset, dlasr,
-     &                   dlasrt, dswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = dlamch( 'e' )
-      eps2 = eps**2
-      safmin = dlamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call dlaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = dlanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call dlasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call dlae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call dlasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call dlasr( 'r', 'v', 'b', 1, mm, work( l ), 
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call dlasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               ************************************* 
-            else
-               call dlae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call dlasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call dlasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call dlasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call dswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of dstqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sgetv0.f b/libcruft/arpack/src/sgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/sgetv0.f
+++ /dev/null
@@ -1,419 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call sgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to sgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that sgetv0 is called.  
-c          It should be set to 1 on the initial call to sgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Real N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Real work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine for vector output.
-c     slarnv  LAPACK routine for generating a random vector.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   slarnv, svout, scopy, sgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2
-      external   sdot, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call slarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call scopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call scopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = sdot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = snrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call sgemv ('T', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call sgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call scopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         rnorm = sdot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = snrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call svout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/slaqrb.f b/libcruft/arpack/src/slaqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/slaqrb.f
+++ /dev/null
@@ -1,521 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: slaqrb
-c
-c\Description:
-c  Compute the eigenvalues and the Schur decomposition of an upper 
-c  Hessenberg submatrix in rows and columns ILO to IHI.  Only the
-c  last component of the Schur vectors are computed.
-c
-c  This is mostly a modification of the LAPACK routine slahqr.
-c  
-c\Usage:
-c  call slaqrb
-c     ( WANTT, N, ILO, IHI, H, LDH, WR, WI,  Z, INFO )
-c
-c\Arguments
-c  WANTT   Logical variable.  (INPUT)
-c          = .TRUE. : the full Schur form T is required;
-c          = .FALSE.: only eigenvalues are required.
-c
-c  N       Integer.  (INPUT)
-c          The order of the matrix H.  N >= 0.
-c
-c  ILO     Integer.  (INPUT)
-c  IHI     Integer.  (INPUT)
-c          It is assumed that H is already upper quasi-triangular in
-c          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
-c          ILO = 1). SLAQRB works primarily with the Hessenberg
-c          submatrix in rows and columns ILO to IHI, but applies
-c          transformations to all of H if WANTT is .TRUE..
-c          1 <= ILO <= max(1,IHI); IHI <= N.
-c
-c  H       Real array, dimension (LDH,N).  (INPUT/OUTPUT)
-c          On entry, the upper Hessenberg matrix H.
-c          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
-c          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
-c          standard form. If WANTT is .FALSE., the contents of H are
-c          unspecified on exit.
-c
-c  LDH     Integer.  (INPUT)
-c          The leading dimension of the array H. LDH >= max(1,N).
-c
-c  WR      Real array, dimension (N).  (OUTPUT)
-c  WI      Real array, dimension (N).  (OUTPUT)
-c          The real and imaginary parts, respectively, of the computed
-c          eigenvalues ILO to IHI are stored in the corresponding
-c          elements of WR and WI. If two eigenvalues are computed as a
-c          complex conjugate pair, they are stored in consecutive
-c          elements of WR and WI, say the i-th and (i+1)th, with
-c          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
-c          eigenvalues are stored in the same order as on the diagonal
-c          of the Schur form returned in H, with WR(i) = H(i,i), and, if
-c          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
-c          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
-c
-c  Z       Real array, dimension (N).  (OUTPUT)
-c          On exit Z contains the last components of the Schur vectors.
-c
-c  INFO    Integer.  (OUPUT)
-c          = 0: successful exit
-c          > 0: SLAQRB failed to compute all the eigenvalues ILO to IHI
-c               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
-c               elements i+1:ihi of WR and WI contain those eigenvalues
-c               which have been successfully computed.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     slabad  LAPACK routine that computes machine constants.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     slanv2  LAPACK routine that computes the Schur factorization of
-c             2 by 2 nonsymmetric matrix in standard form.
-c     slarfg  LAPACK Householder reflection construction routine.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     srot    Level 1 BLAS that applies a rotation to a 2 by 2 matrix.
-
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c               Modified from the LAPACK routine slahqr so that only the
-c               last component of the Schur vectors are computed.
-c
-c\SCCS Information: @(#) 
-c FILE: laqrb.F   SID: 2.2   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine slaqrb ( wantt, n, ilo, ihi, h, ldh, wr, wi,
-     &                    z, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      logical    wantt
-      integer    ihi, ilo, info, ldh, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h( ldh, * ), wi( * ), wr( * ), z( * )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           zero, one, dat1, dat2
-      parameter (zero = 0.0E+0, one = 1.0E+0, dat1 = 7.5E-1, 
-     &           dat2 = -4.375E-1)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, i1, i2, itn, its, j, k, l, m, nh, nr
-      Real
-     &           cs, h00, h10, h11, h12, h21, h22, h33, h33s,
-     &           h43h34, h44, h44s, ovfl, s, smlnum, sn, sum,
-     &           t1, t2, t3, tst1, ulp, unfl, v1, v2, v3
-      Real
-     &           v( 3 ), work( 1 )
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch, slanhs
-      external   slamch, slanhs
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, slabad, slanv2, slarfg, srot
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      info = 0
-c
-c     %--------------------------%
-c     | Quick return if possible |
-c     %--------------------------%
-c
-      if( n.eq.0 )
-     &   return
-      if( ilo.eq.ihi ) then
-         wr( ilo ) = h( ilo, ilo )
-         wi( ilo ) = zero
-         return
-      end if
-c 
-c     %---------------------------------------------%
-c     | Initialize the vector of last components of |
-c     | the Schur vectors for accumulation.         |
-c     %---------------------------------------------%
-c
-      do 5 j = 1, n-1
-         z(j) = zero
-  5   continue 
-      z(n) = one
-c 
-      nh = ihi - ilo + 1
-c
-c     %-------------------------------------------------------------%
-c     | Set machine-dependent constants for the stopping criterion. |
-c     | If norm(H) <= sqrt(OVFL), overflow should not occur.        |
-c     %-------------------------------------------------------------%
-c
-      unfl = slamch( 'safe minimum' )
-      ovfl = one / unfl
-      call slabad( unfl, ovfl )
-      ulp = slamch( 'precision' )
-      smlnum = unfl*( nh / ulp )
-c
-c     %---------------------------------------------------------------%
-c     | I1 and I2 are the indices of the first row and last column    |
-c     | of H to which transformations must be applied. If eigenvalues |
-c     | only are computed, I1 and I2 are set inside the main loop.    |
-c     | Zero out H(J+2,J) = ZERO for J=1:N if WANTT = .TRUE.          |
-c     | else H(J+2,J) for J=ILO:IHI-ILO-1 if WANTT = .FALSE.          |
-c     %---------------------------------------------------------------%
-c
-      if( wantt ) then
-         i1 = 1
-         i2 = n
-         do 8 i=1,i2-2
-            h(i1+i+1,i) = zero
- 8       continue
-      else
-         do 9 i=1, ihi-ilo-1
-            h(ilo+i+1,ilo+i-1) = zero
- 9       continue
-      end if
-c 
-c     %---------------------------------------------------%
-c     | ITN is the total number of QR iterations allowed. |
-c     %---------------------------------------------------%
-c
-      itn = 30*nh
-c 
-c     ------------------------------------------------------------------
-c     The main loop begins here. I is the loop index and decreases from
-c     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
-c     with the active submatrix in rows and columns L to I.
-c     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
-c     H(L,L-1) is negligible so that the matrix splits.
-c     ------------------------------------------------------------------
-c 
-      i = ihi
-   10 continue
-      l = ilo
-      if( i.lt.ilo )
-     &   go to 150
- 
-c     %--------------------------------------------------------------%
-c     | Perform QR iterations on rows and columns ILO to I until a   |
-c     | submatrix of order 1 or 2 splits off at the bottom because a |
-c     | subdiagonal element has become negligible.                   |
-c     %--------------------------------------------------------------%
- 
-      do 130 its = 0, itn
-c
-c        %----------------------------------------------%
-c        | Look for a single small subdiagonal element. |
-c        %----------------------------------------------%
-c
-         do 20 k = i, l + 1, -1
-            tst1 = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
-            if( tst1.eq.zero )
-     &         tst1 = slanhs( '1', i-l+1, h( l, l ), ldh, work )
-            if( abs( h( k, k-1 ) ).le.max( ulp*tst1, smlnum ) )
-     &         go to 30
-   20    continue
-   30    continue
-         l = k
-         if( l.gt.ilo ) then
-c
-c           %------------------------%
-c           | H(L,L-1) is negligible |
-c           %------------------------%
-c
-            h( l, l-1 ) = zero
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | Exit from loop if a submatrix of order 1 or 2 has split off |
-c        %-------------------------------------------------------------%
-c
-         if( l.ge.i-1 )
-     &      go to 140
-c
-c        %---------------------------------------------------------%
-c        | Now the active submatrix is in rows and columns L to I. |
-c        | If eigenvalues only are being computed, only the active |
-c        | submatrix need be transformed.                          |
-c        %---------------------------------------------------------%
-c
-         if( .not.wantt ) then
-            i1 = l
-            i2 = i
-         end if
-c 
-         if( its.eq.10 .or. its.eq.20 ) then
-c
-c           %-------------------%
-c           | Exceptional shift |
-c           %-------------------%
-c
-            s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
-            h44 = dat1*s
-            h33 = h44
-            h43h34 = dat2*s*s
-c
-         else
-c
-c           %-----------------------------------------%
-c           | Prepare to use Wilkinson's double shift |
-c           %-----------------------------------------%
-c
-            h44 = h( i, i )
-            h33 = h( i-1, i-1 )
-            h43h34 = h( i, i-1 )*h( i-1, i )
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Look for two consecutive small subdiagonal elements |
-c        %-----------------------------------------------------%
-c
-         do 40 m = i - 2, l, -1
-c
-c           %---------------------------------------------------------%
-c           | Determine the effect of starting the double-shift QR    |
-c           | iteration at row M, and see if this would make H(M,M-1) |
-c           | negligible.                                             |
-c           %---------------------------------------------------------%
-c
-            h11 = h( m, m )
-            h22 = h( m+1, m+1 )
-            h21 = h( m+1, m )
-            h12 = h( m, m+1 )
-            h44s = h44 - h11
-            h33s = h33 - h11
-            v1 = ( h33s*h44s-h43h34 ) / h21 + h12
-            v2 = h22 - h11 - h33s - h44s
-            v3 = h( m+2, m+1 )
-            s = abs( v1 ) + abs( v2 ) + abs( v3 )
-            v1 = v1 / s
-            v2 = v2 / s
-            v3 = v3 / s
-            v( 1 ) = v1
-            v( 2 ) = v2
-            v( 3 ) = v3
-            if( m.eq.l )
-     &         go to 50
-            h00 = h( m-1, m-1 )
-            h10 = h( m, m-1 )
-            tst1 = abs( v1 )*( abs( h00 )+abs( h11 )+abs( h22 ) )
-            if( abs( h10 )*( abs( v2 )+abs( v3 ) ).le.ulp*tst1 )
-     &         go to 50
-   40    continue
-   50    continue
-c
-c        %----------------------%
-c        | Double-shift QR step |
-c        %----------------------%
-c
-         do 120 k = m, i - 1
-c 
-c           ------------------------------------------------------------
-c           The first iteration of this loop determines a reflection G
-c           from the vector V and applies it from left and right to H,
-c           thus creating a nonzero bulge below the subdiagonal.
-c
-c           Each subsequent iteration determines a reflection G to
-c           restore the Hessenberg form in the (K-1)th column, and thus
-c           chases the bulge one step toward the bottom of the active
-c           submatrix. NR is the order of G.
-c           ------------------------------------------------------------
-c 
-            nr = min( 3, i-k+1 )
-            if( k.gt.m )
-     &         call scopy( nr, h( k, k-1 ), 1, v, 1 )
-            call slarfg( nr, v( 1 ), v( 2 ), 1, t1 )
-            if( k.gt.m ) then
-               h( k, k-1 ) = v( 1 )
-               h( k+1, k-1 ) = zero
-               if( k.lt.i-1 )
-     &            h( k+2, k-1 ) = zero
-            else if( m.gt.l ) then
-               h( k, k-1 ) = -h( k, k-1 )
-            end if
-            v2 = v( 2 )
-            t2 = t1*v2
-            if( nr.eq.3 ) then
-               v3 = v( 3 )
-               t3 = t1*v3
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 60 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-                  h( k+2, j ) = h( k+2, j ) - sum*t3
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 70 j = i1, min( k+3, i )
-                  sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-                  h( j, k+2 ) = h( j, k+2 ) - sum*t3
-   70          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 ) + v3*z( k+2 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-               z( k+2 ) = z( k+2 ) - sum*t3
- 
-            else if( nr.eq.2 ) then
-c
-c              %------------------------------------------------%
-c              | Apply G from the left to transform the rows of |
-c              | the matrix in columns K to I2.                 |
-c              %------------------------------------------------%
-c
-               do 90 j = k, i2
-                  sum = h( k, j ) + v2*h( k+1, j )
-                  h( k, j ) = h( k, j ) - sum*t1
-                  h( k+1, j ) = h( k+1, j ) - sum*t2
-   90          continue
-c
-c              %----------------------------------------------------%
-c              | Apply G from the right to transform the columns of |
-c              | the matrix in rows I1 to min(K+3,I).               |
-c              %----------------------------------------------------%
-c
-               do 100 j = i1, i
-                  sum = h( j, k ) + v2*h( j, k+1 )
-                  h( j, k ) = h( j, k ) - sum*t1
-                  h( j, k+1 ) = h( j, k+1 ) - sum*t2
-  100          continue
-c
-c              %----------------------------------%
-c              | Accumulate transformations for Z |
-c              %----------------------------------%
-c
-               sum      = z( k ) + v2*z( k+1 )
-               z( k )   = z( k ) - sum*t1
-               z( k+1 ) = z( k+1 ) - sum*t2
-            end if
-  120    continue
- 
-  130 continue
-c
-c     %-------------------------------------------------------%
-c     | Failure to converge in remaining number of iterations |
-c     %-------------------------------------------------------%
-c
-      info = i
-      return
- 
-  140 continue
- 
-      if( l.eq.i ) then
-c
-c        %------------------------------------------------------%
-c        | H(I,I-1) is negligible: one eigenvalue has converged |
-c        %------------------------------------------------------%
-c
-         wr( i ) = h( i, i )
-         wi( i ) = zero
-
-      else if( l.eq.i-1 ) then
-c
-c        %--------------------------------------------------------%
-c        | H(I-1,I-2) is negligible;                              |
-c        | a pair of eigenvalues have converged.                  |
-c        |                                                        |
-c        | Transform the 2-by-2 submatrix to standard Schur form, |
-c        | and compute and store the eigenvalues.                 |
-c        %--------------------------------------------------------%
-c
-         call slanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),
-     &                h( i, i ), wr( i-1 ), wi( i-1 ), wr( i ), wi( i ),
-     &                cs, sn )
- 
-         if( wantt ) then
-c
-c           %-----------------------------------------------------%
-c           | Apply the transformation to the rest of H and to Z, |
-c           | as required.                                        |
-c           %-----------------------------------------------------%
-c
-            if( i2.gt.i )
-     &         call srot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,
-     &                    cs, sn )
-            call srot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
-            sum      = cs*z( i-1 ) + sn*z( i )
-            z( i )   = cs*z( i )   - sn*z( i-1 )
-            z( i-1 ) = sum
-         end if
-      end if
-c
-c     %---------------------------------------------------------%
-c     | Decrement number of remaining iterations, and return to |
-c     | start of the main loop with new value of I.             |
-c     %---------------------------------------------------------%
-c
-      itn = itn - its
-      i = l - 1
-      go to 10
- 
-  150 continue
-      return
-c
-c     %---------------%
-c     | End of slaqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snaitr.f b/libcruft/arpack/src/snaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in snaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call snaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See snaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c 
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in snaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl, 
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, slabad, 
-     &           svout, smout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slanhs, slamch
-      external   sdot, snrm2, slanhs, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine slahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determing whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             wnorm = sdot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit, 
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call svout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call saxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine slahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = slanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) 
-     &              h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call smout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of snaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snapps.f b/libcruft/arpack/src/snapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/snapps.f
+++ /dev/null
@@ -1,647 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge chage sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call snapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only 
-c          updated on ouput when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Real array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to snapps, the shifts must be sorted so that the 
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants. 
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     slarfg  LAPACK Householder reflection construction routine.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine slahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Real
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai, 
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slarfg, slarf,
-     &           slaset, slabad, arscnd, slartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch, slanhs, slapy2
-      external   slamch, slanhs, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine slahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call svout (logfil, 1, sigmar, ndigit, 
-     &               '_napps: The real part of the shift ')
-            call svout (logfil, 1, sigmai, ndigit, 
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine slahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = slanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call svout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero ) 
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c 
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Contruct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call slartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t   
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t   
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp ) 
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t   
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c 
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = slapy2 ( sigmar, sigmai ) 
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s 
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call slarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call slarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call slarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call slarf ('Right', kplusp, nr, u, 1, tau, 
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c 
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call sscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call sscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call sscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine slahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = slanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call sgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call saxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call svout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call smout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c 
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of snapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snaup2.f b/libcruft/arpack/src/snaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaup2.f
+++ /dev/null
@@ -1,835 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaup2
-c
-c\Description:
-c  Intermediate level interface called by snaupd.
-c
-c\Usage:
-c  call snaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in snaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in snaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Real  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Real  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from sneigh.
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine.
-c     snaitr  ARPACK Arnoldi factorization routine.
-c     snapps  ARPACK application of implicit shifts routine.
-c     snconv  ARPACK convergence of Ritz values routine.
-c     sneigh  ARPACK compute Ritz values and error bounds routine.
-c     sngets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Real
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Real
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sgetv0, snaitr, snconv, sneigh,
-     &           sngets, snapps, svout , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slapy2, slamch
-      external   sdot, snrm2, slapy2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call snaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine snapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call snaitr (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call sneigh (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from sneigh.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call scopy(kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of sngets are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call snconv (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call svout (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call svout (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call svout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with sngets, we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in sngets    |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call ssortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call ssortc(wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call ssortc(wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call ssortc(which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call svout (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call svout (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call svout (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse comminucation to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call scopy (np, workl,       1, ritzr, 1)
-             call scopy (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call svout (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call svout (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call svout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call snapps (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to snaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call smout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of snaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/snaupd.f b/libcruft/arpack/src/snaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/snaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaupd
-c
-c\Description: 
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs 
-c  of a linear operator "OP" with respect to a semi-inner product defined by 
-c  a symmetric positive semi-definite real matrix B. B may be the identity 
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric 
-c  with respect to the real positive semi-definite symmetric matrix B, 
-c  i.e. B*OP = (OP`)*B, then subroutine ssaupd should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  snaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M. 
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then 
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M 
-c                 amu == 1/(lambda-sigma). 
-c  
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M. 
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then 
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call snaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to snaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          snaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts 
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Arnoldi vectors are generated, the algorithm generates 
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update 
-c          iteration. Most of the cost in generating each Arnoldi vector is 
-c          in the matrix-vector operation OP*x. 
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz 
-c          values are kept together. (See remark 4 below)
-c
-c  V       Real  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors. 
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL 
-c                      array corresponding to RITZR and RITZI. See remark 
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to 
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.  
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of snaupd for the 
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), snaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.        
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array 
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by sneupd. See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the 
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of 
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine sneupd uses this output.
-c          See Data Distribution Note below.  
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration 
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine sneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz 
-c     values is needed, the user must call sneupd immediately following 
-c     completion of snaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically. 
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the 
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations 
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs 
-c     must be placed in consecutive locations. The real part of the 
-c     eigenvalues of the current upper Hessenberg matrix are located in 
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part 
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note: 
-c
-c  Fortran-D syntax:
-c  ================
-c  Real  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Real   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c  
-c  CM2/CM5 syntax:
-c  ==============
-c  
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     snaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#) 
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real 
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Real 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   snaup2, svout, ivout, arscnd, sstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c 
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine sneigh called   |
-c        | by snaup2. Subroutine sneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw 
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call snaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr), 
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw), 
-     &     ipntr, workd, info )
-c 
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within snaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call svout (logfil, np, workl(ritzr), ndigit, 
-     &               '_naupd: Real part of the final Ritz values')
-         call svout (logfil, np, workl(ritzi), ndigit, 
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call svout (logfil, np, workl(bounds), ndigit, 
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of snaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/snaupe.f b/libcruft/arpack/src/snaupe.f
deleted file mode 100644
diff --git a/libcruft/arpack/src/snconv.f b/libcruft/arpack/src/snconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/snconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snconv
-c
-c\Description: 
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call snconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Real arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Real
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, slamch
-      external   slapy2, slamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, slapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c 
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of snconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sneigh.f b/libcruft/arpack/src/sneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/sneigh.f
+++ /dev/null
@@ -1,314 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call sneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Real N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real 
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Real N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from slaqrb or strevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     slaqrb  ARPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slacpy  LAPACK matrix copy routine.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds, 
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real     
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Real     
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, slacpy, slaqrb, strevc, svout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, snrm2
-      external   slapy2, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c 
-      if (msglvl .gt. 2) then
-          call smout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | slaqrb returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call slacpy ('All', n, n, h, ldh, workl, n)
-      call slaqrb (.true., n, 1, n, workl, n, ritzr, ritzi, bounds,
-     &             ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call strevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | strevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            temp = snrm2( n, q(1,i), 1 )
-            call sscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = slapy2( snrm2( n, q(1,i), 1 ), 
-     &                        snrm2( n, q(1,i+1), 1 ) )
-               call sscal ( n, one / temp, q(1,i), 1 )
-               call sscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if         
-   10 continue
-c
-      call sgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c    
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * slapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call svout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call svout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sneupd.f b/libcruft/arpack/src/sneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/sneupd.f
+++ /dev/null
@@ -1,1067 +0,0 @@
-c\BeginDoc
-c
-c\Name: sneupd
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to SNAUPD.  SNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine SNAUPD for 
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of 
-c  IPARAM(7), MODE and WHICH in the documentation of SNAUPD.
-c
-c\Usage:
-c  call sneupd 
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, 
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether a basis for the invariant subspace corresponding 
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below. 
-c 
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors; 
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Real  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains 
-c          the real part of the Ritz  approximations to the eigenvalues of 
-c          A*z = lambda*B*z. 
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by 
-c          SNAUPD. A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by SNAUPD to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Real  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value 
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex 
-c                conjugate pairs.  If eigenvectors are requested, the 
-c                corresponding Ritz vectors will also come in conjugate 
-c                pairs and the real and imaginary parts of these are 
-c                represented in two consecutive columns of the array Z 
-c                (see below).
-c
-c  Z       Real  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem 
-c          A*z = lambda*B*z. 
-c 
-c          The complex Ritz vector associated with the Ritz value 
-c          with positive imaginary part is stored in two consecutive 
-c          columns.  The first column holds the real part of the Ritz 
-c          vector and the second column holds the imaginary part.  The 
-c          Ritz vector associated with the Ritz value with negative 
-c          imaginary part is simply the complex conjugate of the Ritz vector 
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by SNAUPD.  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Real  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SNEUPD following the last call
-c         to SNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SNAUPD and the call to SNEUPD.
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Real  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by SNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          snaupd.  They are not changed by sneupd.
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by sneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine slahqr
-c                could not be reordered by LAPACK routine strsen.
-c                Re-enter subroutine sneupd with IPARAM(5)=NCV and 
-c                increase the size of the arrays DR and DI to have 
-c                dimension at least dimension NCV and allocate at least NCV 
-c                columns for Z. NOTE: Not necessary if Z and V share 
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine slahqr.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine strevc.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: SNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slahqr  LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slaset  LAPACK matrix initialization routine.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     strsen  LAPACK routine that re-orders the Schur form.
-c     strmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately 
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the 
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; 
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by SNAUPD for OP to those of A*z = lambda*B*z. 
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute 
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I), 
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I), 
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics          
-c     Rice University           
-c     Houston, Texas            
-c 
-c\SCCS Information: @(#) 
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sneupd(rvec , howmny, select, dr    , di,    
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real      
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real 
-     &           dr(nev+1)    , di(nev+1), resid(n)  , 
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n), 
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   , 
-     &           iheigr, iheigi, iconj , nconv   , 
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Real 
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy, 
-     &           slahqr, slaset, smout , sorm2r, 
-     &           strevc, strmm , strsen, sscal , 
-     &           svout , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slapy2, snrm2, slamch, sdot
-      external   slapy2, snrm2, slamch, sdot
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by SNEUPD.                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c     
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call sngets(ishift       , which     , nev       , 
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 slapy2( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine slahqr to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by SNAUPD.        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c     
-         call scopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call slaset('All', ncv, ncv, 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call slahqr(.true., .true.       , ncv, 
-     &                1     , ncv          , workl(iuptri), 
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub), 
-     &                ldq   , ierr)
-         call scopy(ncv         , workl(invsub+ncv-1), ldq, 
-     &               workl(ihbds), 1)
-c     
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c     
-         if (msglvl .gt. 1) then
-            call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call svout(logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call smout(logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if 
-c
-         if (reord) then
-c     
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. | 
-c           %-----------------------------------------------------%
-c     
-            call strsen('None'       , 'V'          , 
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          , 
-     &                   workl(invsub), ldq          , 
-     &                   workl(iheigr), workl(iheigi), 
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) , 
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call smout(logfil       , ncv, ncv   , 
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c     
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call scopy(ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then 
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-         end if
-c     
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c     
-         call sgeqr2(ncv, nconv , workl(invsub), 
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using sorm2r.                     |   
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c     
-         call sorm2r('Right', 'Notranspose', n            , 
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            , 
-     &                ldv   , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c     
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c     
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call sscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call sscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c     
- 20      continue
-c     
-         if (howmny .eq. 'A') then
-c     
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T | 
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c     
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call strevc('Right', 'Select'     , select       , 
-     &                   ncv    , workl(iuptri), ldq          , 
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c     
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | strevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c     
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c     
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c     
-                  temp = snrm2( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call sscal( ncv, one / temp, 
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c     
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = slapy2(snrm2(ncv, 
-     &                                   workl(invsub+(j-1)*ldq), 
-     &                                   1),
-     &                             snrm2(ncv, 
-     &                                   workl(invsub+j*ldq),
-     &                                   1))  
-                     call sscal(ncv, one/temp, 
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call sscal(ncv, one/temp, 
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call sgemv('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = slapy2(workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call scopy(ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call svout(logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call smout(logfil, ncv, ncv, workl(invsub), ldq, 
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call scopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c     
-            call sgeqr2(ncv, nconv , workl(invsub), 
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c     
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |   
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  | 
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c     
-            call sorm2r('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c     
-            call strmm('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c     
-         end if
-c     
-      else 
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed SNAUPD into DR and DI |
-c        %------------------------------------------------------%
-c
-         call scopy(nconv, workl(ritzr), 1, dr, 1)
-         call scopy(nconv, workl(ritzi), 1, di, 1)
-         call scopy(nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call scopy(nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call scopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c 
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call sscal(ncv, rnorm, workl(ihbds), 1)     
-c     
-      else 
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec) 
-     &         call sscal(ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) ) 
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c     
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.| 
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c     
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1), 
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp 
-     &                           + sigmar   
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai   
- 80         continue
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz valuess.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz valuess.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if (workl(iheigi+j-1) .eq. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = slapy2( workl(iheigr+j-1), workl(iheigi+j-1) )
-               workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                       workl(iheigr+j-1) +
-     &                       workl(invsub+j*ldq+ncv-1) * 
-     &                       workl(iheigi+j-1) ) / temp / temp
-               workev(j+1) = ( workl(invsub+j*ldq+ncv-1) * 
-     &                         workl(iheigr+j-1) -
-     &                         workl(invsub+(j-1)*ldq+ncv-1) * 
-     &                         workl(iheigi+j-1) ) / temp / temp
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call sger(n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of SNEUPD |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sngets.f b/libcruft/arpack/src/sngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/sngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call sngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary 
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortc  ARPACK sorting routine.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np), 
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, ssortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mngets
-c 
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call ssortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call ssortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c      
-      call ssortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c     
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c     
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine snapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call ssortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c     
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call svout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call svout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call svout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of sngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/ssaitr.f b/libcruft/arpack/src/ssaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in ssaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call ssaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See ssaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some 
-c          computation at the first step. 
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in ssaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl, 
-     &           infol, jj
-      Real
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments | 
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, svout, smout,
-     &           slascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = slamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c 
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c 
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_saitr: generating Arnoldi vector no.')
-            call svout (logfil, 1, rnorm, ndigit, 
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determing whether a |
-c        | j-step Arnoldi factorization is present.                |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1, 
-     &                    workd(ipj), n, infol)
-         end if
-c 
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000
-   50    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c 
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call scopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = sdot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then         
-            wnorm = sdot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call sgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero, 
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call sgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero, 
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call sgemv('N', n, j, -one, v, ldv, workd(irj), 1, one, 
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c 
-         orth1 = .true.
-         iter  = 0
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit, 
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c 
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then 
-               call sscal(n, -one, v(1,j+1), 1)
-            else
-               call sscal(n, -one, resid, 1)
-            end if
-         end if
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, k+np, h(1,2), ndigit, 
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call svout (logfil, k+np-1, h(2,1), ndigit, 
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssapps.f b/libcruft/arpack/src/ssapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssapps.f
+++ /dev/null
@@ -1,516 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of 
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi 
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call ssapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Real array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the 
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers. 
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slacpy  LAPACK matrix copy routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it 
-c     comes from. This routine assumes that the subdiagonal elements 
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Real
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slartg, slaset, svout, 
-     &           ivout, arscnd, sgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = slamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c 
-      kplusp = kev + np 
-c 
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c 
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c 
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_sapps: occured before shift number.')
-                  call svout (logfil, 1, h(i+1,1), ndigit, 
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c 
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call slartg (f, g, c, s, r)
-c 
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2) 
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c 
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c 
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call slartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c 
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c 
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c 
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c 
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call sscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |                               
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, i, ndigit, 
-     &              '_sapps: deflation at row/column no.')
-               call svout (logfil, 1, h(i+1,1), ndigit, 
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &   call sgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c 
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |    
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('All', n, kev, v(1,np+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero ) 
-     &     call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero) 
-     &   call saxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit, 
-     &      '_sapps: sigmak of the updated residual vector')
-         call svout (logfil, 1, h(kev+1,1), ndigit, 
-     &      '_sapps: betak of the updated residual vector')
-         call svout (logfil, kev, h(1,2), ndigit, 
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call svout (logfil, kev-1, h(2,1), ndigit, 
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c 
- 9000 continue 
-      return
-c
-c     %---------------%
-c     | End of ssapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssaup2.f b/libcruft/arpack/src/ssaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaup2.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaup2
-c
-c\Description: 
-c  Intermediate level interface called by ssaupd.
-c
-c\Usage:
-c  call ssaup2 
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in ssaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in ssaupd.
-c  
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during 
-c          each Arnoldi/Lanczos iteration.  
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration 
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector 
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number 
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Real (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting 
-c          at H(2,1).  The main diagonal is stored in the second column
-c          of H starting at H(1,2). If ssaup2 converges store the 
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  RITZ    Real array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Real array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Real (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the 
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c          
-c  WORKL   Real array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the 
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user 
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for 
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of  
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ssaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.  
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP. 
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine. 
-c     ssaitr  ARPACK Lanczos factorization routine.
-c     ssapps  ARPACK application of implicit shifts routine.
-c     ssconv  ARPACK convergence of Ritz values routine.
-c     sseigt  ARPACK compute Ritz values and error bounds routine.
-c     ssgets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors. 
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#) 
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd, 
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds, 
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n), 
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n), 
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0, 
-     &           np0, nptemp, nevd2, nevm2, kp(3) 
-      Real
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sgetv0, ssaitr, sscal, ssconv, sseigt, ssgets, 
-     &           ssapps, ssortr, svout, ivout, arscnd, sswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0/3.0E+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c 
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c 
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. | 
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c 
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c 
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call ssaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv, 
-     &             h, ldh, ipntr, workd, info)
-c 
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | ssaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c 
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c 
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit, 
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit, 
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, np, ndigit, 
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c 
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call ssaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v, 
-     &                ldv, h, ldh, ipntr, workd, info)
-c 
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | ssaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |  
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c 
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call sseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call ssgets (ishift, which, nev, np, ritz, bounds, workl)
-c 
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call ssconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call svout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c 
-         if ( (nconv .ge. nev0) .or. 
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c     
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2 
-               if ( nev .gt. 1 ) then
-                  call sswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call sswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | esitmates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call ssortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call ssortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call ssortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. | 
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. | 
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c     
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c     
-            if (nevbef .lt. nev) 
-     &         call ssgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call svout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c 
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c 
-c 
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, ssgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call svout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call svout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c 
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After ssapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call ssapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to ssaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c 
-  100    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         if (bmat .eq. 'G') then         
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, rnorm, ndigit, 
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call svout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call svout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c 
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c 
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c 
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaup2 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssaupd.f b/libcruft/arpack/src/ssaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaupd
-c
-c\Description: 
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi 
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos 
-c  method.  This method has been designed to compute approximations to a 
-c  few eigenpairs of a linear operator OP that is real and symmetric 
-c  with respect to a real positive semi-definite symmetric matrix B, 
-c  i.e.
-c                   
-c       B*OP = (OP`)*B.  
-c
-c  Another way to express this condition is 
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c  
-c  In the standard eigenproblem B is the identity matrix.  
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  ssaupd is usually called iteratively to solve one of the 
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric 
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M. 
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite, 
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call ssaupd 
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first 
-c          call to ssaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          ssaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c             
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues. 
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value 
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT: 
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector. 
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated 
-c          at each iteration.  After the startup phase in which NEV 
-c          Lanczos vectors are generated, the algorithm generates 
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the 
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Real  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced 
-c                      tridiagonal matrix T.  This is equivalent to 
-c                      restarting the iteration with a starting vector 
-c                      that is a linear combination of Ritz vectors 
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed. 
-c          On OUTPUT: actual number of Arnoldi update iterations taken. 
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used. 
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of ssaupd for the 
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), ssaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.        
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in 
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by sseupd. See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD 
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine sseupd uses this output.
-c          See Data Distribution Note below.  
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)  
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the 
-c                Implicitly restarted Arnoldi iteration. One possibility 
-c                is to increase the size of NCV relative to NEV. 
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatable.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending 
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence, 
-c     approximate eigenvalues of the original problem may be obtained 
-c     with the ARPACK subroutine sseupd. 
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call sseupd immediately following completion
-c     of ssaupd. This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular 
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requrement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will 
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse commuication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the 
-c     NP = IPARAM(8) shifts in locations: 
-c     1   WORKL(IPNTR(11))           
-c     2   WORKL(IPNTR(11)+1)         
-c                        .           
-c                        .           
-c                        .      
-c     NP  WORKL(IPNTR(11)+NP-1). 
-c
-c     The eigenvalues of the current tridiagonal matrix are located in 
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c  
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     ssaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     sstats  ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.4' 
-c
-c\SCCS Information: @(#) 
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2 
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real 
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Real 
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw, 
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ssaup2,  svout, ivout, arscnd, sstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c 
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c 
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c 
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev 
-c 
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c 
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call ssaup2 
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c 
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within ssaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call svout (logfil, np, workl(Ritz), ndigit, 
-     &               '_saupd: final Ritz values')
-         call svout (logfil, np, workl(Bounds), ndigit, 
-     &               '_saupd: corresponding error bounds')
-      end if 
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c 
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c 
- 9000 continue
-c 
-      return
-c
-c     %---------------%
-c     | End of ssaupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssconv.f b/libcruft/arpack/src/ssconv.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssconv
-c
-c\Description: 
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call ssconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Real array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = slamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c 
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of ssconv |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sseigt.f b/libcruft/arpack/src/sseigt.f
deleted file mode 100644
--- a/libcruft/arpack/src/sseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sseigt
-c
-c\Description: 
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call sseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Real N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the 
-c          subdiagonal in the first column starting at H(2,1) and the 
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  EIG     Real array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly 
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Real work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from sstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#) 
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sseigt 
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           zero
-      parameter (zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sstqrb, svout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------% 
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call svout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call scopy  (n, h(1,2), 1, eig, 1)
-      call scopy  (n-1, h(2,1), 1, workl, 1)
-      call sstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c 
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sseigt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssesrt.f b/libcruft/arpack/src/ssesrt.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally 
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call ssesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Real array of length NA by N.  (INPUT/OUTPUT)
-c         
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     sswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and 
-c               the ARPACK code ssortr
-c
-c\SCCS Information: @(#) 
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssesrt |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sseupd.f b/libcruft/arpack/src/sseupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/sseupd.f
+++ /dev/null
@@ -1,857 +0,0 @@
-c\BeginDoc
-c
-c\Name: sseupd
-c
-c\Description: 
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost 
-c  of n*nev if both are requested (in this case a separate array Z must be 
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by SSAUPD for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in SSAUPD documentation.)  SSAUPD must be called before
-c  this routine is called. These approximate eigenvalues and vectors are 
-c  commonly called Ritz values and Ritz vectors respectively.  They are 
-c  referred to as such in the comments that follow.   The computed orthonormal 
-c  basis for the invariant subspace corresponding to these Ritz values is 
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine SSAUPD for a definition 
-c  of OP as well as other terms and the relation of computed Ritz values 
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.  
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call sseupd 
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT) 
-c          Specifies whether Ritz vectors corresponding to the Ritz value 
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT) 
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Real  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by ssaupd transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If 
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same 
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Real  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the 
-c          Arnoldi/Lanczos basis array V computed by SSAUPD.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Real   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SSAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SSEUPD following the last call
-c         to SSAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SSAUPD and the call to SSEUPD.
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          ssaupd.  They are not changed by sseupd.
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by sseupd.
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: SSAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: SSEUPD got a different count of the number of converged
-c                 Ritz values than SSAUPD got.  This indicates the user
-c                 probably made an error in passing data from SSAUPD to
-c                 SSEUPD or that the data was modified before entering 
-c                 SSEUPD.
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos 
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems", 
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing 
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it. 
-c
-c\Routines called:
-c     ssesrt  ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     ssortr  ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational & 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c 
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sseupd(rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real      
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Real 
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real 
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Real 
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy, sorm2r, sscal, 
-     &           ssesrt, ssteqr, sswap , svout , ivout , ssortr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real 
-     &           snrm2, slamch
-      external   snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14 
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) 
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else 
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c     
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       ssaupd stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by ssaupd and is not      |
-c     |       modified by sseupd.                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by sseupd.              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       ssteqr. Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by ssteqr and by sseupd.      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine') 
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of ssaupd WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = snrm2(n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call ssgets(ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call scopy(ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call scopy(ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call ssteqr('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call scopy(ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call svout(logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call svout(logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call scopy(ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call scopy(ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call scopy(ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-         end if
-c
- 30      if (msglvl .gt. 2) then
-             call svout (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call scopy(nconv, workl(ritz), 1, d, 1)
-         call scopy(ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else 
-c 
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by ssaupd.  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call scopy (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then 
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) / 
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c 
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-         call ssortr('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-            call sscal(ncv, bnorm2/rnorm, workl(ihb), 1)
-            call ssortr('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if 
-c 
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c    
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c     
-         call sgeqr2(ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |   
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c     
-         call sorm2r('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero 
-  65     continue
-         workl(ihb+ncv-1) = one
-         call sorm2r('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by ssaupd.             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call sscal (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then 
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) ) 
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit, 
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c 
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iq+k*ldq+ncv-1)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if 
-c
-      if (type .ne. 'REGULR')
-     &   call sger (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of sseupd|
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssgets.f b/libcruft/arpack/src/ssgets.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssgets
-c
-c\Description: 
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors 
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in 
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call ssgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues 
-c          are in the first NP locations and the wanted part is in 
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Real array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order 
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#) 
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap, scopy, ssortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c 
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call ssortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2 
-         if ( kev .gt. 1 ) then
-            call sswap ( min(kevd2,np), ritz, 1, 
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call sswap ( min(kevd2,np), bounds, 1, 
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call ssortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine ssapps.                     |
-c        %-------------------------------------------------------%
-c     
-         call ssortr ('SM', .true., np, bounds, ritz)
-         call scopy (np, ritz, 1, shifts, 1)
-      end if
-c 
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_sgets: NP is')
-         call svout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call svout (logfil, kev+np, bounds, ndigit, 
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c 
-      return
-c
-c     %---------------%
-c     | End of ssgets |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssortc.f b/libcruft/arpack/src/ssortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call ssortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Real array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Real array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real     
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real     
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real     
-     &           slapy2
-      external   slapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/ssortr.f b/libcruft/arpack/src/ssortr.f
deleted file mode 100644
--- a/libcruft/arpack/src/ssortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally 
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call ssortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Real array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University 
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#) 
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c           
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sstatn.f b/libcruft/arpack/src/sstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas    
-c
-c\SCCS Information: @(#) 
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine sstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c 
-      tnaupd = 0.0E+0
-      tnaup2 = 0.0E+0
-      tnaitr = 0.0E+0
-      tneigh = 0.0E+0
-      tngets = 0.0E+0
-      tnapps = 0.0E+0
-      tnconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
-c 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
-c 
-      return
-c
-c
-c     %---------------%
-c     | End of sstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/sstats.f b/libcruft/arpack/src/sstats.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#) 
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
- 
-      subroutine sstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tsaupd = 0.0E+0
-      tsaup2 = 0.0E+0
-      tsaitr = 0.0E+0
-      tseigt = 0.0E+0
-      tsgets = 0.0E+0
-      tsapps = 0.0E+0
-      tsconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
- 
-      return
-c
-c     End of sstats
-c
-      end
diff --git a/libcruft/arpack/src/sstqrb.f b/libcruft/arpack/src/sstqrb.f
deleted file mode 100644
--- a/libcruft/arpack/src/sstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine ssteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call sstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Real array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Real array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Real array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal 
-c          eigenvector matrix of the symmetric tridiagonal matrix.  
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Real array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for 
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     slae2   LAPACK routine that computes the eigenvalues of a 2-by-2 
-c             symmetric matrix.
-c     slaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric 
-c             matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanst  LAPACK routine that computes the norm of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slaset  LAPACK matrix initialization routine.
-c     slasr   LAPACK routine that applies an orthogonal transformation to 
-c             a matrix.
-c     slasrt  LAPACK sorting routine.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#) 
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commeted out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs. 
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Real               
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0E+0, one = 1.0E+0, 
-     &                     two = 2.0E+0, three = 3.0E+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Real               
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Real
-     &                   slamch, slanst, slapy2
-      external           lsame, slamch, slanst, slapy2
-c     ..
-c     .. external subroutines ..
-      external           slae2, slaev2, slartg, slascl, slaset, slasr,
-     &                   slasrt, sswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = slamch( 'e' )
-      eps2 = eps**2
-      safmin = slamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call slaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = slanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call slasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call slasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call slasr( 'r', 'v', 'b', 1, mm, work( l ), 
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call slasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               ************************************* 
-            else
-               call slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call slasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call slasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************                             
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call slasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call sswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of sstqrb |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/stat.h b/libcruft/arpack/src/stat.h
deleted file mode 100644
--- a/libcruft/arpack/src/stat.h
+++ /dev/null
@@ -1,21 +0,0 @@
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-c\SCCS Information: @(#) 
-c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-      real       t0, t1, t2, t3, t4, t5
-      save       t0, t1, t2, t3, t4, t5
-c
-      integer    nopx, nbx, nrorth, nitref, nrstrt
-      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
-      common /timing/ 
-     &           nopx, nbx, nrorth, nitref, nrstrt,
-     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/libcruft/arpack/src/version.h b/libcruft/arpack/src/version.h
deleted file mode 100644
--- a/libcruft/arpack/src/version.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-
- In the current version, the parameter KAPPA in the Kahan's test
- for orthogonality is set to 0.717, the same as used by Gragg & Reichel.
- However computational experience indicates that this is a little too 
- strict and will frequently force reorthogonalization when it is not
- necessary to do so. 
-
- Also the "moving boundary" idea is not currently activated in the nonsymmetric
- code since it is not conclusive that it's the right thing to do all the time.  
- Requires further investigation.
-
- As of 02/01/93 Richard Lehoucq assumes software control of the codes from
- Phuong Vu. On 03/01/93 all the *.F files were migrated SCCS. The 1.1 version
- of codes are those received from Phuong Vu. The frozen version of 07/08/92
- is now considered version 1.1.
-
- Version 2.1 contains two new symmetric routines, sesrt and seupd. 
- Changes as well as bug fixes for version 1.1 codes that were only corrected 
- for programming bugs are version 1.2. These 1.2 versions will also be in version 2.1.
- Subroutine [d,s]saupd now requires slightly more workspace. See [d,s]saupd for the
- details. 
-
- \SCCS Information: @(#) 
-  FILE: version.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2
-
- */
-
-#define VERSION_NUMBER ' 2.1'
-#define VERSION_DATE   ' 11/15/95'
diff --git a/libcruft/arpack/src/zgetv0.f b/libcruft/arpack/src/zgetv0.f
deleted file mode 100644
--- a/libcruft/arpack/src/zgetv0.f
+++ /dev/null
@@ -1,414 +0,0 @@
-c\BeginDoc
-c
-c\Name: zgetv0
-c
-c\Description: 
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.  
-c
-c\Usage:
-c  call zgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM, 
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to zgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that zgetv0 is called.  
-c          It should be set to 1 on the initial call to zgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex*16 N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is 
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex*16 work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlarnv  LAPACK routine for generating a random vector. 
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector. 
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas            
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zgetv0 
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm, 
-     &     ipntr, workd, ierr )
-c 
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &            rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      Complex*16
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy, zgemv, zlarnv, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2, dlapy2
-      Complex*16
-     &           zdotc
-      external   zdotc, dznrm2, dlapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c 
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call zlarnv (idist, iseed, n, resid)
-         end if
-c 
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call zcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         end if
-      end if
-c 
-c     %----------------------------------------%
-c     | Back from computing B*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing B*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c 
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c 
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call zcopy (n, workd(n+1), 1, resid, 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = zdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(dlapy2(dble(cnorm),dimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dznrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c 
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call zgemv ('C', n, j-1, one, v, ldv, workd, 1, 
-     &            zero, workd(n+1), 1)
-      call zgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1, 
-     &            one, resid, 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call zcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c 
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c 
-      if (bmat .eq. 'G') then
-         cnorm = zdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(dlapy2(dble(cnorm),dimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = dznrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, rnorm0, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, rnorm, ndigit, 
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c 
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c 
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, rnorm, ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c 
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zgetv0 |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znaitr.f b/libcruft/arpack/src/znaitr.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaitr
-c
-c\Description: 
-c  Reverse communication interface for applying NP additional steps to 
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in znaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call znaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH, 
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See znaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.          
-c          Only work for NB = 1 right now.  The goal is to have a 
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex*16 N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K 
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling 
-c          program.
-c
-c  H       Complex*16 (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling 
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for 
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the 
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c          
-c  WORKD   Complex*16 work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not 
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some 
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlascl  LAPACK routine for careful scaling of a matrix.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another .
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors. 
-c     zscal   Level 1 BLAS that scales a vector.
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number. 
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas 
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c 
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c  
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k}; 
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already 
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];  
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in znaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};   
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf 
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh, 
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rone, rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0), 
-     &           rone = 1.0D+0, rzero = 0.0D+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Double precision
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision            
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex*16
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zscal, zdscal, zgemv, zgetv0, 
-     &           dlabad, zvout, zmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zdotc 
-      Double precision            
-     &           dlamch,  dznrm2, zlanhs, dlapy2
-      external   zdotc, dznrm2, zlanhs, dlamch, dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  dimag, dble, max, sqrt 
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine zlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c 
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c 
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c 
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         zgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
- 
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, j, ndigit, 
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, rnorm, ndigit, 
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c 
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, j, ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c 
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c 
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call zgetv0 (ido, bmat, itry, .false., n, j, v, ldv, 
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c 
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call zcopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call zdscal (n, temp1, v(1,j), 1)
-             call zdscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine zlascl               |
-c            %-----------------------------------------%
-c
-             call zlascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call zlascl ('General', i, i, rnorm, rone,  
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call zcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c 
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c 
-         go to 9000 
-   50    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
- 
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call zcopy (n, workd(irj), 1, resid, 1)
-c 
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c 
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then  
-             cnorm = zdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = dznrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c 
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. | 
-c        %--------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = dcmplx(betaj, rzero)
-c
-         call arscnd (t4)
-c 
-         orth1 = .true.
-c 
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   70    continue
-c 
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c 
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then         
-            cnorm = zdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2(n, resid, 1)
-         end if
-c 
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c 
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c 
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call dvout (logfil, 2, rtemp, ndigit, 
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call zvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1, 
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, workd(irj), 1, 
-     &               one, resid, 1)
-         call zaxpy (j, one, workd(irj), 1, h(1,j), 1)
-c 
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c 
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c 
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if 
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if 
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c 
-         if (bmat .eq. 'G') then         
-             cnorm  = zdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( dlapy2(dble(cnorm),dimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = dznrm2(n, resid, 1)
-         end if
-c 
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, j, ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call dvout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c 
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue 
-            rnorm = rzero
-         end if
-c 
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c 
-  100    continue
-c 
-         rstart = .false.
-         orth2  = .false.
-c 
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c 
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c     
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine zlahqr        |
-c              %--------------------------------------------%
-c     
-               tst1 = dlapy2(dble(h(i,i)),dimag(h(i,i)))
-     &              + dlapy2(dble(h(i+1,i+1)), dimag(h(i+1,i+1)))
-               if( tst1.eq.dble(zero) )
-     &              tst1 = zlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( dlapy2(dble(h(i+1,i)),dimag(h(i+1,i))) .le. 
-     &                    max( ulp*tst1, smlnum ) ) 
-     &             h(i+1,i) = zero
- 110        continue
-c     
-            if (msglvl .gt. 2) then
-               call zmout (logfil, k+np, k+np, h, ldh, ndigit, 
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c     
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c 
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of znaitr |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znapps.f b/libcruft/arpack/src/znapps.f
deleted file mode 100644
--- a/libcruft/arpack/src/znapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: znapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call znapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, 
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW. 
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex*16 array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex*16 N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16 (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper 
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k} 
-c          in the first KEV locations.
-c
-c  Q       Complex*16 KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex*16 work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlartg  LAPACK Givens rotation construction routine.
-c     zlaset  LAPACK matrix initialization routine.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine zlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, 
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           h(ldh,kev+np), resid(n), shift(np), 
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex*16
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Double precision             
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl 
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zgemv, zscal, zlacpy, zlartg, 
-     &           zvout, zlaset, dlabad, zmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision                 
-     &           zlanhs, dlamch, dlapy2
-      external   zlanhs, dlamch, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, dimag, conjg, dcmplx, max, min, dble
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Double precision     
-     &           zabs1
-      zabs1( cdum ) = abs( dble( cdum ) ) + abs( dimag( cdum ) )
-c
-c     %----------------%
-c     | Data statments |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine zlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c 
-      kplusp = kev + np 
-c 
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call zlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, jj, ndigit, 
-     &               '_napps: shift number.')
-            call zvout (logfil, 1, sigma, ndigit, 
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine zlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = zlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(dble(h(i+1,i))) 
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, i, ndigit, 
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, jj, ndigit, 
-     &                 '_napps: matrix splitting with shift number.')
-                  call zvout (logfil, 1, h(i+1,i), ndigit, 
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, istart, ndigit, 
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, iend, ndigit, 
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c 
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call zlartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t   
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t   
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t   
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c 
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( dble( h(j+1,j) ) .lt. rzero .or.
-     &        dimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / dlapy2(dble(h(j+1,j)),dimag(h(j+1,j)))
-            call zscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call zscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call zscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = dcmplx( dble( h(j+1,j) ), rzero )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine zlahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = zlanhs( '1', kev, h, ldh, workl )
-         if( dble( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) ) 
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero, 
-     &                workd(n+1), 1)
-c 
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call zgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call zcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call zlacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c 
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c 
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call zscal (n, q(kplusp,kev), resid, 1)
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zaxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call zvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call zvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, kev, ndigit, 
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call zmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c 
-      return
-c
-c     %---------------%
-c     | End of znapps |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/znaup2.f b/libcruft/arpack/src/znaup2.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaup2
-c
-c\Description:
-c  Intermediate level interface called by znaupd .
-c
-c\Usage:
-c  call znaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in znaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in znaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse comunication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex*16  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex*16  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Complex*16  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ZNAUPD .
-c
-c  RWORK   Double precision    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0   ARPACK initial vector generation routine.
-c     znaitr   ARPACK Arnoldi factorization routine.
-c     znapps   ARPACK application of implicit shifts routine.
-c     zneigh   ARPACK compute Ritz values and error bounds routine.
-c     zngets   ARPACK reorder Ritz values and error bounds routine.
-c     zsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout    ARPACK utility routine that prints matrices
-c     zvout    ARPACK utility routine that prints vectors.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zcopy    Level 1 BLAS that copies one vector to another .
-c     zdotc    Level 1 BLAS that computes the scalar product of two vectors.
-c     zswap    Level 1 BLAS that swaps two vectors.
-c     dznrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex*16
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np),
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Double precision
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) ,
-     &           rzero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j
-      Complex*16
-     &           cmpnorm
-      Double precision
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift,
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy , zgetv0 , znaitr , zneigh , zngets , znapps ,
-     &           zsortc , zswap , zmout , zvout , ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zdotc
-      Double precision
-     &           dznrm2 , dlamch , dlapy2
-      external   zdotc , dznrm2 , dlamch , dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  dimag , dble , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mcaup2
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call zgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call znaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, iter, ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine znapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, nev, ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, np, ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call znaitr (ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call zneigh  (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from zneigh .             |
-c        %--------------------------------------------------%
-c
-         call zcopy (kplusp,ritz,1,workl(kplusp**2+1),1)
-         call zcopy (kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, dlapy2 ( dble (ritz(np+i)),
-     &                                  dimag (ritz(np+i)) ) )
-            if ( dlapy2 (dble (bounds(np+i)),dimag (bounds(np+i)))
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_naup2: NEV, NP, NCONV are')
-            call zvout  (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call zvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call zvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call zvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to zneupd  if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = dcmplx (rnorm,rzero)
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call zsortc (wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       dimag (ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call zsortc (wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       dimag (ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call zsortc (which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call zvout  (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call zvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, nconv, ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call zvout  (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call zvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call zcopy  (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, np, ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call zvout  (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 )
-     &          call zvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call znapps  (n, nev, np, ritz, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to znaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            cmpnorm = zdotc  (n, resid, 1, workd, 1)
-            rnorm = sqrt(dlapy2 (dble (cmpnorm),dimag (cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, rnorm, ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call zmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of znaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/libcruft/arpack/src/znaupd.f b/libcruft/arpack/src/znaupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/znaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a
-c  complex linear operator OP with respect to a semi-inner product defined
-c  by a hermitian positive semi-definite real matrix B. B may be the identity
-c  matrix.  NOTE: if both OP and B are real, then dsaupd  or dnaupd  should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  znaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M.
-c           ===> shift-and-invert mode
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call znaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to znaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          znaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in
-c          the "shift-and-invert" mode, the vector M * X is already
-c          available and does not need to be recomputed in forming OP*X.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = dlamch ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine dlamch ).
-c
-c  RESID   Complex*16  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex*16  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration from the beginning
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of znaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by zneupd . See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd  if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.
-c
-c  WORKL   Complex*16  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Double precision   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues
-c     of the original problem may be obtained with the ARPACK subroutine zneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call zneupd  immediately following
-c     completion of znaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex*16  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex*16  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     znaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     zstatn   ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     zvout    ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex*16
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Double precision
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   znaup2 , zvout , ivout, arscnd, zstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call zstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0D+0  )			tol = dlamch ('EpsMach')
-         if (ishift .ne. 0  .and.
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine zneigh  called   |
-c        | by znaup2 . Subroutine zneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call znaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, rwork, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within znaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, mxiter, ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, np, ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call zvout  (logfil, np, workl(ritz), ndigit,
-     &               '_naupd: The final Ritz values')
-         call zvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of znaupd  |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zneigh.f b/libcruft/arpack/src/zneigh.f
deleted file mode 100644
--- a/libcruft/arpack/src/zneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: zneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call zneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg 
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex*16 N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16 array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex*16 array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM 
-c          times the last components of the eigenvectors corresponding 
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex*16 N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Double precision  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end. 
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from zlahqr or ztrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     dvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     zlaset  LAPACK matrix initialization routine.
-c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     zcopy   Level 1 BLAS that copies one vector to another. 
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c     
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zneigh (rnorm, n, h, ldh, ritz, bounds, 
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision     
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16     
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3)) 
-      Double precision 
-     &           rwork(n)
-c 
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16     
-     &           one, zero
-      Double precision
-     &           rone
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rone = 1.0D+0)
-c 
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex*16     
-     &           vl(1)
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zlacpy, zlahqr, ztrevc, zcopy, 
-     &           zdscal, zmout, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2
-      external   dznrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c 
-      if (msglvl .gt. 2) then
-          call zmout (logfil, n, n, h, ldh, ndigit, 
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c 
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    zlahqr returns the full Schur form of H               | 
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call zlacpy ('All', n, n, h, ldh, workl, n)
-      call zlaset ('All', n, n, zero, one, q, ldq)
-      call zlahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call zcopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ztrevc ('Right', 'Back', select, n, workl, n, vl, n, q, 
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ztrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = dznrm2( n, q(1,j), 1 )
-            call zdscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call zcopy(n, q(n,1), ldq, workl, 1)
-         call zvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call zcopy(n, q(n,1), n, bounds, 1)
-      call zdscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zneigh |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zneupd.f b/libcruft/arpack/src/zneupd.f
deleted file mode 100644
--- a/libcruft/arpack/src/zneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c 
-c\Name: zneupd  
-c 
-c\Description: 
-c  This subroutine returns the converged approximations to eigenvalues 
-c  of A*z = lambda*B*z and (optionally): 
-c 
-c      (1) The corresponding approximate eigenvectors; 
-c 
-c      (2) An orthonormal basis for the associated approximate 
-c          invariant subspace; 
-c 
-c      (3) Both.  
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal 
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied). 
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to ZNAUPD .  ZNAUPD  must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such 
-c  in the comments that follow.   The computed orthonormal basis for the 
-c  invariant subspace corresponding to these Ritz values is referred to as a 
-c  Schur basis. 
-c 
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of ZNAUPD .  For a brief 
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of ZNAUPD .
-c
-c\Usage:
-c  call zneupd  
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT, 
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, 
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem 
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace 
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE.. 
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized 
-c          but it is used as internal workspace.
-c
-c  D       Complex*16  array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations 
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex*16  N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of 
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding 
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required, 
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi 
-c          basis array V computed by ZNAUPD .  In this case the Arnoldi basis 
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.  
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex*16   (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift. 
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex*16  work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to ZNAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments 
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, 
-c           WORKD, WORKL, LWORKL, RWORK, INFO 
-c
-c         must be passed directly to ZNEUPD  following the last call 
-c         to ZNAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to ZNAUPD  and the call to ZNEUPD .
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex*16  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by ZNAUPD  .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          znaupd .  They are not changed by zneupd .
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of 
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by zneupd .
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ztrsen .
-c                Re-enter subroutine zneupd  with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ztrevc .
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: ZNAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: ZNEUPD  got a different count of the number of converged
-c                 Ritz values than ZNAUPD  got.  This indicates the user
-c                 probably made an error in passing data from ZNAUPD  to
-c                 ZNEUPD  or that the data was modified before entering
-c                 ZNEUPD 
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly 
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673. 
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     zmout    ARPACK utility routine that prints matrices
-c     zvout    ARPACK utility routine that prints vectors.
-c     zgeqr2   LAPACK routine that computes the QR factorization of 
-c             a matrix.
-c     zlacpy   LAPACK matrix copy routine.
-c     zlahqr   LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     zlaset   LAPACK matrix initialization routine.
-c     ztrevc   LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ztrsen   LAPACK routine that re-orders the Schur form.
-c     zunm2r   LAPACK routine that applies an orthogonal matrix in 
-c             factored form.
-c     dlamch   LAPACK routine that determines machine constants.
-c     ztrmm    Level 3 BLAS matrix times an upper triangular matrix.
-c     zgeru    Level 2 BLAS rank one update to a matrix.
-c     zcopy    Level 1 BLAS that copies one vector to another .
-c     zscal    Level 1 BLAS that scales a vector.
-c     zdscal   Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2   Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented. 
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the 
-c     upper triangular matrix stored workl(ipntr(12)). 
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas 
-c     Dept. of Computational & 
-c     Applied Mathematics 
-c     Rice University 
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine zneupd (rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex*16      
-     &           sigma
-      Double precision  
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision 
-     &           rwork(ncv)
-      Complex*16 
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev), 
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16 
-     &           one, zero
-      parameter  (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex*16 
-     &           rnorm, temp, vl(1)
-      Double precision 
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy  , zgeru , zgeqr2 , zlacpy , zmout ,
-     &           zunm2r , ztrmm , zvout , ivout,
-     &           zlahqr 
-c  
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision 
-     &           dznrm2 , dlamch , dlapy2 
-      external   dznrm2 , dlamch , dlapy2 
-c
-      Complex*16 
-     &           zdotc 
-      external   zdotc 
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c 
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c     
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else 
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c 
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by ZNEUPD .                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c     
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call zvout (logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call zvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call zngets (ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call zvout  (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call zvout  (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 dlapy2  ( dble (workl(irz+ncv-j)),
-     &                          dimag (workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          dlapy2 ( dble (workl(ibd+jj-1)),
-     &          dimag (workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nev) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, numcnv, ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, nconv, ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine zlahqr  to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by ZNAUPD .   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call zcopy (ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call zlaset ('All', ncv, ncv          , 
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call zlahqr (.true., .true.       , ncv          , 
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call zcopy (ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call zvout  (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call zvout  (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call zmout  (logfil       , ncv, ncv   , 
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ztrsen ('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2       , conds        , sep         , 
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call zvout  (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call zmout (logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call zcopy (ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c 
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call zcopy (nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call zgeqr2 (ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using zunm2r .                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       | 
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call zunm2r ('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call zlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( dble ( workl(invsub+(j-1)*ldq+j-1) ) .lt. 
-     &                  dble (zero) ) then
-               call zscal (nconv, -one, workl(iuptri+j-1), ldq)
-               call zscal (nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ztrevc ('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ztrevc  returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = dznrm2 (ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = dble (one) / rtemp
-                  call zdscal  ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c 
-                  workev(j) = zdotc (j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call zcopy (nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call zmout (logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c 
-            call zcopy (nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ztrmm ('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if 
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed ZNAUPD  into D.    |
-c        %--------------------------------------------------%
-c
-         call zcopy (nconv, workl(ritz), 1, d, 1)
-         call zcopy (nconv, workl(ritz), 1, workl(iheig), 1)
-         call zcopy (nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec) 
-     &      call zscal (ncv, rnorm, workl(ihbds), 1)
-c      
-      else
-c     
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec) 
-     &      call zscal (ncv, rnorm, workl(ihbds), 1)
-c    
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c  
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c    
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call zvout  (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call zvout  (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call zvout  (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call zgeru  (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c     
-c     %---------------%
-c     | End of zneupd |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zngets.f b/libcruft/arpack/src/zngets.f
deleted file mode 100644
--- a/libcruft/arpack/src/zngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: zngets
-c
-c\Description: 
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of 
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call zngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are 
-c          selected, the unwanted part corresponds to the shifts to 
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     zsortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zvout,  zsortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c 
-      call arscnd (t0)
-      msglvl = mcgets
-c 
-      call zsortc (which, .true., kev+np, ritz, bounds)
-c     
-      if ( ishift .eq. 1 ) then
-c     
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine znapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c     
-         call zsortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c     
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, kev, ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, np, ndigit, '_ngets: NP is')
-         call zvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call zvout (logfil, kev+np, bounds, ndigit, 
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c     
-      return
-c     
-c     %---------------%
-c     | End of zngets |
-c     %---------------%
-c     
-      end
diff --git a/libcruft/arpack/src/zsortc.f b/libcruft/arpack/src/zsortc.f
deleted file mode 100644
--- a/libcruft/arpack/src/zsortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: zsortc
-c
-c\Description:
-c  Sorts the Complex*16 array in X into the order 
-c  specified by WHICH and optionally applies the permutation to the
-c  Double precision  array Y. 
-c
-c\Usage:
-c  call zsortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order 
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex*16 array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex*16 array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics 
-c     Rice University           
-c     Houston, Texas 
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zsortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16     
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex*16     
-     &           temp
-      Double precision 
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           dble, dimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c 
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(dble(x(j)),dimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),dimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(dble(x(j)),dimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),dimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c 
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (dble(x(j)).gt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c 
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (dble(x(j)).lt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c 
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (dimag(x(j)).gt.dimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c 
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (dimag(x(j)).lt.dimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c 
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c 
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zsortc |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/src/zstatn.f b/libcruft/arpack/src/zstatn.f
deleted file mode 100644
--- a/libcruft/arpack/src/zstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine zstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
- 
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
- 
-      tcaupd = 0.0D+0
-      tcaup2 = 0.0D+0
-      tcaitr = 0.0D+0
-      tceigh = 0.0D+0
-      tcgets = 0.0D+0
-      tcapps = 0.0D+0
-      tcconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
- 
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
- 
-      return
-c
-c     %---------------%
-c     | End of zstatn |
-c     %---------------%
-c
-      end
diff --git a/libcruft/arpack/util/cmout.f b/libcruft/arpack/util/cmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/cmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    CMOUT
-*
-*  Purpose:    Complex matrix output routine.
-*
-*  Usage:      CALL CMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: cmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE 
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF 
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN 
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) ) 
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-* 
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',E10.3,',',E10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E10.3,',',E10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E12.5,',',E12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E14.7,',',E14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E20.13,',',E20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/cvout.f b/libcruft/arpack/util/cvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/cvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: cvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    CVOUT
-*
-*  Purpose:    Complex vector output routine.
-*
-*  Usage:      CALL CVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4 
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') ) 
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-* 
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') ) 
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',E10.3,',',E10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E10.3,',',E10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E12.5,',',E12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E14.7,',',E14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E20.13,',',E20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') )
-*
-*
-* 
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/dmout.f b/libcruft/arpack/util/dmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/dmout.f
+++ /dev/null
@@ -1,167 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL DMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LDA, LOUT, M, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   A( LDA, * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, J, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Local Arrays ..
-      CHARACTER          ICOL( 3 )
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Data statements ..
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 10D12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 8D14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 6D18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 5D22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/dvout.f b/libcruft/arpack/util/dvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/dvout.f
+++ /dev/null
@@ -1,122 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL DVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LOUT, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   SX( * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P, 10D12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 8D14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 6D18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 5D24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/icnteq.f b/libcruft/arpack/util/icnteq.f
deleted file mode 100644
--- a/libcruft/arpack/util/icnteq.f
+++ /dev/null
@@ -1,18 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Count the number of elements equal to a specified integer value.
-c
-      integer function icnteq (n, array, value)
-c
-      integer    n, value
-      integer    array(*)
-c
-      k = 0
-      do 10 i = 1, n
-         if (array(i) .eq. value) k = k + 1
-   10 continue
-      icnteq = k
-c
-      return
-      end
diff --git a/libcruft/arpack/util/icopy.f b/libcruft/arpack/util/icopy.f
deleted file mode 100644
--- a/libcruft/arpack/util/icopy.f
+++ /dev/null
@@ -1,77 +0,0 @@
-*--------------------------------------------------------------------
-*\Documentation
-*
-*\Name: ICOPY
-*
-*\Description:
-*     ICOPY copies an integer vector lx to an integer vector ly.
-*
-*\Usage:
-*     call icopy ( n, lx, inc, ly, incy )
-*
-*\Arguments:
-*    n        integer (input)
-*             On entry, n is the number of elements of lx to be
-c             copied to ly.
-*
-*    lx       integer array (input)
-*             On entry, lx is the integer vector to be copied.
-*
-*    incx     integer (input)
-*             On entry, incx is the increment between elements of lx.
-*
-*    ly       integer array (input)
-*             On exit, ly is the integer vector that contains the
-*             copy of lx.
-*
-*    incy     integer (input)
-*             On entry, incy is the increment between elements of ly.
-*
-*\Enddoc
-*
-*--------------------------------------------------------------------
-*
-      subroutine icopy( n, lx, incx, ly, incy )
-*
-*     ----------------------------
-*     Specifications for arguments
-*     ----------------------------
-      integer    incx, incy, n
-      integer    lx( 1 ), ly( 1 )
-*
-*     ----------------------------------
-*     Specifications for local variables
-*     ----------------------------------
-      integer           i, ix, iy
-*
-*     --------------------------
-*     First executable statement
-*     --------------------------
-      if( n.le.0 )
-     $   return
-      if( incx.eq.1 .and. incy.eq.1 )
-     $   go to 20
-c
-c.....code for unequal increments or equal increments
-c     not equal to 1
-      ix = 1
-      iy = 1
-      if( incx.lt.0 )
-     $   ix = ( -n+1 )*incx + 1
-      if( incy.lt.0 )
-     $   iy = ( -n+1 )*incy + 1
-      do 10 i = 1, n
-         ly( iy ) = lx( ix )
-         ix = ix + incx
-         iy = iy + incy
-   10 continue
-      return
-c
-c.....code for both increments equal to 1
-c
-   20 continue
-      do 30 i = 1, n
-         ly( i ) = lx( i )
-   30 continue
-      return
-      end
diff --git a/libcruft/arpack/util/iset.f b/libcruft/arpack/util/iset.f
deleted file mode 100644
--- a/libcruft/arpack/util/iset.f
+++ /dev/null
@@ -1,16 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Only work with increment equal to 1 right now.
-c
-      subroutine iset (n, value, array, inc)
-c
-      integer    n, value, inc
-      integer    array(*)
-c
-      do 10 i = 1, n
-         array(i) = value
-   10 continue
-c
-      return
-      end
diff --git a/libcruft/arpack/util/iswap.f b/libcruft/arpack/util/iswap.f
deleted file mode 100644
--- a/libcruft/arpack/util/iswap.f
+++ /dev/null
@@ -1,55 +0,0 @@
-      subroutine iswap (n,sx,incx,sy,incy)
-c
-c     interchanges two vectors.
-c     uses unrolled loops for increments equal to 1.
-c     jack dongarra, linpack, 3/11/78.
-c
-      integer sx(1),sy(1),stemp
-      integer i,incx,incy,ix,iy,m,mp1,n
-c
-      if(n.le.0)return
-      if(incx.eq.1.and.incy.eq.1)go to 20
-c
-c       code for unequal increments or equal increments not equal
-c         to 1
-c
-      ix = 1
-      iy = 1
-      if(incx.lt.0)ix = (-n+1)*incx + 1
-      if(incy.lt.0)iy = (-n+1)*incy + 1
-      do 10 i = 1,n
-        stemp = sx(ix)
-        sx(ix) = sy(iy)
-        sy(iy) = stemp
-        ix = ix + incx
-        iy = iy + incy
-   10 continue
-      return
-c
-c       code for both increments equal to 1
-c
-c
-c       clean-up loop
-c
-   20 m = mod(n,3)
-      if( m .eq. 0 ) go to 40
-      do 30 i = 1,m
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-   30 continue
-      if( n .lt. 3 ) return
-   40 mp1 = m + 1
-      do 50 i = mp1,n,3
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-        stemp = sx(i + 1)
-        sx(i + 1) = sy(i + 1)
-        sy(i + 1) = stemp
-        stemp = sx(i + 2)
-        sx(i + 2) = sy(i + 2)
-        sy(i + 2) = stemp
-   50 continue
-      return
-      end
diff --git a/libcruft/arpack/util/ivout.f b/libcruft/arpack/util/ivout.f
deleted file mode 100644
--- a/libcruft/arpack/util/ivout.f
+++ /dev/null
@@ -1,120 +0,0 @@
-C-----------------------------------------------------------------------
-C  Routine:    IVOUT
-C
-C  Purpose:    Integer vector output routine.
-C
-C  Usage:      CALL IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C
-C  Arguments
-C     N      - Length of array IX. (Input)
-C     IX     - Integer array to be printed. (Input)
-C     IFMT   - Format to be used in printing array IX. (Input)
-C     IDIGIT - Print up to ABS(IDIGIT) decimal digits / number. (Input)
-C              If IDIGIT .LT. 0, printing is done with 72 columns.
-C              If IDIGIT .GT. 0, printing is done with 132 columns.
-C
-C-----------------------------------------------------------------------
-C
-      SUBROUTINE IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C     ...
-C     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER    IX(*), N, IDIGIT, LOUT
-      CHARACTER  IFMT*(*)
-C     ...
-C     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER    I, NDIGIT, K1, K2, LLL
-      CHARACTER*80 LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-C
-      LLL = MIN ( LEN ( IFMT ), 80 )
-      DO 1 I = 1, LLL
-          LINE(I:I) = '-'
-    1 CONTINUE
-C
-      DO 2 I = LLL+1, 80
-          LINE(I:I) = ' '
-    2 CONTINUE
-C
-      WRITE ( LOUT, 2000 ) IFMT, LINE(1:LLL)
- 2000 FORMAT ( /1X, A  /1X, A )
-C
-      IF (N .LE. 0) RETURN
-      NDIGIT = IDIGIT
-      IF (IDIGIT .EQ. 0) NDIGIT = 4
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-C=======================================================================
-C
-      IF (IDIGIT .LT. 0) THEN
-C
-      NDIGIT = -IDIGIT
-      IF (NDIGIT .LE. 4) THEN
-         DO 10 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   10    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 30 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-   30    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 50 K1 = 1, N, 5
-            K2 = MIN0(N,K1+4)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-   50    CONTINUE
-C
-      ELSE
-         DO 70 K1 = 1, N, 3
-            K2 = MIN0(N,K1+2)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-   70    CONTINUE
-      END IF
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-C=======================================================================
-C
-      ELSE
-C
-      IF (NDIGIT .LE. 4) THEN
-         DO 90 K1 = 1, N, 20
-            K2 = MIN0(N,K1+19)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   90    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 110 K1 = 1, N, 15
-            K2 = MIN0(N,K1+14)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-  110    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 130 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-  130    CONTINUE
-C
-      ELSE
-         DO 150 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-  150    CONTINUE
-      END IF
-      END IF
-      WRITE (LOUT,1004)
-C
- 1000 FORMAT(1X,I4,' - ',I4,':',20(1X,I5))
- 1001 FORMAT(1X,I4,' - ',I4,':',15(1X,I7))
- 1002 FORMAT(1X,I4,' - ',I4,':',10(1X,I11))
- 1003 FORMAT(1X,I4,' - ',I4,':',7(1X,I15))
- 1004 FORMAT(1X,' ')
-C
-      RETURN
-      END
diff --git a/libcruft/arpack/util/second.f b/libcruft/arpack/util/second.f
deleted file mode 100644
--- a/libcruft/arpack/util/second.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      SUBROUTINE ARSCND( T )
-*
-      REAL       T
-*
-*  -- LAPACK auxiliary routine (preliminary version) --
-*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
-*     Courant Institute, Argonne National Lab, and Rice University
-*     July 26, 1991
-*
-*  Purpose
-*  =======
-*
-*  SECOND returns the user time for a process in arscnds.
-*  This version gets the time from the system function ETIME.
-*
-*     .. Local Scalars ..
-      REAL               T1
-*     ..
-*     .. Local Arrays ..
-      REAL               TARRAY( 2 )
-*     ..
-*     .. External Functions ..
-      REAL               ETIME
-      INTRINSIC          ETIME
-*     ..
-*     .. Executable Statements ..
-*
-
-      T1 = ETIME( TARRAY )
-      T  = TARRAY( 1 )
-
-      RETURN
-*
-*     End of ARSCND
-*
-      END
diff --git a/libcruft/arpack/util/smout.f b/libcruft/arpack/util/smout.f
deleted file mode 100644
--- a/libcruft/arpack/util/smout.f
+++ /dev/null
@@ -1,157 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL SMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      REAL               A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P10E12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P8E14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P6E18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P5E22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/svout.f b/libcruft/arpack/util/svout.f
deleted file mode 100644
--- a/libcruft/arpack/util/svout.f
+++ /dev/null
@@ -1,112 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL SVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      REAL               SX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P10E12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P8E14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P6E18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P5E24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/arpack/util/zmout.f b/libcruft/arpack/util/zmout.f
deleted file mode 100644
--- a/libcruft/arpack/util/zmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    ZMOUT
-*
-*  Purpose:    Complex*16 matrix output routine.
-*
-*  Usage:      CALL ZMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex*16 M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: zmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex*16
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE 
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2 
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF 
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN 
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 ) 
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) ) 
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-* 
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',D10.3,',',D10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D10.3,',',D10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D12.5,',',D12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D14.7,',',D14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D20.13,',',D20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/libcruft/arpack/util/zvout.f b/libcruft/arpack/util/zvout.f
deleted file mode 100644
--- a/libcruft/arpack/util/zvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: zvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    ZVOUT
-*
-*  Purpose:    Complex*16 vector output routine.
-*
-*  Usage:      CALL ZVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex*16 array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex*16
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 ) 
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4 
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3 
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ), 
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') ) 
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-* 
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') ) 
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',D10.3,',',D10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D10.3,',',D10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D12.5,',',D12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D14.7,',',D14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D20.13,',',D20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') )
-*
-*
-* 
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/libcruft/blas-xtra/cconv2.f b/libcruft/blas-xtra/cconv2.f
--- a/libcruft/blas-xtra/cconv2.f
+++ b/libcruft/blas-xtra/cconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/cdotc3.f b/libcruft/blas-xtra/cdotc3.f
--- a/libcruft/blas-xtra/cdotc3.f
+++ b/libcruft/blas-xtra/cdotc3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/cmatm3.f b/libcruft/blas-xtra/cmatm3.f
--- a/libcruft/blas-xtra/cmatm3.f
+++ b/libcruft/blas-xtra/cmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/csconv2.f b/libcruft/blas-xtra/csconv2.f
--- a/libcruft/blas-xtra/csconv2.f
+++ b/libcruft/blas-xtra/csconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/dconv2.f b/libcruft/blas-xtra/dconv2.f
--- a/libcruft/blas-xtra/dconv2.f
+++ b/libcruft/blas-xtra/dconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/ddot3.f b/libcruft/blas-xtra/ddot3.f
--- a/libcruft/blas-xtra/ddot3.f
+++ b/libcruft/blas-xtra/ddot3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/dmatm3.f b/libcruft/blas-xtra/dmatm3.f
--- a/libcruft/blas-xtra/dmatm3.f
+++ b/libcruft/blas-xtra/dmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/sconv2.f b/libcruft/blas-xtra/sconv2.f
--- a/libcruft/blas-xtra/sconv2.f
+++ b/libcruft/blas-xtra/sconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/sdot3.f b/libcruft/blas-xtra/sdot3.f
--- a/libcruft/blas-xtra/sdot3.f
+++ b/libcruft/blas-xtra/sdot3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/smatm3.f b/libcruft/blas-xtra/smatm3.f
--- a/libcruft/blas-xtra/smatm3.f
+++ b/libcruft/blas-xtra/smatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zconv2.f b/libcruft/blas-xtra/zconv2.f
--- a/libcruft/blas-xtra/zconv2.f
+++ b/libcruft/blas-xtra/zconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zdconv2.f b/libcruft/blas-xtra/zdconv2.f
--- a/libcruft/blas-xtra/zdconv2.f
+++ b/libcruft/blas-xtra/zdconv2.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zdotc3.f b/libcruft/blas-xtra/zdotc3.f
--- a/libcruft/blas-xtra/zdotc3.f
+++ b/libcruft/blas-xtra/zdotc3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/blas-xtra/zmatm3.f b/libcruft/blas-xtra/zmatm3.f
--- a/libcruft/blas-xtra/zmatm3.f
+++ b/libcruft/blas-xtra/zmatm3.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2009-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2009-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/lapack-xtra/crsf2csf.f b/libcruft/lapack-xtra/crsf2csf.f
--- a/libcruft/lapack-xtra/crsf2csf.f
+++ b/libcruft/lapack-xtra/crsf2csf.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/lapack-xtra/zrsf2csf.f b/libcruft/lapack-xtra/zrsf2csf.f
--- a/libcruft/lapack-xtra/zrsf2csf.f
+++ b/libcruft/lapack-xtra/zrsf2csf.f
@@ -1,9 +1,9 @@
-c Copyright (C) 2010-2011  VZLU Prague, a.s., Czech Republic
+c Copyright (C) 2010-2012  VZLU Prague, a.s., Czech Republic
 c
 c Author: Jaroslav Hajek <highegg@gmail.com>
 c
 c This file is part of Octave.
 c
 c Octave is free software; you can redistribute it and/or modify
 c it under the terms of the GNU General Public License as published by
 c the Free Software Foundation; either version 3 of the License, or
diff --git a/libcruft/misc/blaswrap.c b/libcruft/misc/blaswrap.c
--- a/libcruft/misc/blaswrap.c
+++ b/libcruft/misc/blaswrap.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jarno Rajahalme
+Copyright (C) 2012 Jarno Rajahalme
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/cquit.c b/libcruft/misc/cquit.c
--- a/libcruft/misc/cquit.c
+++ b/libcruft/misc/cquit.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-extern.cc b/libcruft/misc/f77-extern.cc
--- a/libcruft/misc/f77-extern.cc
+++ b/libcruft/misc/f77-extern.cc
@@ -1,12 +1,12 @@
 // misc-extern.cc                                     -*- C++ -*-
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-fcn.c b/libcruft/misc/f77-fcn.c
--- a/libcruft/misc/f77-fcn.c
+++ b/libcruft/misc/f77-fcn.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/lo-error.c b/libcruft/misc/lo-error.c
--- a/libcruft/misc/lo-error.c
+++ b/libcruft/misc/lo-error.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/lo-error.h b/libcruft/misc/lo-error.h
--- a/libcruft/misc/lo-error.h
+++ b/libcruft/misc/lo-error.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/quit.cc b/libcruft/misc/quit.cc
--- a/libcruft/misc/quit.cc
+++ b/libcruft/misc/quit.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/misc/quit.h b/libcruft/misc/quit.h
--- a/libcruft/misc/quit.h
+++ b/libcruft/misc/quit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/libcruft/mkf77def.in b/libcruft/mkf77def.in
old mode 100755
new mode 100644
--- a/libcruft/mkf77def.in
+++ b/libcruft/mkf77def.in
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2006-2011 John W. Eaton
+# Copyright (C) 2006-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-fC.cc b/liboctave/Array-fC.cc
--- a/liboctave/Array-fC.cc
+++ b/liboctave/Array-fC.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-idx-vec.cc b/liboctave/Array-idx-vec.cc
--- a/liboctave/Array-idx-vec.cc
+++ b/liboctave/Array-idx-vec.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-s.cc b/liboctave/Array-s.cc
--- a/liboctave/Array-s.cc
+++ b/liboctave/Array-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-str.cc b/liboctave/Array-str.cc
--- a/liboctave/Array-str.cc
+++ b/liboctave/Array-str.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Array-util.h b/liboctave/Array-util.h
--- a/liboctave/Array-util.h
+++ b/liboctave/Array-util.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array-voidp.cc b/liboctave/Array-voidp.cc
--- a/liboctave/Array-voidp.cc
+++ b/liboctave/Array-voidp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -79,32 +79,32 @@ Array<T>::fill (const T& val)
   else
     fill_or_memset (slice_len, val, slice_data);
 }
 
 template <class T>
 void
 Array<T>::clear (void)
 {
-  if (--rep->count <= 0)
+  if (--rep->count == 0)
     delete rep;
 
   rep = nil_rep ();
   rep->count++;
   slice_data = rep->data;
   slice_len = rep->len;
 
   dimensions = dim_vector ();
 }
 
 template <class T>
 void
 Array<T>::clear (const dim_vector& dv)
 {
-  if (--rep->count <= 0)
+  if (--rep->count == 0)
     delete rep;
 
   rep = new ArrayRep (dv.safe_numel ());
   slice_data = rep->data;
   slice_len = rep->len;
 
   dimensions = dv;
   dimensions.chop_trailing_singletons ();
@@ -778,17 +778,17 @@ Array<T>::index (const idx_vector& i, co
       // A(:,:) produces a shallow copy.
       retval = Array<T> (*this, dv);
     }
   else
     {
       if (i.extent (r) != r)
         gripe_index_out_of_range (2, 1, i.extent (r), r); // throws
       if (j.extent (c) != c)
-        gripe_index_out_of_range (2, 2, i.extent (c), c); // throws
+        gripe_index_out_of_range (2, 2, j.extent (c), c); // throws
 
       octave_idx_type n = numel (), il = i.length (r), jl = j.length (c);
 
       idx_vector ii (i);
 
       if (ii.maybe_reduce (r, j, c))
         {
           octave_idx_type l, u;
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -105,18 +105,22 @@ protected:
   //--------------------------------------------------------------------
 
 public:
 
   void make_unique (void)
     {
       if (rep->count > 1)
         {
-          --rep->count;
-          rep = new ArrayRep (slice_data, slice_len);
+          ArrayRep *r = new ArrayRep (slice_data, slice_len);
+
+          if (--rep->count == 0)
+            delete rep;
+          
+          rep = r;
           slice_data = rep->data;
         }
     }
 
   typedef T element_type;
 
   typedef typename ref_param<T>::type crefT;
 
@@ -147,20 +151,22 @@ protected:
       rep->count++;
       dimensions.chop_trailing_singletons ();
     }
 
 private:
 
   typename Array<T>::ArrayRep *nil_rep (void) const
     {
-      static typename Array<T>::ArrayRep *nr
-        = new typename Array<T>::ArrayRep ();
+      // NR was originally allocated with new, but that does not seem
+      // to be necessary since it will never be deleted.  So just use
+      // a static object instead.
 
-      return nr;
+      static typename Array<T>::ArrayRep nr;
+      return &nr;
     }
 
 public:
 
   // Empty ctor (0x0).
 
   Array (void)
     : dimensions (), rep (nil_rep ()), slice_data (rep->data),
@@ -220,25 +226,25 @@ public:
     {
       rep->count++;
     }
 
 public:
 
   ~Array (void)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
     }
 
   Array<T>& operator = (const Array<T>& a)
     {
       if (this != &a)
         {
-          if (--rep->count <= 0)
+          if (--rep->count == 0)
             delete rep;
 
           rep = a.rep;
           rep->count++;
 
           dimensions = a.dimensions;
           slice_data = a.slice_data;
           slice_len = a.slice_len;
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/CmplxAEPBAL.h
--- a/liboctave/CmplxAEPBAL.h
+++ b/liboctave/CmplxAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxCHOL.h b/liboctave/CmplxCHOL.h
--- a/liboctave/CmplxCHOL.h
+++ b/liboctave/CmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxGEPBAL.h b/liboctave/CmplxGEPBAL.h
--- a/liboctave/CmplxGEPBAL.h
+++ b/liboctave/CmplxGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxHESS.h b/liboctave/CmplxHESS.h
--- a/liboctave/CmplxHESS.h
+++ b/liboctave/CmplxHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxLU.h b/liboctave/CmplxLU.h
--- a/liboctave/CmplxLU.h
+++ b/liboctave/CmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/CmplxQR.h b/liboctave/CmplxQR.h
--- a/liboctave/CmplxQR.h
+++ b/liboctave/CmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/CmplxQRP.h b/liboctave/CmplxQRP.h
--- a/liboctave/CmplxQRP.h
+++ b/liboctave/CmplxQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/CmplxSCHUR.h
--- a/liboctave/CmplxSCHUR.h
+++ b/liboctave/CmplxSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAE.h b/liboctave/DAE.h
--- a/liboctave/DAE.h
+++ b/liboctave/DAE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAEFunc.h b/liboctave/DAEFunc.h
--- a/liboctave/DAEFunc.h
+++ b/liboctave/DAEFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAERT.h b/liboctave/DAERT.h
--- a/liboctave/DAERT.h
+++ b/liboctave/DAERT.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DAERTFunc.h b/liboctave/DAERTFunc.h
--- a/liboctave/DAERTFunc.h
+++ b/liboctave/DAERTFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DET.h b/liboctave/DET.h
--- a/liboctave/DET.h
+++ b/liboctave/DET.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -38,17 +38,17 @@ template <class T>
 class
 DiagArray2 : protected Array<T>
 {
 protected:
   octave_idx_type d1, d2;
 
 public:
 
-  using Array<T>::element_type;
+  using typename Array<T>::element_type;
 
   DiagArray2 (void)
     : Array<T> (), d1 (0), d2 (0) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c)
     : Array<T> (dim_vector (std::min (r, c), 1)), d1 (r), d2 (c) { }
 
   DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/EIG.h b/liboctave/EIG.h
--- a/liboctave/EIG.h
+++ b/liboctave/EIG.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/LSODE.h b/liboctave/LSODE.h
--- a/liboctave/LSODE.h
+++ b/liboctave/LSODE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-C.cc b/liboctave/MArray-C.cc
--- a/liboctave/MArray-C.cc
+++ b/liboctave/MArray-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-d.cc b/liboctave/MArray-d.cc
--- a/liboctave/MArray-d.cc
+++ b/liboctave/MArray-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-decl.h b/liboctave/MArray-decl.h
--- a/liboctave/MArray-decl.h
+++ b/liboctave/MArray-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray-f.cc b/liboctave/MArray-f.cc
--- a/liboctave/MArray-f.cc
+++ b/liboctave/MArray-f.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-fC.cc b/liboctave/MArray-fC.cc
--- a/liboctave/MArray-fC.cc
+++ b/liboctave/MArray-fC.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray-s.cc b/liboctave/MArray-s.cc
--- a/liboctave/MArray-s.cc
+++ b/liboctave/MArray-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -1,12 +1,12 @@
 // Template array classes with like-type math ops
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-C.cc b/liboctave/MSparse-C.cc
--- a/liboctave/MSparse-C.cc
+++ b/liboctave/MSparse-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-d.cc b/liboctave/MSparse-d.cc
--- a/liboctave/MSparse-d.cc
+++ b/liboctave/MSparse-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse-defs.h b/liboctave/MSparse-defs.h
--- a/liboctave/MSparse-defs.h
+++ b/liboctave/MSparse-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's liboctave directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
@@ -182,16 +182,17 @@ INCS = \
   ODE.h \
   ODEFunc.h \
   ODES.h \
   ODESFunc.h \
   Quad.h \
   Range.h \
   base-dae.h \
   base-de.h \
+  base-list.h \
   base-min.h \
   bsxfun.h \
   byte-swap.h \
   caseless-str.h \
   cmd-edit.h \
   cmd-hist.h \
   data-conv.h \
   dir-ops.h \
@@ -238,17 +239,18 @@ INCS = \
   oct-syscalls.h \
   oct-time.h \
   oct-uname.h \
   pathlen.h \
   pathsearch.h \
   randgamma.h \
   randmtzig.h \
   randpoisson.h \
-  regex-match.h \
+  regexp.h \
+  singleton-cleanup.h \
   sparse-sort.h \
   sparse-util.h \
   statdefs.h \
   str-vec.h \
   sun-utils.h \
   sysdir.h \
   syswait.h \
   $(MATRIX_INC)
@@ -446,17 +448,18 @@ LIBOCTAVE_CXX_SOURCES = \
   oct-passwd.cc \
   oct-rand.cc \
   oct-shlib.cc \
   oct-spparms.cc \
   oct-syscalls.cc \
   oct-time.cc \
   oct-uname.cc \
   pathsearch.cc \
-  regex-match.cc \
+  regexp.cc \
+  singleton-cleanup.cc \
   sparse-sort.cc \
   sparse-util.cc \
   str-vec.cc \
   $(TI_SRC) \
   $(MATRIX_SRC)
 
 include vx-op-src.mk
 include mx-op-src.mk
@@ -512,17 +515,17 @@ liboctave_la_CPPFLAGS = \
   @OCTAVE_DLL_DEFS@ \
   $(SPARSE_XCPPFLAGS) \
   $(FFTW_XCPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
   $(AM_CPPFLAGS)
 
 # Increment these as needed and according to the rules in the libtool
 # manual:
-liboctave_current = 0
+liboctave_current = 1
 liboctave_revision = 0
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
diff --git a/liboctave/Matrix.h b/liboctave/Matrix.h
--- a/liboctave/Matrix.h
+++ b/liboctave/Matrix.h
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 Copyright (C) 2006 Andy Adler
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -451,21 +451,21 @@ MatrixType::MatrixType (const SparseMatr
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
-          typ = MatrixType::Rectangular;
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
+          typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full ||
                               typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
@@ -772,21 +772,21 @@ MatrixType::MatrixType (const SparseComp
       // Disable lower under-determined and upper over-determined problems
       // as being detected, and force to treat as singular. As this seems
       // to cause issues
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
-          typ = MatrixType::Rectangular;
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
+          typ = MatrixType::Rectangular;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
       if (maybe_hermitian && (typ == MatrixType::Full ||
                               typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
diff --git a/liboctave/MatrixType.h b/liboctave/MatrixType.h
--- a/liboctave/MatrixType.h
+++ b/liboctave/MatrixType.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 Copyright (C) 2006 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/ODE.h b/liboctave/ODE.h
--- a/liboctave/ODE.h
+++ b/liboctave/ODE.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODEFunc.h b/liboctave/ODEFunc.h
--- a/liboctave/ODEFunc.h
+++ b/liboctave/ODEFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODES.cc b/liboctave/ODES.cc
--- a/liboctave/ODES.cc
+++ b/liboctave/ODES.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODES.h b/liboctave/ODES.h
--- a/liboctave/ODES.h
+++ b/liboctave/ODES.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/ODESFunc.h b/liboctave/ODESFunc.h
--- a/liboctave/ODESFunc.h
+++ b/liboctave/ODESFunc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/PermMatrix.cc b/liboctave/PermMatrix.cc
--- a/liboctave/PermMatrix.cc
+++ b/liboctave/PermMatrix.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/PermMatrix.h b/liboctave/PermMatrix.h
--- a/liboctave/PermMatrix.h
+++ b/liboctave/PermMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Quad-opts.in b/liboctave/Quad-opts.in
--- a/liboctave/Quad-opts.in
+++ b/liboctave/Quad-opts.in
@@ -1,9 +1,9 @@
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Quad.h b/liboctave/Quad.h
--- a/liboctave/Quad.h
+++ b/liboctave/Quad.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse-C.cc b/liboctave/Sparse-C.cc
--- a/liboctave/Sparse-C.cc
+++ b/liboctave/Sparse-C.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-b.cc b/liboctave/Sparse-b.cc
--- a/liboctave/Sparse-b.cc
+++ b/liboctave/Sparse-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-d.cc b/liboctave/Sparse-d.cc
--- a/liboctave/Sparse-d.cc
+++ b/liboctave/Sparse-d.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/Sparse-diag-op-defs.h b/liboctave/Sparse-diag-op-defs.h
--- a/liboctave/Sparse-diag-op-defs.h
+++ b/liboctave/Sparse-diag-op-defs.h
@@ -1,11 +1,11 @@
 /* -*- C++ -*-
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -1,11 +1,11 @@
 /* -*- C++ -*-
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1,12 +1,12 @@
 // Template sparse array class
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -662,27 +662,27 @@ Sparse<T>::Sparse (const Array<T>& a)
           xcidx(j+1) = ii;
         }
     }
 }
 
 template <class T>
 Sparse<T>::~Sparse (void)
 {
-  if (--rep->count <= 0)
+  if (--rep->count == 0)
     delete rep;
 }
 
 template <class T>
 Sparse<T>&
 Sparse<T>::operator = (const Sparse<T>& a)
 {
   if (this != &a)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
 
       rep = a.rep;
       rep->count++;
 
       dimensions = a.dimensions;
     }
 
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -1,12 +1,12 @@
 // Template sparse classes
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -142,46 +142,49 @@ protected:
   };
 
   //--------------------------------------------------------------------
 
   void make_unique (void)
     {
       if (rep->count > 1)
         {
-          --rep->count;
-          rep = new SparseRep (*rep);
+          SparseRep *r = new SparseRep (*rep);
+
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = r;
         }
     }
 
 public:
 
   // !!! WARNING !!! -- these should be protected, not public.  You
   // should not access these data members directly!
 
   typename Sparse<T>::SparseRep *rep;
 
   dim_vector dimensions;
 
 private:
 
   typename Sparse<T>::SparseRep *nil_rep (void) const
     {
-      static typename Sparse<T>::SparseRep *nr
-        = new typename Sparse<T>::SparseRep ();
-
-      nr->count++;
-
-      return nr;
+      static typename Sparse<T>::SparseRep nr;
+      return &nr;
     }
 
 public:
 
   Sparse (void)
-    : rep (nil_rep ()), dimensions (dim_vector(0,0)) { }
+    : rep (nil_rep ()), dimensions (dim_vector(0,0))
+    {
+      rep->count++;
+    }
 
   explicit Sparse (octave_idx_type n)
     : rep (new typename Sparse<T>::SparseRep (n)),
       dimensions (dim_vector (n, n)) { }
 
   explicit Sparse (octave_idx_type nr, octave_idx_type nc)
     : rep (new typename Sparse<T>::SparseRep (nr, nc)),
       dimensions (dim_vector (nr, nc)) { }
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxLU.h b/liboctave/SparseCmplxLU.h
--- a/liboctave/SparseCmplxLU.h
+++ b/liboctave/SparseCmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -91,25 +91,25 @@ public:
 
   SparseComplexQR (const SparseComplexMatrix& a, int order = 0) :
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
     }
 
   SparseComplexQR& operator = (const SparseComplexQR& a)
     {
       if (this != &a)
         {
-          if (--rep->count <= 0)
+          if (--rep->count == 0)
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -93,25 +93,25 @@ public:
 
   SparseQR (const SparseMatrix& a, int order = 0) :
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
     }
 
   SparseQR& operator = (const SparseQR& a)
     {
       if (this != &a)
         {
-          if (--rep->count <= 0)
+          if (--rep->count == 0)
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-aepbal.h b/liboctave/base-aepbal.h
--- a/liboctave/base-aepbal.h
+++ b/liboctave/base-aepbal.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-dae.h b/liboctave/base-dae.h
--- a/liboctave/base-dae.h
+++ b/liboctave/base-dae.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-de.h b/liboctave/base-de.h
--- a/liboctave/base-de.h
+++ b/liboctave/base-de.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/base-list.h b/liboctave/base-list.h
rename from src/base-list.h
rename to liboctave/base-list.h
--- a/src/base-list.h
+++ b/liboctave/base-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -31,17 +31,18 @@ octave_base_list
 {
 public:
 
   typedef typename std::list<elt_type>::iterator iterator;
   typedef typename std::list<elt_type>::const_iterator const_iterator;
 
   bool empty (void) const { return lst.empty (); }
 
-  size_t length (void) const { return lst.size (); }
+  size_t size (void) const { return lst.size (); }
+  size_t length (void) const { return size (); }
 
   iterator erase (iterator pos) { return lst.erase (pos); }
 
   template <class P>
   void remove_if (P pred)
   {
     // We would like to simply call
     //
@@ -85,16 +86,18 @@ public:
 
   // For backward compatibility.
   void append (const elt_type& s) { lst.push_back (s); }
 
 protected:
 
   octave_base_list (void) : lst () { }
 
+  octave_base_list (const std::list<elt_type>& l) : lst (l) { }
+
   octave_base_list (const octave_base_list& bl) : lst (bl.lst) { }
 
   octave_base_list& operator = (const octave_base_list& bl)
     {
       if (this != &bl)
         {
           lst = bl.lst;
         }
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/base-min.h b/liboctave/base-min.h
--- a/liboctave/base-min.h
+++ b/liboctave/base-min.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-qr.cc b/liboctave/base-qr.cc
--- a/liboctave/base-qr.cc
+++ b/liboctave/base-qr.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/base-qr.h b/liboctave/base-qr.h
--- a/liboctave/base-qr.h
+++ b/liboctave/base-qr.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun-decl.h b/liboctave/bsxfun-decl.h
--- a/liboctave/bsxfun-decl.h
+++ b/liboctave/bsxfun-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/bsxfun.h b/liboctave/bsxfun.h
--- a/liboctave/bsxfun.h
+++ b/liboctave/bsxfun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jordi Guti√©rrez Hermoso <jordigh@octave.org>
+Copyright (C) 2012 Jordi Guti√©rrez Hermoso <jordigh@octave.org>
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -21,48 +21,59 @@ along with Octave; see the file COPYING.
 */
 #if !defined (bsxfun_h)
 #define bsxfun_h 1
 
 #include <algorithm>
 
 #include "Array.h"
 #include "dim-vector.h"
+#include "lo-error.h"
 
 inline
 bool
-is_valid_bsxfun (const dim_vector& dx, const dim_vector& dy)
+is_valid_bsxfun (const std::string& name, const dim_vector& dx,
+                 const dim_vector& dy)
 {
   for (int i = 0; i < std::min (dx.length (), dy.length ()); i++)
     {
       octave_idx_type xk = dx(i), yk = dy(i);
       // Check the three conditions for valid bsxfun dims
       if (! ( (xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
         return false;
     }
+
+  (*current_liboctave_warning_with_id_handler)
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
+
   return true;
 }
 
 // since we can't change the size of the assigned-to matrix, we cannot
 // apply singleton expansion to it, so the conditions to check are
 // different here.
 inline
 bool
-is_valid_inplace_bsxfun (const dim_vector& dr, const dim_vector& dx)
+is_valid_inplace_bsxfun (const std::string& name, const dim_vector& dr,
+                         const dim_vector& dx)
 {
   octave_idx_type drl = dr.length (), dxl = dx.length ();
   if (drl < dxl)
     return false;
 
   for (int i = 0; i < drl; i++)
     {
       octave_idx_type rk = dr(i), xk = dx(i);
 
       // Only two valid canditions to check; can't stretch rk
       if (! ( (rk == xk) || (rk > 1 && xk == 1)))
         return false;
     }
+
+  (*current_liboctave_warning_with_id_handler)
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
+
   return true;
 }
 
 #include "bsxfun-defs.cc"
 
 #endif
diff --git a/liboctave/byte-swap.h b/liboctave/byte-swap.h
--- a/liboctave/byte-swap.h
+++ b/liboctave/byte-swap.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/caseless-str.h b/liboctave/caseless-str.h
--- a/liboctave/caseless-str.h
+++ b/liboctave/caseless-str.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Shai Ayal
+Copyright (C) 2007-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -132,17 +132,17 @@ charMatrix::insert (const charMatrix& a,
 std::string
 charMatrix::row_as_string (octave_idx_type r, bool strip_ws) const
 {
   std::string retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
-  if (r == 0 && nr == 0 && nc == 0)
+  if (r == 0 && (nr == 0 || nc == 0))
     return retval;
 
   if (r < 0 || r >= nr)
     {
       (*current_liboctave_error_handler) ("range error for row_as_string");
       return retval;
     }
 
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
 #include "oct-time.h"
+#include "singleton-cleanup.h"
 
 command_editor *command_editor::instance = 0;
 
 std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
 
 std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
 
 static octave_mutex event_hook_lock;
@@ -826,17 +827,22 @@ default_command_editor::do_accept_line (
 }
 
 bool
 command_editor::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    make_command_editor ();
+    {
+      make_command_editor ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       current_liboctave_error_handler
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -179,16 +179,18 @@ private:
   typedef std::set<startup_hook_fcn>::const_iterator startup_hook_set_const_iterator;
 
   typedef std::set<event_hook_fcn>::iterator event_hook_set_iterator;
   typedef std::set<event_hook_fcn>::const_iterator event_hook_set_const_iterator;
 
   // The real thing.
   static command_editor *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
 protected:
 
   // To use something other than the GNU readline library, derive a new
   // class from command_editor, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_name (const std::string&) { }
 
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
 
 command_history *command_history::instance = 0;
 
 #if defined (USE_READLINE)
 
 #include <cstdlib>
 
@@ -462,17 +463,22 @@ gnu_history::do_clean_up_and_save (const
 #endif
 
 bool
 command_history::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    make_command_history ();
+    {
+      make_command_history ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -121,16 +121,18 @@ private:
 
   static bool instance_ok (void);
 
   static void make_command_history (void);
 
   // The real thing.
   static command_history *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
 protected:
 
   // To use something other than the GNU history library, derive a new
   // class from command_history, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_file (const std::string&);
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/dbleAEPBAL.h
--- a/liboctave/dbleAEPBAL.h
+++ b/liboctave/dbleAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleGEPBAL.h b/liboctave/dbleGEPBAL.h
--- a/liboctave/dbleGEPBAL.h
+++ b/liboctave/dbleGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleHESS.h b/liboctave/dbleHESS.h
--- a/liboctave/dbleHESS.h
+++ b/liboctave/dbleHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleLU.h b/liboctave/dbleLU.h
--- a/liboctave/dbleLU.h
+++ b/liboctave/dbleLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/dbleQR.h b/liboctave/dbleQR.h
--- a/liboctave/dbleQR.h
+++ b/liboctave/dbleQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dbleQRP.h b/liboctave/dbleQRP.h
--- a/liboctave/dbleQRP.h
+++ b/liboctave/dbleQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyirght (C) 2009, 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyirght (C) 2009, 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <cassert>
 #include <limits>
 
 #include <sstream>
 #include <string>
 
 #include "lo-error.h"
 #include "lo-macros.h"
+#include "oct-refcount.h"
 
 // Rationale: This implementation is more tricky than Array, but the
 // big plus is that dim_vector requires only one allocation instead of
 // two.  It is (slightly) patterned after GCC's basic_string
 // implementation.  rep is a pointer to an array of memory, comprising
 // count, length, and the data:
 //
 //          <count>
@@ -123,18 +124,22 @@ private:
     assert (count () == 0);
     delete [] (rep - 2);
   }
 
   void make_unique (void)
   {
     if (count () > 1)
       {
-        --count();
-        rep = clonerep ();
+	octave_idx_type *new_rep = clonerep ();
+
+	if (OCTREFCOUNT_ATOMIC_DECREMENT(&(count())) == 0)
+	  freerep ();
+
+        rep = new_rep;
       }
   }
 
 public:
 
   // The constructor
   //
   //   dim_vector (n)
@@ -217,42 +222,44 @@ private:
 
   explicit dim_vector (octave_idx_type *r)
     : rep (r) { }
 
 public:
 
   static octave_idx_type dim_max (void);
 
-  explicit dim_vector (void) : rep (nil_rep ()) { count()++; }
+  explicit dim_vector (void) : rep (nil_rep ())
+  { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
-  dim_vector (const dim_vector& dv) : rep (dv.rep) { count()++; }
+  dim_vector (const dim_vector& dv) : rep (dv.rep)
+  { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
   static dim_vector alloc (int n)
   {
     return dim_vector (newrep (n < 2 ? 2 : n));
   }
 
   dim_vector& operator = (const dim_vector& dv)
   {
     if (&dv != this)
       {
-        if (--count() <= 0)
+        if (OCTREFCOUNT_ATOMIC_DECREMENT (&(count())) == 0)
           freerep ();
 
         rep = dv.rep;
-        count()++;
+        OCTREFCOUNT_ATOMIC_INCREMENT (&(count()));
       }
 
     return *this;
   }
 
   ~dim_vector (void)
   {
-    if (--count() <= 0)
+    if (OCTREFCOUNT_ATOMIC_DECREMENT (&(count())) == 0)
       freerep ();
   }
 
   int length (void) const { return ndims (); }
 
   octave_idx_type& operator () (int i) { return elem (i); }
 
   octave_idx_type operator () (int i) const { return elem (i); }
@@ -260,17 +267,17 @@ public:
   void resize (int n, int fill_value = 0)
   {
     int len = length ();
 
     if (n != len)
       {
         octave_idx_type *r = resizerep (n, fill_value);
 
-        if (--count() <= 0)
+        if (OCTREFCOUNT_ATOMIC_DECREMENT (&(count())) == 0)
           freerep ();
 
         rep = r;
       }
   }
 
   std::string str (char sep = 'x') const;
 
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -72,17 +72,17 @@ dir_entry::read (void)
   string_vector retval;
 
   if (ok ())
     {
       std::list<std::string> dirlist;
 
       struct dirent *dir_ent;
 
-      while ((dir_ent = readdir (static_cast<DIR *> (dir))))
+      while ((dir_ent = gnulib::readdir (static_cast<DIR *> (dir))))
         {
           if (dir_ent)
             dirlist.push_back (dir_ent->d_name);
           else
             break;
         }
 
       retval = string_vector (dirlist);
diff --git a/liboctave/dir-ops.h b/liboctave/dir-ops.h
--- a/liboctave/dir-ops.h
+++ b/liboctave/dir-ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "SparsedbleCHOL.h"
 #include "SparseCmplxCHOL.h"
 #include "oct-rand.h"
 #include "dbleCHOL.h"
 #include "CmplxCHOL.h"
 #include "dbleLU.h"
 #include "CmplxLU.h"
 
+#ifdef HAVE_ARPACK
 typedef ColumnVector (*EigsFunc) (const ColumnVector &x, int &eigs_error);
 typedef ComplexColumnVector (*EigsComplexFunc)
   (const ComplexColumnVector &x, int &eigs_error);
 
 // Arpack and blas fortran functions we call.
 extern "C"
 {
   F77_RET_T
@@ -3824,16 +3825,17 @@ extern octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string &_typ, Complex sigma,
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &resid, std::ostream& os,
                              double tol = DBL_EPSILON, bool rvec = false,
                              bool cholB = 0, int disp = 0, int maxit = 300);
+#endif
 
 #ifndef _MSC_VER
 template static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 template static octave_idx_type
 lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&,
          ComplexMatrix&);
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -1,12 +1,12 @@
 // DiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxAEPBAL.cc b/liboctave/fCmplxAEPBAL.cc
--- a/liboctave/fCmplxAEPBAL.cc
+++ b/liboctave/fCmplxAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxAEPBAL.h b/liboctave/fCmplxAEPBAL.h
--- a/liboctave/fCmplxAEPBAL.h
+++ b/liboctave/fCmplxAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxCHOL.h b/liboctave/fCmplxCHOL.h
--- a/liboctave/fCmplxCHOL.h
+++ b/liboctave/fCmplxCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxGEPBAL.h b/liboctave/fCmplxGEPBAL.h
--- a/liboctave/fCmplxGEPBAL.h
+++ b/liboctave/fCmplxGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxHESS.h b/liboctave/fCmplxHESS.h
--- a/liboctave/fCmplxHESS.h
+++ b/liboctave/fCmplxHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxLU.cc b/liboctave/fCmplxLU.cc
--- a/liboctave/fCmplxLU.cc
+++ b/liboctave/fCmplxLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxLU.h b/liboctave/fCmplxLU.h
--- a/liboctave/fCmplxLU.h
+++ b/liboctave/fCmplxLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fCmplxQR.h b/liboctave/fCmplxQR.h
--- a/liboctave/fCmplxQR.h
+++ b/liboctave/fCmplxQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fCmplxQRP.h b/liboctave/fCmplxQRP.h
--- a/liboctave/fCmplxQRP.h
+++ b/liboctave/fCmplxQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSCHUR.h b/liboctave/fCmplxSCHUR.h
--- a/liboctave/fCmplxSCHUR.h
+++ b/liboctave/fCmplxSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSVD.cc b/liboctave/fCmplxSVD.cc
--- a/liboctave/fCmplxSVD.cc
+++ b/liboctave/fCmplxSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fCmplxSVD.h b/liboctave/fCmplxSVD.h
--- a/liboctave/fCmplxSVD.h
+++ b/liboctave/fCmplxSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -1,12 +1,12 @@
 // ColumnVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -1,12 +1,12 @@
 // FloatDiagMatrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fEIG.h b/liboctave/fEIG.h
--- a/liboctave/fEIG.h
+++ b/liboctave/fEIG.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -1,12 +1,12 @@
 // Matrix manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -1,12 +1,12 @@
 // RowVector manipulations.
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -37,21 +37,22 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "pathmax.h"
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
+#include "oct-locbuf.h"
 #include "oct-passwd.h"
 #include "pathlen.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "oct-locbuf.h"
 
 file_ops *file_ops::instance = 0;
 
 bool
 file_ops::instance_ok (void)
 {
   bool retval = true;
 
@@ -68,23 +69,26 @@ file_ops::instance_ok (void)
       std::string system_dir_sep_chars = "/\\";
 #else
       std::string system_dir_sep_chars = system_dir_sep_str;
 #endif
 
       instance = new file_ops (system_dir_sep_char, system_dir_sep_str,
                                system_dir_sep_chars);
 
-      if (! instance)
-        {
-          (*current_liboctave_error_handler)
-            ("unable to create file_ops object!");
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
-          retval = false;
-        }
+  if (! instance)
+    {
+      (*current_liboctave_error_handler)
+        ("unable to create file_ops object!");
+
+      retval = false;
     }
 
   return retval;
 }
 
 // The following tilde-expansion code was stolen and adapted from
 // readline.
 
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -94,16 +94,18 @@ public:
 
     return path.substr (ipos);
   }
 
 private:
 
   static file_ops *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // No copying!
 
   file_ops (const file_ops&);
 
   file_ops& operator = (const file_ops&);
 
   static bool instance_ok (void);
 
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/file-stat.h b/liboctave/file-stat.h
--- a/liboctave/file-stat.h
+++ b/liboctave/file-stat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatAEPBAL.cc b/liboctave/floatAEPBAL.cc
--- a/liboctave/floatAEPBAL.cc
+++ b/liboctave/floatAEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatAEPBAL.h b/liboctave/floatAEPBAL.h
--- a/liboctave/floatAEPBAL.h
+++ b/liboctave/floatAEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatCHOL.h b/liboctave/floatCHOL.h
--- a/liboctave/floatCHOL.h
+++ b/liboctave/floatCHOL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatGEPBAL.h b/liboctave/floatGEPBAL.h
--- a/liboctave/floatGEPBAL.h
+++ b/liboctave/floatGEPBAL.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatHESS.cc b/liboctave/floatHESS.cc
--- a/liboctave/floatHESS.cc
+++ b/liboctave/floatHESS.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatHESS.h b/liboctave/floatHESS.h
--- a/liboctave/floatHESS.h
+++ b/liboctave/floatHESS.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatLU.cc b/liboctave/floatLU.cc
--- a/liboctave/floatLU.cc
+++ b/liboctave/floatLU.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatLU.h b/liboctave/floatLU.h
--- a/liboctave/floatLU.h
+++ b/liboctave/floatLU.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/floatQR.h b/liboctave/floatQR.h
--- a/liboctave/floatQR.h
+++ b/liboctave/floatQR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/floatQRP.h b/liboctave/floatQRP.h
--- a/liboctave/floatQRP.h
+++ b/liboctave/floatQRP.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSCHUR.cc b/liboctave/floatSCHUR.cc
--- a/liboctave/floatSCHUR.cc
+++ b/liboctave/floatSCHUR.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSCHUR.h b/liboctave/floatSCHUR.h
--- a/liboctave/floatSCHUR.h
+++ b/liboctave/floatSCHUR.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/floatSVD.h b/liboctave/floatSVD.h
--- a/liboctave/floatSVD.h
+++ b/liboctave/floatSVD.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/functor.h b/liboctave/functor.h
--- a/liboctave/functor.h
+++ b/liboctave/functor.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 John W. Eaton
+Copyright (C) 2008-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/glob-match.cc b/liboctave/glob-match.cc
--- a/liboctave/glob-match.cc
+++ b/liboctave/glob-match.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -326,17 +326,20 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type[len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
+      {
+        delete [] data;
         gripe_invalid_index ();
+      }
     }
 }
 
 // Note that this makes a shallow copy of the index array.
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda)
   : data (inda.data ()), len (inda.numel ()), ext (0),
     aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 class NDArray;
 
 template <class T>
 class
 intNDArray : public MArray<T>
 {
 public:
 
-  using MArray<T>::element_type;
+  using typename MArray<T>::element_type;
 
   intNDArray (void) : MArray<T> () { }
 
   intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
   intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
 
   intNDArray (const dim_vector& dv, T val)
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -220,20 +220,16 @@ extern "C" {
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1); DEBUGF_END ()
 #define DEBUGF2(str, e1, e2)                                            \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2); DEBUGF_END ()
 #define DEBUGF3(str, e1, e2, e3)                                        \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3); DEBUGF_END ()
 #define DEBUGF4(str, e1, e2, e3, e4)                                    \
   DEBUGF_START (); gnulib::fprintf (stderr, str, e1, e2, e3, e4); DEBUGF_END ()
 
-#undef fopen
-#define fopen kpse_fopen_trace
-static FILE *fopen (const char *filename, const char *mode);
-
 #endif /* not NO_DEBUG */
 
 #ifdef KPSE_DEBUG
 static unsigned int kpathsea_debug = 0;
 #endif
 
 #if defined (WIN32) && !defined (__MINGW32__)
 
@@ -357,21 +353,25 @@ kpse_is_env_sep (char c)
 
 static FILE *
 xfopen (const std::string& filename, const char *mode)
 {
   FILE *f;
 
   assert (! filename.empty () && mode);
 
-  f = fopen (filename.c_str (), mode);
+  f = gnulib::fopen (filename.c_str (), mode);
 
   if (! f)
     FATAL_PERROR (filename.c_str ());
 
+  if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
+    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename.c_str (), mode,
+             reinterpret_cast<unsigned long> (f));
+
   return f;
 }
 
 /* A single (key,value) pair.  */
 
 struct hash_element_type
 {
   std::string key;
@@ -2277,17 +2277,17 @@ do_subdir (str_llist_type *str_list_ptr,
       /* If we do have something to match, see if it exists.  For
          example, POST might be `pk/ljfour', and they might have a
          directory `$TEXMF/fonts/pk/ljfour' that we should find.  */
       name += post;
       expand_elt (str_list_ptr, name, elt_length);
       name.resize (elt_length);
     }
 
-  while ((e = readdir (dir)))
+  while ((e = gnulib::readdir (dir)))
     {
       /* If it begins with a `.', never mind.  (This allows ``hidden''
          directories that the algorithm won't find.)  */
 
       if (e->d_name[0] != '.')
         {
           int links;
 
@@ -2441,38 +2441,16 @@ xclosedir (DIR *d)
 {
   int ret = gnulib::closedir (d);
 
   if (ret != 0)
     FATAL ("closedir failed");
 }
 #endif
 
-/* Help the user discover what's going on.  */
-
-#ifdef KPSE_DEBUG
-
-/* If the real definitions of fopen or fclose are macros, we lose -- the
-   #undef won't restore them. */
-
-static FILE *
-fopen (const char *filename, const char *mode)
-{
-#undef fopen
-  FILE *ret = fopen (filename, mode);
-
-  if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
-    DEBUGF3 ("fopen (%s, %s) => 0x%lx\n", filename, mode,
-             reinterpret_cast<unsigned long> (ret));
-
-  return ret;
-}
-
-#endif
-
 /* Implementation of a linked list of strings.  */
 
 /* Add the new string STR to the end of the list L.  */
 
 static void
 str_llist_add (str_llist_type *l, const std::string& str)
 {
   str_llist_elt_type *e;
diff --git a/liboctave/lo-array-gripes.cc b/liboctave/lo-array-gripes.cc
--- a/liboctave/lo-array-gripes.cc
+++ b/liboctave/lo-array-gripes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-array-gripes.h b/liboctave/lo-array-gripes.h
--- a/liboctave/lo-array-gripes.h
+++ b/liboctave/lo-array-gripes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cieee.c b/liboctave/lo-cieee.c
--- a/liboctave/lo-cieee.c
+++ b/liboctave/lo-cieee.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cutils.c b/liboctave/lo-cutils.c
--- a/liboctave/lo-cutils.c
+++ b/liboctave/lo-cutils.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-cutils.h b/liboctave/lo-cutils.h
--- a/liboctave/lo-cutils.h
+++ b/liboctave/lo-cutils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-macros.h b/liboctave/lo-macros.h
--- a/liboctave/lo-macros.h
+++ b/liboctave/lo-macros.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-mappers.h b/liboctave/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/lo-mappers.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-math.h b/liboctave/lo-math.h
--- a/liboctave/lo-math.h
+++ b/liboctave/lo-math.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -847,16 +847,23 @@ zbesi (const Complex& z, double alpha, i
           yi *= expz;
         }
 
       if (zi == 0.0 && zr >= 0.0)
         yi = 0.0;
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
+  else if (is_integer_value (alpha))
+    {
+      // zbesi can overflow as z->0, and cause troubles for generic case below
+      alpha = -alpha;
+      Complex tmp = zbesi (z, alpha, kode, ierr);
+      retval = bessel_return_value (tmp, ierr);
+    }
   else
     {
       alpha = -alpha;
 
       Complex tmp = zbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -72,17 +72,17 @@ octave_chdir (const std::string& path_ar
 {
   std::string path = file_ops::tilde_expand (path_arg);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   if (path.length() == 2 && path[1] == ':')
     path += "\\";
 #endif
 
-  return chdir (path.c_str ());
+  return gnulib::chdir (path.c_str ());
 }
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 pid_t
 octave_popen2 (const std::string& cmd, const string_vector& args, bool sync_mode,
     int *fildes, std::string& msg)
 {
@@ -136,78 +136,8 @@ octave_popen2 (const std::string& cmd, c
   CloseHandle (childWrite);
   CloseHandle (pi.hProcess);
   CloseHandle (pi.hThread);
 
   return pid;
 }
 
 #endif
-
-#if defined (_MSC_VER) && ! defined (HAVE_DIRENT_H)
-
-// FIXME -- it would probably be better to adapt the versions of
-// opendir, readdir, and closedir from Emacs as they appear to be more
-// complete implementations (do the functions below work for network
-// paths, for example)?  We can probably get along without rewinddir.
-
-struct __DIR
-{
-  HANDLE hnd;
-  WIN32_FIND_DATA fd;
-  int dirty;
-  struct direct d;
-  const char *current;
-};
-
-DIR *
-opendir (const char *name)
-{
-  DIR *d = static_cast<DIR *> (malloc (sizeof (DIR)));
-  static char buffer[MAX_PATH];
-
-  strncpy (buffer, name, MAX_PATH);
-  if (buffer[strnlen(buffer, MAX_PATH)-1] != '\\')
-    strncat (buffer, "\\*", MAX_PATH);
-  else
-    strncat (buffer, "*", MAX_PATH);
-  d->current = buffer;
-  d->hnd = FindFirstFile (buffer, &(d->fd));
-  if (d->hnd == INVALID_HANDLE_VALUE)
-    {
-      free (d);
-      return 0;
-    }
-  d->dirty = 1;
-  return d;
-}
-
-void
-rewinddir (DIR *d)
-{
-  if (d->hnd != INVALID_HANDLE_VALUE)
-    FindClose (d->hnd);
-  d->hnd = FindFirstFile (d->current, &(d->fd));
-  d->dirty = 1;
-}
-
-void
-closedir (DIR *d)
-{
-  if (d->hnd != INVALID_HANDLE_VALUE)
-    FindClose (d->hnd);
-  free (d);
-}
-
-struct direct *
-readdir (DIR *d)
-{
-  if (! d->dirty)
-    {
-      if (! FindNextFile(d->hnd, &(d->fd)))
-        return 0;
-    }
-  d->d.d_name = d->fd.cFileName;
-  d->dirty = 0;
-  return &(d->d);
-}
-
-#endif
diff --git a/liboctave/lo-sysdep.h b/liboctave/lo-sysdep.h
--- a/liboctave/lo-sysdep.h
+++ b/liboctave/lo-sysdep.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -32,30 +32,9 @@ extern std::string octave_getcwd (void);
 
 extern int octave_chdir (const std::string&);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 extern pid_t octave_popen2 (const std::string&, const string_vector&,
     bool, int *, std::string&);
 #endif
 
-#if defined (_MSC_VER) && ! defined (HAVE_DIRENT_H)
-
-// FIXME -- it would probably be better to adapt the versions of
-// opendir, readdir, and closedir from Emacs as they appear to be more
-// complete implementations.  We can probably get along without
-// rewinddir.
-
-struct direct
-{
-  char *d_name;
-};
-
-typedef struct __DIR DIR;
-
-extern DIR* opendir (const char *name);
-extern void rewinddir (DIR *d);
-extern void closedir (DIR *d);
-extern struct direct *readdir (DIR *d);
-
 #endif
-
-#endif
diff --git a/liboctave/lo-traits.h b/liboctave/lo-traits.h
--- a/liboctave/lo-traits.h
+++ b/liboctave/lo-traits.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -1,12 +1,12 @@
 // utils.cc
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "mach-info.h"
+#include "singleton-cleanup.h"
 
 extern "C"
 {
   double F77_FUNC (d1mach, D1MACH) (const octave_idx_type&);
 }
 
 oct_mach_info *oct_mach_info::instance = 0;
 
@@ -158,17 +159,22 @@ oct_mach_info::oct_mach_info (void)
     big_chief (ten_little_endians ()) { }
 
 bool
 oct_mach_info::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new oct_mach_info ();
+    {
+      instance = new oct_mach_info ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/mach-info.h b/liboctave/mach-info.h
--- a/liboctave/mach-info.h
+++ b/liboctave/mach-info.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -56,16 +56,18 @@ public:
   static float_format string_to_float_format (const std::string&);
 
   static std::string float_format_as_string (float_format);
 
 private:
 
   static oct_mach_info *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // The floating point format for the current machine.
   mutable float_format native_float_fmt;
 
   // TRUE if the byte order on this system is big endian.
   mutable bool big_chief;
 
   // No copying!
 
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/mx-base.h b/liboctave/mx-base.h
--- a/liboctave/mx-base.h
+++ b/liboctave/mx-base.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-defs.h b/liboctave/mx-defs.h
--- a/liboctave/mx-defs.h
+++ b/liboctave/mx-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-ext.h b/liboctave/mx-ext.h
--- a/liboctave/mx-ext.h
+++ b/liboctave/mx-ext.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -367,17 +367,17 @@ do_mm_binary_op (const Array<X>& x, cons
 {
   dim_vector dx = x.dims (), dy = y.dims ();
   if (dx == dy)
     {
       Array<R> r (dx);
       op (r.length (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
-  else if (is_valid_bsxfun (dx, dy))
+  else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
     {
       gripe_nonconformant (opname, dx, dy);
       return Array<R> ();
     }
@@ -410,17 +410,17 @@ do_mm_inplace_op (Array<R>& r, const Arr
                   void (*op1) (size_t, R *, X) throw (),
                   const char *opname)
 {
   dim_vector dr = r.dims (), dx = x.dims ();
   if (dr == dx)
     {
       op (r.length (), r.fortran_vec (), x.data ());
     }
-  else if (is_valid_inplace_bsxfun (dr, dx))
+  else if (is_valid_inplace_bsxfun (opname, dr, dx))
     {
       do_inplace_bsxfun_op (r, x, op, op1);
     }
   else
     gripe_nonconformant (opname, dr, dx);
   return r;
 }
 
diff --git a/liboctave/mx-op-decl.h b/liboctave/mx-op-decl.h
--- a/liboctave/mx-op-decl.h
+++ b/liboctave/mx-op-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/mx-ops b/liboctave/mx-ops
--- a/liboctave/mx-ops
+++ b/liboctave/mx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
--- a/liboctave/oct-alloc.h
+++ b/liboctave/oct-alloc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -169,17 +169,17 @@ binmap (const Array<T>& xa, const Array<
 {
   dim_vector xad = xa.dims (), yad = ya.dims ();
   if (xa.numel () == 1)
     return binmap<U, T, R, F> (xa(0), ya, fcn);
   else if (ya.numel () == 1)
     return binmap<U, T, R, F> (xa, ya(0), fcn);
   else if (xad != yad)
     {
-      if (is_valid_bsxfun (xad, yad))
+      if (is_valid_bsxfun (name, xad, yad))
         {
           bsxfun_wrapper<U, T, R, F>::set_f(fcn);
           return do_bsxfun_op (xa, ya,
                                bsxfun_wrapper<U, T, R, F>::op_mm,
                                bsxfun_wrapper<U, T, R, F>::op_sm,
                                bsxfun_wrapper<U, T, R, F>::op_ms);
         }
       else
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -132,17 +132,17 @@ convolve (const MArray<T>& a, const MArr
                      c.fortran_vec (), cdims.cumulative (), nd, ct == convn_valid);
 
   if (ct == convn_same)
     {
       // Pick the relevant part.
       Array<idx_vector> sidx (dim_vector (nd, 1));
 
       for (int i = 0; i < nd; i++)
-        sidx(i) = idx_vector::make_range ((bdims(i)-1)/2, 1, adims(i));
+        sidx(i) = idx_vector::make_range (bdims(i)/2, 1, adims(i));
       c = c.index (sidx);
     }
 
   return c;
 }
 
 #define CONV_DEFS(TPREF, RPREF) \
 TPREF ## NDArray \
diff --git a/liboctave/oct-convn.h b/liboctave/oct-convn.h
--- a/liboctave/oct-convn.h
+++ b/liboctave/oct-convn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -53,16 +53,17 @@ Free Software Foundation, Inc.
 
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-sysdep.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
 #include "oct-syscalls.h"
+#include "singleton-cleanup.h"
 
 octave_env::octave_env (void)
   : follow_symbolic_links (true), verbatim_pwd (true),
     current_directory (), prog_name (), prog_invocation_name (),
     user_name (), host_name ()
 {
   // Get a real value for the current directory.
   do_getcwd ();
@@ -76,17 +77,22 @@ octave_env::octave_env (void)
 octave_env *octave_env::instance = 0;
 
 bool
 octave_env::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_env ();
+    {
+      instance = new octave_env ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create current working directory object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-env.h b/liboctave/oct-env.h
--- a/liboctave/oct-env.h
+++ b/liboctave/oct-env.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -110,16 +110,19 @@ private:
 
   octave_env (const octave_env&);
 
   octave_env& operator = (const octave_env&);
 
   // The real thing.
   static octave_env *instance;
 
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // TRUE means follow symbolic links that point to directories just
   // as if they are real directories.
   bool follow_symbolic_links;
 
   // TRUE means that pwd always give verbatim directory, regardless
   // of symbolic link following.
   bool verbatim_pwd;
 
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton
+Copyright (C) 2001-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -28,59 +28,81 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "lo-error.h"
 #include "oct-fftw.h"
 #include "quit.h"
 #include "oct-locbuf.h"
+#include "singleton-cleanup.h"
 
 octave_fftw_planner *octave_fftw_planner::instance = 0;
 
-// Helper class to create and cache fftw plans for both 1d and
-// 2d. This implementation defaults to using FFTW_ESTIMATE to create
-// the plans, which in theory is suboptimal, but provides quit
-// reasonable performance.
+// Helper class to create and cache FFTW plans for both 1D and
+// 2D. This implementation defaults to using FFTW_ESTIMATE to create
+// the plans, which in theory is suboptimal, but provides quite
+// reasonable performance in practice.
 
-// Also note that if FFTW_ESTIMATE is not used the planner in FFTW3
-// destroys the input and output arrays. We must therefore create a
+// Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
+// will destroy the input and output arrays. We must, therefore, create a
 // temporary input array with the same size and 16-byte alignment as
-// the original array and use that for the planner. Note that we also
-// use any wisdom that is available, either in a FFTW3 system wide file
-//  or as supplied by the user.
+// the original array when using a different planner strategy.
+// Note that we also use any wisdom that is available, either in a
+// FFTW3 system wide file or as supplied by the user.
 
 // FIXME -- if we can ensure 16 byte alignment in Array<T>
 // (<T> *data) the FFTW3 can use SIMD instructions for further
 // acceleration.
 
-// Note that it is profitable to store the FFTW3 plans, for small
-// ffts.
+// Note that it is profitable to store the FFTW3 plans, for small FFTs.
 
 octave_fftw_planner::octave_fftw_planner (void)
   : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
   // If we have a system wide wisdom file, import it.
   fftw_import_system_wisdom ();
 }
 
+octave_fftw_planner::~octave_fftw_planner (void)
+{
+  fftw_plan *plan_p;
+
+  plan_p = &rplan;
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+
+  plan_p = &plan[0];
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+
+  plan_p = &plan[1];
+  if (*plan_p)
+    fftw_destroy_plan (*plan_p);
+}
+
 bool
 octave_fftw_planner::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_fftw_planner ();
+    {
+      instance = new octave_fftw_planner ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_fftw_planner object!");
 
       retval = false;
     }
@@ -372,23 +394,45 @@ octave_float_fftw_planner::octave_float_
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
 
   // If we have a system wide wisdom file, import it.
   fftwf_import_system_wisdom ();
 }
 
+octave_float_fftw_planner::~octave_float_fftw_planner (void)
+{
+  fftwf_plan *plan_p;
+
+  plan_p = &rplan;
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+
+  plan_p = &plan[0];
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+
+  plan_p = &plan[1];
+  if (*plan_p)
+    fftwf_destroy_plan (*plan_p);
+}
+
 bool
 octave_float_fftw_planner::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_float_fftw_planner ();
+    {
+      instance = new octave_float_fftw_planner ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_fftw_planner object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton
+Copyright (C) 2001-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -39,17 +39,17 @@ OCTAVE_API
 octave_fftw_planner
 {
 protected:
 
   octave_fftw_planner (void);
 
 public:
 
-  ~octave_fftw_planner (void) { }
+  ~octave_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
     EXHAUSTIVE,
@@ -103,16 +103,18 @@ private:
   // No copying!
 
   octave_fftw_planner (const octave_fftw_planner&);
 
   octave_fftw_planner& operator = (const octave_fftw_planner&);
 
   static octave_fftw_planner *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   fftw_plan
   do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const Complex *in,
                   Complex *out);
 
   fftw_plan
   do_create_plan (const int rank, const dim_vector dims,
@@ -174,17 +176,17 @@ OCTAVE_API
 octave_float_fftw_planner
 {
 protected:
 
   octave_float_fftw_planner (void);
 
 public:
 
-  ~octave_float_fftw_planner (void) { }
+  ~octave_float_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
     EXHAUSTIVE,
@@ -238,16 +240,18 @@ private:
   // No copying!
 
   octave_float_fftw_planner (const octave_float_fftw_planner&);
 
   octave_float_fftw_planner& operator = (const octave_float_fftw_planner&);
 
   static octave_float_fftw_planner *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   fftwf_plan
   do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const FloatComplex *in,
                   FloatComplex *out);
 
   fftwf_plan
   do_create_plan (const int rank, const dim_vector dims,
diff --git a/liboctave/oct-glob.cc b/liboctave/oct-glob.cc
--- a/liboctave/oct-glob.cc
+++ b/liboctave/oct-glob.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 John W. Eaton
+Copyright (C) 2010-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-glob.h b/liboctave/oct-glob.h
--- a/liboctave/oct-glob.h
+++ b/liboctave/oct-glob.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 John W. Eaton
+Copyright (C) 2010-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -361,18 +361,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division with rounding to nearest. Note that / and % are probably
   // computed by a single instruction.
   static T
   div (T x, T y)
     {
       if (y != 0)
@@ -616,18 +616,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division.
   static T
   div (T x, T y)
     {
       T z;
       if (y == 0)
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -20,85 +20,128 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
+
+#include "lo-error.h"
 #include "oct-locbuf.h"
 
-// Query for configured chunk size, and if not defined, set it to 32 MB.
-// FIXME: 32MB is hard-coded. Maybe we could use something better, like
-// querying for available physical memory.
+// FIXME -- Maybe we should querying for available physical memory?
+
 #ifndef OCTAVE_LOCBUF_CHUNKSIZE_MB
 #define OCTAVE_LOCBUF_CHUNKSIZE_MB 32
 #endif
 
 // Each chunk will be at least this big.
+
 const size_t octave_chunk_buffer::chunk_size =
   static_cast<size_t> (OCTAVE_LOCBUF_CHUNKSIZE_MB) << 20;
 
-char *octave_chunk_buffer::top = 0, *octave_chunk_buffer::chunk = 0;
+char *octave_chunk_buffer::top = 0;
+char *octave_chunk_buffer::chunk = 0;
 size_t octave_chunk_buffer::left = 0;
+size_t octave_chunk_buffer::active = 0;
 
 octave_chunk_buffer::octave_chunk_buffer (size_t size) : cnk (0), dat (0)
 {
-  // Alignment mask. The size of double or long int, whichever is greater.
-  // All data will be aligned to this size. If it's not enough for a type,
-  // that type should not be declared as POD.
+  // Alignment mask. The size of double or long int, whichever is
+  // greater.  All data will be aligned to this size.  If it's not
+  // enough for a type, that type should not be declared as POD.
+
   static const size_t align_mask = (sizeof (long) < sizeof (double)
                                     ? sizeof (double)
                                     : sizeof (long)) - 1;
 
-  if (! size) return;
+  active++;
+
+  if (! size)
+    return;
+
   // Align size. Note that size_t is unsigned, so size-1 must correctly
   // wrap around.
+
   size = ((size - 1) | align_mask) + 1;
 
   if (size > left)
     {
       // Big buffers (> 1/8 chunk) will be allocated as stand-alone and
       // won't disrupt the chain.
+
       if (size > chunk_size >> 3)
         {
-          // Use new [] to get std::bad_alloc if out of memory. Could as
-          // well be std::malloc and handle that ourselves.
+          // Use new [] to get std::bad_alloc if out of memory.
+
           dat = new char [size];
           return;
         }
 
       dat = new char [chunk_size];
       chunk = top = dat;
       left = chunk_size;
     }
 
   // Now allocate memory from the chunk and update state.
+
   cnk = chunk;
   dat = top;
   left -= size;
   top += size;
 }
 
 octave_chunk_buffer::~octave_chunk_buffer (void)
 {
+  active--;
+
   if (cnk == chunk)
     {
-      // Our chunk is still the active one. Just restore the state.
+      // Our chunk is still the active one.  Just restore the state.
+
       left += top - dat;
       top = dat;
     }
-  else if (! cnk)
+  else
     {
-      // We were a stand-alone buffer.
-      delete [] dat;
+      if (cnk)
+        {
+          // Responsible for deletion.
+
+          delete [] chunk;
+          chunk = cnk;
+          top = dat;
+
+          // FIXME -- the following calcuation of remaining data will
+          // only work if each chunk has the same chunk_size.
+
+          left = chunk_size - (dat - cnk);
+        }
+      else
+        {
+          // We were a stand-alone buffer.
+
+          delete [] dat;
+        }
+    }
+}
+
+// Clear the final chunk of allocated memory.
+
+void
+octave_chunk_buffer::clear (void)
+{
+  if (active == 0)
+    {
+      delete [] chunk;
+      chunk = 0;
+      top = 0;
+      left = 0;
     }
   else
     {
-      // Responsible for deletion.
-      delete [] chunk;
-      chunk = cnk;
-      top = dat;
-      // FIXME: This will only work if chunk_size is constant.
-      left = chunk_size - (dat - cnk);
+      (*current_liboctave_warning_handler)
+        ("octave_chunk_buffer::clear: %d active allocations remain!",
+         active);
     }
 }
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -21,18 +21,19 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_local_buffer_h)
 #define octave_local_buffer_h 1
 
 #include <cstddef>
 #include "oct-cmplx.h"
 
-// The default local buffer simply encapsulates an *array* pointer that gets
-// delete[]d automatically. For common POD types, we provide specializations.
+// The default local buffer simply encapsulates an *array* pointer
+// that gets deleted automatically.  For common POD types, we provide
+// specializations.
 
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
     {
@@ -45,54 +46,72 @@ public:
 private:
   T *data;
 
   // No copying!
   octave_local_buffer (const octave_local_buffer&);
   octave_local_buffer& operator = (const octave_local_buffer&);
 };
 
-// For buffers of POD types, we'll be more smart. There is one thing that
-// differentiates a local buffer from a dynamic array - the local buffers, if
-// not manipulated improperly, have a FIFO semantics, meaning that if buffer B
-// is allocated after buffer A, B *must* be deallocated before A. This is
-// *guaranteed* if you use local buffer exclusively through the
-// OCTAVE_LOCAL_BUFFER macro, because the C++ standard *mandates* explicit
-// local objects be destroyed in reverse order of declaration.
-// Therefore, we can avoid memory fragmentation by allocating fairly large
-// chunks of memory and serving local buffers from them in a stack-like manner.
-// The first returning buffer in previous chunk will be responsible for
+// For buffers of POD types, we'll be smarter.  There is one thing
+// that differentiates a local buffer from a dynamic array - the local
+// buffers, if not manipulated improperly, have a FIFO semantics,
+// meaning that if buffer B is allocated after buffer A, B *must* be
+// deallocated before A.  This is *guaranteed* if you use local buffer
+// exclusively through the OCTAVE_LOCAL_BUFFER macro, because the C++
+// standard requires that explicit local objects be destroyed in
+// reverse order of declaration.  Therefore, we can avoid memory
+// fragmentation by allocating fairly large chunks of memory and
+// serving local buffers from them in a stack-like manner.  The first
+// returning buffer in previous chunk will be responsible for
 // deallocating the chunk.
 
 class octave_chunk_buffer
 {
 public:
 
   OCTAVE_API octave_chunk_buffer (size_t size);
 
   OCTAVE_API virtual ~octave_chunk_buffer (void);
 
   char *data (void) const { return dat; }
 
+  static OCTAVE_API void clear (void);
+
 private:
+
+  // The number of bytes we allocate for each large chunk of memory we
+  // manage.
   static const size_t chunk_size;
 
-  static char *top, *chunk;
+  // Pointer to the end end of the last allocation.
+  static char *top;
+
+  // Pointer to the current active chunk.
+  static char *chunk;
+
+  // The number of bytes remaining in the active chunk.
   static size_t left;
 
+  // The number of active allocations.
+  static size_t active;
+
+  // Pointer to the current chunk.
   char *cnk;
+
+  // Pointer to the beginning of the most recent allocation.
   char *dat;
 
   // No copying!
   octave_chunk_buffer (const octave_chunk_buffer&);
   octave_chunk_buffer& operator = (const octave_chunk_buffer&);
 };
 
-// This specializes octave_local_buffer to use the chunked buffer mechanism
-// for POD types.
+// This specializes octave_local_buffer to use the chunked buffer
+// mechanism for POD types.
 #define SPECIALIZE_POD_BUFFER(TYPE) \
 template <> \
 class octave_local_buffer<TYPE> : private octave_chunk_buffer \
 { \
 public: \
   octave_local_buffer (size_t size) \
     : octave_chunk_buffer (size * sizeof (TYPE)) { } \
  \
@@ -138,51 +157,57 @@ public:
     { }
 
   operator const T **() const
   {
     return reinterpret_cast<const T **> (this->data ());
   }
 };
 
-// If the compiler supports dynamic stack arrays, we can use the attached hack
-// to place small buffer arrays on the stack. It may be even faster than our
-// obstack-like optimization, but is dangerous because stack is a very limited
-// resource, so we disable it.
-#if 0 //defined (HAVE_DYNAMIC_AUTO_ARRAYS)
+// If the compiler supports dynamic stack arrays, we can use the
+// attached hack to place small buffer arrays on the stack. It may be
+// even faster than our obstack-like optimization, but is dangerous
+// because stack is a very limited resource, so we disable it.
+
+#if 0 // defined (HAVE_DYNAMIC_AUTO_ARRAYS)
 
 // Maximum buffer size (in bytes) to be placed on the stack.
 
 #define OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE 8192
 
-// If we have automatic arrays, we use an automatic array if the size is small
-// enough.  To avoid possibly evaluating `size' multiple times, we first cache
-// it.  Note that we always construct both the stack array and the
-// octave_local_buffer object, but only one of them will be nonempty.
+// If we have automatic arrays, we use an automatic array if the size
+// is small enough.  To avoid possibly evaluating `size' multiple
+// times, we first cache it.  Note that we always construct both the
+// stack array and the octave_local_buffer object, but only one of
+// them will be nonempty.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   const size_t _bufsize_ ## buf = size; \
   const bool _lbufaut_ ## buf = _bufsize_ ## buf * sizeof (T) \
      <= OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE; \
   T _bufaut_ ## buf [_lbufaut_ ## buf ? _bufsize_ ## buf : 0]; \
-  octave_local_buffer<T> _bufheap_ ## buf (!_lbufaut_ ## buf ? _bufsize_ ## buf : 0); \
-  T *buf = _lbufaut_ ## buf ? _bufaut_ ## buf : static_cast<T *> (_bufheap_ ## buf)
+  octave_local_buffer<T> _bufheap_ ## buf \
+    (!_lbufaut_ ## buf ? _bufsize_ ## buf : 0); \
+  T *buf = _lbufaut_ ## buf \
+    ? _bufaut_ ## buf : static_cast<T *> (_bufheap_ ## buf)
 
 #else
 
-// If we don't have automatic arrays, we simply always use octave_local_buffer.
+// If we don't have automatic arrays, we simply always use
+// octave_local_buffer.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   octave_local_buffer<T> _buffer_ ## buf (size); \
   T *buf = _buffer_ ## buf
 
 #endif
 
-// Yeah overloading macros would be nice.
-// Note: we use weird variables in the for loop to avoid warnings about
-// shadowed parameters.
+// Note: we use weird variables in the for loop to avoid warnings
+// about shadowed parameters.
+
 #define OCTAVE_LOCAL_BUFFER_INIT(T, buf, size, value) \
   OCTAVE_LOCAL_BUFFER(T, buf, size); \
   for (size_t _buf_iter = 0, _buf_size = size; \
-       _buf_iter < _buf_size; _buf_iter++) buf[_buf_iter] = value
+        _buf_iter < _buf_size; _buf_iter++) \
+    buf[_buf_iter] = value
 
 #endif
 
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -57,17 +57,17 @@ oct_md5 (const std::string str)
   return oct_md5_result_to_str (buf);
 }
 
 std::string
 oct_md5_file (const std::string file)
 {
   std::string retval;
 
-  FILE *ifile = fopen (file.c_str (), "rb");
+  FILE *ifile = gnulib::fopen (file.c_str (), "rb");
 
   if (ifile)
     {
       unsigned char buf[16];
 
       int errflag = md5_stream (ifile, buf);
 
       gnulib::fclose (ifile);
diff --git a/liboctave/oct-md5.h b/liboctave/oct-md5.h
--- a/liboctave/oct-md5.h
+++ b/liboctave/oct-md5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mutex.cc b/liboctave/oct-mutex.cc
--- a/liboctave/oct-mutex.cc
+++ b/liboctave/oct-mutex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-mutex.h b/liboctave/oct-mutex.h
--- a/liboctave/oct-mutex.h
+++ b/liboctave/oct-mutex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -18,16 +18,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_octave_mutex_h)
 #define octave_octave_mutex_h 1
 
+#include "oct-refcount.h"
+
 class octave_mutex;
 
 class
 octave_base_mutex
 {
 public:
   friend class octave_mutex;
 
@@ -37,17 +39,17 @@ public:
 
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool try_lock (void);
 
 private:
-  int count;
+  octave_refcount<int> count;
 };
 
 class
 OCTAVE_API
 octave_mutex
 {
 public:
   octave_mutex (void);
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-norm.h b/liboctave/oct-norm.h
--- a/liboctave/oct-norm.h
+++ b/liboctave/oct-norm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-openmp.h b/liboctave/oct-openmp.h
--- a/liboctave/oct-openmp.h
+++ b/liboctave/oct-openmp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 David Bateman
+Copyright (C) 2010-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-passwd.cc b/liboctave/oct-passwd.cc
--- a/liboctave/oct-passwd.cc
+++ b/liboctave/oct-passwd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -24,28 +24,29 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <map>
 #include <vector>
 
 #include <stdint.h>
 
+#include "data-conv.h"
 #include "f77-fcn.h"
+#include "lo-error.h"
 #include "lo-ieee.h"
-#include "lo-error.h"
 #include "lo-mappers.h"
+#include "mach-info.h"
+#include "oct-locbuf.h"
 #include "oct-rand.h"
 #include "oct-time.h"
-#include "data-conv.h"
+#include "randgamma.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
-#include "randgamma.h"
-#include "mach-info.h"
-#include "oct-locbuf.h"
+#include "singleton-cleanup.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgennor, DGENNOR) (const double&, const double&, double&);
 
   F77_RET_T
   F77_FUNC (dgenunf, DGENUNF) (const double&, const double&, double&);
@@ -84,17 +85,22 @@ octave_rand::octave_rand (void)
 }
 
 bool
 octave_rand::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_rand ();
+    {
+      instance = new octave_rand ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_rand object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -155,16 +155,18 @@ public:
   {
     return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
   }
 
 private:
 
   static octave_rand *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   enum
   {
     unknown_dist,
     uniform_dist,
     normal_dist,
     expon_dist,
     poisson_dist,
     gamma_dist
diff --git a/liboctave/oct-refcount.h b/liboctave/oct-refcount.h
--- a/liboctave/oct-refcount.h
+++ b/liboctave/oct-refcount.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Jaroslav Hajek
+Copyright (C) 2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -18,48 +18,72 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_refcount_h)
 #define octave_refcount_h 1
 
+#ifndef OCTAVE_CONFIG_INCLUDED
+# error "The file <octave/config.h> must be included before oct-refcount.h."
+#endif
+
+#if defined (USE_ATOMIC_REFCOUNT) && (defined (_MSC_VER) || defined (__GNUC__))
+# if defined (_MSC_VER)
+#  include <intrin.h>
+#  define OCTREFCOUNT_ATOMIC_INCREMENT(x) _InterlockedIncrement((long*)x)
+#  define OCTREFCOUNT_ATOMIC_DECREMENT(x) _InterlockedDecrement((long*)x)
+#  define OCTREFCOUNT_ATOMIC_INCREMENT_POST(x) _InterlockedExchangeAdd((long*)x,  1)
+#  define OCTREFCOUNT_ATOMIC_DECREMENT_POST(x) _InterlockedExchangeAdd((long*)x, -1)
+# elif defined (__GNUC__)
+#  define OCTREFCOUNT_ATOMIC_INCREMENT(x) __sync_add_and_fetch(x,  1)
+#  define OCTREFCOUNT_ATOMIC_DECREMENT(x) __sync_add_and_fetch(x, -1)
+#  define OCTREFCOUNT_ATOMIC_INCREMENT_POST(x) __sync_fetch_and_add(x,  1)
+#  define OCTREFCOUNT_ATOMIC_DECREMENT_POST(x) __sync_fetch_and_add(x, -1)
+# endif
+#else // Generic non-locking versions
+# define OCTREFCOUNT_ATOMIC_INCREMENT(x) ++(*(x))
+# define OCTREFCOUNT_ATOMIC_DECREMENT(x) --(*(x))
+# define OCTREFCOUNT_ATOMIC_INCREMENT_POST(x) (*(x))++
+# define OCTREFCOUNT_ATOMIC_DECREMENT_POST(x) (*(x))--
+#endif
+
 // Encapsulates a reference counter.
 template <class T>
 class octave_refcount
 {
 public:
   typedef T count_type;
 
   octave_refcount(count_type initial_count) : count(initial_count) {}
 
   // Increment/Decrement. int is postfix.
   count_type operator++(void)
     {
-      return ++count;
+      return OCTREFCOUNT_ATOMIC_INCREMENT (&count);
     }
 
   count_type operator++(int)
     {
-      return count++;
+      return OCTREFCOUNT_ATOMIC_INCREMENT_POST (&count);
     }
 
   count_type operator--(void)
     {
-      return --count;
+      return OCTREFCOUNT_ATOMIC_DECREMENT (&count);
     }
 
   count_type operator--(int)
     {
-      return count--;
+      return OCTREFCOUNT_ATOMIC_DECREMENT_POST (&count);
     }
 
-  operator count_type (void) const { return count; }
-
-  // For low-level optimizations only.
-  count_type& direct (void) const { return count; }
+  operator count_type (void) const
+    {
+      return static_cast<count_type const volatile&> (count);
+    }
 
 private:
   count_type count;
 };
 
 #endif
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
--- a/liboctave/oct-rl-edit.h
+++ b/liboctave/oct-rl-edit.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/oct-rl-hist.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-rl-hist.h b/liboctave/oct-rl-hist.h
--- a/liboctave/oct-rl-hist.h
+++ b/liboctave/oct-rl-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 David Bateman
+Copyright (C) 2003-2012 David Bateman
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/liboctave/oct-sort.h b/liboctave/oct-sort.h
--- a/liboctave/oct-sort.h
+++ b/liboctave/oct-sort.h
@@ -1,10 +1,10 @@
 /*
-Copyright (C) 2003-2011 David Bateman
+Copyright (C) 2003-2012 David Bateman
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/oct-sparse.h b/liboctave/oct-sparse.h
--- a/liboctave/oct-sparse.h
+++ b/liboctave/oct-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-spparms.cc b/liboctave/oct-spparms.cc
--- a/liboctave/oct-spparms.cc
+++ b/liboctave/oct-spparms.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -24,26 +24,32 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-error.h"
 #include "lo-ieee.h"
 
 #include "oct-spparms.h"
+#include "singleton-cleanup.h"
 
 octave_sparse_params *octave_sparse_params::instance = 0;
 
 bool
 octave_sparse_params::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_sparse_params ();
+    {
+      instance = new octave_sparse_params ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_sparse_params object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-spparms.h b/liboctave/oct-spparms.h
--- a/liboctave/oct-spparms.h
+++ b/liboctave/oct-spparms.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -90,16 +90,18 @@ public:
 private:
 
   ColumnVector params;
 
   string_vector keys;
 
   static octave_sparse_params *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   void do_defaults (void);
 
   void do_tight (void);
 
   string_vector do_get_keys (void) const { return keys; }
 
   ColumnVector do_get_vals (void) const { return params; }
 
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-syscalls.h b/liboctave/oct-syscalls.h
--- a/liboctave/oct-syscalls.h
+++ b/liboctave/oct-syscalls.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "strftime.h"
 
 #include "lo-error.h"
 #include "lo-math.h"
 #include "lo-utils.h"
+#include "oct-locbuf.h"
 #include "oct-time.h"
 
 octave_time::octave_time (const octave_base_tm& tm)
   : ot_unix_time (), ot_usec ()
 {
   struct tm t;
 
   t.tm_sec = tm.sec ();
@@ -48,16 +49,20 @@ octave_time::octave_time (const octave_b
   t.tm_hour = tm.hour ();
   t.tm_mday = tm.mday ();
   t.tm_mon = tm.mon ();
   t.tm_year = tm.year ();
   t.tm_wday = tm.wday ();
   t.tm_yday = tm.yday ();
   t.tm_isdst = tm.isdst ();
 
+#if defined (HAVE_STRUCT_TM_GMTOFF)
+  t.tm_gmtoff = tm.gmtoff ();
+#endif
+
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
   std::string s = tm.zone ();
   char *ps = strsave (s.c_str ());
   t.tm_zone = ps;
 #endif
 
   ot_unix_time = gnulib::mktime (&t);
 
@@ -93,50 +98,39 @@ octave_time::stamp (void)
 //     <snip>
 //
 //     If structure members are outside  their  legal interval, they
 //     will be normalized (so that, e.g., 40 October is changed into
 //     9 November).
 //
 // So, we no longer check limits here.
 
-#if 0
-#define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
+#define DEFINE_SET_FIELD_FCN(type, f, lo, hi) \
   octave_base_tm& \
-  octave_base_tm::f (int v) \
-  { \
-    if (v < lo || v > hi) \
-      (*current_liboctave_error_handler) \
-        ("invalid value specified for " #f); \
- \
-    tm_ ## f = v; \
- \
-    return *this; \
-  }
-#else
-#define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
-  octave_base_tm& \
-  octave_base_tm::f (int v) \
+  octave_base_tm::f (type v) \
   { \
     tm_ ## f = v; \
  \
     return *this; \
   }
-#endif
+
+#define DEFINE_SET_INT_FIELD_FCN(f, lo, hi) \
+  DEFINE_SET_FIELD_FCN (int, f, lo, hi)
 
 DEFINE_SET_INT_FIELD_FCN (usec, 0, 1000000)
 DEFINE_SET_INT_FIELD_FCN (sec, 0, 61)
 DEFINE_SET_INT_FIELD_FCN (min, 0, 59)
 DEFINE_SET_INT_FIELD_FCN (hour, 0, 23)
 DEFINE_SET_INT_FIELD_FCN (mday, 1, 31)
 DEFINE_SET_INT_FIELD_FCN (mon, 0, 11)
 DEFINE_SET_INT_FIELD_FCN (year, INT_MIN, INT_MAX)
 DEFINE_SET_INT_FIELD_FCN (wday, 0, 6)
 DEFINE_SET_INT_FIELD_FCN (yday, 0, 365)
 DEFINE_SET_INT_FIELD_FCN (isdst, 0, 1)
+DEFINE_SET_FIELD_FCN (long, gmtoff, -86400, 0)
 
 octave_base_tm&
 octave_base_tm::zone (const std::string& s)
 {
   tm_zone = s;
   return *this;
 }
 
@@ -158,16 +152,20 @@ octave_base_tm::strftime (const std::str
       t.tm_hour = tm_hour;
       t.tm_mday = tm_mday;
       t.tm_mon = tm_mon;
       t.tm_year = tm_year;
       t.tm_wday = tm_wday;
       t.tm_yday = tm_yday;
       t.tm_isdst = tm_isdst;
 
+#if defined (HAVE_STRUCT_TM_GMTOFF)
+      t.tm_gmtoff = tm_gmtoff;
+#endif
+
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
       char *ps = strsave (tm_zone.c_str ());
       t.tm_zone = ps;
 #endif
 
       const char *fmt_str = fmt.c_str ();
 
       char *buf = 0;
@@ -210,16 +208,20 @@ octave_base_tm::init (void *p)
   tm_hour = t->tm_hour;
   tm_mday = t->tm_mday;
   tm_mon = t->tm_mon;
   tm_year = t->tm_year;
   tm_wday = t->tm_wday;
   tm_yday = t->tm_yday;
   tm_isdst = t->tm_isdst;
 
+#if defined (HAVE_STRUCT_TM_GMTOFF)
+  tm_gmtoff = t->tm_gmtoff;
+#endif
+
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
   if (t->tm_zone)
     tm_zone = t->tm_zone;
 #elif defined (HAVE_TZNAME)
   if (t->tm_isdst == 0 || t->tm_isdst == 1)
     tm_zone = tzname[t->tm_isdst];
 #endif
 }
@@ -254,22 +256,26 @@ octave_strptime::init (const std::string
   t.tm_hour = 0;
   t.tm_mday = 0;
   t.tm_mon = -1;
   t.tm_year = INT_MIN;
   t.tm_wday = 0;
   t.tm_yday = 0;
   t.tm_isdst = 0;
 
+#if defined (HAVE_STRUCT_TM_GMTOFF)
+  t.tm_gmtoff = 0;
+#endif
+
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
   char *ps = strsave ("");
   t.tm_zone = ps;
 #endif
 
-  char *p = strsave (str.c_str ());
+  const char *p = str.c_str ();
 
   char *q = gnulib::strptime (p, fmt.c_str (), &t);
 
   // Fill in wday and yday, but only if mday is valid and the mon and year
   // are filled in, avoiding issues with mktime and invalid dates.
   if (t.tm_mday != 0 && t.tm_mon >= 0 && t.tm_year != INT_MIN)
     {
       t.tm_isdst = -1;
@@ -282,16 +288,14 @@ octave_strptime::init (const std::string
   if (t.tm_year == INT_MIN)
     t.tm_year = 0;
 
   if (q)
     nchars = q - p + 1;
   else
     nchars = 0;
 
-  delete [] p;
-
   octave_base_tm::init (&t);
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
   delete [] ps;
 #endif
 }
diff --git a/liboctave/oct-time.h b/liboctave/oct-time.h
--- a/liboctave/oct-time.h
+++ b/liboctave/oct-time.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -169,40 +169,41 @@ class
 OCTAVE_API
 octave_base_tm
 {
 public:
 
   octave_base_tm (void)
     : tm_usec (0), tm_sec (0), tm_min (0), tm_hour (0),
       tm_mday (0), tm_mon (0), tm_year (0), tm_wday (0),
-      tm_yday (0), tm_isdst (0), tm_zone ("unknown")
+      tm_yday (0), tm_isdst (0), tm_gmtoff (0), tm_zone ("unknown")
   { }
 
   octave_base_tm (const octave_base_tm& tm)
     : tm_usec (tm.tm_usec), tm_sec (tm.tm_sec), tm_min (tm.tm_min),
       tm_hour (tm.tm_hour), tm_mday (tm.tm_mday), tm_mon (tm.tm_mon),
       tm_year (tm.tm_year), tm_wday (tm.tm_wday), tm_yday (tm.tm_yday),
-      tm_isdst (tm.tm_isdst), tm_zone (tm.tm_zone)
+      tm_isdst (tm.tm_isdst), tm_gmtoff (tm.tm_gmtoff), tm_zone (tm.tm_zone)
   { }
 
   octave_base_tm& operator = (const octave_base_tm& tm)
   {
     if (this != &tm)
       {
         tm_usec = tm.tm_usec;
         tm_sec = tm.tm_sec;
         tm_min = tm.tm_min;
         tm_hour = tm.tm_hour;
         tm_mday = tm.tm_mday;
         tm_mon = tm.tm_mon;
         tm_year = tm.tm_year;
         tm_wday = tm.tm_wday;
         tm_yday = tm.tm_yday;
         tm_isdst = tm.tm_isdst;
+        tm_gmtoff = tm.tm_gmtoff;
         tm_zone = tm.tm_zone;
       }
 
     return *this;
   }
 
   virtual ~octave_base_tm (void) { }
 
@@ -211,28 +212,30 @@ public:
   int min (void) const { return tm_min; }
   int hour (void) const { return tm_hour; }
   int mday (void) const { return tm_mday; }
   int mon (void) const { return tm_mon; }
   int year (void) const { return tm_year; }
   int wday (void) const { return tm_wday; }
   int yday (void) const { return tm_yday; }
   int isdst (void) const { return tm_isdst; }
+  long gmtoff (void) const { return tm_gmtoff; }
   std::string zone (void) const { return tm_zone; }
 
   octave_base_tm& usec (int v);
   octave_base_tm& sec (int v);
   octave_base_tm& min (int v);
   octave_base_tm& hour (int v);
   octave_base_tm& mday (int v);
   octave_base_tm& mon (int v);
   octave_base_tm& year (int v);
   octave_base_tm& wday (int v);
   octave_base_tm& yday (int v);
   octave_base_tm& isdst (int v);
+  octave_base_tm& gmtoff (long v);
   octave_base_tm& zone (const std::string& s);
 
   std::string strftime (const std::string& fmt) const;
 
   std::string asctime (void) const
     { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
 
 protected:
@@ -263,16 +266,19 @@ protected:
 
   // Days since January 1 (0, 365).
   int tm_yday;
 
   // Daylight Savings Time flag.
   int tm_isdst;
 
   // Time zone.
+  long tm_gmtoff;
+
+  // Time zone.
   std::string tm_zone;
 
   void init (void *p);
 };
 
 class
 OCTAVE_API
 octave_localtime : public octave_base_tm
diff --git a/liboctave/oct-uname.cc b/liboctave/oct-uname.cc
--- a/liboctave/oct-uname.cc
+++ b/liboctave/oct-uname.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/oct-uname.h b/liboctave/oct-uname.h
--- a/liboctave/oct-uname.h
+++ b/liboctave/oct-uname.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/pathlen.h b/liboctave/pathlen.h
--- a/liboctave/pathlen.h
+++ b/liboctave/pathlen.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -26,33 +26,38 @@ along with Octave; see the file COPYING.
 
 #include <cstdlib>
 
 #include <string>
 
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "pathsearch.h"
-#include "str-vec.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
 
 #include "kpse.cc"
 
 dir_path::static_members *dir_path::static_members::instance = 0;
 
 dir_path::static_members::static_members (void)
   : xpath_sep_char (SEPCHAR), xpath_sep_str (SEPCHAR_STR) { }
 
 bool
 dir_path::static_members::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new static_members ();
+    {
+      instance = new static_members ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create dir_path::static_members object!");
 
       retval = false;
     }
diff --git a/liboctave/pathsearch.h b/liboctave/pathsearch.h
--- a/liboctave/pathsearch.h
+++ b/liboctave/pathsearch.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -148,16 +148,18 @@ private:
     {
       return instance_ok () ? instance->xpath_sep_str : std::string ();
     }
 
   private:
 
     static static_members *instance;
 
+    static void cleanup_instance (void) { delete instance; instance = 0; }
+
     static bool instance_ok (void);
 
     // No copying!
 
     static_members (const static_members&);
 
     static_members& operator = (const static_members&);
 
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randgamma.h b/liboctave/randgamma.h
--- a/liboctave/randgamma.h
+++ b/liboctave/randgamma.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randmtzig.h b/liboctave/randmtzig.h
--- a/liboctave/randmtzig.h
+++ b/liboctave/randmtzig.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/randpoisson.h b/liboctave/randpoisson.h
--- a/liboctave/randpoisson.h
+++ b/liboctave/randpoisson.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/regex-match.cc b/liboctave/regexp.cc
rename from liboctave/regex-match.cc
rename to liboctave/regexp.cc
--- a/liboctave/regex-match.cc
+++ b/liboctave/regexp.cc
@@ -1,11 +1,13 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2012 John W. Eaton
+Copyright (C) 2005-2012 David Bateman
+Copyright (C) 2002-2005 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -19,131 +21,559 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <list>
+#include <sstream>
+#include <string>
 #include <vector>
-#include <iostream>
-#include <string>
 
-#include "regex-match.h"
-#include "str-vec.h"
-#include "oct-locbuf.h"
+#if defined (HAVE_PCRE_H)
+#include <pcre.h>
+#elif defined (HAVE_PCRE_PCRE_H)
+#include <pcre/pcre.h>
+#endif
 
-regex_match&
-regex_match::operator = (const regex_match& gm)
-{
-  if (this != &gm)
-    {
-#if HAVE_REGEX
-      for (int i = 0; i < pat.length (); i++)
-        regfree (compiled +i);
-      delete [] compiled;
-#endif
-      pat = gm.pat;
-      case_insen = gm.case_insen;
-      init ();
-    }
-  return *this;
-}
+#include "Matrix.h"
+#include "base-list.h"
+#include "lo-error.h"
+#include "oct-locbuf.h"
+#include "quit.h"
+#include "regexp.h"
+#include "str-vec.h"
 
-regex_match::~regex_match (void)
-{
-#if HAVE_REGEX
-  for (int i = 0; i < pat.length (); i++)
-    regfree (compiled +i);
-  delete [] compiled;
-#endif
-}
+// Define the maximum number of retries for a pattern that possibly
+// results in an infinite recursion.
+#define PCRE_MATCHLIMIT_MAX 10
 
+// FIXME -- should this be configurable?
+#define MAXLOOKBEHIND 10
+
+static bool lookbehind_warned = false;
+
+// FIXME -- don't bother collecting and composing return values the user
+// doesn't want.
 
 void
-regex_match::set_pattern (const std::string& p)
+regexp::free (void)
 {
-#if HAVE_REGEX
-  for (int i = 0; i < pat.length (); i++)
-    regfree (compiled +i);
-  delete [] compiled;
-#endif
-  pat = p;
-  init ();
-}
-
-void
-regex_match::set_pattern (const string_vector& p)
-{
-#if HAVE_REGEX
-  for (int i = 0; i < pat.length (); i++)
-    regfree (compiled +i);
-  delete [] compiled;
-#endif
-  pat = p;
-  init ();
+  if (data)
+    pcre_free (static_cast<pcre *> (data));
 }
 
 void
-regex_match::init (void)
+regexp::compile_internal (void)
 {
-#ifdef HAVE_REGEX
-  int npat = pat.length ();
-  int err = 0;
-  int i;
+  // If we had a previously compiled pattern, release it.
+  free ();
+
+  size_t max_length = MAXLOOKBEHIND;
+
+  size_t pos = 0;
+  size_t new_pos;
+  int inames = 0;
+  std::ostringstream buf;
+
+  while ((new_pos = pattern.find ("(?", pos)) != std::string::npos)
+    {
+      if (pattern.at (new_pos + 2) == '<'
+          && !(pattern.at (new_pos + 3) == '='
+               || pattern.at (new_pos + 3) == '!'))
+        {
+          // The syntax of named tokens in pcre is "(?P<name>...)" while
+          // we need a syntax "(?<name>...)", so fix that here. Also an
+          // expression like
+          // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
+          // should be perfectly legal, while pcre does not allow the same
+          // named token name on both sides of the alternative. Also fix
+          // that here by replacing name tokens by dummy names, and dealing
+          // with the dummy names later.
+
+          size_t tmp_pos = pattern.find_first_of ('>', new_pos);
+
+          if (tmp_pos == std::string::npos)
+            {
+              (*current_liboctave_error_handler)
+                ("regexp: syntax error in pattern");
+              return;
+            }
+
+          std::string tmp_name =
+            pattern.substr (new_pos+3, tmp_pos-new_pos-3);
+
+          bool found = false;
+
+          for (int i = 0; i < nnames; i++)
+            {
+              if (named_pats(i) == tmp_name)
+                {
+                  named_idx.resize (dim_vector (inames+1, 1));
+                  named_idx(inames) = i;
+                  found = true;
+                  break;
+                }
+            }
+
+          if (! found)
+            {
+              named_idx.resize (dim_vector (inames+1, 1));
+              named_idx(inames) = nnames;
+              named_pats.append (tmp_name);
+              nnames++;
+            }
+
+          if (new_pos - pos > 0)
+            buf << pattern.substr (pos, new_pos-pos);
+          if (inames < 10)
+            buf << "(?P<n00" << inames++;
+          else if (inames < 100)
+            buf << "(?P<n0" << inames++;
+          else
+            buf << "(?P<n" << inames++;
 
-  compiled = new regex_t [npat];
+          pos = tmp_pos;
+        }
+      else if (pattern.at (new_pos + 2) == '<')
+        {
+          // Find lookbehind operators of arbitrary length (ie like
+          // "(?<=[a-z]*)") and replace with a maximum length operator
+          // as PCRE can not yet handle arbitrary length lookahead
+          // operators. Use the string length as the maximum length to
+          // avoid issues.
+
+          int brackets = 1;
+          size_t tmp_pos1 = new_pos + 2;
+          size_t tmp_pos2 = tmp_pos1;
+
+          while (tmp_pos1 <= pattern.length () && brackets > 0)
+            {
+              char ch = pattern.at (tmp_pos1);
+
+              if (ch == '(')
+                brackets++;
+              else if (ch == ')')
+                {
+                  if (brackets > 1)
+                    tmp_pos2 = tmp_pos1;
+
+                  brackets--;
+                }
+
+              tmp_pos1++;
+            }
+
+          if (brackets != 0)
+            {
+              buf << pattern.substr (pos, new_pos - pos) << "(?";
+              pos = new_pos + 2;
+            }
+          else
+            {
+              size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
 
-  for (i = 0; i < npat; i++)
-    {
-      err = regcomp (compiled + i, pat(i).c_str (),
-                     (REG_NOSUB | REG_EXTENDED |
-                      (case_insen ? REG_ICASE : 0)));
-      if (err)
-        break;
+              if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
+                {
+                  if (!lookbehind_warned)
+                    {
+                      lookbehind_warned = true;
+                      (*current_liboctave_warning_handler)
+                        ("%s: arbitrary length lookbehind patterns are only supported up to length %d",
+                               who.c_str (), MAXLOOKBEHIND);
+                    }
+
+                  buf << pattern.substr (pos, new_pos - pos) << "(";
+
+                  size_t i;
+
+                  if (pattern.at (tmp_pos3) == '*')
+                    i = 0;
+                  else
+                    i = 1;
+
+                  for (; i < max_length + 1; i++)
+                    {
+                      buf << pattern.substr (new_pos, tmp_pos3 - new_pos)
+                          << "{" << i << "}";
+                      buf << pattern.substr (tmp_pos3 + 1,
+                                             tmp_pos1 - tmp_pos3 - 1);
+                      if (i != max_length)
+                        buf << "|";
+                    }
+                  buf << ")";
+                }
+              else
+                buf << pattern.substr (pos, tmp_pos1 - pos);
+
+              pos = tmp_pos1;
+            }
+        }
+      else
+        {
+          buf << pattern.substr (pos, new_pos - pos) << "(?";
+          pos = new_pos + 2;
+        }
+
     }
 
-  if (err)
+  buf << pattern.substr (pos);
+
+  const char *err;
+  int erroffset;
+  std::string buf_str = buf.str ();
+
+  int pcre_options
+    = ((options.case_insensitive () ? PCRE_CASELESS : 0)
+       | (options.dotexceptnewline () ? 0 : PCRE_DOTALL)
+       | (options.lineanchors () ? PCRE_MULTILINE : 0)
+       | (options.freespacing () ? PCRE_EXTENDED : 0));
+
+  data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, 0);
+
+  if (! data)
+    (*current_liboctave_error_handler)
+      ("%s: %s at position %d of expression", who.c_str (),
+       err, erroffset);
+}
+
+regexp::match_data
+regexp::match (const std::string& buffer)
+{
+  regexp::match_data retval;
+
+  std::list<regexp::match_element> lst;
+
+  int subpatterns;
+  int namecount;
+  int nameentrysize;
+  char *nametable;
+  size_t idx = 0;
+
+  pcre *re = static_cast <pcre *> (data);
+
+  pcre_fullinfo (re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
+  pcre_fullinfo (re, 0, PCRE_INFO_NAMECOUNT, &namecount);
+  pcre_fullinfo (re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
+  pcre_fullinfo (re, 0, PCRE_INFO_NAMETABLE, &nametable);
+
+  OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
+  OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
+
+  for (int i = 0; i < namecount; i++)
     {
-      int len = regerror (err, compiled + i, 0, 0);
-      OCTAVE_LOCAL_BUFFER (char, errmsg, len);
-      regerror(err, compiled + i, errmsg, len);
-      (*current_liboctave_error_handler) ("%s in pattern (%s)", errmsg,
-                                          pat(i).c_str());
+      // Index of subpattern in first two bytes MSB first of name.
+      // Extract index.
+      nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
+        | static_cast<int> (nametable[i*nameentrysize+1]);
+    }
+
+  while (true)
+    {
+      OCTAVE_QUIT;
+
+      int matches = pcre_exec (re, 0, buffer.c_str (),
+                               buffer.length (), idx,
+                               (idx ? PCRE_NOTBOL : 0),
+                               ovector, (subpatterns+1)*3);
+
+      if (matches == PCRE_ERROR_MATCHLIMIT)
+        {
+          // Try harder; start with default value for MATCH_LIMIT
+          // and increase it.
+          (*current_liboctave_warning_handler)
+            ("your pattern caused PCRE to hit its MATCH_LIMIT; trying harder now, but this will be slow");
+
+          pcre_extra pe;
+
+          pcre_config (PCRE_CONFIG_MATCH_LIMIT,
+                       static_cast <void *> (&pe.match_limit));
+
+          pe.flags = PCRE_EXTRA_MATCH_LIMIT;
+
+          int i = 0;
+          while (matches == PCRE_ERROR_MATCHLIMIT
+                 && i++ < PCRE_MATCHLIMIT_MAX)
+            {
+              OCTAVE_QUIT;
+
+              pe.match_limit *= 10;
+              matches = pcre_exec (re, &pe, buffer.c_str (),
+                                   buffer.length (), idx,
+                                   (idx ? PCRE_NOTBOL : 0),
+                                   ovector, (subpatterns+1)*3);
+            }
+        }
 
-      for (int j = 0; j < i + 1; j++)
-        regfree (compiled + j);
+      if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
+        {
+          (*current_liboctave_error_handler)
+            ("%s: internal error calling pcre_exec; error code from pcre_exec is %i",
+             who.c_str (), matches);
+          return retval;
+        }
+      else if (matches == PCRE_ERROR_NOMATCH)
+        break;
+      else if (ovector[1] <= ovector[0])
+        {
+          // Zero sized match.  Skip to next char.
+          idx = ovector[0] + 1;
+          if (idx < buffer.length ())
+            continue;
+          else
+            break;
+        }
+      else
+        {
+          int pos_match = 0;
+          Matrix token_extents (matches-1, 2);
+
+          for (int i = 1; i < matches; i++)
+            {
+              if (ovector[2*i] >= 0 && ovector[2*i+1] > 0
+                  && (i == 1 || ovector[2*i] != ovector[2*i-2]
+                      || ovector[2*i-1] != ovector[2*i+1])
+                  && ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                {
+                  token_extents(pos_match,0) = double (ovector[2*i]+1);
+                  token_extents(pos_match++,1) = double (ovector[2*i+1]);
+                }
+            }
+
+          token_extents.resize (pos_match, 2);
+
+          double start = double (ovector[0]+1);
+          double end = double (ovector[1]);
+
+          const char **listptr;
+          int status = pcre_get_substring_list (buffer.c_str (), ovector,
+                                                matches, &listptr);
+
+          if (status == PCRE_ERROR_NOMEMORY)
+            {
+              (*current_liboctave_error_handler)
+                ("%s: cannot allocate memory in pcre_get_substring_list",
+                 who.c_str ());
+              return retval;
+            }
+
+          string_vector tokens (pos_match);
+          string_vector named_tokens (nnames);
+          int pos_offset = 0;
+          pos_match = 0;
+
+          for (int i = 1; i < matches; i++)
+            {
+              if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                {
+                  if (i == 1 || ovector[2*i] != ovector[2*i-2]
+                      || ovector[2*i-1] != ovector[2*i+1])
+                    {
+                      if (namecount > 0)
+                        named_tokens(named_idx(i-pos_offset-1)) =
+                          std::string (*(listptr+nidx[i-pos_offset-1]));
+
+                      tokens(pos_match++) = std::string (*(listptr+i));
+                    }
+                  else
+                    pos_offset++;
+                }
+            }
+
+          std::string match_string = std::string (*listptr);
+
+          pcre_free_substring_list (listptr);
+
+          regexp::match_element new_elem (named_tokens, tokens, match_string,
+                                          token_extents, start, end);
+          lst.push_back (new_elem);
+          idx = ovector[1];
+
+          if (options.once () || idx >= buffer.length ())
+            break;
+        }
     }
-#else
-  (*current_liboctave_error_handler)
-    ("regex not available in this version of Octave");
-#endif
+
+  retval = regexp::match_data (lst, named_pats);
+
+  return retval;
 }
 
 bool
-regex_match::match (const std::string& s)
+regexp::is_match (const std::string& buffer)
 {
-#if HAVE_REGEX
-  int npat = pat.length ();
-
-  const char *str = s.c_str ();
+  regexp::match_data rx_lst = match (buffer);
 
-  for (int i = 0; i < npat; i++)
-    if (regexec (compiled + i, str, 0, 0, 0) == 0)
-      return true;
-#endif
+  regexp::match_data::const_iterator p = rx_lst.begin ();
 
-  return false;
+  std::string match_string = p->match_string ();
+
+  return ! match_string.empty ();
 }
 
 Array<bool>
-regex_match::match (const string_vector& s)
+regexp::is_match (const string_vector& buffer)
 {
-  int n = s.length ();
+  octave_idx_type len = buffer.length ();
 
-  Array<bool> retval (dim_vector (n, 1));
+  Array<bool> retval (dim_vector (len, 1));
 
-  for (int i = 0; i < n; i++)
-    retval(i) = match (s[i]);
+  for (octave_idx_type i = 0; i < buffer.length (); i++)
+    retval(i) = is_match (buffer(i));
 
   return retval;
 }
+
+std::string
+regexp::replace (const std::string& buffer, const std::string& replacement)
+{
+  std::string retval;
+
+  // Identify replacement tokens; build a vector of group numbers in
+  // the replacement string so that we can quickly calculate the size
+  // of the replacement.
+
+  int tokens = 0;
+  for (size_t i=1; i < replacement.size (); i++)
+    {
+      if (replacement[i-1]=='$' && isdigit (replacement[i]))
+        {
+          tokens++;
+          i++;
+        }
+    }
+  std::vector<int> token (tokens);
+
+  int kk = 0;
+  for (size_t i = 1; i < replacement.size (); i++)
+    {
+      if (replacement[i-1]=='$' && isdigit (replacement[i]))
+        {
+          token[kk++] = replacement[i]-'0';
+          i++;
+        }
+    }
+
+  regexp::match_data rx_lst = match (buffer);
+
+  size_t sz = rx_lst.size ();
+
+  if (sz == 0)
+    {
+      retval = buffer;
+      return retval;
+    }
+
+  std::string rep;
+
+  if (tokens > 0)
+    {
+      // Determine replacement length
+      const size_t replen = replacement.size () - 2*tokens;
+      int delta = 0;
+      regexp::match_data::const_iterator p = rx_lst.begin ();
+      for (size_t i = 0; i < sz; i++)
+        {
+          OCTAVE_QUIT;
+
+          double start = p->start ();
+          double end = p->end ();
+
+          const Matrix pairs (p->token_extents ());
+          size_t pairlen = 0;
+          for (int j = 0; j < tokens; j++)
+            {
+              if (token[j] == 0)
+                pairlen += static_cast<size_t> (end - start) + 1;
+              else if (token[j] <= pairs.rows ())
+                pairlen += static_cast<size_t> (pairs(token[j]-1,1)
+                                                - pairs(token[j]-1,0)) + 1;
+            }
+          delta += (static_cast<int> (replen + pairlen)
+                    - static_cast<int> (end - start + 1));
+          p++;
+        }
+
+      // Build replacement string
+      rep.reserve (buffer.size () + delta);
+      size_t from = 0;
+      p = rx_lst.begin ();
+      for (size_t i = 0; i < sz; i++)
+        {
+          OCTAVE_QUIT;
+
+          double start = p->start ();
+          double end = p->end ();
+
+          const Matrix pairs (p->token_extents ());
+          rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
+          from = static_cast<size_t> (end - 1) + 1;
+
+          for (size_t j = 1; j < replacement.size (); j++)
+            {
+              if (replacement[j-1]=='$' && isdigit (replacement[j]))
+                {
+                  int k = replacement[j]-'0';
+                  if (k == 0)
+                    {
+                      // replace with entire match
+                      rep.append (&buffer[static_cast<size_t> (end - 1)],
+                                  static_cast<size_t> (end - start) + 1);
+                    }
+                  else if (k <= pairs.rows ())
+                    {
+                      // replace with group capture
+                      rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
+                                  static_cast<size_t> (pairs(k-1,1)
+                                                       - pairs(k-1,0)) + 1);
+                    }
+                  else
+                    {
+                      // replace with nothing
+                    }
+                  j++;
+                }
+              else
+                rep.append (1, replacement[j-1]);
+
+              if (j+1 == replacement.size ())
+                rep.append (1, replacement[j]);
+            }
+          p++;
+        }
+      rep.append (&buffer[from], buffer.size () - from);
+    }
+  else
+    {
+      // Determine replacement length
+      const size_t replen = replacement.size ();
+      int delta = 0;
+      regexp::match_data::const_iterator p = rx_lst.begin ();
+      for (size_t i = 0; i < sz; i++)
+        {
+          OCTAVE_QUIT;
+          delta += static_cast<int> (replen)
+            - static_cast<int> (p->end () - p->start () + 1);
+          p++;
+        }
+
+      // Build replacement string
+      rep.reserve (buffer.size () + delta);
+      size_t from = 0;
+      p = rx_lst.begin ();
+      for (size_t i = 0; i < sz; i++)
+        {
+          OCTAVE_QUIT;
+          rep.append (&buffer[from],
+                      static_cast<size_t> (p->start () - 1) - from);
+          from = static_cast<size_t> (p->end () - 1) + 1;
+          rep.append (replacement);
+          p++;
+        }
+      rep.append (&buffer[from], buffer.size () - from);
+    }
+
+  retval = rep;
+  return retval;
+}
diff --git a/liboctave/regex-match.h b/liboctave/regexp.h
rename from liboctave/regex-match.h
rename to liboctave/regexp.h
--- a/liboctave/regex-match.h
+++ b/liboctave/regexp.h
@@ -1,11 +1,12 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2012 John W. Eaton
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -15,85 +16,266 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if !defined (octave_regex_match_h)
-#define octave_regex_match_h 1
+#if !defined (octave_regexp_match_h)
+#define octave_regexp_match_h 1
 
+#include <list>
+#include <sstream>
 #include <string>
 
-#if defined (HAVE_REGEX)
-#if defined (__MINGW32__)
-#define __restrict
-#endif
-#include <sys/types.h>
-#include <regex.h>
-#endif
-
 #include "Array.h"
+#include "Matrix.h"
+#include "base-list.h"
 #include "str-vec.h"
 
-class
-OCTAVE_API
-regex_match
+class regexp
 {
 public:
 
-  regex_match (const std::string& p, bool insen = false)
-    : pat (p), case_insen (insen)
-#if HAVE_REGEX
-      , compiled (0)
-#endif
+  class opts;
+  class match_data;
+
+  regexp (const std::string& pat = "",
+          const regexp::opts& opt = regexp::opts (),
+          const std::string& w = "regexp")
+    : pattern (pat), options (opt), data (0), named_pats (),
+      nnames (0), named_idx (), who (w)
+  {
+    compile_internal ();
+  }
+
+  regexp (const regexp& rx)
+    : pattern (rx.pattern), data (rx.data), named_pats (rx.named_pats),
+      nnames (rx.nnames), named_idx (rx.named_idx)
+  { }
+
+  regexp& operator = (const regexp& rx)
+  {
+    if (this != &rx)
+      {
+        pattern = rx.pattern;
+        data = rx.data;
+        named_pats = rx.named_pats;
+        nnames = rx.nnames;
+        named_idx = rx.named_idx;
+      }
+
+    return *this;
+  }
+
+  ~regexp (void) { free (); }
+
+  void compile (const std::string& pat,
+                const regexp::opts& opt = regexp::opts ())
+  {
+    pattern = pat;
+    options = opt;
+    compile_internal ();
+  }
+
+  match_data match (const std::string& buffer);
+
+  bool is_match (const std::string& buffer);
+
+  Array<bool> is_match (const string_vector& buffer);
+
+  std::string replace (const std::string& buffer,
+                       const std::string& replacement);
+
+  struct opts
+  {
+  public:
+
+    opts (void)
+      : x_case_insensitive (false), x_dotexceptnewline (false),
+        x_freespacing (false), x_lineanchors (false), x_once (false) { }
+
+    opts (const opts& o)
+      : x_case_insensitive (o.x_case_insensitive),
+        x_dotexceptnewline (o.x_dotexceptnewline),
+        x_freespacing (o.x_freespacing),
+        x_lineanchors (o.x_lineanchors),
+        x_once (o.x_once)
+    { }
+
+    opts& operator = (const opts& o)
     {
-      init ();
-    }
+      if (this != &o)
+        {
+          x_case_insensitive = o.x_case_insensitive;
+          x_dotexceptnewline = o.x_dotexceptnewline;
+          x_freespacing = o.x_freespacing;
+          x_lineanchors = o.x_lineanchors;
+          x_once = o.x_once;
+        }
 
-  regex_match (const string_vector& p = string_vector (), bool insen = false)
-    : pat (p), case_insen (insen)
-#if HAVE_REGEX
-      , compiled (0)
-#endif
-    {
-      init ();
+      return *this;
     }
 
-  regex_match (const regex_match& gm)
-    : pat (gm.pat), case_insen (gm.case_insen)
-#if HAVE_REGEX
-      , compiled (0)
-#endif
+    ~opts (void) { }
+
+    void case_insensitive (bool val) { x_case_insensitive = val; }
+    void dotexceptnewline (bool val) { x_dotexceptnewline = val; }
+    void freespacing (bool val) { x_freespacing = val; }
+    void lineanchors (bool val) { x_lineanchors = val; }
+    void once (bool val) { x_once = val; }
+
+    bool case_insensitive (void) const { return x_case_insensitive; }
+    bool dotexceptnewline (void) const { return x_dotexceptnewline; }
+    bool freespacing (void) const { return x_freespacing; }
+    bool lineanchors (void) const { return x_lineanchors; }
+    bool once (void) const { return x_once; }
+
+  private:
+
+    bool x_case_insensitive;
+    bool x_dotexceptnewline;
+    bool x_freespacing;
+    bool x_lineanchors;
+    bool x_once;
+  };
+
+  class match_element
+  {
+  public:
+
+    match_element (const string_vector& nt, const string_vector& t,
+                   const std::string& ms, const Matrix& te,
+                   double s, double e)
+      : x_match_string (ms), x_named_tokens (nt), x_tokens (t),
+        x_token_extents (te), x_start (s), x_end (e)
+    { }
+
+    match_element (const match_element &a)
+      : x_match_string (a.x_match_string),
+        x_named_tokens (a.x_named_tokens), x_tokens (a.x_tokens),
+        x_token_extents (a.x_token_extents),
+        x_start (a.x_start), x_end (a.x_end)
+    { }
+
+    std::string match_string (void) const { return x_match_string; }
+    string_vector named_tokens (void) const { return x_named_tokens; }
+    string_vector tokens (void) const { return x_tokens; }
+    Matrix token_extents (void) const { return x_token_extents; }
+    double start (void) const { return x_start; }
+    double end (void) const { return x_end; }
+
+  private:
+
+    std::string x_match_string;
+    string_vector x_named_tokens;
+    string_vector x_tokens;
+    Matrix x_token_extents;
+    double x_start;
+    double x_end;
+  };
+
+  class match_data : public octave_base_list<match_element>
+  {
+  public:
+
+    match_data (void)
+      : octave_base_list<match_element> (), named_pats ()
+    { }
+
+    match_data (const std::list<match_element>& l, const string_vector& np)
+      : octave_base_list<match_element> (l), named_pats (np)
+    { }
+
+    match_data (const match_data& rx_lst)
+      : octave_base_list<match_element> (rx_lst),
+        named_pats (rx_lst.named_pats)
+    { }
+
+    match_data& operator = (const match_data& rx_lst)
     {
-      init ();
+      if (this != &rx_lst)
+        {
+          octave_base_list<match_element>::operator = (rx_lst);
+          named_pats = rx_lst.named_pats;
+        }
+
+      return *this;
     }
 
-  regex_match& operator = (const regex_match& gm);
+    ~match_data (void) { }
 
-  ~regex_match (void);
-
-  void set_pattern (const std::string& p);
+    string_vector named_patterns (void) { return named_pats; }
 
-  void set_pattern (const string_vector& p);
+  private:
 
-  bool match (const std::string&);
-
-  Array<bool> match (const string_vector&);
+    string_vector named_pats;
+  };
 
 private:
 
-  void init (void);
+  // The pattern we've been asked to match.
+  std::string pattern;
 
-  // Regex pattern(s).
-  string_vector pat;
+  opts options;
+
+  // Internal data describing the regular expression.
+  void *data;
 
-  // Should match be case insensitive
-  bool case_insen;
+  std::string m;
+  string_vector named_pats;
+  int nnames;
+  Array<int> named_idx;
+  std::string who;
 
-#if HAVE_REGEX
-  regex_t *compiled;
-#endif
+  void free (void);
+
+  void compile_internal (void);
 };
 
+inline regexp::match_data
+regexp_match (const std::string& pat,
+              const std::string& buffer,
+              const regexp::opts& opt = regexp::opts (),
+              const std::string& who = "regexp")
+{
+  regexp rx (pat, opt, who);
+
+  return rx.match (buffer);
+}
+
+inline bool
+is_regexp_match (const std::string& pat,
+                 const std::string& buffer,
+                 const regexp::opts& opt = regexp::opts (),
+                 const std::string& who = "regexp")
+{
+  regexp rx (pat, opt, who);
+
+  return rx.is_match (buffer);
+}
+
+inline Array<bool>
+is_regexp_match (const std::string& pat,
+                 const string_vector& buffer,
+                 const regexp::opts& opt = regexp::opts (),
+                 const std::string& who = "regexp")
+{
+  regexp rx (pat, opt, who);
+
+  return rx.is_match (buffer);
+}
+
+inline std::string
+regexp_replace (const std::string& pat,
+                const std::string& buffer,
+                const std::string& replacement,
+                const regexp::opts& opt = regexp::opts (),
+                const std::string& who = "regexp")
+{
+  regexp rx (pat, opt, who);
+
+  return rx.replace (buffer, replacement);
+}
+
 #endif
diff --git a/liboctave/singleton-cleanup.cc b/liboctave/singleton-cleanup.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/singleton-cleanup.cc
@@ -0,0 +1,60 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <lo-error.h>
+#include <singleton-cleanup.h>
+
+singleton_cleanup_list *singleton_cleanup_list::instance = 0;
+
+singleton_cleanup_list::~singleton_cleanup_list (void)
+{
+  for (std::set<fptr>::iterator p = fcn_list.begin ();
+       p != fcn_list.end (); p++)
+    {
+      fptr fcn = *p;
+
+      fcn ();
+    }
+}
+
+bool
+singleton_cleanup_list::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    instance = new singleton_cleanup_list ();
+
+  if (! instance)
+    {
+      current_liboctave_error_handler
+        ("unable to create singleton_cleanup_list object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
diff --git a/liboctave/singleton-cleanup.h b/liboctave/singleton-cleanup.h
new file mode 100644
--- /dev/null
+++ b/liboctave/singleton-cleanup.h
@@ -0,0 +1,50 @@
+#if !defined (octave_singleton_cleanup_h)
+#define octave_singleton_cleanup_h 1
+
+#include <set>
+
+class
+OCTAVE_API
+singleton_cleanup_list
+{
+protected:
+
+  singleton_cleanup_list (void) : fcn_list () { }
+
+public:
+
+  typedef void (*fptr) (void);
+
+  ~singleton_cleanup_list (void);
+
+  static void add (fptr f)
+  {
+    if (instance_ok ())
+      instance->do_add (f);
+  }
+
+  static void cleanup (void) { delete instance; instance = 0; }
+
+private:
+
+  static singleton_cleanup_list *instance;
+
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
+  std::set<fptr> fcn_list;
+
+  void do_add (fptr f)
+  {
+    fcn_list.insert (f);
+  }
+
+  // No copying!
+
+  singleton_cleanup_list (const singleton_cleanup_list&);
+
+  singleton_cleanup_list& operator = (const singleton_cleanup_list&);
+};
+
+#endif
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -173,25 +173,25 @@ public:
     { }
 
   sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a)
     : rep (a.rep)
     { rep->count++; }
 
   virtual ~sparse_base_chol (void)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
     }
 
   sparse_base_chol& operator = (const sparse_base_chol& a)
     {
       if (this != &a)
         {
-          if (--rep->count <= 0)
+          if (--rep->count == 0)
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
 
       return *this;
     }
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-base-lu.h b/liboctave/sparse-base-lu.h
--- a/liboctave/sparse-base-lu.h
+++ b/liboctave/sparse-base-lu.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/sparse-mk-ops.awk
@@ -1,9 +1,9 @@
-# Copyright (C) 2004-2011 John W. Eaton
+# Copyright (C) 2004-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/sparse-mx-ops b/liboctave/sparse-mx-ops
--- a/liboctave/sparse-mx-ops
+++ b/liboctave/sparse-mx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2004-2011 John W. Eaton
+# Copyright (C) 2004-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/liboctave/sparse-sort.cc b/liboctave/sparse-sort.cc
--- a/liboctave/sparse-sort.cc
+++ b/liboctave/sparse-sort.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-sort.h b/liboctave/sparse-sort.h
--- a/liboctave/sparse-sort.h
+++ b/liboctave/sparse-sort.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-util.cc b/liboctave/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/sparse-util.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/sparse-util.h b/liboctave/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/sparse-util.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/liboctave/statdefs.h b/liboctave/statdefs.h
--- a/liboctave/statdefs.h
+++ b/liboctave/statdefs.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sun-utils.h b/liboctave/sun-utils.h
--- a/liboctave/sun-utils.h
+++ b/liboctave/sun-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/sysdir.h b/liboctave/sysdir.h
--- a/liboctave/sysdir.h
+++ b/liboctave/sysdir.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/syswait.h b/liboctave/syswait.h
--- a/liboctave/syswait.h
+++ b/liboctave/syswait.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -1,12 +1,12 @@
 // N-D Array  manipulations.
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/liboctave/vx-ops b/liboctave/vx-ops
--- a/liboctave/vx-ops
+++ b/liboctave/vx-ops
@@ -1,9 +1,9 @@
-# Copyright (C) 2003-2011 John W. Eaton
+# Copyright (C) 2003-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1,11 +1,11 @@
 dnl aclocal.m4 -- extra macros for configuring Octave
 dnl
-dnl Copyright (C) 1995-2011 John W. Eaton
+dnl Copyright (C) 1995-2012 John W. Eaton
 dnl 
 dnl This file is part of Octave.
 dnl 
 dnl Octave is free software; you can redistribute it and/or modify it
 dnl under the terms of the GNU General Public License as published by the
 dnl Free Software Foundation; either version 3 of the License, or (at
 dnl your option) any later version.
 dnl 
@@ -365,17 +365,18 @@ AC_DEFUN([OCTAVE_CHECK_FORTRAN_INTEGER_S
   octave_idx_type in[2];
   octave_idx_type out[2];
   in[0] = 13;
   in[0] = 42;
   F77_FUNC(foo,FOO) (&n, &in, &out);
   assert (in[0] == out[0] && in[1] == out[1]);
 ]])],
   [octave_cv_fortran_integer_size=yes],
-  [octave_cv_fortran_integer_size=no])
+  [octave_cv_fortran_integer_size=no],
+  [octave_cv_fortran_integer_size=yes])
   AC_LANG_POP(C)dnl
   LIBS="$octave_fintsize_save_LIBS"
 rm -f conftest.$ac_objext fintsize.$ac_objext
 ], [
   rm -f conftest.$ac_objext
   AC_MSG_FAILURE([cannot compile a simple Fortran program])
   octave_cv_fortran_integer_size=no])])
   AC_LANG_POP(Fortran 77)
@@ -813,17 +814,17 @@ main (void)
    
   ieeebytes l = {0x1c, 0xbc, 0x6e, 0xf2, 0x54, 0x8b, 0x11, 0x43};
   ieeebytes b = {0x43, 0x11, 0x8b, 0x54, 0xf2, 0x6e, 0xbc, 0x1c};
 
   return l.d != 1234567891234567.0 && b.d != 1234567891234567.0;
 }]])],
   octave_cv_ieee754_data_format=yes,
   octave_cv_ieee754_data_format=no,
-  octave_cv_ieee754_data_format=no)])
+  octave_cv_ieee754_data_format=yes)])
 if test "$cross_compiling" = yes; then
   AC_MSG_RESULT([$octave_cv_ieee754_data_format assumed for cross compilation])
 else
   AC_MSG_RESULT([$octave_cv_ieee754_data_format])
 fi
 if test "$octave_cv_ieee754_data_format" = yes; then
   AC_DEFINE(HAVE_IEEE754_DATA_FORMAT, 1, [Define if your system uses IEEE 754 data format.])
 else
@@ -876,17 +877,17 @@ int main (void)
   for (i = 0; i < n; i++, x+=2) 
     if (fabs(*x - i - 1.) > 1.e-13)
       return (1);
   return (0) ;
 }
 ]])],
   octave_cv_umfpack_seperate_split=yes,
   octave_cv_umfpack_seperate_split=no,
-  octave_cv_umfpack_seperate_split=no)])
+  octave_cv_umfpack_seperate_split=yes)])
 if test "$cross_compiling" = yes; then
   AC_MSG_RESULT([$octave_cv_umfpack_seperate_split assumed for cross compilation])
 else
   AC_MSG_RESULT([$octave_cv_umfpack_seperate_split])
 fi
 if test "$octave_cv_umfpack_seperate_split" = yes; then
   AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, [Define if the UMFPACK Complex solver allow matrix and RHS to be split independently])
 fi
@@ -930,51 +931,245 @@ AC_DEFUN([OCTAVE_HDF5_HAS_ENFORCED_16_AP
 ])
 dnl
 dnl Check for the QHull version.
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION],
   [AC_CACHE_CHECK([for qh_version in $QHULL_LIBS],
     octave_cv_lib_qhull_version,  [
       AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-#include <qhull/qhull_a.h>
+#include <stdio.h>
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
 ]], [[
 const char *tmp = qh_version;
 ]])], [octave_cv_lib_qhull_version=yes], [octave_cv_lib_qhull_version=no])])
   if test "$octave_cv_lib_qhull_version" = no; then
     AC_DEFINE(NEED_QHULL_VERSION, 1,
       [Define if the QHull library needs a qh_version variable defined.])
   fi
 ])
 dnl
 dnl Check whether QHull works (does not crash)
 dnl
 AC_DEFUN([OCTAVE_CHECK_QHULL_OK],
   [AC_CACHE_CHECK([whether the qhull library works],
     octave_cv_lib_qhull_ok, [
       AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
-#include <qhull/qhull.h>
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
 #ifdef NEED_QHULL_VERSION
 char *qh_version = "version";
 #endif
 ]], [[
 int dim = 2;
 int n = 4;
 coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
 boolT ismalloc = 0;
 return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr); 
-]])], [octave_cv_lib_qhull_ok=yes], [octave_cv_lib_qhull_ok=no])])
+]])],
+  [octave_cv_lib_qhull_ok=yes],
+  [octave_cv_lib_qhull_ok=no],
+  [octave_cv_lib_qhull_ok=yes])])
   if test "$octave_cv_lib_qhull_ok" = "yes"; then
     $1
   else
     $2
   fi
 ])
 dnl
+dnl Check whether ARPACK works (does not crash)
+dnl
+dnl Using a pure Fortran program doesn't seem to crash when linked
+dnl with the buggy ARPACK library but the C++ program does.  Maybe
+dnl it is the memory allocation that exposes the bug and using statically
+dnl allocated arrays in Fortran does not?
+dnl
+AC_DEFUN([OCTAVE_CHECK_ARPACK_OK], [
+  AC_LANG_PUSH(C++)
+  AC_CACHE_CHECK([whether the arpack library works],
+    [octave_cv_lib_arpack_ok], [
+      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+// External functions from ARPACK library
+extern "C" int
+F77_FUNC (dnaupd, DNAUPD) (int&, const char *, const int&, const char *,
+                           int&, const double&, double*, const int&,
+                           double*, const int&, int*, int*, double*,
+                           double*, const int&, int&, long int, long int);
+
+extern "C" int
+F77_FUNC (dneupd, DNEUPD) (const int&, const char *, int*, double*,
+                           double*, double*, const int&,
+                           const double&, const double&, double*,
+                           const char*, const int&, const char *,
+                           int&, const double&, double*, const int&,
+                           double*, const int&, int*, int*, double*,
+                           double*, const int&, int&, long int,
+                           long int, long int);
+
+extern "C" int
+F77_FUNC (dgemv, DGEMV) (const char *, const int&, const int&,
+                         const double&, const double*, const int&,
+                         const double*, const int&, const double&,
+                         double*, const int&, long int);
+
+#include <cfloat>
+
+void
+doit (void)
+{
+  // Based on function EigsRealNonSymmetricMatrix from liboctave/eigs-base.cc.
+
+  // Problem matrix.  See bug #31479
+  int n = 4;
+  double *m = new double [n * n];
+  m[0] = 1, m[4] = 0, m[8]  = 0, m[12] = -1;
+  m[1] = 0, m[5] = 1, m[9]  = 0, m[13] = 0;
+  m[2] = 0, m[6] = 0, m[10] = 1, m[14] = 0;
+  m[3] = 0, m[7] = 0, m[11] = 2, m[15] = 1;
+
+  double *resid = new double [4];
+
+  resid[0] = 0.960966;
+  resid[1] = 0.741195;
+  resid[2] = 0.150143;
+  resid[3] = 0.868067;
+
+  int *ip = new int [11];
+
+  ip[0] = 1;   // ishift
+  ip[1] = 0;   // ip[1] not referenced
+  ip[2] = 300; // mxiter, maximum number of iterations
+  ip[3] = 1;   // NB blocksize in recurrence
+  ip[4] = 0;   // nconv, number of Ritz values that satisfy convergence
+  ip[5] = 0;   // ip[5] not referenced
+  ip[6] = 1;   // mode
+  ip[7] = 0;   // ip[7] to ip[10] are return values
+  ip[8] = 0;
+  ip[9] = 0;
+  ip[10] = 0;
+ 
+  int *ipntr = new int [14];
+
+  int k = 1;
+  int p = 3;
+  int lwork = 3 * p * (p + 2);
+
+  double *v = new double [n * (p + 1)];
+  double *workl = new double [lwork + 1];
+  double *workd = new double [3 * n + 1];
+
+  int ido = 0;
+  int info = 0;
+
+  double tol = DBL_EPSILON;
+
+  do 
+    {
+      F77_FUNC (dnaupd, DNAUPD) (ido, "I", n, "LM", k, tol, resid, p,
+                                 v, n, ip, ipntr, workd, workl, lwork,
+                                 info, 1L, 2L);
+
+      if (ido == -1 || ido == 1 || ido == 2)
+        {
+          double *x = workd + ipntr[0] - 1;
+          double *y = workd + ipntr[1] - 1;
+
+          F77_FUNC (dgemv, DGEMV) ("N", n, n, 1.0, m, n, x, 1, 0.0,
+                                   y, 1, 1L);
+        }
+      else
+        {
+          if (info < 0)
+            {
+              return;  // Error
+            }
+
+          break;
+        }
+    } 
+  while (1);
+
+  int *sel = new int [p];
+
+  // In Octave, the dimensions of dr and di are k+1, but k+2 avoids segfault
+  double *dr = new double [k + 1];
+  double *di = new double [k + 1];
+  double *workev = new double [3 * p];
+
+  for (int i = 0; i < k + 1; i++)
+    dr[i] = di[i] = 0.;
+
+  int rvec = 1;
+
+  double sigmar = 0.0;
+  double sigmai = 0.0;
+
+  // In Octave, this is n*(k+1), but k+2 avoids segfault
+  double *z = new double [n * (k + 1)];
+
+  F77_FUNC (dneupd, DNEUPD) (rvec, "A", sel, dr, di, z, n, sigmar,
+                             sigmai, workev, "I", n, "LM", k, tol,
+                             resid, p, v, n, ip, ipntr, workd,
+                             workl, lwork, info, 1L, 1L, 2L);
+}
+]], [[
+  for (int i = 0; i < 10; i++)
+    doit ();
+]])],
+  [octave_cv_lib_arpack_ok=yes],
+  [octave_cv_lib_arpack_ok=no],
+  [octave_cv_lib_arpack_ok=yes])])
+  AC_LANG_POP(C++)
+  if test "$octave_cv_lib_arpack_ok" = "yes"; then
+    $1
+  else
+    $2
+  fi
+])
+dnl
 dnl Check for OpenGL.  If found, define OPENGL_LIBS
 dnl
 dnl FIXME -- the following tests should probably check for the
 dnl libraries separately.
 dnl
 dnl FIXME -- should we allow a way to specify a directory for OpenGL
 dnl libraries and header files?
 dnl
@@ -1332,19 +1527,20 @@ dnl    (see <http://en.wikipedia.org/wik
 dnl 2. static_cast to unsigned int counterpart works like interpreting
 dnl    the signed bit pattern as unsigned (and is thus zero-cost).
 dnl 3. Signed addition and subtraction yield the same bit results as unsigned.
 dnl    (We use casts to prevent optimization interference, so there is no
 dnl     need for things like -ftrapv).
 dnl 4. Bit operations on signed integers work like on unsigned integers,
 dnl    except for the shifts. Shifts are arithmetic.
 dnl
-AC_DEFUN([OCTAVE_FAST_INT_OPS],[
-AC_MSG_CHECKING([whether fast integer arithmetics is usable])
-AC_LANG_PUSH(C++)
+AC_DEFUN([OCTAVE_FAST_INT_OPS],
+[AC_CACHE_CHECK([whether fast integer arithmetics is usable],
+octave_cv_fast_int_ops,
+[AC_LANG_PUSH(C++)
 AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include <limits>
 template<class UT, class ST>
 static bool 
 do_test (UT, ST)
 {
   volatile ST s = std::numeric_limits<ST>::min () / 3;
   volatile UT u = static_cast<UT> (s);
@@ -1378,20 +1574,25 @@ if (do_test (static_cast<unsigned T> (0)
   DO_TEST(char)
   DO_TEST(short)
   DO_TEST(int)
   DO_TEST(long)
 #if (defined(HAVE_LONG_LONG_INT) && defined(HAVE_UNSIGNED_LONG_LONG_INT))
   DO_TEST(long long)
 #endif
 ]])],
-[AC_MSG_RESULT([yes])
- AC_DEFINE(HAVE_FAST_INT_OPS,1,[Define if signed integers use two's complement])],
-[AC_MSG_RESULT([no])])
+   [octave_cv_fast_int_ops=yes],
+   [octave_cv_fast_int_ops=no],
+   [octave_cv_fast_int_ops=yes])
 AC_LANG_POP(C++)])
+if test $octave_cv_fast_int_ops = yes; then
+  AC_DEFINE(HAVE_FAST_INT_OPS, 1,
+    [Define if signed integers use two's complement])
+fi
+])
 dnl
 dnl Check to see if the compiler and the linker can handle the flags
 dnl "-framework $1" for the given prologue $2 and the given body $3 of
 dnl a source file.  Arguments 2 and 3 optionally can also be empty.
 dnl Add options (lower case letters $1) "--with-framework-$1" and
 dnl "--without-framework-$1". If this test is successful then perform
 dnl $4, otherwise do $5.
 dnl
diff --git a/run-octave.in b/run-octave.in
old mode 100755
new mode 100644
--- a/run-octave.in
+++ b/run-octave.in
@@ -1,13 +1,13 @@
 #! /bin/sh
 ##
 ## run-octave -- run Octave in the build tree.
 ## 
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ## 
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ## 
diff --git a/scripts/@ftp/ascii.m b/scripts/@ftp/ascii.m
--- a/scripts/@ftp/ascii.m
+++ b/scripts/@ftp/ascii.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,15 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ascii (@var{f})
-## Put the FTP connection @var{f} into ascii mode.
+## Set the FTP connection @var{f} to use ASCII mode for transfers.
+## ASCII mode is only appropriate for text files as it will convert
+## the remote host's newline representation to the local host's newline
+## representation.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function ascii (f)
   __ftp_ascii__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/binary.m b/scripts/@ftp/binary.m
--- a/scripts/@ftp/binary.m
+++ b/scripts/@ftp/binary.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,15 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} binary (@var{f})
-## Put the FTP connection @var{f} into binary mode.
+## Set the FTP connection @var{f} to use binary mode for transfers.
+## In binary mode there is no conversion of newlines from the remote
+## representation to the local representation.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function binary (f)
   __ftp_binary__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/cd.m b/scripts/@ftp/cd.m
--- a/scripts/@ftp/cd.m
+++ b/scripts/@ftp/cd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,14 +14,15 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cd (@var{f}, @var{path})
 ## Set the remote directory to @var{path} on the FTP connection @var{f}.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function cd (f, path)
   __ftp_cwd__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/@ftp/close.m b/scripts/@ftp/close.m
--- a/scripts/@ftp/close.m
+++ b/scripts/@ftp/close.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,15 +13,16 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} close (@var{f})
-## Close the FTP connection represented by the given FTP object @var{f}.
+## Close the FTP connection represented by the FTP object @var{f}.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function dir (f)
   __ftp_close__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/delete.m b/scripts/@ftp/delete.m
--- a/scripts/@ftp/delete.m
+++ b/scripts/@ftp/delete.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,15 +13,16 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} delete (@var{f}, @var{file})
-## Delete the remote file @var{file}, over the FTP connection @var{f}.
+## Delete the remote file @var{file} over the FTP connection @var{f}.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function delete (f, file)
   __ftp_delete__ (f.curlhandle, file);
 endfunction
diff --git a/scripts/@ftp/dir.m b/scripts/@ftp/dir.m
--- a/scripts/@ftp/dir.m
+++ b/scripts/@ftp/dir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,17 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{lst} =} dir (@var{f})
 ## List the current directory in verbose form for the FTP connection
-## @var{f}.  @var{f} is an FTP object returned by the @code{ftp} function.
+## @var{f}.
+##
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function lst = dir (f)
   if (nargout == 0)
     __ftp_dir__ (f.curlhandle);
   else
     lst = __ftp_dir__ (f.curlhandle);
   endif
diff --git a/scripts/@ftp/display.m b/scripts/@ftp/display.m
--- a/scripts/@ftp/display.m
+++ b/scripts/@ftp/display.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,28 +18,43 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{f} =} ftp (@var{host})
 ## @deftypefnx {Function File} {@var{f} =} ftp (@var{host}, @var{username}, @var{password})
 ## Connect to the FTP server @var{host} with @var{username} and @var{password}.
 ## If @var{username} and @var{password} are not specified, user "anonymous"
 ## with no password is used.  The returned FTP object @var{f} represents the
 ## established FTP connection.
+##
+## The list of actions for an FTP object are shown below.  All functions
+## require an FTP object as the first argument.
+##
+## @multitable @columnfractions 0.15 0.8
+## @headitem Method @tab Description
+## @item ascii @tab Set transfer type to ascii
+## @item binary @tab Set transfer type to binary
+## @item cd @tab Change remote working directory 
+## @item close @tab Close FTP connection
+## @item delete @tab Delete remote file 
+## @item dir @tab List remote directory contents 
+## @item mget @tab Download remote files
+## @item mkdir @tab Create remote directory
+## @item mput @tab Upload local files
+## @item rename @tab Rename remote file or directory
+## @item rmdir @tab Remove remote directory
+## @end multitable
+## 
 ## @end deftypefn
 
-function obj = ftp (host, username = "anonymous", password = "")
-  if (nargin == 0)
-    p.host = "";
-    p.username = username;
-    p.password = password;
-    p.curlhandle = tmpnam ("ftp-");
-    obj = class (p, "ftp");
-  elseif (nargin == 1 && strcmp (class (host), "ftp"))
-    obj = host;
+function obj = ftp (host = "", username = "anonymous", password = "")
+  if (nargin == 1 && isa (host, "ftp"))
+    obj = host;   # Copy constructor
   else
     p.host = host;
     p.username = username;
     p.password = password;
     p.curlhandle = tmpnam ("ftp-");
-    __ftp__ (p.curlhandle, host, username, password);
+    if (nargin > 0)
+      __ftp__ (p.curlhandle, host, username, password);
+    endif
     obj = class (p, "ftp");
   endif
 endfunction
diff --git a/scripts/@ftp/loadobj.m b/scripts/@ftp/loadobj.m
--- a/scripts/@ftp/loadobj.m
+++ b/scripts/@ftp/loadobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,12 +25,12 @@ function b = loadobj (a)
   __ftp__ (b.curlhandle, b.host, b.username, b.password);
   if (isfield (b, "dir"))
     if (! isempty (b.dir))
       __ftp_cwd__ (b.curlhandle, b.dir);
     endif
     b = rmfield (b, "dir");
   elseif (isfield (b, "remotePwd"))
     ## FIXME: Can we read matlab java stringBuffer objects?
-    warning ("can not change remote directory in loqded FTP object");
+    warning ("can not change remote directory in loaded FTP object");
     b = rmfield (b, "remotePwd");
   endif
 endfunction
diff --git a/scripts/@ftp/mget.m b/scripts/@ftp/mget.m
--- a/scripts/@ftp/mget.m
+++ b/scripts/@ftp/mget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,24 +14,24 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} mget (@var{f}, @var{file})
 ## @deftypefnx {Function File} {} mget (@var{f}, @var{dir})
-## @deftypefnx {Function File} {} mget (@dots{}, @var{target})
+## @deftypefnx {Function File} {} mget (@var{f}, @var{remote_name}, @var{target})
 ## Download a remote file @var{file} or directory @var{dir} to the local
 ## directory on the FTP connection @var{f}.  @var{f} is an FTP object
 ## returned by the @code{ftp} function.
 ##
 ## The arguments @var{file} and @var{dir} can include wildcards and any
 ## files or directories on the remote server that match will be downloaded.
 ##
 ## If a third argument @var{target} is given, then a single file or
-## directory will be downloaded with the name @var{target} to the local
-## directory.
+## directory will be downloaded to the local directory and the local name
+## will be changed to @var{target}.
 ## @end deftypefn
 
 function mget (f, file)
   __ftp_mget__ (f.curlhandle, file);
 endfunction
diff --git a/scripts/@ftp/mkdir.m b/scripts/@ftp/mkdir.m
--- a/scripts/@ftp/mkdir.m
+++ b/scripts/@ftp/mkdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,14 +14,15 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mkdir (@var{f}, @var{path})
 ## Create the remote directory @var{path}, over the FTP connection @var{f}.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function mkdir (f, path)
   __ftp_mkdir__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/@ftp/mput.m b/scripts/@ftp/mput.m
--- a/scripts/@ftp/mput.m
+++ b/scripts/@ftp/mput.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mput (@var{f}, @var{file})
 ## Upload the local file @var{file} into the current remote directory on
 ## the FTP connection @var{f}.  @var{f} is an FTP object returned by the
 ## ftp function.
 ##
-## The argument @var{file} is passed by the @dfn{glob} function and any
+## The argument @var{file} is passed through the @code{glob} function and any
 ## files that match the wildcards in @var{file} will be uploaded.
 ## @end deftypefn
 
 function retval = mput (f, file)
   if (nargout == 0)
     __ftp_mput__ (f.curlhandle, file);
   else
     retval = __ftp_mput__ (f.curlhandle, file);
diff --git a/scripts/@ftp/rename.m b/scripts/@ftp/rename.m
--- a/scripts/@ftp/rename.m
+++ b/scripts/@ftp/rename.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,15 +14,16 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rename (@var{f}, @var{oldname}, @var{newname})
 ## Rename or move the remote file or directory @var{oldname} to @var{newname},
-##  over the FTP connection @var{f}.  @var{f} is an FTP object returned by the
-## ftp function.
+## over the FTP connection @var{f}.
+##
+## @var{f} is an FTP object returned by the ftp function.
 ## @end deftypefn
 
 function rename (f, oldname, newname)
   __ftp_rename__ (f.curlhandle, oldname, newname);
 endfunction
diff --git a/scripts/@ftp/rmdir.m b/scripts/@ftp/rmdir.m
--- a/scripts/@ftp/rmdir.m
+++ b/scripts/@ftp/rmdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,14 +14,15 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rmdir (@var{f}, @var{path})
 ## Remove the remote directory @var{path}, over the FTP connection @var{f}.
+##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function rmdir (f, path)
   __ftp_rmdir__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/@ftp/saveobj.m b/scripts/@ftp/saveobj.m
--- a/scripts/@ftp/saveobj.m
+++ b/scripts/@ftp/saveobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 David Bateman
+## Copyright (C) 2009-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's scripts directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Michael Zeising
+## Copyright (C) 2005-2012 Michael Zeising
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Michael Zeising
+## Copyright (C) 2005-2012 Michael Zeising
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/__error_text__.m b/scripts/deprecated/__error_text__.m
--- a/scripts/deprecated/__error_text__.m
+++ b/scripts/deprecated/__error_text__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/autocor.m b/scripts/deprecated/autocor.m
--- a/scripts/deprecated/autocor.m
+++ b/scripts/deprecated/autocor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/autocov.m b/scripts/deprecated/autocov.m
--- a/scripts/deprecated/autocov.m
+++ b/scripts/deprecated/autocov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/betai.m b/scripts/deprecated/betai.m
--- a/scripts/deprecated/betai.m
+++ b/scripts/deprecated/betai.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cellidx.m b/scripts/deprecated/cellidx.m
--- a/scripts/deprecated/cellidx.m
+++ b/scripts/deprecated/cellidx.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Auburn University.  All rights reserved.
+## Copyright (C) 2000-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave program is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/clg.m b/scripts/deprecated/clg.m
--- a/scripts/deprecated/clg.m
+++ b/scripts/deprecated/clg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cor.m b/scripts/deprecated/cor.m
--- a/scripts/deprecated/cor.m
+++ b/scripts/deprecated/cor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/corrcoef.m b/scripts/deprecated/corrcoef.m
--- a/scripts/deprecated/corrcoef.m
+++ b/scripts/deprecated/corrcoef.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cquad.m b/scripts/deprecated/cquad.m
--- a/scripts/deprecated/cquad.m
+++ b/scripts/deprecated/cquad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/cut.m b/scripts/deprecated/cut.m
--- a/scripts/deprecated/cut.m
+++ b/scripts/deprecated/cut.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/dispatch.m b/scripts/deprecated/dispatch.m
--- a/scripts/deprecated/dispatch.m
+++ b/scripts/deprecated/dispatch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/error_text.m b/scripts/deprecated/error_text.m
--- a/scripts/deprecated/error_text.m
+++ b/scripts/deprecated/error_text.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/fstat.m b/scripts/deprecated/fstat.m
--- a/scripts/deprecated/fstat.m
+++ b/scripts/deprecated/fstat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/gammai.m b/scripts/deprecated/gammai.m
--- a/scripts/deprecated/gammai.m
+++ b/scripts/deprecated/gammai.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/glpkmex.m b/scripts/deprecated/glpkmex.m
--- a/scripts/deprecated/glpkmex.m
+++ b/scripts/deprecated/glpkmex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Nicolo' Giorgetti
+## Copyright (C) 2005-2012 Nicolo' Giorgetti
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/is_duplicate_entry.m b/scripts/deprecated/is_duplicate_entry.m
--- a/scripts/deprecated/is_duplicate_entry.m
+++ b/scripts/deprecated/is_duplicate_entry.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 A. S. Hodel
+## Copyright (C) 1996-2012 A. S. Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/is_global.m b/scripts/deprecated/is_global.m
--- a/scripts/deprecated/is_global.m
+++ b/scripts/deprecated/is_global.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/isstr.m b/scripts/deprecated/isstr.m
--- a/scripts/deprecated/isstr.m
+++ b/scripts/deprecated/isstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/krylovb.m b/scripts/deprecated/krylovb.m
--- a/scripts/deprecated/krylovb.m
+++ b/scripts/deprecated/krylovb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 A. Scottedward Hodel
+## Copyright (C) 1993-2012 A. Scottedward Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -1,36 +1,37 @@
 FCN_FILE_DIRS += deprecated
 
 deprecated_FCN_FILES = \
+  deprecated/__error_text__.m \
   deprecated/autocor.m \
   deprecated/autocov.m \
   deprecated/betai.m \
   deprecated/cellidx.m \
   deprecated/clg.m \
   deprecated/cor.m \
   deprecated/corrcoef.m \
   deprecated/cquad.m \
   deprecated/cut.m \
   deprecated/dispatch.m \
+  deprecated/error_text.m \
   deprecated/fstat.m \
   deprecated/gammai.m \
   deprecated/glpkmex.m \
   deprecated/intwarning.m \
   deprecated/is_duplicate_entry.m \
   deprecated/is_global.m \
   deprecated/isstr.m \
   deprecated/krylovb.m \
   deprecated/perror.m \
   deprecated/polyderiv.m \
   deprecated/replot.m \
   deprecated/saveimage.m \
   deprecated/setstr.m \
-  deprecated/sphcat.m \
-  deprecated/spvcat.m \
+  deprecated/shell_cmd.m \
   deprecated/strerror.m \
   deprecated/studentize.m \
   deprecated/sylvester_matrix.m \
   deprecated/values.m \
   deprecated/weibcdf.m \
   deprecated/weibinv.m \
   deprecated/weibpdf.m \
   deprecated/weibrnd.m
diff --git a/scripts/deprecated/perror.m b/scripts/deprecated/perror.m
--- a/scripts/deprecated/perror.m
+++ b/scripts/deprecated/perror.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/polyderiv.m b/scripts/deprecated/polyderiv.m
--- a/scripts/deprecated/polyderiv.m
+++ b/scripts/deprecated/polyderiv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/replot.m b/scripts/deprecated/replot.m
--- a/scripts/deprecated/replot.m
+++ b/scripts/deprecated/replot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/saveimage.m b/scripts/deprecated/saveimage.m
--- a/scripts/deprecated/saveimage.m
+++ b/scripts/deprecated/saveimage.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/setstr.m b/scripts/deprecated/setstr.m
--- a/scripts/deprecated/setstr.m
+++ b/scripts/deprecated/setstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/shell_cmd.m b/scripts/deprecated/shell_cmd.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/shell_cmd.m
@@ -0,0 +1,68 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## "-*- texinfo -*-
+## @deftypefn  {Built-in Function} {} shell_cmd (@var{string})
+## @deftypefnx {Built-in Function} {} shell_cmd (@var{string}, @var{return_output})
+## @deftypefnx {Built-in Function} {} shell_cmd (@var{string}, @var{return_output}, @var{type})
+## @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} shell_cmd (@dots{})
+## @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} shell_cmd (@var{string}, @var{return_output}, @var{type})
+## Execute a shell command specified by @var{string}.
+## If the optional argument @var{type} is "async", the process
+## is started in the background and the process id of the child process
+## is returned immediately.  Otherwise, the process is started and
+## Octave waits until it exits.  If the @var{type} argument is omitted, it
+## defaults to a value of "sync".
+## 
+## If the optional argument @var{return_output} is true and the subprocess
+## is started synchronously, or if @var{shell_cmd} is called with one input
+## argument and one or more output arguments, then the output from the command
+## is returned.  Otherwise, if the subprocess is executed synchronously, its
+## output is sent to the standard output.
+##
+## The @code{shell_cmd} function can return two values.  The first is the
+## exit status of the command and the second is any output from the
+## command that was written to the standard output stream.  For example,
+## 
+## @example
+## [status, output] = shell_cmd ("echo foo; exit 2");
+## @end example
+## 
+## @noindent
+## will set the variable @code{output} to the string @samp{foo}, and the
+## variable @code{status} to the integer @samp{2}.
+## 
+## For commands run asynchronously, @var{status} is the process id of the
+## command shell that is started to run the command.
+## @seealso{system, unix, dos}
+## @end deftypefn
+
+## Deprecated in version 3.6
+
+function [status, output] = shell_cmd (varargin)
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "shell_cmd is obsolete and will be removed from a future version of Octave; please use system instead");
+  endif
+
+  [status, output] = system (varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/sphcat.m b/scripts/deprecated/sphcat.m
deleted file mode 100644
--- a/scripts/deprecated/sphcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} sphcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the horizontal concatenation of sparse matrices.  This function
-## is obselete and @code{horzcat} should be used instead.
-## @seealso {horzcat, spvcat, vertcat, cat}
-## @end deftypefn
-
-function y = sphcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "sphcat is obsolete and will be removed from a future version of Octave; please use horzcat instead");
-  endif
-
-  y = horzcat (varargin{:});
-endfunction
diff --git a/scripts/deprecated/spvcat.m b/scripts/deprecated/spvcat.m
deleted file mode 100644
--- a/scripts/deprecated/spvcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} spvcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the vertical concatenation of sparse matrices.  This function
-## is obselete and @code{vertcat} should be used instead.
-## @seealso{vertcat, sphcat, horzcat, cat}
-## @end deftypefn
-
-function y = spvcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "spvcat is obsolete and will be removed from a future version of Octave; please use vertcat instead");
-  endif
-
-  y = vertcat (varargin{:});
-endfunction
diff --git a/scripts/deprecated/strerror.m b/scripts/deprecated/strerror.m
--- a/scripts/deprecated/strerror.m
+++ b/scripts/deprecated/strerror.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/studentize.m b/scripts/deprecated/studentize.m
--- a/scripts/deprecated/studentize.m
+++ b/scripts/deprecated/studentize.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/sylvester_matrix.m b/scripts/deprecated/sylvester_matrix.m
--- a/scripts/deprecated/sylvester_matrix.m
+++ b/scripts/deprecated/sylvester_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/values.m b/scripts/deprecated/values.m
--- a/scripts/deprecated/values.m
+++ b/scripts/deprecated/values.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibcdf.m b/scripts/deprecated/weibcdf.m
--- a/scripts/deprecated/weibcdf.m
+++ b/scripts/deprecated/weibcdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibinv.m b/scripts/deprecated/weibinv.m
--- a/scripts/deprecated/weibinv.m
+++ b/scripts/deprecated/weibinv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibpdf.m b/scripts/deprecated/weibpdf.m
--- a/scripts/deprecated/weibpdf.m
+++ b/scripts/deprecated/weibpdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/deprecated/weibrnd.m b/scripts/deprecated/weibrnd.m
--- a/scripts/deprecated/weibrnd.m
+++ b/scripts/deprecated/weibrnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/elfun/acosd.m b/scripts/elfun/acosd.m
--- a/scripts/elfun/acosd.m
+++ b/scripts/elfun/acosd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} acosd (@var{x})
 ## Compute the inverse cosine in degrees for each element of @var{x}.
 ## @seealso{cosd, acos}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = acosd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
-  y = acos(x) .* 180 ./ pi;
+
+  y = acos (x) .* 180 ./ pi;
+
 endfunction
 
-%!error(acosd())
-%!error(acosd(1,2))
-%!assert(acosd(0:0.1:1),180/pi*acos(0:0.1:1),-10*eps)
+
+%!assert (acosd (0:0.1:1), 180/pi*acos (0:0.1:1), -10*eps)
+
+%!error acosd ()
+%!error acosd (1, 2)
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,23 +25,23 @@
 ## Author: jwe
 
 function y = acot (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = atan (1./x);
+  y = atan (1 ./ x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
 %! v = [pi/6, pi/4, pi/3, pi/2, -pi/3, -pi/4, -pi/6];
-%! assert(all (abs (acot (x) - v) < sqrt (eps)));
+%! assert (all (abs (acot (x) - v) < sqrt (eps)));
 
-%!error acot ();
+%!error acot ()
+%!error acot (1, 2)
 
-%!error acot (1, 2);
-
diff --git a/scripts/elfun/acotd.m b/scripts/elfun/acotd.m
--- a/scripts/elfun/acotd.m
+++ b/scripts/elfun/acotd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} acotd (@var{x})
 ## Compute the inverse cotangent in degrees for each element of @var{x}.
 ## @seealso{cotd, acot}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = acotd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = atand (1 ./ x);
+
 endfunction
 
-%!error(acotd())
-%!error(acotd(1,2))
-%!assert(acotd(0:10:90),180./pi.*acot(0:10:90),-10*eps)
+
+%!assert (acotd (0:10:90), 180./pi.*acot (0:10:90), -10*eps)
+
+%!error acotd ()
+%!error acotd (1, 2)
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,19 +29,19 @@ function y = acoth (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = atanh (1 ./ x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = -i*[pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6];
 %! x = i*[rt3, 1, rt3/3, -rt3/3, -1, -rt3];
-%! assert(all (abs (acoth (x) - v) < sqrt (eps)));
+%! assert (all (abs (acoth (x) - v) < sqrt (eps)));
 
-%!error acoth ();
+%!error acoth ()
+%!error acoth (1, 2)
 
-%!error acoth (1, 2);
-
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,19 +29,19 @@ function y = acsc (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = asin (1 ./ x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6];
 %! x = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert(all (abs (acsc (x) - v) < sqrt (eps)));
+%! assert (all (abs (acsc (x) - v) < sqrt (eps)));
 
-%!error acsc ();
+%!error acsc ()
+%!error acsc (1, 2)
 
-%!error acsc (1, 2);
-
diff --git a/scripts/elfun/acscd.m b/scripts/elfun/acscd.m
--- a/scripts/elfun/acscd.m
+++ b/scripts/elfun/acscd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} acscd (@var{x})
 ## Compute the inverse cosecant in degrees for each element of @var{x}.
 ## @seealso{cscd, acsc}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = acscd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
-  y = acsc(x) .* 180 ./ pi;
+
+  y = acsc (x) .* 180 ./ pi;
+
 endfunction
 
-%!error(acscd())
-%!error(acscd(1,2))
-%!assert(acscd(0:10:90),180/pi*acsc(0:10:90),-10*eps)
+
+%!assert (acscd (0:10:90), 180/pi*acsc (0:10:90), -10*eps)
+
+%!error acscd ()
+%!error acscd (1, 2)
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,17 +29,17 @@ function y = acsch (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = asinh (1 ./ x);
 
 endfunction
 
+
 %!test
 %! v = [pi/2*i, -pi/2*i];
 %! x = [-i, i];
-%! assert(all (abs (acsch (x) - v) < sqrt (eps)));
+%! assert (all (abs (acsch (x) - v) < sqrt (eps)));
 
-%!error acsch ();
+%!error acsch ()
+%!error acsch (1, 2)
 
-%!error acsch (1, 2);
-
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,18 +29,18 @@ function y = asec (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = acos (1 ./ x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! x = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert(all (abs (asec (x) - v) < sqrt (eps)));
+%! assert (all (abs (asec (x) - v) < sqrt (eps)));
 
-%!error asec ();
-
-%!error asec (1, 2);
+%!error asec ()
+%!error asec (1, 2)
diff --git a/scripts/elfun/asecd.m b/scripts/elfun/asecd.m
--- a/scripts/elfun/asecd.m
+++ b/scripts/elfun/asecd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} asecd (@var{x})
 ## Compute the inverse secant in degrees for each element of @var{x}.
 ## @seealso{secd, asec}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = asecd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = asec (x) .* 180 ./ pi;
-endfunction;
+
+endfunction
 
-%!error(asecd())
-%!error(asecd(1,2))
-%!assert(asecd(0:10:90),180./pi.*asec(0:10:90),-10*eps)
+
+%!assert (asecd (0:10:90), 180./pi.*asec (0:10:90), -10*eps)
+
+%!error asecd ()
+%!error asecd (1, 2)
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,17 +29,17 @@ function y = asech (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = acosh (1 ./ x);
 
 endfunction
 
+
 %!test
 %! v = [0, pi*i];
 %! x = [1, -1];
-%! assert(all (abs (asech (x) - v) < sqrt (eps)));
+%! assert (all (abs (asech (x) - v) < sqrt (eps)));
 
-%!error asech ();
+%!error asech ()
+%!error asech (1, 2)
 
-%!error asech (1, 2);
-
diff --git a/scripts/elfun/asind.m b/scripts/elfun/asind.m
--- a/scripts/elfun/asind.m
+++ b/scripts/elfun/asind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} asind (@var{x})
 ## Compute the inverse sine in degrees for each element of @var{x}.
 ## @seealso{sind, asin}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = asind (x)
+
   if (nargin != 1)
     print_usage ();
   endif
-  y = asin(x) .* 180 ./ pi;
+
+  y = asin (x) .* 180 ./ pi;
+
 endfunction
 
-%!error(asind())
-%!error(asind(1,2))
-%!assert(asind(0:0.1:1),180/pi*asin(0:0.1:1),-10*eps)
+
+%!assert (asind (0:0.1:1), 180/pi*asin (0:0.1:1), -10*eps)
+
+%!error asind ()
+%!error asind (1, 2)
diff --git a/scripts/elfun/atand.m b/scripts/elfun/atand.m
--- a/scripts/elfun/atand.m
+++ b/scripts/elfun/atand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,22 @@
 ## @deftypefn {Function File} {} atand (@var{x})
 ## Compute the inverse tangent in degrees for each element of @var{x}.
 ## @seealso{tand, atan}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = atand (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = 180 ./ pi .* atan (x);
+
 endfunction
 
-%!error(atand())
-%!error(atand(1,2))
-%!assert(atand(0:10:90),180./pi.*atan(0:10:90),-10*eps)
+
+%!assert (atand (0:10:90), 180./pi.*atan (0:10:90), -10*eps)
+
+%!error atand ()
+%!error atand (1, 2)
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,22 +21,27 @@
 ## Compute the cosine for each element of @var{x} in degrees.  Returns zero
 ## for elements where @code{(@var{x}-90)/180} is an integer.
 ## @seealso{acosd, cos}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = cosd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   I = x / 180;
   y = cos (I .* pi);
   I = I + 0.5;
   y(I == fix (I) & finite (I)) = 0;
+
 endfunction
 
-%!error(cosd())
-%!error(cosd(1,2))
-%!assert(cosd(0:10:80),cos(pi*[0:10:80]/180),-10*eps)
-%!assert(cosd([0,180,360]) != 0)
-%!assert(cosd([90,270]) == 0)
+
+%!assert (cosd (0:10:80), cos (pi*[0:10:80]/180), -10*eps)
+%!assert (cosd ([0, 180, 360]) != 0)
+%!assert (cosd ([90, 270]) == 0)
+
+%!error cosd ()
+%!error cosd (1, 2)
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,23 +25,23 @@
 ## Author: jwe
 
 function y = cot (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = 1 ./ tan(x);
+  y = 1 ./ tan (x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
-%! assert(all (abs (cot (x) - v) < sqrt (eps)));
+%! assert (all (abs (cot (x) - v) < sqrt (eps)));
 
-%!error cot ();
+%!error cot ()
+%!error cot (1, 2)
 
-%!error cot (1, 2);
-
diff --git a/scripts/elfun/cotd.m b/scripts/elfun/cotd.m
--- a/scripts/elfun/cotd.m
+++ b/scripts/elfun/cotd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,19 +20,24 @@
 ## @deftypefn {Function File} {} cotd (@var{x})
 ## Compute the cotangent for each element of @var{x} in degrees.
 ## @seealso{acotd, cot}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = cotd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = 1 ./ tand (x);
+
 endfunction
 
-%!error(cotd())
-%!error(cotd(1,2))
-%!assert(cotd(10:10:80),cot(pi*[10:10:80]/180),-10*eps)
-%!assert(cotd([0,180,360]) == Inf)
-%!assert(cotd([90,270]) == 0)
+
+%!assert (cotd (10:10:80), cot (pi*[10:10:80]/180), -10*eps)
+%!assert (cotd ([0, 180, 360]) == Inf)
+%!assert (cotd ([90, 270]) == 0)
+
+%!error cotd ()
+%!error cotd (1, 2)
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,17 +29,17 @@ function y = coth (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = 1 ./ tanh (x);
 
 endfunction
 
+
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [0, 0];
-%! assert(all (abs (coth (x) - v) < sqrt (eps)));
+%! assert (all (abs (coth (x) - v) < sqrt (eps)));
 
-%!error coth ();
+%!error coth ()
+%!error coth (1, 2)
 
-%!error coth (1, 2);
-
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,23 +25,23 @@
 ## Author: jwe
 
 function y = csc (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = 1 ./ sin(x);
+  y = 1 ./ sin (x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert(all (abs (csc (x) - v) < sqrt (eps)));
+%! assert (all (abs (csc (x) - v) < sqrt (eps)));
 
-%!error csc ();
+%!error csc ()
+%!error csc (1, 2)
 
-%!error csc (1, 2);
-
diff --git a/scripts/elfun/cscd.m b/scripts/elfun/cscd.m
--- a/scripts/elfun/cscd.m
+++ b/scripts/elfun/cscd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,20 +20,24 @@
 ## @deftypefn {Function File} {} cscd (@var{x})
 ## Compute the cosecant for each element of @var{x} in degrees.
 ## @seealso{acscd, csc}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = cscd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = 1 ./ sind (x);
+
 endfunction
 
-%!error(cscd())
-%!error(cscd(1,2))
-%!assert(cscd(10:10:90),csc(pi*[10:10:90]/180),-10*eps)
-%!assert(cscd([0,180,360]) == Inf)
-%!assert(cscd([90,270]) != Inf)
 
+%!assert (cscd (10:10:90), csc (pi*[10:10:90]/180), -10*eps)
+%!assert (cscd ([0, 180, 360]) == Inf)
+%!assert (cscd ([90, 270]) != Inf)
+
+%!error cscd ()
+%!error cscd (1, 2)
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,21 +25,21 @@
 ## Author: jwe
 
 function y = csch (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = 1 ./ sinh(x);
+  y = 1 ./ sinh (x);
 
 endfunction
 
+
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [-i, i];
-%! assert(all (abs (csch (x) - v) < sqrt (eps)));
+%! assert (all (abs (csch (x) - v) < sqrt (eps)));
 
-%!error csch ();
+%!error csch ()
+%!error csch (1, 2)
 
-%!error csch (1, 2);
-
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,23 +25,23 @@
 ## Author: jwe
 
 function y = sec (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = 1 ./ cos(x);
+  y = 1 ./ cos (x);
 
 endfunction
 
+
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert(all (abs (sec (x) - v) < sqrt (eps)));
+%! assert (all (abs (sec (x) - v) < sqrt (eps)));
 
-%!error sec ();
+%!error sec ()
+%!error sec (1, 2)
 
-%!error sec (1, 2);
-
diff --git a/scripts/elfun/secd.m b/scripts/elfun/secd.m
--- a/scripts/elfun/secd.m
+++ b/scripts/elfun/secd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,19 +20,24 @@
 ## @deftypefn {Function File} {} secd (@var{x})
 ## Compute the secant for each element of @var{x} in degrees.
 ## @seealso{asecd, sec}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = secd (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   y = 1 ./ cosd (x);
+
 endfunction
 
-%!error(secd())
-%!error(secd(1,2))
-%!assert(secd(0:10:80),sec(pi*[0:10:80]/180),-10*eps)
-%!assert(secd([0,180,360]) != Inf)
-%!assert(secd([90,270]) == Inf)
+
+%!assert (secd (0:10:80), sec (pi*[0:10:80]/180), -10*eps)
+%!assert (secd ([0, 180, 360]) != Inf)
+%!assert (secd ([90, 270]) == Inf)
+
+%!error secd ()
+%!error secd (1, 2)
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,21 +25,21 @@
 ## Author: jwe
 
 function y = sech (x)
 
 if (nargin != 1)
     print_usage ();
   endif
 
-  y = 1 ./ cosh(x);
+  y = 1 ./ cosh (x);
 
 endfunction
 
+
 %!test
 %! x = [0, pi*i];
 %! v = [1, -1];
-%! assert(all (abs (sech (x) - v) < sqrt (eps)));
+%! assert (all (abs (sech (x) - v) < sqrt (eps)));
 
-%!error sech ();
+%!error sech ()
+%!error sech (1, 2)
 
-%!error sech (1, 2);
-
diff --git a/scripts/elfun/sind.m b/scripts/elfun/sind.m
--- a/scripts/elfun/sind.m
+++ b/scripts/elfun/sind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,21 +21,26 @@
 ## Compute the sine for each element of @var{x} in degrees.  Returns zero
 ## for elements where @code{@var{x}/180} is an integer.
 ## @seealso{asind, sin}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = sind (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   I = x / 180;
   y = sin (I .* pi);
   y(I == fix (I) & finite (I)) = 0;
+
 endfunction
 
-%!error(sind())
-%!error(sind(1,2))
-%!assert(sind(10:10:90),sin(pi*[10:10:90]/180),-10*eps)
-%!assert(sind([0,180,360]) == 0)
-%!assert(sind([90,270]) != 0)
+
+%!assert (sind (10:10:90), sin (pi*[10:10:90]/180), -10*eps)
+%!assert (sind ([0, 180, 360]) == 0)
+%!assert (sind ([90, 270]) != 0)
+
+%!error sind ()
+%!error sind (1, 2)
diff --git a/scripts/elfun/tand.m b/scripts/elfun/tand.m
--- a/scripts/elfun/tand.m
+++ b/scripts/elfun/tand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,23 +22,28 @@
 ## for elements where @code{@var{x}/180} is an integer and @code{Inf} for
 ## elements where @code{(@var{x}-90)/180} is an integer.
 ## @seealso{atand, tan}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = tand (x)
+
   if (nargin != 1)
     print_usage ();
   endif
+
   I0 = x / 180;
   I90 = (x-90) / 180;
   y = tan (I0 .* pi);
   y(I0 == fix (I0) & finite (I0)) = 0;
   y(I90 == fix (I90) & finite (I90)) = Inf;
-endfunction;
+
+endfunction
+
 
-%!error(tand())
-%!error(tand(1,2))
-%!assert(tand(10:10:80),tan(pi*[10:10:80]/180),-10*eps)
-%!assert(tand([0,180,360]) == 0)
-%!assert(tand([90,270]) == Inf)
+%!assert (tand (10:10:80), tan (pi*[10:10:80]/180), -10*eps)
+%!assert (tand ([0, 180, 360]) == 0)
+%!assert (tand ([90, 270]) == Inf)
+
+%!error tand ()
+%!error tand (1, 2)
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2009-2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -21,24 +21,26 @@
 ## @deftypefn  {Function File} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{func}, @var{fillval}, @var{issparse})
 ## @deftypefnx {Function File} {} accumarray (@var{subs}, @var{vals}, @dots{})
 ##
 ## Create an array by accumulating the elements of a vector into the
 ## positions defined by their subscripts.  The subscripts are defined by
 ## the rows of the matrix @var{subs} and the values by @var{vals}.  Each
 ## row of @var{subs} corresponds to one of the values in @var{vals}.  If
 ## @var{vals} is a scalar, it will be used for each of the row of
-## @var{subs}.
+## @var{subs}.  If @var{subs} is a cell array of vectors, all vectors
+## must be of the same length, and the subscripts in the @var{k}th
+## vector must correspond to the @var{k}th dimension of the result.
 ##
 ## The size of the matrix will be determined by the subscripts
 ## themselves.  However, if @var{sz} is defined it determines the matrix
 ## size.  The length of @var{sz} must correspond to the number of columns
 ## in @var{subs}.  An exception is if @var{subs} has only one column, in
-## which case @var{sz} may be the dimensions of a vector and the subscripts
-## of @var{subs} are taken as the indices into it.
+## which case @var{sz} may be the dimensions of a vector and the
+## subscripts of @var{subs} are taken as the indices into it.
 ##
 ## The default action of @code{accumarray} is to sum the elements with
 ## the same subscripts.  This behavior can be modified by defining the
 ## @var{func} function.  This should be a function or function handle
 ## that accepts a column vector and returns a scalar.  The result of the
 ## function should not depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated
@@ -58,19 +60,19 @@
 ## The following @code{accumarray} example constructs a frequency table
 ## that in the first column counts how many occurrences each number in
 ## the second column has, taken from the vector @var{x}.  Note the usage
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
 ## the same index (@pxref{doc-unique}).
 ##
 ## @example
 ## @group
-## x = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
-## [u, ~, j] = unique (x);
-## [accumarray(j', 1), u']
+## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
+## [@var{u}, ~, @var{j}] = unique (@var{x});
+## [accumarray(@var{j}', 1), @var{u}']
 ## @result{} 2    89
 ##    3    90
 ##    2    91
 ##    2    92
 ##    3   100
 ## @end group
 ## @end example
 ##
@@ -84,55 +86,91 @@
 ##              2, 3, 2;
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
 ##    ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
-## The complexity in the non-sparse case is generally O(M+N), where N is
-## the number of subscripts and M is the maximum subscript (linearized
-## in multi-dimensional case).  If @var{func} is one of @code{@@sum}
-## (default), @code{@@max}, @code{@@min} or @code{@@(x) @{x@}}, an
-## optimized code path is used.  Note that for general reduction function
-## the interpreter overhead can play a major part and it may be more
-## efficient to do multiple accumarray calls and compute the results in
-## a vectorized manner.
+## The sparse option can be used as an alternative to the @code{sparse}
+## constructor (@pxref{doc-sparse}). Thus
+##
+## @example
+## sparse (@var{i}, @var{j}, @var{sv})
+## @end example
+##
+## @noindent
+## can be written with @code{accumarray} as
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], [], 0, true)
+## @end example
 ##
-## @seealso{accumdim, unique}
+## @noindent
+## For repeated indices, @code{sparse} adds the corresponding value. To
+## take the minimum instead, use @code{min} as an accumulator function:
+##
+## @example
+## accumarray ([@var{i}, @var{j}], @var{sv}', [], @@min, 0, true)
+## @end example
+##
+## The complexity of accumarray in general for the non-sparse case is
+## generally O(M+N), where N is the number of subscripts and M is the
+## maximum subscript (linearized in multi-dimensional case).  If
+## @var{func} is one of @code{@@sum} (default), @code{@@max},
+## @code{@@min} or @code{@@(x) @{x@}}, an optimized code path is used.
+## Note that for general reduction function the interpreter overhead can
+## play a major part and it may be more efficient to do multiple
+## accumarray calls and compute the results in a vectorized manner.
+##
+## @seealso{accumdim, unique, sparse}
 ## @end deftypefn
 
 function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
+  lenvals = length (vals);
+
   if (iscell (subs))
-    subs = cellfun ("vec", subs, "uniformoutput", false);
+    subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
     if (ndims == 1)
       subs = subs{1};
     endif
+
+    lensubs = cellfun (@length, subs);
+
+    if (any (lensubs != lensubs(1)) || 
+        (lenvals > 1 && lenvals != lensubs(1)))
+      error ("accumarray: dimension mismatch");
+    endif
+
   else
     ndims = columns (subs);
+    if (lenvals > 1 && lenvals != rows (subs))
+      error ("accumarray: dimension mismatch")
+    endif
   endif
 
   if (isempty (fillval))
     fillval = 0;
   endif
 
   if (isempty (issparse))
     issparse = false;
   endif
 
   if (issparse)
 
-    ## Sparse case. Avoid linearizing the subscripts, because it could overflow.
+    ## Sparse case. Avoid linearizing the subscripts, because it could
+    ## overflow.
 
     if (fillval != 0)
       error ("accumarray: FILLVAL must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
     if (iscell (subs))
       subs = [subs{:}];
@@ -148,18 +186,18 @@ function A = accumarray (subs, vals, sz 
     if (isnumeric (vals) || islogical (vals))
       vals = double (vals);
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
-      ## Reduce values. This is not needed if we're about to sum them, because
-      ## "sparse" can do that.
+      ## Reduce values. This is not needed if we're about to sum them,
+      ## because "sparse" can do that.
 
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
 
@@ -233,17 +271,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @max)
       ## Fast maximization.
 
       if (isinteger (vals))
         zero = intmin (class (vals));
       elseif (islogical (vals))
         zero = false;
       elseif (fillval == 0 && all (vals(:) >= 0))
-        ## This is a common case - fillval is zero, all numbers nonegative.
+        ## This is a common case - fillval is zero, all numbers
+        ## nonegative.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_max__ (subs, vals, zero);
       else
@@ -259,17 +298,18 @@ function A = accumarray (subs, vals, sz 
     elseif (func == @min)
       ## Fast minimization.
 
       if (isinteger (vals))
         zero = intmax (class (vals));
       elseif (islogical (vals))
         zero = true;
       elseif (fillval == 0 && all (vals(:) <= 0))
-        ## This is a common case - fillval is zero, all numbers nonpositive.
+        ## This is a common case - fillval is zero, all numbers
+        ## non-positive.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
         A = __accumarray_min__ (subs, vals, zero);
       else
@@ -293,24 +333,31 @@ function A = accumarray (subs, vals, sz 
       endif
 
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       jdx = [jdx; n];
       vals = mat2cell (vals(idx), diff ([0; jdx]));
-      ## Optimize the case when function is @(x) {x}, i.e. we just want to
-      ## collect the values to cells.
+      ## Optimize the case when function is @(x) {x}, i.e. we just want
+      ## to collect the values to cells.
       persistent simple_cell_str = func2str (@(x) {x});
       if (! strcmp (func2str (func), simple_cell_str))
         vals = cellfun (func, vals);
       endif
       subs = subs(jdx);
 
+      if (isempty (sz))
+        sz = max (subs);
+        if (length (sz) == 1)
+          sz(2) = 1;
+        endif
+      endif
+
       ## Construct matrix of fillvals.
       if (iscell (vals))
         A = cell (sz);
       elseif (fillval == 0)
         A = zeros (sz, class (vals));
       else
         A = repmat (fillval, sz);
       endif
@@ -323,16 +370,17 @@ endfunction
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
 %!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
 %!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,42 +17,47 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} accumdim (@var{subs}, @var{vals}, @var{dim}, @var{n}, @var{func}, @var{fillval})
 ## Create an array by accumulating the slices of an array into the
 ## positions defined by their subscripts along a specified dimension.
 ## The subscripts are defined by the index vector @var{subs}.
 ## The dimension is specified by @var{dim}.  If not given, it defaults
-## to the first non-singleton dimension.
+## to the first non-singleton dimension.  The length of @var{subs} must
+## be equal to @code{size (@var{vals}, @var{dim})}.
 ##
-## The extent of the result matrix in the working dimension will be determined
-## by the subscripts themselves.
-## However, if @var{n} is defined it determines this extent.
+## The extent of the result matrix in the working dimension will be
+## determined by the subscripts themselves.  However, if @var{n} is
+## defined it determines this extent.
 ##
 ## The default action of @code{accumdim} is to sum the subarrays with the
-## same subscripts.  This behavior can be modified by defining the @var{func}
-## function.  This should be a function or function handle that accepts an
-## array and a dimension, and reduces the array along this dimension.
-## As a special exception, the built-in @code{min} and @code{max} functions
-## can be used directly, and @code{accumdim} accounts for the middle empty
-## argument that is used in their calling.
+## same subscripts.  This behavior can be modified by defining the
+## @var{func} function.  This should be a function or function handle
+## that accepts an array and a dimension, and reduces the array along
+## this dimension.  As a special exception, the built-in @code{min} and
+## @code{max} functions can be used directly, and @code{accumdim}
+## accounts for the middle empty argument that is used in their calling.
 ##
-## The slices of the returned array that have no subscripts associated with
-## them are set to zero.  Defining @var{fillval} to some other value allows
-## these values to be defined.
+## The slices of the returned array that have no subscripts associated
+## with them are set to zero.  Defining @var{fillval} to some other
+## value allows these values to be defined.
 ##
 ## An example of the use of @code{accumdim} is:
 ##
-## @smallexample
+## @example
 ## @group
-## accumdim ([1, 2, 1, 2, 1], [7,-10,4;-5,-12,8;-12,2,8;-10,9,-3;-5,-3,-13])
+## accumdim ([1, 2, 1, 2, 1], [ 7, -10,   4;
+##                             -5, -12,   8;
+##                            -12,   2,   8;
+##                            -10,   9,  -3;
+##                             -5,  -3, -13])
 ## @result{} ans = [-10,-11,-1;-15,-3,5]
 ## @end group
-## @end smallexample
+## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
 function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
@@ -63,34 +68,39 @@ function A = accumdim (subs, vals, dim, 
   endif
 
   if (! isvector (subs))
     error ("accumdim: SUBS must be a subscript vector");
   elseif (! isindex (subs)) # creates index cache
     error ("accumdim: indices must be positive integers");
   else
     m = max (subs);
-    if (n == 0)
+    if (n == 0 || isempty (n))
       n = m;
     elseif (n < m)
       error ("accumdim: N index out of range");
     endif
   endif
 
   sz = size (vals);
 
   if (nargin < 3)
-    [~, dim] = max (sz != 1); # first non-singleton dim
+    ## Find the first non-singleton dimension.
+    (dim = find (sz > 1, 1)) || (dim = 1);
   elseif (! isindex (dim))
     error ("accumdim: DIM must be a valid dimension");
   elseif (dim > length (sz))
     sz(end+1:dim) = 1;
   endif
   sz(dim) = n;
 
+  if (length (subs) != size (vals, dim))
+    error ("accumdim: dimension mismatch")
+  endif
+
   if (isempty (func) || func == @sum)
     ## Fast summation case.
     A = __accumdim_sum__ (subs, vals, dim, n);
 
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Hoxide Ma
+## Copyright (C) 2005-2012 Hoxide Ma
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -193,16 +193,21 @@ function zi = bicubic (x, y, z, xi, yi, 
     zi(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     zi([yfirst_ind; ylast_ind], :) = extrapval;
   endif
 
 endfunction
 
+
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]+10; y=[-10,-9,-8];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,bicubic(x,y,A,xi,yi));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]+10;
+%! y = [-10,-9,-8];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
+%! mesh (xi, yi, bicubic (x,y,A,xi,yi));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
+
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Laurent Mazet
+## Copyright (C) 2005-2012 Laurent Mazet
 ## Copyright (C) 2010 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -73,32 +73,33 @@ function m = cell2mat (c)
       cc = num2cell (c, xdim);
       c = cellfun ("cat", {idim}, cc{:}, "uniformoutput", false);
     endfor
     m = c{1};
   endif
 
 endfunction
 
-## Tests
-%!shared C, D, E, F
+
+%!demo
+%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
+%! cell2mat (C)
+
+%!assert (cell2mat ({}), []);
+%!test
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! D = C; D(:,:,2) = C;
 %! E = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! F = E; F(:,:,2) = E;
-%!assert (cell2mat (C), E);
-%!assert (cell2mat (D), F);
+%! assert (cell2mat (C), E);
+%! assert (cell2mat (D), F);
 %!test
 %! m = rand (10) + i * rand (10);
 %! c = mat2cell (m, [1 2 3 4], [4 3 2 1]);
-%! assert (cell2mat (c), m)
+%! assert (cell2mat (c), m);
 %!test
 %! m = int8 (256*rand (4, 5, 6, 7, 8));
 %! c = mat2cell (m, [1 2 1], [1 2 2], [3 1 1 1], [4 1 2], [3 1 4]);
-%! assert (cell2mat (c), m)
+%! assert (cell2mat (c), m);
 %!test
 %! m = {1, 2, 3};
 %! assert (cell2mat (mat2cell (m, 1, [1 1 1])), m);
-%!assert (cell2mat ({}), []);
-## Demos
-%!demo
-%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
-%! cell2mat (C)
+
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -73,15 +73,16 @@ function s = indices (dv, i)
     [c{:}] = ind2sub (dv, i);
     s = sprintf("%i,", c{:});
     s(end) = [];
   else
     s = sprintf("%i", i);
   endif
 endfunction
 
+
 %!demo
 %! c = {1, 2, {31, 32}};
-%! celldisp(c, "b")
+%! celldisp (c, "b")
 
 %!error celldisp ();
 %!error celldisp ({}, "name", 1);
 %!error celldisp (1);
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -134,31 +134,33 @@ function y = cplxpair (z, tol, dim)
     endfor
   endfor
 
   ## Reshape the output matrix.
   y = ipermute (reshape (y, sz), perm);
 
 endfunction
 
+
 %!demo
 %! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]
 
-%!assert (isempty(cplxpair([])));
-%!assert (cplxpair(1), 1)
-%!assert (cplxpair([1+1i, 1-1i]), [1-1i, 1+1i])
-%!assert (cplxpair([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), \
-%!        [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
-%!assert (cplxpair([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), \
-%!        [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
-%!assert (cplxpair([0, 1, 2]), [0, 1, 2]);
+%!assert (isempty (cplxpair ([])))
+%!assert (cplxpair (1), 1)
+%!assert (cplxpair ([1+1i, 1-1i]), [1-1i, 1+1i])
+%!assert (cplxpair ([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), ...
+%!                  [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
+%!assert (cplxpair ([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), ...
+%!                  [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
+%!assert (cplxpair ([0, 1, 2]), [0, 1, 2])
 
 %!shared z
-%! z=exp(2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair([z(randperm(7)),z(randperm(7))]),[z,z])
-%!assert (cplxpair([z(randperm(7)),z(randperm(7))],[],1),[z,z])
-%!assert (cplxpair([z(randperm(7)).';z(randperm(7)).'],[],2),[z.';z.'])
+%! z = exp (2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
+%!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
+%!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
 %!## tolerance test
-%!assert (cplxpair([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)]);
+%!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
+
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Ariel Tankus
+## Copyright (C) 1998-2012 Ariel Tankus
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2007  David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney, Robert Platt
+## Copyright (C) 2008-2012 Bill Denney, Robert Platt
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -293,83 +293,88 @@ function yi = interp1 (x, y, varargin)
       endif
     endif
   else
     yi.orient = "first";
   endif
 
 endfunction
 
+
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5);
-%! xp=0:10;      yp = sin(2*pi*xp/5);
-%! lin=interp1(xp,yp,xf,"linear");
-%! spl=interp1(xp,yp,xf,"spline");
-%! cub=interp1(xp,yp,xf,"pchip");
-%! near=interp1(xp,yp,xf,"nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
-%! legend ("original","nearest","linear","pchip","spline")
+%! clf;
+%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
+%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! lin = interp1 (xp,yp,xf, "linear");
+%! spl = interp1 (xp,yp,xf, "spline");
+%! cub = interp1 (xp,yp,xf, "pchip");
+%! near= interp1 (xp,yp,xf, "nearest");
+%! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
+%! legend ("original", "nearest", "linear", "pchip", "spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5);
-%! xp=0:10;      yp = sin(2*pi*xp/5);
-%! lin=interp1(xp,yp,xf,"*linear");
-%! spl=interp1(xp,yp,xf,"*spline");
-%! cub=interp1(xp,yp,xf,"*cubic");
-%! near=interp1(xp,yp,xf,"*nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
-%! legend ("*original","*nearest","*linear","*cubic","*spline")
+%! clf;
+%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
+%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! lin = interp1 (xp,yp,xf, "*linear");
+%! spl = interp1 (xp,yp,xf, "*spline");
+%! cub = interp1 (xp,yp,xf, "*cubic");
+%! near= interp1 (xp,yp,xf, "*nearest");
+%! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
+%! legend ("*original", "*nearest", "*linear", "*cubic", "*spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
+%! clf;
 %! t = 0 : 0.3 : pi; dt = t(2)-t(1);
 %! n = length (t); k = 100; dti = dt*n/k;
 %! ti = t(1) + [0 : k-1]*dti;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
-%! ddyc = diff(diff(interp1(t,y,ti,'cubic'))./dti)./dti;
-%! ddys = diff(diff(interp1(t,y,ti,'spline'))./dti)./dti;
-%! ddyp = diff(diff(interp1(t,y,ti,'pchip'))./dti)./dti;
-%! plot (ti(2:end-1), ddyc,'g+',ti(2:end-1),ddys,'b*', ...
-%!       ti(2:end-1),ddyp,'c^');
-%! legend('cubic','spline','pchip');
-%! title("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
+%! ddyc = diff (diff (interp1 (t,y,ti, "cubic")) ./dti)./dti;
+%! ddys = diff (diff (interp1 (t,y,ti, "spline"))./dti)./dti;
+%! ddyp = diff (diff (interp1 (t,y,ti, "pchip")) ./dti)./dti;
+%! plot (ti(2:end-1),ddyc,'g+', ti(2:end-1),ddys,'b*', ti(2:end-1),ddyp,'c^');
+%! legend ("cubic", "spline", "pchip");
+%! title ("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
 
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5) - (xf >= 5);
-%! xp=[0:.5:4.5,4.99,5:.5:10];      yp = sin(2*pi*xp/5) - (xp >= 5);
-%! lin=interp1(xp,yp,xf,"linear");
-%! near=interp1(xp,yp,xf,"nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xp,yp,"r*");
-%! legend ("original","nearest","linear")
+%! clf;
+%! xf = 0:0.05:10;               yf = sin (2*pi*xf/5) - (xf >= 5);
+%! xp = [0:.5:4.5,4.99,5:.5:10]; yp = sin (2*pi*xp/5) - (xp >= 5);
+%! lin = interp1 (xp,yp,xf, "linear");
+%! near= interp1 (xp,yp,xf, "nearest");
+%! plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xp,yp,"r*");
+%! legend ("original", "nearest", "linear");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 ##FIXME: add test for n-d arguments here
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
 ## from the knots are requested, but only 'nearest' and 'linear'
 ## confirm they are the correct values.
 
 %!shared xp, yp, xi, style
-%! xp=0:2:10;      yp = sin(2*pi*xp/5);
+%! xp = 0:2:10;
+%! yp = sin (2*pi*xp/5);
 %! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];
 
-
 ## The following BLOCK/ENDBLOCK section is repeated for each style
 ##    nearest, linear, cubic, spline, pchip
 ## The test for ppval of cubic has looser tolerance, but otherwise
 ## the tests are identical.
 ## Note that the block checks style and *style; if you add more tests
-## before to add them to both sections of each block.  One test,
+## be sure to add them to both sections of each block.  One test,
 ## style vs. *style, occurs only in the first section.
 ## There is an ENDBLOCKTEST after the final block
+
 %!test style = "nearest";
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -394,16 +399,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='linear';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -428,16 +434,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='cubic';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -462,16 +469,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),100*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='pchip';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -496,16 +504,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='spline';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -441,118 +441,138 @@ function ind = sym_sub2ind(sz, Y, X)
     X (X > 2 * sz (2)) = round (X (X > 2 * sz (2)) / 2);
   endwhile
   X (X > sz (2)) = 1 + 2 * sz (2) - X (X > sz (2));
   ind = sub2ind(sz, Y, X);
 endfunction
 
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! clf;
+%! colormap ("default");
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! clf;
+%! colormap ("default");
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! clf;
+%! colormap ("default");
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! clf;
+%! colormap ("default");
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! clf;
+%! colormap ("default");
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
+%!  [X, Y] = meshgrid (x,y);
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [1.2,2, 1.5];
 %!  yi = [6.2, 4.0, 5.0]';
 %!
 %!  Expected = ...
 %!    [243,   245.4,  243.9;
 %!      65.6,  68,     66.5;
 %!     126.6, 129,    127.5];
-%!  Result = interp2(x,y,Orig, xi, yi);
+%!  Result = interp2 (x,y,Orig, xi, yi);
 %!
 %!  assert(Result, Expected, 1000*eps);
 
 %!test % 2^n form
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
 %!  [X, Y] = meshgrid(x,y);
 %!  Orig = X.^2 + Y.^3;
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,17 +22,17 @@
 ##
 ## Fourier interpolation.  If @var{x} is a vector, then @var{x} is
 ## resampled with @var{n} points.  The data in @var{x} is assumed to be
 ## equispaced.  If @var{x} is an array, then operate along each column of
 ## the array separately.  If @var{dim} is specified, then interpolate
 ## along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
-## and so assumptions are made about the end points of the interpolation.
+## and so assumptions are made about the endpoints of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## 2001-02-11
 ##    * initial version
 ## 2002-03-17 aadler
@@ -87,30 +87,33 @@ function z = interpft (x, n, dim)
   endif
 
   z = ipermute (z, perm);
 
 endfunction
 
 
 %!demo
+%! clf;
 %! t = 0 : 0.3 : pi; dt = t(2)-t(1);
 %! n = length (t); k = 100;
 %! ti = t(1) + [0 : k-1]*dt*n/k;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-%! plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
-%!       ti, interpft (y, k), 'c', t, y, 'r+');
-%! legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
+%! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
+%!       ti, interpft (y, k), 'c', t, y, "r+");
+%! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]'; y = sin(x); n = length (x);
-%!assert (interpft(y, n), y, 20*eps);
-%!assert (interpft(y', n), y', 20*eps);
-%!assert (interpft([y,y],n), [y,y], 20*eps);
+%!assert (interpft (y, n), y, 20*eps);
+%!assert (interpft (y', n), y', 20*eps);
+%!assert (interpft ([y,y],n), [y,y], 20*eps);
 
 %% Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
-%!error (interpft(1,[n,n]))
-%!error (interpft(1,2,0))
-%!error (interpft(1,2,3))
+%!error <N must be a scalar integer> interpft (1,[2,2])
+%!error <N must be a scalar integer> interpft (1,2.1)
+%!error <invalid dimension DIM> interpft (1,2,0)
+%!error <invalid dimension DIM> interpft (1,2,3)
+
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -204,111 +204,117 @@ function vi = interpn (varargin)
   elseif (strcmp (method, "cubic"))
     error ("interpn: cubic interpolation not yet implemented");
   else
     error ("interpn: unrecognized interpolation METHOD");
   endif
 
 endfunction
 
+
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"linear").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "linear").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"nearest").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "nearest").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
-%!#demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"cubic").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%!#demo  # FIXME: Uncomment when support for "cubic" has been added
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "cubic").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"spline").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
-
+%! clf;
+%! colormap ("default");
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "spline").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
+%! clf;
+%! colormap ("default");
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.1:1;
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+%! vi = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
 %! mesh (yi, zi, squeeze (vi(1,:,:)));
 
-
 %!test
-%! [x,y,z] = ndgrid(0:2);
-%! f = x+y+z;
-%! assert (interpn(x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5])
-%! assert (interpn(x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],'nearest'), [3, 6])
-%! assert (interpn(x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],'spline'), [1.5, 4.5])
-%! assert (interpn(x,y,z,f,x,y,z), f)
-%! assert (interpn(x,y,z,f,x,y,z,'nearest'), f)
-%! assert (interpn(x,y,z,f,x,y,z,'spline'), f)
+%! [x,y,z] = ndgrid (0:2);
+%! f = x + y + z;
+%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5]);
+%! assert (interpn (x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],"nearest"), [3, 6]);
+%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],"spline"), [1.5, 4.5]);
+%! assert (interpn (x,y,z,f,x,y,z), f);
+%! assert (interpn (x,y,z,f,x,y,z,"nearest"), f);
+%! assert (interpn (x,y,z,f,x,y,z,"spline"), f);
 
 %!test
 %! [x, y, z] = ndgrid (0:2, 1:4, 2:6);
 %! f = x + y + z;
-%! xi = [0.5 1.0 1.5];
-%! yi = [1.5 2.0 2.5 3.5];
-%! zi = [2.5 3.5 4.0 5.0 5.5];
+%! xi = [0.5 1.0 1.5];  yi = [1.5 2.0 2.5 3.5];  zi = [2.5 3.5 4.0 5.0 5.5];
 %! fi = interpn (x, y, z, f, xi, yi, zi);
 %! [xi, yi, zi] = ndgrid (xi, yi, zi);
-%! assert (fi, xi + yi + zi)
+%! assert (fi, xi + yi + zi);
 
 %!test
-%! xi = 0:2;
-%! yi = 1:4;
-%! zi = 2:6;
+%! xi = 0:2;  yi = 1:4;  zi = 2:6;
 %! [x, y, z] = ndgrid (xi, yi, zi);
 %! f = x + y + z;
 %! fi = interpn (x, y, z, f, xi, yi, zi, "nearest");
-%! assert (fi, x + y + z)
+%! assert (fi, x + y + z);
 
 %!test
-%! [x,y,z] = ndgrid(0:2);
-%! f = x.^2+y.^2+z.^2;
-%! assert (interpn(x,y,-z,f,1.5,1.5,-1.5), 7.5)
+%! [x,y,z] = ndgrid (0:2);
+%! f = x.^2 + y.^2 + z.^2;
+%! assert (interpn (x,y,-z,f,1.5,1.5,-1.5), 7.5);
 
-%!test % for Matlab-compatible rounding for 'nearest'
-%! X = meshgrid (1:4);
-%! assert (interpn (X, 2.5, 2.5, 'nearest'), 3);
+%!test  # for Matlab-compatible rounding for "nearest"
+%! x = meshgrid (1:4);
+%! assert (interpn (x, 2.5, 2.5, "nearest"), 3);
 
-%!shared z, zout, tol
+%!test
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
 %! for n = 1:5
 %!   zout(:,:,n) = [1 2 3 4 5;
-%!                  2 3 4 5 6; 
+%!                  2 3 4 5 6;
 %!                  3 4 5 6 7;
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
-%! end
-%! tol = 10 * eps;
-%!assert (interpn (z), zout, tol)
-%!assert (interpn (z, "linear"), zout, tol)
-%!assert (interpn (z, "spline"), zout, tol)
+%! endfor
+%! tol = 10*eps;
+%! assert (interpn (z), zout, tol);
+%! assert (interpn (z, "linear"), zout, tol);
+%! assert (interpn (z, "spline"), zout, tol);
+
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/iscolumn.m b/scripts/general/iscolumn.m
--- a/scripts/general/iscolumn.m
+++ b/scripts/general/iscolumn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -30,31 +30,27 @@ function retval = iscolumn (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(2) == 1));
 
 endfunction
 
-%!assert(iscolumn ([1, 2, 3]), false);
-%!assert(iscolumn ([1; 2; 3]));
-%!assert(iscolumn (1));
-%!assert(iscolumn ([]), false);
-%!assert(iscolumn ([1, 2; 3, 4]), false);
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((iscolumn ("t")));
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert(!(iscolumn ("test")));
+%!assert (iscolumn ([1, 2, 3]), false)
+%!assert (iscolumn ([1; 2; 3]))
+%!assert (iscolumn (1))
+%!assert (iscolumn ([]), false)
+%!assert (iscolumn ([1, 2; 3, 4]), false)
 
-%!assert(!(iscolumn (["test"; "ing"])));
+%!assert (iscolumn ("t"))
+%!assert (iscolumn ("test"), false)
+%!assert (iscolumn (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((iscolumn (s)));
+%! assert (iscolumn (s));
 
 %% Test input validation
-%!error iscolumn ();
-%!error iscolumn ([1, 2], 2);
+%!error iscolumn ()
+%!error iscolumn ([1, 2], 2)
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Alois Schloegl
+## Copyright (C) 2004-2012 Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isrow.m b/scripts/general/isrow.m
--- a/scripts/general/isrow.m
+++ b/scripts/general/isrow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -30,31 +30,27 @@ function retval = isrow (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(1) == 1));
 
 endfunction
 
-%!assert(isrow ([1, 2, 3]));
-%!assert(isrow ([1; 2; 3]), false);
-%!assert(isrow (1));
-%!assert(isrow ([]), false);
-%!assert(isrow ([1, 2; 3, 4]), false);
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isrow ("t")));
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isrow ("test")));
+%!assert (isrow ([1, 2, 3]))
+%!assert (isrow ([1; 2; 3]), false)
+%!assert (isrow (1))
+%!assert (isrow ([]), false)
+%!assert (isrow ([1, 2; 3, 4]), false)
 
-%!assert(!(isrow (["test"; "ing"])));
+%!assert (isrow ("t"))
+%!assert (isrow ("test"))
+%!assert (isrow (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isrow (s)));
+%! assert (isrow (s));
 
 %% Test input validation
-%!error isrow ();
-%!error isrow ([1, 2], 2);
+%!error isrow ()
+%!error isrow ([1, 2], 2)
 
diff --git a/scripts/general/isscalar.m b/scripts/general/isscalar.m
--- a/scripts/general/isscalar.m
+++ b/scripts/general/isscalar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,28 +29,26 @@ function retval = isscalar (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   retval = numel (x) == 1;
 
 endfunction
 
-%!assert(isscalar (1));
-%!assert(!(isscalar ([1, 2])));
-%!assert(!(isscalar ([])));
-%!assert(!(isscalar ([1, 2; 3, 4])));
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isscalar ("t")));
+%!assert (isscalar (1))
+%!assert (isscalar ([1, 2]), false)
+%!assert (isscalar ([]), false)
+%!assert (isscalar ([1, 2; 3, 4]), false)
 
-%!assert(!(isscalar ("test")));
-%!assert(!(isscalar (["test"; "ing"])));
+%!assert (isscalar ("t"))
+%!assert (isscalar ("test"), false)
+%!assert (isscalar (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isscalar (s)));
+%! assert (isscalar (s));
 
 %% Test input validation
-%!error isscalar ();
-%!error isscalar (1, 2);
+%!error isscalar ()
+%!error isscalar (1, 2)
 
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/isvector.m b/scripts/general/isvector.m
--- a/scripts/general/isvector.m
+++ b/scripts/general/isvector.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -32,31 +32,26 @@ function retval = isvector (x)
     print_usage ();
   endif
 
   sz = size (x);
   retval = (ndims (x) == 2 && (sz(1) == 1 || sz(2) == 1));
 
 endfunction
 
-%!assert(isvector (1));
-%!assert(isvector ([1; 2; 3]));
-%!assert(!(isvector ([])));
-%!assert(!(isvector ([1, 2; 3, 4])));
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isvector ("t")));
+%!assert (isvector (1))
+%!assert (isvector ([1; 2; 3]))
+%!assert (isvector ([]), false)
+%!assert (isvector ([1, 2; 3, 4]), false)
 
-%!test
-%! warning ("off", "Octave:str-to-num");
-%! assert((isvector ("test")));
-
-%!assert(!(isvector (["test"; "ing"])));
+%!assert (isvector ("t"))
+%!assert (isvector ("test"))
+%!assert (isvector (["test"; "ing"]), false)
 
 %!test
 %! s.a = 1;
-%! assert((isvector (s)));
+%! assert (isvector (s));
 
 %% Test input validation
-%!error isvector ();
-%!error isvector ([1, 2], 2);
+%!error isvector ()
+%!error isvector ([1, 2], 2)
 
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Carn√´ Draug
+## Copyright (C) 2012 Carn√´ Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Bill Denney
-## Copyright (C) 2011 Carn√´ Draug
+## Copyright (C) 2008-2012 Bill Denney
+## Copyright (C) 2012 Carn√´ Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Jordi Guti√©rrez Hermoso
+## Copyright (C) 2012 Jordi Guti√©rrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 David M. Doolin
+## Copyright (C) 1999-2012 David M. Doolin
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyarea (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} polyarea (@var{x}, @var{y}, @var{dim})
 ##
-## Determines area of a polygon by triangle method.  The variables
+## Determine area of a polygon by triangle method.  The variables
 ## @var{x} and @var{y} define the vertex pairs, and must therefore have
 ## the same shape.  They can be either vectors or arrays.  If they are
 ## arrays then the columns of @var{x} and @var{y} are treated separately
 ## and an area returned for each.
 ##
 ## If the optional @var{dim} argument is given, then @code{polyarea}
 ## works along this dimension of the arrays @var{x} and @var{y}.
 ##
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -27,17 +27,17 @@
 ## @seealso{profile, profshow}
 ## @end deftypefn
 
 ## Built-in profiler.
 ## Author: Daniel Kraft <d@domob.eu>
 
 function profexplore (data)
 
-  if (nargin ~= 1)
+  if (nargin != 1)
     print_usage ();
   endif
 
   ## The actual work is done by a recursive worker function, since that
   ## is an easy way to traverse the tree datastructure.  Here, we just check
   ## the arguments (already done) and give over to it.
 
   __profexplore_worker (data.FunctionTable, data.Hierarchical, "Top\n", "  ");
@@ -82,17 +82,17 @@ function rv = __profexplore_worker (fcn_
       rv = 0;
       return;
     elseif (strcmp (cmd, "help"))
       printf ("\nCommands for profile explorer:\n\n");
       printf ("exit   Return to Octave prompt.\n");
       printf ("help   Display this help message.\n");
       printf ("up [N] Go up N levels, where N is an integer.  Default is 1.\n");
       printf ("N      Go down a level into option N.\n");
-    elseif (~isnan (option))
+    elseif (! isnan (option))
       if (option < 1 || option > length (tree))
         printf ("The chosen option is out of range!\n");
       else
         newParents = sprintf ("%s%s%s\n", parents, prefix, strings{option});
         newPrefix = sprintf ("%s  ", prefix);
 
         rv = __profexplore_worker (fcn_table, tree(option).Children, ...
                                    newParents, newPrefix);
@@ -110,17 +110,17 @@ function rv = __profexplore_worker (fcn_
     elseif (length (cmd) >= 2 && strcmp (substr (cmd, 1, 2), "up"))
       if (length (cmd) == 2)
         rv = 1;
         return;
       endif
 
       if (length (cmd) > 3 && cmd(3) == ' ')
         opt = fix (str2double (substr (cmd, 3)));
-        if (~isnan (opt) && opt > 0)
+        if (! isnan (opt) && opt > 0)
           rv = opt;
           return;
         endif
       endif
 
       printf ("Invalid 'up' command.  Type 'help' for further");
       printf (" information.\n");
     else
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -64,88 +64,91 @@
 
 function retval = profile (option)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   switch (option)
-    case 'on'
+    case "on"
       __profiler_reset__ ();
       __profiler_enable__ (true);
 
-    case 'off'
+    case "off"
       __profiler_enable__ (false);
 
-    case 'clear'
+    case "clear"
       __profiler_reset__ ();
 
-    case 'resume'
+    case "resume"
       __profiler_enable__ (true);
 
-    case 'status'
+    case "status"
       enabled = __profiler_enable__ ();
       if (enabled)
-        enabled = 'on';
+        enabled = "on";
       else
-        enabled = 'off';
+        enabled = "off";
       endif
-      retval = struct ('ProfilerStatus', enabled);
+      retval = struct ("ProfilerStatus", enabled);
 
-    case 'info'
+    case "info"
       [flat, tree] = __profiler_data__ ();
-      retval = struct ('FunctionTable', flat, 'Hierarchical', tree);
+      retval = struct ("FunctionTable", flat, "Hierarchical", tree);
 
     otherwise
       warning ("profile: Unrecognized option '%s'", option);
       print_usage ();
 
   endswitch
 
 endfunction
 
 
 %!demo
-%! profile ('on');
+%! profile on;
 %! A = rand (100);
 %! B = expm (A);
-%! profile ('off');
-%! profile ('resume');
+%! profile off;
+%! profile resume;
 %! C = sqrtm (A);
-%! profile ('off');
-%! T = profile ('info');
+%! profile off;
+%! T = profile ("info");
 %! profshow (T);
 
-%!error profile ();
-%!error profile ('on', 2);
-
 %!test
 %! on_struct.ProfilerStatus = "on";
 %! off_struct.ProfilerStatus = "off";
-%! profile ('on');
+%! profile ("on");
 %! result = logm (rand (200) + 10 * eye (200));
-%! assert (profile ('status'), on_struct);
-%! profile ('off');
-%! assert (profile ('status'), off_struct);
-%! profile ('resume');
+%! assert (profile ("status"), on_struct);
+%! profile ("off");
+%! assert (profile ("status"), off_struct);
+%! profile ("resume");
 %! result = logm (rand (200) + 10 * eye (200));
-%! profile ('off');
-%! assert (profile ('status'), off_struct);
-%! info = profile ('info');
+%! profile ("off");
+%! assert (profile ("status"), off_struct);
+%! info = profile ("info");
 %! assert (isstruct (info));
 %! assert (size (info), [1, 1]);
-%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! assert (fieldnames (info), {"FunctionTable"; "Hierarchical"});
 %! ftbl = info.FunctionTable;
-%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
-%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'TotalTime'; 'NumCalls'; 'Children'});
-%! profile ('clear');
-%! info = profile ('info');
+%! assert (fieldnames (hier), {"Index"; "SelfTime"; "TotalTime"; "NumCalls"; "Children"});
+%! profile ("clear");
+%! info = profile ("info");
 %! assert (isstruct (info));
 %! assert (size (info), [1, 1]);
-%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! assert (fieldnames (info), {"FunctionTable"; "Hierarchical"});
 %! ftbl = info.FunctionTable;
 %! assert (size (ftbl), [0, 1]);
-%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
 %! assert (size (hier), [0, 1]);
-%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'NumCalls'; 'Children'});
+%! assert (fieldnames (hier), {"Index"; "SelfTime"; "NumCalls"; "Children"});
+
+%% Test input validation
+%!error profile ()
+%!error profile ("on", 2)
+%!error profile ("INVALID_OPTION");
+
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Daniel Kraft
+## Copyright (C) 2012 Daniel Kraft
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -76,25 +76,27 @@ function profshow (data, n = 20)
       attr = "R";
     endif
     printf (rowFormat, p(i), row.FunctionName, attr, ...
             row.TotalTime, row.NumCalls);
   endfor
 
 endfunction
 
+
 %!demo
-%! profile ("on");
+%! profile on;
 %! A = rand (100);
 %! B = expm (A);
-%! profile ("off");
+%! profile off;
 %! T = profile ("info");
 %! profshow (T, 10);
 
 %!demo
-%! profile ("on");
+%! profile on;
 %! expm (rand (500) + eye (500));
-%! profile ("off");
+%! profile off;
 %! profshow (profile ("info"), 5);
 
 %!error profshow ();
 %!error profshow (1, 2, 3);
 %!error profshow (struct (), 1.2);
+
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Walter Gautschi
+## Copyright (C) 1998-2012 Walter Gautschi
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -198,20 +198,20 @@ function q = adaptlobstp (f, a, b, fa, f
 endfunction
 
 
 ## basic functionality
 %!assert (quadl (@(x) sin (x), 0, pi, [], []), 2, -3e-16)
 
 ## the values here are very high so it may be unavoidable that this fails
 %!assert (quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15),
-%!         2.588424538641647e+10, -9e-15)
+%!         2.588424538641647e+10, -1.1e-14)
 
 ## extra parameters
 %!assert (quadl (@(x,a,b) sin (a + b*x), 0, 1, [], [], 2, 3),
-%!        cos(2)/3 - cos(5)/3, - 3e-16)
+%!        cos(2)/3 - cos(5)/3, -3e-16)
 
 ## test different tolerances.
 %!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.3, []),
 %!        (60 + sin(4) - sin(64))/12, -0.3)
 %!assert (quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []),
 %!        (60 + sin(4) - sin(64))/12, -0.1)
 
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 David Bateman
-## Copyright (C) 2011 Alexander Klein
+## Copyright (C) 2008-2012 David Bateman
+## Copyright (C) 2012 Alexander Klein
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Rik Wehbring
+## Copyright (C) 2010-2012 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -15,22 +15,23 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} repmat (@var{A}, @var{m})
 ## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n})
-## @deftypefnx {Function File} {} repmat (@var{A}, @var{m}, @var{n}, @var{p}, @dots{})
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
 ## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
 ## @var{A} as each element.  If @var{n} is not specified, form an
-## @var{m} by @var{m} block matrix.
+## @var{m} by @var{m} block matrix. For copying along more than two
+## dimensions, specify the number of times to copy across each dimension
+## @var{m}, @var{n}, @var{p}, @dots{}, in a vector in the second argument.
 ## @seealso{repelems}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Created: July 2000
 
 function x = repmat (A, m, n)
 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman
+## Copyright (C) 2004-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John Eaton and David Bateman
+## Copyright (C) 2004-2012 John Eaton and David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -80,16 +80,17 @@ function H = convhull (x, y, options)
   endfor
 
   H(n + 1) = H(1);
 
 endfunction
 
 
 %!demo
+%! clf;
 %! x = -3:0.05:3;
 %! y = abs (sin (x));
 %! k = convhull (x, y);
 %! plot (x(k),y(k),"r-;convex hull;", x,y,"b+;points;");
 %! axis ([-3.05, 3.05, -0.05, 1.05]);
 
 %!testif HAVE_QHULL
 %! x = -3:0.5:3;
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -97,18 +97,19 @@ endfunction
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 1);
 %! x = rand (1,10);
 %! y = rand (1,10);
 %! T = delaunay (x,y);
 %! VX = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
 %! VY = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
+%! clf;
+%! plot (VX,VY,"b", x,y,"r*");
 %! axis ([0,1,0,1]);
-%! plot (VX,VY,"b", x,y,"r*");
 
 %!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0];
 %! y = [0, 1, 0, -1];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;2,3,4]);
 
 %!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0, 0];
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -135,43 +135,51 @@ function [rx, ry, rz] = griddata (x, y, 
     rz = zi;
   elseif (nargout == 1)
     rx = zi;
   elseif (nargout == 0)
     mesh (xi, yi, zi);
   endif
 endfunction
 
-%!testif HAVE_QHULL
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! x = xx(:);
-%! x = x + 10 * (2 * round(rand(size(x))) - 1) * eps;
-%! y = yy(:);
-%! y = y + 10 * (2 * round(rand(size(y))) - 1) * eps;
-%! z = sin(2*(x.^2+y.^2));
-%! zz = griddata(x,y,z,xx,yy,'linear');
-%! zz2 = sin(2*(xx.^2+yy.^2));
-%! zz2(isnan(zz)) = NaN;
-%! assert (zz, zz2, 100 * eps)
+
+%!demo
+%! clf;
+%! colormap ("default");
+%! x = 2*rand (100,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! griddata (x,y,z,xx,yy);
+%! title ("nonuniform grid sampled at 100 points");
+
+%!demo
+%! clf;
+%! colormap ("default");
+%! x = 2*rand (1000,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! griddata (x,y,z,xx,yy);
+%! title ("nonuniform grid sampled at 1000 points");
 
 %!demo
-%! x=2*rand(100,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy);
-%! title('nonuniform grid sampled at 100 points');
+%! clf;
+%! colormap ("default");
+%! x = 2*rand (1000,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! griddata (x,y,z,xx,yy,"nearest");
+%! title ("nonuniform grid sampled at 1000 points with nearest neighbor");
 
-%!demo
-%! x=2*rand(1000,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy);
-%! title('nonuniform grid sampled at 1000 points');
+%!testif HAVE_QHULL
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! x = xx(:);
+%! x = x + 10*(2*round (rand (size(x))) - 1) * eps;
+%! y = yy(:);
+%! y = y + 10*(2*round (rand (size(y))) - 1) * eps;
+%! z = sin (2*(x.^2 + y.^2));
+%! zz = griddata (x,y,z,xx,yy,"linear");
+%! zz2 = sin (2*(xx.^2 + yy.^2));
+%! zz2(isnan (zz)) = NaN;
+%! assert (zz, zz2, 100*eps);
 
-%!demo
-%! x=2*rand(1000,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy,'nearest');
-%! title('nonuniform grid sampled at 1000 points with nearest neighbor');
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Frederick (Rick) A Niles
+## Copyright (C) 2006-2012 Frederick (Rick) A Niles
 ##               and SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -79,65 +79,69 @@ function [in, on] = inpolygon (x, y, xv,
                & (0 == distance | !delta_xv));
        on (idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
-%!demo
-%!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
-%!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
-%!       0.05840 ];
-%!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
-%!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
-%!       0.60628 ];
-%! xa=[0:0.1:2.3];
-%! ya=[0:0.1:1.4];
-%! [x,y]=meshgrid(xa,ya);
-%! [in,on]=inpolygon(x,y,xv,yv);
-%!
-%! inside=in & !on;
-%! plot(xv,yv)
-%! hold on
-%! plot(x(inside),y(inside),"@g")
-%! plot(x(~in),y(~in),"@m")
-%! plot(x(on),y(on),"@b")
-%! hold off
-%! disp("Green points are inside polygon, magenta are outside,");
-%! disp("and blue are on boundary.");
 
 %!demo
-%!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
-%!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
-%!       0.05840, 0.73295, 1.28913, 1.74221, 1.16023, \
-%!       0.73295, 0.05840 ];
-%!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
-%!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
-%!       0.60628, 0.82096, 0.67155, 0.96114, 1.14833, \
-%!       0.82096, 0.60628];
-%! xa=[0:0.1:2.3];
-%! ya=[0:0.1:1.4];
-%! [x,y]=meshgrid(xa,ya);
-%! [in,on]=inpolygon(x,y,xv,yv);
+%! xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
+%!        1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
+%!        0.05840 ];
+%! yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
+%!        0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
+%!        0.60628 ];
+%! xa = [0:0.1:2.3];
+%! ya = [0:0.1:1.4];
+%! [x,y] = meshgrid (xa, ya);
+%! [in,on] = inpolygon (x, y, xv, yv);
+%! inside = in & !on;
 %!
-%! inside=in & ~ on;
-%! plot(xv,yv)
-%! hold on
-%! plot(x(inside),y(inside),"@g")
-%! plot(x(~in),y(~in),"@m")
-%! plot(x(on),y(on),"@b")
-%! hold off
-%! disp("Green points are inside polygon, magenta are outside,");
-%! disp("and blue are on boundary.");
+%! clf;
+%! plot (xv, yv);
+%! hold on;
+%! plot (x(inside), y(inside), "@g")
+%! plot (x(!in), y(!in), "@m");
+%! plot (x(on), y(on), "@b");
+%! hold off;
+%! disp ("Green points are inside polygon, magenta are outside,");
+%! disp ("and blue are on boundary.");
 
-%!error inpolygon ();
-%!error inpolygon (1, 2);
-%!error inpolygon (1, 2, 3);
-
-%!error inpolygon (1, [1,2], [3, 4], [5, 6]);
-%!error inpolygon ([1,2], [3, 4], [5, 6], 1);
+%!demo
+%!  xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
+%!         1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
+%!         0.05840, 0.73295, 1.28913, 1.74221, 1.16023, ...
+%!         0.73295, 0.05840 ];
+%!  yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
+%!         0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
+%!         0.60628, 0.82096, 0.67155, 0.96114, 1.14833, ...
+%!         0.82096, 0.60628];
+%! xa = [0:0.1:2.3];
+%! ya = [0:0.1:1.4];
+%! [x,y] = meshgrid (xa, ya);
+%! [in,on] = inpolygon (x, y, xv, yv);
+%! inside = in & !on;
+%!
+%! clf;
+%! plot (xv, yv);
+%! hold on;
+%! plot (x(inside), y(inside), "@g");
+%! plot (x(!in), y(!in), "@m");
+%! plot (x(on), y(on), "@b");
+%! hold off;
+%! disp ("Green points are inside polygon, magenta are outside,");
+%! disp ("and blue are on boundary.");
 
 %!test
 %! [in, on] = inpolygon ([1, 0], [1, 0], [-1, -1, 1, 1], [-1, 1, 1, -1]);
 %! assert (in, [false, true]);
 %! assert (on, [true, false]);
+
+%% Test input validation
+%!error inpolygon ()
+%!error inpolygon (1, 2)
+%!error inpolygon (1, 2, 3)
+%!error inpolygon (1, [1,2], [3, 4], [5, 6])
+%!error inpolygon ([1,2], [3, 4], [5, 6], 1)
+
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -31,17 +31,17 @@
 ## diagram is drawn on the specified axis rather than in a new figure.
 ##
 ## The @var{options} argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
-## plotted and a graphics handle to the plot is returned.
+## plotted and a graphics handle @var{h} to the plot is returned.
 ## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the Voronoi vertices
 ## instead of plotting the diagram.
 ##
 ## @example
 ## @group
 ##   x = rand (10, 1);
 ##   y = rand (size (x));
 ##   h = convhull (x, y);
@@ -169,17 +169,17 @@ function [vx, vy] = voronoi (varargin)
     vx = Vvx;
     vy = Vvy;
   endif
 
 endfunction
 
 
 %!demo
-%! voronoi (rand(10,1), rand(10,1));
+%! voronoi (rand (10,1), rand (10,1));
 
 %!testif HAVE_QHULL
 %! phi = linspace (-pi, 3/4*pi, 8);
 %! [x,y] = pol2cart (phi, 1);
 %! [vx,vy] = voronoi (x,y);
 %! assert(vx(2,:), zeros (1, columns (vx)), eps);
 %! assert(vy(2,:), zeros (1, columns (vy)), eps);
 
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
--- a/scripts/gethelp.cc
+++ b/scripts/gethelp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 static bool
 looks_like_octave_copyright (const std::string& s)
 {
   // Perhaps someday we will want to do more here, so leave this as a
   // separate function.
 
-  return (s.substr (0, 9) == "Copyright");
+  return (s.substr (0, 9) == "Copyright" || s.substr (0, 6) == "Author");
 }
 
 // Eat whitespace and comments from FFILE, returning the text of the
 // first block of comments that doesn't look like a copyright notice,
 
 static std::string
 extract_help_text (void)
 {
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 S¯ren Hauberg
+## Copyright (C) 2005-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -176,10 +176,11 @@ function do_contents (name)
     endif
 
     error ("help: %s\n", msg);
   endif
 
 endfunction
 
 
-%!assert (! isempty (findstr (help ("ls"), "List directory contents")))
+%!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!error <invalid input> help (42)
+
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S¯ren Hauberg
+## Copyright (C) 2009-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/private/__additional_help_message__.m b/scripts/help/private/__additional_help_message__.m
--- a/scripts/help/private/__additional_help_message__.m
+++ b/scripts/help/private/__additional_help_message__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S¯ren Hauberg
+## Copyright (C) 2009-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S¯ren Hauberg
+## Copyright (C) 2009-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 SÔøΩren Hauberg
+## Copyright (C) 2009-2012 SÔøΩren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 John W. Eaton
+## Copyright (C) 2009-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -48,14 +48,15 @@ function map = autumn (n)
     b = zeros (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'autumn' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (autumn (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (autumn (64));
 
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -51,14 +51,15 @@ function map = bone (n)
       + (x >= 3/4) .* (7/8 * x + 1/8);
     b = (x < 3/8) .* (29/24 * x) + (x >= 3/8) .* (7/8 * x + 1/8);
     map = [r, g, b];
   else
     map = [];
   endif
 endfunction
 
+
 %!demo
 %! ## Show the 'bone' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (bone (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (bone (64));
 
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,18 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} colormap (@var{map})
-## @deftypefnx {Function File} {} colormap ("default")
+## @deftypefn  {Function File} {@var{cmap} =} colormap ()
+## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{map})
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("default")
 ## Set the current colormap.
 ##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## color map should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## should be between 0 and 1 inclusive.  The new colormap is returned.
 ##
 ## @code{colormap ("default")} restores the default colormap (the
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,20 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} contrast (@var{x}, @var{n})
+## @deftypefn  {Function File} {} contrast (@var{x})
+## @deftypefnx {Function File} {} contrast (@var{x}, @var{n})
 ## Return a gray colormap that maximizes the contrast in an image.  The
 ## returned colormap will have @var{n} rows.  If @var{n} is not defined
-## then the size of the current colormap is used instead.
+## then the size of the current colormap is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = contrast (x, n)
 
   if (nargin == 1)
     n = rows (colormap);
   elseif (nargin == 2)
@@ -37,14 +38,24 @@ function map = contrast (x, n)
   endif
 
   x = x(:);
   minx = min (x);
   map = find (diff (sort ([round(n * ((x - minx) ./ (max(x) - minx))); [0:n]'])));
   minm = min (map);
   map = (map - minm) ./ (max (map) - minm);
   map = [map, map, map];
+
 endfunction
 
-%!assert (contrast(1:100,10),[([0:9]/9)',([0:9]/9)',([0:9]/9)'],1e-10)
+
 %!demo
-%! image (reshape (1:100, 10, 10))
-%! colormap (contrast (1:100,10))
+%! clf;
+%! img = reshape (1:100, 10, 10);
+%! image (img);
+%! colormap (gray (10));
+%! title ("Image with default 256 gray levels");
+%! input ("Press <enter> to continue: ", "s");
+%! colormap (contrast (img));
+%! title ("Image with contrast enhanced");
+
+%!assert (contrast (1:100,10), [([0:9]/9)',([0:9]/9)',([0:9]/9)'], 1e-10)
+
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -47,14 +47,15 @@ function map = cool (n)
     b = ones (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'cool' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (cool (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (cool (64));
 
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -49,14 +49,15 @@ function map = copper (n)
     b = 1/2 * x;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'copper' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (copper (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (copper (64));
 
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -46,14 +46,15 @@ function map = flag (n)
   else
     m1 = kron (ones (fix (n / 4), 1), p);
     m2 = p(1:rem (n, 4), :);
     map = [m1; m2];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'flag' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (flag (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (flag (64));
 
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -44,14 +44,15 @@ function map = gmap40 (n)
     map = repmat ([1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1],
           ceil (n / 6), 1) (1:n, :);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gmap40' colormap as an image
-%! image (1:6, linspace (0, 1, 6), repmat (1:6, 6, 1)')
-%! axis ([1, 6, 0, 1], "ticy", "xy")
-%! colormap (gmap40 (6))
+%! image (1:6, linspace (0, 1, 6), repmat ((1:6)', 1, 6));
+%! axis ([1, 6, 0, 1], "ticy", "xy");
+%! colormap (gmap40 (6));
 
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -42,14 +42,15 @@ function map = gray (n)
   endif
 
   gr = [0:(n-1)]';
 
   map = [ gr, gr, gr ] / (n - 1);
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gray' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (gray (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (gray (64));
 
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -49,14 +49,15 @@ function map = hot (n)
     b = (x >= 4/5) .* (5*x - 4);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hot' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (hot (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (hot (64));
 
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -50,14 +50,15 @@ function map = hsv (n)
     h = linspace (0, 1, n)';
     map = hsv2rgb ([h, ones(n, 1), ones(n, 1)]);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hsv' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (hsv (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (hsv (64));
 
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,32 +14,35 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} image (@var{img})
 ## @deftypefnx {Function File} {} image (@var{x}, @var{y}, @var{img})
+## @deftypefnx {Function File} {@var{h} =} image (@dots{})
 ## Display a matrix as a color image.  The elements of @var{img} are indices
 ## into the current colormap, and the colormap will be scaled so that the
 ## extremes of @var{img} are mapped to the extremes of the colormap.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 ##
 ## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
 ## @code{ydir} property to @code{"reverse"}.  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
 ## using, for example, @code{flipud (ydata,1)}.
+##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = image (varargin)
@@ -90,17 +93,17 @@ endfunction
 ## @var{x} and @var{y}. If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = __img__ (x, y, img, varargin)
-
+  
   newplot ();
 
   if (isempty (img))
     error ("__img__: matrix is empty");
   endif
 
   if (isempty (x))
     x = [1, columns(img)];
@@ -108,16 +111,25 @@ function h = __img__ (x, y, img, varargi
 
   if (isempty (y))
     y = [1, rows(img)];
   endif
 
   xdata = [x(1), x(end)];
   ydata = [y(1), y(end)];
 
+  dx = diff (x);
+  dy = diff (y);
+  dx = std (dx) / mean (abs (dx));
+  dy = std (dy) / mean (abs (dy));
+  tol = 100*eps;
+  if (any (dx > tol) || any (dy > tol))
+    warning ("Image does not map to non-linearly spaced coordinates")
+  endif
+
   ca = gca ();
 
   tmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
                     "cdatamapping", "direct", varargin {:});
 
   px = __image_pixel_size__ (tmp);
 
   if (xdata(2) < xdata(1))
@@ -158,69 +170,74 @@ function h = __img__ (x, y, img, varargi
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
+%! colormap ("default");
 %! img = 1 ./ hilb (11);
 %! x = -5:5;
 %! y = x;
-%! subplot (2,2,1)
-%! h = image (abs(x), abs(y), img);
-%! set (h, "cdatamapping", "scaled")
-%! ylabel ("limits = [4.5, 15.5]")
-%! title ('image (abs(x), abs(y), img)')
-%! subplot (2,2,2)
-%! h = image (-x, y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (-x, y, img)')
-%! subplot (2,2,3)
-%! h = image (x, -y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (x, -y, img)')
-%! ylabel ("limits = [-5.5, 5.5]")
-%! subplot (2,2,4)
-%! h = image (-x, -y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (-x, -y, img)')
+%! subplot (2,2,1);
+%!  h = image (abs(x), abs(y), img);
+%!  set (h, "cdatamapping", "scaled");
+%!  ylabel ("limits = [4.5, 15.5]");
+%!  title ("image (abs(x), abs(y), img)");
+%! subplot (2,2,2);
+%!  h = image (-x, y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (-x, y, img)");
+%! subplot (2,2,3);
+%!  h = image (x, -y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (x, -y, img)");
+%!  ylabel ("limits = [-5.5, 5.5]");
+%! subplot (2,2,4);
+%!  h = image (-x, -y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (-x, -y, img)");
 
 %!demo
-%! clf
+%! clf;
+%! colormap ("default");
 %! g = 0.1:0.1:10;
 %! h = g'*g;
 %! imagesc (g, g, sin (h));
-%! hold on
+%! hold on;
 %! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("two consecutive images")
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("two consecutive images");
 
 %!demo
-%! clf
+%! clf;
+%! colormap ("default");
 %! g = 0.1:0.1:10;
 %! h = g'*g;
 %! imagesc (g, g, sin (h));
-%! hold all
-%! plot (g, 11.0 * ones (size (g)))
+%! hold all;
+%! plot (g, 11.0 * ones (size (g)));
 %! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("image, line, image")
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("image, line, image");
 
 %!demo
-%! clf
+%! clf;
+%! colormap ("default");
 %! g = 0.1:0.1:10;
 %! h = g'*g;
-%! plot (g, 10.5 * ones (size (g)))
-%! hold all
+%! plot (g, 10.5 * ones (size (g)));
+%! hold all;
 %! imagesc (g, g, sin (h));
-%! plot (g, 11.0 * ones (size (g)))
+%! plot (g, 11.0 * ones (size (g)));
 %! imagesc (g, g+12, cos (h/2));
-%! plot (g, 11.5 * ones (size (g)))
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("line, image, line, image, line")
+%! plot (g, 11.5 * ones (size (g)));
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("line, image, line, image, line");
 
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -27,16 +27,17 @@
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
 ## range is set to the 'clim' of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{A}.
 ##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = imagesc (varargin)
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Soren Hauberg <hauberg@gmail.com>
+## Copyright (C) 2008-2012 Soren Hauberg <hauberg@gmail.com>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thomas L. Scofield <scofield@calvin.edu>
+## Copyright (C) 2008-2012 Thomas L. Scofield <scofield@calvin.edu>
 ## Copyright (C) 2008 Kristian Rumberg <kristianrumberg@gmail.com>
 ## Copyright (C) 2006 Thomas Weber <thomas.weber.mail@gmail.com>
 ## Copyright (C) 2005 Stefan van der Walt <stefan@sun.ac.za>
 ## Copyright (C) 2002 Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,16 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} imshow (@var{im})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{limits})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{map})
 ## @deftypefnx {Function File} {} imshow (@var{rgb}, @dots{})
 ## @deftypefnx {Function File} {} imshow (@var{filename})
 ## @deftypefnx {Function File} {} imshow (@dots{}, @var{string_param1}, @var{value1}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} imshow (@dots{})
 ## Display the image @var{im}, where @var{im} can be a 2-dimensional
 ## (gray-scale image) or a 3-dimensional (RGB image) matrix.
 ##
 ## If @var{limits} is a 2-element vector @code{[@var{low}, @var{high}]},
 ## the image is shown using a display range between @var{low} and
 ## @var{high}.  If an empty matrix is passed for @var{limits}, the
 ## display range is computed as the range between the minimal and the
 ## maximal value in the image.
@@ -39,16 +40,18 @@
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
 ## @var{value1}.  @var{string_param1} can be any of the following:
 ## @table @asis
 ## @item "displayrange"
 ## @var{value1} is the display range as described above.
 ## @end table
+##
+## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
 
 ## Author: Stefan van der Walt  <stefan@sun.ac.za>
 ## Author: Soren Hauberg <hauberg at gmail dot com>
 ## Adapted-By: jwe
 
 function h = imshow (im, varargin)
@@ -168,40 +171,51 @@ function h = imshow (im, varargin)
   axis ("image");
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
-%!error imshow ()                           # no arguments
-%!error imshow ({"cell"})                   # No image or filename given
-%!error imshow (ones(4,4,4))                # Too many dimensions in image
+
+%!demo
+%! clf;
+%! imshow ("default.img");
 
 %!demo
-%!  imshow ("default.img");
+%! clf;
+%! imshow ("default.img");
+%! colormap (autumn (64));
 
 %!demo
-%!  imshow ("default.img");
-%!  colormap ("autumn");
+%! clf;
+%! [I, M] = imread ("default.img");
+%! imshow (I, M);
 
 %!demo
-%!  [I, M] = imread ("default.img");
-%!  imshow (I, M);
+%! clf;
+%! [I, M] = imread ("default.img");
+%! [R, G, B] = ind2rgb (I, M);
+%! imshow (cat (3, R, G*0.5, B*0.8));
 
 %!demo
-%!  [I, M] = imread ("default.img");
-%!  [R, G, B] = ind2rgb (I, M);
-%!  imshow (cat(3, R, G*0.5, B*0.8));
+%! clf;
+%! imshow (rand (100, 100));
 
 %!demo
-%!  imshow (rand (100, 100));
+%! clf;
+%! imshow (rand (100, 100, 3));
 
 %!demo
-%!  imshow (rand (100, 100, 3));
+%! clf;
+%! imshow (100*rand (100, 100, 3));
 
 %!demo
-%!  imshow (100*rand (100, 100, 3));
+%! clf;
+%! imshow (rand (100, 100));
+%! colormap (jet (64));
 
-%!demo
-%!  imshow (rand (100, 100));
-%!  colormap (jet);
+%% Test input validation
+%!error imshow ()
+%!error <IM must be an image> imshow ({"cell"})
+%!error <expecting MxN or MxNx3 matrix> imshow (ones (4,4,4))
+
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -52,14 +52,15 @@ function map = jet (n)
       + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'jet' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (jet (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (jet (64));
 
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -52,14 +52,15 @@ function map = ocean (n)
   g = prepad([0:dg:(n-1)], n)';
 
   b = [0:(n-1)]';
 
   map = [ r, g, b ] / (n - 1);
 
 endfunction
 
+
 %!demo
 %! ## Show the 'ocean' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (ocean (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (ocean (64));
 
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -52,14 +52,15 @@ function map = pink (n)
 
     map = sqrt ([r, g, b]);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'pink' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (pink (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (pink (64));
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -45,14 +45,15 @@ function map = prism (n)
   if (rem (n, 6) == 0)
     map = kron(ones (fix (n / 6), 1), p);
   else
     map = [kron(ones (fix (n / 6), 1), p); p(1:rem (n, 6), :)];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'prism' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (prism (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (prism (64));
 
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -54,14 +54,15 @@ function map = rainbow (n)
     b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'rainbow' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (rainbow (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (rainbow (64));
 
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -47,14 +47,15 @@ function map = spring (n)
     b = 1 - g;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'spring' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (spring (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (spring (64));
 
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -48,14 +48,15 @@ function map = summer (n)
 
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'summer' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (summer (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (summer (64));
 
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -42,14 +42,15 @@ function map = white (n)
   if (n > 0)
     map = ones (n, 3);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'white' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (white (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (white (64));
 
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Kai Habel
+## Copyright (C) 1999-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -48,14 +48,15 @@ function map = winter (n)
 
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'winter' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (winter (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (winter (64));
 
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/csvread.m b/scripts/io/csvread.m
--- a/scripts/io/csvread.m
+++ b/scripts/io/csvread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/csvwrite.m b/scripts/io/csvwrite.m
--- a/scripts/io/csvwrite.m
+++ b/scripts/io/csvwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 Paul Kienzle
+## Copyright (C) 2002-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague
+## Copyright (C) 2010-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/is_valid_file_id.m b/scripts/io/is_valid_file_id.m
--- a/scripts/io/is_valid_file_id.m
+++ b/scripts/io/is_valid_file_id.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -1,9 +1,10 @@
-## Copyright (C) 2009-2011 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2009-2012 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2012 Philip Nienhuis
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -118,18 +119,20 @@
 ## (2) 2x1 cell string array: Everything between the left and right strings
 ## is skipped.
 ## @end itemize
 ##
 ## @item "delimiter"
 ## Any character in @var{value} will be used to split @var{str} into words
 ## (default value = any whitespace).
 ##
-## @item "emptyvalue"
-## Parts of the output where no word is available is filled with @var{value}.
+## @item "emptyvalue":
+## Value to return for empty numeric values in non-whitespace delimited data.
+## The default is NaN@.  When the data type does not support NaN
+## (int32 for example), then default is zero.
 ##
 ## @item "multipledelimsasone"
 ## Treat a series of consecutive delimiters, without whitespace in between,
 ## as a single delimiter.  Consecutive delimiter series need not be vertically
 ## "aligned".
 ##
 ## @item "treatasempty"
 ## Treat single occurrences (surrounded by delimiters or whitespace) of the
@@ -139,16 +142,18 @@
 ## If @var{value} true (1, default), ignore read errors and return normally.
 ## If false (0), return an error.
 ##
 ## @item "whitespace"
 ## Any character in @var{value} will be interpreted as whitespace and
 ## trimmed; the string defining whitespace must be enclosed in double
 ## quotes for proper processing of special characters like \t.
 ## The default value for whitespace = " \b\r\n\t" (note the space).
+## Unless whitespace is set to '' (empty) AND at least one "%s" format
+## conversion specifier is supplied, a space is always part of whitespace.
 ##
 ## @end table
 ##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
@@ -221,32 +226,32 @@ function varargout = strread (str, forma
               ## FIXME - a user may have numeric values specified: {'//', 7}
               ##         this will lead to an error in the warning message
               error ("strread: unknown or unrecognized comment style '%s'",
                       varargin{n+1});
             endif
         endswitch
       case "delimiter"
         delimiter_str = varargin{n+1};
-        if (is_sq_string (delimiter_str))
+        if (strcmp (typeinfo (delimiter_str), "sq_string"))
           delimiter_str = do_string_escapes (delimiter_str);
         endif
       case "emptyvalue"
         numeric_fill_value = varargin{n+1};
       case "expchars"
         warning ('strread: property "expchars" is not implemented');
       case "whitespace"
         white_spaces = varargin{n+1};
-        if (is_sq_string (white_spaces))
+        if (strcmp (typeinfo (white_spaces), "sq_string"))
           white_spaces = do_string_escapes (white_spaces);
         endif
       ## The following parameters are specific to textscan and textread
       case "endofline"
         eol_char = varargin{n+1};
-        if (is_sq_string (eol_char))
+        if (strcmp (typeinfo (eol_char), "sq_string"))
           eol_char = do_string_escapes (eol_char);
         endif
       case "returnonerror"
         err_action = varargin{n+1};
       case "multipledelimsasone"
         mult_dlms_s1 = varargin{n+1};
       case "treatasempty"
         if (iscellstr (varargin{n+1}))
@@ -324,52 +329,59 @@ function varargout = strread (str, forma
     endif
     len = length (str);
     c2len = length (comment_end);
     str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
     str = [str{:}];
   endif
 
   if (! isempty (white_spaces))
-    ## Remove any delimiter chars from white_spaces list
-    white_spaces = setdiff (white_spaces, delimiter_str);
+    ## For numeric fields, whitespace is always a delimiter, but not for text fields
+    if (isempty (strfind (format, "%s")))
+      ## Add whitespace to delimiter set
+      delimiter_str = unique ([white_spaces delimiter_str]);
+    else
+      ## Remove any delimiter chars from white_spaces list
+      white_spaces = setdiff (white_spaces, delimiter_str);
+    endif
   endif
   if (isempty (delimiter_str))
     delimiter_str = " ";
   endif
   if (! isempty (eol_char))
     ## Add eol_char to delimiter collection
     delimiter_str = unique ([delimiter_str eol_char]);
     ## .. and remove it from whitespace collection
     white_spaces = strrep (white_spaces, eol_char, '');
   endif
 
   pad_out = 0;
   ## Trim whitespace if needed
-  ## FIXME: This is very complicated.  Can this be simplified with regexprep?
   if (! isempty (white_spaces))
     ## Check if trailing "\n" might signal padding output arrays to equal size
     ## before it is trimmed away below
     if ((str(end) == 10) && (nargout > 1))
       pad_out = 1;
     endif
-    ## Remove repeated white_space chars.  First find white_space positions
-    idx = strchr (str, white_spaces);
-    ## Find repeated white_spaces
-    idx2 = ! (idx(2:end) - idx(1:end-1) - 1);
-    ## Set all whitespace chars to spaces
-    ## FIXME: this implies real spaces are always part of white_spaces
-    str(idx) = ' ';
-    ## Set all repeated white_space to \0
-    str(idx(idx2)) = "\0";
-    str = strsplit (str, "\0");
-    ## Reconstruct trimmed str
-    str = cell2mat (str);
-    ## Remove leading & trailing space, but preserve delimiters.
-    str = strtrim (str);
+    ## Condense all repeated whitespace into one single space
+    ## FIXME: this will also fold repeated whitespace in a char field
+    rxp_wsp = sprintf ("[%s]+", white_spaces);
+    str = regexprep (str, rxp_wsp, ' ');
+    ## Remove possible leading space at string
+    if (str(1) == 32)
+       str = str(2:end);
+    endif
+    ## Check for single delimiter followed/preceded by whitespace
+    ## FIXME: Double strrep on str is enormously expensive of CPU time.
+    ## Can this be eliminated
+    if (! isempty (delimiter_str))
+      dlmstr = setdiff (delimiter_str, " ");
+      rxp_dlmwsp = sprintf ("( [%s]|[%s] )", dlmstr, dlmstr);
+      str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
+    endif
     ## FIXME: Double strrep on str is enormously expensive of CPU time.
     ## Can this be eliminated
     ## Wipe leading and trailing whitespace on each line (it may be delimiter too)
     if (! isempty (eol_char))
       str = strrep (str, [eol_char " "], eol_char);
       str = strrep (str, [" " eol_char], eol_char);
     endif
   endif
@@ -384,40 +396,46 @@ function varargout = strread (str, forma
   endif
   num_words = numel (words);
   ## First guess at number of lines in file (ignoring leading/trailing literals)
   num_lines = ceil (num_words / num_words_per_line);
 
   ## Replace TreatAsEmpty char sequences by empty strings
   if (! isempty (empty_str))
     for ii = 1:numel (empty_str)
-      idz = strmatch (empty_str{ii}, words, "exact");
+      idz = strncmp (empty_str{ii}, words, length (empty_str{ii}));
       words(idz) = {""};
     endfor
   endif
 
-  ## We now may have to cope with 3 cases:
+  ## fmt_words has been split properly now, but words{} has only been split on
+  ## delimiter positions. 
+  ## As numeric fields can also be separated by whitespace, more splits may be
+  ## needed.
+  ## We also don't know the number of lines (as EndOfLine may have been set to
+  ## "" (empty) by the caller).
+  ##
+  ## We also may have to cope with 3 cases as far as literals go:
   ## A: Trailing literals (%f<literal>) w/o delimiter in between.
   ## B: Leading literals (<literal>%f) w/o delimiter in between.
   ## C. Skipping leftover parts of specified skip fields (%*N )
-  ## fmt_words has been split properly now, but words{} has only been split on
-  ## delimiter positions.  Some words columns may have to be split further.
-  ## We also don't know the number of lines (as EndOfLine may have been set to
-  ## "" (empty) by the caller).
+  ## Some words columns may have to be split further to fix these.
 
   ## Find indices and pointers to possible literals in fmt_words
   idf = cellfun ("isempty", strfind (fmt_words, "%"));
   ## Find indices and pointers to conversion specifiers with fixed width
   idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
   idy = find (idf | idg);
+  ## Find indices to numeric conversion specifiers
+  idn = ! cellfun ("isempty", regexp (fmt_words, "%[dnfu]"));
 
   ## If needed, split up columns in three steps:
   if (! isempty (idy))
     ## Try-catch because complexity of strings to read can be infinite
-    #try
+    try
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and counting words until the fmt_words array is exhausted:
       iwrd = 1; iwrdp = 0; iwrdl = length (words{iwrd});
       for ii = 1:numel (fmt_words)
 
@@ -429,33 +447,43 @@ function varargout = strread (str, forma
             if (ii < numel (fmt_words))
               iwrdl = length (words{iwrd});
             endif
           else
             ## Found it in current word.  Subtract literal length
             iwrdp += length (fmt_words{ii});
             if (iwrdp > iwrdl)
               ## Parse error.  Literal extends beyond delimiter (word boundary)
-              error ("strread: Literal '%s' (fmt spec # %d) does not match data", fmt_words{ii}, ii);
+              warning ("strread: literal '%s' (fmt spec # %d) does not match data", ...
+                fmt_words{ii}, ii);
+              ## Word assumed to be completely "used up". Next word
+              ++iwrd; iwrdp = 0;
+              if (ii < numel (fmt_words))
+                iwrdl = length (words{iwrd});
+              endif
             elseif (iwrdp == iwrdl)
               ## Word completely "used up". Next word
               ++iwrd; iwrdp = 0;
               if (ii < numel (fmt_words))
                 iwrdl = length (words{iwrd});
               endif
             endif
           endif
 
         elseif (idg(ii))
           ## Fixed width specifier (%N or %*N): read just a part of word
             iwrdp += floor ...
              (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
             if (iwrdp > iwrdl)
-              ## Error. Field extends beyond word boundary.
-              error ("strread: Field width '%s' (fmt spec # %d) extends beyond word limit", fmt_words{ii}, ii);
+              ## Match error. Field extends beyond word boundary.
+              warning  ...
+              ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
+                 fmt_words{ii}, ii);
+              ## Assume word to be completely "used up".  Next word
+              ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             elseif (iwrdp == iwrdl)
               ## Word completely "used up".  Next word
               ++iwrd; iwrdp = 0; iwrdl = length (words{iwrd});
             endif
 
         else
           ## A simple format conv. specifier. Either (1) uses rest of word, or
           ## (2) is squeezed between current iwrdp and next literal, or (3) uses
@@ -551,34 +579,36 @@ function varargout = strread (str, forma
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
               endif
             endif
           endif
 
         else
           ## Conv. specifier.  Peek if next fmt_word needs split from current column
-          if (ii < num_words_per_line && idf(ii+1))
-            if (! isempty (strfind (words{icol, 1}, fmt_words{ii+1})))
+          if (ii < num_words_per_line)
+            if (idf(ii+1) && (! isempty (strfind (words{icol, 1}, fmt_words{ii+1}))))
+              --icol;
+            elseif (idg(ii+1))
               --icol;
             endif
           endif
         endif
         ## Next fmt_word, next column
         ++ii; ++icol;
       endwhile
 
       ## Done.  Reshape words back into 1 long vector and strip padded empty words
       words = reshape (words, 1, numel (words))(1 : end-num_words_padded);
 
-    #catch
-    #  warning ("strread: unable to parse text or file with given format string");
-    #  return;
+    catch
+      warning ("strread: unable to parse text or file with given format string");
+      return;
 
-    #end_try_catch
+    end_try_catch
   endif
 
   ## For each specifier, process corresponding column
   k = 1;
   for m = 1:num_words_per_line
     try
       if (format_repeat_count < 0)
         data = words(m:num_words_per_line:end);
@@ -673,25 +703,29 @@ endfunction
 
 function out = split_by (text, sep, mult_dlms_s1, eol_char)
 
   ## Check & if needed, process MultipleDelimsAsOne parameter
   if (mult_dlms_s1)
     mult_dlms_s1 = true;
     ## FIXME: Should re-implement strsplit() function here in order
     ## to avoid strrep on megabytes of data.
-    ## If \n is in sep collection we need to enclose it in spaces in text
+    ## If \n is in sep collection we need to enclose it in text
     ## to avoid it being included in consecutive delim series
-    text = strrep (text, eol_char, [" " eol_char " "]);
+    enchr = ' ';
+    ## However watch out if eol_char is also in delimiters
+    if (index (sep, eol_char)); enchr = char(255); endif
+    text = strrep (text, eol_char, [enchr eol_char enchr]);
   else
     mult_dlms_s1 = false;
   endif
 
   ## Split text string along delimiters
   out = strsplit (text, sep, mult_dlms_s1);
+  if (index (sep, eol_char)); out = strrep (out, char(255), ''); endif
   ## In case of trailing delimiter, strip stray last empty word
   if (!isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
 
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
 
@@ -790,29 +824,67 @@ endfunction
 %! # TreatAsEmpty
 %! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", 'delimiter', ',', 'TreatAsEmpty', 'NN');
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
 %! # No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
-%! c = textscan (str, "Text%dText%1sText");
-%! assert (c{1}, int32 ([1; 398; 57]));
-%! assert (c{2}(1:2), {'2'; '4'});
-%! assert (isempty (c{2}{3}), true);
+%! [a, b] = strread (str, "Text%dText%1sText");
+%! assert (a, int32 ([1; 398; 57]));
+%! assert (b(1:2), {'2'; '4'});
+%! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", 'delimiter', ',', 'multipledelimsasone', 1, 'endofline', "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
 %% delimiter as sq_string and dq_string
+%!test
 %! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
 %!         strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
 %% whitespace as sq_string and dq_string
+%!test
 %! assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
 %!         strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
+
+%!test
+%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", " ", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31,0.86,0.94\n0.60,0.72,0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
+
+%!test
+%! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
+%! fmt = "%f %f %f";
+%! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
+%! [a, b, c] = strread (str, fmt, args {:});
+%! assert (a, [0.31; 0.60], 0.01)
+%! assert (b, [0.86; 0.72], 0.01)
+%! assert (c, [0.94; 0.87], 0.01)
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Eric Chassande-Mottin, CNRS (France)
+## Copyright (C) 2009-2012 Eric Chassande-Mottin, CNRS (France)
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -101,20 +101,20 @@ function varargout = textread (filename,
     ## 'endofline' option set by user.
     if (! ischar (varargin{endofline + 1}));
       error ("textread: character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.  Search for EOL candidates in first 3000 chars
     eol_srch_len = min (length (str), 3000);
     ## First try DOS (CRLF)
-    if (! isempty (findstr ("\r\n", str(1 : eol_srch_len))))
+    if (! isempty (strfind ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
-    elseif (! isempty (findstr ("\r", str(1 : eol_srch_len))))
+    elseif (! isempty (strfind ("\r", str(1 : eol_srch_len))))
       eol_char = "\r";
     ## Otherwise, use plain UNIX (LF)
     else
       eol_char = "\n";
     endif
     ## Set up default endofline param value
     varargin(end+1:end+2) = {'endofline', eol_char};
   endif
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott <bpabbott@mac.com>
+## Copyright (C) 2010-2012 Ben Abbott <bpabbott@mac.com>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -99,24 +99,21 @@ function [C, position] = textscan (fid, 
 
   ipos = find (strcmpi (args, "whitespace"));
   if (isempty (ipos))
     ## Matlab default whitespace = " \b\t"
     args(end+1:end+2) = {'whitespace', " \b\t"};
     whitespace = " \b\t";
   else
     ## Check if there's at least one string format specifier
-    fmt = strrep (format, "%", " %");
-    fmt = regexp (fmt, '[^ ]+', 'match');
-    fmt = strtrim (fmt(strmatch ("%", fmt)))
-    has_str_fmt = all (cellfun ("isempty", strfind (strtrim (fmt(strmatch ("%", fmt))), 's')));
-    ## If there is a format, AND whitespace value = empty,
+    has_str_fmt = regexp (format, '%[*]?\d*s', "once");
+    ## If there is a string format AND whitespace value = empty,
     ## don't add a space (char(32)) to whitespace
-    if (! (isempty (args{ipos+1}) &&  has_str_fmt))
-      args{ipos+1} = unique ([" ", whitespace]);
+    if (! (isempty (args{ipos+1}) && has_str_fmt))
+      args{ipos+1} = unique ([" ", args{ipos+1}]);
     endif
   endif
 
   if (! any (strcmpi (args, "delimiter")))
     ## Matlab says default delimiter = whitespace.
     ## strread() will pick this up further
     args(end+1:end+2) = {'delimiter', ""};
   endif
@@ -180,30 +177,30 @@ function [C, position] = textscan (fid, 
     return;
   endif
 
   ## Check value of 'endofline'.  String or file doesn't seem to matter
   endofline = find (strcmpi (args, "endofline"), 1);
   if (! isempty (endofline))
     if (ischar (args{endofline + 1}))
       eol_char = args{endofline + 1};
-      if (isempty (strmatch (eol_char, {"", "\n", "\r", "\r\n"}, 'exact')))
+      if (! any (strcmp (eol_char, {"", "\n", "\r", "\r\n"})))
         error ("textscan: illegal EndOfLine character value specified");
       endif
     else
       error ("textscan: character value required for EndOfLine");
     endif
   else
     ## Determine EOL from file.  Search for EOL candidates in first 3000 chars
     eol_srch_len = min (length (str), 3000);
     ## First try DOS (CRLF)
-    if (! isempty (findstr ("\r\n", str(1 : eol_srch_len))))
+    if (! isempty (strfind ("\r\n", str(1 : eol_srch_len))))
       eol_char = "\r\n";
     ## Perhaps old Macintosh? (CR)
-    elseif (! isempty (findstr ("\r", str(1 : eol_srch_len))))
+    elseif (! isempty (strfind ("\r", str(1 : eol_srch_len))))
       eol_char = "\r";
     ## Otherwise, use plain UNIX (LF)
     else
       eol_char = "\n";
     endif
     ## Set up the default endofline param value
     args(end+1:end+2) = {'endofline', eol_char};
   endif
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Regents of the University of California
+## Copyright (C) 2007-2012 Regents of the University of California
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -189,50 +189,51 @@ function [est, v] = condest (varargin)
 
   [Ainv_norm, v, w] = onenormest (solve, solve_t, n, t);
 
   est = Anorm * Ainv_norm;
   v = w / norm (w, 1);
 
 endfunction
 
+
 %!demo
-%!  N = 100;
-%!  A = randn (N) + eye (N);
-%!  condest (A)
-%!  [L,U,P] = lu (A);
-%!  condest (A, @(x) U\ (L\ (P*x)), @(x) P'*(L'\ (U'\x)))
-%!  condest (@(x) A*x, @(x) A'*x, @(x) U\ (L\ (P*x)), @(x) P'*(L'\ (U'\x)), N)
-%!  norm (inv (A), 1) * norm (A, 1)
+%! N = 100;
+%! A = randn (N) + eye (N);
+%! condest (A)
+%! [L,U,P] = lu (A);
+%! condest (A, @(x) U \ (L \ (P*x)), @(x) P'*(L' \ (U'\x)))
+%! condest (@(x) A*x, @(x) A'*x, @(x) U \ (L \ (P*x)), @(x) P'*(L' \ (U'\x)), N)
+%! norm (inv (A), 1) * norm (A, 1)
 
 ## Yes, these test bounds are really loose.  There's
 ## enough randomization to trigger odd cases with hilb().
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  cA = condest (A);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-8);
+%! N = 6;
+%! A = hilb (N);
+%! cA = condest (A);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-8);
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  solve = @(x) A\x; solve_t = @(x) A'\x;
-%!  cA = condest (A, solve, solve_t);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-8);
+%! N = 6;
+%! A = hilb (N);
+%! solve = @(x) A\x; solve_t = @(x) A'\x;
+%! cA = condest (A, solve, solve_t);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-8);
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  apply = @(x) A*x; apply_t = @(x) A'*x;
-%!  solve = @(x) A\x; solve_t = @(x) A'\x;
-%!  cA = condest (apply, apply_t, solve, solve_t, N);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-6);
+%! N = 6;
+%! A = hilb (N);
+%! apply = @(x) A*x; apply_t = @(x) A'*x;
+%! solve = @(x) A\x; solve_t = @(x) A'\x;
+%! cA = condest (apply, apply_t, solve, solve_t, N);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-6);
 
 %!test
-%!  N = 12;
-%!  A = hilb (N);
-%!  [rcondA, v] = condest (A);
-%!  x = A*v;
-%!  assert (norm(x, inf), 0, eps);
+%! N = 12;
+%! A = hilb (N);
+%! [rcondA, v] = condest (A);
+%! x = A*v;
+%! assert (norm(x, inf), 0, eps);
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek, Marco Caliari
+## Copyright (C) 2008-2012 Jaroslav Hajek, Marco Caliari
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 A. Scottedward Hodel
+## Copyright (C) 1995-2012 A. Scottedward Hodel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 Gabriele Pannocchia
+## Copyright (C) 2003-2012 Gabriele Pannocchia
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -32,26 +32,26 @@
 ## Adapted-By: jwe
 
 function retval = isdefinite (x, tol)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (! ishermitian (x))
-    error ("isdefinite: X must be a hermitian matrix");
-  endif
-
   if (! isfloat (x))
     x = double (x);
   endif
 
   if (nargin == 1)
-    tol = 100 * eps(class (x)) * norm (x, "fro");
+    tol = 100 * eps (class (x)) * norm (x, "fro");
+  endif
+
+  if (! ishermitian (x, tol))
+    error ("isdefinite: X must be a Hermitian matrix");
   endif
 
   e = tol * eye (rows (x));
   [r, p] = chol (x - e);
   if (p == 0)
     retval = 1;
   else
     [r, p] = chol (x + e);
@@ -59,16 +59,17 @@ function retval = isdefinite (x, tol)
       retval = 0;
     else
       retval = -1;
     endif
   endif
 
 endfunction
 
+
 %!test
 %! A = [-1 0; 0 -1];
 %! assert (isdefinite (A), -1)
 
 %!test
 %! A = [1 0; 0 1];
 %! assert (isdefinite (A), 1)
 
@@ -76,9 +77,11 @@ endfunction
 %! A = [2 -1 0; -1 2 -1; 0 -1 2];
 %! assert (isdefinite (A), 1)
 
 %!test
 %! A = [1 0; 0 0];
 %! assert (isdefinite (A), 0)
 
 %!error isdefinite ()
-%!error isdefinite ([1 2; 3 4])
\ No newline at end of file
+%!error isdefinite (1,2,3)
+%!error <X must be a Hermitian matrix> isdefinite ([1 2; 3 4])
+
diff --git a/scripts/linear-algebra/ishermitian.m b/scripts/linear-algebra/ishermitian.m
--- a/scripts/linear-algebra/ishermitian.m
+++ b/scripts/linear-algebra/ishermitian.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/issymmetric.m b/scripts/linear-algebra/issymmetric.m
--- a/scripts/linear-algebra/issymmetric.m
+++ b/scripts/linear-algebra/issymmetric.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Auburn University.  All rights reserved.
+## Copyright (C) 1993-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 N.J. Higham
+## Copyright (C) 2008-2012 N.J. Higham
 ## Copyright (C) 2010 Richard T. Guy <guyrt7@wfu.edu>
 ## Copyright (C) 2010 Marco Caliari <marco.caliari@univr.it>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman and Marco Caliari
+## Copyright (C) 2006-2012 David Bateman and Marco Caliari
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Regents of the University of California
+## Copyright (C) 2007-2012 Regents of the University of California
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -233,58 +233,59 @@ function [est, v, w, iter] = onenormest 
   endfor
 
   ## The estimate est and vector w are set in the loop above. The
   ## vector v selects the ind_best column of A.
   v = zeros (n, 1);
   v(ind_best) = 1;
 endfunction
 
+
 %!demo
-%!  N = 100;
-%!  A = randn(N) + eye(N);
-%!  [L,U,P] = lu(A);
-%!  nm1inv = onenormest(@(x) U\(L\(P*x)), @(x) P'*(L'\(U'\x)), N, 30)
-%!  norm(inv(A), 1)
+%! N = 100;
+%! A = randn (N) + eye (N);
+%! [L,U,P] = lu (A);
+%! nm1inv = onenormest (@(x) U\(L\(P*x)), @(x) P'*(L'\(U'\x)), N, 30)
+%! norm (inv (A), 1)
 
 %!test
-%!  N = 10;
-%!  A = ones (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, N, -2*eps);
-%!  assert (nminf, N, -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 10;
+%! A = ones (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, N, -2*eps);
+%! assert (nminf, N, -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 %!test
-%!  N = 10;
-%!  A = ones (N);
-%!  [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
-%!  [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
-%!  assert (nm1, N, -2*eps);
-%!  assert (nminf, N, -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 10;
+%! A = ones (N);
+%! [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
+%! [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
+%! assert (nm1, N, -2*eps);
+%! assert (nminf, N, -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 %!test
-%!  N = 5;
-%!  A = hilb (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, norm (A, 1), -2*eps);
-%!  assert (nminf, norm (A, inf), -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 5;
+%! A = hilb (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, norm (A, 1), -2*eps);
+%! assert (nminf, norm (A, inf), -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 ## Only likely to be within a factor of 10.
 %!test
-%!  old_state = rand ("state");
-%!  restore_state = onCleanup (@() rand ("state", old_state));
-%!  rand ('state', 42);  % Initialize to guarantee reproducible results
-%!  N = 100;
-%!  A = rand (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, norm (A, 1), -.1);
-%!  assert (nminf, norm (A, inf), -.1);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! old_state = rand ("state");
+%! restore_state = onCleanup (@() rand ("state", old_state));
+%! rand ('state', 42);  % Initialize to guarantee reproducible results
+%! N = 100;
+%! A = rand (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, norm (A, 1), -.1);
+%! assert (nminf, norm (A, inf), -.1);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thorsten Meyer
+## Copyright (C) 2008-2012 Thorsten Meyer
 ## (based on gzip.m by David Bateman)
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,74 +13,81 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} debug ()
-## Summary of the debugging commands.  The debugging commands that are
-## available in Octave are
+## Summary of debugging commands.  For more information on each command
+## and available options use @code{help CMD}.
+## 
+## The debugging commands available in Octave are
 ##
 ## @table @code
-## @item keyboard
-## Force entry into debug mode.
-##
 ## @item dbstop
 ## Add a breakpoint.
 ##
 ## @item dbclear
 ## Remove a breakpoint.
 ##
 ## @item dbstatus
 ## List all breakpoints.
 ##
+## @item dbwhere
+## Report the current file and line number where execution is stopped.
+##
+## @item dbtype
+## List the function where execution is currently stopped, enumerating
+## the line numbers.
+##
+## @item  dbstep
+## @itemx dbnext
+## Execute (step) one or more lines, follow execution into (step into) a
+## function call, or execute until the end of a function (step out), and
+## re-enter debug mode.
+##
 ## @item dbcont
-## Continue execution from the debug prompt.
+## Continue normal code execution from the debug prompt.
+##
+## @item dbquit
+## Quit debugging mode immediately and return to the main prompt.
 ##
 ## @item dbstack
 ## Print a backtrace of the execution stack.
 ##
-## @item dbstep
-## Execute one or more lines and re-enter debug mode
-##
-## @item dbtype
-## List the function where execution is currently stopped, enumerating
-## the lines.
-##
 ## @item dbup
-## The workspace up the execution stack.
+## Move up the execution stack.
 ##
 ## @item dbdown
-## The workspace down the execution stack.
+## Move down the execution stack.
 ##
-## @item dbquit
-## Quit debugging mode and return to the main prompt.
+## @item keyboard
+## Force entry into debug mode from an m-file.
 ##
 ## @item debug_on_error
-## Function to query or set whether to enter debug mode in case Octave
-## encounters an error.
+## Configure whether Octave enters debug mode when it encounters an error.
 ##
 ## @item debug_on_warning
-## Function to query or set whether to enter debug mode in case Octave
-## encounters a warning.
+## Configure whether Octave enters debug mode when it encounters a warning.
 ##
 ## @item debug_on_interrupt
-## Function to query or set whether to enter debug mode in case Octave
-## encounters an interupt.
+## Configure whether Octave enters debug mode when it encounters an interrupt.
 ##
+## @item isdebugmode
+## Return true if in debug mode.
 ## @end table
 ##
 ## @noindent
-## when Octave encounters a breakpoint or other reason to enter debug
+## When Octave encounters a breakpoint, or other reason to enter debug
 ## mode, the prompt changes to @code{"debug>"}.  The workspace of the function
 ## where the breakpoint was encountered becomes available and any Octave
-## command that works within that workspace may be executed.
+## command that is valid in that workspace context may be executed.
 ##
-## @seealso{dbstop, dbclear, dbstatus, dbcont, dbstack, dbstep, dbtype,
-## dbup, dbdown, dbquit, debug_on_error, debug_on_warning,
-## debug_on_interrupt}
+## @seealso{dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont, dbquit,
+##          dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning,
+##          debug_on_interrupt, isdebugmode}
 ## @end deftypefn
 
 function debug ()
   help ("debug");
 endfunction
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,24 +12,26 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{status}, @var{text}] =} dos (@var{command})
-## @deftypefnx {Function File} {[@var{status}, @var{text}] =} dos (@var{command}, "-echo")
+## @deftypefn  {Function File} {} dos ("@var{command}")
+## @deftypefnx {Function File} {@var{status} =} dos ("@var{command}")
+## @deftypefnx {Function File} {[@var{status}, @var{text}] =} dos ("@var{command"})
+## @deftypefnx {Function File} {[@dots{}] =} dos ("@var{command}", "-echo")
 ## Execute a system command if running under a Windows-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
-## in @var{status} and any output sent to the standard output in
-## @var{text}.  If the optional second argument @code{"-echo"} is given,
-## then also send the output from the command to the standard output.
-## @seealso{unix, isunix, ispc, system}
+## in @var{status} and any output from the command in @var{text}.
+## When called with no output argument, or the "-echo" argument is
+## given, then @var{text} is also sent to standard output.
+## @seealso{unix, system, isunix, ispc}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = dos (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
@@ -37,8 +39,33 @@ function [status, text] = dos (command, 
   elseif (! isunix ())
     [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
+
+
+%!test
+%! cmd = ls_command ();
+%! old_wstate = warning ("query");
+%! warning ("off", "Octave:undefined-return-values");
+%! unwind_protect
+%!   [status, output] = dos (cmd);
+%! unwind_protect_cleanup
+%!   warning (old_wstate); 
+%! end_unwind_protect
+%!
+%! if (ispc () && ! isunix ())
+%!   [status, output] = dos (cmd);
+%!   assert (status, 0);
+%!   assert (ischar (output));
+%!   assert (! isempty (output));
+%! else
+%!   assert (status, []);
+%!   assert (output, []);
+%! endif
+
+%!error dos ()
+%!error dos (1, 2, 3)
+
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/fact.m
@@ -0,0 +1,269 @@
+## Copyright (C) 2007-2012 Jordi Guti√©rrez Hermoso 
+## Copyright (C) 2007 Stallmanfacts.com
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Command} {} fact
+## @deftypefnx {Function File} {T =} fact()
+## Display an amazing and random fact about the world's greatest hacker.
+## @end deftypefn
+
+
+function f = fact()
+  persistent wisdom = \
+      {
+       "Richard Stallman takes notes in binary.";
+       "Richard Stallman doesn't need sudo. I will make him a sandwich anyway.";
+       "Richard Stallman is my shephurd, and I am his GNU.";
+       "Richard Stallman doesn't wget, Richard Stallman wdemands!";
+       "Richard Stallman can touch MC Hammer";
+       "Richard Stallman doesn't read web pages. They write to him.";
+       "Richard Stallman gets 9 bits to the byte.";
+       "Richard Stallman doesn't really believe in open software, because it's not free enough.";
+       "Richard Stallman can leave neutral or negative feedback on eBay.";
+       "Richard Stallman is the only man alive who can pronounce GNU the way it is meant to be pronounced.";
+       "Richard Stallman does not own a mobile phone because he can fashion a crude convex dish and shout into it at the exact resonant frequency of the ozone, causing a voice to seemingly come from the sky above his intended recipient.";
+       "Richard Stallman is so handsome that when he was young he was responsible for all other geeks not being able to get girls. This is why he has to cover his face with a thick layer of hair.";
+       "Some people check their computers for viruses. Viruses check their computers for Richard Stallman.";
+       "Richard Stallman memorises all his documents. In binary. He just types everything in whenever he needs a document.";
+       "When Richard Stallman makes a sudo command, he loses permissions.";
+       "Richard Stallman's beard is made of parentheses.";
+       "Richard Stallman's DNA is in binary.";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman's brain accepts UNIX commands.";
+       "If Richard Stallman has 1GB of RAM, and if you have 1GB of RAM, Richard Stallman has more RAM than you.";
+       "Richard Stallman eats ethernet cables. That's why they invented wireless.";
+       "Richard Stallman has a katana. 'Nuff said.";
+       "Richard Stallman wrote a program that divides by zero.";
+       "Ricahrd Stallman doesn't use zip drives, he just squeezes the hard drive.";
+       "Richard Stallman's compiler is afraid to report errors.";
+       "Richard Stallman wrote the compiler God used. The Big Bang was the Universe's first segfault.";
+       "Richard Stallman successfully compiled a kernel of popcorn.";
+       "Richard Stallman doesn't write programs, they write themselves out of reverence.";
+       "Richard Stallman can make infinite loops end.";
+       "Richard Stallman's anti-virus programs cures HIV.";
+       "Richard Stallman's computer doesn't have a clock; it defines what time it is.";
+       "Richard Stallman wrote a program to compute the last digit of pi.";
+       "Richard Stallman doesn't use web browsers. He sends a link to a demon that uses wget to fetch the page and sends it back to him.";
+       "Richard Stallman can solve the halting problem... in polynomial time.";
+       "For Richard Stallman, polynomial time is O(1).";
+       "Richard Stallman didn't \"write\" Emacs or created it in his own image. Richard Stallman made Emacs an instance of himself.";
+       "Richard Stallman can coerce meaningful data from /dev/null.";
+       "Some people wear Linus Torvalds pyjamas to bed, Linus Torvalds wears Richard Stallman pyjamas.";
+       "There is no software development process, only a bunch of programs Richard Stallman allows to exist. ";
+       "Richard Stallman spends his leisure time programming with Guile on GNU Hurd. ";
+       "Richard Stallman's left and right hands are named \"(\" and \")\" ";
+       "Richard Stallman first words were actually syscalls. ";
+       "Richard Stallman didn't create the singularity. He is the singularity. GNU/Linux is only the event horizon. ";
+       "When Richard Stallman pipes to more, he gets less ";
+       "Richard Stallman never showers: he runs 'make clean'. ";
+       "Richard Stallman needs neither mouse nor keyboard to operate his computer. He just stares it down until it does what he wants. ";
+       "Richard Stallman didn't write the GPL. He is the GPL. ";
+       "Richad Stallman's pinky finger is really a USB memory stick. ";
+       "Richard Stallman called his operating system GNU because he created it before computers existed, when actual gnus were used for calcuations. ";
+       "In Soviet Russia, Richard Stallman is still Richard Stallman! ";
+       "Richard Stallman's flute only plays free music. ";
+       "When Richard Stallman uses floats, there are no rounding errors.";
+       "Richard Stallman wrote a program so powerful, it knows the question to 42.";
+       "Richard Stallman released his own DNA under GNU FDL.";
+       "Richard Stallman knows the entire wikipedia by heart, markup included.";
+       "Richard Stallman wrote the HAL9000 OS.";
+       "Richard Stallman's laser pointer is a lightsaber.";
+       "Richard Stallman never steps down; he shifts the universe up .";
+       "Richard Stallman doesn't maintain code; he stares at it until it fixes itself out of reverence.";
+       "Richard Stallman doesn't use an editor; he sets the fundamental constants of the universe so that a magnetic platter with his code on it evolves itself.";
+       "Richard Stallman doesn‚Äôt code; he dares the computer to not do his bidding.";
+       "Global warming is caused by Richard Stallman‚Äôs rage toward non-free software.";
+       "Rather than being birthed like a normal child, Richard Stallman instead instantiated himself polymorphically. Shortly thereafter he grew a beard.";
+       "Richard Stallman discovered extra-terrestrial life but killed them because they used non-free software.";
+       "Richard Stallman doesn't evaluate expressions, expressions evaluate to Richard Stallman.";
+       "Richard Stallman can see Russia from his house.";
+       "Richard Stallman proved P=NP, twice!";
+       "Richard Stallman knows of an unfixed bug in TeX.";
+       "Richard Stallman can write a context-free grammar for C.";
+       "Richard Stallman can determine whether an arbitrary program will terminate.";
+       "Richard Stallman's computer has only two buttons. One is for guests.";
+       "Richard Stallman does not actually write programs. He comes up with a length and digit index in pi.";
+       "Richard Stallman's distributed version control system is a flamewar on Usenet.";
+       "Richard Stallman wrote the first version of Emacs on a typewriter.";
+       "Richard Stallman has no known weaknesses, except for a phobia against soap.";
+       "Richard Stallman is not affected by Godwin's Law.";
+       "Richard Stallman can write an anti-virus program that cures HIV. Too bad he never writes anti-virus programs.";
+       "Richard Stallman' facial hair is \"free as in beard\"";
+       "Richard Stallman is licensed under GPL, so you can clone him and redistribute copies so you can help your neighbor. For example a version that take a bath more often.";
+       "Richard Stallman doesn't code; he just travels around the world.";
+       "Richard Stallman was coded by himself in lisp with Emacs.";
+       "Richard Stallman doesn't eat McDonald's because the machine that kills the cows uses proprietary software.";
+       "There is no chin behind Richard Stallman's legendary beard, there is only another Emacs.";
+       "In an average living room there are 1,242 objects Richard Stallman could use to write an OS, including the room itself.";
+       "Vendor lock-in is when vendors lock themselves inside of a building out of fear of Richard Stallman's wrath.";
+       "When Richard Stallman executes ps -e, you show up.";
+       "When Richard Stallman gets angry he doesn't swear; he recurses.";
+       "On Richard Stallman's computer the bootloader is contained in his .emacs.";
+       "Richard Satallman can make any operating system free, free from drivers.";
+       "Richard Stallman programmed Chuck Norris.";
+       "Behind Richard Stallman's beard there is another fist, to code faster.";
+       "Richard Stallman won a Suduku that started with only one number in each line";
+       "Richard Stallman's brain compiles and runs C code.";
+       "Richard Stallman wrote the first version of Emacs using Emacs.";
+       "Richard Stallman never gonna give you up, never gonna let you down, never gonna run around and desert you, never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you.";
+       "Richard Stallman, upon reading these facts, didn't laugh at all. Instead, he complained that he is being linked to that dirty \"open source\" software. He also asked it to be changed to \"free software\", in order to raise awareness for software freedom in our society.";
+       "Richard Stallman has no problem using Emacs. He wrote it with his 4 hands.";
+       "Richard Stallman will revert the big rip by adding parenthesis to the dark matter.";
+       "When you make a Google search and it doesn't find the answer, Google gently consults Richard Stallman.";
+       "Richard Stallman's uptime is over 53 years. And counting up.";
+       "Richard Stallman's portable music player plays ogg and WMA.";
+       "Richard Stallman will never die, but may some day go to /dev/null.";
+       "Richard Stallman once got swine flu, but it got cleansed by hereditay GPL and thus got assimilated.";
+       "Richard Stallman don't cut his hair because there are no GNU/Scissors";
+       "Richard Stallman is the one who trims Chuck Norris beard. And he does it freely, of course.";
+       "Richard Stallman does not take bath, for the hydroelectric company uses proprietary software.";
+       "Agent Smith loves Richard Stallman's scent.";
+       "Richard Stallman is the One.";
+       "\"They can take our lives, but they can never take our freedom.\" Willian Wallace after a litle talk with Richard Stallman.";
+       "Richard Stallman can connect to any brain using an Emacs ssh client.";
+       "Richard Stallman ported Emacs to Intel 4004 chip.";
+       "Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.";
+       "Richard Stallman once used GDB to reverse-engineer Windows 7 into a free operating system - able to run on GNU Emacs!";
+       "Richard Stallman does not contribute to open source projects; open source projects contribute to Richard Stallman, and then call themselves free software projects.";
+       "Richard Stallman programmed himself before he could even exist";
+       "Richard Stallman can fill up /dev/null.";
+       "Richard Stallman is so zealous about privacy he has /dev/null as his home.";
+       "When Richard Stallman runs /bin/false, it returns \"true\".";
+       "Richard Stallman doesn't like money, because banks don't run on free software.";
+       "Richard Stallman user GNU tar to compress air.";
+       "Richard Stallman was installed in the world, it runs on a free program ..";
+       "When Richard Stallman reports a bug, the bug prefers to squash itself instead of facing Richard Stallman's wrath.";
+       "There is no Windows in Richard Stallman's house... only Doors...";
+       "Richard Stallman doesn't like neither PCs-Intel nor Burger King... He prefers e-Macs...";
+       "Richard Stallman can use grep to find Jimmy Hoffa.";
+       "Richard Stallman made it possible to not absolutely abhor HPUX.";
+       "When Richard Stallman pours his alphabets cereal into a bowl, only G's, N's, and U's come out.";
+       "Richard Stallman is pronounced \"GNU slash Stallman\"";
+       "Richard Stallman doesn't mind if you read his mail as long as you don't delete it before he reads it.";
+       "Richard Stallman is just a guy who has strong principles and decided to follow them.";
+       "Richard Stallman knows that you don't have class because it is a keyword that he defined.";
+       "Richard Stallman doesn't need a qwerty/dvorak keyboard only two buttons \"1\" and \"0\" and his erect penis.";
+       "On the first day Richard Stallman said M-x create-light.";
+       "Richard Stallman once went out of scope for a while. The garbage collector never dared to touch him.";
+       "Richard Stallman does not compile; he closes his eyes, and see energy lines created between bit blocks by the compiler optimizations...";
+       "intx80 first calls Richard Stallman before calling sys_call";
+       "Tron is actually a biographical story about Richard Stallman. The director decided to tone it down or audiences wouldn't find it believable.";
+       "Richard Stallman always wears a red shirt to make sure that whatever attacks his away-team has to go through him first.";
+       "kill -9 invokes Richard Stallman's rage against a process.";
+       "If Richard were to stumble upon stallmanfacts.com, he would find it a gnuisance.";
+       "Richard Stallman can telnet into Mordor.";
+       "sudo chown Richard:Stallman /all/your/base";
+       "Richard Stallman's nervous system is completely wireless.";
+       "Richard Stallman does not sleep. He yields.";
+       "Some people say M-x psychoanalyse-pinhead is a merely a program. Others say M-x psychoanalyse-pinhead *is* Richard Stallman. All I know is, Richard Stallman is The Stig.";
+       "If you execute Emacs backward it either undoes the industrial revolution or induces the rapture. But only Richard Stallman knows which.";
+       "If Richard Stallman's beard were ever trimmed, the clippings would re-marshal into an exact copy of Richard Stallman.";
+       "Richard Stallman never sleeps because he altered his own source to gain background garbage collection.";
+       "Richard Stallman's doctor can retrieve a blood sample via CVS.";
+       "Richard Stallman can touch this";
+       "Because Richard Stallman's DNA is licensed under the FDL, his doctor can't draw his blood without violating HIPAA.";
+       "Richard Stallman can remove his own appendix, using only gdb.";
+       "Richard Stallman's DNA includes debugging symbols. But he doesn't need them.";
+       "Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him in the skull.";
+       "Richard Stallman doesn't need to buy a bigger hard drive. He can compress data infinitely. ";
+       "When Richard Stallman cannot take your call, his beard answers the phone for you.";
+       "The R in RMS stands for RMS.";
+       "Richard Stallman can parse HTML with regular expressions.";
+       "Richard Stallman's traceroute goes all the way through an infinite number of anonymous proxies back to the traffic's source.";
+       "Richard Stallman's beard is in fact not a just a beard, but a microprinted hard copy of Emacs source code. New patches must be checked against new hair growth before being approved.";
+       "In the beginning-of-buffer there was Richard Stallman.";
+       "The NOOP was created to give Richard Stallman some time to comb his beard.";
+       "Whenever Richard Stallman looks at a Windows computer, it segfaults. Whenever Richard Stallman doesn't look at a Windows computer, it segfaults.";
+       "Richard Stallman can walk on Windows!";
+       "After being unable to satisfy my wife for years, Richard Stallman was able to single-handedly unlock her orgasm within seconds and managed to write a texinfo manual minutes later for other users.";
+       "Richard Stallman's tabbed browser is a set to wget/telnet fg/bg processes.";
+       "There is no chin under Richard Stallman' beard. There's only another beard. Recursively.";
+       "Stallman can chown anything! stallman@stallman~$ chown stallman:stallman Earth (for example)";
+       "Richard Stallman freed his beard so he can always check what's in it.";
+       "In the beginning was the Word, and the Word was with RMS, and the Word was GNU.";
+       "RMS means \"RMS means Stallman\"";
+       "Richard Stallman is the babelfish of his own speeches.";
+       "Richard Stallman wrote his own library and lives in it.";
+       "Richard Stallman found Waldo using grep in /dev/null";
+       "Richard Stallman doesn't sleep; he is compiling";
+       "Richard Stallman will get Coca Cola to release their recipe under the GPL.";
+       "Richard Stallman doesn't change clothes. He makes case mods.";
+       "Richard Stallman compiled the first version of gcc with an hexadecimal editor.";
+       "Richard Stallman will be the last guest on Linux Outlaws";
+       "Richard Stallman calculates the universe's entropy by exploiting forced stack overflows.";
+       "Richard Stallman's consciousness will one day become the singularity, which will create Deep Thought, and answer the meaning of life, the universe and everything.";
+       "C is actually written in RMS.";
+       "Richard Stallman can write software that does not have a buffer overflow when counting money lost by Jerome Kerviel.";
+       "There were no double rainbows before Richard Stallman.";
+       "Chuck Norris had to shorten his beard in the presence of Stallman because two beards that awsome, so close would segfault the universe (again).";
+       "RMS is Titanic.";
+       "Richard Stallman is the answer to the Turing Test.";
+       "Richard Stallman's beard makes ads for Gillette and Braun appear.";
+       "for i = 1 to Stallman will never stop.";
+       "\"RMS\" stands for \"RMS Makes Software\"";
+       "Whenever someone writes a \"Hello, world\" program, Richard Stallman says \"Hello\" back.";
+       "Richard Stallman wasn't born. He was compiled from source.";
+       "Richard Stallman has a URL tatooed on the left side of his chest where you can download his genetic code.";
+       "The GNU command line idiom that Richard Stallman never needs: \"date | more\"";
+       "Richard Stallman's toe cheese is aged to perfection.";
+       "Richard Stallman doesn't always run an OS kernel, but when he does he prefers GNU/Hurd. He is... the most interesting hacker in the world. Stay free, my friends.";
+       "When Richard Stallman gets hungry, he just picks debris from his foot and eats it.";
+       "Richard Stallman can GPL your code just by looking at it funny.";
+       "Richard Mathew Stallman loves birds. Birds make auricular love to Richard Mathew Stallman.";
+       "Richard Stallman is so free that the primitive recursive function for computing his liberty causes a stack overflow.";
+       "GNU Hurd is taking more than twenty years to develop because Richard Stallman is using a programming language comprised entirely of different lengths of time.";
+       "Richard Stallman's beard contains Richard Stallman, whose beard contains Richard Stallman....";
+       "Richard Stallman had a Google Plus account in 2010.";
+       "sudo chown rms:gnu ~/base -R";
+       "Richard Stallman pipes the Emacs binaries to /dev/dsp before he goes to sleep.";
+       "When Richard Stallman counted his fingers as a kid, he always started with 0.";
+       "When Richard Stallman's computer gets a virus, he simply applies a GPL license to it which converts the whole botnet to Linux. I mean, GNU/Linux.";
+       "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
+       "Richard Stallman's doesn't kill a process, he just dares it to stay running.";
+       "Richard Stallman exists because he compiled himself into being. ";
+       "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
+       "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
+       };
+
+  w = wisdom{randi([1, numel(wisdom)])};
+  if nargout > 0
+    f = w;
+  else
+    w = wordwrap (w);
+    printf ("%s", w);
+  endif
+endfunction
+
+function out = wordwrap (w)
+  cols = terminal_size ()(2);
+  wc = strsplit (w, " ");
+  out = "\n";
+  i = 1;
+  numwords = numel (wc);
+  while i <= numwords;
+    line = wc{i};
+    while (i < numwords && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+      line = newline;
+      i++;
+    endwhile
+    out = cstrcat (out, line, "\n");
+    i++;
+  endwhile
+  out = cstrcat(out, "\n");
+endfunction
\ No newline at end of file
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} fileattrib (@var{file})
+## @deftypefn {Function File} {[@var{status}, @var{result}, @var{msgid}] =} fileattrib (@var{file})
 ## Return information about @var{file}.
 ##
 ## If successful, @var{status} is 1, with @var{result} containing a
 ## structure with the following fields:
 ##
 ## @table @code
 ## @item Name
 ## Full name of @var{file}.
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Etienne Grossmann
+## Copyright (C) 2000-2012 Etienne Grossmann
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Julian Schnidder
+## Copyright (C) 2008-2012 Julian Schnidder
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/isdeployed.m b/scripts/miscellaneous/isdeployed.m
--- a/scripts/miscellaneous/isdeployed.m
+++ b/scripts/miscellaneous/isdeployed.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Thomas Treichl
+## Copyright (C) 2007-2012 Thomas Treichl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -41,51 +41,54 @@ function retval = ls (varargin)
 
   global __ls_command__;
 
   if (isempty (__ls_command__) || ! ischar (__ls_command__))
     ## Initialize value for __ls_command__.
     ls_command ();
   endif
 
-  if (iscellstr (varargin))
-
-    args = tilde_expand (varargin);
+  if (! iscellstr (varargin))
+    error ("ls: all arguments must be character strings");
+  endif
 
-    if (nargin > 0)
-      ## FIXME -- this will fail for filenames that contain single quote
-      ## characters...
-      cmd = sprintf (" '%s'", args{:});
+  if (nargin > 0)
+    args = tilde_expand (varargin);
+    if (ispc () && ! isunix ())
+      ## shell (cmd.exe) on MinGW uses '^' as escape character
+      args = regexprep (args, '([^\w.*? -])', '^$1');
     else
-      cmd = "";
+      args = regexprep (args, '([^\w.*? -])', '\$1');
     endif
-
-    cmd = sprintf ("%s%s", __ls_command__, cmd);
-
-    if (page_screen_output () || nargout > 0)
-
-      [status, output] = system (cmd);
+    args = sprintf ("%s ", args{:});
+  else
+    args = "";
+  endif
 
-      if (status == 0)
-        if (nargout == 0)
-          puts (output);
-        else
-          retval = strvcat (regexp (output, '\S+', 'match'){:});
-        endif
-      else
-        error ("ls: command exited abnormally with status %d\n", status);
-      endif
+  cmd = sprintf ("%s %s", __ls_command__, args);
+
+  if (page_screen_output () || nargout > 0)
+    [status, output] = system (cmd);
 
+    if (status != 0)
+      error ("ls: command exited abnormally with status %d\n", status);
+    elseif (nargout == 0)
+      puts (output);
     else
-      ## Just let the output flow if the pager is off.  That way the
-      ## output from things like "ls -R /" will show up immediately and
-      ## we won't have to buffer all the output.
-      system (cmd);
+      retval = strvcat (regexp (output, '\S+', 'match'){:});
     endif
-
   else
-    error ("ls: expecting all arguments to be character strings");
+    ## Just let the output flow if the pager is off.  That way the
+    ## output from things like "ls -R /" will show up immediately and
+    ## we won't have to buffer all the output.
+    system (cmd);
   endif
 
 endfunction
 
+
+%!test
+%! list = ls ();
+%! assert (ischar (list));
+%! assert (! isempty (list));
+
 %!error ls (1);
 
diff --git a/scripts/miscellaneous/ls_command.m b/scripts/miscellaneous/ls_command.m
--- a/scripts/miscellaneous/ls_command.m
+++ b/scripts/miscellaneous/ls_command.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,20 +25,20 @@
 
 ## Author: jwe
 
 function old_cmd = ls_command (cmd)
 
   global __ls_command__;
 
   if (isempty (__ls_command__))
-    ## FIXME -- ispc and isunix both return true for Cygwin.  Should they?
+    ## MinGW uses different ls_command
     if (ispc () && ! isunix ()
         && isempty (file_in_path (getenv ("PATH"), "ls")))
-      __ls_command__ = "cmd /C dir /D";
+      __ls_command__ = "dir /D";
     else
       __ls_command__ = "ls -C";
     endif
   endif
 
   if (nargin == 0 || nargin == 1)
 
     old_cmd = __ls_command__;
@@ -49,8 +49,19 @@ function old_cmd = ls_command (cmd)
       else
         error ("ls_command: expecting argument to be a character string");
       endif
     endif
 
   endif
 
 endfunction
+
+
+%!test
+%! cmd = ls_command ();
+%! assert (ischar (cmd));
+%! if (ispc () && ! isunix ())
+%!   assert (cmd(1:3), "dir"); 
+%! else
+%!   assert (cmd(1:2), "ls"); 
+%! endif
+
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -37,43 +37,34 @@ function num = menu (title, varargin)
 
   ## Force pending output to appear before the menu.
 
   fflush (stdout);
 
   ## Don't send the menu through the pager since doing that can cause
   ## major confusion.
 
-  save_page_screen_output = page_screen_output ();
-
-  unwind_protect
-
-    page_screen_output (0);
+  page_screen_output (0, "local");
 
-    if (! isempty (title))
-      disp (title);
-      printf ("\n");
-    endif
+  if (! isempty (title))
+    disp (title);
+    printf ("\n");
+  endif
 
-    nopt = nargin - 1;
+  nopt = nargin - 1;
 
-    while (1)
-      for i = 1:nopt
-        printf ("  [%2d] ", i);
-        disp (varargin{i});
-      endfor
-      printf ("\n");
-      s = input ("pick a number, any number: ", "s");
-      num = sscanf (s, "%d");
-      if (! isscalar (num) || num < 1 || num > nopt)
-        printf ("\nerror: input invalid or out of range\n\n");
-      else
-        break;
-      endif
-    endwhile
-
-  unwind_protect_cleanup
-
-    page_screen_output (save_page_screen_output);
-
-  end_unwind_protect
+  while (1)
+    for i = 1:nopt
+      printf ("  [%2d] ", i);
+      disp (varargin{i});
+    endfor
+    printf ("\n");
+    s = input ("pick a number, any number: ", "s");
+    num = sscanf (s, "%d");
+    if (! isscalar (num) || num < 1 || num > nopt)
+      printf ("\nerror: input invalid or out of range\n\n");
+    else
+      break;
+    endif
+  endwhile
 
 endfunction
+
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Keith Goodman
+## Copyright (C) 2006-2012 Keith Goodman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,24 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} mkoctfile [-options] file @dots{}
+## @deftypefnx {Function File} {[@var{output}, @var{status} =} mkoctfile (@dots{})
 ##
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
-## prompt.
+## prompt.  Calling it from the Octave prompt simply delegates the
+## call to the shell prompt.  The output is stored in the @var{output}
+## variable and the exit status in the @var{status} variable.
 ##
 ## @code{mkoctfile} accepts the following options, all of which are optional
 ## except for the file name of the code you wish to compile:
 ##
 ## @table @samp
 ## @item -I DIR
 ## Add the include directory DIR to compile commands.
 ##
@@ -132,29 +135,35 @@
 ##                   .o    object file
 ##                   .a    library file
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @end deftypefn
 
-function mkoctfile (varargin)
+function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
   cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
     cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
 
-  status = system (cmd);
+  [sys, out] = system (cmd);
 
-  if (status == 127)
+  if (nargout > 0)
+    [output, status] = deal (out, sys);
+  else
+    printf ("%s", out);
+  endif
+
+  if (sys == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -15,16 +15,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/computer.m \
   miscellaneous/copyfile.m \
   miscellaneous/debug.m \
   miscellaneous/delete.m \
   miscellaneous/dir.m \
   miscellaneous/dos.m \
   miscellaneous/dump_prefs.m \
   miscellaneous/edit.m \
+	miscellaneous/fact.m \
   miscellaneous/fileattrib.m \
   miscellaneous/fileparts.m \
   miscellaneous/fullfile.m \
   miscellaneous/getappdata.m \
   miscellaneous/getfield.m \
   miscellaneous/gunzip.m \
   miscellaneous/gzip.m \
   miscellaneous/info.m \
@@ -62,16 +63,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/symvar.m \
   miscellaneous/tar.m \
   miscellaneous/tempdir.m \
   miscellaneous/tempname.m \
   miscellaneous/unix.m \
   miscellaneous/unpack.m \
   miscellaneous/untar.m \
   miscellaneous/unzip.m \
+  miscellaneous/usejava.m \
   miscellaneous/ver.m \
   miscellaneous/version.m \
   miscellaneous/warning_ids.m \
   miscellaneous/what.m \
   miscellaneous/xor.m \
   miscellaneous/zip.m \
   $(miscellaneous_PRIVATE_FCN_FILES)
 
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,52 +12,59 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} news (@var{package})
-## Display the current NEWS file for Octave or installed package.
+## @deftypefn  {Function File} {} news
+## @deftypefnx {Function File} {} news (@var{package})
+## Display the current NEWS file for Octave or an installed package.
 ##
-## If @var{package} is the name of an installed package, display the current
-## NEWS file for that package.
+## When called without an argument, display the NEWS file for Octave.
+## When given a package name @var{package}, display the current NEWS file for
+## that package.
 ## @end deftypefn
 
 function news (package = "octave")
 
-  if (ischar (package) && strcmpi (package, "octave"))
+  if (nargin > 1)
+    print_usage ();
+  elseif (! ischar (package))
+    error ("news: PACKAGE must be a string");
+  endif
+
+  if (strcmpi (package, "octave"))
     octetcdir = octave_config_info ("octetcdir");
     newsfile  = fullfile (octetcdir, "NEWS");
-
-  elseif (nargin == 1 && ischar (package))
+  else
     installed = pkg ("list");
     names     = cellfun (@(x) x.name, installed, "UniformOutput", false);
     ## we are nice and let the user use any case on the package name
     pos = strcmpi (names, package);
     if (!any (pos))
       error ("Package '%s' is not installed.", package);
     endif
     newsfile = fullfile (installed{pos}.dir, "packinfo", "NEWS");
-
-  else
-    print_usage;
   endif
 
-  if (exist (newsfile, "file"))
-    f = fopen (newsfile, "r");
-    while (ischar (line = fgets (f)))
-      puts (line);
-    endwhile
-  else
+  if (! exist (newsfile, "file"))
     if (strcmpi (package, "octave"))
       error ("news: unable to locate NEWS file");
     else
-      error ("news: unable to locate NEWS file of %s package", package);
+      error ("news: unable to locate NEWS file for package %s", package);
     endif
   endif
 
+  fid = fopen (newsfile, "r");
+  while (ischar (line = fgets (fid)))
+    puts (line);
+  endwhile
+  fclose (fid);
+
 endfunction
 
-## Remove from test statistics.  No real tests possible
-%!assert (1)
+
+%!error news (1, 2)
+%!error <PACKAGE must be a string> news (1)
+%!error <Package .* is not installed> news ("__NOT_A_VALID_PKG_NAME__")
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Paul Kienzle
+## Copyright (C) 2006-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/pack.m b/scripts/miscellaneous/pack.m
--- a/scripts/miscellaneous/pack.m
+++ b/scripts/miscellaneous/pack.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 John W. Eaton
+## Copyright (C) 1999-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Alexander Barth
+## Copyright (C) 2006-2012 Alexander Barth
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -43,17 +43,17 @@
 ## The parseparams function may be used to separate 'regular'
 ## arguments and additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
-## When called from a m-file function, the error is prefixed with the
+## When called from an m-file function, the error is prefixed with the
 ## name of the caller function.
 ## The matching of options is case-insensitive.
 ##
 ## @seealso{varargin}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth93@users.sourceforge.net>
 ## Author: Aida Alvera Azcarate <aida@netecho.info>
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Julian Schnidder
+## Copyright (C) 2008-2012 Julian Schnidder
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Thorsten Meyer
+## Copyright (C) 2008-2012 Thorsten Meyer
 ## based on the original gzip function by David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -94,23 +94,18 @@ function entries = __xzip__ (commandname
         entries  = cellfun(@(x) sprintf ("%s.%s", x, extension),
                            files, "uniformoutput", false);
       endif
     endif
 
   unwind_protect_cleanup
     cd (cwd);
     if (nargin == 4)
-      crr = confirm_recursive_rmdir ();
-      unwind_protect
-        confirm_recursive_rmdir (false);
-        rmdir (outdir, "s");
-      unwind_protect_cleanup
-        confirm_recursive_rmdir (crr);
-      end_unwind_protect
+      confirm_recursive_rmdir (false, "local");
+      rmdir (outdir, "s");
     endif
   end_unwind_protect
 
 endfunction
 
 function [d, f] = myfileparts (files)
   [d, f, ext] = cellfun ("fileparts", files, "uniformoutput", false);
   f = cellfun (@(x, y) sprintf ("%s%s", x, y), f, ext,
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Julian Schnidder
-## Copyright (C) 2011 Carn√´ Draug
+## Copyright (C) 2008-2012 Julian Schnidder
+## Copyright (C) 2012 Carn√´ Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Etienne Grossmann
+## Copyright (C) 2000-2012 Etienne Grossmann
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 S¯ren Hauberg
+## Copyright (C) 2005-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/tempname.m b/scripts/miscellaneous/tempname.m
--- a/scripts/miscellaneous/tempname.m
+++ b/scripts/miscellaneous/tempname.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 John W. Eaton
+## Copyright (C) 2003-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 John W. Eaton
+## Copyright (C) 2004-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,24 +12,26 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{status}, @var{text}] =} unix (@var{command})
-## @deftypefnx {Function File} {[@var{status}, @var{text}] =} unix (@var{command}, "-echo")
+## @deftypefn  {Function File} {} unix ("@var{command}")
+## @deftypefnx {Function File} {@var{status} =} unix ("@var{command}")
+## @deftypefnx {Function File} {[@var{status}, @var{text}] =} unix ("@var{command}")
+## @deftypefnx {Function File} {[@dots{}] =} unix ("@var{command}", "-echo")
 ## Execute a system command if running under a Unix-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
-## in @var{status} and any output sent to the standard output in
-## @var{text}.  If the optional second argument @code{"-echo"} is given,
-## then also send the output from the command to the standard output.
-## @seealso{isunix, ispc, system}
+## in @var{status} and any output from the command in @var{text}.
+## When called with no output argument, or the "-echo" argument is
+## given, then @var{text} is also sent to standard output.
+## @seealso{dos, system, isunix, ispc}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = unix (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
@@ -37,8 +39,32 @@ function [status, text] = unix (command,
   elseif (isunix ())
     [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
+
+
+%!test
+%! cmd = ls_command ();
+%! old_wstate = warning ("query");
+%! warning ("off", "Octave:undefined-return-values");
+%! unwind_protect
+%!   [status, output] = unix (cmd);
+%! unwind_protect_cleanup
+%!   warning (old_wstate); 
+%! end_unwind_protect
+%!
+%! if (isunix ())
+%!   assert (status, 0);
+%!   assert (ischar (output));
+%!   assert (! isempty (output));
+%! else
+%!   assert (status, []);
+%!   assert (output, []);
+%! endif
+
+%!error unix ()
+%!error unix (1, 2, 3)
+
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Bill Denney
+## Copyright (C) 2006-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/untar.m b/scripts/miscellaneous/untar.m
--- a/scripts/miscellaneous/untar.m
+++ b/scripts/miscellaneous/untar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 S¯ren Hauberg
+## Copyright (C) 2005-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/unzip.m b/scripts/miscellaneous/unzip.m
--- a/scripts/miscellaneous/unzip.m
+++ b/scripts/miscellaneous/unzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 S¯ren Hauberg
+## Copyright (C) 2005-2012 S¯ren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/usejava.m b/scripts/miscellaneous/usejava.m
--- a/scripts/miscellaneous/usejava.m
+++ b/scripts/miscellaneous/usejava.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Rik Wehbring
+## Copyright (C) 2012 Rik Wehbring
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -31,17 +31,17 @@
 ##
 ## @item "jvm"
 ## Java Virtual Machine.
 ##
 ## @item "swing"
 ## Swing components for lightweight GUIs.
 ## @end table
 ##
-## This function is provided for compatability with @sc{matlab} scripts which
+## This function is provided for compatibility with @sc{matlab} scripts which
 ## may alter their behavior based on the availability of Java.  Octave does
 ## not implement an interface to Java and this function always returns
 ## @code{false}.
 ## @end deftypefn
 
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,16 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @cindex warning ids
 ## @table @code
 ## @item Octave:abbreviated-property-match
 ## By default, the @code{Octave:abbreviated-property-match} warning is enabled.
 ##
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
 ## attempted.
@@ -115,16 +116,21 @@
 ## @item Octave:autoload-relative-file-name
 ## If the @code{Octave:autoload-relative-file-name} is enabled,
 ## Octave will warn when parsing autoload() function calls with relative
 ## paths to function files.  This usually happens when using autoload()
 ## calls in PKG_ADD files, when the PKG_ADD file is not in the same
 ## directory as the .oct file referred to by the autoload() command.
 ## By default, the @code{Octave:autoload-relative-file-name} warning is enabled.
 ##
+## @item Octave:broadcast
+## Warn when performing broadcasting operations.  By default, this is
+## enabled.  See @ref{Broadcasting} in the chapter Vectorization and Faster
+## Code Execution of the manual.
+##
 ## @item Octave:built-in-variable-assignment
 ## By default, the @code{Octave:built-in-variable-assignment} warning is
 ## enabled.
 ##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.
 ## By default, the @code{Octave:divide-by-zero} warning is enabled.
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Sylvain Pelissier
+## Copyright (C) 2006-2012 Sylvain Pelissier
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/mk-pkg-add b/scripts/mk-pkg-add
--- a/scripts/mk-pkg-add
+++ b/scripts/mk-pkg-add
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2002-2011 John W. Eaton
+# Copyright (C) 2002-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/scripts/mkdoc b/scripts/mkdoc
--- a/scripts/mkdoc
+++ b/scripts/mkdoc
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 VZLU Prague
+## Copyright (C) 2009-2012 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -81,17 +81,16 @@
 ## Iteration limit exceeded.
 ##
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
 ## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fzero} is usually a much better idea.
-## @seealso{fzero, optimset}
 ##
 ## Note about user-supplied Jacobians:
 ## As an inherent property of the algorithm, Jacobian is always requested for a
 ## solution vector whose residual vector is already known, and it is the last
 ## accepted successful step.  Often this will be one of the last two calls, but
 ## not always.  If the savings by reusing intermediate results from residual
 ## calculation in Jacobian calculation are significant, the best strategy is to
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
@@ -116,20 +115,21 @@
 ##   ## outputfcn call.
 ##   if (all (x == sav0.x))
 ##     sav = sav0;
 ##   endif
 ##   ## maybe output iteration status, etc.
 ## endif
 ## endfunction
 ##
-## ## @dots{}.
+## ## @dots{}
 ##
 ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
 ## @end example
+## @seealso{fzero, optimset}
 ## @end deftypefn
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
   ## Get default options if requested.
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s.
+## Copyright (C) 2008-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Nicolo' Giorgetti
+## Copyright (C) 2005-2012 Nicolo' Giorgetti
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ## Copyright (C) 2008 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ## Copyright (C) 2008 Jaroslav Hajek
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
diff --git a/scripts/optimization/private/__fdjac__.m b/scripts/optimization/private/__fdjac__.m
--- a/scripts/optimization/private/__fdjac__.m
+++ b/scripts/optimization/private/__fdjac__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Gabriele Pannocchia.
+## Copyright (C) 2000-2012 Gabriele Pannocchia.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,16 +20,17 @@
 ## @deftypefn {Function File} {} matlabroot ()
 ## Return the name of the top-level Octave installation directory.
 ##
 ## This is an alias for the function @w{@code{OCTAVE_HOME}} provided
 ## for compatibility.
 ## @seealso{OCTAVE_HOME}
 ## @end deftypefn
 
-function val = matlabroot ()
+function retval = matlabroot ()
 
-  val = OCTAVE_HOME;
+  retval = OCTAVE_HOME;
 
 endfunction
 
+
 %!assert (matlabroot(), OCTAVE_HOME())
 
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Bill Denney
+## Copyright (C) 2005-2012 Bill Denney
 ## Copyright (C) 2007-2009 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -16,48 +16,46 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{val} =} pathdef ()
 ## Return the default path for Octave.
 ## The path information is extracted from one of three sources.
-## In order of preference, those are;
+## The possible sources, in order of preference, are:
 ##
 ## @enumerate
 ## @item @file{~/.octaverc}
 ##
 ## @item @file{<octave-home>/@dots{}/<version>/m/startup/octaverc}
 ##
 ## @item Octave's path prior to changes by any octaverc.
 ## @end enumerate
-## @seealso{path, addpath, rmpath, genpath, savepath, pathsep}
+## @seealso{path, addpath, rmpath, genpath, savepath}
 ## @end deftypefn
 
 function val = pathdef ()
 
   ## Locate the site octaverc file.
   pathdir = octave_config_info ("localstartupfiledir");
   site_octaverc = fullfile (pathdir, "octaverc");
 
-  ## Locate the user ~\.octaverc file.
+  ## Locate the user's ~/.octaverc file.
   user_octaverc = fullfile ("~", ".octaverc");
 
-  ## Extract the specified paths from the site and user octaverc"s.
+  ## Extract the specified paths from the site and user octavercs.
   site_path = __extractpath__ (site_octaverc);
   if (exist (user_octaverc, "file"))
     user_path = __extractpath__ (user_octaverc);
   else
     user_path = "";
   endif
 
-  ## A path definition in the user octaverc has precedence over the
-  ## site.
-
+  ## A path definition in the user rcfile has precedence over the site rcfile.
   if (! isempty (user_path))
     val = user_path;
   elseif (! isempty (site_path))
     val = site_path;
   else
     val = __pathorig__ ();
   endif
 
@@ -68,53 +66,45 @@ endfunction
 ## @file{~/.octaverc} is used.  If successful, @code{__extractpath__}
 ## returns the path specified in @var{file}.
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function specifiedpath = __extractpath__ (savefile)
 
   ## The majority of this code was borrowed from savepath.m.
-  ## FIXME -- is there some way to share the common parts instead of
-  ## duplicating?
-
+  ## FIXME: is there some way to share the common parts instead of duplicating?
+  ## ANSWER: Yes.  Create a private directory and extract this section of code
+  ##         and place it there in a new function only visible by pathdef() and
+  ##         savepath().
   beginstring = "## Begin savepath auto-created section, do not edit";
   endstring   = "## End savepath auto-created section";
 
   if (nargin == 0)
     savefile = tilde_expand ("~/.octaverc");
   endif
 
   ## Parse the file if it exists to see if we should replace a section
   ## or create a section.
-  startline = 0;
-  endline = 0;
+  startline = endline = 0;
   filelines = {};
   if (exist (savefile) == 2)
-    ## read in all lines of the file
     [fid, msg] = fopen (savefile, "rt");
     if (fid < 0)
       error ("__extractpath__: could not open savefile, %s: %s", savefile, msg);
     endif
     unwind_protect
       linenum = 0;
-      while (linenum >= 0)
-        result = fgetl (fid);
-        if (isnumeric (result))
-          ## End at the end of file.
-          linenum = -1;
-        else
-          linenum++;
-          filelines{linenum} = result;
-          ## Find the first and last lines if they exist in the file.
-          if (strcmp (result, beginstring))
-            startline = linenum + 1;
-          elseif (strcmp (result, endstring))
-            endline = linenum - 1;
-          endif
+      while (ischar (line = fgetl (fid)))
+        filelines{++linenum} = line;
+        ## find the first and last lines if they exist in the file
+        if (strcmp (line, beginstring))
+          startline = linenum;
+        elseif (strcmp (line, endstring))
+          endline = linenum;
         endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
         error ("__extractpath__: could not close savefile after reading, %s",
                savefile);
       endif
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Bill Denney
+## Copyright (C) 2005-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,71 +12,63 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} savepath (@var{file})
-## Save the portion of the current function search path, that is
-## not set during Octave's initialization process, to @var{file}.
+## @deftypefn  {Function File} {} savepath ()
+## @deftypefnx {Function File} {} savepath (@var{file})
+## @deftypefnx {Function File} {@var{status} =} savepath (@dots{})
+## Save the unique portion of the current function search path that is
+## not set during Octave's initialization process to @var{file}.
 ## If @var{file} is omitted, @file{~/.octaverc} is used.  If successful,
 ## @code{savepath} returns 0.
-## @seealso{path, addpath, rmpath, genpath, pathdef, pathsep}
+## @seealso{path, addpath, rmpath, genpath, pathdef}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@givebillmoney.com>
 
-function varargout = savepath (file)
+function retval = savepath (file)
 
-  retval = 1;
+  ret = 1;
 
   beginstring = "## Begin savepath auto-created section, do not edit";
   endstring   = "## End savepath auto-created section";
 
   if (nargin == 0)
     file = fullfile ("~", ".octaverc");
   endif
 
-  ## parse the file if it exists to see if we should replace a section
-  ## or create a section
-  startline = 0;
-  endline = 0;
+  ## parse the file if it exists to see if we should replace an
+  ## existing section or create a new section
+  startline = endline = 0;
   filelines = {};
   if (exist (file) == 2)
-    ## read in all lines of the file
     [fid, msg] = fopen (file, "rt");
     if (fid < 0)
       error ("savepath: could not open file, %s: %s", file, msg);
     endif
     unwind_protect
       linenum = 0;
-      while (linenum >= 0)
-        result = fgetl (fid);
-        if (isnumeric (result))
-          ## end at the end of file
-          linenum = -1;
-        else
-          linenum = linenum + 1;
-          filelines{linenum} = result;
-          ## find the first and last lines if they exist in the file
-          if (strcmp (result, beginstring))
-            startline = linenum;
-          elseif (strcmp (result, endstring))
-            endline = linenum;
-          endif
+      while (ischar (line = fgetl (fid)))
+        filelines{++linenum} = line;
+        ## find the first and last lines if they exist in the file
+        if (strcmp (line, beginstring))
+          startline = linenum;
+        elseif (strcmp (line, endstring))
+          endline = linenum;
         endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
-        error ("savepath: could not close file after reading, %s",
-               file);
+        error ("savepath: could not close file after reading, %s", file);
       endif
     end_unwind_protect
   endif
 
   if (startline > endline || (startline > 0 && endline == 0))
     error ("savepath: unable to parse file, %s", file);
   endif
 
@@ -111,61 +103,61 @@ function varargout = savepath (file)
       fprintf (fid, "%s\n", pre{i});
     endfor
 
     ## Remove the portion of the path defined via the command line
     ## and/or the environment.
     workingpath = parsepath (path);
     command_line_path = parsepath (command_line_path ());
     octave_path = parsepath (getenv ("OCTAVE_PATH"));
-    if (isempty (pathdef ()))
+    pathdef = pathdef ();
+    if (isempty (pathdef))
       ## This occurs when running octave via run-octave. In this instance
       ## the entire path is specified via the command line and pathdef()
       ## is empty.
-      [tmp, n] = setdiff (workingpath, octave_path);
+      [~, n] = setdiff (workingpath, octave_path);
       default_path = command_line_path;
     else
-      [tmp, n] = setdiff (workingpath, union (command_line_path, octave_path));
-      default_path = parsepath (pathdef ());
+      [~, n] = setdiff (workingpath, union (command_line_path, octave_path));
+      default_path = parsepath (pathdef);
     endif
     ## This is the path we'd like to preserve when octave is run.
     path_to_preserve = workingpath (sort (n));
 
     ## Determine the path to Octave's user and sytem wide pkgs.
     [pkg_user, pkg_system] = pkg ("list");
     pkg_user_path = cell (1, numel (pkg_user));
     pkg_system_path = cell (1, numel (pkg_system));
-    for n = 1:numel(pkg_user)
+    for n = 1:numel (pkg_user)
       pkg_user_path{n} = pkg_user{n}.archprefix;
     endfor
-    for n = 1:numel(pkg_system)
+    for n = 1:numel (pkg_system)
       pkg_system_path{n} = pkg_system{n}.archprefix;
     endfor
     pkg_path = union (pkg_user_path, pkg_system_path);
 
     ## Rely on Octave's initialization to include the pkg path elements.
     if (! isempty (pkg_path))
-      [tmp, n] = setdiff (path_to_preserve, strcat (pkg_path, ":"));
-      path_to_preserve = path_to_preserve (sort (n));
+      [~, n] = setdiff (path_to_preserve, strcat (pkg_path, ":"));
+      path_to_preserve = path_to_preserve(sort (n));
     endif
 
     ## Split the path to be saved into two groups. Those path elements that
     ## belong at the beginning and those at the end.
     if (! isempty (default_path))
-      n1 = strmatch (default_path{1}, path_to_preserve, "exact");
-      n2 = strmatch (default_path{end}, path_to_preserve, "exact");
+      n1 = find (strcmp (default_path{1}, path_to_preserve));
+      n2 = find (strcmp (default_path{end}, path_to_preserve));
       n_middle = round (0.5*(n1+n2));
-      [tmp, n] = setdiff (path_to_preserve, default_path);
-      path_to_save = path_to_preserve (sort (n));
+      [~, n] = setdiff (path_to_preserve, default_path);
+      path_to_save = path_to_preserve(sort (n));
       ## Remove pwd
-      path_to_save = path_to_save (! strcmpi (path_to_save,
-                                              strcat (".", pathsep)));
+      path_to_save = path_to_save(! strcmp (path_to_save, ["." pathsep]));
       n = ones (size (path_to_save));
-      for m = 1:numel(path_to_save)
-        n(m) = strmatch (path_to_save{m}, path_to_preserve);
+      for m = 1:numel (path_to_save)
+        n(m) = find (strcmp (path_to_save{m}, path_to_preserve));
       endfor
       path_to_save_begin = path_to_save(n <= n_middle);
       path_to_save_end   = path_to_save(n > n_middle);
     else
       path_to_save_begin = path_to_preserve;
       path_to_save_end   = {};
     endif
     path_to_save_begin = cell2mat (path_to_save_begin);
@@ -194,21 +186,21 @@ function varargout = savepath (file)
     closeread = fclose (fid);
     if (closeread < 0)
       error ("savepath: could not close savefile after writing, %s", file);
     elseif (nargin == 0)
       warning ("savepath: current path saved to %s", file);
     endif
   end_unwind_protect
 
-  retval = 0;
+  ret = 0;
 
-  if (nargout == 1)
-    varargout{1} = retval;
+  if (nargout > 0)
+    retval = ret;
   endif
 
 endfunction
 
 function path_elements = parsepath (p)
   pat = sprintf ('([^%s]+[%s$])', pathsep, pathsep);
-  [~, ~, ~, path_elements] = regexpi (strcat (p, pathsep), pat);
+  path_elements = regexpi (strcat (p, pathsep), pat, "match");
 endfunction
 
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 SÔøΩren Hauberg
+## Copyright (C) 2005-2012 SÔøΩren Hauberg
 ## Copyright (C) 2010 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -941,16 +941,25 @@ function install (files, handle_deps, au
             break;
           endif
         endfor
       endif
     endfor
     load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
                                     global_install);
   endif
+
+  ## If there's a NEWS file, mention it
+  ## we are checking if desc exists too because it's possible to ge to this point
+  ## without creating it such as giving an invalid filename for the package
+  if (exist ("desc", "var") && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
+    printf ("For information about changes from previous versions of the %s package, run 'news (\"%s\")'.\n",
+            desc.name, desc.name);
+  endif
+
 endfunction
 
 function uninstall (pkgnames, handle_deps, verbose, local_list,
                     global_list, global_install)
   ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages(local_list,
                                                          global_list);
   if (global_install)
@@ -1869,17 +1878,17 @@ endfunction
 function write_index (desc, dir, index_file, global_install)
   ## Get names of functions in dir
   [files, err, msg] = readdir (dir);
   if (err)
     error ("couldn't read directory %s: %s", dir, msg);
   endif
 
   ## Get classes in dir
-  class_idx = strmatch ("@", files);
+  class_idx = find (strncmp (files, '@', 1));
   for k = 1:length (class_idx)
     class_name = files {class_idx (k)};
     class_dir = fullfile (dir, class_name);
     if (exist (class_dir, "dir"))
       [files2, err, msg] = readdir (class_dir);
       if (err)
         error ("couldn't read directory %s: %s", class_dir, msg);
       endif
@@ -1992,31 +2001,31 @@ function [out1, out2] = installed_packag
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
   endif
 
   ## Now check if the package is loaded.
   tmppath = strrep (path(), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
-    if (findstr (tmppath, strrep (installed_pkgs_lst{i}.dir, "\\", "/")))
+    if (strfind (tmppath, strrep (installed_pkgs_lst{i}.dir, '\', '/')))
       installed_pkgs_lst{i}.loaded = true;
     else
       installed_pkgs_lst{i}.loaded = false;
     endif
   endfor
   for i = 1:length (local_packages)
-    if (findstr (tmppath, strrep (local_packages{i}.dir, "\\", "/")))
+    if (strfind (tmppath, strrep (local_packages{i}.dir, '\', '/')))
       local_packages{i}.loaded = true;
     else
       local_packages{i}.loaded = false;
     endif
   endfor
   for i = 1:length (global_packages)
-    if (findstr (tmppath, strrep (global_packages{i}.dir, "\\", "/")))
+    if (strfind (tmppath, strrep (global_packages{i}.dir, '\', '/')))
       global_packages{i}.loaded = true;
     else
       global_packages{i}.loaded = false;
     endif
   endfor
 
   ## Should we return something?
   if (nargout == 2)
@@ -2185,23 +2194,18 @@ function unload_packages (files, handle_
       ## FIXME: We should also check if we need to remove items from
       ## EXEC_PATH.
     endif
   endfor
 endfunction
 
 function [status_out, msg_out] = rm_rf (dir)
   if (exist (dir))
-    crr = confirm_recursive_rmdir ();
-    unwind_protect
-      confirm_recursive_rmdir (false);
-      [status, msg] = rmdir (dir, "s");
-    unwind_protect_cleanup
-      confirm_recursive_rmdir (crr);
-    end_unwind_protect
+    crr = confirm_recursive_rmdir (false, "local");
+    [status, msg] = rmdir (dir, "s");
   else
     status = 1;
     msg = "";
   endif
   if (nargout > 0)
     status_out = status;
   endif
   if (nargout > 1)
@@ -2389,17 +2393,17 @@ function dep = is_architecture_dependent
   for i = 1 : length (archdepsuffix)
     ext = archdepsuffix{i};
     if (ext(end) == "*")
       isglob = true;
       ext(end) = [];
     else
       isglob = false;
     endif
-    pos = findstr (nm, ext);
+    pos = strfind (nm, ext);
     if (pos)
       if (! isglob && (length(nm) - pos(end) != length(ext) - 1))
         continue;
       endif
       dep = true;
       break;
     endif
   endfor
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 VZLU Prague, a.s.
+## Copyright (C) 2010-2012 VZLU Prague, a.s.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -117,18 +117,18 @@ function enhanced = gnuplot_set_term (pl
     term = gnuplot_default_term ();
     opts_str = "";
   else
     ## Get the one word terminal id and save the remaining as options to
     ## be passed on to gnuplot.  The terminal may respect the graphics
     ## toolkit.
     [term, opts_str] = gnuplot_trim_term (term);
     term = lower (term);
-    if (strcmpi (term, "lua"))
-      ## Replace "lau tikz" with
+    if (strcmp (term, "lua"))
+      ## Replace "lua tikz" with just "tikz"
       term = "tikz";
       opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
 
   if (strfind (opts_str, "noenhanced"))
     enhanced = false;
   else
@@ -142,20 +142,20 @@ function enhanced = gnuplot_set_term (pl
       enh_str = "enhanced";
     else
       enh_str = "";
     endif
 
     if (! isempty (h) && isfigure (h))
 
       ## Generate gnuplot title string for plot windows.
-      if (output_to_screen (term) && ~strcmp (term, "dumb"))
+      if (output_to_screen (term) && ! strcmp (term, "dumb"))
         fig.numbertitle = get (h, "numbertitle");
         fig.name = strrep (get (h, "name"), "\"", "\\\"");
-        if (strcmpi (get (h, "numbertitle"), "on"))
+        if (strcmp (get (h, "numbertitle"), "on"))
           title_str = sprintf ("Figure %d", h);
         else
           title_str = "";
         endif
         if (! isempty (fig.name) && ! isempty (title_str))
           title_str = sprintf ("%s: %s", title_str, fig.name);
         elseif (! isempty (fig.name) && isempty (title_str))
           title_str = fig.name;
@@ -181,18 +181,18 @@ function enhanced = gnuplot_set_term (pl
           set (h, "units", "pixels");
           position_in_pixels = get (h, "position");
         unwind_protect_cleanup
           set (h, "units", units);
         end_unwind_protect
         gnuplot_pos = position_in_pixels(1:2);
         gnuplot_size = position_in_pixels(3:4);
         if (! (output_to_screen (term)
-               || any (strcmp (term, {"emf", "gif", "jpeg", "pbm", "png", ...
-                                      "pngcairo", "svg"}))))
+               || any (strcmp (term, {"canvas", "emf", "gif", "jpeg", ...
+                                      "pbm", "png", "pngcairo", "svg"}))))
           ## Convert to inches
           gnuplot_pos = gnuplot_pos / 72;
           gnuplot_size = gnuplot_size / 72;
         endif
         if (all (gnuplot_size > 0))
           terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
                                  "gif", "jpeg", "latex", "pbm", "pdf", ...
                                  "pdfcairo", "postscript", "png", "pngcairo", ...
@@ -200,22 +200,22 @@ function enhanced = gnuplot_set_term (pl
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
           switch (term)
           case terminals_with_size
-            size_str = sprintf ("size %g,%g", gnuplot_size);
+            size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
           case "tikz"
             size_str = sprintf ("size %gin,%gin", gnuplot_size);
           case "dumb"
             new_stream = 1;
-            if (~isempty (getenv ("COLUMNS")) && ~isempty (getenv ("LINES")))
+            if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
               ## Let dumb use full text screen size (minus prompt lines).
               n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
               ## n = the number of times \n appears in PS1
               size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
             else
               ## Use the gnuplot default.
               size_str = "";
             endif
diff --git a/scripts/plot/__go_close_all__.m b/scripts/plot/__go_close_all__.m
deleted file mode 100644
--- a/scripts/plot/__go_close_all__.m
+++ /dev/null
@@ -1,32 +0,0 @@
-## Copyright (C) 2007-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} __go_close_all__ ()
-## Undocumented internal function.
-## @end deftypefn
-
-## Author: jwe
-
-function __go_close_all__ ()
-  close ("all", "hidden");
-endfunction
-
-
-## No test needed for internal helper function.
-%!assert (1)
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -30,30 +30,28 @@
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function h = allchild (handles)
 
   shh = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "on");
-    if (isscalar (handles))
-      h = get (handles, "children");
-    else
-      h = cell (size (handles));
-      for i = 1:numel (handles)
-        h{i} = get (handles, "children");
-      endfor
-    endif
+    h = get (handles, "children");
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
-%!test
+
+%!testif HAVE_FLTK
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
-%!   assert(get(allchild(hf),'type'),{'axes'; 'uimenu'; 'uimenu'; 'uimenu'})
+%!   assert(get (allchild (hf),"type"),{"axes"; "uimenu"; "uimenu"; "uimenu"});
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ## Copyright (C) 2007-2009 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -28,19 +28,21 @@
 ## contributions of a value to a sum, and is functionally similar to
 ## @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the area under
 ## the curve is shaded.
 ##
 ## If the @var{x} argument is omitted it is assumed to be given by
 ## @code{1 : rows (@var{y})}.  A value @var{lvl} can be defined that determines
 ## where the base level of the shading under the curve should be defined.
 ##
-## Additional arguments to the @code{area} function are passed to the
-## @code{patch}.  The optional return value @var{h} provides a handle to
-## area series object representing the patches of the areas.
+## Additional arguments to the @code{area} function are passed to
+## @code{patch}.
+##
+## The optional return value @var{h} is a graphics handle to the hggroup
+## object representing the area patch objects.
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
 
   if (nargin > 0)
diff --git a/scripts/plot/axes.m b/scripts/plot/axes.m
--- a/scripts/plot/axes.m
+++ b/scripts/plot/axes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -304,246 +304,284 @@ function curr_axis = __axis__ (ca, ax, v
 
 endfunction
 
 function lims = __get_tight_lims__ (ca, ax)
 
   ## Get the limits for axis ("tight").
   ## AX should be one of "x", "y", or "z".
   kids = findobj (ca, "-property", strcat (ax, "data"));
-  ## Since contours set the cdata for the patches to the hggroup zdata property, exclude
-  ## hgroups when determining the tight limits.
-  hg_kids = findobj (ca, "-property", strcat (ax, "data"), "type", "hggroup");
+  ## The data properties for hggroups mirror their children.
+  ## Exclude the redundant hgroup values.
+  hg_kids = findobj (kids, "type", "hggroup");
   kids = setdiff (kids, hg_kids);
   if (isempty (kids))
     ## Return the current limits.
     lims = get (ca, strcat (ax, "lim"));
   else
     data = get (kids, strcat (ax, "data"));
     scale = get (ca, strcat (ax, "scale"));
-    if (strcmp (scale, "log") && any (data > 0))
-      data(data<=0) = NaN;
+    if (! iscell (data))
+      data = {data};
+    end
+    if (strcmp (scale, "log"))
+      tmp = data;
+      data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
+      n = cellfun (@isempty, data);
+      data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
-    if (iscell (data))
-      data = data (find (! cellfun ("isempty", data)));
-      if (! isempty (data))
-        lims_min = min (cellfun ("min", cellfun ("min", data, 'uniformoutput', false)(:)));
-        lims_max = max (cellfun ("max", cellfun ("max", data, 'uniformoutput', false)(:)));
-        lims = [lims_min, lims_max];
-      else
-        lims = [0, 1];
-      endif
+    data = cellfun (@(x) x(isfinite(x)), data, "uniformoutput", false);
+    data = data(! cellfun ("isempty", data));
+    if (! isempty (data))
+      lims_min = min (cellfun (@(x) min (x(:)), data(:)));
+      lims_max = max (cellfun (@(x) max (x(:)), data(:)));
+      lims = [lims_min, lims_max];
     else
-      lims = [min(data(:)), max(data(:))];
+      lims = [0, 1];
     endif
   endif
 
 endfunction
 
 function __do_tight_option__ (ca)
 
   set (ca,
        "xlim", __get_tight_lims__ (ca, "x"),
        "ylim", __get_tight_lims__ (ca, "y"));
   if __calc_dimensions__ (ca) > 2
     set (ca, "zlim", __get_tight_lims__ (ca, "z"));
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
-%!
-%! subplot(221);
-%! plot(t, x);
-%! title("normal plot");
-%!
-%! subplot(222);
-%! plot(t, x);
-%! title("square plot");
-%! axis("square");
-%!
-%! subplot(223);
-%! plot(t, x);
-%! title("equal plot");
-%! axis("equal");
-%!
-%! subplot(224);
-%! plot(t, x);
-%! title("normal plot again");
-%! axis("normal");
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
+%!
+%! subplot (221);
+%!  plot (t, x);
+%!  title ('normal plot');
+%!
+%! subplot (222);
+%!  plot (t, x);
+%!  title ('square plot');
+%!  axis ('square');
+%!
+%! subplot (223);
+%!  plot (t, x);
+%!  title ('equal plot');
+%!  axis ('equal');
 %!
-%! subplot(121);
-%! plot(t, x);
-%! title("ij plot");
-%! axis("ij");
+%! subplot (224);
+%!  plot (t, x);
+%!  title ('normal plot again');
+%!  axis ('normal');
+
+%!demo
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(122);
-%! plot(t, x);
-%! title("xy plot");
-%! axis("xy");
+%! subplot (121);
+%!  plot (t, x);
+%!  title ('ij plot');
+%!  axis ('ij');
+%!
+%! subplot (122);
+%!  plot (t, x);
+%!  title ('xy plot');
+%!  axis ('xy');
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(331);
-%! plot(t, x);
-%! title("x tics and labels");
-%! axis("ticx");
+%! subplot (331);
+%!  plot (t, x);
+%!  title ('x tics and labels');
+%!  axis ('ticx');
 %!
-%! subplot(332);
-%! plot(t, x);
-%! title("y tics and labels");
-%! axis("ticy");
+%! subplot (332);
+%!  plot (t, x);
+%!  title ('y tics and labels');
+%!  axis ('ticy');
 %!
-%! subplot(333);
-%! plot(t, x);
-%! title("axis off");
-%! axis("off");
+%! subplot (333);
+%!  plot (t, x);
+%!  title ('axis off');
+%!  axis ('off');
 %!
-%! subplot(334);
-%! plot(t, x);
-%! title("x and y tics, x labels");
-%! axis("labelx","tic");
+%! subplot (334);
+%!  plot (t, x);
+%!  title ('x and y tics, x labels');
+%!  axis ('labelx','tic');
 %!
-%! subplot(335);
-%! plot(t, x);
-%! title("x and y tics, y labels");
-%! axis("labely","tic");
+%! subplot (335);
+%!  plot (t, x);
+%!  title ('x and y tics, y labels');
+%!  axis ('labely','tic');
 %!
-%! subplot(336);
-%! plot(t, x);
-%! title("all tics but no labels");
-%! axis("nolabel","tic");
+%! subplot (336);
+%!  plot (t, x);
+%!  title ('all tics but no labels');
+%!  axis ('nolabel','tic');
 %!
-%! subplot(337);
-%! plot(t, x);
-%! title("x tics, no labels");
-%! axis("nolabel","ticx");
+%! subplot (337);
+%!  plot (t, x);
+%!  title ('x tics, no labels');
+%!  axis ('nolabel','ticx');
 %!
-%! subplot(338);
-%! plot(t, x);
-%! title("y tics, no labels");
-%! axis("nolabel","ticy");
+%! subplot (338);
+%!  plot (t, x);
+%!  title ('y tics, no labels');
+%!  axis ('nolabel','ticy');
 %!
-%! subplot(339);
-%! plot(t, x);
-%! title("all tics and labels");
-%! axis("on");
+%! subplot (339);
+%!  plot (t, x);
+%!  title ('all tics and labels');
+%!  axis ('on');
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(321);
-%! plot(t, x);
-%! title("axes at [0 3 0 1]")
-%! axis([0,3,0,1]);
+%! subplot (321);
+%!  plot (t, x);
+%!  title ('axes at [0 3 0 1]');
+%!  axis ([0,3,0,1]);
 %!
-%! subplot(322);
-%! plot(t, x);
-%! title("auto");
-%! axis("auto");
+%! subplot (322);
+%!  plot (t, x);
+%!  title ('auto');
+%!  axis ('auto');
 %!
-%! subplot(323);
-%! plot(t, x, ";sine [0:2pi];"); hold on;
-%! plot(-3:3,-3:3, ";line (-3,-3)->(3,3);"); hold off;
-%! title("manual");
-%! axis("manual");
+%! subplot (323);
+%!  plot (t, x, ';sine [0:2pi];'); hold on;
+%!  plot (-3:3,-3:3, ';line (-3,-3)->(3,3);'); hold off;
+%!  title ('manual');
+%!  axis ('manual');
 %!
-%! subplot(324);
-%! plot(t, x, ";sine [0:2pi];");
-%! title("axes at [0 3 0 1], then autox");
-%! axis([0,3,0,1]); axis("autox");
+%! subplot (324);
+%!  plot (t, x, ';sine [0:2pi];');
+%!  title ('axes at [0 3 0 1], then autox');
+%!  axis ([0,3,0,1]);
+%!  axis ('autox');
 %!
-%! subplot(325);
-%! plot(t, x, ";sine [0:2p];");
-%! axis([3,6,0,1]); axis("autoy");
-%! title("axes at [3 6 0 1], then autoy");
+%! subplot (325);
+%!  plot (t, x, ';sine [0:2p];');
+%!  title ('axes at [3 6 0 1], then autoy');
+%!  axis ([3,6,0,1]);
+%!  axis ('autoy');
 %!
-%! subplot(326);
-%! plot(t, sin(t), t, -2*sin(t/2))
-%! axis("tight");
-%! title("tight");
+%! subplot (326);
+%!  plot (t, sin(t), t, -2*sin(t/2));
+%!  axis ('tight');
+%!  title ('tight');
 
 %!demo
-%! clf
-%! axis image
-%! x=0:0.1:10;
-%! plot(x,sin(x))
-%! axis image
-%! title("image")
+%! clf;
+%! x = 0:0.1:10;
+%! plot (x, sin(x));
+%! axis image;
+%! title ('image');
 
 %!demo
-%! clf
-%! [x,y,z] = peaks(50);
-%! x1 = max(x(:));
-%! pcolor(x-x1,y-x1/2,z)
-%! hold on
-%! [x,y,z] = sombrero;
-%! s = x1/max(x(:));
-%! pcolor(s*x+x1,s*y+x1/2,5*z)
-%! axis tight
+%! clf;
+%! colormap ('default');
+%! [x,y,z] = peaks (50);
+%! x1 = max (x(:));
+%! pcolor (x-x1, y-x1/2, z);
+%! hold on;
+%! [x,y,z] = sombrero ();
+%! s = x1 / max (x(:));
+%! pcolor (s*x+x1, s*y+x1/2, 5*z);
+%! axis tight;
+
+%!demo
+%! clf;
+%! x = -10:10;
+%! plot (x,x, x,-x);
+%! set (gca, 'yscale', 'log');
+%! legend ({'x >= 1', 'x <= 1'}, 'location', 'north');
+%! title ('ylim = [1, 10]');
+
+%!demo
+%! clf;
+%! loglog (1:20, '-s');
+%! axis tight;
 
 %!demo
-%! clf
-%! x = -10:10;
-%! plot (x, x, x, -x)
-%! set (gca, "yscale", "log")
-%! legend ({"x >= 1", "x <= 1"}, "location", "north")
-%! title ("ylim = [1, 10]")
+%! clf;
+%! x = -10:0.1:10;
+%! y = sin (x)./(1 + abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ('no plot box');
+%! set (gca, 'xaxislocation', 'zero');
+%! set (gca, 'yaxislocation', 'zero');
+%! box off;
 
 %!demo
-%! clf
-%! loglog (1:20, "-s")
-%! axis tight
+%! clf;
+%! x = -10:0.1:10;
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ('no plot box');
+%! set (gca, 'xaxislocation', 'zero');
+%! set (gca, 'yaxislocation', 'left');
+%! box off;
 
 %!demo
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ('no plot box');
+%! set (gca, 'xaxislocation', 'zero');
+%! set (gca, 'yaxislocation', 'right');
+%! box off;
 
 %!demo
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "left")
-%! box off
-
-%!demo
-%! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "right")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ('no plot box');
+%! set (gca, 'xaxislocation', 'bottom');
+%! set (gca, 'yaxislocation', 'zero');
+%! box off;
 
 %!demo
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "bottom")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ('no plot box');
+%! set (gca, 'xaxislocation', 'top');
+%! set (gca, 'yaxislocation', 'zero');
+%! box off;
 
-%!demo
-%! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "top")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   plot (11:20, [21:24, NaN, -Inf, 27:30]);
+%!   hold all;
+%!   plot (11:20, 25.5 + rand (10));
+%!   axis tight;
+%!   assert (axis (), [11 20 21 30]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   a = logspace (-5, 1, 10);
+%!   loglog (a, -a);
+%!   axis tight;
+%!   assert (axis (), [1e-5, 10, -10, -1e-5]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -31,17 +31,17 @@
 ## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
-## The optional return value @var{h} provides a handle to the "bar series"
+## The optional return value @var{h} is a handle to the created "bar series"
 ## object with one handle per column of the variable @var{y}.  This
 ## series allows common elements of the group of bar series objects to
 ## be changed in a single bar series and the same properties are changed
 ## in the other "bar series".  For example,
 ##
 ## @example
 ## @group
 ## h = bar (rand (5, 10));
@@ -88,8 +88,12 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = bar (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (true, "bar", varargin{:});
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/barh.m b/scripts/plot/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/barh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -31,24 +31,28 @@
 ## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
-## The optional return value @var{h} provides a handle to the bar series
-## object.  See @code{bar} for a description of the use of the bar series.
-##
 ## The optional input handle @var{h} allows an axis handle to be passed.
 ## Properties of the patch graphics object can be changed using
 ## @var{prop}, @var{val} pairs.
 ##
+## The optional return value @var{h} is a graphics handle to the created
+## bar series object.  See @code{bar} for a description of the use of the
+## bar series.
 ## @seealso{bar, plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = barh (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (false, "barh", varargin{:});
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -1,9 +1,9 @@
-## Copyright (C)  2007-2011 David Bateman
+## Copyright (C)  2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -34,19 +34,20 @@
 ## the contours to label can be selected with the mouse.
 ##
 ## Additional property/value pairs that are valid properties of text objects
 ## can be given and are passed to the underlying text objects.  Additionally,
 ## the property "LabelSpacing" is available allowing the spacing between labels
 ## on a contour (in points) to be specified.  The default is 144 points, or 2
 ## inches.
 ##
-## The returned value @var{h} is the set of text object that represent the
-## contour labels.  The "userdata" property of the text objects contains the
-## numerical value of the contour label.
+## The optional return value @var{h} is a vector of graphics handles to
+## the text objects representing each label.  
+## The "userdata" property of the text objects contains the numerical value of
+## the contour label.
 ##
 ## An example of the use of @code{clabel} is
 ##
 ## @example
 ## @group
 ## [c, h] = contour (peaks(), -4 : 6);
 ## clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
 ## @end group
@@ -121,19 +122,24 @@ function retval = clabel (c, varargin)
     endif
     retval = findobj (hg, "type", "text");
     if (! isempty (varargin))
       set (retval, varargin {:});
     endif
   else
     retval =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
   endif
+
 endfunction
 
+
 %!demo
-%! clf
-%! [c, h] = contour (peaks(), -4 : 6);
-%! clabel (c, h, -4 : 2 : 6, 'fontsize', 12);
+%! clf;
+%! colormap ('default');
+%! [c, h] = contour (peaks (), -4:6);
+%! clabel (c, h, -4:2:6, 'fontsize', 12);
 
 %!demo
-%! clf
-%! [c, h] = contourf (peaks(), -7 : 6);
-%! clabel (c, h, -6 : 2 : 6, 'fontsize', 12);
+%! clf;
+%! colormap ('default');
+%! [c, h] = contourf (peaks (), -7:6);
+%! clabel (c, h, -6:2:6, 'fontsize', 12);
+
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,18 +21,20 @@
 ## @deftypefnx {Function File} {} clf ("reset")
 ## @deftypefnx {Function File} {} clf (@var{hfig})
 ## @deftypefnx {Function File} {} clf (@var{hfig}, "reset")
 ## @deftypefnx {Function File} {@var{h} =} clf (@dots{})
 ## Clear the current figure window.  @code{clf} operates by deleting child
 ## graphics objects with visible handles (@code{handlevisibility} = on).
 ## If @var{hfig} is specified operate on it instead of the current figure.
 ## If the optional argument @code{"reset"} is specified, all objects including
-## those with hidden handles are deleted.  If an output value is
-## requested, return the handle of the figure window that was cleared.
+## those with hidden handles are deleted.
+## 
+## The optional return value @var{h} is the graphics handle of the figure
+## window that was cleared.
 ## @seealso{cla, close, delete}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = clf (varargin)
 
   if (nargin > 2)
@@ -77,16 +79,17 @@ function retval = clf (varargin)
   delete (hc);
 
   if (nargout > 0)
     retval = hfig;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (!isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
@@ -94,8 +97,9 @@ endfunction
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 John W. Eaton
+## Copyright (C) 2002-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/closereq.m b/scripts/plot/closereq.m
--- a/scripts/plot/closereq.m
+++ b/scripts/plot/closereq.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -357,257 +357,293 @@ function [pos, cpos, vertical, mirr] = _
       dy = (1-scale)*actual_pos(4);
       cpos(2) = actual_pos(2) + dy/2;
       cpos(4) = actual_pos(4) - dy;
     endif
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar();
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("peer", gca (), "northoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! contour(peaks())
-%! colorbar("west");
-
-%!demo
-%! clf
-%! subplot(2,2,1)
-%! contour(peaks())
-%! colorbar("east");
-%! subplot(2,2,2)
-%! contour(peaks())
-%! colorbar("west");
-%! subplot(2,2,3)
-%! contour(peaks())
-%! colorbar("north");
-%! subplot(2,2,4)
-%! contour(peaks())
-%! colorbar("south");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,2,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(2,2,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-%! subplot(2,2,3)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(2,2,4)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar();
-%! subplot(1,2,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar("northoutside");
-%! subplot(1,2,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("southoutside");
 
 %!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar();
-%! subplot(2,1,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar("northoutside");
-%! subplot(2,1,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(1,2,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(1,2,2)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(2,1,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(2,1,2)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! contour(x)
-%! axis square;
-%! colorbar("east");
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! subplot(1,2,2)
-%! contour(x)
-%! colorbar("west");
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! contour (x)
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! colorbar ();
-%! colorbar off
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! contour (x)
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! colorbar ();
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
 %! colorbar ();
 
 %!demo
-%! clf
-%! imagesc (1./hilb(99));
-%! h = colorbar;
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ('westoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ('peer', gca (), 'northoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! contour (peaks ());
+%! colorbar ('west');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! subplot (2,2,1);
+%!  contour (peaks ());
+%!  colorbar ('east');
+%! subplot (2,2,2);
+%!  contour (peaks ());
+%!  colorbar ('west');
+%! subplot (2,2,3);
+%!  contour (peaks ());
+%!  colorbar ('north');
+%! subplot (2,2,4);
+%!  contour (peaks ());
+%!  colorbar ('south');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,2,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (2,2,2);
+%!  imagesc (x);
+%!  colorbar ('westoutside');
+%! subplot (2,2,3);
+%!  imagesc (x);
+%!  colorbar ('northoutside');
+%! subplot (2,2,4);
+%!  imagesc (x);
+%!  colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ();
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('westoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('northoutside');
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ();
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('westoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('northoutside');
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  colorbar ('westoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  colorbar ('northoutside');
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  colorbar ('westoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  colorbar ('northoutside');
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  colorbar ('southoutside');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  contour (x);
+%!  axis square;
+%!  colorbar ('east');
+%!  xlim ([1, 64]);
+%!  ylim ([1, 64]);
+%! subplot (1,2,2);
+%!  contour (x);
+%!  colorbar ('west');
+%!  xlim ([1, 64]);
+%!  ylim ([1, 64]);
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! contour (x);
+%! xlim ([1, 64]);
+%! ylim ([1, 64]);
+%! colorbar ();
+%! colorbar off;
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! contour (x);
+%! xlim ([1, 64]);
+%! ylim ([1, 64]);
+%! colorbar ();
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! imagesc (1 ./ hilb (99));
+%! h = colorbar ();
 %! set (h, 'yscale', 'log');
 
 %!demo
-%! clf
+%! clf;
+%! colormap ('default');
 %! imagesc (log10 (1 ./ hilb (99)));
-%! h = colorbar;
-%! ytick = get(h, "ytick");
-%! set (h, "yticklabel", sprintf ('10^{%g}|', ytick));
-
-%!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(1./hilb(n)); axis equal; colorbar
+%! h = colorbar ();
+%! ytick = get (h, 'ytick');
+%! set (h, 'yticklabel', sprintf ('10^{%g}|', ytick));
 
 %!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(x,y,1./hilb(n)); axis equal; colorbar
+%! clf;
+%! colormap ('default');
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
 
 %!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(y,x,1./hilb(n)); axis equal; colorbar
-## This requires that the axes position be properly determined for "axes equal"
-
-%!demo
-%! clf
-%! axes
-%! colorbar
-%! hold on
-%! contour(peaks)
-%! hold off
+%! clf;
+%! colormap ('default');
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (x, y, 1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("east")
-%! axis square
+%! clf;
+%! colormap ('default');
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (y, x, 1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
+
+## This requires that the axes position be properly determined for 'axis equal'
+%!demo
+%! clf;
+%! colormap ('default');
+%! axes;
+%! colorbar ();
+%! hold on;
+%! contour (peaks ());
+%! hold off;
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("eastoutside")
-%! axis square
+%! clf;
+%! colormap ('default');
+%! plot ([0, 2]);
+%! colorbar ('east');
+%! axis square;
 
 %!demo
-%! clf
-%! pcolor (peaks (20))
-%! shading ("interp")
-%! axis ("tight", "square")
-%! colorbar ()
-#%! axes('color','none','box','on','activepositionproperty','position')
+%! clf;
+%! colormap ('default');
+%! plot ([0, 2]);
+%! colorbar ('eastoutside');
+%! axis square;
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("east")
-%! axis equal
+%! clf;
+%! colormap ('default');
+%! pcolor (peaks (20));
+%! shading interp;
+%! axis ('tight', 'square');
+%! colorbar ();
+#%! axes ('color','none','box','on','activepositionproperty','position');
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("eastoutside")
-%! axis equal
+%! clf;
+%! colormap ('default');
+%! plot ([0, 2]);
+%! colorbar ('east');
+%! axis equal;
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! plot ([0, 2]);
+%! colorbar ('eastoutside');
+%! axis equal;
+
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 David Bateman
+## Copyright (C) 2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -73,16 +73,16 @@ function comet (varargin)
       pause (p);
     endfor
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! t = 0:.1:2*pi;
-%! x = cos(2*t).*(cos(t).^2);
-%! y = sin(2*t).*(sin(t).^2);
-%! comet(x,y)
+%! x = cos (2*t) .* (cos (t).^2);
+%! y = sin (2*t) .* (sin (t).^2);
+%! comet (x, y);
 
-
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott and John W. Eaton
+## Copyright (C) 2010-2012 Ben Abbott and John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -75,12 +75,14 @@ function comet3 (varargin)
       pause (p);
     endfor
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! t = 0:pi/20:5*pi;
 %! comet3 (cos(t), sin(t), t, 0.01);
+
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -26,27 +26,27 @@
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
 ## from the origin of a polar plot.  If a single complex argument @var{z} is
 ## given, then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag
 ## (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
-## a = toeplitz([1;randn(9,1)],[1,randn(1,9)]);
+## a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
 ## compass (eig (a))
 ## @end group
 ## @end example
 ##
-## @seealso{plot, polar, quiver, feather}
+## @seealso{polar, quiver, feather, plot}
 ## @end deftypefn
 
 function retval = compass (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("compass", varargin{:});
 
   arrowsize = 0.25;
 
@@ -107,13 +107,14 @@ function retval = compass (varargin)
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
 
 %!demo
+%! clf;
 %! randn_9x1_data = [-2.555884; 0.394974; -0.191871; -1.147024; 1.355425; -0.437335; -0.014370; -0.941312; 1.240300];
 %! randn_1x9_data = [1.42934, -1.10821, -1.70404, 0.63357, -0.68337, -1.19771, -0.96502, -1.12810, 0.22457];
 %! a = toeplitz ([1;randn_9x1_data], [1,randn_1x9_data]);
 %! compass (eig (a));
 
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Shai Ayal
+## Copyright (C) 1993-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -65,28 +65,32 @@ function [c, h] = contour (varargin)
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf ()
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = peaks ();
 %! contour (x, y, z);
 
 %!demo
-%! clf ()
-%! [theta, r] = meshgrid (linspace (0, 2*pi, 64), linspace(0,1,64));
+%! clf;
+%! colormap ('default');
+%! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
-%! Z = sin(2*theta).*(1-r);
-%! contour(X, Y, abs(Z), 10)
+%! Z = sin (2*theta) .* (1-r);
+%! contour (X, Y, abs(Z), 10);
 
 %!demo
-%! clf ()
+%! clf;
+%! colormap ('default');
 %! x = linspace (-2, 2);
 %! [x, y] = meshgrid (x);
-%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2+1);
-%! contourf (x, y, z, [0.4, 0.4])
-%! title ("The hole should be filled with the background color")
+%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2 + 1);
+%! contourf (x, y, z, [0.4, 0.4]);
+%! title ('The hole should be filled with the background color');
 
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David BAteman
+## Copyright (C) 2007-2012 David BAteman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -69,17 +69,20 @@ function [c, h] = contour3 (varargin)
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! contour3 (peaks (19));
-%! hold on
-%! surface (peaks (19), "facecolor", "none", "edgecolor", "black")
-%! colormap hot
-%! axis tight
-%! zlim auto
-%! hold off
-%! box off
+%! hold on;
+%! surface (peaks (19), 'facecolor', 'none', 'edgecolor', 'black');
+%! colormap (hot (64));
+%! axis tight;
+%! zlim auto;
+%! box off;
+%! hold off;
+
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2003-2011 Shai Ayal
+## Copyright (C) 2003-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ## Copyright (C) 2003 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -73,19 +73,26 @@ function [c, h] = contourf (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
+
 endfunction
 
+
 %!demo
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = peaks (50);
-%! contourf (x, y, z, -7:9)
+%! contourf (x, y, z, -7:9);
 
 %!demo
-%! [theta, r] = meshgrid (linspace (0, 2*pi, 64), linspace(0,1,64));
+%! clf;
+%! colormap ('default');
+%! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
-%! Z = sin(2*theta).*(1-r);
-%! contourf(X, Y, abs(Z), 10)
+%! Z = sin (2*theta) .* (1-r);
+%! contourf (X, Y, abs (Z), 10);
+
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul and Kai Habel
+## Copyright (C) 2007-2012 Michael Goffioul and Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -80,12 +80,16 @@ function [xx, yy, zz] = cylinder (vararg
     yy = y;
     zz = z;
   else
     surf (ax, x, y, z);
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = cylinder (10:-1:0,50);
 %! surf (x, y, z);
-%! title ("a cone")
+%! title ('a cone');
+
diff --git a/scripts/plot/daspect.m b/scripts/plot/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/daspect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -84,50 +84,51 @@ function varargout = daspect (varargin)
   if (nargout == 1)
     varargout{1} = get (hax, "dataaspectratio");
   elseif (nargout > 1)
     error ("daspect: only one output is allowed");
   endif
 
 endfunction
 
-%!demo
-%! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis square
-%! daspect ([1 1 1])
-%! title ("square plot-box with axis limits [0, 4, -2, 2]")
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis ([0 4 -1 1])
-%! daspect ([2 1 1])
-%! title ("square plot-box with axis limits [0, 4, -1, 1]")
+%! plot (x,cos(x), x,sin(x));
+%! axis square;
+%! daspect ([1 1 1]);
+%! title ('square plot-box with axis limits [0, 4, -2, 2]');
+
+%!demo
+%! clf;
+%! x = 0:0.01:4;
+%! plot (x,cos (x), x,sin (x));
+%! axis ([0 4 -1 1]);
+%! daspect ([2 1 1]);
+%! title ('square plot-box with axis limits [0, 4, -1, 1]');
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! daspect ([1 2 1])
-%! pbaspect ([2 1 1])
-%! title ("2x1 plot box with axis limits [0, 4, -2, 2]")
+%! plot (x,cos(x), x,sin(x));
+%! daspect ([1 2 1]);
+%! pbaspect ([2 1 1]);
+%! title ('2x1 plot box with axis limits [0, 4, -2, 2]');
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis square
-%! set (gca, "activepositionproperty", "position")
-%! daspect ([1 1 1])
-%! title ("square plot-box with axis limits [0, 4, -2, 2]")
+%! plot (x,cos(x), x, sin(x));
+%! axis square;
+%! set (gca, 'activepositionproperty', 'position');
+%! daspect ([1 1 1]);
+%! title ('square plot-box with axis limits [0, 4, -2, 2]');
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis ([0 4 -1 1])
-%! set (gca, "activepositionproperty", "position")
-%! daspect ([2 1 1])
-%! title ("square plot-box with axis limits [0, 4, -1, 1]")
+%! plot (x,cos(x), x,sin(x));
+%! axis ([0 4 -1 1]);
+%! set (gca, 'activepositionproperty', 'position');
+%! daspect ([2 1 1]);
+%! title ('square plot-box with axis limits [0, 4, -1, 1]');
 
diff --git a/scripts/plot/diffuse.m b/scripts/plot/diffuse.m
--- a/scripts/plot/diffuse.m
+++ b/scripts/plot/diffuse.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Sylvain Pelissier
+## Copyright (C) 2007-2012 Sylvain Pelissier
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -64,10 +64,13 @@ function [xx, yy, zz] = ellipsoid (varar
     yy = y;
     zz = z;
   else
     surf (h, x, y, z);
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! ellipsoid (0, 0, 1, 2, 3, 4, 20);
+
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -133,39 +133,44 @@ function retval = errorbar (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
+%! clf;
 %! rand_1x11_data1 = [0.82712, 0.50325, 0.35613, 0.77089, 0.20474, 0.69160, 0.30858, 0.88225, 0.35187, 0.14168, 0.54270];
 %! rand_1x11_data2 = [0.506375, 0.330106, 0.017982, 0.859270, 0.140641, 0.327839, 0.275886, 0.162453, 0.807592, 0.318509, 0.921112];
 %! errorbar (0:10, rand_1x11_data1, 0.25*rand_1x11_data2);
 
 %!demo
+%! clf;
 %! rand_1x11_data3 = [0.423650, 0.142331, 0.213195, 0.129301, 0.975891, 0.012872, 0.635327, 0.338829, 0.764997, 0.401798, 0.551850];
 %! rand_1x11_data4 = [0.682566, 0.456342, 0.132390, 0.341292, 0.108633, 0.601553, 0.040455, 0.146665, 0.309187, 0.586291, 0.540149];
-%! errorbar(0:10, rand_1x11_data3, rand_1x11_data4, ">");
+%! errorbar (0:10, rand_1x11_data3, rand_1x11_data4, '>');
 
 %!demo
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
-%! hg = errorbar (x, y1, err, "~", x, y2, err, ">");
+%! hg = errorbar (x, y1, err, '~', x, y2, err, '>');
 
 %!demo
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
-%! hg = errorbar (x, y1, err, err, "#r", x, y2, err, err, "#~");
+%! hg = errorbar (x, y1, err, err, '#r', x, y2, err, err, '#~');
 
 %!demo
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
-%! hg = errorbar (x, y1, err, err, err, err, "~>", ...
-%!                x, y2, err, err, err, err, "#~>-*");
+%! hg = errorbar (x, y1, err, err, err, err, '~>', ...
+%!                x, y2, err, err, err, err, '#~>-*');
 
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,30 +18,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontour (@var{f})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontour (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontour (@dots{})
 ##
-## Plots the contour lines of a function.  @var{f} is a string, inline function
+## Plot the contour lines of a function.  @var{f} is a string, inline function
 ## or function handle with two arguments defining the function.  By default the
 ## plot is over the domain @code{-2*pi < @var{x} < 2*pi} and @code{-2*pi <
 ## @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -54,13 +53,18 @@ function retval = ezcontour (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontour (f, [-3, 3]);
+
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,30 +18,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontourf (@var{f})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontourf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontourf (@dots{})
 ##
-## Plots the filled contour lines of a function.  @var{f} is a string, inline
+## Plot the filled contour lines of a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -54,13 +53,18 @@ function retval = ezcontourf (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontourf (f, [-3, 3]);
+
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezmesh (@var{f})
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
-## Plots the mesh defined by a function.  @var{f} is a string, inline
+## Plot the mesh defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
@@ -39,18 +39,18 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created 
+## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -60,33 +60,40 @@
 ## @group
 ## fx = @@(s,t) cos (s) .* cos(t);
 ## fy = @@(s,t) sin (s) .* cos(t);
 ## fz = @@(s,t) sin(t);
 ## ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezsurf, ezsurfc, ezmeshc}
+## @seealso{ezplot, ezmeshc, ezsurf, ezsurfc}
 ## @end deftypefn
 
 function retval = ezmesh (varargin)
 
   [h, needusage] = __ezplot__ ("mesh", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmesh (f, [-3, 3]);
 
 %!demo
+%! clf;
+%! colormap ('default');
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezmesh (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
+
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezmeshc (@var{f})
 ## @deftypefnx {Function File} {} ezmeshc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
-## Plots the mesh and contour lines defined by a function.  @var{f} is a string,
+## Plot the mesh and contour lines defined by a function.  @var{f} is a string,
 ## inline function or function handle with two arguments defining the function.
 ## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
@@ -39,18 +39,19 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a 2-element vector with a graphics
+## handle for the created mesh plot and a second handle for the created contour
+## plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -63,13 +64,18 @@ function retval = ezmeshc (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmeshc (f, [-3, 3]);
+
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot (@var{f})
 ## @deftypefnx {Function File} {} ezplot (@var{fx}, @var{fy})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot (@dots{})
 ##
-## Plots in two-dimensions the curve defined by @var{f}.  The function
+## Plot the curve defined by @var{f} in two dimensions.  The function
 ## @var{f} may be a string, inline function or function handle and can
 ## have either one or two variables.  If @var{f} has one variable, then
 ## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 500 points.
 ##
 ## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
 ## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
 ## < 2*pi} with 60 by 60 in the mesh.  For example:
@@ -56,35 +56,40 @@
 ## value of @var{x}, @var{y} and @var{t}.  If it is a four element
 ## vector, then the minimum and maximum values of @var{x} and @var{t}
 ## are determined by the first two elements and the minimum and maximum
 ## of @var{y} by the second pair of elements.
 ##
 ## @var{n} is a scalar defining the number of points to use in plotting
 ## the function.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the line objects plotted.
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @seealso{plot, ezplot3}
 ## @end deftypefn
 
 function retval = ezplot (varargin)
 
   [h, needusage] = __ezplot__ ("plot", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! ezplot (@cos, @sin)
+%! clf;
+%! ezplot (@cos, @sin);
 
 %!demo
-%! ezplot ("1/x")
+%! clf;
+%! ezplot ('1/x');
 
 %!demo
-%! ezplot (inline("x^2 - y^2 = 1"))
+%! clf;
+%! ezplot (inline ('x^2 - y^2 = 1'));
+
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,27 +18,26 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot3 (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot3 (@dots{})
 ##
-## Plots in three-dimensions the curve defined parametrically.
+## Plot a parametrically defined curve in three dimensions.
 ## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions
 ## or function handles with one arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{t}.  @var{n} is a scalar defining the number of points to use.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## fx = @@(t) cos (t);
 ## fy = @@(t) sin (t);
 ## fz = @@(t) t;
 ## ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 ## @end group
@@ -53,15 +52,19 @@ function retval = ezplot3 (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
+%! clf;
 %! fx = @(t) cos (t);
 %! fy = @(t) sin (t);
 %! fz = @(t) t;
 %! ezplot3 (fx, fy, fz, [0, 10*pi], 100);
+
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,27 +18,26 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezpolar (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
-## Plots in polar plot defined by a function.  The function @var{f} is either
+## Plot a function in polar coordinates.  The function @var{f} is either
 ## a string, inline function or function handle with one arguments defining
 ## the function.  By default the plot is over the domain @code{0 < @var{x} <
 ## 2*pi} with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{t}.  @var{n} is a scalar defining the number of points to
 ## use.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## ezpolar (@@(t) 1 + sin (t));
 ## @end example
 ##
 ## @seealso{polar, ezplot, ezsurf, ezmesh}
 ## @end deftypefn
 
@@ -48,12 +47,16 @@ function retval = ezpolar (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
+%! clf;
 %! ezpolar (@(t) 1 + sin (t));
+
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezsurf (@var{f})
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
-## Plots the surface defined by a function.  @var{f} is a string, inline
+## Plot the surface defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
@@ -39,18 +39,18 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -74,19 +74,26 @@ function retval = ezsurf (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurf (f, [-3, 3]);
 
 %!demo
+%! clf;
+%! colormap ('default');
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
+
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} ezsurfc (@var{f})
 ## @deftypefnx {Function File} {} ezsurfc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
-## Plots the surface and contour lines defined by a function.  @var{f} is a
+## Plot the surface and contour lines defined by a function.  @var{f} is a
 ## string, inline function or function handle with two arguments defining the
 ## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
 ## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
@@ -39,18 +39,19 @@
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a 2-element vector with a graphics
+## for the created surface plot and a second handle for the created contour
+## plot.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
@@ -63,13 +64,18 @@ function retval = ezsurfc (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
+
 %!demo
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurfc (f, [-3, 3]);
+
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -26,18 +26,18 @@
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
 ## from equidistant points on the x-axis.  If a single complex argument
 ## @var{z} is given, then @code{@var{u} = real (@var{z})} and
 ## @code{@var{v} = imag (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## phi = [0 : 15 : 360] * pi / 180;
 ## feather (sin (phi), cos (phi))
 ## @end group
 ## @end example
 ##
@@ -104,11 +104,14 @@ function retval = feather (varargin)
   end_unwind_protect
 
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
+
 %!demo
-%! phi = [0 : 15 : 360] * pi / 180;
-%! feather (sin (phi), cos (phi))
+%! clf;
+%! phi = [0 : 15 : 360] * pi/180;
+%! feather (sin (phi), cos (phi));
+
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -32,17 +32,17 @@ function h = figure (varargin)
 
   nargs = nargin;
 
   f = NaN;
 
   init_new_figure = false;
   if (mod (nargs, 2) == 1)
     tmp = varargin{1};
-    if (ishandle (tmp) && strcmp (get (tmp, "type"), "figure"))
+    if (isfigure (tmp))
       f = tmp;
       varargin(1) = [];
       nargs--;
     elseif (isnumeric (tmp) && tmp > 0 && tmp == fix (tmp))
       f = tmp;
       init_new_figure = true;
       varargin(1) = [];
       nargs--;
@@ -58,17 +58,26 @@ function h = figure (varargin)
   if (! isempty (cf) && cf != 0)
     if (isnan (f) || cf != f)
       drawnow ();
     endif
   endif
 
   if (rem (nargs, 2) == 0)
     if (isnan (f) || init_new_figure)
-      f = __go_figure__ (f, varargin{:});
+      if (ismac () && strcmp (graphics_toolkit (), "fltk"))
+        ## FIXME - Hack for fltk-aqua to work around bug # 31931
+        f = __go_figure__ (f);
+        drawnow ();
+        if (! isempty (varargin))
+          set (f, varargin{:});
+        endif
+      else
+        f = __go_figure__ (f, varargin{:});
+      endif
     elseif (nargs > 0)
       set (f, varargin{:});
     endif
     set (0, "currentfigure", f);
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,17 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fill (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} fill (@var{x1}, @var{y1}, @var{c1}, @var{x2}, @var{y2}, @var{c2})
 ## @deftypefnx {Function File} {} fill (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} fill (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} fill (@dots{})
-## Create one or more filled patch objects, returning a patch object for each.
+## Create one or more filled patch objects.
+##
+## The optional return value @var{h} is an array of graphics handles to
+## the created patch objects.
+## @seealso{patch}
 ## @end deftypefn
 
 function retval = fill (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
 
   htmp = [];
   iargs = __find_patches__ (varargin{:});
@@ -37,26 +41,26 @@ function retval = fill (varargin)
     axes (h);
 
     nextplot = get (h, "nextplot");
     for i = 1 : length (iargs)
       if (i > 1 && strncmp (nextplot, "replace", 7))
         set (h, "nextplot", "add");
       endif
       if (i == length (iargs))
-        args = varargin (iargs(i):end);
+        args = varargin(iargs(i):end);
       else
-        args = varargin (iargs(i):iargs(i+1)-1);
+        args = varargin(iargs(i):iargs(i+1)-1);
       endif
       newplot ();
       [tmp, fail] = __patch__ (h, args{:});
       if (fail)
-        print_usage();
+        print_usage ();
       endif
-      htmp (end + 1) = tmp;
+      htmp(end + 1, 1) = tmp;
     endfor
     if (strncmp (nextplot, "replace", 7))
       set (h, "nextplot", nextplot);
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
@@ -65,17 +69,17 @@ function retval = fill (varargin)
   endif
 
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
-    iargs (end + 1) = i;
+    iargs(end + 1) = i;
     if (ischar (varargin{i})
         && (strcmpi (varargin{i}, "faces")
             || strcmpi (varargin{i}, "vertices")))
       i += 4;
     elseif (isnumeric (varargin{i}))
       i += 2;
     endif
 
@@ -87,39 +91,35 @@ function iargs = __find_patches__ (varar
           break;
         elseif (isnumeric (varargin{i}))
           ## Assume its the colorspec
           i++;
           break;
         elseif (ischar (varargin{i}))
           colspec = tolower (varargin{i});
           collen = length (colspec);
-
-          if (strncmp (colspec, "blue", collen)
-              || strncmp (colspec, "black", collen)
-              || strncmp (colspec, "k", collen)
-              || strncmp (colspec, "black", collen)
-              || strncmp (colspec, "red", collen)
-              || strncmp (colspec, "green", collen)
-              || strncmp (colspec, "yellow", collen)
-              || strncmp (colspec, "magenta", collen)
-              || strncmp (colspec, "cyan", collen)
-              || strncmp (colspec, "white", collen))
+          if (any (strncmp (colspec, 
+                            {"blue", "black", "k", "red", "green", ...
+                             "yellow", "magenta", "cyan", "white"},
+                            collen)))
             i++;
             break;
           endif
         else
           i += 2;
         endif
       endwhile
     endif
   endwhile
+
 endfunction
 
+
 %!demo
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
-%! h = fill(x1,y1,'r',x2,y2,'g');
+%! clf;
+%! t1 = (1/16:1/8:1) * 2*pi;
+%! t2 = ((1/16:1/8:1) + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
+%! h = fill (x1,y1,'r', x2,y2,'g');
+
diff --git a/scripts/plot/findall.m b/scripts/plot/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/findall.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findall ()
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, "-depth", @var{d}, @dots{})
-## Find object with specified property values including hidden handles.
+## Find graphics object with specified property values including hidden handles.
 ##
 ## This function performs the same function as @code{findobj}, but it
 ## includes hidden objects in its search.  For full documentation, see
 ## @code{findobj}.
 ## @seealso{get, set, findobj, allchild}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
@@ -38,17 +38,23 @@ function h = findall (varargin)
     set (0, "showhiddenhandles", "on");
     h = findobj (varargin{:});
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
-%!test
+
+%!testif HAVE_FLTK
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = findall (hf);
-%!   all_handles = {"uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "uimenu"; "figure"};
-%!   assert (get (h, 'type'), all_handles)
+%!   all_handles(1:13,1) = {"uimenu"};
+%!   all_handles(14) = {"figure"};
+%!   assert (get (h, "type"), all_handles);
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
+
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Ben Abbott
+## Copyright (C) 2007-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findobj ()
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{prop_name})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{prop_name}, @var{pattern})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
-## Find object with specified property values.  The simplest form is
+## Find graphics object with specified property values.  The simplest form is
 ##
 ## @example
 ## findobj (@var{prop_name}, @var{prop_Value})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name
 ## @var{prop_name} and the name @var{prop_Value}.  The search can be limited
@@ -238,20 +238,22 @@ function h = findobj (varargin)
       endfor
     endfor
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   obj = findobj (hf, "type", "line");
 %!   assert (l, obj);
 %!   assert (gca, findobj (hf, "type", "axes"));
 %!   assert (hf, findobj (hf, "type", "figure"));
 %!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -122,13 +122,17 @@ function fplot (fn, limits, n, fmt)
   else
     for i = 1:columns (y)
       nams{i} = sprintf ("%s(:,%i)", nam, i);
     endfor
     legend (nams{:});
   endif
 endfunction
 
-%!demo
-%! fplot ("cos", [0, 2*pi])
 
 %!demo
-%! fplot ("[cos(x), sin(x)]", [0, 2*pi])
+%! clf;
+%! fplot ('cos', [0, 2*pi]);
+
+%!demo
+%! clf;
+%! fplot ('[cos(x), sin(x)]', [0, 2*pi]);
+
diff --git a/scripts/plot/gca.m b/scripts/plot/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/gca.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcbf.m b/scripts/plot/gcbf.m
--- a/scripts/plot/gcbf.m
+++ b/scripts/plot/gcbf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcbo.m b/scripts/plot/gcbo.m
--- a/scripts/plot/gcbo.m
+++ b/scripts/plot/gcbo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ginput.m b/scripts/plot/ginput.m
--- a/scripts/plot/ginput.m
+++ b/scripts/plot/ginput.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/gnuplot_binary.in b/scripts/plot/gnuplot_binary.in
--- a/scripts/plot/gnuplot_binary.in
+++ b/scripts/plot/gnuplot_binary.in
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,60 +12,84 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} graphics_toolkit (@var{name})
+## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
+## @deftypefnx {Function File} {@var{old_name} =} graphics_toolkit (@var{name})
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Change the default graphics toolkit to @var{name}.  If the
+## Query or set the default graphics toolkit to @var{name}.  If the
 ## toolkit is not already loaded, it is first initialized by calling the
 ## function @code{__init_@var{name}__}.
 ##
 ## When called with a list of figure handles, @var{hlist}, the graphics
 ## toolkit is changed only for the listed figures.
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
-function graphics_toolkit (varargin)
+function retval = graphics_toolkit (name, hlist = [])
 
-  name = "";
-  hlist = [];
+  if (nargin > 2)
+    print_usage ();
+  endif
 
-  if (nargin == 1)
-    if (ischar (varargin{1}))
-      name = varargin{1};
-    else
+  if (nargout > 0 || nargin == 0)
+    retval = get (0, "defaultfigure__graphics_toolkit__");
+  endif
+
+  if (nargin == 0)
+    return;
+  elseif (nargin == 1)
+    if (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
   elseif (nargin == 2)
-    if (isnumeric (varargin{1}) && ischar (varargin{2}))
-      hlist = varargin{1};
-      name = varargin{2};
-    elseif (ischar (varargin{2}))
-      error ("graphics_toolkit: invalid handle list");
-    else
+    ## Swap input arguments
+    [hlist, name] = deal (name, hlist);
+    if (! all (isfigure (hlist)))
+      error ("graphics_toolkit: invalid figure handle list HLIST");
+    elseif (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
-  else
-    print_usage ();
   endif
 
-  if (! any (strcmp (available_graphics_toolkits (), name)))
+  if (! any (strcmp (loaded_graphics_toolkits (), name)))
     feval (["__init_", name, "__"]);
-    if (! any (strcmp (available_graphics_toolkits (), name)))
-      error ("graphics_toolkit: %s toolkit was not correctly registered",
-             name);
+    if (! any (strcmp (loaded_graphics_toolkits (), name)))
+      error ("graphics_toolkit: %s toolkit was not correctly loaded", name);
     endif
   endif
 
   if (isempty (hlist))
     set (0, "defaultfigure__graphics_toolkit__", name);
   else
-    for h = hlist(:)'
-      set (h, "__graphics_toolkit__", name);
-    endfor
+    set (hlist, "__graphics_toolkit__", name);
   endif
 
 endfunction
+
+
+%!testif HAVE_FLTK
+%! unwind_protect
+%!   hf = figure ("visible", "off"); 
+%!   toolkit = graphics_toolkit ();
+%!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
+%!   graphics_toolkit (hf, "fltk"); 
+%!   assert (get (hf, "__graphics_toolkit__"), "fltk");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!testif HAVE_FLTK
+%!  old_toolkit = graphics_toolkit ();
+%!  switch old_toolkit
+%!    case {"gnuplot"}
+%!      new_toolkit = "fltk";
+%!    otherwise
+%!      new_toolkit = "gnuplot";
+%!  endswitch
+%!  assert (graphics_toolkit (new_toolkit), old_toolkit)
+%!  assert (graphics_toolkit (old_toolkit), new_toolkit)
+
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -93,29 +93,28 @@ function grid (varargin)
     endif
   else
     set (ax, "xgrid", "off", "ygrid", "off", "zgrid", "off");
     set (ax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! subplot (2,2,1)
-%! plot (1:100)
-%! grid minor
-%! grid minor
-%! grid
-%! title ("no grid")
-%! subplot (2,2,2)
-%! plot (1:100)
-%! grid
-%! title ("grid on")
-%! subplot (2,2,3)
-%! plot (1:100)
-%! grid minor
-%! title ("grid minor")
-%! subplot (2,2,4)
-%! semilogy (1:100)
-%! grid minor
-%! title ("grid minor")
+%! clf;
+%! subplot (2,2,1);
+%!  plot (1:100);
+%!  grid off;
+%!  title ('no grid');
+%! subplot (2,2,2);
+%!  plot (1:100);
+%!  grid on;
+%!  title ('grid on');
+%! subplot (2,2,3);
+%!  plot (1:100);
+%!  grid minor;
+%!  title ('grid minor');
+%! subplot (2,2,4);
+%!  semilogy (1:100);
+%!  grid minor;
+%!  title ('grid minor');
 
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/guidata.m b/scripts/plot/guidata.m
--- a/scripts/plot/guidata.m
+++ b/scripts/plot/guidata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/guihandles.m b/scripts/plot/guihandles.m
--- a/scripts/plot/guihandles.m
+++ b/scripts/plot/guihandles.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hggroup.m b/scripts/plot/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/hggroup.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Michael Goffioul
+## Copyright (C) 2008-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -89,85 +89,90 @@ function hold (varargin)
   else
     set (ax, "nextplot", "add");
     set (fig, "nextplot", "add");
   endif
   set (ax, "__hold_all__", hold_all);
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! A = rand (100);
 %! [X, Y] = find (A > 0.9);
-%! imshow (A)
-%! hold on
-%! plot (X, Y, 'o')
-%! hold off
+%! imshow (A);
+%! hold on;
+%! plot (X, Y, 'o');
+%! hold off;
 
 %!demo
-%! clf
-%! hold on
-%! imagesc(1./hilb(4));
-%! plot (1:4, "-s")
-%! hold off
+%! clf;
+%! colormap ('default');
+%! hold on;
+%! imagesc (1 ./ hilb (4));
+%! plot (1:4, '-s');
+%! hold off;
 
 %!demo
-%! clf
-%! hold on
-%! imagesc(1./hilb(2));
-%! imagesc(1./hilb(4));
-%! hold off
+%! clf;
+%! colormap ('default');
+%! hold on;
+%! imagesc (1 ./ hilb (2));
+%! imagesc (1 ./ hilb (4));
+%! hold off;
 
 %!demo
-%! clf
-%! hold on
-%! plot (1:4, "-s")
-%! imagesc(1./hilb(4));
-%! hold off
+%! clf;
+%! colormap ('default');
+%! hold on;
+%! plot (1:4, '-s');
+%! imagesc (1 ./ hilb (4));
+%! hold off;
 
 %!demo
-%! clf
-%! colormap (jet)
+%! clf;
+%! colormap ('default');
 %! t = linspace (-3, 3, 50);
 %! [x, y] = meshgrid (t, t);
 %! z = peaks (x, y);
 %! contourf (x, y, z, 10);
-%! hold ("on");
-%! plot (vec (x), vec (y), "^");
-%! patch ([-1.0 1.0 1.0 -1.0 -1.0], [-1.0 -1.0 1.0 1.0 -1.0], "red");
+%! hold on;
+%! plot (vec (x), vec (y), '^');
+%! patch ([-1.0 1.0 1.0 -1.0 -1.0], [-1.0 -1.0 1.0 1.0 -1.0], 'red');
 %! xlim ([-2.0 2.0]);
 %! ylim ([-2.0 2.0]);
-%! colorbar ("SouthOutside");
-%! title ("Test script for some plot functions");
+%! colorbar ('SouthOutside');
+%! title ('Test script for some plot functions');
 
 ##hold on
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1],"black");
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 3);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ##hold off
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1],"black");
-%!   hold off
+%!   hold off;
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/isfigure.m b/scripts/plot/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/isfigure.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -185,20 +185,26 @@ function varargout = isosurface(varargin
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
     otherwise
       print_usage ();
   endswitch
 
 endfunction
 
 
+%!demo
+%! clf;
+%! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
+%! v = x.^2 + y.^2 + z.^2;
+%! isosurface (x, y, z, v, 1);
+
 %!shared x, y, z, val
-%!  [x, y, z]  = meshgrid (0:1, 0:1, 0:1); ## Points for single
-%!  val        = [0, 0; 0, 0];             ## cube and a 3--dim
-%!  val(:,:,2) = [0, 0; 1, 0];             ## array of values
+%!  [x, y, z]  = meshgrid (0:1, 0:1, 0:1); %% Points for single
+%!  val        = [0, 0; 0, 0];             %% cube and a 3-D
+%!  val(:,:,2) = [0, 0; 1, 0];             %% array of values
 %!test
 %!  fv = isosurface (x, y, z, val, 0.3);
 %!  assert (isfield (fv, "vertices"), true);
 %!  assert (isfield (fv, "faces"), true);
 %!  assert (size (fv.vertices), [3 3]);
 %!  assert (size (fv.faces), [1 3]);
 %!test
 %!  fvc = isosurface (x, y, z, val, .3, y);
@@ -213,13 +219,8 @@ endfunction
 %!  assert (size (f), [1 3]);
 %!  assert (size (v), [3 3]);
 %!test
 %!  [f, v, c] = isosurface (x, y, z, val, .3, y);
 %!  assert (size (f), [1 3]);
 %!  assert (size (v), [3 3]);
 %!  assert (size (c), [3 1]);
 
-%!demo
-%! clf
-%! [x,y,z] = meshgrid(-2:0.5:2, -2:0.5:2, -2:0.5:2);
-%! v = x.^2 + y.^2 + z.^2;
-%! isosurface (x, y, z, v, 1)
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -142,17 +142,17 @@ function [hlegend2, hobjects2, hplot2, t
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
   else
     kids = ca;
     kids (strcmp (get (ca, "tag"), "legend")) = [];
     if (isscalar (kids))
       kids = get(kids, "children")(:);
     else
-      kids = [get(kids, "children"){:}](:);
+      kids = flipud ([get(kids, "children"){:}](:));
     endif
   endif
   nargs = numel (varargin);
   nkids = numel (kids);
 
   orientation = "default";
   position = "default";
   show = "create";
@@ -190,17 +190,17 @@ function [hlegend2, hobjects2, hplot2, t
   switch (orientation)
     case {"vertical", "horizontal","default"}
     otherwise
       error ("legend: unrecognized legend orientation");
   endswitch
 
   ## Validate the position type is valid
   outside = false;
-  inout = findstr (position, "outside");
+  inout = strfind (position, "outside");
   if (! isempty (inout))
     outside = true;
     position = position(1:inout-1);
   else
     outside = false;
   endif
 
   switch (position)
@@ -373,23 +373,25 @@ function [hlegend2, hobjects2, hplot2, t
               hplots = [hplots, kids(k)];
               text_strings = {text_strings{:}, arg};
             endif
 
             if (--k == 0)
               break;
             endif
           elseif (! warned)
-            warned = true;
-            warning ("legend: ignoring extra labels");
+            break;
           endif
         else
           error ("legend: expecting argument to be a character string");
         endif
       endfor
+      if (i < nargs && ! warned)
+        warning ("legend: ignoring extra labels");
+      endif
     else
       k = nkids;
       while (k > 0)
         typ = get (kids(k), "type");
         while (k > 1
                && ! (strcmp (typ, "line") || strcmp (typ, "surface")
                      || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
           typ = get (kids(--k), "type");
@@ -435,17 +437,17 @@ function [hlegend2, hobjects2, hplot2, t
     else
       ## Delete the old legend if it exists
       if (! isempty (hlegend))
         if (strcmp (textpos, "default"))
           textpos = get (hlegend, "textposition");
         endif
         if (strcmp (position, "default"))
           position = get (hlegend, "location");
-          inout = findstr (position, "outside");
+          inout = strfind (position, "outside");
           if (! isempty (inout))
             outside = true;
             position = position(1:inout-1);
           else
             outside = false;
           endif
         endif
         if (strcmp (orientation, "default"))
@@ -811,32 +813,24 @@ function updatelegend (h, d)
       h = legend (hax, hplots, get (h, "string"));
     unwind_protect_cleanup
       recursive = false;
     end_unwind_protect
   endif
 endfunction
 
 function updatelegendtext (h, d)
+  hax = get (h, "userdata").handle;
   kids = get (h, "children");
-  k = numel (kids);
-  in = get (h, "interpreter");
-  tc = get (h, "textcolor");
-  while (k > 0)
-    typ = get (kids(k), "type");
-    while (k > 0 && ! strcmp (typ, "text"))
-      typ = get (kids(--k), "type");
-    endwhile
-    if (k > 0)
-      set (kids (k), "interpreter", in, "color", tc);
-      if (--k == 0)
-        break;
-      endif
-    endif
-  endwhile
+  text_kids = findobj (kids, "-property", "interpreter", "type", "text");
+  interpreter = get (h, "interpreter");
+  textcolor = get (h, "textcolor");
+  set (kids, "interpreter", interpreter, "color", textcolor);
+  hobj = cell2mat (get (kids, "userdata"));
+  set (hobj, "interpreter", interpreter);
 endfunction
 
 function hideshowlegend (h, d, ca, pos1, pos2)
   isvisible = strcmp (get (h, "visible"), "off");
   if (! isvisible)
     kids = get (h, "children");
     for i = 1 : numel (kids)
       if (! strcmp (get (kids(i), "visible"), "off"))
@@ -973,182 +967,221 @@ function updateline (h, d, hlegend, line
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", get (h, "markersize"), "linestyle", "none",
             "userdata", h, "parent", hlegend);
     endif
   endif
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = 0:1;
-%! plot (x, x, ";I am Blue;", x, 2*x, ";I am Green;", x, 3*x, ";I am Red;")
+%! plot (x,x,';I am Blue;', x,2*x,';I am Green;', x,3*x,';I am Red;');
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:1;
-%! plot (x, x, ";I am Blue;", x, 2*x, x, 3*x, ";I am Red;")
-%! title ("Blue and Green keys, with Green mising")
+%! plot (x, x, ';\alpha;',  ...
+%!       x, 2*x, ';\beta=2\alpha;',  ...
+%!       x, 3*x, ';\gamma=3\alpha;');
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("incline is blue and decline is green");
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend hide
-%! legend show
+%! clf;
+%! x = 0:1;
+%! plot (x,x,';I am Blue;', x,2*x, x,3*x,';I am Red;');
+%! title ('Blue and Green keys, with Green missing');
+
+%!demo
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('incline is blue and decline is green');
+%! legend ({'I am blue', 'I am green'}, 'location', 'east');
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend is hidden")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend hide
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('Legend is hidden')
+%! legend ({'I am blue', 'I am green'}, 'location', 'east');
+%! legend hide;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend with box on")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend boxon
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('Legend with box on');
+%! legend ({'I am blue', 'I am green'}, 'location', 'east');
+%! legend boxon;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend with text to the right")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend right
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ('Legend with text to the right');
+%! legend ({'I am blue', 'I am green'}, 'location', 'east');
+%! legend right;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10);
-%! title("a very long label can sometimes cause problems");
-%! legend({"hello world"}, "location", "northeastoutside");
+%! clf;
+%! plot (1:10, 1:10);
+%! title ('a very long label can sometimes cause problems');
+%! legend ({'hello world'}, 'location', 'northeastoutside');
 
 %!demo
-%! clf
-%! plot(1:10, 1:10);
-%! title("a very long label can sometimes cause problems");
-%! legend("hello world", "location", "northeastoutside");
+%! clf;
+%! plot (1:10, 1:10);
+%! title ('a very long label can sometimes cause problems');
+%! legend ('hello world', 'location', 'northeastoutside');
 
 %!demo
-%! clf
+%! clf;
 %! labels = {};
-%! colororder = get (gca, "colororder");
+%! colororder = get (gca, 'colororder');
 %! for i = 1:5
-%!   h = plot(1:100, i + rand(100,1)); hold on;
-%!   set (h, "color", colororder(i,:))
-%!   labels = {labels{:}, cstrcat("Signal ", num2str(i))};
-%! endfor
+%!   h = plot (1:100, i + rand(100,1)); hold on;
+%!   set (h, 'color', colororder(i,:));
+%!   labels = {labels{:}, cstrcat('Signal ', num2str (i))};
+%! end
 %! hold off;
-%! title("Signals with random offset and uniform noise")
-%! xlabel("Sample Nr [k]"); ylabel("Amplitude [V]");
-%! legend(labels, "location", "southoutside");
-%! legend("boxon");
+%! title ('Signals with random offset and uniform noise');
+%! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
+%! legend (labels, 'location', 'southoutside');
+%! legend ('boxon');
 
 %!demo
-%! clf
+%! clf;
 %! labels = {};
-%! colororder = get (gca, "colororder");
+%! colororder = get (gca, 'colororder');
 %! for i = 1:5
-%!   h = plot(1:100, i + rand(100,1)); hold on;
-%!   set (h, "color", colororder(i,:))
-%!   labels = {labels{:}, cstrcat("Signal ", num2str(i))};
-%! endfor
+%!   h = plot (1:100, i + rand (100,1)); hold on;
+%!   set (h, 'color', colororder(i,:));
+%!   labels = {labels{:}, cstrcat('Signal ', num2str (i))};
+%! end
 %! hold off;
-%! title("Signals with random offset and uniform noise")
-%! xlabel("Sample Nr [k]"); ylabel("Amplitude [V]");
-%! legend(labels{:}, "location", "southoutside")
-%! legend("boxon")
+%! title ('Signals with random offset and uniform noise');
+%! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
+%! legend (labels{:}, 'location', 'southoutside');
+%! legend ('boxon');
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x);
-%! hold ("on");
-%! stem (x, x.^2, 'g')
-%! legend ("linear");
-%! hold ("off");
+%! hold on;
+%! stem (x, x.^2, 'g');
+%! legend ('linear');
+%! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
-%! legend ("linear");
+%! legend ('linear');
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
-%! legend ("linear", "quadratic");
+%! legend ('linear', 'quadratic');
 
 %!demo
-%! clf
+%! clf;
 %! rand_2x3_data1 = [0.341447, 0.171220, 0.284370; 0.039773, 0.731725, 0.779382];
 %! bar (rand_2x3_data1);
 %! ylim ([0 1.0]);
-%! legend ({"1st Bar", "2nd Bar", "3rd Bar"});
+%! legend ({'1st Bar', '2nd Bar', '3rd Bar'});
 
 %!demo
-%! clf
+%! clf;
 %! rand_2x3_data2 = [0.44804, 0.84368, 0.23012; 0.72311, 0.58335, 0.90531];
 %! bar (rand_2x3_data2);
 %! ylim ([0 1.2]);
-%! legend ("1st Bar", "2nd Bar", "3rd Bar");
-%! legend right
+%! legend ('1st Bar', '2nd Bar', '3rd Bar');
+%! legend right;
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:7;
-%! h = plot (x, sin(x), x, cos(x), x, sin(x.^2/10), x, cos(x.^2/10));
-%! title ("Only the sin() objects have keylabels");
-%! legend (h([1, 3]), {"sin(x)", "sin(x^2/10)"}, "location", "southwest");
+%! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
+%! title ('Only the sin() objects have keylabels');
+%! legend (h([1, 3]), {'sin(x)', 'sin(x^2/10)'}, 'location', 'southwest');
+
+%!demo
+%! clf;
+%! x = 0:0.1:10;
+%! plot (x, sin(x), ';sin(x);');
+%! hold all;
+%! plot (x, cos(x), ';cos(x);');
+%! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ";sin(x);")
-%! hold all
-%! plot (x, cos(x), ";cos(x);")
-%! hold off
+%! plot (x, sin(x), ';sin(x);');
+%! hold all;
+%! plot (x, cos(x), ';cos(x);');
+%! hold off;
+%! legend ({'sin(x)', 'cos(x)'}, 'location', 'northeastoutside');
 
 %!demo
-%! clf
-%! x = 0:0.1:10;
-%! plot (x, sin(x), ";sin(x);")
-%! hold all
-%! plot (x, cos(x), ";cos(x);")
-%! hold off
-%! legend ({"sin(x)", "cos(x)"}, "location", "northeastoutside")
+%! clf;
+%! x = 0:10;
+%! plot (x, rand (11));
+%! xlabel ('Indices');
+%! ylabel ('Random Values');
+%! title ('Legend ''off'' should delete the legend');
+%! legend (cellstr (num2str ((1:10)')), 'location', 'northeastoutside');
+%! legend off;
+%! axis ([0, 10, 0 1]);
 
 %!demo
-%! clf
-%! x = 0:10;
-%! plot (x, rand (11));
-%! xlabel ("Indices")
-%! ylabel ("Random Values")
-%! title ("Legend ""off"" should delete the legend")
-%! legend (cellstr (num2str ((1:10)')), "location", "northeastoutside")
-%! legend off
-%! axis ([0, 10, 0 1])
+%! clf;
+%! x = (1:5)';
+%! subplot (2, 2, 1);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), 'location', 'northwestoutside');
+%!  legend boxon;
+%! subplot (2, 2, 2);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), 'location', 'northeastoutside');
+%!  legend boxon;
+%! subplot (2, 2, 3);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), 'location', 'southwestoutside');
+%!  legend boxon;
+%! subplot (2, 2, 4);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), 'location', 'southeastoutside');
+%!  legend boxon;
+
+%!demo
+%! clf;
+%! plot (rand (2));
+%! title ('Warn of extra labels');
+%! legend ('Hello', 'World', 'interpreter', 'foobar');
 
 %!demo
-%! clf
-%! x = 0:4;
-%! subplot (2, 2, 1)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str ((1:10)')), "location", "northwestoutside")
-%! legend boxon
-%! subplot (2, 2, 2)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str ((1:10)')), "location", "northeastoutside")
-%! legend boxon
-%! subplot (2, 2, 3);
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str ((1:10)')), "location", "southwestoutside")
-%! legend boxon
-%! subplot (2, 2, 4)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str ((1:10)')), "location", "southeastoutside")
-%! legend boxon
+%! clf;
+%! plot (rand (2));
+%! title ('Turn off TeX interpreter');
+%! h = legend ('Hello_World', 'foo^bar');
+%! set (h, 'interpreter', 'none');
+
+%!demo
+%! x = 0:10;
+%! y1 = rand (size (x));
+%! y2 = rand (size (x));
+%! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! legend ([h1, h2], {'Blue', 'Green'}, 'location', 'south');
 
+%!demo
+%! x = 0:10;
+%! y1 = rand (size (x));
+%! y2 = rand (size (x));
+%! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! legend ({'Blue', 'Green'}, 'location', 'south');
+
+%!demo
+%! x = 0:10;
+%! y1 = rand (size (x));
+%! y2 = rand (size (x));
+%! [ax, h1, h2] = plotyy (x, y1, x, y2);
+%! legend ('Blue', 'Green', 'location', 'south');
+
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} loglog (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} loglog (@dots{})
 ## Produce a two-dimensional plot using log scales for both axes.  See
 ## the documentation of @code{plot} for a description of the arguments
 ## that @code{loglog} will accept.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, semilogy}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
@@ -55,53 +57,54 @@ function retval = loglog (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
 %! y = ((t .* (1 + rand (size (t)))) .^ 2);
 %! loglog (x, y);
 
 %!demo
-%! clf ();
+%! clf;
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! loglog (a, b)
-%! xlabel ('loglog (a, b)')
+%! subplot (1,2,1);
+%!  loglog (a, b);
+%!  xlabel ('loglog (a, b)');
 %!
-%! subplot (1, 2, 2)
-%! loglog (a, abs (b))
-%! set (gca, 'ydir', 'reverse')
-%! xlabel ('loglog (a, abs (b))')
+%! subplot (1,2,2);
+%!  loglog (a, abs (b));
+%!  set (gca, 'ydir', 'reverse');
+%!  xlabel ('loglog (a, abs (b))');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   loglog (a, b)
+%!   loglog (a, b);
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "log");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   loglog (a, b)
-%!   axis tight
+%!   loglog (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -55,16 +55,18 @@ function retval = loglogerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
-%! loglogerr (x, y, eyl, eyu, "#~x-")
-%! xlim (x([1, end]))
+%! loglogerr (x, y, eyl, eyu, '#~x-');
+%! xlim (x([1, end]));
 
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -27,16 +27,19 @@
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ##
 ## The color of the mesh is derived from the @code{colormap}
 ## and the value of @var{z}.  Optionally the color of the mesh can be
 ## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ## @seealso{colormap, contour, meshgrid, surf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = mesh (varargin)
 
   newplot ();
@@ -53,8 +56,12 @@ function h = mesh (varargin)
          "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/meshc.m b/scripts/plot/meshc.m
--- a/scripts/plot/meshc.m
+++ b/scripts/plot/meshc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -51,17 +51,16 @@ plot_PRIVATE_FCN_FILES = \
   plot/private/__tight_eps_bbox__.m \
   plot/private/__uigetdir_fltk__.m \
   plot/private/__uigetfile_fltk__.m \
   plot/private/__uiputfile_fltk__.m \
   plot/private/__uiobject_split_args__.m
 
 plot_FCN_FILES = \
   plot/__gnuplot_drawnow__.m \
-  plot/__go_close_all__.m \
   plot/__plt_get_axis_arg__.m \
   plot/allchild.m \
   plot/ancestor.m \
   plot/area.m \
   plot/axes.m \
   plot/axis.m \
   plot/bar.m \
   plot/barh.m \
@@ -190,16 +189,17 @@ plot_FCN_FILES = \
   plot/uipanel.m \
   plot/uipushtool.m \
   plot/uiputfile.m \
   plot/uiresume.m \
   plot/uitoggletool.m \
   plot/uitoolbar.m \
   plot/uiwait.m \
   plot/view.m \
+  plot/waitbar.m \
   plot/waitforbuttonpress.m \
   plot/whitebg.m \
   plot/xlabel.m \
   plot/xlim.m \
   plot/ylabel.m \
   plot/ylim.m \
   plot/zlabel.m \
   plot/zlim.m \
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Alexander Barth
+## Copyright (C) 2006-2012 Alexander Barth
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2003 Alberto Terruzzi
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -36,24 +36,28 @@
 ## of the result.  Thus, targeting these "major causes" for elimination
 ## results in the most cost-effective improvement scheme.
 ##
 ## The data are passed as @var{x} and the abscissa as @var{y}.  If @var{y} is
 ## absent, then the abscissa are assumed to be @code{1 : length (@var{x})}.
 ## @var{y} can be a string array, a cell array of strings or a numerical
 ## vector.
 ##
+## The optional return value @var{h} is a 2-element vector with a graphics
+## handle for the created bar plot and a second handle for the created line
+## plot.
+##
 ## An example of the use of @code{pareto} is
 ##
 ## @example
 ## @group
 ## Cheese = @{"Cheddar", "Swiss", "Camembert", ...
 ##           "Munster", "Stilton", "Blue"@};
 ## Sold = [105, 30, 70, 10, 15, 20];
-## pareto(Sold, Cheese);
+## pareto (Sold, Cheese);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function h = pareto (varargin)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
@@ -94,23 +98,25 @@ function h = pareto (varargin)
   set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
 
   if (nargout > 0)
     h = [hbar; hline];
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! colormap (jet (64))
-%! Cheese = {"Cheddar", "Swiss", "Camembert", "Munster", "Stilton", "Blue"};
-%! Sold = [105, 30, 70, 10, 15, 20];
-%! pareto(Sold, Cheese);
 
 %!demo
-%! clf
-%! % Suppose that we want establish which products makes 80 % of turnover.
-%! Codes = {"AB4","BD7","CF8","CC5","AD11","BB5","BB3","AD8","DF3","DE7"};
+%! clf;
+%! colormap (jet (64));
+%! Cheese = {'Cheddar', 'Swiss', 'Camembert', 'Munster', 'Stilton', 'Blue'};
+%! Sold = [105, 30, 70, 10, 15, 20];
+%! pareto (Sold, Cheese);
+
+%!demo
+%! clf;
+%! % Suppose that we want establish which products makes 80% of turnover.
+%! Codes = {'AB4','BD7','CF8','CC5','AD11','BB5','BB3','AD8','DF3','DE7'};
 %! Value = [2.35 7.9 2.45 1.1 0.15 13.45 5.4 2.05 0.85  1.65]';
 %! SoldUnits = [54723 41114 16939 1576091 168000 687197 120222 168195, ...
 %!              1084118 55576]';
 %! pareto (Value.*SoldUnits, Codes);
+
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -30,16 +30,20 @@
 ##
 ## For a uniform colored patch, @var{c} can be given as an RGB vector,
 ## scalar value referring to the current colormap, or string value (for
 ## example, "r" or "red").
 ##
 ## If passed a structure @var{fv} contain the fields "vertices", "faces"
 ## and optionally "facevertexcdata", create the patch based on these
 ## properties.
+##
+## The optional return value @var{h} is a graphics handle to the created patch
+## object.
+## @seealso{fill}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = patch (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
 
@@ -50,166 +54,167 @@ function retval = patch (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
-%!demo
-%! ## Patches with same number of vertices
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
-%! patch([x1,x2],[y1,y2],'r');
 
 %!demo
-%! ## Unclosed patch
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
-%! patch([[x1;NaN(8,1)],x2],[[y1;NaN(8,1)],y2],'r');
+%! %% Patches with same number of vertices
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
+%! patch ([x1,x2], [y1,y2], 'r');
+
+%!demo
+%! %% Unclosed patch
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
+%! patch ([[x1;NaN(8,1)],x2], [[y1;NaN(8,1)],y2], 'r');
 
 %!demo
-%! ## Specify vertices and faces separately
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! %% Specify vertices and faces separately
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch('Faces',fac,'Vertices',vert,'FaceColor','r');
+%! patch ('Faces',fac, 'Vertices',vert, 'FaceColor','r');
 
 %!demo
-%! ## Specify vertices and faces separately
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
+%! %% Specify vertices and faces separately
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch('Faces',fac,'Vertices',vert,'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
+%! patch ('Faces',fac, 'Vertices',vert, 'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
 
 %!demo
-%! ## Property change on multiple patches
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
-%! x1 = sin(t1) - 0.8;
-%! y1 = cos(t1);
-%! x2 = sin(t2) + 0.8;
-%! y2 = cos(t2);
-%! h = patch([x1,x2],[y1,y2],cat (3,[0,0],[1,0],[0,1]));
+%! %% Property change on multiple patches
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
+%! x1 = sin (t1) - 0.8;
+%! y1 = cos (t1);
+%! x2 = sin (t2) + 0.8;
+%! y2 = cos (t2);
+%! h = patch ([x1,x2], [y1,y2], cat (3,[0,0],[1,0],[0,1]));
 %! pause (1);
 %! set (h, 'FaceColor', 'r');
 
 %!demo
-%! clf
+%! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch('Vertices', vertices, 'Faces', faces, ...
-%!       'FaceVertexCData', jet(4), 'FaceColor', 'flat')
-%! view (-37.5, 30)
+%! patch ('Vertices', vertices, 'Faces', faces, ...
+%!        'FaceVertexCData', jet (4), 'FaceColor', 'flat');
+%! view (-37.5, 30);
 
 %!demo
-%! clf
+%! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch('Vertices', vertices, 'Faces', faces, ...
-%!       'FaceVertexCData', jet(5), 'FaceColor', 'interp')
-%! view (-37.5, 30)
+%! patch  ('Vertices', vertices, 'Faces', faces, ...
+%!        'FaceVertexCData', jet (5), 'FaceColor', 'interp');
+%! view (-37.5, 30);
 
 %!demo
-%! clf
-%! colormap (jet)
+%! clf;
+%! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1)
-%! title ("Blue, Light-Green, and Red Horizontal Bars")
-%! patch (x, y + 0, 1);
-%! patch (x, y + 1, 2);
-%! patch (x, y + 2, 3);
-%! subplot (2, 1, 2)
-%! title ("Blue, Light-Green, and Red Vertical Bars")
-%! patch (x + 0, y, 1 * ones (size (x)));
-%! patch (x + 1, y, 2 * ones (size (x)));
-%! patch (x + 2, y, 3 * ones (size (x)));
-
-%!demo
-%! clf
-%! colormap (jet)
-%! x = [0 1 1 0];
-%! y = [0 0 1 1];
-%! subplot (2, 1, 1)
-%! title ("Blue horizontal bars: Dark to Light")
-%! patch (x, y + 0, 1, "cdatamapping", "direct");
-%! patch (x, y + 1, 9, "cdatamapping", "direct");
-%! patch (x, y + 2, 17, "cdatamapping", "direct");
-%! subplot (2, 1, 2)
-%! title ("Blue vertical bars: Dark to Light")
-%! patch (x + 0, y, 1 * ones (size (x)), "cdatamapping", "direct");
-%! patch (x + 1, y, 9 * ones (size (x)), "cdatamapping", "direct");
-%! patch (x + 2, y, 17 * ones (size (x)), "cdatamapping", "direct");
+%! subplot (2, 1, 1);
+%!  title ('Blue, Light-Green, and Red Horizontal Bars');
+%!  patch (x, y + 0, 1);
+%!  patch (x, y + 1, 2);
+%!  patch (x, y + 2, 3);
+%! subplot (2, 1, 2);
+%!  title ('Blue, Light-Green, and Red Vertical Bars');
+%!  patch (x + 0, y, 1 * ones (size (x)));
+%!  patch (x + 1, y, 2 * ones (size (x)));
+%!  patch (x + 2, y, 3 * ones (size (x)));
 
 %!demo
 %! clf;
-%! colormap (jet);
-%! x = [ 0 0; 1 1; 1 0 ];
-%! y = [ 0 0; 0 1; 1 1 ];
-%! p = patch (x, y, "facecolor", "b");
-%! title ("Two blue triangles")
-%! set (p, "cdatamapping", "direct", "facecolor", "flat", "cdata", [1 32])
-%! title ("Direct mapping of colors: Light-Green UL and Blue LR triangles")
+%! colormap (jet (64));
+%! x = [0 1 1 0];
+%! y = [0 0 1 1];
+%! subplot (2, 1, 1);
+%!  title ('Blue horizontal bars: Dark to Light');
+%!  patch (x, y + 0, 1, 'cdatamapping', 'direct');
+%!  patch (x, y + 1, 9, 'cdatamapping', 'direct');
+%!  patch (x, y + 2, 17, 'cdatamapping', 'direct');
+%! subplot (2, 1, 2);
+%!  title ('Blue vertical bars: Dark to Light');
+%!  patch (x + 0, y, 1 * ones (size (x)), 'cdatamapping', 'direct');
+%!  patch (x + 1, y, 9 * ones (size (x)), 'cdatamapping', 'direct');
+%!  patch (x + 2, y, 17 * ones (size (x)), 'cdatamapping', 'direct');
 
 %!demo
 %! clf;
-%! colormap (jet);
+%! colormap (jet (64));
+%! x = [ 0 0; 1 1; 1 0 ];
+%! y = [ 0 0; 0 1; 1 1 ];
+%! p = patch (x, y, 'facecolor', 'b');
+%! title ('Two blue triangles');
+%! set (p, 'cdatamapping', 'direct', 'facecolor', 'flat', 'cdata', [1 32]);
+%! title ('Direct mapping of colors: Light-Green UL and Blue LR triangles');
+
+%!demo
+%! clf;
+%! colormap (jet (64));
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, [1 32]);
-%! title ("Autoscaling of colors: Red UL and Blue LR triangles")
+%! title ('Autoscaling of colors: Red UL and Blue LR triangles');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   h = patch;
+%!   h = patch ();
 %!   assert (findobj (hf, "type", "patch"), h);
 %!   assert (get (h, "xdata"), [0; 1; 0], eps);
 %!   assert (get (h, "ydata"), [1; 1; 0], eps);
-%!   assert (isempty(get (h, "zdata")));
-%!   assert (isempty(get (h, "cdata")));
+%!   assert (isempty (get (h, "zdata")));
+%!   assert (isempty (get (h, "cdata")));
 %!   assert (get (h, "faces"), [1, 2, 3], eps);
 %!   assert (get (h, "vertices"), [0 1; 1 1; 0 0], eps);
 %!   assert (get (h, "type"), "patch");
 %!   assert (get (h, "facecolor"), [0 0 0]);
 %!   assert (get (h, "linestyle"), get (0, "defaultpatchlinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultpatchlinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultpatchmarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultpatchmarkersize"));
@@ -223,8 +228,9 @@ endfunction
 %! unwind_protect
 %!   h = patch ([0 1 0], [0 1 1], c);
 %!   assert (get (gca, "clim"), [c - 1, c + 1]);
 %!   h = patch ([0 1 0], [0 1 1], 2 * c);
 %!   assert (get (gca, "clim"), [c, 2 * c]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/pbaspect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -84,30 +84,31 @@ function varargout = pbaspect (varargin)
   if (nargout == 1)
     varargout{1} = get (hax, "plotboxaspectratio");
   elseif (nargout > 1)
     error ("pbaspect: only one output is allowed");
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! pbaspect ([1 1 1])
-%! title ("plot box should be square")
+%! plot (x,cos(x), x,sin(x));
+%! pbaspect ([1 1 1]);
+%! title ('plot box is square');
 
 %!demo
-%! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! pbaspect ([2 1 1])
-%! title ("plot box aspect ratio should be 2x1")
+%! clf;
+%! x = 0:0.01:4;;
+%! plot (x,cos(x), x,sin(x));
+%! pbaspect ([2 1 1]);
+%! title ('plot box aspect ratio is 2x1');
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! daspect ([1 1 1])
-%! pbaspect ([2 1 1])
-%! title ("plot box should be 2x1, and axes [0 4 -1 1]")
+%! plot (x,cos(x), x,sin(x));
+%! daspect ([1 1 1]);
+%! pbaspect ([2 1 1]);
+%! title ('plot box is 2x1, and axes [0 4 -1 1]');
 
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -76,18 +76,23 @@ function h = pcolor (x, y, c)
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! [~,~,Z]=peaks;
-%! pcolor(Z);
+%! clf;
+%! colormap ('default');
+%! [~,~,Z] = peaks ();
+%! pcolor (Z);
 
 %!demo
-%! [X,Y,Z]=sombrero;
-%! [Fx,Fy] = gradient(Z);
-%! pcolor(X,Y,Fx+Fy);
+%! clf;
+%! colormap ('default');
+%! [X,Y,Z] = sombrero ();
+%! [Fx,Fy] = gradient (Z);
+%! pcolor (X,Y,Fx+Fy);
 %! shading interp;
+
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Paul Kienzle
+## Copyright (C) 2007-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,29 +17,30 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie (@var{x})
 ## @deftypefnx {Function File} {} pie (@var{x}, @var{explode})
 ## @deftypefnx {Function File} {} pie (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie (@var{h}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
-## Produce a pie chart.
+## Produce a 2-D pie chart.
 ##
 ## Called with a single vector argument, produces a pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
-## The optional return value @var{h} provides a handle to the patch object.
+## The optional return value @var{h} is a list of handles to the patch
+## and text objects generating the plot.
 ##
 ## @seealso{pie3, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie (varargin)
@@ -60,22 +61,27 @@ function retval = pie (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
-%!demo
-%! pie ([3, 2, 1], [0, 0, 1]);
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
-%! pie ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! clf;
+%! pie ([3, 2, 1], [0, 0, 1]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+
+%!demo
+%! clf;
+%! pie ([3, 2, 1], [0, 0, 1], {'Cheddar', 'Swiss', 'Camembert'});
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
-%! pie ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! clf;
+%! pie ([0.17, 0.34, 0.41], {'Cheddar', 'Swiss', 'Camembert'});
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
-%! title ("missing slice");
\ No newline at end of file
+%! title ('missing slice');
+
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -30,18 +30,18 @@
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
-## The optional return value @var{h} provides a handle list to patch, surface
-## and text objects generating this plot.
+## The optional return value @var{h} is a list of graphics handles to the patch,
+## surface, and text objects generating the plot.
 ##
 ## @seealso{pie, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie3 (varargin)
@@ -62,22 +62,27 @@ function retval = pie3 (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
-%!demo
-%! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
-%! pie3 ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! clf;
+%! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+
+%!demo
+%! clf;
+%! pie3 ([3, 2, 1], [0, 0, 1], {'Cheddar', 'Swiss', 'Camembert'});
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
-%! pie3 ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
-%! colormap([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! clf;
+%! pie3 ([0.17, 0.34, 0.41], {'Cheddar', 'Swiss', 'Camembert'});
+%! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
-%! title ("missing slice");
+%! title ('missing slice');
+
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -168,16 +168,18 @@
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ##
 ## If the first argument is an axis handle, then plot into these axes,
 ## rather than the current axis handle returned by @code{gca}.
 ##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
 ## stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
@@ -196,8 +198,12 @@ function retval = plot (varargin)
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
+
+
+%% FIXME: Need demo or test for function
+
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -165,16 +165,18 @@ function retval = plot3 (varargin)
           [x, y] = meshgrid (x, y);
         else
           error ("plot3: [length(x), length(y)] must match size(z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
+      elseif (ndims (x) > 2)
+        error ("plot3: x, y, and z must not have more than two dimensions");
       endif
 
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
         if (isempty (marker) && isempty (linestyle))
            [linestyle, marker] = __next_line_style__ ();
         endif
@@ -217,16 +219,18 @@ function retval = plot3 (varargin)
           [x, y] = meshgrid (x, y);
         else
           error ("plot3: [length(x), length(y)] must match size(z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
+      elseif (ndims (x) > 2)
+        error ("plot3: x, y, and z must not have more than two dimensions");
       endif
 
       options =  __default_plot_options__ ();
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
         if (isempty (marker) && isempty (linestyle))
            [linestyle, marker] = __next_line_style__ ();
@@ -289,16 +293,18 @@ function retval = plot3 (varargin)
         [x, y] = meshgrid (x, y);
       else
         error ("plot3: [length(x), length(y)] must match size(z)");
       endif
     endif
 
     if (! size_equal (x, y, z))
       error ("plot3: x, y, and z must have the same shape");
+    elseif (ndims (x) > 2)
+      error ("plot3: x, y, and z must not have more than two dimensions");
     endif
 
     options =  __default_plot_options__ ();
 
     for i = 1 : columns (x)
       linestyle = options.linestyle;
       marker = options.marker;
       if (isempty (marker) && isempty (linestyle))
@@ -327,12 +333,15 @@ function retval = plot3 (varargin)
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! z = [0:0.05:5];
-%! plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
-%! plot3 (z, exp(2i*pi*z), ";complex sinusoid;");
+%! plot3 (cos(2*pi*z), sin(2*pi*z), z, ';helix;');
+%! plot3 (z, exp(2i*pi*z), ';complex sinusoid;');
+
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -91,17 +91,18 @@ function [h, ax, bigax, p, pax] = plotma
       set (bigax2, "visible", "off");
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   endif
 endfunction
 
 %!demo
-%! plotmatrix (randn (100, 3), 'g+')
+%! clf;
+%! plotmatrix (randn (100, 3), 'g+');
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
     if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
         && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -221,53 +221,54 @@ function [ax, h1, h2] = __plotyy__ (ax, 
     addproperty ("__plotyy_axes__", ax(2), "data", ax);
   elseif (ishandle (ax(2)))
     set (ax(2), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen. File a bug report.")
   endif
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
-%! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
-%! xlabel ("X");
-%! ylabel (ax(1), "Axis 1");
-%! ylabel (ax(2), "Axis 2");
-%! axes (ax(1))
-%! text (0.5, 0.5, "Left Axis", ...
-%!       "color", [0 0 1], "horizontalalignment", "center")
-%! axes (ax(2))
-%! text (4.5, 80, "Right Axis", ...
-%!       "color", [0 0.5 0], "horizontalalignment", "center")
+%! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
+%! xlabel ('X');
+%! ylabel (ax(1), 'Axis 1');
+%! ylabel (ax(2), 'Axis 2');
+%! axes (ax(1));
+%! text (0.5, 0.5, 'Left Axis', ...
+%!       'color', [0 0 1], 'horizontalalignment', 'center');
+%! axes (ax(2));
+%! text (4.5, 80, 'Right Axis', ...
+%!       'color', [0 0.5 0], 'horizontalalignment', 'center');
 
 %!demo
-%! clf
+%! clf;
+%! colormap ('default');
 %! x = linspace (-1, 1, 201);
-%! subplot (2, 2, 1)
-%! plotyy (x, sin(pi*x), x, 10*cos(pi*x))
-%! subplot (2, 2, 2)
-%! surf (peaks (25))
-%! subplot (2, 2, 3)
-%! contour (peaks (25))
-%! subplot (2, 2, 4)
-%! plotyy (x, 10*sin(2*pi*x), x, cos(2*pi*x))
-%! axis square
+%! subplot (2,2,1);
+%!  plotyy (x,sin(pi*x), x,10*cos(pi*x));
+%! subplot (2,2,2);
+%!  surf (peaks (25));
+%! subplot (2,2,3);
+%!  contour (peaks (25));
+%! subplot (2,2,4);
+%!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
+%! axis square;
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (-1, 1, 201);
-%! subplot (1, 1, 1);
 %! hax = plotyy (x, sin(pi*x), x, cos(pi*x));
-%! ylabel ("Blue and on the Left")
-%! ylabel (hax(2), "Green and on the Right")
-%! xlabel ("xlabel")
+%! ylabel ('Blue on the Left');
+%! ylabel (hax(2), 'Green on the Right');
+%! xlabel ('xlabel');
 
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -16,20 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polar (@var{theta}, @var{rho})
 ## @deftypefnx {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## @deftypefnx {Function File} {} polar (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} polar (@dots{})
-## Make a two-dimensional plot given the polar coordinates @var{theta} and
+## Create a two-dimensional plot from polar coordinates @var{theta} and
 ## @var{rho}.
 ##
-## The optional third argument specifies the line type.
+## The optional argument @var{fmt} specifies the line format.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
@@ -209,17 +212,19 @@ function retval = __plr2__ (h, theta, rh
   else
     error ("__plr2__: invalid data for plotting");
   endif
 
 endfunction
 
 
 %!demo
-%! theta = linspace (0, 2*pi, 1000);
+%! clf;
+%! theta = linspace (0,2*pi,1000);
 %! rho = sin (7*theta);
 %! polar (theta, rho);
 
 %!demo
-%! theta = linspace (0, 10*pi, 1000);
+%! clf;
+%! theta = linspace (0,10*pi,1000);
 %! rho = sin (5/4*theta);
 %! polar (theta, rho);
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -365,16 +365,20 @@ function print (varargin)
         set (h(ishandle(h)), "fontname", opts.font);
       endif
       if (! isempty (opts.fontsize))
         if (ischar (opts.fontsize))
           fontsize = str2double (opts.fontsize);
         else
           fontsize = opts.fontsize;
         endif
+        if (! isempty (opts.scalefontsize) && ! opt.scalefontsize != 1)
+          ## This is done to work around the bbox being whole numbers.
+          fontsize = fontsize * opts.scalefontsize;
+        endif
         set (h(ishandle(h)), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphcis toolkit print script
     switch (get (opts.figure, "__graphics_toolkit__"))
     case "gnuplot"
       opts = __gnuplot_print__ (opts);
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__add_default_menu__.m b/scripts/plot/private/__add_default_menu__.m
--- a/scripts/plot/private/__add_default_menu__.m
+++ b/scripts/plot/private/__add_default_menu__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__axes_limits__.m b/scripts/plot/private/__axes_limits__.m
--- a/scripts/plot/private/__axes_limits__.m
+++ b/scripts/plot/private/__axes_limits__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__color_str_rgb__.m b/scripts/plot/private/__color_str_rgb__.m
--- a/scripts/plot/private/__color_str_rgb__.m
+++ b/scripts/plot/private/__color_str_rgb__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__default_plot_options__.m b/scripts/plot/private/__default_plot_options__.m
--- a/scripts/plot/private/__default_plot_options__.m
+++ b/scripts/plot/private/__default_plot_options__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/private/__errcomm__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Teemu Ikonen
+## Copyright (C) 2001-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -112,20 +112,20 @@ function [h, needusage] = __ezplot__ (pf
       xarg = "";
       yarg = "";
     else
       xarg = argnames(fun)(1);
       yarg = argnames(fun)(2);
     endif
   elseif (isa (fun, "function_handle"))
     fstr = func2str (fun);
-    if (length (findstr (fstr, ")")) != 0)
-      args = regexp (substr (fstr, 3, findstr (fstr, ")")(1) - 3),
+    if (! isempty (strfind (fstr, ')')))
+      args = regexp (substr (fstr, 3, strfind (fstr, ')')(1) - 3),
                      '(\w+)', 'tokens');
-    fstr = substr (fstr, findstr (fstr, ")")(1) + 1);
+    fstr = substr (fstr, strfind (fstr, ')')(1) + 1);
     else
       args = {{"x"}};
     endif
     if (isplot && length (args) == 2)
       nargs = 2;
     elseif (length (args) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
@@ -170,20 +170,20 @@ function [h, needusage] = __ezplot__ (pf
       if (length (argnames (funy)) != nargs)
         error ("%s: excepting a function of %d arguments", func, nargs);
       endif
       funy = vectorize (funy);
       fstry = formula (funy);
     elseif (isa (funy, "function_handle"))
       parametric = true;
       fstry = func2str (funy);
-      if (length (findstr (fstry, ")")) != 0)
-        args = regexp (substr (fstry, 3, findstr (fstry, ")")(1) - 3),
+      if (! isempty (strfind (fstry, ')')))
+        args = regexp (substr (fstry, 3, strfind (fstry, ')')(1) - 3),
                        '(\w+)', 'tokens');
-        fstry = substr (fstry, findstr (fstry, ")")(1) + 1);
+        fstry = substr (fstry, strfind (fstry, ')')(1) + 1);
       else
         args = {{"y"}};
       endif
       if (length (args) != nargs)
         error ("%s: excepting a function of %d arguments", func, nargs);
       endif
     endif
 
@@ -211,22 +211,22 @@ function [h, needusage] = __ezplot__ (pf
       elseif (strcmp (typeinfo (funz), "inline function"))
         if (length (argnames (funz)) != nargs)
           error ("%s: excepting a function of %d arguments", func, nargs);
         endif
         funz = vectorize (funz);
         fstrz = formula (funz);
       elseif (isa (funz, "function_handle"))
         fstrz = func2str (funz);
-        args = regexp (substr (fstrz, 3, findstr (fstrz, ")")(1) - 3),
+        args = regexp (substr (fstrz, 3, strfind (fstrz, ')')(1) - 3),
                        '(\w+)', 'tokens');
         if (length (args) != nargs)
           error ("%s: excepting a function of %d arguments", func, nargs);
         endif
-        fstrz = substr (fstrz, findstr (fstrz, ")")(1) + 1);
+        fstrz = substr (fstrz, strfind (fstrz, ')')(1) + 1);
       else
         error ("%s: parametric plots expect 3 functions", func);
       endif
     endif
   endif
 
   if (isplot && nargs != 2)
     n = 500;
diff --git a/scripts/plot/private/__file_filter__.m b/scripts/plot/private/__file_filter__.m
--- a/scripts/plot/private/__file_filter__.m
+++ b/scripts/plot/private/__file_filter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_file_filter__.m b/scripts/plot/private/__fltk_file_filter__.m
--- a/scripts/plot/private/__fltk_file_filter__.m
+++ b/scripts/plot/private/__fltk_file_filter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_ginput__.m b/scripts/plot/private/__fltk_ginput__.m
--- a/scripts/plot/private/__fltk_ginput__.m
+++ b/scripts/plot/private/__fltk_ginput__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Shai Ayal
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Shai Ayal
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -47,25 +47,27 @@ function opts = __fltk_print__ (opts)
   case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
         "pslatexstandalone", "pdflatexstandalone"}
     ## format GL2PS_TEX
     n = find (opts.devopt == "l", 1);
     suffix = opts.devopt(1:n-1);
     dot = find (opts.name == ".", 1, "last");
     if ((! isempty (dot))
         && any (strcmpi (opts.name(dot:end), ...
-                {".eps", ".ps", ".pdf", ".tex", "."})))
+                {strcat(".", suffix), ".tex", "."})))
       name = opts.name(1:dot-1);
       if (dot < numel (opts.name)
           && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
         ## If user provides eps/ps/pdf suffix, use it.
         suffix = opts.name(dot+1:end);
       endif
-    elseif (dot == numel (opts.name))
-      name = opts.name;
+    else
+      error ("print:invalid-suffix", 
+             "invalid suffix `%s' for device `%s'.",
+             opts.name(dot:end), lower (opts.devopt));
     endif
     gl2ps_device = {sprintf("%snotxt", lower (suffix))};
     gl2ps_device{2} = "tex";
     if (dos_shell)
       ## FIXME - this will only work on MinGW with the MSYS shell
       pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
       pipeline{2} = sprintf ("cat > %s.tex", name);
     else
diff --git a/scripts/plot/private/__getlegenddata__.m b/scripts/plot/private/__getlegenddata__.m
--- a/scripts/plot/private/__getlegenddata__.m
+++ b/scripts/plot/private/__getlegenddata__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/private/__gnuplot_get_var__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_ginput__.m b/scripts/plot/private/__gnuplot_ginput__.m
--- a/scripts/plot/private/__gnuplot_ginput__.m
+++ b/scripts/plot/private/__gnuplot_ginput__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Petr Mikulik
+## Copyright (C) 2004-2012 Petr Mikulik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
--- a/scripts/plot/private/__gnuplot_has_feature__.m
+++ b/scripts/plot/private/__gnuplot_has_feature__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/private/__gnuplot_has_terminal__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_open_stream__.m b/scripts/plot/private/__gnuplot_open_stream__.m
--- a/scripts/plot/private/__gnuplot_open_stream__.m
+++ b/scripts/plot/private/__gnuplot_open_stream__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Ben Abbott
+## Copyright (C) 2009-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Daniel Heiserer
+## Copyright (C) 1999-2012 Daniel Heiserer
 ## Copyright (C) 2001 Laurent Mazet
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -64,20 +64,26 @@ function opts = __gnuplot_print__ (opts)
       pipeline = {sprintf("%s %s",
                           opts.epstool_cmd (opts, tmp_file, opts.name),
                           cleanup)};
     else
       eps_drawnow (opts, opts.name, gp_opts);
     endif
   case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
     dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end),
-                {".eps", ".ps", ".pdf", ".tex", "."})))
-      name = opts.name(1:dot-1);
+    n = find (opts.devopt == "l", 1);
+    suffix = opts.devopt(1:n-1);
+    if (! isempty (dot))
+      if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
+        name = opts.name(1:dot-1);
+      else
+        error ("print:invalid-suffix", 
+               "invalid suffix `%s' for device `%s'.",
+               opts.name(dot:end), lower (opts.devopt));
+      endif
     endif
     if (strfind (opts.devopt, "standalone"))
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
diff --git a/scripts/plot/private/__gnuplot_version__.m b/scripts/plot/private/__gnuplot_version__.m
--- a/scripts/plot/private/__gnuplot_version__.m
+++ b/scripts/plot/private/__gnuplot_version__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Daniel Sebald
+## Copyright (C) 2006-2012 Daniel Sebald
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -436,28 +436,29 @@ function __go_draw_axes__ (h, plot_strea
     addedcmap = [];
 
     ximg_data = {};
     ximg_data_idx = 0;
 
     while (! isempty (kids))
 
       obj = get (kids(end));
+
       if (isfield (obj, "units"))
         units = obj.units;
         unwind_protect
           set (kids(end), "units", "data");
           obj = get (kids(end));
         unwind_protect_cleanup
           set (kids(end), "units", units);
         end_unwind_protect
       endif
       kids = kids(1:(end-1));
 
-      if (strcmpi (obj.visible, "off"))
+      if (strcmp (obj.visible, "off"))
         continue;
       endif
 
       if (xlogscale && isfield (obj, "xdata"))
         obj.xdata = axis_obj.xsgn * obj.xdata;
         obj.xdata(obj.xdata<=0) = NaN;
       endif
       if (ylogscale && isfield (obj, "ydata"))
@@ -689,20 +690,21 @@ function __go_draw_axes__ (h, plot_strea
                                || size (obj.cdata, 2) == 3)))
                      ccol = cdat (i, :);
                    elseif (ndims (obj.cdata) == 3)
                      ccol = permute (cdat (:, i, :), [1, 3, 2]);
                    else
                      ccol = cdat;
                    endif
                    if (strncmp (obj.facecolor, "flat", 4))
-                     if (numel(ccol) == 3)
+                     if (isequal (size (ccol), [1, 3]))
+                       ## RGB Triplet
                        color = ccol;
                      elseif (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol * ones (3,1);
+                       ccdat = ccol;
                      else
                        if (cdatadirect)
                          r = round (ccol);
                        else
                          r = 1 + round ((size (cmap, 1) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
                        r = max (1, min (r, size (cmap, 1)));
@@ -1537,17 +1539,17 @@ function __go_draw_axes__ (h, plot_strea
         reverse = "reverse";
       else
         reverse = "noreverse";
       endif
       inout = "inside";
       keypos = hlgnd.location;
       if (ischar (keypos))
         keypos = lower (keypos);
-        keyout = findstr (keypos, "outside");
+        keyout = strfind (keypos, "outside");
         if (! isempty (keyout))
           inout = "outside";
           keypos = keypos(1:keyout-1);
         endif
       endif
       switch (keypos)
         case "north"
           pos = "center top";
@@ -2199,17 +2201,16 @@ endfunction
 
 function ticklabel = ticklabel_to_cell (ticklabel)
   if (isnumeric (ticklabel))
     ## Use upto 5 significant digits
     ticklabel = num2str (ticklabel(:), 5);
   endif
   if (ischar (ticklabel))
     if (size (ticklabel, 1) == 1 && any (ticklabel == "|"))
-      n = setdiff (findstr (ticklabel, "|"), findstr (ticklabel, '\|'));
       ticklabel = strsplit (ticklabel, "|");
     else
       ticklabel = cellstr (ticklabel);
     endif
   elseif (isempty (ticklabel))
     ticklabel = {""};
   else
     ticklabel = ticklabel;
@@ -2297,20 +2298,48 @@ function [str, f, s] = __maybe_munge_tex
       else
         str = __tex2enhanced__ (str, fnt, it, bld);
       endif
     elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
         warning ("latex markup not supported for text objects");
         warned_latex = true;
       endif
+    elseif (enhanced)
+      str = no_super_sub_scripts (str);
     endif
   endif
 endfunction
 
+function str = no_super_sub_scripts (str)
+  if (iscellstr (str))
+    labels = str;
+  else
+    labels = cellstr (str);
+  endif
+  for marker = "_^" 
+    for m = 1 : numel(labels)
+      n1 = strfind (labels{m}, sprintf ("\\%s", marker));
+      n2 = strfind (labels{m}, marker);
+      if (! isempty (n1))
+        n1 = n1 + 1;
+        n2 = setdiff (n2, n1);
+      end
+      for n = numel(n2):-1:1
+        labels{m} = [labels{m}(1:n2(n)-1), "\\", labels{m}(n2(n):end)]
+      endfor
+    endfor
+  endfor
+  if (iscellstr (str))
+    str = labels;
+  else
+    str = char (labels);
+  endif
+endfunction
+
 function str = __tex2enhanced__ (str, fnt, it, bld)
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
   [s, e, m] = regexp(str,'\\([a-zA-Z]+|0)','start','end','matches');
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__is_function__.m b/scripts/plot/private/__is_function__.m
--- a/scripts/plot/private/__is_function__.m
+++ b/scripts/plot/private/__is_function__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__line__.m b/scripts/plot/private/__line__.m
--- a/scripts/plot/private/__line__.m
+++ b/scripts/plot/private/__line__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Martin Helm
+## Copyright (C) 2009-2012 Martin Helm
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__next_line_color__.m b/scripts/plot/private/__next_line_color__.m
--- a/scripts/plot/private/__next_line_color__.m
+++ b/scripts/plot/private/__next_line_color__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__next_line_style__.m b/scripts/plot/private/__next_line_style__.m
--- a/scripts/plot/private/__next_line_style__.m
+++ b/scripts/plot/private/__next_line_style__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton, Shai Ayal, Kai Habel
+## Copyright (C) 2007-2012 John W. Eaton, Shai Ayal, Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -24,16 +24,17 @@
 ## __patch__ (p, x, y, c)
 ## Create patch object from x and y with color c and parent p.
 ## Return handle to patch object.
 
 ## Author: Kai Habel
 
 function [h, failed] = __patch__ (p, varargin)
 
+  h = NaN;
   failed = false;
 
   is_numeric_arg = cellfun (@isnumeric, varargin);
 
   if (isempty (varargin))
     args = {"xdata", [0; 1; 0], "ydata", [1; 1; 0], "facecolor", [0, 0, 0]};
     args = setvertexdata (args);
   elseif (isstruct (varargin{1}))
@@ -123,21 +124,39 @@ function [h, failed] = __patch__ (p, var
           elseif (isnumeric (c))
             args{7} = "facecolor";
             args{8} = "flat";
             args{9} = "cdata";
             args{10} = c;
           else
             error ("patch: color value not valid");
           endif
-        elseif (size (c, ndims (c)) == 3)
+        elseif (isvector (c) && numel (c) == 3)
           args{7} = "facecolor";
           args{8} = c;
           args{9} = "cdata";
           args{10} = [];
+        elseif (ndims (c) == 3 && size (c, 3) == 3)
+          ## CDATA is specified as RGB data
+          if ((size (c, 1) == 1 && size (c, 2) == 1) ...
+              || (size (c, 1) == 1 && size (c, 2) == columns (x)))
+            ## Single patch color or per-face color
+            args{7} = "facecolor";
+            args{8} = "flat";
+            args{9} = "cdata";
+            args{10} = c;
+          elseif (size (c, 1) == rows (x) && size (c, 2) == columns (x))
+            ## Per-vertex color
+            args{7} = "facecolor";
+            args{8} = "interp";
+            args{9} = "cdata";
+            agrs{10} = c;
+          else
+            error ("patch: color value not valid");
+          endif
         else
           ## Color Vectors
           if (isempty (c))
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
             args{10} = [];
           elseif (isequal (size (c), size (x)) && isequal (size (c), size (y)))
@@ -226,21 +245,18 @@ function args = setdata (args)
   idx = find (strcmpi (args, "facecolor"), 1, "last") + 1;
   if (isempty(idx) || idx > nargs)
     if (!isempty (fvc))
       fc = "flat";
     else
       fc = [0, 1, 0];
     endif
     args = {"facecolor", fc, args{:}};
-  else
-    fc = args {idx};
   endif
 
-  nr = size (faces, 2);
   nc = size (faces, 1);
   idx = faces .';
   t1 = isnan (idx);
   for i = find (any (t1))
     first_idx_in_column = find (t1(:,i), 1);
     idx(first_idx_in_column:end,i) = idx(first_idx_in_column-1,i);
   endfor
   x = reshape (vert(:,1)(idx), size (idx));
@@ -253,18 +269,20 @@ function args = setdata (args)
 
   if (size(fvc, 1) == nc || size (fvc, 1) == 1)
     c = reshape (fvc, [1, size(fvc)]);
   else
     if (size(fvc, 2) == 3)
       c = cat(3, reshape (fvc(idx, 1), size(idx)),
               reshape (fvc(idx, 2), size(idx)),
               reshape (fvc(idx, 3), size(idx)));
-    else
+    elseif (isempty (fvc))
       c = [];
+    else ## if (size (fvc, 2) == 1)
+      c = permute (fvc(faces), [2, 1]);
     endif
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
 function args = setvertexdata (args)
   args = delfields (args, {"vertices", "faces", "facevertexcdata"});
   ## Remove the readonly fields as well
@@ -297,35 +315,35 @@ function args = setvertexdata (args)
   idx = find (strcmpi (args, "facecolor"), 1, "last") + 1;
   if (isempty(idx) || idx > nargs)
     if (!isempty (c))
       fc = "flat";
     else
       fc = [0, 1, 0];
     endif
     args = {"facecolor", fc, args{:}};
-  else
-    fc = args {idx};
   endif
 
   [nr, nc] = size (x);
+  if (nr == 1 && nc > 1)
+    nr = nc;
+    nc = 1;
+  end
   if (!isempty (z))
     vert = [x(:), y(:), z(:)];
   else
     vert = [x(:), y(:)];
   endif
-  faces = reshape (1:numel(x), rows (x), columns (x));
+  faces = reshape (1:numel(x), nr, nc);
   faces = faces';
 
   if (ndims (c) == 3)
     fvc = reshape (c, size (c, 1) * size (c, 2), size(c, 3));
-  elseif (isvector (c))
+  else
     fvc = c(:);
-  else
-    fvc = c.'(:);
   endif
 
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
   update_handle (h, false);
 endfunction
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ## Copyright (C) 2010 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -201,17 +201,17 @@ function [options, valid] = __pltopt1__ 
         options.color = [0, 1, 1];
       elseif (topt == "w" || topt == "6")
         options.color = [1, 1, 1];
       elseif (isspace (topt))
         ## Do nothing.
       elseif (topt == ";")
         t = index (opt(2:end), ";");
         if (t)
-          options.key = undo_string_escapes (opt(2:t));
+          options.key = opt(2:t);
           n = t+1;
         else
           if (err_on_invalid)
             error ("%s: unfinished key label", caller);
           else
             valid = false;
             options = __default_plot_options__ ();
             return;
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2010-2012 Shai Ayal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,37 +12,36 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{x}, @var{y}, @var{buttons}] =} ginput (@var{n})
-## Return which mouse buttons were pressed and keys were hit on the current
-## figure.  If @var{n} is defined, then wait for @var{n} mouse clicks
-## before returning.  If @var{n} is not defined, then @code{ginput} will
-## loop until the return key is pressed.
+## @deftypefn {Function File} {@var{args} =} __print_parse_opts__ (@var{propname}, @var{propvalue})
+## @deftypefnx {Function File} {@var{args} =} __print_parse_opts__ (@var{struct})
+## Undocumented internal function.
 ## @end deftypefn
 
 function arg_st = __print_parse_opts__ (varargin)
 
   persistent warn_on_missing_binary = true
 
   arg_st.append_to_file = false;
   arg_st.canvas_size = [];
   arg_st.debug = false;
   arg_st.debug_file = "octave-print-commands.log";
   arg_st.devopt = "";
   arg_st.epstool_binary = __quote_path__ (__find_binary__ ("epstool"));
   arg_st.figure = get (0, "currentfigure");
   arg_st.fig2dev_binary = __quote_path__ (__find_binary__ ("fig2dev"));
   arg_st.fontsize = "";
   arg_st.font = "";
+  arg_st.scalefontsize = 1;
   arg_st.force_solid = 0; # 0=default, -1=dashed, +1=solid
   arg_st.formatted_for_printing = false;
   arg_st.ghostscript.binary = __quote_path__ (__ghostscript_binary__ ());
   arg_st.ghostscript.debug = false;
   arg_st.ghostscript.device = "";
   arg_st.ghostscript.epscrop = true;
   arg_st.ghostscript.level = [];
   arg_st.ghostscript.output = "";
@@ -323,18 +322,22 @@ function arg_st = __print_parse_opts__ (
     endif
     arg_st.canvas_size = paperposition(3:4);
     if (strcmp (__graphics_toolkit__, "gnuplot") && ! arg_st.ghostscript.epscrop)
       arg_st.ghostscript.pageoffset = paperposition(1:2) - 50;
     else
       arg_st.ghostscript.pageoffset = paperposition(1:2);
     endif
   else
-    ## Convert canvas size to points from pixles.
-    arg_st.canvas_size = arg_st.canvas_size * 72 / arg_st.ghostscript.resolution;
+    ## Convert canvas size to points from pixels.
+    if (! isempty (arg_st.fontsize))
+      ## Work around the eps bbox having whole numbers (both gnuplot & gl2ps).
+      arg_st.scalefontsize = arg_st.ghostscript.resolution / 72;
+    endif
+    arg_st.ghostscript.resolution = 72;
     arg_st.ghostscript.papersize = arg_st.canvas_size;
     arg_st.ghostscript.epscrop = true;
     arg_st.ghostscript.pageoffset = [0, 0];
   endif
 
   if (arg_st.formatted_for_printing)
     arg_st.ghostscript.resolution = [];
   else
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -128,25 +128,27 @@ function hg = __scatter__ (varargin)
   endif
   addproperty ("sizedata", hg, "data", s);
   addlistener (hg, "xdata", @update_data);
   addlistener (hg, "ydata", @update_data);
   addlistener (hg, "zdata", @update_data);
   addlistener (hg, "cdata", @update_data);
   addlistener (hg, "sizedata", @update_data);
 
+  one_explicit_color = ischar (c) || isequal (size (c), [1, 3]);
+
   if (numel (x) <= 100)
 
     ## For small number of points, we'll construct an object for each point.
 
     if (numel (s) == 1)
       s = repmat (s, numel(x), 1);
     endif
 
-    if (ischar (c) || rows(c) == 1)
+    if (one_explicit_color)
       for i = 1 : numel (x)
         if (filled)
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
                             "faces", 1, "vertices", [x(i), y(i), z(i,:)],
                             "facecolor", "none", "edgecolor", "none",
                             "marker", marker,  "markersize", s(i),
                             "markeredgecolor", c, "markerfacecolor", c,
                             "linestyle", "none");
@@ -155,16 +157,19 @@ function hg = __scatter__ (varargin)
                             "faces", 1, "vertices", [x(i), y(i), z(i,:)],
                             "facecolor", "none", "edgecolor", "none",
                             "marker", marker,  "markersize", s(i),
                             "markeredgecolor", c, "markerfacecolor", "none",
                             "linestyle", "none");
         endif
       endfor
     else
+      if (rows (c) == 1)
+        c = ones (rows (x), 1) * c;
+      endif
       for i = 1 : numel (x)
         if (filled)
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
                             "faces", 1, "vertices", [x(i), y(i), z(i,:)],
                             "facecolor", "none", "edgecolor", "none",
                             "marker", marker, "markersize", s(i),
                             "markeredgecolor", "none",
                             "markerfacecolor", "flat",
@@ -184,34 +189,38 @@ function hg = __scatter__ (varargin)
       endfor
     endif
 
   else
 
     ## For larger numbers of points, we split the points by common color.
 
     vert = [x, y, z];
-
-    if (ischar (c) || rows (c) == 1)
-      h = render_size_color (hg, vert, s, c, marker, filled, false);
-    elseif (columns (c) == 1)
+    if (one_explicit_color)
       h = render_size_color (hg, vert, s, c, marker, filled, true);
     else
-      [cc, idx] = unique_idx (c, "rows");
-      if (isscalar (s))
-        for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s, cc(i,:),
+      if (rows (c) == 1)
+        c = ones (rows (x), 1) * c;
+      endif
+      ## We want to group points by colour. So first get all the unique colours
+      [cc, ~, c_to_cc] = unique (c, "rows");
+
+      for i = 1:rows (cc)
+        ## Now for each possible unique colour, get the logical index of
+        ## points that correspond to that colour
+        idx = (i == c_to_cc);
+        if (isscalar (s))
+          h = render_size_color (hg, vert(idx, :), s, c(idx,:),
                                  marker, filled, true);
-        endfor
-      else
-        for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s(idx{i}), cc(i,:),
+        else
+          h = render_size_color (hg, vert(idx, :), s(idx), c(idx,:),
                                  marker, filled, true);
-        endfor
-      endif
+        endif
+      endfor
+
     endif
   endif
 
   if (! ischar (c) && rows (c) > 1)
     ax = get (hg, "parent");
     clim = get (ax, "clim");
     if (min(c(:)) < clim(1))
       clim(1) = min(c(:));
@@ -221,111 +230,95 @@ function hg = __scatter__ (varargin)
       set (ax, "clim", [clim(1), max(c(:))]);
     endif
   endif
 
   addproperty ("linewidth", hg, "patchlinewidth", 0.5);
   addproperty ("marker", hg, "patchmarker", marker);
   if (filled)
     addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "none");
-    if (ischar (c) || rows (c) == 1)
+    if (one_explicit_color)
       addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", c);
     else
       addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "flat");
     endif
   else
     addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "none");
-    if (ischar (c) || rows (c) == 1)
+    if (one_explicit_color)
       addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", c);
     else
       addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "flat");
     endif
   endif
   addlistener (hg, "linewidth", @update_props);
   addlistener (hg, "marker", @update_props);
   addlistener (hg, "markerfacecolor", @update_props);
   addlistener (hg, "markeredgecolor", @update_props);
 
   if (! isempty (newargs))
     set (hg, newargs{:});
   endif
 
 endfunction
 
-function [y, idx] =  unique_idx (x, byrows)
-  if (nargin == 2)
-    [xx, idx] = sortrows (x);
-    n = rows (x);
-    jdx = find (any (xx(1:n-1,:) != xx(2:n,:), 2));
-    jdx(end+1) = n;
-    y = xx(jdx,:);
-  else
-    [xx, idx] = sort (x);
-    n = length (x);
-    jdx = find (xx(1:n-1,:) != xx(2:n,:));
-    jdx(end+1) = n;
-    y = xx(jdx);
-  endif
-
-  if (nargin == 2 || columns (x) == 1)
-    idx = mat2cell (idx, diff ([0; jdx]), 1);
-  else
-    idx = mat2cell (idx, 1, diff ([0, jdx]));
-  endif
-endfunction
-
 function h = render_size_color(hg, vert, s, c, marker, filled, isflat)
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
-    if (ischar (c) || !isflat)
+    toolkit = get (ancestor (hg, "figure"), "__graphics_toolkit__");
+    ## Does gnuplot only support triangles with different vertex colors ?
+    ## TODO - Verify gnuplot can only support one color. If RGB triplets
+    ##        can be assigned to each vertex, then fix __go_draw_axe__.m
+    gnuplot_hack = numel (x) > 1 && strcmp (toolkit, "gnuplot");
+    if (ischar (c) || ! isflat || gnuplot_hack)
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel(x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", "none",
-                          "markerfacecolor", c,
+                          "markerfacecolor", c(1,:),
                           "markersize", s, "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel(x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
-                          "markeredgecolor", c,
+                          "markeredgecolor", c(1,:),
                           "markerfacecolor", "none",
                           "markersize", s, "linestyle", "none");
       endif
     else
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel(x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "none",
                           "markerfacecolor", "flat",
-                          "cdata", c, "facevertexcdata", c(:),
+                          "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel(x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "flat",
                           "markerfacecolor", "none",
-                          "cdata", c, "facevertexcdata", c(:),
+                          "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       endif
     endif
   else
     ## FIXME: round the size to one decimal place. It's not quite right, though.
-    [ss, idx] = unique_idx (ceil (s*10) / 10);
+    [ss, ~, s_to_ss] = unique (ceil (s*10) / 10);
     for i = 1:rows (ss)
-      h = render_size_color (hg, vert(idx{i},:), ss(i), c,
+      idx = (i == s_to_ss);
+      h = render_size_color (hg, vert(idx,:), ss(i), c,
                              marker, filled, isflat);
     endfor
   endif
 endfunction
 
 function update_props (h, d)
   lw = get (h, "linewidth");
   m = get (h, "marker");
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Michel D. Schmid
+## Copyright (C) 2006-2012 Michel D. Schmid
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uigetdir_fltk__.m b/scripts/plot/private/__uigetdir_fltk__.m
--- a/scripts/plot/private/__uigetdir_fltk__.m
+++ b/scripts/plot/private/__uigetdir_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uigetfile_fltk__.m b/scripts/plot/private/__uigetfile_fltk__.m
--- a/scripts/plot/private/__uigetfile_fltk__.m
+++ b/scripts/plot/private/__uigetfile_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uiobject_split_args__.m b/scripts/plot/private/__uiobject_split_args__.m
--- a/scripts/plot/private/__uiobject_split_args__.m
+++ b/scripts/plot/private/__uiobject_split_args__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__uiputfile_fltk__.m b/scripts/plot/private/__uiputfile_fltk__.m
--- a/scripts/plot/private/__uiputfile_fltk__.m
+++ b/scripts/plot/private/__uiputfile_fltk__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -29,28 +29,28 @@
 ## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] =
 ## size(@var{u})}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
-##  the arrows of the field relative to the mesh spacing.  A value of 0
+## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
-## The optional return value @var{h} provides a quiver group that
-## regroups the components of the quiver plot (body, arrow and marker),
-## and allows them to be changed together
+## The optional return value @var{h} is a graphics handle to a quiver object.
+## A quiver object regroups the components of the quiver plot (body, arrow,
+## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y] = meshgrid (1:2:20);
 ## h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
 ## set (h, "maxheadsize", 0.33);
 ## @end group
 ## @end example
@@ -76,19 +76,24 @@ function retval = quiver (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! [x,y] = meshgrid(1:2:20);
-%! h = quiver(x,y,sin(2*pi*x/10),sin(2*pi*y/10));
-%! set (h, "maxheadsize", 0.33);
+%! clf;
+%! [x,y] = meshgrid (1:2:20);
+%! h = quiver (x,y, sin (2*pi*x/10), sin (2*pi*y/10));
+%! set (h, 'maxheadsize', 0.33);
 
 %!demo
-%! axis("equal");
-%! x=linspace(0,3,80); y=sin(2*pi*x); theta=2*pi*x+pi/2;
-%! quiver(x,y,sin(theta)/10,cos(theta)/10);
-%! hold on; plot(x,y,"r"); hold off;
+%! clf;
+%! axis ('equal');
+%! x = linspace (0, 3, 80);
+%! y = sin (2*pi*x);
+%! theta = 2*pi*x + pi/2;
+%! quiver (x, y, sin (theta)/10, cos (theta)/10);
+%! hold on; plot (x,y,'r'); hold off;
+
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -38,19 +38,19 @@
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
-## The optional return value @var{h} provides a quiver group that
-## regroups the components of the quiver plot (body, arrow and marker),
-## and allows them to be changed together
+## The optional return value @var{h} is a graphics handle to a quiver object.
+## A quiver object regroups the components of the quiver plot (body, arrow,
+## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (25);
 ## surf (x, y, z);
 ## hold on;
 ## [u, v, w] = surfnorm (x, y, z / 10);
 ## h = quiver3 (x, y, z, u, v, w);
@@ -79,32 +79,43 @@ function retval = quiver3 (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! colormap (jet (64))
-%! [x,y]=meshgrid (-1:0.1:1);
-%! z=sin(2*pi*sqrt(x.^2+y.^2));
-%! theta=2*pi*sqrt(x.^2+y.^2)+pi/2;
-%! quiver3(x,y,z,sin(theta),cos(theta),ones(size(z)));
+%! clf;
+%! colormap ('default');
+%! [x,y] = meshgrid (-1:0.1:1);
+%! z = sin (2*pi * sqrt (x.^2 + y.^2));
+%! theta = 2*pi * sqrt (x.^2 + y.^2) + pi/2;
+%! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold on;
-%! mesh(x,y,z);
+%! mesh (x,y,z);
 %! hold off;
 
 %!demo
-%! clf
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
 %! h = quiver3 (x, y, z, u, v, w);
-%! set (h, "maxheadsize", 0.33);
+%! set (h, 'maxheadsize', 0.33);
 %! hold off;
 
 %!demo
-%! shading interp
+%! clf;
+%! colormap ('default');
+%! [x, y, z] = peaks (25);
+%! surf (x, y, z);
+%! hold on;
+%! [u, v, w] = surfnorm (x, y, z / 10);
+%! h = quiver3 (x, y, z, u, v, w);
+%! set (h, 'maxheadsize', 0.33);
+%! hold off;
+%! shading interp;
 
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 David Bateman
+## Copyright (C) 2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -39,19 +39,20 @@
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
 ## min (pos (1:2)) / max (pos (1:2)) * curv
 ## @end example
 ##
-## Other properties are passed to the underlying patch command.  If called
-## with an output argument, @code{rectangle} returns the handle to the
-## rectangle.
+## Other properties are passed to the underlying patch command. 
+## 
+## The optional return value @var{h} is a graphics handle to the created
+## rectangle object.
 ## @end deftypefn
 ## @seealso{patch}
 
 function h = rectangle (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("rectangle", varargin{:});
 
   tmp =  __rectangle__ (hax, varargin{:});
@@ -199,23 +200,23 @@ function update_props (h, d)
   set (kids, "edgecolor", get (h, "edgecolor"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
        "facecolor", get (h, "facecolor"));
 endfunction
 
 
 %!demo
-%! close all
-%! axis equal
-%! rectangle ("Position", [0.05, 0.05, 0.9, 0.9], "Curvature", [0.5, 0.5]);
+%! clf;
+%! axis equal;
+%! rectangle ('Position', [0.05, 0.05, 0.9, 0.9], 'Curvature', [0.5, 0.5]);
 
 %!demo
-%! close all
-%! axis equal
-%! rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature", 1.0);
+%! clf;
+%! axis equal;
+%! rectangle ('Position', [0.05, 0.05, 0.9, 0.4], 'Curvature', 1.0);
 
 %!demo
-%! close all
-%! axis equal
-%! h = rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature",  1.0);
-%! set (h, "FaceColor", [0, 1, 0]);
+%! clf;
+%! axis equal;
+%! h = rectangle ('Position', [0.05, 0.05, 0.9, 0.4], 'Curvature', 1.0);
+%! set (h, 'FaceColor', [0, 1, 0]);
 
diff --git a/scripts/plot/refresh.m b/scripts/plot/refresh.m
--- a/scripts/plot/refresh.m
+++ b/scripts/plot/refresh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,29 +14,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} refresh ()
 ## @deftypefnx {Function File} {} refresh (@var{h})
-## Refresh a figure, forcing it to be redrawn.  Called without an
-## argument the current figure is redrawn, otherwise the figure pointed
+## Refresh a figure, forcing it to be redrawn.  When called without an
+## argument the current figure is redrawn.  Otherwise, the figure pointed
 ## to by @var{h} is redrawn.
 ## @seealso{drawnow}
 ## @end deftypefn
 
 function refresh (h)
 
-  if (nargin == 1)
-    if (!ishandle (h) || !strcmp (get (h, "type"), "figure"))
-      error ("refresh: expecting argument to be a valid figure handle");
+  if (nargin > 1)
+    print_usage ();
+  elseif (nargin == 1)
+    if (! isfigure (h))
+      error ("refresh: H must be a valid figure handle");
     endif
-  elseif (nargin > 1)
-    print_usage ();
   else
     h = gcf ();
   endif
 
-  set(h,"__modified__", "on");
+  set (h, "__modified__", "on");
   drawnow ();
+
 endfunction
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -37,19 +37,19 @@
 ## An example of the use of @code{refreshdata} is:
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
 ## y = sin (x);
 ## plot (x, y, "ydatasource", "y");
 ## for i = 1 : 100
-##   pause(0.1)
+##   pause (0.1)
 ##   y = sin (x + 0.1 * i);
-##   refreshdata();
+##   refreshdata ();
 ## endfor
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function refreshdata (h, workspace)
 
   if (nargin == 0)
@@ -98,19 +98,23 @@ function refreshdata (h, workspace)
         val = evalin (workspace, expr);
         prop =  props{i}{j}(1:end-6);
         if (! isequal (get (objs(i), prop), val))
           set (objs(i), props{i}{j}(1:end-6), val);
         endif
       endif
     endfor
   endfor
+
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
-%! plot (x, y, "ydatasource", "y");
+%! plot (x, y, 'ydatasource', 'y');
 %! for i = 1 : 100
-%!   pause(0.1)
+%!   pause (0.1);
 %!   y = sin (x + 0.1 * i);
-%!   refreshdata(gcf(), "caller");
-%! endfor
+%!   refreshdata (gcf (), 'caller');
+%! end
+
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,74 +18,78 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ribbon (@var{x}, @var{y}, @var{width})
 ## @deftypefnx {Function File} {} ribbon (@var{y})
 ## @deftypefnx {Function File} {@var{h} =} ribbon (@dots{})
 ## Plot a ribbon plot for the columns of @var{y} vs.  @var{x}.  The
 ## optional parameter @var{width} specifies the width of a single ribbon
 ## (default is 0.75).  If @var{x} is omitted, a vector containing the
-## row numbers is assumed (1:rows(Y)).  If requested, return a vector
-## @var{h} of the handles to the surface objects.
-## @seealso{gca, colorbar}
+## row numbers is assumed (1:rows(Y)).
+##
+## The optional return value @var{h} is a vector of graphics handles to
+## the surface objects representing each ribbon.
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
-function h = ribbon (x, y, width)
+function h = ribbon (x, y, width = 0.75)
 
-  newplot ();
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  endif
 
   if (nargin == 1)
     y = x;
     if (isvector (y))
       y = y(:);
     endif
     [nr, nc] = size (y);
     x = repmat ((1:nr)', 1, nc);
-    width = 0.75;
-  elseif (nargin == 2)
-    width = 0.75;
-  elseif (nargin != 3)
-    print_usage ();
   endif
 
   if (isvector (x) && isvector (y))
     if (length (x) != length (y))
-      error ("ribbon: in case of vectors, X and Y must have same length");
+      error ("ribbon: vectors X and Y must have the same length");
     else
       [x, y] = meshgrid (x, y);
     endif
   else
-    if (! size_equal(x, y))
-      error ("ribbon: in case of matrices, X and Y must have same size");
+    if (! size_equal (x, y))
+      error ("ribbon: matrices X and Y must have the same size");
     endif
   endif
 
+  newplot ();
+
   [nr, nc] = size (y);
-  tmp = zeros (1, nc);
+  htmp = zeros (nc, 1);
 
   for c = nc:-1:1
     zz = [y(:,c), y(:,c)];
     yy = x(:,c);
     xx = [c - width / 2, c + width / 2];
     [xx, yy] = meshgrid (xx, yy);
-    cc = ones (size (zz)) * c;
-    tmp(c) = surface (xx, yy, zz, cc);
+    cc = repmat (c, size (zz));
+    htmp(c) = surface (xx, yy, zz, cc);
   endfor
 
-  ax = get (tmp(c), "parent");
-
   if (! ishold ())
-    set (ax, "view", [-37.5, 30], "box", "off", "xgrid", "on",
-         "ygrid", "on", "zgrid", "on");
+    ax = get (htmp(1), "parent");
+    set (ax, "view", [-37.5, 30], "box", "off", 
+             "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
+
+%!FIXME: Could have some input validation tests here
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,32 +25,31 @@
 ## Plot an angular histogram.  With one vector argument @var{th}, plots the
 ## histogram with 20 angular bins.  If @var{th} is a matrix, then each column
 ## of @var{th} produces a separate histogram.
 ##
 ## If @var{r} is given and is a scalar, then the histogram is produced with
 ## @var{r} bins.  If @var{r} is a vector, then the center of each bin are
 ## defined by the values of @var{r}.
 ##
-## The optional return value @var{h} provides a list of handles to the
-## the parts of the vector field (body, arrow and marker).
+## The optional return value @var{h} is a vector of graphics handles to the
+## line objects representing each histogram.
 ##
-## If two output arguments are requested, then rather than plotting the
+## If two output arguments are requested then, rather than plotting the
 ## histogram, the polar vectors necessary to plot the histogram are
 ## returned.
 ##
 ## @example
 ## @group
 ## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
 ## polar (r, t);
 ## @end group
 ## @end example
 ##
-##
-## @seealso{plot, compass, polar, hist}
+## @seealso{polar, compass, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose",
                                                 varargin{:});
 
   if (nargin < 1)
@@ -102,10 +101,11 @@ function [thout, rout] = rose (varargin)
     thout = th;
     rout = r;
   endif
 
 endfunction
 
 
 %!demo
+%! clf;
 %! rose ([2*randn(1e5, 1), pi + 2*randn(1e5, 1)]);
 
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -77,41 +77,112 @@ function retval = scatter (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
-%! scatter (x, y, "r");
+%! scatter (x, y, 'r');
+%! title ('Scatter plot with red bubbles');
 
 %!demo
+%! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
-%! scatter (x, y, [], sqrt(x.^2 + y.^2));
+%! scatter (x, y, [], sqrt (x.^2 + y.^2));
+%! title ('Scatter plot with bubble color determined by distance from origin');
 
 %!demo
+%! clf;
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
 %! y = rand_10x1_data2;
 %! s = 10 - 10*log (x.^2 + y.^2);
-%! h = scatter (x, y, s, s, "s", "filled");
+%! h = scatter (x, y, s, s, 's', 'filled');
+%! title ({'Scatter plot with filled square markers', ...
+%!         'size and color of markers determined by algorithm'});
 
 %!demo
+%! clf;
 %! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726];
 %! rand_10x1_data4 = [0.020207, 0.527193, 0.443472, 0.061683, 0.370277, 0.947349, 0.249591, 0.666304, 0.134247, 0.920356];
 %! x = rand_10x1_data3;
 %! y = rand_10x1_data4;
 %! s = 10 - 10*log (x.^2 + y.^2);
-%! h = scatter (x, y, [], "r", "s", "filled");
+%! h = scatter (x, y, [], 'r', 's', 'filled');
 
 %!demo
+%! clf;
 %! rand_10x1_data5 = [0.777753, 0.093848, 0.183162, 0.399499, 0.337997, 0.686724, 0.073906, 0.651808, 0.869273, 0.137949];
 %! rand_10x1_data6 = [0.37460, 0.25027, 0.19510, 0.51182, 0.54704, 0.56087, 0.24853, 0.75443, 0.42712, 0.44273];
 %! x = rand_10x1_data5;
 %! y = rand_10x1_data6;
 %! s = 10 - 10*log (x.^2 + y.^2);
-%! h = scatter (x, y, [], "r", "s");
+%! h = scatter (x, y, [], 'r', 's');
 
+%!demo
+%! clf;
+%! k = 1;
+%! for m = [1, 3]
+%!   for n = [101, 50, 1]
+%!     x = rand (n, 1);
+%!     y = rand (n, 1);
+%!     if (m > 1)
+%!       str = 'Three Colors';
+%!       idx = ceil (rand (n, 1) * 3);
+%!       colors = eye (3);
+%!       colors = colors(idx, :);
+%!     else
+%!       str = 'Random Colors';
+%!       colors = rand (n, m);
+%!     end
+%!     if (n == 1)
+%!       str = sprintf ('%s: 1 point', str);
+%!     elseif (n < 100)
+%!       str = sprintf ('%s: < 100 points', str);
+%!     else
+%!       str = sprintf ('%s: > 100 points', str);
+%!     end
+%!     subplot (2,3,k);
+%!     k = k + 1;
+%!     scatter (x, y, 15, colors, 'filled');
+%!     axis ([0 1 0 1]);
+%!     title (str);
+%!   end
+%! end
+
+%!demo
+%! clf;
+%! k = 1;
+%! for m = [1, 3]
+%!   for n = [101, 50, 1]
+%!     x = rand (n, 1);
+%!     y = rand (n, 1);
+%!     if (m > 1)
+%!       str = 'Three Colors';
+%!       idx = ceil (rand (n, 1) * 3);
+%!       colors = eye (3);
+%!       colors = colors(idx, :);
+%!     else
+%!       str = 'Random Colors';
+%!       colors = rand (n, m);
+%!     end
+%!     if (n == 1)
+%!       str = sprintf ('%s: 1 point', str);
+%!     elseif (n < 100)
+%!       str = sprintf ('%s: < 100 points', str);
+%!     else
+%!       str = sprintf ('%s: > 100 points', str);
+%!     end
+%!     subplot (2,3,k);
+%!     k = k + 1;
+%!     scatter (x, y, 15, colors);
+%!     axis ([0 1 0 1]);
+%!     title (str);
+%!   end
+%! end
+
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -36,17 +36,18 @@
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
 ## If the argument 'filled' is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
-## The optional return value @var{h} provides a handle to the patch object
+## The optional return value @var{h} is a graphics handle to the hggroup
+## object representing the points.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
 ## scatter3 (x(:), y(:), z(:), [], z(:));
 ## @end group
 ## @end example
 ##
@@ -78,29 +79,32 @@ function retval = scatter3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
+%! clf;
 %! [x, y, z] = peaks (20);
 %! scatter3 (x(:), y(:), z(:), [], z(:));
+%! %% Default scatter3 with constant size bubbles and color determined by Z
 
 %!demo
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
-%! scatter3 (x(:), y(:), z(:), 10, z(:), "s");
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
+%! scatter3 (x(:), y(:), z(:), 10, z(:), 's');
+%! %% scatter3 using a square marker of size 10 and color determined by Z
 
 %!demo
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
-%! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), "s");
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
+%! scatter3 (x(:), y(:), z(:), 20*z(:), [], 's');
+%! %% scatter3 using a square marker whose size is determined by Z
 
 %!demo
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
-%! scatter3 (x(:), y(:), z(:), 20*z(:), [], "s");
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
+%! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), 's');
+%! %% scatter3 using a square marker.
+%! %% Size and color of marker are determined by Z
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogx (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogx (@dots{})
 ## Produce a two-dimensional plot using a logarithmic scale for the @var{x}
 ## axis.  See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogx} will accept.
+## 
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogy, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
@@ -55,64 +57,67 @@ function retval = semilogx (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! semilogx (x, y)
-%! xlabel ('semilogx (x, y)')
+%! subplot (1,2,1);
+%!  semilogx (x, y);
+%!  xlabel ('semilogx (x, y)');
 %!
-%! subplot (1, 2, 2)
-%! semilogx (-x, y)
-%! xlabel ('semilogx (-x, y)')
+%! subplot (1,2,2);
+%!  semilogx (-x, y);
+%!  xlabel ('semilogx (-x, y)');
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! semilogx (x, y)
-%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
-%! xlabel ({"semilogx (x, y)", "xdir = reversed"})
+%! subplot (1,2,1);
+%!  semilogx (x, y);
+%!  set (gca, 'xdir', 'reverse', 'activepositionproperty', 'outerposition');
+%!  xlabel ({'semilogx (x, y)', 'xdir = reversed'});
 %!
-%! subplot (1, 2, 2)
-%! semilogx (-x, y)
-%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
-%! xlabel ({"semilogx (-x, y)","xdir = reversed"})
+%! subplot (1,2,2);
+%!  semilogx (-x, y);
+%!  set (gca, 'xdir', 'reverse', 'activepositionproperty', 'outerposition');
+%!  xlabel ({'semilogx (-x, y)', 'xdir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   assert (get (gca, "xscale"), "log");
 %!   assert (get (gca, "yscale"), "linear");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   semilogx (a, b)
-%!   axis tight
+%!   semilogx (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -55,14 +55,17 @@ function retval = semilogxerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
-%! semilogxerr (x, y, ey, "#~x-")
-%! xlim (x([1, end]))
+%! semilogxerr (x, y, ey, '#~x-');
+%! xlim (x([1, end]));
+
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,16 +21,18 @@
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogy (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogy (@dots{})
 ## Produce a two-dimensional plot using a logarithmic scale for the @var{y}
 ## axis.  See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogy} will accept.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
@@ -56,66 +58,67 @@ function retval = semilogy (varargin)
     endif
 
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1)
-%! semilogy (x, y)
-%! ylabel ('semilogy (x, y)')
+%! subplot (2, 1, 1);
+%! semilogy (x, y);
+%! ylabel ('semilogy (x, y)');
 %!
-%! subplot (2, 1, 2)
-%! semilogy (x, -y)
-%! ylabel ('semilogy (x, -y)')
+%! subplot (2, 1, 2);
+%! semilogy (x, -y);
+%! ylabel ('semilogy (x, -y)');
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1)
-%! semilogy (x, y)
-%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
-%! ylabel ({"semilogy (x, y)", "ydir = reversed"})
+%! subplot (2, 1, 1);
+%! semilogy (x, y);
+%! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
+%! ylabel ({'semilogy (x, y)', 'ydir = reversed'});
 %!
-%! subplot (2, 1, 2)
-%! semilogy (x, -y)
-%! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition")
-%! ylabel ({"semilogy (x, -y)", "ydir = reversed"})
+%! subplot (2, 1, 2);
+%! semilogy (x, -y);
+%! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
+%! ylabel ({'semilogy (x, -y)', 'ydir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   semilogy (a, b)
+%!   semilogy (a, b);
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "linear");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   semilogy (a, b)
-%!   axis tight
+%!   semilogy (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
-
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Teemu Ikonen
+## Copyright (C) 2000-2012 Teemu Ikonen
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -55,16 +55,18 @@ function retval = semilogyerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 0.25:0.25:10;
 %! y = wblpdf (x, 4, 2);
 %! eyu = rand (size (y));
 %! eyl = 1.0 - 1./(1+eyu);
-%! semilogyerr (x, y, eyl.*y, eyu.*y, "~-d")
-%! xlim ([0 10])
+%! semilogyerr (x, y, eyl.*y, eyu.*y, '~-d');
+%! xlim ([0 10]);
 
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Kai Habel
+## Copyright (C) 2006-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -68,29 +68,51 @@ function shading (varargin)
       set (h, "edgecolor", [0 0 0]);
     else
       error ("shading: unknown argument");
     endif
   endfor
 
 endfunction
 
+
 %!demo
-%! clf
-%! colormap (jet)
-%! sombrero
-%! shading faceted
-%! title("shading ""faceted""")
+%! clf;
+%! colormap ('default');
+%! sombrero ();
+%! shading faceted;
+%! title ('shading ''faceted''');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! sombrero ();
+%! shading flat;
+%! title ('shading ''flat''');
 
 %!demo
-%! sombrero
-%! shading interp
-%! title("shading ""interp""")
+%! clf;
+%! colormap ('default');
+%! sombrero ();
+%! shading interp;
+%! title ('shading ''interp''');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! pcolor (peaks ());
+%! shading faceted;
+%! title ('shading ''faceted''');
 
 %!demo
-%! pcolor (peaks ())
-%! shading faceted
-%! title("shading ""faceted""")
+%! clf;
+%! colormap ('default');
+%! pcolor (peaks ());
+%! shading flat;
+%! title ('shading ''flat''');
 
 %!demo
-%! pcolor (peaks ())
-%! shading interp
-%! title("shading ""interp""")
+%! clf;
+%! colormap ('default');
+%! pcolor (peaks ());
+%! shading interp;
+%! title ('shading ''interp''');
+
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel, David Bateman
+## Copyright (C) 2007-2012 Kai Habel, David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -50,18 +50,19 @@
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
 ## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## The default method is @code{"linear"}.
-## The optional return value @var{h} is a vector of handles to the
-## surface graphic objects.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## [x, y, z] = meshgrid (linspace (-8, 8, 32));
 ## v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 ## slice (x, y, z, v, [], 0, []);
@@ -174,15 +175,25 @@ function h = slice (varargin)
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
+%! colormap ('default');
 %! [x, y, z] = meshgrid (linspace (-8, 8, 32));
 %! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! slice (x, y, z, v, [], 0, []);
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! [x, y, z] = meshgrid (linspace (-8, 8, 32));
+%! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! [xi, yi] = meshgrid (linspace (-7, 7));
 %! zi = xi + yi;
 %! slice (x, y, z, v, xi, yi, zi);
+
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -56,10 +56,14 @@ function [x, y, z] = sombrero (n)
       error ("sombrero: number of grid lines must be greater than 1");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
+%! colormap ('default');
 %! sombrero ();
+
diff --git a/scripts/plot/specular.m b/scripts/plot/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/specular.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/sphere.m b/scripts/plot/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/sphere.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Michael Goffioul
+## Copyright (C) 2007-2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/spinmap.m b/scripts/plot/spinmap.m
--- a/scripts/plot/spinmap.m
+++ b/scripts/plot/spinmap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -205,32 +205,36 @@ function [h, xs, ys] = __stairs__ (doplo
   else
     h = 0;
   endif
 
 endfunction
 
 
 %!demo
+%! clf;
 %! x = 1:10;
 %! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
 %! y = rand_1x10_data1;
 %! stairs (x, y);
 
 %!demo
+%! clf;
 %! x = 1:10;
 %! rand_1x10_data2 = [0.014, 0.460, 0.622, 0.394, 0.531, 0.378, 0.466, 0.788, 0.342, 0.893];
 %! y = rand_1x10_data2;
 %! [xs, ys] = stairs (x, y);
 %! plot (xs, ys);
 
 %!demo
+%! clf;
 %! stairs (1:9);
 
 %!demo
+%! clf;
 %! [xs, ys] = stairs (9:-1:1);
 %! plot (xs, ys);
 
 
 function update_props (h, d)
   set (get (h, "children"), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Michel D. Schmid
+## Copyright (C) 2006-2012 Michel D. Schmid
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -42,18 +42,18 @@
 ## y = ones (1, length (x))*2.*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ##
-## The return value of @code{stem} is a vector of "stem series" graphics
-## handles, with one handle per column of the variable @var{y}.  This
+## The optional return value @var{h} is a vector of "stem series" graphics
+## handles with one handle per column of the variable @var{y}.  The
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example,
 ##
 ## @example
 ## @group
 ## x = [0 : 10]';
 ## y = [sin(x), cos(x)]
@@ -81,43 +81,52 @@ function h = stem (varargin)
   tmp = __stem__ (false, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 1:10;
 %! stem (x);
 
 %!demo
+%! clf;
 %! x = 1:10;
-%! y = ones (1, length (x))*2.*x;
+%! y = 2*x;
 %! stem (x, y);
 
 %!demo
+%! clf;
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "r");
+%! y = 2*x;
+%! h = stem (x, y, 'r');
 
 %!demo
+%! clf;
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "-.k");
+%! y = 2*x;
+%! h = stem (x, y, '-.k');
 
 %!demo
+%! clf;
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "-.k.");
+%! y = 2*x;
+%! h = stem (x, y, '-.k.');
 
 %!demo
+%! clf;
 %! x = 1:10;
-%! y = ones (size (x))*2.*x;
-%! h = stem (x, y, "filled");
+%! y = 2*x;
+%! h = stem (x, y, 'filled');
 
 %!demo
-%! x = [0 : 10]';
+%! clf;
+%! x = (0 : 10)';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
-%! set (h(2), "color", "g");
-%! set (h(1), "basevalue", -1)
+%! set (h(2), 'color', 'g');
+%! set (h(1), 'basevalue', -1)
+
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -47,11 +47,14 @@ function h = stem3 (varargin)
   tmp = __stem__ (true, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! theta = 0:0.2:6;
-%! stem3 (cos (theta), sin (theta), theta)
+%! stem3 (cos(theta), sin(theta), theta);
+
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -323,43 +323,43 @@ function pos = subplot_position (rows, c
   else
     ## subplot (row, col, num)
     pos = [x0, y0, width, height];
   endif
 
 endfunction
 
 %!demo
-%! clf
+%! clf;
 %! r = 3;
 %! c = 3;
 %! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
-%! for n = 1:(r*c)
-%!   subplot (r, c, n)
-%!   xlabel (sprintf ("xlabel #%d", n))
-%!   ylabel (sprintf ("ylabel #%d", n))
-%!   title (sprintf ("title #%d", n))
-%!   text (0.5, 0.5, sprintf('subplot(%d,%d,%d)', r, c, n), fmt{:})
-%!   axis ([0 1 0 1])
-%! endfor
-%! subplot (r, c, 1:3)
-%! xlabel (sprintf ("xlabel #%d:%d", 1, 3))
-%! ylabel (sprintf ("ylabel #%d:%d", 1, 3))
-%! title (sprintf ("title #%d:%d", 1, 3))
-%! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:})
-%! axis ([0 1 0 1])
+%! for n = 1 : r*c
+%!   subplot (r, c, n);
+%!   xlabel (sprintf ('xlabel #%d', n));
+%!   ylabel (sprintf ('ylabel #%d', n));
+%!   title (sprintf ('title #%d', n));
+%!   text (0.5, 0.5, sprintf('subplot(%d,%d,%d)', r, c, n), fmt{:});
+%!   axis ([0 1 0 1]);
+%! end
+%! subplot (r, c, 1:3);
+%! xlabel (sprintf ('xlabel #%d:%d', 1, 3));
+%! ylabel (sprintf ('ylabel #%d:%d', 1, 3));
+%! title (sprintf ('title #%d:%d', 1, 3));
+%! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:});
+%! axis ([0 1 0 1]);
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:1;
 %! for n = 1:4
-%!   subplot (2, 2, n, "align")
-%!   plot (x, x)
-%!   xlabel (sprintf ("xlabel (2,2,%d)", n))
-%!   ylabel (sprintf ("ylabel (2,2,%d)", n))
-%!   title (sprintf ("title (2,2,%d)", n))
-%! endfor
-%! subplot (1, 2, 1, "align")
-%! plot (x, x)
-%! xlabel ("xlabel (1,2,1)")
-%! ylabel ("ylabel (1,2,1)")
-%! title ("title (1,2,1)")
+%!   subplot (2, 2, n, 'align');
+%!   plot (x, x);
+%!   xlabel (sprintf ('xlabel (2,2,%d)', n));
+%!   ylabel (sprintf ('ylabel (2,2,%d)', n));
+%!   title (sprintf ('title (2,2,%d)', n));
+%! end
+%! subplot (1, 2, 1, 'align');
+%! plot (x, x);
+%! xlabel ('xlabel (1,2,1)');
+%! ylabel ('ylabel (1,2,1)');
+%! title ('title (1,2,1)');
 
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Kai Habel
+## Copyright (C) 2007-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -27,16 +27,19 @@
 ## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
 ## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
 ## correspond to different @var{x} values and rows of @var{z} correspond
 ## to different @var{y} values.
 ##
 ## The color of the surface is derived from the @code{colormap} and
 ## the value of @var{z}.  Optionally the color of the surface can be
 ## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ## @seealso{colormap, contour, meshgrid, mesh}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = surf (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
@@ -56,24 +59,31 @@ function retval = surf (varargin)
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! [~,~,Z]=peaks;
-%! surf(Z);
 
 %!demo
-%! [~,~,Z]=sombrero;
-%! [Fx,Fy] = gradient(Z);
-%! surf(Z,Fx+Fy);
+%! clf;
+%! colormap ('default');
+%! [~,~,Z] = peaks ();
+%! surf (Z);
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! [~,~,Z] = sombrero ();
+%! [Fx,Fy] = gradient (Z);
+%! surf (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
-%! [X,Y,Z]=sombrero;
-%! [~,Fy] = gradient(Z);
-%! surf(X,Y,Z,Fy);
+%! clf;
+%! colormap ('default');
+%! [X,Y,Z] = sombrero ();
+%! [~,Fy] = gradient (Z);
+%! surf (X, Y, Z, Fy);
 %! shading interp;
+
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -28,16 +28,19 @@
 ## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
 ## @var{y} coordinates of the surface.  If @var{x} and @var{y} are vectors,
 ## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
 ## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.  If @var{x} and @var{y}
 ## are missing, they are constructed from size of the matrix @var{z}.
 ##
 ## Any additional properties passed are assigned to the surface.
+## 
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = surface (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
@@ -158,19 +161,18 @@ function [h, bad_usage] = __surface__ (a
 
     if (! ishold ())
       set (ax, "view", [0, 90], "box", "off");
     endif
   endif
 
 endfunction
 
-## Mark file as being tested.  Tests for surface are in
-## surf.m, surfc.m, surfl.m, and pcolor.m
 
+## Functional tests for surface() are in surf.m, surfc.m, surfl.m, and pcolor.m
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = surface;
 %!   assert (findobj (hf, "type", "surface"), h);
 %!   assert (get (h, "xdata"), 1:3, eps);
 %!   assert (get (h, "ydata"), (1:3)', eps);
 %!   assert (get (h, "zdata"), eye(3));
@@ -178,8 +180,9 @@ endfunction
 %!   assert (get (h, "type"), "surface");
 %!   assert (get (h, "linestyle"), get (0, "defaultsurfacelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultsurfacelinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultsurfacemarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultsurfacemarkersize"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -69,24 +69,31 @@ function h = surfc (varargin)
   tmp = [tmp; tmp2];
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! [~,~,Z]=peaks;
-%! surfc(Z);
 
 %!demo
-%! [~,~,Z]=sombrero;
-%! [Fx,Fy] = gradient(Z);
-%! surfc(Z,Fx+Fy);
+%! clf;
+%! colormap ('default');
+%! [~,~,Z] = peaks ();
+%! surfc (Z);
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! [~,~,Z] = sombrero ();
+%! [Fx,Fy] = gradient (Z);
+%! surfc (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
-%! [X,Y,Z]=sombrero;
-%! [~,Fy] = gradient(Z);
-%! surfc(X,Y,Z,Fy);
+%! clf;
+%! colormap ('default');
+%! [X,Y,Z] = sombrero ();
+%! [~,Fy] = gradient (Z);
+%! surfc (X,Y,Z,Fy);
 %! shading interp;
+
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Kai Habel
+## Copyright (C) 2009-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,53 +18,52 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} surfl (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} surfl (@var{z})
 ## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z}, @var{L})
 ## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z}, @var{L}, @var{P})
 ## @deftypefnx {Function File} {} surfl (@dots{}, "light")
 ## Plot a lighted surface given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and
-## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
-## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
-## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
-## correspond to different @var{x} values and rows of @var{z} correspond
-## to different @var{y} values.
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
+## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, then
+## a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns
+## of @var{z} correspond to different @var{x} values and rows of @var{z}
+## correspond to different @var{y} values.
 ##
-## The light direction can be specified using @var{L}.  It can be
-## given as 2-element vector [azimuth, elevation] in degrees or as 3-element
-## vector [lx, ly, lz].
-## The default value is rotated 45¬∞ counter-clockwise from the current view.
+## The light direction can be specified using @var{L}.  It can be given as a
+## 2-element vector [azimuth, elevation] in degrees or as a 3-element vector
+## [lx, ly, lz].  The default value is rotated 45 degrees counterclockwise
+## from the current view.
 ##
 ## The material properties of the surface can specified using a 4-element vector
 ## @var{P} = [@var{AM} @var{D} @var{SP} @var{exp}] which defaults to
 ## @var{p} = [0.55 0.6 0.4 10].
+##
 ## @table @asis
 ## @item "AM" strength of ambient light
 ##
 ## @item "D" strength of diffuse reflection
 ##
 ## @item "SP" strength of specular reflection
 ##
 ## @item "EXP" specular exponent
 ## @end table
 ##
 ## The default lighting mode "cdata", changes the cdata property to give the
-## impression
-## of a lighted surface.  Please note: the alternative "light" mode, which
-## creates a light
-## object to illuminate the surface is not implemented (yet).
+## impression of a lighted surface.  Please note: the alternative "light"
+## mode, which creates a light object to illuminate the surface is not
+## implemented (yet).
 ##
 ## Example:
 ##
 ## @example
 ## @group
-## colormap(bone);
-## surfl(peaks);
+## colormap (bone);
+## surfl (peaks);
 ## shading interp;
 ## @end group
 ## @end example
 ## @seealso{surf, diffuse, specular, surface}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
@@ -75,22 +74,22 @@ function retval = surfl (varargin)
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     ## Check for lighting type.
     use_cdata = true;
     if (ischar (varargin{end}))
-      lstr = varargin{end};
-      if (strncmp (tolower (lstr), "light", 5))
+      lstr = tolower (varargin{end});
+      if (strncmp (lstr, "light", 5))
         warning ("light method not supported (yet), using cdata method instead");
         ## This can be implemented when light objects are supported.
         use_cdata = false;
-      elseif (strncmp (tolower (lstr), "cdata", 5))
+      elseif (strncmp (lstr, "cdata", 5))
         use_cdata = true;
       else
         error ("surfl: unknown lighting method");
       endif
       varargin(end) = [];
     endif
 
     ## Check for reflection properties argument.
@@ -118,17 +117,17 @@ function retval = surfl (varargin)
         have_lv = true;
       elseif (len == 2)
         [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180, lastarg(2) * pi/180, 1.0);
         varargin(end) = [];
         have_lv = true;
       endif
     endif
 
-    tmp = surface (varargin{:});
+    htmp = surface (varargin{:});
     if (! ishold ())
       set (h, "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
     endif
 
     ## Get view vector (vv).
     a = axis;
     [az, el] = view;
@@ -139,49 +138,51 @@ function retval = surfl (varargin)
       ## Calculate light vector (lv) from view vector.
       Phi = 45.0 / 180.0 * pi;
       R = [cos(Phi), -sin(Phi), 0;
            sin(Phi),  cos(Phi), 0;
            0,          0,         1];
       lv = (R * vv.').';
     endif
 
-    vn = get (tmp, "vertexnormals");
+    vn = get (htmp, "vertexnormals");
     dar = get (h, "plotboxaspectratio");
     vn(:,:,1) *= dar(1);
     vn(:,:,2) *= dar(2);
     vn(:,:,3) *= dar(3);
 
     ## Normalize vn.
     vn = vn ./ repmat (sqrt (sumsq (vn, 3)), [1, 1, 3]);
-    [nr, nc] = size(get(tmp, "zdata"));
+    [nr, nc] = size(get(htmp, "zdata"));
 
     ## Ambient, diffuse, and specular term.
     cdata = (r(1) * ones (nr, nc)
              + r(2) * diffuse  (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv)
              + r(3) * specular (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv, vv, r(4)));
 
-    set (tmp, "cdata", cdata ./ sum (r(1:3)));
+    set (htmp, "cdata", cdata ./ sum (r(1:3)));
 
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! [X,Y,Z]=sombrero;
-%! colormap(copper);
-%! surfl(X,Y,Z);
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! colormap (copper (64));
+%! surfl (X,Y,Z);
 %! shading interp;
 
 %!demo
-%! [X,Y,Z]=sombrero;
-%! colormap(copper);
-%! [az, el] = view;
-%! surfl(X,Y,Z,[az+225,el],[0.2 0.6 0.4 25]);
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! colormap (copper (64));
+%! [az, el] = view ();
+%! surfl (X,Y,Z, [az+225,el], [0.2 0.6 0.4 25]);
 %! shading interp;
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -136,19 +136,26 @@ function [Nx, Ny, Nz] = surfnorm (vararg
   else
     Nx = nx;
     Ny = ny;
     Nz = nz;
   endif
 
 endfunction
 
+
 %!demo
-%! colormap (jet (64))
-%! [x, y, z] = peaks(10);
+%! clf;
+%! colormap ('default');
+%! [x, y, z] = peaks (10);
 %! surfnorm (x, y, z);
 
 %!demo
-%! surfnorm (peaks(10));
+%! clf;
+%! colormap ('default');
+%! surfnorm (peaks (10));
 
 %!demo
-%! surfnorm (peaks(32));
-%! shading interp
+%! clf;
+%! colormap ('default');
+%! surfnorm (peaks (32));
+%! shading interp;
+
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,23 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{label})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{z}, @var{label})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{label}, @var{p1}, @var{v1}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} text (@var{x}, @var{y}, @var{z}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefn  {Function File} {} text (@var{x}, @var{y}, @var{label})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} text (@dots{})
 ## Create a text object with text @var{label} at position @var{x},
 ## @var{y}, @var{z} on the current axes.  Property-value pairs following
 ## @var{label} may be used to specify the appearance of the text.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = text (varargin)
 
   nargs = nargin;
   offset = 0;
@@ -117,134 +121,135 @@ function h = text (varargin)
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! ha = {"left", "center", "right"};
-%! va = {"bottom", "middle", "top"};
+%! clf;
+%! ha = {'left', 'center', 'right'};
+%! va = {'bottom', 'middle', 'top'};
 %! x = [0.25 0.5 0.75];
-%! y = [0.25 0.5 0.75];
+%! y = x;
 %! for t = 0:30:359;
 %!   for nh = 1:numel(ha)
 %!     for nv = 1:numel(va)
-%!       text (x(nh), y(nv), "Hello World", ...
-%!             "rotation", t, ...
-%!             "horizontalalignment", ha{nh}, ...
-%!             "verticalalignment", va{nv})
-%!     endfor
-%!   endfor
-%! endfor
-%! set (gca, "xtick", [0.25, 0.5, 0.75], ...
-%!           "xticklabel", ha, ...
-%!           "ytick", [0.25, 0.5, 0.75], ...
-%!           "yticklabel", va)
-%! axis ([0 1 0 1])
-%! xlabel ("horizontal alignment")
-%! ylabel ("vertical alignment")
-%! title ("text alignment and rotation (0:30:360 degrees)")
+%!       text (x(nh), y(nv), 'Hello World', ...
+%!             'rotation', t, ...
+%!             'horizontalalignment', ha{nh}, ...
+%!             'verticalalignment', va{nv});
+%!     end
+%!   end
+%! end
+%! set (gca, 'xtick', [0.25, 0.5, 0.75], ...
+%!           'xticklabel', ha, ...
+%!           'ytick', [0.25, 0.5, 0.75], ...
+%!           'yticklabel', va);
+%! axis ([0 1 0 1]);
+%! xlabel ('horizontal alignment');
+%! ylabel ('vertical alignment');
+%! title ('text alignment and rotation (0:30:360 degrees)');
 
 %!demo
-%! clf
-%! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
-%!                  "facecolor", "none", ...
-%!                  "facealpha", 0);
+%! clf;
+%! h = mesh (peaks, 'edgecolor', 0.7 * [1 1 1], ...
+%!                  'facecolor', 'none', ...
+%!                  'facealpha', 0);
 %! for t = 0:45:359;
-%!   text (25, 25, 0, "Vertical Alignment = Bottom", ...
-%!                    "rotation", t, ...
-%!                    "horizontalalignment", "left", ...
-%!                    "verticalalignment", "bottom")
-%! endfor
-%! caxis ([-100 100])
-%! title ("Vertically Aligned at Bottom")
+%!   text (25, 25, 0, 'Vertical Alignment = Bottom', ...
+%!                    'rotation', t, ...
+%!                    'horizontalalignment', 'left', ...
+%!                    'verticalalignment', 'bottom');
+%! end
+%! caxis ([-100 100]);
+%! title ('Vertically Aligned at Bottom');
 
 %!demo
-%! clf
-%! axis ([0 8 0 8])
-%! title (["1st title";"2nd title"])
-%! xlabel (["1st xlabel";"2nd xlabel"])
-%! ylabel (["1st ylabel";"2nd ylabel"])
-%! text (4, 4, {"Hello", "World"}, ...
-%!       "horizontalalignment", "center", ...
-%!       "verticalalignment", "middle")
-%! grid on
+%! clf;
+%! axis ([0 8 0 8]);
+%! title (['1st title';'2nd title']);
+%! xlabel (['1st xlabel';'2nd xlabel']);
+%! ylabel (['1st ylabel';'2nd ylabel']);
+%! text (4, 4, {'Hello', 'World'}, ...
+%!       'horizontalalignment', 'center', ...
+%!       'verticalalignment', 'middle');
+%! grid on;
 
 %!demo
-%! clf
-%! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
-%!                  "facecolor", "none", ...
-%!                  "facealpha", 0);
-%! title (["1st title";"2nd title"])
-%! xlabel (["1st xlabel";"2nd xlabel"])
-%! ylabel (["1st ylabel";"2nd ylabel"])
-%! zlabel (["1st zlabel";"2nd zlabel"])
-%! text (0, 0, 5, {"Hello", "World"}, ...
-%!       "horizontalalignment", "center", ...
-%!       "verticalalignment", "middle")
-%! hold on
-%! plot3 (0, 0, 5, "+k")
-%!
+%! clf;
+%! h = mesh (peaks (), 'edgecolor', 0.7 * [1 1 1], ...
+%!                     'facecolor', 'none', ...
+%!                     'facealpha', 0);
+%! title (['1st title';'2nd title']);
+%! xlabel (['1st xlabel';'2nd xlabel']);
+%! ylabel (['1st ylabel';'2nd ylabel']);
+%! zlabel (['1st zlabel';'2nd zlabel']);
+%! text (0, 0, 5, {'Hello', 'World'}, ...
+%!       'horizontalalignment', 'center', ...
+%!       'verticalalignment', 'middle');
+%! hold on;
+%! plot3 (0, 0, 5, '+k');
 
 %!demo
-%! clf
-%! h = text (0.5, 0.3, "char");
-%! assert ("char", class (get (h, "string")))
-%! h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
-%! assert ("char", class (get (h, "string")))
-%! h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
-%! assert ("cell", class (get (h, "string")))
-%! h = text (0.5, 0.8, "foobar");
-%! set (h, "string", 1:3)
-%! h = text ([0.1, 0.1], [0.3, 0.4], "one string & two objects");
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
-%! h = text ([0.1, 0.1], [0.5, 0.6], {"one cellstr & two objects"});
-%! assert ("cell", class (get (h(1), "string")))
-%! assert ("cell", class (get (h(2), "string")))
-%! h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr 1 object 1", "cellstr 2 object 2"});
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
-%! h = text ([0.1, 0.1], [0.1, 0.2], ["1st string & 1st object"; "2nd string & 2nd object"]);
-%! assert ("char", class (get (h(1), "string")))
-%! assert ("char", class (get (h(2), "string")))
-%! h = text (0.7, 0.6, "single string");
-%! assert ("char", class (get (h, "string")))
-%! h = text (0.7, 0.5, {"single cell-string"});
-%! assert ("cell", class (get (h, "string")))
-%! xlabel (1:2)
-%! ylabel (1:2)
-%! title (1:2)
+%! clf;
+%! h = text (0.5, 0.3, 'char');
+%! assert ('char', class (get (h, 'string')));
+%! h = text (0.5, 0.4, ['char row 1'; 'char row 2']);
+%! assert ('char', class (get (h, 'string')));
+%! h = text (0.5, 0.6, {'cell2str (1,1)', 'cell2str (1,2)'; 'cell2str (2,1)', 'cell2str (2,2)'});
+%! assert ('cell', class (get (h, 'string')));
+%! h = text (0.5, 0.8, 'foobar');
+%! set (h, 'string', 1:3);
+%! h = text ([0.1, 0.1], [0.3, 0.4], 'one string & two objects');
+%! assert ('char', class (get (h(1), 'string')));
+%! assert ('char', class (get (h(2), 'string')));
+%! h = text ([0.1, 0.1], [0.5, 0.6], {'one cellstr & two objects'});
+%! assert ('cell', class (get (h(1), 'string')));
+%! assert ('cell', class (get (h(2), 'string')));
+%! h = text ([0.1, 0.1], [0.7, 0.8], {'cellstr 1 object 1', 'cellstr 2 object 2'});
+%! assert ('char', class (get (h(1), 'string')));
+%! assert ('char', class (get (h(2), 'string')));
+%! h = text ([0.1, 0.1], [0.1, 0.2], ['1st string & 1st object'; '2nd string & 2nd object']);
+%! assert ('char', class (get (h(1), 'string')));
+%! assert ('char', class (get (h(2), 'string')));
+%! h = text (0.7, 0.6, 'single string');
+%! assert ('char', class (get (h, 'string')));
+%! h = text (0.7, 0.5, {'single cell-string'});
+%! assert ('cell', class (get (h, 'string')));
+%! xlabel (1:2);
+%! ylabel (1:2);
+%! title (1:2);
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = text (0.5, 0.3, "char");
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
-%!   assert ("cell", class (get (h, "string")))
+%!   assert ("cell", class (get (h, "string")));
 %!   h = text (0.5, 0.8, "foobar");
-%!   set (h, "string", 1:3)
+%!   set (h, "string", 1:3);
 %!   h = text ([0.1, 0.1], [0.3, 0.4], "one string & two objects");
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.5, 0.6], {"one cellstr & two objects"});
-%!   assert ("cell", class (get (h(1), "string")))
-%!   assert ("cell", class (get (h(2), "string")))
+%!   assert ("cell", class (get (h(1), "string")));
+%!   assert ("cell", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.7, 0.8], {"cellstr 1 object 1", "cellstr 2 object 2"});
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text ([0.1, 0.1], [0.1, 0.2], ["1st string & 1st object"; "2nd string & 2nd object"]);
-%!   assert ("char", class (get (h(1), "string")))
-%!   assert ("char", class (get (h(2), "string")))
+%!   assert ("char", class (get (h(1), "string")));
+%!   assert ("char", class (get (h(2), "string")));
 %!   h = text (0.7, 0.6, "single string");
-%!   assert ("char", class (get (h, "string")))
+%!   assert ("char", class (get (h, "string")));
 %!   h = text (0.7, 0.5, {"single cell-string"});
-%!   assert ("cell", class (get (h, "string")))
+%!   assert ("cell", class (get (h, "string")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -16,17 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} title (@var{string})
 ## @deftypefnx {Function File} {} title (@var{string}, @var{p1}, @var{v1}, @dots{})
 ## @deftypefnx {Function File} {} title (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} title (@dots{})
-## Create a title object and return a handle to it.
+## Create a title object for a plot.
+##
+## The optional return value @var{h} is a graphics handle to the created object.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = title (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
 
@@ -37,43 +39,45 @@ function retval = title (varargin)
   tmp = __axis_label__ (h, "title", varargin{:});
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
-%!demo
-%! clf ();
-%! ax=axes();
-%! xl = get(ax,"title");
-%! title("Testing title")
-%! assert(get(xl,"string"),"Testing title")
 
 %!demo
-%! clf ();
+%! clf;
+%! ax = axes ();
+%! xl = get (ax,'title');
+%! title ('Testing title');
+%! assert (get (xl, 'string'), 'Testing title');
+
+%!demo
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xl = get(gca (), "title");
-%! title("Testing title")
-%! assert(get(xl,"string"),"Testing title")
+%! xl = get (gca (), 'title');
+%! title ('Testing title');
+%! assert (get (xl, 'string'), 'Testing title');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   ax=axes();
-%!   xl = get(ax,"title");
-%!   title("Testing title")
-%!   assert(get(xl,"string"),"Testing title")
+%!   ax = axes();
+%!   xl = get (ax,"title");
+%!   title ("Testing title");
+%!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
-%!   xl = get(gca (), "title");
-%!   title("Testing title")
-%!   assert(get(xl,"string"),"Testing title")
+%!   xl = get (gca (), "title");
+%!   title ("Testing title");
+%!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,18 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
 ## Plot a triangular mesh in 3D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned
 ## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
-## handle of the plot.
+## @code{(@var{x}, @var{y})}.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{triplot, trisurf, delaunay3}
 ## @end deftypefn
 
 function h = trimesh (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
@@ -50,18 +51,19 @@ function h = trimesh (tri, x, y, z, vara
       h = handle;
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! old_state = rand ("state");
-%! restore_state = onCleanup (@() rand ("state", old_state));
-%! rand ("state", 10);
+%! clf;
+%! old_state = rand ('state');
+%! restore_state = onCleanup (@() rand ('state', old_state));
+%! rand ('state', 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trimesh (tri, x(:), y(:), z(:));
 
diff --git a/scripts/plot/triplot.m b/scripts/plot/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/triplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,18 +18,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} triplot (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} triplot (@var{tri}, @var{x}, @var{y}, @var{linespec})
 ## @deftypefnx {Function File} {@var{h} =} triplot (@dots{})
 ## Plot a triangular mesh in 2D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned from
 ## @code{delaunay}.  If given, @var{linespec} determines the properties
-## to use for the lines.  The output argument @var{h} is the graphic handle
-## of the plot.
+## to use for the lines. 
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, trimesh, trisurf, delaunay}
 ## @end deftypefn
 
 function h = triplot (tri, x, y, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
@@ -42,17 +43,18 @@ function h = triplot (tri, x, y, varargi
   if (nargout > 0)
     h = handle;
   endif
 
 endfunction
 
 
 %!demo
-%! old_state = rand ("state");
-%! restore_state = onCleanup (@() rand ("state", old_state));
-%! rand ("state", 2);
+%! clf;
+%! old_state = rand ('state');
+%! restore_state = onCleanup (@() rand ('state', old_state));
+%! rand ('state', 2);
 %! N = 20;
 %! x = rand (N, 1);
 %! y = rand (N, 1);
 %! tri = delaunay (x, y);
 %! triplot (tri, x, y);
 
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,18 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trisurf (@dots{})
 ## Plot a triangular surface in 3D@.  The variable @var{tri} is the triangular
 ## meshing of the points @code{(@var{x}, @var{y})} which is returned
 ## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
-## handle of the plot.
+## @code{(@var{x}, @var{y})}.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{triplot, trimesh, delaunay3}
 ## @end deftypefn
 
 function h = trisurf (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
@@ -67,39 +68,71 @@ function h = trisurf (tri, x, y, z, vara
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! old_state = rand ("state");
-%! restore_state = onCleanup (@() rand ("state", old_state));
-%! rand ("state", 10);
+%! clf;
+%! colormap ('default');
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, 'facecolor', 'interp');
+%! axis tight;
+%! zlim auto;
+%! title (sprintf ('facecolor = %s', get (h, 'facecolor')));
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! N = 31;
+%! [x, y] = meshgrid (1:N);
+%! tri = delaunay (x, y);
+%! z = peaks (N);
+%! h = trisurf (tri, x, y, z, 'facecolor', 'flat');
+%! axis tight;
+%! zlim auto;
+%! title (sprintf ('facecolor = %s', get (h, 'facecolor')));
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! old_state = rand ('state');
+%! restore_state = onCleanup (@() rand ('state', old_state));
+%! rand ('state', 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trisurf (tri, x(:), y(:), z(:));
 
 %!demo
+%! clf;
+%! colormap ('default');
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z)
+%! trisurf (tri, x, y, z);
 
 %!demo
+%! clf;
+%! colormap ('default');
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z, "facecolor", "interp")
+%! trisurf (tri, x, y, z, 'facecolor', 'interp');
 
 %!demo
+%! clf;
+%! colormap ('default');
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
-%! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k")
+%! trisurf (tri, x, y, z, 'facecolor', 'interp', 'edgecolor', 'k');
 
diff --git a/scripts/plot/uicontextmenu.m b/scripts/plot/uicontextmenu.m
--- a/scripts/plot/uicontextmenu.m
+++ b/scripts/plot/uicontextmenu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uicontrol.m b/scripts/plot/uicontrol.m
--- a/scripts/plot/uicontrol.m
+++ b/scripts/plot/uicontrol.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -53,14 +53,15 @@ function dirname = uigetdir (init_path =
 
   if (!isdir (init_path))
     init_path = fileparts (init_path);
   endif
   dirname = feval (funcname, init_path, dialog_name);
 
 endfunction
 
+
 %!demo
-%! uigetdir(pwd, "Select Directory")
+%! uigetdir (pwd, 'Select Directory');
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -93,19 +93,20 @@ function [retfile, retpath, retindex] = 
     outargs{i} = defaultvals{i};
   endfor
 
   idx1 = idx2 = [];
   if (length (varargin) > 0)
     for i = 1 : length (varargin)
       val = varargin{i};
       if (ischar (val))
-        if (strncmpi (val, "multiselect", 11))
+        val = tolower (val);
+        if (strncmp (val, "multiselect", 11))
           idx1 = i;
-        elseif (strncmpi (val, "position", 8))
+        elseif (strncmp (val, "position", 8))
           idx2 = i;
         endif
       endif
     endfor
   endif
 
   stridx = [idx1, idx2, 0];
   if (length (stridx) > 1)
@@ -180,14 +181,15 @@ function [retfile, retpath, retindex] = 
       endif
     endfor
   endif
 
   [retfile, retpath, retindex] = feval (funcname, outargs{:});
 
 endfunction
 
+
 %!demo
-%! uigetfile({"*.gif;*.png;*.jpg", "Supported Picture Formats"})
+%! uigetfile ({'*.gif;*.png;*.jpg', 'Supported Picture Formats'});
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1);
+
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -84,54 +84,66 @@ function hui = uimenu (varargin)
   tmp = __go_uimenu__ (h, args{:});
 
   if (nargout > 0)
     hui = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! surfl(peaks);
-%! colormap(copper);
-%! shading("interp");
-%! f = uimenu("label", "&File", "accelerator", "f");
-%! e = uimenu("label", "&Edit", "accelerator", "e");
-%! uimenu(f, "label", "Close", "accelerator", "q", "callback", "close (gcf)");
-%! uimenu(e, "label", "Toggle &Grid", "accelerator", "g", "callback", "grid (gca)");
+%! clf;
+%! surfl (peaks);
+%! colormap (copper (64));
+%! shading ('interp');
+%! f = uimenu ('label', '&File', 'accelerator', 'f');
+%! e = uimenu ('label', '&Edit', 'accelerator', 'e');
+%! uimenu (f, 'label', 'Close', 'accelerator', 'q', 'callback', 'close (gcf)');
+%! uimenu (e, 'label', 'Toggle &Grid', 'accelerator', 'g', 'callback', 'grid (gca)');
 
-%!test
+%!testif HAVE_FLTK
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ui = uimenu ("label", "mylabel");
 %!   assert (findobj (hf, "type", "uimenu"), ui);
 %!   assert (get (ui, "label"), "mylabel");
 %!   assert (get (ui, "checked"), "off");
 %!   assert (get (ui, "separator"), "off");
 %!   assert (get (ui, "enable"), "on");
 %!   assert (get (ui, "position"), 9);
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
 %% check for top level menus file, edit, and help
-%!test
+%!testif HAVE_FLTK
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uif = findall (hf, "label", "&file");
-%!   assert (ishghandle (uif))
+%!   assert (ishghandle (uif));
 %!   uie = findall (hf, "label", "&edit");
-%!   assert (ishghandle (uie))
+%!   assert (ishghandle (uie));
 %!   uih = findall (hf, "label", "&help");
-%!   assert (ishghandle (uih))
+%!   assert (ishghandle (uih));
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%!test
+%!testif HAVE_FLTK
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uie = findall (hf, "label", "&edit");
 %!   myui = uimenu (uie, "label", "mylabel");
-%!   assert (ancestor (myui, "uimenu", "toplevel"), uie)
+%!   assert (ancestor (myui, "uimenu", "toplevel"), uie);
 %! unwind_protect_cleanup
 %!   close (hf);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
+
diff --git a/scripts/plot/uipanel.m b/scripts/plot/uipanel.m
--- a/scripts/plot/uipanel.m
+++ b/scripts/plot/uipanel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uipushtool.m b/scripts/plot/uipushtool.m
--- a/scripts/plot/uipushtool.m
+++ b/scripts/plot/uipushtool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Kai Habel
+## Copyright (C) 2010-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -115,14 +115,15 @@ function [retfile, retpath, retindex] = 
       print_usage ();
     endif
   endif
 
   [retfile, retpath, retindex] = feval (funcname, outargs{:});
 
 endfunction
 
+
 %!demo
-%! uiputfile({"*.gif;*.png;*.jpg", "Supported Picture Formats"})
+%! uiputfile ({'*.gif;*.png;*.jpg', 'Supported Picture Formats'});
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/uiresume.m b/scripts/plot/uiresume.m
--- a/scripts/plot/uiresume.m
+++ b/scripts/plot/uiresume.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -24,18 +24,18 @@
 ## with handle @var{h}, this function does nothing.
 ## @seealso{uiwait}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function uiresume (h)
 
-  if (! ishandle (h) || ! strcmp (get (h, "type"), "figure"))
-    error ("uiresume: invalid figure handle");
+  if (! isfigure (h))
+    error ("uiresume: invalid figure handle H");
   endif
 
   try
     uiwait_state = get (h, "__uiwait_state__");
     if (strcmp (uiwait_state, "active"))
       set (h, "__uiwait_state__", "triggered");
     endif
   catch
diff --git a/scripts/plot/uitoggletool.m b/scripts/plot/uitoggletool.m
--- a/scripts/plot/uitoggletool.m
+++ b/scripts/plot/uitoggletool.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uitoolbar.m b/scripts/plot/uitoolbar.m
--- a/scripts/plot/uitoolbar.m
+++ b/scripts/plot/uitoolbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/uiwait.m b/scripts/plot/uiwait.m
--- a/scripts/plot/uiwait.m
+++ b/scripts/plot/uiwait.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 Michael Goffioul
+## Copyright (C) 2012 Michael Goffioul
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -42,33 +42,33 @@ function uiwait (varargin)
 
   h = [];
   timeout = [];
 
   if (nargin == 0)
     h = get (0, "currentfigure");
   else
     h = varargin{1};
-    if (! ishandle (h) || ! strcmp (get (h, "type"), "figure"))
-      error ("uiwait: invalid figure handle");
+    if (! isfigure (h))
+      error ("uiwait: invalid figure handle H");
     endif
     if (nargin > 1)
       timeout = varargin{2};
     endif
   endif
 
   if (! isempty (h))
     unwind_protect
       try
         addproperty ("__uiwait_state__", h, "radio", "none|{active}|triggered");
       catch
         if (! strcmp (get (h, "__uiwait_state__"), "none"))
           error ("uiwait: an active uiwait call for this figure already exists");
         endif
-	set (h, "__uiwait_state__", "active");
+        set (h, "__uiwait_state__", "active");
       end_try_catch
       waitfor_args = {h, "__uiwait_state__", "triggered"};
       if (! isempty (timeout))
         waitfor_args(end+1:end+2) = {"timeout", timeout};
       endif
       waitfor (waitfor_args{:});
     unwind_protect_cleanup
       if (ishandle (h) && isprop (h, "__uiwait_state__"))
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/waitbar.m b/scripts/plot/waitbar.m
--- a/scripts/plot/waitbar.m
+++ b/scripts/plot/waitbar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@var{frac}, @var{msg})
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@dots{}, "FigureProperty", "Value", @dots{})
 ## @deftypefnx {Function File} {} waitbar (@var{frac})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar}, @var{msg})
 ## Return a handle @var{h} to a new waitbar object.  The waitbar is
 ## filled to fraction @var{frac} which must be in the range [0, 1].  The
 ## optional message @var{msg} is centered and displayed above the waitbar.
-## The appearance of the waitbar figure window can be configured by passing 
+## The appearance of the waitbar figure window can be configured by passing
 ## property/value pairs to the function.
 ## 
 ## When called with a single input the current waitbar, if it exists, is
 ## updated to the new value @var{frac}.  If there are multiple outstanding
 ## waitbars they can be updated individually by passing the handle @var{hwbar}
 ## of the specific waitbar to modify.
 ## @end deftypefn
 
@@ -87,18 +87,22 @@ function retval = waitbar (varargin)
 
   if (h)
     p = findobj (h, "type", "patch");
     set (p, "xdata", [0; frac; frac; 0]);
     ax = findobj (h, "type", "axes");
     if (ischar (msg) || iscellstr (msg))
       th = get (ax, "title");
       curr_msg = get (th, "string");
+      ## graphics handles always store data as column vectors
+      if (iscellstr (msg))
+        msg = msg(:);  
+      endif
       cmp = strcmp (msg, curr_msg);
-      if (all (cmp(:)))
+      if (! all (cmp(:)))
         set (th, "string", msg);
       endif
     endif
   else
     h = __go_figure__ (NaN, "position", [250, 500, 400, 100],
                        "numbertitle", "off",
                        "toolbar", "none", "menubar", "none",
                        "integerhandle", "off",
@@ -127,56 +131,56 @@ function retval = waitbar (varargin)
 
   ## If there were no errors, update current waitbar.
   curr_waitbar = h;
 
 endfunction
 
 
 %!demo
-%! h = waitbar (0, "0.00%");
+%! h = waitbar (0, '0.00%');
 %! for i = 0:0.01:1
-%!   waitbar (i, h, sprintf ("%.2f%%", 100*i));
-%! endfor
+%!   waitbar (i, h, sprintf ('%.2f%%', 100*i));
+%! end
 %! close (h);
 
 %!demo
-%! h = waitbar (0, "please wait...");
+%! h = waitbar (0, 'please wait...');
 %! for i = 0:0.01:0.6
 %!   waitbar (i);
-%! endfor
-%! i = 0.3
-%! waitbar (i, h, "don't you hate taking a step backward?")
+%! end
+%! i = 0.3;
+%! waitbar (i, h, 'don''t you hate taking a step backward?');
 %! pause (0.5);
 %! for i = i:0.005:0.7
 %!   waitbar (i, h);
-%! endfor
-%! waitbar (i, h, "or stalling?")
+%! end
+%! waitbar (i, h, 'or stalling?');
 %! pause (1);
 %! for i = i:0.003:0.8
-%!   waitbar (i, h, "just a little longer now")
-%! endfor
+%!   waitbar (i, h, 'just a little longer now');
+%! end
 %! for i = i:0.001:1
-%!   waitbar (i, h, "please don't be impatient")
-%! endfor
+%!   waitbar (i, h, 'please don''t be impatient');
+%! end
 %! close (h);
 
 %!demo
-%! h1 = waitbar (0, "Waitbar #1");
-%! h2 = waitbar (0, "Waitbar #2");
-%! h2pos = get (h2, "position");
-%! h2pos(1) += h2pos(3) + 50;
-%! set (h2, "position", h2pos);
+%! h1 = waitbar (0, 'Waitbar #1');
+%! h2 = waitbar (0, 'Waitbar #2');
+%! h2pos = get (h2, 'position');
+%! h2pos(1) = h2pos(1) + (h2pos(3) + 50);
+%! set (h2, 'position', h2pos);
 %! pause (0.5);
 %! for i = 1:4
 %!   waitbar (i/4, h1);
 %!   pause (0.5);
 %!   waitbar (i/4, h2);
 %!   pause (0.5);
-%! endfor
+%! end
 %! pause (0.5);
 %! close (h1);
 %! close (h2);
 
 %% Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
diff --git a/scripts/plot/waitforbuttonpress.m b/scripts/plot/waitforbuttonpress.m
--- a/scripts/plot/waitforbuttonpress.m
+++ b/scripts/plot/waitforbuttonpress.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Petr Mikulik
+## Copyright (C) 2004-2012 Petr Mikulik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,20 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} xlabel (@var{h}, @var{string})
 ## @deftypefnx {Function File} {@var{h} =} xlabel (@dots{})
 ## @deftypefnx {Function File} {} ylabel (@dots{})
 ## @deftypefnx {Function File} {} zlabel (@dots{})
 ## Specify x-, y-, or z-axis labels for the current axis.  If @var{h} is
-## specified then label the axis defined by @var{h}.  The optional return
-## value @var{h} provides a handle to the created label.
-## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, title}
+## specified then label the axis defined by @var{h}.
+##
+## The optional return value @var{h} is a graphics handle to the created object.
+## @seealso{title, text}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = xlabel (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
@@ -43,19 +43,21 @@ function retval = xlabel (varargin)
                         "color", get (h, "xcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   x = xlabel ("xlabel_string");
-%!   assert (get(gca, "xlabel"), x);
-%!   assert (get(x, "type"), "text");
-%!   assert (get(x, "visible"), "on");
-%!   assert (get(x, "string"), "xlabel_string");
+%!   assert (get (gca, "xlabel"), x);
+%!   assert (get (x, "type"), "text");
+%!   assert (get (x, "visible"), "on");
+%!   assert (get (x, "string"), "xlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,16 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @c List other forms of function in documentation index
+## @findex ylim
+## @findex zlim
+##
 ## @deftypefn  {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
@@ -40,44 +44,44 @@
 function retval = xlim (varargin)
   ret = __axes_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! xlim ([0.2, 0.8]);
-%! title ("xlim is [0.2, 0.8]");
+%! title ('xlim is [0.2, 0.8]');
 %! assert (xlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! xlim ('auto');
-%! title ("xlim is auto");
-%! assert (xlim ("mode"), "auto");
+%! title ('xlim is auto');
+%! assert (xlim ('mode'), 'auto');
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xlim ([0.2, 0.8]);
-%! title ("xlim is [0.2, 0.8]");
+%! title ('xlim is [0.2, 0.8]');
 %! assert (xlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xlim ('auto');
-%! title ("xlim is auto");
-%! assert (xlim ("mode"), "auto");
-
+%! title ('xlim is auto');
+%! assert (xlim ('mode'), 'auto');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   xlim ([0, 1.1]);
 %!   assert (get (gca, "xlim"), [0, 1.1], eps);
 %!   assert (xlim ("mode"), "manual");
@@ -89,8 +93,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = plot3 ([0,1.1], [0,1], [0, 1]);
 %!   assert (get (gca, "xlim"), [0, 1.4], eps);
 %!   assert (xlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -37,19 +37,21 @@ function retval = ylabel (varargin)
                         "color", get (h, "ycolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   y = ylabel ("ylabel_string");
-%!   assert (get(gca, "ylabel"), y);
-%!   assert (get(y, "type"), "text");
-%!   assert (get(y, "visible"), "on");
-%!   assert (get(y, "string"), "ylabel_string");
+%!   assert (get (gca, "ylabel"), y);
+%!   assert (get (y, "type"), "text");
+%!   assert (get (y, "visible"), "on");
+%!   assert (get (y, "string"), "ylabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -40,43 +40,44 @@
 function retval = ylim (varargin)
   ret = __axes_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! ylim ([0.2, 0.8]);
-%! title ("ylim is [0.2, 0.8]");
+%! title ('ylim is [0.2, 0.8]');
 %! assert (ylim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! ylim ('auto');
-%! title ("ylim is auto");
-%! assert (ylim ("mode"), "auto");
+%! title ('ylim is auto');
+%! assert (ylim ('mode'), 'auto');
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! ylim ([0.2, 0.8]);
-%! title ("ylim is [0.2, 0.8]");
+%! title ('ylim is [0.2, 0.8]');
 %! assert (ylim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! ylim ('auto');
-%! title ("ylim is auto");
-%! assert (ylim ("mode"), "auto");
+%! title ('ylim is auto');
+%! assert (ylim ('mode'), 'auto');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   limy = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   ylim (limy);
 %!   assert (get (gca, "ylim"), limy, eps);
@@ -89,8 +90,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1.1], [0, 1]);
 %!   assert (get (gca, "ylim"), [0, 1.4], eps);
 %!   assert (ylim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -37,32 +37,34 @@ function retval = zlabel (varargin)
                         "color", get (h, "zcolor"));
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
-%!   assert (get(gca, "zlabel"), z);
-%!   assert (get(z, "type"), "text");
-%!   assert (get(z, "visible"), "off");
-%!   assert (get(z, "string"), "zlabel_string");
+%!   assert (get (gca, "zlabel"), z);
+%!   assert (get (z, "type"), "text");
+%!   assert (get (z, "visible"), "off");
+%!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! plot3 (0, 0, 0);
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
-%!   assert (get(gca, "zlabel"), z);
-%!   assert (get(z, "type"), "text");
-%!   assert (get(z, "visible"), "off");
-%!   assert (get(z, "string"), "zlabel_string");
+%!   assert (get (gca, "zlabel"), z);
+%!   assert (get (z, "type"), "text");
+%!   assert (get (z, "visible"), "off");
+%!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -40,43 +40,44 @@
 function retval = zlim (varargin)
   ret = __axes_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! zlim ([0.2, 0.8]);
-%! title ("zlim is [0.2, 0.8]");
+%! title ('zlim is [0.2, 0.8]');
 %! assert (zlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! zlim ('auto');
-%! title ("zlim is auto");
-%! assert (zlim ("mode"), "auto");
+%! title ('zlim is auto');
+%! assert (zlim ('mode'), 'auto');
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! zlim ([0.2, 0.8]);
-%! title ("zlim is [0.2, 0.8]");
+%! title ('zlim is [0.2, 0.8]');
 %! assert (zlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! zlim ('auto');
-%! title ("zlim is auto");
-%! assert (zlim ("mode"), "auto");
+%! title ('zlim is auto');
+%! assert (zlim ('mode'), 'auto');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   limz = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   zlim (limz);
 %!   assert (get (gca, "zlim"), limz, eps);
@@ -89,8 +90,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0, 1.1]);
 %!   assert (get (gca, "zlim"), [0, 1.4], eps);
 %!   assert (zlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -46,18 +46,17 @@
 ##     |       .            .        .       .             .      |
 ##     |_      0            0      @dots{}       1             0     _|
 ## @end group
 ## @end smallexample
 ##
 ## @end ifnottex
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
-## @seealso{poly, roots, residue, conv, deconv, polyval, polyderiv,
-## polyint}
+## @seealso{roots, poly, eig}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -31,17 +31,17 @@
 ## @table @asis
 ## @item @var{shape} = "full"
 ## Return the full convolution.  (default)
 ##
 ## @item @var{shape} = "same"
 ## Return the central part of the convolution with the same size as @var{a}.
 ## @end table
 ##
-## @seealso{deconv, fftconv, conv2, poly}
+## @seealso{deconv, conv2, convn, fftconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b, shape = "full")
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,17 +21,17 @@
 ## Deconvolve two vectors.
 ##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
 ##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
 ## a remainder polynomial of lowest order.
-## @seealso{conv, poly, roots, residue, polyval, polyderiv, polyint}
+## @seealso{conv, residue}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{breaks}, @var{coefs}, @var{d})
 ##
-## Construct a piece-wise polynomial (pp) structure from sample points
+## Construct a piecewise polynomial (pp) structure from sample points
 ## @var{breaks} and coefficients @var{coefs}.  @var{breaks} must be a vector of
 ## strictly increasing values.  The number of intervals is given by
 ## @code{@var{ni} = length (@var{breaks}) - 1}.
 ## When @var{m} is the polynomial order @var{coefs} must be of
 ## size: @var{ni} x @var{m} + 1.
 ##
 ## The i-th row of @var{coefs},
 ## @code{@var{coefs} (@var{i},:)}, contains the coefficients for the polynomial
@@ -35,17 +35,17 @@
 ## @var{coefs} may also be a multi-dimensional array, specifying a vector-valued
 ## or array-valued polynomial.  In that case the polynomial order is defined
 ## by the length of the last dimension of @var{coefs}.
 ## The size of first dimension(s) are given by the scalar or
 ## vector @var{d}.  If @var{d} is not given it is set to @code{1}.
 ## In any case @var{coefs} is reshaped to a 2-D matrix of
 ## size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
-## @seealso{unmkpp, ppval, spline}
+## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
   # check number of arguments
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
@@ -74,39 +74,41 @@ function pp = mkpp (x, P, d)
     pp.order /= prod (d);
   endif
 
   dim_vec = [pp.pieces * prod(pp.dim), pp.order];
   pp.coefs = reshape (P, dim_vec);
 
 endfunction
 
+
 %!demo # linear interpolation
-%! x=linspace(0,pi,5)';
-%! t=[sin(x),cos(x)];
-%! m=diff(t)./(x(2)-x(1));
-%! b=t(1:4,:);
-%! pp = mkpp(x, [m(:),b(:)]);
-%! xi=linspace(0,pi,50);
-%! plot(x,t,"x",xi,ppval(pp,xi));
-%! legend("control","interp");
+%! x = linspace (0,pi,5)';
+%! t = [sin(x), cos(x)];
+%! m = diff (t) ./ (x(2)-x(1));
+%! b = t(1:4,:);
+%! pp = mkpp (x, [m(:),b(:)]);
+%! xi = linspace (0,pi,50);
+%! plot (x,t,"x", xi,ppval (pp,xi));
+%! legend ("control","interp");
 
 %!shared b,c,pp
-%! b = 1:3; c = 1:24; pp=mkpp(b,c);
-%!assert (pp.pieces,2);
-%!assert (pp.order,12);
-%!assert (pp.dim,1);
-%!assert (size(pp.coefs),[2,12]);
-%! pp=mkpp(b,c,2);
-%!assert (pp.pieces,2);
-%!assert (pp.order,6);
-%!assert (pp.dim,2);
-%!assert (size(pp.coefs),[4,6]);
-%! pp=mkpp(b,c,3);
-%!assert (pp.pieces,2);
-%!assert (pp.order,4);
-%!assert (pp.dim,3);
-%!assert (size(pp.coefs),[6,4]);
-%! pp=mkpp(b,c,[2,3]);
-%!assert (pp.pieces,2);
-%!assert (pp.order,2);
-%!assert (pp.dim,[2,3]);
-%!assert (size(pp.coefs),[12,2]);
+%! b = 1:3; c = 1:24; pp = mkpp (b,c);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 12);
+%!assert (pp.dim, 1);
+%!assert (size (pp.coefs), [2,12]);
+%! pp = mkpp(b,c,2);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 6);
+%!assert (pp.dim, 2);
+%!assert (size (pp.coefs), [4,6]);
+%! pp = mkpp(b,c,3);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 4);
+%!assert (pp.dim, 3);
+%!assert (size (pp.coefs), [6,4]);
+%! pp = mkpp(b,c,[2,3]);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 2);
+%!assert (pp.dim, [2,3]);
+%!assert (size (pp.coefs), [12,2]);
+
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 Ben Abbott
+## Copyright (C) 2007-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,44 +12,45 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p})
-## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol})
-## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
-## Identify unique poles in @var{p} and associates their multiplicity,
-## ordering them from largest to smallest.
+## @deftypefn  {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p})
+## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol})
+## @deftypefnx {Function File} {[@var{multp}, @var{idxp}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
+## Identify unique poles in @var{p} and their associated multiplicity.  The
+## output is ordered from largest pole to smallest pole.
 ##
-## If the relative difference of the poles is less than @var{tol}, then
+## If the relative difference of two poles is less than @var{tol} then
 ## they are considered to be multiples.  The default value for @var{tol}
 ## is 0.001.
 ##
 ## If the optional parameter @var{reorder} is zero, poles are not sorted.
 ##
-## The value @var{multp} is a vector specifying the multiplicity of the
-## poles.  @var{multp}(:) refers to multiplicity of @var{p}(@var{indx}(:)).
+## The output @var{multp} is a vector specifying the multiplicity of the
+## poles.  @code{@var{multp}(n)} refers to the multiplicity of the Nth pole
+## @code{@var{p}(@var{idxp}(n))}.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## p = [2 3 1 1 2];
 ## [m, n] = mpoles(p);
 ##   @result{} m = [1; 1; 2; 1; 2]
 ##   @result{} n = [2; 5; 1; 4; 3]
 ##   @result{} p(n) = [3, 2, 2, 1, 1]
 ## @end group
 ## @end example
 ##
-## @seealso{poly, roots, conv, deconv, polyval, polyderiv, polyint, residue}
+## @seealso{residue, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: Sept 30, 2007
 
 function [multp, indx] = mpoles (p, tol, reorder)
 
   if (nargin < 1 || nargin > 3)
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Kai Habel
+## Copyright (C) 2001-2012 Kai Habel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,49 +14,47 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} pchip (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} pchip (@var{x}, @var{y}, @var{xi})
+## Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
+## points @var{x} and @var{y}.
 ##
-## Piecewise Cubic Hermite interpolating polynomial.  Called with two
-## arguments, the piecewise polynomial @var{pp} is returned, that may
-## later be used with @code{ppval} to evaluate the polynomial at
-## specific points.
+## If called with two arguments, return the piecewise polynomial @var{pp}
+## that may be used with @code{ppval} to evaluate the polynomial at specific
+## points.  When called with a third input argument, @code{pchip} evaluates
+## the pchip polynomial at the points @var{xi}.  The third calling form is
+## equivalent to @code{ppval (pchip (@var{x}, @var{y}), @var{xi})}.
 ##
 ## The variable @var{x} must be a strictly monotonic vector (either
-## increasing or decreasing).  While @var{y} can be either a vector or
-## an array.  In the case where @var{y} is a vector, it must have the
-## length @var{n}.  If @var{y} is an array, then the size of @var{y} must
+## increasing or decreasing) of length @var{n}.  @var{y} can be either a
+## vector or array.  If @var{y} is a vector then it must be the same length
+## @var{n} as @var{x}.  If @var{y} is an array then the size of @var{y} must
 ## have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
-## The array is then reshaped internally to a matrix where the leading
+## The array is reshaped internally to a matrix where the leading
 ## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
-## and each row in this matrix is then treated separately.  Note that this
-## is exactly the opposite treatment than @code{interp1} and is done
-## for compatibility.
-##
-## Called with a third input argument, @code{pchip} evaluates the
-## piecewise polynomial at the points @var{xi}.  There is an equivalence
-## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
-## @code{pchip (@var{x}, @var{y}, @var{xi})}.
+## and each row of this matrix is then treated separately.  Note that this
+## is exactly opposite to @code{interp1} but is done for @sc{matlab}
+## compatibility.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date: 9. mar 2001
 ##
 ## S_k = a_k + b_k*x + c_k*x^2 + d_k*x^3; (spline polynom)
@@ -122,50 +120,52 @@ function ret = pchip (x, y, xi)
   ret = mkpp (x, coeffs, szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
+
 %!demo
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %! xi = 0:0.01:8;
-%! yspline = spline(x,y,xi);
-%! ypchip = pchip(x,y,xi);
-%! title("pchip and spline fit to discontinuous function");
-%! plot(xi,yspline,xi,ypchip,"-",x,y,"+");
-%! legend ("spline","pchip","data");
+%! yspline = spline (x,y,xi);
+%! ypchip = pchip (x,y,xi);
+%! title ("pchip and spline fit to discontinuous function");
+%! plot (xi,yspline, xi,ypchip,"-", x,y,"+");
+%! legend ("spline", "pchip", "data");
 %! %-------------------------------------------------------------------
 %! % confirm that pchip agreed better to discontinuous data than spline
 
 %!shared x,y,y2,pp,yi1,yi2,yi3
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
-%!assert (pchip(x,y,x), y);
-%!assert (pchip(x,y,x'), y');
-%!assert (pchip(x',y',x'), y');
-%!assert (pchip(x',y',x), y);
-%!assert (isempty(pchip(x',y',[])));
-%!assert (isempty(pchip(x,y,[])));
-%!assert (pchip(x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x,y,x), y)
+%!assert (pchip (x,y,x'), y')
+%!assert (pchip (x',y',x'), y')
+%!assert (pchip (x',y',x), y)
+%!assert (isempty (pchip(x',y',[])))
+%!assert (isempty (pchip(x,y,[])))
+%!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!test
-%! x=(0:8)*pi/4;y=[sin(x);cos(x)];
-%! y2(:,:,1)=y;y2(:,:,2)=y+1;y2(:,:,3)=y-1;
-%! pp=pchip(x,shiftdim(y2,2));
-%! yi1=ppval(pp,(1:4)*pi/4);
-%! yi2=ppval(pp,repmat((1:4)*pi/4,[5,1]));
-%! yi3=ppval(pp,[pi/2,pi]);
-%!assert(size(pp.coefs),[48,4]);
-%!assert(pp.pieces,8);
-%!assert(pp.order,4);
-%!assert(pp.dim,[3,2]);
-%!assert(ppval(pp,pi),[0,-1;1,0;-1,-2],1e-14);
-%!assert(yi3(:,:,2),ppval(pp,pi),1e-14);
-%!assert(yi3(:,:,1),[1,0;2,1;0,-1],1e-14);
-%!assert(squeeze(yi1(1,2,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
-%!assert(size(yi2),[3,2,5,4]);
-%!assert(squeeze(yi2(1,2,3,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
\ No newline at end of file
+%! x = (0:8)*pi/4; y = [sin(x);cos(x)];
+%! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
+%! pp = pchip (x, shiftdim (y2,2));
+%! yi1 = ppval (pp, (1:4)*pi/4);
+%! yi2 = ppval (pp, repmat ((1:4)*pi/4, [5,1]));
+%! yi3 = ppval (pp, [pi/2,pi]);
+%!assert (size (pp.coefs), [48,4])
+%!assert (pp.pieces, 8)
+%!assert (pp.order, 4)
+%!assert (pp.dim, [3,2])
+%!assert (ppval (pp,pi), [0,-1;1,0;-1,-2], 1e-14)
+%!assert (yi3(:,:,2), ppval(pp,pi), 1e-14)
+%!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
+%!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
+%!assert (size (yi2), [3,2,5,4])
+%!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
+
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -33,23 +33,22 @@
 ## @result{} 0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
 ## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
-## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the coefficients
-## of the polynomial whose roots are the elements of @var{x}.  That is,
-## if @var{c} is a polynomial, then the elements of
-## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.
-## The vectors @var{c} and @var{d} are not identical, however, due to sorting
-## and numerical errors.
-## @seealso{eig, roots}
+## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the
+## coefficients of the polynomial whose roots are the elements of @var{x}. 
+## That is, if @var{c} is a polynomial, then the elements of @code{@var{d} =
+## roots (poly (@var{c}))} are contained in @var{c}.  The vectors @var{c} and
+## @var{d} are not identical, however, due to sorting and numerical errors.
+## @seealso{roots, eig}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function y = poly (x)
 
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Tony Richardson, Jaroslav Hajek
+## Copyright (C) 2009-2012 Tony Richardson, Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,17 +22,17 @@
 ## transformation.  If @var{f} is the vector representing the polynomial f(x),
 ## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
 ## representing:
 ##
 ## @example
 ## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
 ## @end example
 ##
-## @seealso{polyval}
+## @seealso{polyval, polyfit}
 ## @end deftypefn
 
 
 function g = polyaffine (f, mu)
 
    if (nargin != 2)
       print_usage ();
    endif
@@ -65,30 +65,24 @@ function g = polyaffine (f, mu)
      ii = lf:-1:1;
      g = g(ii) * (toeplitz (w) .* pascal (lf, -1));
      g = g(ii);
    endif
 
 endfunction
 
 
+%!demo
+%! f = [1/5 4/5 -7/5 -2];
+%! g = polyaffine (f, [1, 1.2]);
+%! x = linspace (-4,4,100);
+%! plot (x,polyval(f, x), x,polyval(g, x));
+%! legend ("original", "affine");
+%! axis ([-4 4 -3 5]);
+%! grid on;
+
 %!test
 %! f = [1/5 4/5 -7/5 -2];
-%!
 %! mu = [1, 1.2];
-%!
 %! g = polyaffine (f, mu);
-%!
-%! x = linspace (-4, 4, 100);
-%!
-%! assert (polyval(f, x, [], mu), polyval (g, x), 1e-10);
+%! x = linspace (-4,4,100);
+%! assert (polyval (f, x, [], mu), polyval (g, x), 1e-10);
 
-%!demo
-%! f = [1/5 4/5 -7/5 -2];
-%!
-%! g = polyaffine (f, [1, 1.2]);
-%!
-%! x = linspace (-4, 4, 100);
-%!
-%! plot(x, polyval (f, x), x, polyval (g, x));
-%!
-%! axis ([-4 4 -3 5]);
-%! grid ("on");
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -21,18 +21,17 @@
 ## @deftypefnx {Function File} {[@var{k}] =} polyder (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by the vector @var{p}.  If a pair of polynomials
 ## is given, return the derivative of the product @math{@var{a}*@var{b}}.
 ## If two inputs and two outputs are given, return the derivative of the
 ## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
 ## in @var{q} and the denominator in @var{d}.
-## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
-## filter, polygcd, polyval, polyvalm}
+## @seealso{polyint, polyval, polyreduce}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [q, d] = polyder (p, a)
 
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -16,21 +16,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
-## @var{n} that minimizes the least-squares-error of the fit.
+## @var{n} that minimizes the least-squares-error of the fit to the points
+## @code{[@var{x}, @var{y}]}.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
-## The second output is a structure containing the following fields:
+## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
 ## @item R
 ## Triangular factor R from the QR@tie{}decomposition.
 ##
 ## @item X
 ## The Vandermonde matrix used to compute the polynomial coefficients.
 ##
@@ -48,17 +49,17 @@
 ## statistical error limits of the predicted values.
 ##
 ## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
 ## stability of the fit.
-## @seealso{polyval, residue}
+## @seealso{polyval, polyaffine, roots, vander, zscore}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 
 function [p, s, mu] = polyfit (x, y, n)
 
@@ -72,17 +73,17 @@ function [p, s, mu] = polyfit (x, y, n)
     x = (x - mu(1)) / mu(2);
   endif
 
   if (! size_equal (x, y))
     error ("polyfit: X and Y must be vectors of the same size");
   endif
 
   if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == fix (n)))
-    error ("polyfit: N must be a nonnegative integer");
+    error ("polyfit: N must be a non-negative integer");
   endif
 
   y_is_row_vector = (rows (y) == 1);
 
   ## Reshape x & y into column vectors.
   l = numel (x);
   x = x(:);
   y = y(:);
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,34 +18,32 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
 ## Find the greatest common divisor of two polynomials.  This is equivalent
 ## to the polynomial found by multiplying together all the common roots.
 ## Together with deconv, you can reduce a ratio of two polynomials.
-## Tolerance defaults to @code{sqrt(eps)}.
+## The tolerance @var{tol} defaults to @code{sqrt(eps)}.
 ##
-## Note that this is a numerically unstable algorithm, and should not be used
-## on large polynomials.
+## @strong{Caution:} This is a numerically unstable algorithm and should not be used on large polynomials.
 ##
-## Example:
+## Example code:
 ##
 ## @example
 ## @group
 ## polygcd (poly(1:8), poly(3:12)) - poly(3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
 ## deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
 ##   - poly(1:2)
 ## @result{} [ 0, 0, 0 ]
 ## @end group
 ## @end example
-## @seealso{poly, polyint, polyderiv, polyreduce, roots, conv, deconv,
-## residue, filter, polyval, polyvalm}
+## @seealso{poly, roots, conv, deconv, residue}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
     if (nargin == 2)
       if (isa (a, "single") || isa (b, "single"))
         tol = sqrt (eps ("single"));
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,18 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyint (@var{p})
 ## @deftypefnx {Function File} {} polyint (@var{p}, @var{k})
 ## Return the coefficients of the integral of the polynomial whose
 ## coefficients are represented by the vector @var{p}.  The variable
 ## @var{k} is the constant of integration, which by default is set to zero.
-## @seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
-## filter, polyval, polyvalm}
+## @seealso{polyder, polyval}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function retval = polyint (p, k)
 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Auburn University.  All rights reserved.
+## Copyright (C) 1995-2012 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -26,21 +26,19 @@
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
-## and return it as a string or write it to the screen (if
-## @var{nargout} is zero).
-## @var{x} defaults to the string @code{"s"}.
-## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
-## filter, polyderiv, polyint}
+## and return it as a string or write it to the screen (if @var{nargout} is
+## zero).  @var{x} defaults to the string @code{"s"}.
+## @seealso{polyreduce}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,52 +15,44 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyreduce (@var{c})
 ## Reduce a polynomial coefficient vector to a minimum number of terms by
 ## stripping off any leading zeros.
-## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
-## polyvalm, polyderiv, polyint}
+## @seealso{polyout}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (c)
 
   if (nargin != 1)
     print_usage ();
-  endif
-
-  if (!isvector (c) || isempty (c))
+  elseif (! isvector (c) || isempty (c))
     error ("polyreduce: C must be a non-empty vector");
   endif
 
-  if (! isempty (c))
-
-    index = find (c != 0);
-
-    if (isempty (index))
+  idx = find (c != 0, 1);
 
-      p = 0;
-
-    else
-
-      p = c(index (1):length (c));
-
-    endif
-
+  if (isempty (idx))
+    p = 0;
+  else
+    p = c(idx:end);
   endif
 
 endfunction
 
-%!assert(all (all (polyreduce ([0, 0, 1, 2, 3]) == [1, 2, 3])));
 
-%!assert(all (all (polyreduce ([1, 2, 3, 0, 0]) == [1, 2, 3, 0, 0])));
+%!assert (polyreduce ([0, 0, 1, 2, 3]), [1, 2, 3])
+%!assert (polyreduce ([1, 2, 3, 0, 0]), [1, 2, 3, 0, 0])
+%!assert (polyreduce ([1, 0, 3]), [1, 0, 3])
+%!assert (polyreduce ([0, 0, 0]), 0)
 
-%!assert(all (all (polyreduce ([1, 0, 3]) == [1, 0, 3])));
+%!error polyreduce ()
+%!error polyreduce (1, 2)
+%!error <C must be a non-empty vector> polyreduce ([1, 2; 3, 4])
+%!error <C must be a non-empty vector> polyreduce ([])
 
-%!error polyreduce ([1, 2; 3, 4]);
-
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,25 +19,25 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
 ## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
 ## @var{mu} is present, evaluate the polynomial for
 ## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
+## 
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
 ## In addition to evaluating the polynomial, the second output
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
-## form `polyfit', must be present.
-## @seealso{polyfit, polyvalm, poly, roots, conv, deconv, residue, filter,
-## polyderiv, polyint}
+## from @code{polyfit}, must be supplied.
+## @seealso{polyvalm, polyaffine, polyfit, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [y, dy] = polyval (p, x, s = [], mu)
 
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -18,21 +18,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyvalm (@var{c}, @var{x})
 ## Evaluate a polynomial in the matrix sense.
 ##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
 ## matrix sense, i.e., matrix multiplication is used instead of element by
-## element multiplication as is used in polyval.
+## element multiplication as used in @code{polyval}.
 ##
 ## The argument @var{x} must be a square matrix.
-## @seealso{polyval, poly, roots, conv, deconv, residue, filter,
-## polyderiv, polyint}
+## @seealso{polyval, roots, poly}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {ppd =} ppder (pp, m)
+## @deftypefn  {Function File} {ppd =} ppder (pp)
+## @deftypefnx {Function File} {ppd =} ppder (pp, m)
 ## Compute the piecewise @var{m}-th derivative of a piecewise polynomial
-## struct @var{pp}.  If @var{m} is omitted the first derivate is
-## calculated.
+## struct @var{pp}.  If @var{m} is omitted the first derivative is calculated.
 ## @seealso{mkpp, ppval, ppint}
 ## @end deftypefn
 
 function ppd = ppder (pp, m)
 
   if ((nargin < 1) || (nargin > 2))
     print_usage ();
   elseif (nargin == 1)
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
+## Copyright (C) 2008-2012 VZLU Prague, a.s., Czech Republic
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,28 +13,23 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
-## Evaluate piece-wise polynomial structure @var{pp} at the points @var{xi}.
+## Evaluate the piecewise polynomial structure @var{pp} at the points @var{xi}.
 ## If @var{pp} describes a scalar polynomial function, the result is an
 ## array of the same shape as @var{xi}.
 ## Otherwise, the size of the result is @code{[pp.dim, length(@var{xi})]} if
 ## @var{xi} is a vector, or @code{[pp.dim, size(@var{xi})]} if it is a
 ## multi-dimensional array.
-##
-##, the dimensions are permuted as
-## in interp1, to
-## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]}
-## respectively.
-## @seealso{mkpp, unmkpp, spline, pchip, interp1}
+## @seealso{mkpp, unmkpp, spline, pchip}
 ## @end deftypefn
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2007 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -131,17 +131,17 @@
 ## @group
 ##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
 ##    ----- + ------- + ----- + s = --------------------------
 ##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## @seealso{poly, roots, conv, deconv, mpoles, polyval, polyderiv, polyint}
+## @seealso{mpoles, poly, roots, conv, deconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [r, p, k, e] = residue (b, a, varargin)
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -45,17 +45,17 @@
 ## p(x) = x^2 - 5.
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## @example
 ## @group
 ## c = [1, 0, -5];
-## roots(c)
+## roots (c)
 ## @result{}  2.2361
 ## @result{} -2.2361
 ## @end group
 ## @end example
 ##
 ## Note that the true result is
 ## @tex
 ## $\pm \sqrt{5}$
@@ -65,17 +65,17 @@
 ## @end ifnottex
 ## which is roughly
 ## @tex
 ## $\pm 2.2361$.
 ## @end tex
 ## @ifnottex
 ## @math{+/- 2.2361}.
 ## @end ifnottex
-## @seealso{compan}
+## @seealso{poly, compan, fzero}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2006 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -15,60 +15,60 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
+## Return the cubic spline interpolant of points @var{x} and @var{y}.
+## 
+## When called with two arguments, return the piecewise polynomial @var{pp}
+## that may be used with @code{ppval} to evaluate the polynomial at specific
+## points.  When called with a third input argument, @code{spline} evaluates
+## the spline at the points @var{xi}.  The third calling form @code{spline
+## (@var{x}, @var{y}, @var{xi})} is equivalent to @code{ppval (spline
+## (@var{x}, @var{y}), @var{xi})}.
 ##
-## Return the cubic spline interpolant of @var{y} at points @var{x}.
-## If called with two arguments, @code{spline} returns the piecewise
-## polynomial @var{pp} that may later be used with @code{ppval} to
-## evaluate the polynomial at specific points.
-## If called with a third input argument, @code{spline} evaluates the
-## spline at the points @var{xi}.  There is an equivalence
-## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
-## @code{spline (@var{x}, @var{y}, @var{xi})}.
-##
-## The variable @var{x} must be a vector of length @var{n}, and @var{y}
-## can be either a vector or array.  In the case where @var{y} is a
-## vector, it can have a length of either @var{n} or @code{@var{n} + 2}.
-## If the length of @var{y} is @var{n}, then the 'not-a-knot' end
-## condition is used.  If the length of @var{y} is @code{@var{n} + 2},
-## then the first and last values of the vector @var{y} are the values
-## of the first derivative of the cubic spline at the end-points.
+## The variable @var{x} must be a vector of length @var{n}.  @var{y} can be
+## either a vector or array.  If @var{y} is a vector it must have a length of
+## either @var{n} or @code{@var{n} + 2}.  If the length of @var{y} is
+## @var{n}, then the "not-a-knot" end condition is used.  If the length of
+## @var{y} is @code{@var{n} + 2}, then the first and last values of the
+## vector @var{y} are the values of the first derivative of the cubic spline
+## at the endpoints.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
 ## or
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n + 2].$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
 ## @end ifnottex
-## The array is then reshaped internally to a matrix where the leading
+## The array is reshaped internally to a matrix where the leading
 ## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row of this matrix is then treated separately.  Note that this
-## is exactly the opposite treatment than @code{interp1} and is done
-## for compatibility.
-## @seealso{ppval, mkpp, unmkpp}
+## is exactly opposite to @code{interp1} but is done for @sc{matlab}
+## compatibility.
+##
+## @seealso{pchip, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## This code is based on csape.m from octave-forge, but has been
 ## modified to use the sparse solver code in octave that itself allows
 ## special casing of tri-diagonal matrices, modified for NDArrays and
 ## for the treatment of vectors y 2 elements longer than x as complete
 ## splines.
 
@@ -102,17 +102,17 @@ function ret = spline (x, y, xi)
   complete = false;
   if (size (a, 1) == n + 2)
     complete = true;
     dfs = a(1,:);
     dfe = a(end,:);
     a = a(2:end-1,:);
   endif
 
-  if (~issorted (x))
+  if (! issorted (x))
     [x, idx] = sort(x);
     a = a(idx,:);
   endif
 
   b = c = zeros (size (a));
   h = diff (x);
   idx = ones (columns (a), 1);
 
@@ -239,47 +239,48 @@ function ret = spline (x, y, xi)
   ret = mkpp (x, cat (2, d, c, b, a), szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
+
 %!demo
-%! x = 0:10; y = sin(x);
-%! xspline = 0:0.1:10; yspline = spline(x,y,xspline);
-%! title("spline fit to points from sin(x)");
-%! plot(xspline,sin(xspline),"r",xspline,yspline,"g-",x,y,"b+");
-%! legend("original","interpolation","interpolation points");
+%! x = 0:10; y = sin (x);
+%! xspline = 0:0.1:10; yspline = spline (x,y,xspline);
+%! title ("spline fit to points from sin(x)");
+%! plot (xspline,sin(xspline),"r", xspline,yspline,"g-", x,y,"b+");
+%! legend ("original", "interpolation", "interpolation points");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!shared x,y,abserr
-%! x = [0:10]; y = sin(x); abserr = 1e-14;
-%!assert (spline(x,y,x), y, abserr);
-%!assert (spline(x,y,x'), y', abserr);
-%!assert (spline(x',y',x'), y', abserr);
-%!assert (spline(x',y',x), y, abserr);
-%!assert (isempty(spline(x',y',[])));
-%!assert (isempty(spline(x,y,[])));
-%!assert (spline(x,[y;y],x), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x,[y;y],x'), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x',[y;y],x), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x',[y;y],x'), [spline(x,y,x);spline(x,y,x)],abserr)
+%! x = [0:10]; y = sin (x); abserr = 1e-14;
+%!assert (spline (x,y,x), y, abserr)
+%!assert (spline (x,y,x'), y', abserr)
+%!assert (spline (x',y',x'), y', abserr)
+%!assert (spline (x',y',x), y, abserr)
+%!assert (isempty (spline (x',y',[])))
+%!assert (isempty (spline (x,y,[])))
+%!assert (spline (x,[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x,[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x',[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x',[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
 %! y = cos(x) + i*sin(x);
-%!assert (spline(x,y,x), y, abserr)
-%!assert (real(spline(x,y,x)), real(y), abserr);
-%!assert (real(spline(x,y,x.')), real(y).', abserr);
-%!assert (real(spline(x.',y.',x.')), real(y).', abserr);
-%!assert (real(spline(x.',y,x)), real(y), abserr);
-%!assert (imag(spline(x,y,x)), imag(y), abserr);
-%!assert (imag(spline(x,y,x.')), imag(y).', abserr);
-%!assert (imag(spline(x.',y.',x.')), imag(y).', abserr);
-%!assert (imag(spline(x.',y,x)), imag(y), abserr);
+%!assert (spline (x,y,x), y, abserr)
+%!assert (real (spline (x,y,x)), real (y), abserr)
+%!assert (real (spline (x,y,x.')), real (y).', abserr)
+%!assert (real (spline (x.',y.',x.')), real (y).', abserr)
+%!assert (real (spline (x.',y,x)), real (y), abserr)
+%!assert (imag (spline (x,y,x)), imag (y), abserr)
+%!assert (imag (spline (x,y,x.')), imag (y).', abserr)
+%!assert (imag (spline (x.',y.',x.')), imag (y).', abserr)
+%!assert (imag (spline (x.',y,x)), imag (y), abserr)
 %!test
 %! xnan = 5;
 %! y(x==xnan) = NaN;
 %! ok = ! isnan (y);
 %! assert (spline (x, y, x(ok)), y(ok), abserr);
 %!test
 %! ok = ! isnan (y);
 %! assert (! isnan (spline (x, y, x(!ok))));
@@ -298,8 +299,9 @@ endfunction
 %! [x,P] = unmkpp (pp);
 %! assert (norm (P-[3,-3,1,2]), 0, abserr);
 %!test
 %! x = [2,1];
 %! y = [1,2,3,4];
 %! pp = spline (x,y);
 %! [x,P] = unmkpp (pp);
 %! assert (norm (P-[7,-9,1,3]), 0, abserr);
+
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{p}, @var{n}, @var{k}, @var{d}] =} unmkpp (@var{pp})
 ##
 ## Extract the components of a piecewise polynomial structure @var{pp}.
-## These are as follows:
+## The components are:
 ##
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ##
 ## @item @var{p}
 ## Polynomial coefficients for points in sample interval.  @code{@var{p}
 ## (@var{i}, :)} contains the coefficients for the polynomial over
@@ -38,17 +38,17 @@
 ##
 ## @item @var{k}
 ## Order of the polynomial plus 1.
 ##
 ## @item @var{d}
 ## Number of polynomials defined for each interval.
 ## @end table
 ##
-## @seealso{mkpp, ppval, spline}
+## @seealso{mkpp, ppval, spline, pchip}
 ## @end deftypefn
 
 function [x, P, n, k, d] = unmkpp (pp)
 
   if (nargin != 1)
     print_usage ();
   endif
   if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/ispref.m b/scripts/prefs/ispref.m
--- a/scripts/prefs/ispref.m
+++ b/scripts/prefs/ispref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/private/loadprefs.m b/scripts/prefs/private/loadprefs.m
--- a/scripts/prefs/private/loadprefs.m
+++ b/scripts/prefs/private/loadprefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,32 +22,13 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = prefsfile ()
 
   retval = "~/.octave_prefs";
 
-  ## Transition users to new filename if necessary
-  ## FIXME: Delete before 3.6.0 release
-  oldname = tilde_expand ("~/.octave-prefs");
-  if (exist (oldname, "file"))
-    newname = tilde_expand (retval); 
-    if (exist (newname, "file"))
-      error (["Octave uses the file ~/.octave_prefs to store preferences.\n",...
-              "       The old file name was ~/.octave-prefs.\n",...
-              "       Both files exist."...
-              "  User must manually delete one of the files.\n"]);
-    endif
-    status = movefile (oldname, newname);
-    if (! status)
-      error (["Octave uses the file ~/.octave_prefs to store preferences.\n",
-             "        The old file name was ~/.octave-prefs.\n",
-             "        User must manually rename the old file to the new name.\n"]);
-    endif
-  endif
-
 endfunction
 
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
diff --git a/scripts/prefs/private/saveprefs.m b/scripts/prefs/private/saveprefs.m
--- a/scripts/prefs/private/saveprefs.m
+++ b/scripts/prefs/private/saveprefs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/rmpref.m b/scripts/prefs/rmpref.m
--- a/scripts/prefs/rmpref.m
+++ b/scripts/prefs/rmpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -52,30 +52,32 @@ function [c, ia, ib] = intersect (a, b, 
       b = unique (b, varargin{:});
     endif
 
     if (nargin > 2)
       c = [a; b];
       [c, ic] = sortrows (c);
       ii = find (all (c(1:end-1,:) == c(2:end,:), 2));
       c = c(ii,:);
+      len_a = rows (a);
     else
       c = [a(:); b(:)];
       [c, ic] = sort (c);               ## [a(:);b(:)](ic) == c
       if (iscellstr (c))
         ii = find (strcmp (c(1:end-1), c(2:end)));
       else
         ii = find (c(1:end-1) == c(2:end));
       endif
       c = c(ii);
+      len_a = length (a);
     endif
 
     if (nargout > 1)
       ia = ja(ic(ii));                  ## a(ia) == c
-      ib = jb(ic(ii+1) - length (a));   ## b(ib) == c
+      ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
     endif
 
     if (nargin == 2 && (size (b, 1) == 1 || size (a, 1) == 1))
       c = c.';
     endif
   endif
 
 endfunction
@@ -100,8 +102,14 @@ endfunction
 %! assert(ib,[3;1]);
 %! assert(a(ia,:),c);
 %! assert(b(ib,:),c);
 %!test
 %! a = [1 1 1 2 2 2];
 %! b = [1 2 3 4 5 6];
 %! c = intersect(a,b);
 %! assert(c, [1,2]);
+%!test
+%! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
+%! [b, ia, ib] = intersect(a, a, "rows");
+%! assert(b, a);
+%! assert(ia, [1:3]');
+%! assert(ib, [1:3]');
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Jaroslav Hajek
+## Copyright (C) 2010-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/set/private/validargs.m b/scripts/set/private/validargs.m
--- a/scripts/set/private/validargs.m
+++ b/scripts/set/private/validargs.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009-2010 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ## Copyright (C) 2000, 2006-2007 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2008-2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1997-2011 Vincent Cautaerts
+## Copyright (C) 1997-2012 Vincent Cautaerts
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 John W. Eaton
+## Copyright (C) 2002-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1997-2011 Vincent Cautaerts
+## Copyright (C) 1997-2012 Vincent Cautaerts
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ## Copyright (C) 2010 Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/rectangle_sw.m b/scripts/signal/private/rectangle_sw.m
--- a/scripts/signal/private/rectangle_sw.m
+++ b/scripts/signal/private/rectangle_sw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/triangle_lw.m b/scripts/signal/private/triangle_lw.m
--- a/scripts/signal/private/triangle_lw.m
+++ b/scripts/signal/private/triangle_lw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/private/triangle_sw.m b/scripts/signal/private/triangle_sw.m
--- a/scripts/signal/private/triangle_sw.m
+++ b/scripts/signal/private/triangle_sw.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Andreas Weingessel
+## Copyright (C) 1995-2012 Andreas Weingessel
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Bill Lash
+## Copyright (C) 2000-2012 Bill Lash
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006   Sylvain Pelissier   <sylvain.pelissier@gmail.com>
-## Copyright (C) 2011   Carlo de Falco
+## Copyright (C) 2012   Carlo de Falco
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Radek Salac
-## Copyright (C) 2011 Carlo de Falco
+## Copyright (C) 2008-2012 Radek Salac
+## Copyright (C) 2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -201,21 +201,22 @@ function [x, flag, relres, iter, resvec]
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
 %! % Solve system of A*x=b
-%! A = [5 -1 3;-1 2 -2;3 -2 3]
-%! b = [7;-1;4]
-%! [x, flag, relres, iter, resvec] = bicgstab(A, b)
+%! A = [5 -1 3;-1 2 -2;3 -2 3];
+%! b = [7;-1;4];
+%! [x, flag, relres, iter, resvec] = bicgstab (A, b)
 
 %!shared A, b, n, M1, M2
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2008-2011 Radek Salac
-## Copyright (C) 2011 Carlo de Falco
+## Copyright (C) 2008-2012 Radek Salac
+## Copyright (C) 2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -184,22 +184,21 @@ function [x, flag, relres, iter, resvec]
 
   else
     print_usage ();
   endif
 
 endfunction
 
 
-
 %!demo
 %! % Solve system of A*x=b
-%! A=[5 -1 3;-1 2 -2;3 -2 3]
-%! b=[7;-1;4]
-%! [a,b,c,d,e]=cgs(A,b)
+%! A = [5 -1 3;-1 2 -2;3 -2 3];
+%! b = [7;-1;4];
+%! [a,b,c,d,e] = cgs (A,b)
 
 %!shared A, b, n, M
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
@@ -218,8 +217,9 @@ endfunction
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Carlo de Falco
+## Copyright (C) 2009-2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at your
 ## option) any later version.
 ##
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -61,23 +61,23 @@ endfunction
 %! A = [0 1 0 0 0 0 0
 %!      1 0 1 1 0 0 0
 %!      0 1 0 0 0 0 0
 %!      0 1 0 0 1 0 0
 %!      0 0 0 1 0 1 1
 %!      0 0 0 0 1 0 0
 %!      0 0 0 0 1 0 0];
 %!
-%! xy = [1, 0
+%! xy = [1  , 0
 %!       1.5, 1
-%!       2, 0
+%!       2  , 0
 %!       2.5, 2
 %!       3.5, 1
-%!       3, 0
-%!       4, 0];
+%!       3  , 0
+%!       4  , 0];
 %!
 %! clf;
 %! gplot (A, xy, "o-");
 %! set (get (gca, ("children")), "markersize", 12);
 %! title ("gplot() of Binary Tree Adjacency matrix");
 
 %% Mark graphical function as tested by demo block
 %!assert (1);
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Piotr Krzyzanowski
+## Copyright (C) 2004-2012 Piotr Krzyzanowski
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pcg (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@dots{})
 ##
-## Solves the linear system of equations @code{@var{A} * @var{x} = @var{b}}
+## Solve the linear system of equations @code{@var{A} * @var{x} = @var{b}}
 ## by means of the Preconditioned Conjugate Gradient iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
@@ -384,150 +384,159 @@ function [x, flag, relres, iter, resvec,
   if (! matrix_positive_definite)
     flag = 3;
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
 endfunction
 
+
 %!demo
-%!
-%!      # Simplest usage of pcg (see also 'help pcg')
-%!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); y =  A \ b; #y is the true solution
-%!      x = pcg (A, b);
-%!      printf('The solution relative error is %g\n', norm (x - y) / norm (y));
-%!
-%!      # You shouldn't be afraid if pcg issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations
-%!      # of pcg to converge to (a very accurate, by the way) solution
+%!  # Simplest usage of pcg (see also 'help pcg')
+%! 
+%!  N = 10;
+%!  A = diag ([1:N]); b = rand (N, 1);
+%!  y = A \ b;  # y is the true solution
+%!  x = pcg (A, b);
+%!  printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
+%! 
+%!  # You shouldn't be afraid if pcg issues some warning messages in this
+%!  # example: watch out in the second example, why it takes N iterations
+%!  # of pcg to converge to (a very accurate, by the way) solution
+
 %!demo
-%!
-%!      # Full output from pcg, except for the eigenvalue estimates
-%!      # We use this output to plot the convergence history
-%!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); X =  A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcg (A, b);
-%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!      semilogy([0:iter], resvec / resvec(1),'o-g');
-%!      legend('relative residual');
+%!  # Full output from pcg, except for the eigenvalue estimates
+%!  # We use this output to plot the convergence history
+%! 
+%!  N = 10;
+%!  A = diag ([1:N]); b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec] = pcg (A, b);
+%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec / resvec(1), "o-g");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%!  legend ("relative residual");
+
 %!demo
-%!
-%!      # Full output from pcg, including the eigenvalue estimates
-%!      # Hilbert matrix is extremely ill conditioned, so pcg WILL have problems
-%!
-%!      N = 10;
-%!      A = hilb (N); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!      printf('Condition number estimate is %g\n', eigest(2) / eigest (1));
-%!      printf('Actual condition number is   %g\n', cond (A));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter], resvec,['o-g';'+-r']);
-%!      legend('absolute residual','absolute preconditioned residual');
+%!  # Full output from pcg, including the eigenvalue estimates
+%!  # Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
+%! 
+%!  N = 10;
+%!  A = hilb (N); b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
+%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  printf ("Actual condition number is   %g\n", cond (A));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  legend ("absolute residual", "absolute preconditioned residual");
+
 %!demo
 %!
-%!      # Full output from pcg, including the eigenvalue estimates
-%!      # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
-%!      # and that's the reasone we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner,
-%!      # which is the diagonal of A
+%!  # Full output from pcg, including the eigenvalue estimates
+%!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
+%!  # and that's the reason we need some preconditioner; here we take
+%!  # a very simple and not powerful Jacobi preconditioner,
+%!  # which is the diagonal of A
 %!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i=1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = rand (N, 1); X = A \ b; #X is the true solution
-%!      maxit = 80;
-%!      printf('System condition number is %g\n', cond (A));
-%!      # No preconditioner: the convergence is very slow!
+%!  N = 100;
+%!  A = zeros (N, N);
+%!  for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!    A(i:i+1, i:i+1) = [2 -1; -1 2];
+%!  endfor
+%!  b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  maxit = 80;
+%!  printf ("System condition number is %g\n", cond (A));
+%!  # No preconditioner: the convergence is very slow!
 %!
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%!      printf('System condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter], resvec(:,1), 'o-g');
-%!      legend('NO preconditioning: absolute residual');
-%!
-%!      pause(1);
-%!      # Test Jacobi preconditioner: it will not help much!!!
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
+%!  printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec(:,1), "o-g");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  legend ("NO preconditioning: absolute residual");
 %!
-%!      M = diag (diag (A)); # Jacobi preconditioner
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!      printf('JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      hold on;
-%!      semilogy([0:iter], resvec(:,1), 'o-r');
-%!      legend('NO preconditioning: absolute residual', ...
-%!             'JACOBI preconditioner: absolute residual');
+%!  pause (1);
+%!  # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!      pause(1);
-%!      # Test nonoverlapping block Jacobi preconditioner: it will help much!
+%!  M = diag (diag (A)); # Jacobi preconditioner
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!  printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  hold on;
+%!  semilogy ([0:iter], resvec(:,1), "o-r");
+%!  legend ("NO preconditioning: absolute residual", ...
+%!          "JACOBI preconditioner: absolute residual");
+%!
+%!  pause (1);
+%!  # Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
-%!      M = zeros (N, N); k = 4;
-%!      for i = 1 : k : N # form 1-D Laplacian matrix
-%!              M (i:i+k-1, i:i+k-1) = A (i:i+k-1, i:i+k-1);
-%!      endfor
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!      printf('BLOCK JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      semilogy ([0:iter], resvec(:,1),'o-b');
-%!      legend('NO preconditioning: absolute residual', ...
-%!             'JACOBI preconditioner: absolute residual', ...
-%!             'BLOCK JACOBI preconditioner: absolute residual');
-%!      hold off;
+%!  M = zeros (N, N); k = 4;
+%!  for i = 1 : k : N # form 1-D Laplacian matrix
+%!    M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
+%!  endfor
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!  printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  semilogy ([0:iter], resvec(:,1), "o-b");
+%!  legend ("NO preconditioning: absolute residual", ...
+%!          "JACOBI preconditioner: absolute residual", ...
+%!          "BLOCK JACOBI preconditioner: absolute residual");
+%!  hold off;
+
 %!test
-%!
-%!      #solve small diagonal system
+%! # solve small diagonal system
 %!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag] = pcg (A, b, [], N+1);
-%!      assert(norm (x - X) / norm (X), 0, 1e-10);
-%!      assert(flag, 0);
-%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcg (A, b, [], N+1);
+%! assert (norm (x - X) / norm (X), 0, 1e-10);
+%! assert (flag, 0);
+
 %!test
+%! # solve small indefinite diagonal system
+%! # despite A is indefinite, the iteration continues and converges
+%! # indefiniteness of A is detected
 %!
-%!      #solve small indefinite diagonal system
-%!      #despite A is indefinite, the iteration continues and converges
-%!      #indefiniteness of A is detected
-%!
-%!      N = 10;
-%!      A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag] = pcg (A, b, [], N+1);
-%!      assert(norm (x - X) / norm (X), 0, 1e-10);
-%!      assert(flag, 3);
-%!
+%! N = 10;
+%! A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcg (A, b, [], N+1);
+%! assert (norm (x - X) / norm (X), 0, 1e-10);
+%! assert (flag, 3);
+
 %!test
-%!
-%!      #solve tridiagonal system, do not converge in default 20 iterations
+%! # solve tridiagonal system, do not converge in default 20 iterations
 %!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
-%!      assert(flag);
-%!      assert(relres > 1.0);
-%!      assert(iter, 20); #should perform max allowable default number of iterations
-%!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!   A(i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
+%! assert (flag);
+%! assert (relres > 1.0);
+%! assert (iter, 20); # should perform max allowable default number of iterations
+
 %!test
+%! # solve tridiagonal system with 'perfect' preconditioner
+%! # which converges in one iteration, so the eigest does not
+%! # work and issues a warning
 %!
-%!      #solve tridiagonal system with 'prefect' preconditioner
-%!      #converges in one iteration, so the eigest does not work
-%!      #and issues a warning
-%!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
-%!      assert(norm (x - X) / norm (X), 0, 1e-6);
-%!      assert(flag, 0);
-%!      assert(iter, 1); #should converge in one iteration
-%!      assert(isnan (eigest), isnan ([NaN, NaN]));
-%!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!         A (i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
+%! assert (norm (x - X) / norm (X), 0, 1e-6);
+%! assert (flag, 0);
+%! assert (iter, 1); # should converge in one iteration
+%! assert (isnan (eigest), isnan ([NaN, NaN]));
+
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Piotr Krzyzanowski
+## Copyright (C) 2004-2012 Piotr Krzyzanowski
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pcr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
 ##
-## Solves the linear system of equations @code{@var{A} * @var{x} = @var{b}}
+## Solve the linear system of equations @code{@var{A} * @var{x} = @var{b}}
 ## by means of the Preconditioned Conjugate Residuals iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
@@ -105,17 +105,17 @@
 ##      A = sparse (diag (1:n));
 ##      b = rand (N, 1);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ##
 ## @example
-##   x = pcr(A, b)
+##   x = pcr (A, b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
 ##   function y = apply_a (x)
@@ -295,137 +295,148 @@ function [x, flag, relres, iter, resvec]
     if (nargout < 2)
       warning ("pcr: breakdown occurred:\n");
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
+
 %!demo
-%!
-%!      # Simplest usage of PCR (see also 'help pcr')
+%!  # Simplest usage of PCR (see also 'help pcr')
 %!
-%!      N = 20;
-%!      A = diag(linspace(-3.1,3,N)); b = rand(N,1); y = A\b; #y is the true solution
-%!      x = pcr(A,b);
-%!      printf('The solution relative error is %g\n', norm(x-y)/norm(y));
-%!
-%!      # You shouldn't be afraid if PCR issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations
-%!      # of PCR to converge to (a very accurate, by the way) solution
-%!demo
+%!  N = 20;
+%!  A = diag (linspace (-3.1,3,N)); b = rand (N,1);
+%!  y = A \ b;  # y is the true solution
+%!  x = pcr (A,b);
+%!  printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%!      # Full output from PCR
-%!      # We use this output to plot the convergence history
+%!  # You shouldn't be afraid if PCR issues some warning messages in this
+%!  # example: watch out in the second example, why it takes N iterations
+%!  # of PCR to converge to (a very accurate, by the way) solution
+
+%!demo
+%!  # Full output from PCR
+%!  # We use this output to plot the convergence history
 %!
-%!      N = 20;
-%!      A = diag(linspace(-3.1,30,N)); b = rand(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcr(A,b);
-%!      printf('The solution relative error is %g\n', norm(x-X)/norm(X));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!      semilogy([0:iter],resvec/resvec(1),'o-g;relative residual;');
+%!  N = 20;
+%!  A = diag (linspace(-3.1,30,N)); b = rand (N,1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec] = pcr (A,b);
+%!  printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%!  semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
+
 %!demo
-%!
-%!      # Full output from PCR
-%!      # We use indefinite matrix based on the Hilbert matrix, with one
-%!      # strongly negative eigenvalue
-%!      # Hilbert matrix is extremely ill conditioned, so is ours,
-%!      # and that's why PCR WILL have problems
+%!  # Full output from PCR
+%!  # We use indefinite matrix based on the Hilbert matrix, with one
+%!  # strongly negative eigenvalue
+%!  # Hilbert matrix is extremely ill conditioned, so is ours,
+%!  # and that's why PCR WILL have problems
 %!
-%!      N = 10;
-%!      A = hilb(N); A(1,1)=-A(1,1); b = rand(N,1); X = A\b; #X is the true solution
-%!      printf('Condition number of A is   %g\n', cond(A));
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],200);
-%!      if (flag == 3)
-%!        printf('PCR breakdown. System matrix is [close to] singular\n');
-%!      end
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter],resvec,'o-g;absolute residual;');
+%!  N = 10;
+%!  A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
+%!  X = A \ b;  # X is the true solution
+%!  printf ("Condition number of A is   %g\n", cond (A));
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
+%!  if (flag == 3)
+%!    printf ("PCR breakdown.  System matrix is [close to] singular\n");
+%!  end
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  semilogy ([0:iter], resvec, "o-g;absolute residual;");
+
 %!demo
+%!  # Full output from PCR
+%!  # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%!  # and here we have cond(A) = O(N^2)
+%!  # That's the reason we need some preconditioner; here we take
+%!  # a very simple and not powerful Jacobi preconditioner,
+%!  # which is the diagonal of A
 %!
-%!      # Full output from PCR
-%!      # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%!      # and here we have cond(A) = O(N^2)
-%!      # That's the reason we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner,
-%!      # which is the diagonal of A
-%!
-%!      # Note that we use here indefinite preconditioners!
+%!  # Note that we use here indefinite preconditioners!
 %!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      A = [A, zeros(size(A)); zeros(size(A)), -A];
-%!      b = rand(2*N,1); X = A\b; #X is the true solution
-%!      maxit = 80;
-%!      printf('System condition number is %g\n',cond(A));
-%!      # No preconditioner: the convergence is very slow!
+%!  N = 100;
+%!  A = zeros (N,N);
+%!  for i=1:N-1 # form 1-D Laplacian matrix
+%!    A(i:i+1,i:i+1) = [2 -1; -1 2];
+%!  endfor
+%!  A = [A, zeros(size(A)); zeros(size(A)), -A];
+%!  b = rand (2*N,1);
+%!  X = A \ b;  # X is the true solution
+%!  maxit = 80;
+%!  printf ("System condition number is %g\n", cond (A));
+%!  # No preconditioner: the convergence is very slow!
 %!
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit);
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter],resvec,'o-g;NO preconditioning: absolute residual;');
-%!
-%!      pause(1);
-%!      # Test Jacobi preconditioner: it will not help much!!!
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
-%!      M = diag(diag(A)); # Jacobi preconditioner
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!      hold on;
-%!      semilogy([0:iter],resvec,'o-r;JACOBI preconditioner: absolute residual;');
+%!  pause (1);
+%!  # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!      pause(1);
-%!      # Test nonoverlapping block Jacobi preconditioner: this one should give
-%!      # some convergence speedup!
+%!  M = diag (diag (A)); # Jacobi preconditioner
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%!  hold on;
+%!  semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
-%!      M = zeros(N,N);k=4;
-%!      for i=1:k:N # get k x k diagonal blocks of A
-%!              M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
-%!      endfor
-%!      M = [M, zeros(size(M)); zeros(size(M)), -M];
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!      semilogy([0:iter],resvec,'o-b;BLOCK JACOBI preconditioner: absolute residual;');
-%!      hold off;
+%!  pause (1);
+%!  # Test nonoverlapping block Jacobi preconditioner: this one should give
+%!  # some convergence speedup!
+%!
+%!  M = zeros (N,N); k = 4;
+%!  for i=1:k:N # get k x k diagonal blocks of A
+%!    M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
+%!  endfor
+%!  M = [M, zeros(size (M)); zeros(size(M)), -M];
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%!  semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
+%!  hold off;
+
 %!test
-%!
-%!      #solve small indefinite diagonal system
-%!
-%!      N = 10;
-%!      A = diag(linspace(-10.1,10,N)); b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag] = pcr(A,b,[],N+1);
-%!      assert(norm(x-X)/norm(X)<1e-10);
-%!      assert(flag,0);
+%! # solve small indefinite diagonal system
 %!
-%!test
-%!
-%!      #solve tridiagonal system, do not converge in default 20 iterations
-%!      #should perform max allowable default number of iterations
-%!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,1e-12);
-%!      assert(flag,1);
-%!      assert(relres>0.6);
-%!      assert(iter,20);
-%!
+%! N = 10;
+%! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcr (A,b,[],N+1);
+%! assert (norm (x-X) / norm (X) < 1e-10);
+%! assert (flag, 0);
+
 %!test
-%!
-%!      #solve tridiagonal system with 'prefect' preconditioner
-%!      #converges in one iteration
+%! # solve tridiagonal system, do not converge in default 20 iterations
+%! # should perform max allowable default number of iterations
 %!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter] = pcr(A,b,[],[],A,b);
-%!      assert(norm(x-X)/norm(X)<1e-6);
-%!      assert(relres<1e-6);
-%!      assert(flag,0);
-%!      assert(iter,1); #should converge in one iteration
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcr (A,b,1e-12);
+%! assert (flag, 1);
+%! assert (relres > 0.6);
+%! assert (iter, 20);
+
+%!test
+%! # solve tridiagonal system with "perfect" preconditioner
+%! # converges in one iteration
 %!
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter] = pcr (A,b,[],[],A,b);
+%! assert (norm (x-X) / norm(X) < 1e-6);
+%! assert (relres < 1e-6);
+%! assert (flag, 0);
+%! assert (iter, 1); # should converge in one iteration
+
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2004-2011 Paul Kienzle
-## Copyright (C) 2011 Jordi Guti√©rrez Hermoso
+## Copyright (C) 2004-2012 Paul Kienzle
+## Copyright (C) 2012 Jordi Guti√©rrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2004-2011 David Bateman and Andy Adler
-## Copyright (C) 2011 Jordi Guti√©rrez Hermoso
+## Copyright (C) 2004-2012 David Bateman and Andy Adler
+## Copyright (C) 2012 Jordi Guti√©rrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Andy Adler
+## Copyright (C) 1998-2012 Andy Adler
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 David Bateman
+## Copyright (C) 2006-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -236,51 +236,61 @@ function [u, s, v, flag] = svds (A, k, s
 
     if (nargout > 3)
       flag = norm (A*v - u*s, 1) > root2 * opts.tol * norm (A, 1);
     endif
   endif
 
 endfunction
 
-%!shared n, k, A, u, s, v, opts
+%!shared n, k, A, u, s, v, opts, rand_state, randn_state
 %! n = 100;
 %! k = 7;
-%! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
-%! [u,s,v] = svd(full(A));
-%! s = diag(s);
-%! [~, idx] = sort(abs(s));
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
+%! [u,s,v] = svd (full (A));
+%! s = diag (s);
+%! [~, idx] = sort (abs(s));
 %! s = s(idx);
-%! u = u(:,idx);
-%! v = v(:,idx);
-%! old_state1 = randn ("state");
-%! restore_state1 = onCleanup (@() randn ("state", old_state1));
-%! old_state2 = rand ("state");
-%! restore_state2 = onCleanup (@() rand ("state", old_state2));
-%! randn ('state', 42);      % Initialize to make normest function reproducible
-%! rand ('state', 42);
+%! u = u(:, idx);
+%! v = v(:, idx);
+%! randn_state = randn ("state");
+%! rand_state = rand ("state");
+%! randn ("state", 42);      % Initialize to make normest function reproducible
+%! rand ("state", 42);
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
 %!                         % to guarantee reproducible results
-%!test
-%! [u2,s2,v2,flag] = svds(A,k);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s(end:-1:end-k+1), 1e-10);
-%!testif HAVE_UMFPACK
-%! [u2,s2,v2,flag] = svds(A,k,0,opts);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s(k:-1:1), 1e-10);
-%!testif HAVE_UMFPACK
+%!
+%!testif HAVE_ARPACK
+%! [u2,s2,v2,flag] = svds (A,k);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s(end:-1:end-k+1), 1e-10);
+%!
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! [u2,s2,v2,flag] = svds (A,k,0,opts);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s(k:-1:1), 1e-10);
+%!
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! idx = floor(n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
-%! [u2,s2,v2,flag] = svds(A,k,sigma,opts);
-%! s2 = diag(s2);
-%! assert(flag,!1);
-%! assert(s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
-%!test
-%! [u2,s2,v2,flag] = svds(zeros (10), k);
-%! assert (isequal(u2, eye (10, k)) && isequal (s2, zeros(k)) && isequal (v2, eye(10, 7)));
-%!test
+%! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
+%! s2 = diag (s2);
+%! assert (flag, !1);
+%! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
+%!
+%!testif HAVE_ARPACK
+%! [u2,s2,v2,flag] = svds (zeros (10), k);
+%! assert (u2, eye (10, k));
+%! assert (s2, zeros (k));
+%! assert (v2, eye (10, 7));
+%!
+%!testif HAVE_ARPACK
 %! s = svds (speye (10));
 %! assert (s, ones (6, 1), 2*eps);
 
+%!test
+%! ## Restore random number generator seeds at end of tests
+%! rand ("state", rand_state);
+%! randn ("state", randn_state);
+
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ivana Varekova & Radek Salac
+## Copyright (C) 2008-2012 Ivana Varekova & Radek Salac
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Ivana Varekova
+## Copyright (C) 2005-2012 Ivana Varekova
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -191,15 +191,19 @@ function treeplot (tree, node_style = "k
   unwind_protect_cleanup
     if (! hold_is_on)
       hold ("off");
     endif
   end_unwind_protect
 
 endfunction
 
-%!demo
-%! % Plot a simple tree plot
-%! treeplot([2 4 2 0 6 4 6])
 
 %!demo
+%! clf;
+%! treeplot ([2 4 2 0 6 4 6]);
+%! % Plot a simple tree plot
+
+%!demo
+%! clf;
+%! treeplot ([2 4 2 0 6 4 6], "b+", "g");
 %! % Plot a simple tree plot defining the edge and node styles
-%! treeplot([2 4 2 0 6 4 6], "b+", "g")
+
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 Nicol N. Schraudolph
+## Copyright (C) 1998-2012 Nicol N. Schraudolph
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,18 +25,18 @@
 ## @code{gamma}.
 ## @seealso{prod, gamma}
 ## @end deftypefn
 
 function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != fix (n(:))))
-    error ("factorial: N must all be nonnegative integers");
+    error ("factorial: N must all be non-negative integers");
   endif
   x = round (gamma (n+1));
 endfunction
 
 %!assert (factorial(5), prod(1:5))
 %!assert (factorial([1,2;3,4]), [1,2;6,24])
 %!assert (factorial(70), exp(sum(log(1:70))), -128*eps)
-%!fail ('factorial(5.5)', "must all be nonnegative integers")
-%!fail ('factorial(-3)', "must all be nonnegative integers")
+%!fail ('factorial(5.5)', "must all be non-negative integers")
+%!fail ('factorial(-3)', "must all be non-negative integers")
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/lcm.m b/scripts/specfun/lcm.m
--- a/scripts/specfun/lcm.m
+++ b/scripts/specfun/lcm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Kai Habel
+## Copyright (C) 2000-2012 Kai Habel
 ## Copyright (C) 2008 Marco Caliari
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Rolf Fabian and Paul Kienzle
+## Copyright (C) 2001-2012 Rolf Fabian and Paul Kienzle
 ## Copyright (C) 2008 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -13,21 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+## @deftypefn  {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
+## @deftypefnx {Function File} {@var{c} =} nchoosek (@var{set}, @var{k})
 ##
-## Compute the binomial coefficient or all combinations of @var{n}.
-## If @var{n} is a scalar then, calculate the binomial coefficient
-## of @var{n} and @var{k}, defined as
+## Compute the binomial coefficient or all combinations of a set of items.
+##
+## If @var{n} is a scalar then calculate the binomial coefficient
+## of @var{n} and @var{k} which is defined as
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ##                = {n! \over k! (n-k)!}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
@@ -37,43 +39,69 @@
 ##  | n |    n (n-1) (n-2) @dots{} (n-k+1)       n!
 ##  |   |  = ------------------------- =  ---------
 ##  | k |               k!                k! (n-k)!
 ##  \   /
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
+## @noindent
+## This is the number of combinations of @var{n} items taken in groups of
+## size @var{k}.
 ##
-## If @var{n} is a vector generate all combinations of the elements
-## of @var{n}, taken @var{k} at a time, one row per combination.  The
-## resulting @var{c} has size @code{[nchoosek (length (@var{n}),
-## @var{k}), @var{k}]}.
+## If the first argument is a vector, @var{set}, then generate all
+## combinations of the elements of @var{set}, taken @var{k} at a time, with
+## one row per combination.  The result @var{c} has @var{k} columns and
+## @w{@code{nchoosek (length (@var{set}), @var{k})}} rows.
+##
+## For example:
+##
+## How many ways can three items be grouped into pairs?
 ##
-## @code{nchoosek} works only for non-negative integer arguments; use
-## @code{bincoeff} for non-integer scalar arguments and for using vector
-## arguments to compute many coefficients at once.
+## @example
+## @group
+## nchoosek (3, 2)
+##    @result{} 3
+## @end group
+## @end example
+##
+## What are the possible pairs?
 ##
-## @seealso{bincoeff}
+## @example
+## @group
+## nchoosek (1:3, 2)
+##    @result{}  1   2
+##        1   3
+##        2   3
+## @end group
+## @end example
+##
+## @code{nchoosek} works only for non-negative, integer arguments.  Use
+## @code{bincoeff} for non-integer and negative scalar arguments, or for
+## computing many binomial coefficients at once with vector inputs
+## for @var{n} or @var{k}.
+##
+## @seealso{bincoeff, perms}
 ## @end deftypefn
 
 ## Author: Rolf Fabian  <fabian@tu-cottbus.de>
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Author: Jaroslav Hajek
 
 function A = nchoosek (v, k)
 
   if (nargin != 2
-      || !isnumeric(k) || !isnumeric(v)
-      || !isscalar(k) || (!isscalar(v) && !isvector(v)))
+      || !isnumeric (k) || !isnumeric (v)
+      || !isscalar (k) || ! (isscalar (v) || isvector (v)))
     print_usage ();
   endif
-  if ((isscalar(v) && v < k) || k < 0
-      || k != round(k) || any (v < 0 || v != round(v)))
-    error ("nchoosek: args are nonnegative integers with V not less than K");
+  if (k < 0 || k != fix (k)
+      || (isscalar (v) && (v < k || v < 0 || v != fix (v))))
+    error ("nchoosek: args are non-negative integers with V not less than K");
   endif
 
   n = length (v);
 
   if (n == 1)
     ## Improve precision at next step.
     k = min (k, v-k);
     A = round (prod ((v-k+1:v)./(1:k)));
@@ -106,13 +134,24 @@ function A = nchoosek (v, k)
       l = cumsum (l);
       l = [1, 1 + l(1:n-k)];
     endfor
     clear cA b;
     A = A.';
   endif
 endfunction
 
-%!warning (nchoosek(100,45));
-%!error (nchoosek(100,45.5));
-%!error (nchoosek(100,145));
-%!assert (nchoosek(80,10), bincoeff(80,10))
-%!assert (nchoosek(1:5,3),[1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+
+%!assert (nchoosek (80,10), bincoeff (80,10))
+%!assert (nchoosek(1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+
+%% Test input validation
+%!warning nchoosek (100,45);
+%!error nchoosek ("100", 45)
+%!error nchoosek (100, "45")
+%!error nchoosek (100, ones (2,2))
+%!error nchoosek (repmat (100, [2 2]), 45)
+%!error nchoosek (100, -45)
+%!error nchoosek (100, 45.5)
+%!error nchoosek (100, 145)
+%!error nchoosek (-100, 45)
+%!error nchoosek (100.5, 45)
+
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2001-2011 Paul Kienzle
+## Copyright (C) 2001-2012 Paul Kienzle
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Paul Kienzle
+## Copyright (C) 1993-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 Dirk Laurie
+## Copyright (C) 1993-2012 Dirk Laurie
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Paul Kienzle
+## Copyright (C) 1999-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1993-2011 John W. Eaton
+## Copyright (C) 1993-2012 John W. Eaton
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/special-matrix/wilkinson.m b/scripts/special-matrix/wilkinson.m
--- a/scripts/special-matrix/wilkinson.m
+++ b/scripts/special-matrix/wilkinson.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1999-2011 Peter Ekberg
+## Copyright (C) 1999-2012 Peter Ekberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,23 +18,24 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __finish__ ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Check for the existence of the function/script, @file{finish}, in the
 ## path or current working directory and execute it.  This function is
-## intended to be excecuted upon a clean exit form Octave.  This is
+## intended to be excecuted upon a clean exit from Octave.  This is
 ## accomplished in the system script @file{startup/octaverc} by use of
-## the built-in function @code{onexit}.
+## the built-in function @code{atexit}.
 
 function __finish__ ()
 
   if (exist ("finish", "file"))
     ## No arg list here since finish might be a script.
     finish;
   endif
 
 endfunction
 
+
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 S√∏ren Hauberg
+## Copyright (C) 2009-2012 S√∏ren Hauberg
 ## Copyright (C) 2009 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ## Copyright (C) 2009-2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott
+## Copyright (C) 2008-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Ben Abbott and Jaroslav Hajek
+## Copyright (C) 2008-2012 Ben Abbott and Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/base/runlength.m
--- a/scripts/statistics/base/runlength.m
+++ b/scripts/statistics/base/runlength.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,61 +12,83 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} zscore (@var{x})
-## @deftypefnx {Function File} {} zscore (@var{x}, @var{dim})
+## @deftypefn  {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x})
+## @deftypefnx {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x}, @var{opt})
+## @deftypefnx {Function File} {[@var{z}, @var{mu}, @var{sigma}] =} zscore (@var{x}, @var{opt}, @var{dim})
 ## If @var{x} is a vector, subtract its mean and divide by its standard
-## deviation.
+## deviation. If the standard deviation is zero, divide by 1 instead.
+## The optional parameter @var{opt} determines the normalization to use
+## when computing the standard deviation and is the same as the
+## corresponding parameter for @code{std}.
 ##
 ## If @var{x} is a matrix, do the above along the first non-singleton
-## dimension.
-## If the optional argument @var{dim} is given, operate along this dimension.
-## @seealso{center}
+## dimension. If the third optional argument @var{dim} is given, operate
+## along this dimension.
+##
+## The mean and standard deviation along @var{dim} are given in @var{mu}
+## and @var{sigma} respectively.
+##
+## @seealso{mean, std, center}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Subtract mean and divide by standard deviation
 
-function z = zscore (x, dim)
+function [z, mu, sigma] = zscore (x, opt, dim)
 
-  if (nargin != 1 && nargin != 2)
+  if (nargin < 1 || nargin > 3 )
     print_usage ();
   endif
 
   if (! (isnumeric (x) || islogical (x)))
     error ("zscore: X must be a numeric vector or matrix");
   endif
 
+  if (nargin < 2)
+    opt = 0;
+  else
+    if (opt != 0 && opt != 1 || ! isscalar(opt))
+      error("zscore: OPT must be empty, 0, or 1");
+    endif
+  endif
+
   nd = ndims (x);
   sz = size (x);
-  if (nargin != 2)
+  if (nargin < 3)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("zscore: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
   if (n == 0)
     z = x;
   else
-    x = center (x, dim); # center also promotes integer to double for next line
-    z = zeros (sz, class (x));
-    s = std (x, [], dim);
+
+    if (isinteger (x))
+      x = double (x);
+    endif
+
+    mu = mean (x, dim);
+    sigma = std (x, opt, dim);
+    s = sigma;
     s(s==0) = 1;
-    z = bsxfun (@rdivide, x, s);
+    ## FIXME: Use normal broadcasting once we can disable that warning
+    z = bsxfun (@rdivide, bsxfun (@minus, x, mu), s);
   endif
 
 endfunction
 
 
 %!assert(zscore ([1,2,3]), [-1,0,1])
 %!assert(zscore (single([1,2,3])), single([-1,0,1]))
 %!assert(zscore (int8([1,2,3])), [-1,0,1])
@@ -74,11 +96,11 @@ endfunction
 %!assert(zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
 
 %% Test input validation
 %!error zscore ()
 %!error zscore (1, 2, 3)
 %!error zscore (['A'; 'B'])
 %!error zscore (1, ones(2,2))
 %!error zscore (1, 1.5)
-%!error zscore (1, 0)
+%!error zscore (1, 1, 0)
 %!error zscore (1, 3)
 
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ## Copyright (C) 2010 Christos Dimitrakakis
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2010-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2010-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1997-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1997-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
--- a/scripts/statistics/distributions/unidinv.m
+++ b/scripts/statistics/distributions/unidinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2007-2011 David Bateman
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2007-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 2005-2011 John W. Eaton
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2005-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2011 Rik Wehbring
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/private/logistic_regression_derivatives.m b/scripts/statistics/models/private/logistic_regression_derivatives.m
--- a/scripts/statistics/models/private/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/private/logistic_regression_derivatives.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/private/logistic_regression_likelihood.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -38,17 +38,17 @@ function [pval, chisq, df] = mcnemar_tes
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! (min (size (x)) > 1) && issquare (x))
     error ("mcnemar_test: X must be a square matrix of size > 1");
   elseif (! (all (all (x >= 0)) && all (all (x == fix (x)))))
-    error ("mcnemar_test: all entries of X must be nonnegative integers");
+    error ("mcnemar_test: all entries of X must be non-negative integers");
   endif
 
   r = rows (x);
   df = r * (r - 1) / 2;
   if (r == 2)
     num = max (abs (x - x') - 1, 0) .^ 2;
   else
     num = abs (x - x') .^ 2;
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Friedrich Leisch
+## Copyright (C) 1995-2012 Friedrich Leisch
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 Kurt Hornik
+## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Daniel Calvelo
+## Copyright (C) 2000-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Daniel Calvelo
+## Copyright (C) 1996-2012 Daniel Calvelo
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1998-2011 John W. Eaton
+## Copyright (C) 1998-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2002-2011 Rolf Fabian
+## Copyright (C) 2002-2012 Rolf Fabian
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1994-2011 John W. Eaton
+## Copyright (C) 1994-2012 John W. Eaton
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2009 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ## Copyright (C) 2003 Alois Schloegl
 ## Copyright (C) 2010 VZLU Prague
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
@@ -21,17 +21,16 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} strmatch (@var{s}, @var{A})
 ## @deftypefnx {Function File} {} strmatch (@var{s}, @var{A}, "exact")
 ## Return indices of entries of @var{A} which begin with the string @var{s}.
 ## The second argument @var{A} must be a string, character matrix, or a cell
 ## array of strings.  If the third argument @code{"exact"} is not given, then
 ## @var{s} only needs to match @var{A} up to the length of @var{s}.
 ## Trailing spaces and nulls in @var{s} and @var{A} are ignored when matching.
-## option.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## strmatch ("apple", "apple juice")
 ##      @result{} 1
 ##
@@ -39,17 +38,18 @@
 ##      @result{} [1; 2]
 ##
 ## strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
 ##      @result{} [1]
 ## @end group
 ## @end example
 ##
 ## @strong{Caution:} @code{strmatch} is scheduled for deprecation.  Use
-## @code{strcmpi} or @code{strncmpi} in all new code.
+## @code{strncmp} (normal case), or @code{strcmp} ("exact" case), or
+## @code{regexp} in all new code.
 ## @seealso{strfind, findstr, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Author: Paul Kienzle, Alois Schloegl
 ## Adapted-by: jwe
 
 function idx = strmatch (s, A, exact)
 
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Jaroslav Hajek
+## Copyright (C) 2009-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -128,17 +128,17 @@ function [tok, rem] = strtok (str, delim
       rem(midx) = tmp(2:2:end);
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! strtok("this is the life")
+%! strtok ("this is the life")
 %! % split at the first space, returning "this"
 
 %!demo
 %! s = "14*27+31"
 %! while (1)
 %!   [t, s] = strtok (s, "+-*/");
 %!   printf ("<%s>", t);
 %!   if (isempty (s))
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 William Poetra Yoga Hadisoeseno
+## Copyright (C) 2006-2012 William Poetra Yoga Hadisoeseno
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 Kurt Hornik
+## Copyright (C) 1996-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 Ben Abbott
+## Copyright (C) 2010-2012 Ben Abbott
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -34,28 +34,28 @@
 ## substrings of each other.  Otherwise, an error will be raised because the
 ## expansion of @var{str} is ambiguous.  All comparisons are case insensitive.
 ##
 ## The additional inputs @var{funcname}, @var{varname}, and @var{position}
 ## are optional and will make any generated validation error message more
 ## specific.
 ##
 ## Examples:
+## @c Set example in small font to prevent overfull line
 ##
-## @example
+## @smallexample
 ## @group
 ## validatestring ("r", @{"red", "green", "blue"@})
-##    @result{} "red"
+## @result{} "red"
 ##
 ## validatestring ("b", @{"red", "green", "blue", "black"@})
-##    @result{} error: validatestring: multiple unique matches were found for 'b':
-##       blue, black
+## @result{} error: validatestring: multiple unique matches were found for 'b':
+##    blue, black
 ## @end group
-## @end example
-##
+## @end smallexample
 ## 
 ## @seealso{strcmp, strcmpi}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function str = validatestring (str, strarray, varargin)
 
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,45 +18,43 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} assert (@var{cond})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected}, @var{tol})
 ##
-## Produces an error if the condition is not met.  @code{assert} can be
-## called in three different ways.
+## Produce an error if the specified condition is not met.  @code{assert} can
+## be called in three different ways.
 ##
 ## @table @code
 ## @item assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
-## error if @var{cond} is zero.  If called with a single argument a
-## generic error message.  With more than one argument, the additional
-## arguments are passed to the @code{error} function.
+## error if @var{cond} is zero.  When called with more than one argument the
+## additional arguments are passed to the @code{error} function.
 ##
 ## @item assert (@var{observed}, @var{expected})
 ## Produce an error if observed is not the same as expected.  Note that
-## observed and expected can be strings, scalars, vectors, matrices,
-## lists or structures.
+## @var{observed} and @var{expected} can be scalars, vectors, matrices,
+## strings, cell arrays, or structures.
 ##
-## @item assert(@var{observed}, @var{expected}, @var{tol})
-## Accept a tolerance when comparing numbers.
-## If @var{tol} is positive use it as an absolute tolerance, will produce an
-## error if
-## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
-## If @var{tol} is negative use it as a relative tolerance, will produce an
-## error if
-## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} *
-## @var{expected})}.  If @var{expected} is zero @var{tol} will always be used as
-## an absolute tolerance.
+## @item assert (@var{observed}, @var{expected}, @var{tol})
+## Produce an error if observed is not the same as expected but equality
+## comparison for numeric data uses a tolerance @var{tol}.
+## If @var{tol} is positive then it is an absolute tolerance which will produce
+## an error if @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
+## If @var{tol} is negative then it is a relative tolerance which will produce
+## an error if @code{abs(@var{observed} - @var{expected}) >
+## abs(@var{tol} * @var{expected})}.  If @var{expected} is zero @var{tol} will
+## always be interpreted as an absolute tolerance.
 ## @end table
-## @seealso{test, fail}
+## @seealso{test, fail, error}
 ## @end deftypefn
 
 ## FIXME: Output throttling: don't print out the entire 100x100 matrix,
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
 ## the message generation type specific.
 
 function assert (cond, varargin)
@@ -76,21 +74,21 @@ function assert (cond, varargin)
         error (varargin{:});
       endif
     endif
   else
     if (nargin < 2 || nargin > 3)
       print_usage ();
     endif
 
-    expected = varargin {1};
+    expected = varargin{1};
     if (nargin < 3)
       tol = 0;
     else
-      tol = varargin {2};
+      tol = varargin{2};
     endif
 
     if (exist ("argn") == 0)
       argn = " ";
     endif
 
     coda = "";
     iserror = 0;
@@ -113,18 +111,19 @@ function assert (cond, varargin)
       endif
 
     elseif (isstruct (expected))
       if (! isstruct (cond) || any (size (cond) != size (expected))
           || rows (fieldnames (cond)) != rows (fieldnames (expected)))
         iserror = 1;
       else
         try
-          empty = numel (cond) == 0;
-          normal = numel (cond) == 1;
+          #empty = numel (cond) == 0;
+          empty = isempty (cond);
+          normal = (numel (cond) == 1);
           for [v, k] = cond
             if (! isfield (expected, k))
               error ();
             endif
             if (empty)
               v = {};
             elseif (normal)
               v = {v};
@@ -141,17 +140,17 @@ function assert (cond, varargin)
     elseif (ndims (cond) != ndims (expected)
             || any (size (cond) != size (expected)))
       iserror = 1;
       coda = "Dimensions don't match";
 
     else
       if (nargin < 3)
         ## Without explicit tolerance, be more strict.
-        if (! strcmp(class (cond), class (expected)))
+        if (! strcmp (class (cond), class (expected)))
           iserror = 1;
           coda = cstrcat ("Class ", class (cond), " != ", class (expected));
         elseif (isnumeric (cond))
           if (issparse (cond) != issparse (expected))
             if (issparse (cond))
               iserror = 1;
               coda = "sparse != non-sparse";
             else
@@ -183,18 +182,18 @@ function assert (cond, varargin)
           coda = "NaNs don't match";
           ## Try to avoid problems comparing strange values like Inf+NaNi.
         elseif (any (isinf (A) != isinf (B))
                 || any (A(isinf (A) & ! isnan (A)) != B(isinf (B) & ! isnan (B))))
           iserror = 1;
           coda = "Infs don't match";
         else
           ## Check normal values.
-          A = A(finite (A));
-          B = B(finite (B));
+          A = A(isfinite (A));
+          B = B(isfinite (B));
           if (tol == 0)
             err = any (A != B);
             errtype = "values do not match";
           elseif (tol >= 0)
             err = max (abs (A - B));
             errtype = "maximum absolute error %g exceeds tolerance %g";
           else
             abserr = max (abs (A(B == 0)));
@@ -229,96 +228,110 @@ function assert (cond, varargin)
     if (! isempty (idx))
       str2 = str2 (idx(1):idx(end));
     endif
     msg = cstrcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
     if (! isempty (coda))
       msg = cstrcat (msg, "\n", coda);
     endif
     error ("%s", msg);
-    ## disp (msg);
-    ## error ("assertion failed");
   endif
+
 endfunction
 
-## empty
-%!assert([])
-%!assert(zeros(3,0),zeros(3,0))
-%!error assert(zeros(3,0),zeros(0,2))
-%!error assert(zeros(3,0),[])
-%!fail("assert(zeros(2,0,2),zeros(2,0))", "Dimensions don't match")
+
+## empty input
+%!assert ([])
+%!assert (zeros (3,0), zeros (3,0))
+%!error assert (zeros (3,0), zeros (0,2))
+%!error assert (zeros (3,0), [])
+%!error <Dimensions don't match> assert (zeros (2,0,2), zeros (2,0))
 
 ## conditions
-%!assert(isempty([]))
-%!assert(1)
-%!error assert(0)
-%!assert(ones(3,1))
-%!assert(ones(1,3))
-%!assert(ones(3,4))
-%!error assert([1,0,1])
-%!error assert([1;1;0])
-%!error assert([1,0;1,1])
+%!assert (isempty ([]))
+%!assert (1)
+%!error assert (0)
+%!assert (ones(3,1))
+%!assert (ones(1,3))
+%!assert (ones(3,4))
+%!error assert ([1,0,1])
+%!error assert ([1;1;0])
+%!error assert ([1,0;1,1])
+
+## scalars
+%!error assert (3, [3,3; 3,3])
+%!error assert ([3,3; 3,3], 3)
+%!assert (3, 3)
+%!assert (3+eps, 3, eps)
+%!assert (3, 3+eps, eps)
+%!error assert (3+2*eps, 3, eps)
+%!error assert (3, 3+2*eps, eps)
 
 ## vectors
-%!assert([1,2,3],[1,2,3]);
-%!assert([1;2;3],[1;2;3]);
-%!error assert([2;2;3],[1;2;3]);
-%!error assert([1,2,3],[1;2;3]);
-%!error assert([1,2],[1,2,3]);
-%!error assert([1;2;3],[1;2]);
-%!assert([1,2;3,4],[1,2;3,4]);
-%!error assert([1,4;3,4],[1,2;3,4])
-%!error assert([1,3;2,4;3,5],[1,2;3,4])
-
-## exceptional values
-%!assert([NaN, NA, Inf, -Inf, 1+eps, eps],[NaN, NA, Inf, -Inf, 1, 0],eps)
-%!error assert(NaN, 1)
-%!error assert(NA, 1)
-%!error assert(-Inf, Inf)
+%!assert ([1,2,3],[1,2,3]);
+%!assert ([1;2;3],[1;2;3]);
+%!error assert ([2;2;3],[1;2;3]);
+%!error assert ([1,2,3],[1;2;3]);
+%!error assert ([1,2],[1,2,3]);
+%!error assert ([1;2;3],[1;2]);
+%!assert ([1,2;3,4],[1,2;3,4]);
+%!error assert ([1,4;3,4],[1,2;3,4])
+%!error assert ([1,3;2,4;3,5],[1,2;3,4])
 
-## scalars
-%!error assert(3, [3,3; 3,3])
-%!error assert([3,3; 3,3], 3)
-%!assert(3, 3);
-%!assert(3+eps, 3, eps);
-%!assert(3, 3+eps, eps);
-%!error assert(3+2*eps, 3, eps);
-%!error assert(3, 3+2*eps, eps);
-
-## must give a little space for floating point errors on relative
-%!assert(100+100*eps, 100, -2*eps);
-%!assert(100, 100+100*eps, -2*eps);
-%!error assert(100+300*eps, 100, -2*eps);
-%!error assert(100, 100+300*eps, -2*eps);
-%!error assert(3, [3,3]);
-%!error assert(3,4);
+## must give a small tolerance for floating point errors on relative
+%!assert (100+100*eps, 100, -2*eps)
+%!assert (100, 100+100*eps, -2*eps)
+%!error assert (100+300*eps, 100, -2*eps)
+%!error assert (100, 100+300*eps, -2*eps)
+%!error assert (3, [3,3])
+%!error assert (3, 4)
 
 ## test relative vs. absolute tolerances
 %!test  assert (0.1+eps, 0.1,  2*eps);  # accept absolute
 %!error assert (0.1+eps, 0.1, -2*eps);  # fail relative
 %!test  assert (100+100*eps, 100, -2*eps);  # accept relative
 %!error assert (100+100*eps, 100,  2*eps);  # fail absolute
 
+## exceptional values
+%!assert ([NaN, NA, Inf, -Inf, 1+eps, eps], [NaN, NA, Inf, -Inf, 1, 0], eps)
+%!error assert (NaN, 1)
+%!error assert (NA, 1)
+%!error assert (-Inf, Inf)
+
+## strings
+%!assert ("dog", "dog")
+%!error assert ("dog", "cat")
+%!error assert ("dog", 3)
+%!error assert (3, "dog")
+
 ## structures
 %!shared x,y
 %! x.a = 1; x.b=[2, 2];
 %! y.a = 1; y.b=[2, 2];
-%!assert (x,y)
+%!assert (x, y)
 %!test y.b=3;
-%!error assert (x,y)
-%!error assert (3, x);
-%!error assert (x, 3);
+%!error assert (x, y)
+%!error assert (3, x)
+%!error assert (x, 3)
 %!test
 %! # Empty structures
 %! x = resize (x, 0, 1);
 %! y = resize (y, 0, 1);
 %! assert (x, y);
 
-## strings
-%!assert("dog","dog")
-%!error assert("dog","cat")
-%!error assert("dog",3);
-%!error assert(3,"dog");
+## cell arrays
+%!test
+%! x = {[3], [1,2,3]; 100+100*eps, "dog"};
+%! y = x;
+%! assert (x, y);
+%! y = x; y(1,1) = [2];
+%! fail ("assert (x, y)");
+%! y = x; y(1,2) = [0, 2, 3];
+%! fail ("assert (x, y)");
+%! y = x; y(2,1) = 101;
+%! fail ("assert (x, y)");
+%! y = x; y(2,2) = "cat";
+%! fail ("assert (x, y)");
 
-## check input validation
+%% Test input validation
 %!error assert
-%!error assert (1,2,3,4,5)
+%!error assert (1,2,3,4)
 
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -30,18 +30,19 @@
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
 ## example must also be introduced by the keyword 'demo' flush left to the
 ## prefix with no intervening spaces.  The remainder of the example can
 ## contain arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
 ##   %!demo
-##   %! t=0:0.01:2*pi; x = sin(t);
-##   %! plot (t,x)
+##   %! t = 0:0.01:2*pi;
+##   %! x = sin (t);
+##   %! plot (t,x);
 ##   %! %-------------------------------------------------
 ##   %! % the figure window shows one cycle of a sine wave
 ## @end group
 ## @end example
 ##
 ## Note that the code is displayed before it is executed, so a simple
 ## comment at the end suffices for labeling what is being shown.  It is
 ## generally not necessary to use @code{disp} or @code{printf} within the demo.
@@ -117,30 +118,40 @@ function demo (name, n)
     ## Pause between demos
     if (i > 1)
       input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
-      ## Use an environment without variables
-      eval (cstrcat ("function __demo__()\n", block, "\nendfunction"));
-      ## Display the code that will be executed before executing it
-      printf ("%s example %d:%s\n\n", name, doidx(i), block);
-      __demo__;
+      ## FIXME: need to check for embedded test functions, which cause
+      ## segfaults, until issues with subfunctions in functions are resolved.
+      embed_func = regexp (block, '^\s*function ', 'once', 'lineanchors');
+      if (isempty (embed_func))
+        ## Use an environment without variables
+        eval (cstrcat ("function __demo__()\n", block, "\nendfunction"));
+        ## Display the code that will be executed before executing it
+        printf ("%s example %d:%s\n\n", name, doidx(i), block);
+        __demo__;
+      else
+        error (["Functions embedded in %!demo blocks are not allowed.\n", ...
+                "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
+      endif
     catch
       ## Let the programmer know which demo failed.
       printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
   endfor
 
 endfunction
 
+
 %!demo
-%! t=0:0.01:2*pi; x = sin(t);
-%! plot (t,x)
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
+%! plot (t,x);
 %! %-------------------------------------------------
 %! % the figure window shows one cycle of a sine wave
 
 %!error demo ();
 %!error demo (1, 2, 3);
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -78,25 +78,29 @@ function [code_r, idx_r] = example (name
     for i = 1:length (doidx)
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
-%!## warning: don't modify the demos without modifying the tests!
+
+## WARNING: don't modify the demos without modifying the tests!
 %!demo
 %! example ('example');
+
 %!demo
+%! clf;
 %! t=0:0.01:2*pi; x = sin(t);
 %! plot (t,x)
 
 %!assert (example('example',1), "\n example ('example');");
 %!test
 %! [code, idx] = example ('example');
 %! assert (code, ...
-%!         "\n example ('example');\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
-%! assert (idx, [1, 23, 63]);
+%!         "\n example ('example');\n clf;\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
+%! assert (idx, [1, 23, 69]);
 
 %% Test input validation
-%!error example;
-%!error example('example', 3, 5)
+%!error example
+%!error example ('example', 3, 5)
+
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 John W. Eaton
+## Copyright (C) 2008-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -57,29 +57,36 @@ endfunction
 function run_all_demos (directory)
   dirinfo = dir (directory);
   flist = {dirinfo.name};
   for i = 1:numel (flist)
     f = flist{i};
     if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
       f = fullfile (directory, f);
       if (has_demos (f))
-        demo (f);
+        try
+          demo (f);
+        catch
+          printf ("error: %s\n\n", lasterror().message)
+        end_try_catch
         if (i != numel (flist))
           input ("Press <enter> to continue: ", "s");
         endif
       endif
     endif
   endfor
 endfunction
 
 function retval = has_demos (f)
   fid = fopen (f);
   if (f < 0)
     error ("rundemos: fopen failed: %s", f);
   else
     str = fscanf (fid, "%s");
     fclose (fid);
-    retval = findstr (str, "%!demo");
+    retval = strfind (str, "%!demo");
   endif
 endfunction
 
-%!error rundemos ("foo", 1);
+
+%!error rundemos ("foo", 1)
+%!error <DIRECTORY argument> rundemos ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
+
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -352,54 +352,55 @@ endfunction
 
 %% FIXME: Demos with declared functions do not work.  See bug #31815.
 %%        A workaround has been hacked by not declaring the functions
 %%        but using eval to create them in the proper context.
 %%        Unfortunately, we can't remove them from the user's workspace
 %%        because of another bug (#34497).
 %!demo
 %!  fstr_build_orig = cstrcat (
-%!  "function x = build_orig (n)\n",
-%!  "  ## extend the target vector on the fly\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build_orig (n)\n",
+%!    "  ## extend the target vector on the fly\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!  fstr_build = cstrcat (
-%!  "function x = build (n)\n",
-%!  "  ## preallocate the target vector\n",
-%!  "  x = zeros (1, n*100);\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build (n)\n",
+%!    "  ## preallocate the target vector\n",
+%!    "  x = zeros (1, n*100);\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!
 %!  disp ("-----------------------");
 %!  disp (fstr_build_orig);
 %!  disp ("-----------------------");
 %!  disp (fstr_build);
 %!  disp ("-----------------------");
 %!
 %!  ## Eval functions strings to create them in the current context
 %!  eval (fstr_build_orig);
 %!  eval (fstr_build);
 %!
 %!  disp ("Preallocated vector test.\nThis takes a little while...");
 %!  speed("build (n)", "", 1000, "build_orig (n)");
 %!  clear -f build build_orig
+%!  disp ("-----------------------");
 %!  disp ("Note how much faster it is to pre-allocate a vector.");
 %!  disp ("Notice the peak speedup ratio.");
 
 %!demo
 %!  fstr_build_orig = cstrcat (
-%!  "function x = build_orig (n)\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build_orig (n)\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!  fstr_build = cstrcat (
-%!  "function x = build (n)\n",
-%!  "  idx = [1:100]';\n",
-%!  "  x = idx(:,ones(1,n));\n",
-%!  "  x = reshape (x, 1, n*100);\n",
-%!  "endfunction");
+%!    "function x = build (n)\n",
+%!    "  idx = [1:100]';\n",
+%!    "  x = idx(:,ones(1,n));\n",
+%!    "  x = reshape (x, 1, n*100);\n",
+%!    "endfunction");
 %!
 %!  disp ("-----------------------");
 %!  disp (fstr_build_orig);
 %!  disp ("-----------------------");
 %!  disp (fstr_build);
 %!  disp ("-----------------------");
 %!
 %!  ## Eval functions strings to create them in the current context
@@ -420,17 +421,18 @@ endfunction
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
 %! assert (size (T_f1), size (n));
 %! assert (isnumeric (T_f2));
 %! assert (length (T_f2) > 10);
 
-%% This test is known to fail on operating systems with low resolution timers such as MinGW
+%% This test is known to fail on operating systems with low resolution timers
+%% such as MinGW
 %!xtest
 %! [order, n, T_f1, T_f2] = speed ("sum (x)", "", [100, 1000], "v = 0; for i = 1:length (x), v += x(i); endfor");
 %! assert (isstruct (order));
 %! assert (size (order), [1, 1]);
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 Paul Kienzle
+## Copyright (C) 2005-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -451,18 +451,22 @@ function [__ret1, __ret2, __ret3, __ret4
         clear __test__;
       endif
       ## Code already processed.
       __code = "";
 
 ### TESTIF
 
     elseif (strcmp (__type, "testif"))
-      [__e, __feat] = regexp (__code, '^\s*(\S+)', 'end', 'tokens');
-      if (isempty (findstr (octave_config_info ("DEFS"), __feat{1}{1})))
+      __e = regexp (__code, '.$', 'lineanchors', 'once');
+      ## Strip comment any comment from testif line before looking for features
+      __feat_line = strtok (__code(1:__e), '#%'); 
+      __feat = regexp (__feat_line, '\w+', 'match');
+      __have_feat = strfind (octave_config_info ("DEFS"), __feat); 
+      if (any (cellfun ("isempty", __have_feat)))
         __xskip++;
         __istest = 0;
         __code = ""; # Skip the code.
         __msg = sprintf ("%sskipped test\n", __signal_skip);
       else
         __istest = 1;
         __code = __code(__e + 1 : end);
       endif
@@ -486,19 +490,27 @@ function [__ret1, __ret2, __ret3, __ret4
       __success = 0;
       __msg = sprintf ("%sunknown test type!\n", __signal_fail);
       __code = ""; # skip the code
     endif
 
     ## evaluate code for test, shared, and assert.
     if (! isempty(__code))
       try
-        eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
-                       __shared_r,__shared, __code));
-        eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
+        ## FIXME: need to check for embedded test functions, which cause
+        ## segfaults, until issues with subfunctions in functions are resolved.
+        embed_func = regexp (__code, '^\s*function ', 'once', 'lineanchors');
+        if (isempty (embed_func))
+          eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
+                         __shared_r,__shared, __code));
+          eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
+        else
+          error (["Functions embedded in %!test blocks are not allowed.\n", ...
+                  "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
+        endif
       catch
         if (strcmp (__type, "xtest"))
            __msg = sprintf ("%sknown failure\n%s", __signal_fail, lasterr ());
            __xfail++;
         else
            __msg = sprintf ("%stest failed\n%s", __signal_fail, lasterr ());
            __success = 0;
         endif
@@ -788,25 +800,25 @@ endfunction
 %! assert(x,6);
 %! assert(z,9);
 
 %!## test of assert block
 %!assert (isempty([]))      # support for test assert shorthand
 
 %!## demo blocks
 %!demo                   # multiline demo block
-%! t=[0:0.01:2*pi]; x=sin(t);
-%! plot(t,x);
+%! t = [0:0.01:2*pi]; x = sin (t);
+%! plot (t,x);
 %! % you should now see a sine wave in your figure window
 %!demo a=3               # single line demo blocks work too
 
 %!## this is a comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
-%! and it  stays as a comment even through continuation lines
+%! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
 % !# failure tests.  All the following should fail. These tests should
 % !# be disabled unless you are developing test() since users don't
 % !# like to be presented with expected failures.  I use % ! to disable.
 % !test   error("---------Failure tests.  Use test('test','verbose',1)");
 % !test   assert([a,b,c],[1,3,6]);   # variables have wrong values
 % !bogus                     # unknown block type
@@ -821,8 +833,9 @@ endfunction
 % !demo                      # shared variables not available in demo
 % ! assert(exist("a"))
 % !error
 % ! test('/etc/passwd');
 % ! test("nonexistent file");
 % ! ## These don't signal an error, so the test for an error fails. Note
 % ! ## that the call doesn't reference the current fid (it is unavailable),
 % ! ## so of course the informational message is not printed in the log.
+
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Bill Denney
+## Copyright (C) 2008-2012 Bill Denney
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -83,22 +83,22 @@ function varargout = calendar (varargin)
     puts (strftime ("                    %b %Y\n", s));
     puts ("     S     M    Tu     W    Th     F     S\n");
     puts (str);
   endif
 
 endfunction
 
 
-## demos
 %!demo
 %! ## Calendar for current month
 %! calendar ()
+
 %!demo
+%! ## Calendar for October, 1957
 %! calendar (1957, 10)
 
-## tests
 %!assert ((calendar(2000,2))'(2:31), [0:29])
 %!assert ((calendar(1957,10))'(2:33), [0:31])
 
 %% Test input validation
 %!error calendar (1,2,3)
 
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1995-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 Paul Kienzle
+## Copyright (C) 2006-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -276,23 +276,24 @@ function retval = datestr (date, f = [],
 
     retval = [retval; str];
 
   endfor
 
 endfunction
 
 
-## demos
 %!demo
 %! ## Current date and time in default format
 %! datestr (now ())
+
 %!demo
 %! ## Current date (integer portion of datenum)
 %! datestr (fix (now ()))
+
 %!demo
 %! ## Current time (fractional portion of datenum)
 %! datestr (rem (now (), 1))
 
 %!shared testtime
 %! testtime = [2005.0000, 12.0000, 18.0000, 2.0000, 33.0000, 17.3822];
 %!assert (datestr (testtime,0), "18-Dec-2005 02:33:17")
 %!assert (datestr (testtime,1), "18-Dec-2005")
@@ -330,8 +331,9 @@ endfunction
 ## Test possible bug where input is a vector of datenums that is exactly 6 wide
 %!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00")
 ## Test fractional millisecond time extension
 %!assert (datestr (testtime, "HH:MM:SS:FFF"), "02:33:17:382")
 
 %% Test input validation
 %!error datestr ()
 %!error datestr (1, 2, 3, 4)
+
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -41,36 +41,39 @@ function datetick (varargin)
     axes (h);
     __datetick__ (varargin{:});
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! yr = 1900:10:2000;
 %! pop = [76.094, 92.407, 106.461, 123.077 131.954, 151.868, 179.979, ...
 %!        203.984, 227.225, 249.623, 282.224];
 %! plot (datenum (yr, 1, 1), pop);
 %! title ("US population (millions)");
 %! xlabel ("Year");
 %! datetick ("x", "YYYY");
 
 %!demo
-%! yr =1988:2:2002;
-%! yr =datenum(yr,1,1);
+%! clf;
+%! yr = 1988:2:2002;
+%! yr = datenum (yr,1,1);
 %! pr = [12.1 13.3 12.6 13.1 13.3 14.1 14.4 15.2];
-%! plot(yr,pr);
-%! xlabel('year')
-%! ylabel('average price')
-%! ax=gca;
-%! set(ax,'xtick',datenum(1990:5:2005,1,1))
-%! datetick(2,'keepticks')
-%! set(ax,'ytick',12:16)
+%! plot (yr, pr);
+%! xlabel ("year");
+%! ylabel ("average price");
+%! ax = gca ();
+%! set (ax, "xtick", datenum (1990:5:2005,1,1));
+%! datetick (2, "keepticks");
+%! set (ax, "ytick", 12:16);
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
 
 function __datetick__ (varargin)
 
   keeplimits = false;
   keepticks = false;
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Paul Kienzle
+## Copyright (C) 2004-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2000-2011 Paul Kienzle
+## Copyright (C) 2000-2012 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,17 +25,17 @@
 ## @var{d} is a serial date number or a date string.
 ##
 ## If the string @var{format} is not present or is equal to "short" then
 ## @var{s} will contain the abbreviated name of the weekday.  If @var{format}
 ## is "long" then @var{s} will contain the full name.
 ##
 ## Table of return values based on @var{format}:
 ##
-## @multitable @columnfractions .06 .13 .13
+## @multitable @columnfractions .06 .13 .16
 ## @headitem @var{n} @tab "short" @tab "long"
 ## @item 1 @tab Sun @tab Sunday
 ## @item 2 @tab Mon @tab Monday
 ## @item 3 @tab Tue @tab Tuesday
 ## @item 4 @tab Wed @tab Wednesday
 ## @item 5 @tab Thu @tab Thursday
 ## @item 6 @tab Fri @tab Friday
 ## @item 7 @tab Sat @tab Saturday
@@ -79,22 +79,24 @@ function [d, s] = weekday (d, format = "
   endif
 
 endfunction
 
 
 %!demo
 %! ## Current weekday
 %! [n, s] = weekday (now ())
+
 %!demo
 %! ## Weekday from datenum input
 %! [n, s] = weekday (728647)
+
 %!demo
 %! ## Weekday of new millennium from datestr input
-%! [n, s] = weekday ('1-Jan-2000')
+%! [n, s] = weekday ("1-Jan-2000")
 
 # tests
 %!assert (weekday (728647), 2)
 ## Test vector inputs for both directions
 %!assert (weekday ([728647 728648]), [2 3])
 %!assert (weekday ([728647;728648]), [2;3])
 ## Test a full week before our reference day
 %!assert (weekday ("19-Dec-1994"), 2)
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -1,11 +1,11 @@
 /* Contour lines for function evaluated on a grid.
 
-Copyright (C) 2007-2011 Kai Habel
+Copyright (C) 2007-2012 Kai Habel
 Copyright (C) 2004, 2007 Shai Ayal
 
 Adapted to an oct file from the stand alone contourl by Victro Munoz
 Copyright (C) 2004 Victor Munoz
 
 Based on contour plot routine (plcont.c) in PLPlot package
 http://plplot.org/
 
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -45,37 +45,34 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <string>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-#ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
-#endif
+# endif
 #endif
 
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{T} =} __delaunayn__ (@var{pts}, @var{options})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/DLD-FUNCTIONS/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/DLD-FUNCTIONS/__dispatch__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 John W. Eaton and Paul Kienzle
+Copyright (C) 2001-2012 John W. Eaton and Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Kai Habel
+Copyright (C) 2010-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Nicolo' Giorgetti
+Copyright (C) 2005-2012 Nicolo' Giorgetti
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Shai Ayal
+Copyright (C) 2007-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -24,20 +24,25 @@ along with Octave; see the file COPYING.
 
 To initialize:
 
   graphics_toolkit ("fltk");
   plot (randn (1e3, 1));
 
 */
 
+// PKG_ADD: register_graphics_toolkit ("fltk");
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "defun-dld.h"
+#include "error.h"
+
 #if defined (HAVE_FLTK)
 
 #include <map>
 #include <set>
 #include <sstream>
 #include <iostream>
 
 #ifdef WIN32
@@ -62,18 +67,16 @@ To initialize:
 // conflicts with Octave's Complex typedef.  We don't need the X11
 // Complex definition in this file, so remove it before including Octave
 // headers which may require Octave's Complex typedef.
 #undef Complex
 
 #include "cmd-edit.h"
 #include "lo-ieee.h"
 
-#include "defun-dld.h"
-#include "error.h"
 #include "file-ops.h"
 #include "gl-render.h"
 #include "gl2ps-renderer.h"
 #include "graphics.h"
 #include "parse.h"
 #include "sysdep.h"
 #include "toplev.h"
 #include "variables.h"
@@ -654,17 +657,18 @@ private:
 
 class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
 public:
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp)
     : Fl_Window (xx, yy, ww, hh, "octave"), window_label (), shift (0),
       ndim (2), fp (xfp), canvas (0), autoscale (0), togglegrid (0),
-      panzoom (0), rotate (0), help (0), status (0)
+      panzoom (0), rotate (0), help (0), status (0),
+      ax_obj (), pos_x (0), pos_y (0)
   {
     callback (window_close, static_cast<void*> (this));
     size_range (4*status_h, 2*status_h);
 
     begin ();
     {
 
       canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
@@ -744,19 +748,16 @@ public:
   }
 
   ~plot_window (void)
   {
     canvas->hide ();
     status->hide ();
     uimenu->hide ();
     this->hide ();
-    delete canvas;
-    delete status;
-    delete uimenu;
   }
 
   double number (void) { return fp.get___myhandle__ ().value (); }
 
   void renumber (double new_number)
   {
     if (canvas)
       {
@@ -966,16 +967,19 @@ private:
   OpenGL_fltk* canvas;
   Fl_Box*    bottom;
   Fl_Button* autoscale;
   Fl_Button* togglegrid;
   Fl_Button* panzoom;
   Fl_Button* rotate;
   Fl_Button* help;
   Fl_Output* status;
+  graphics_object ax_obj;
+  int pos_x;
+  int pos_y;
 
   void axis_auto (void)
   {
     octave_value_list args;
     args(0) = fp.get_currentaxes ().as_octave_value ();
     args(1) = "auto";
     feval ("axis", args);
     mark_modified ();
@@ -1172,19 +1176,16 @@ private:
     Matrix pos = fp.get_position ().matrix_value ();
     Fl_Window::resize (pos(0), pos(1), pos(2), pos(3) + status_h + menu_h);
 
     return Fl_Window::draw ();
   }
 
   int handle (int event)
   {
-    static int px0,py0;
-    static graphics_object ax0;
-
     graphics_handle gh;
 
     graphics_object fig = gh_manager::get_object (fp.get___myhandle__ ());
     int retval = Fl_Window::handle (event);
 
     // We only handle events which are in the canvas area.
     if (!Fl::event_inside (canvas))
       return retval;
@@ -1250,27 +1251,27 @@ private:
             break;
 
           case FL_MOVE:
             pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
                           Fl::event_x (), Fl::event_y ());
             break;
 
           case FL_PUSH:
-            px0 = Fl::event_x ();
-            py0 = Fl::event_y ();
+            pos_x = Fl::event_x ();
+            pos_y = Fl::event_y ();
 
             set_currentpoint (Fl::event_x (), Fl::event_y ());
 
-            gh = pixel2axes_or_ca (px0, py0);
+            gh = pixel2axes_or_ca (pos_x, pos_y);
 
             if (gh.ok ())
               {
-                ax0 = gh_manager::get_object (gh);
-                set_axes_currentpoint (ax0, px0, py0);
+                ax_obj = gh_manager::get_object (gh);
+                set_axes_currentpoint (ax_obj, pos_x, pos_y);
               }
 
             fp.execute_windowbuttondownfcn ();
 
             if (Fl::event_button () == 1 || Fl::event_button () == 3)
               return 1;
 
             break;
@@ -1279,52 +1280,54 @@ private:
             if (fp.get_windowbuttonmotionfcn ().is_defined ())
               {
                 set_currentpoint (Fl::event_x (), Fl::event_y ());
                 fp.execute_windowbuttonmotionfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
-                if (ax0 && ax0.isa ("axes"))
+                if (ax_obj && ax_obj.isa ("axes"))
                   {
                     if (gui_mode == pan_zoom)
-                      pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
+                      pixel2status (ax_obj, pos_x, pos_y,
+                                    Fl::event_x (), Fl::event_y ());
                     else
-                      view2status (ax0);
+                      view2status (ax_obj);
                     axes::properties& ap =
-                      dynamic_cast<axes::properties&> (ax0.get_properties ());
+                      dynamic_cast<axes::properties&> (ax_obj.get_properties ());
 
                     double x0, y0, x1, y1;
                     Matrix pos = fp.get_position ().matrix_value ();
-                    pixel2pos (ax0, px0, py0, x0, y0);
-                    pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
+                    pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
+                    pixel2pos (ax_obj, Fl::event_x (), Fl::event_y (), x1, y1);
 
                     if (gui_mode == pan_zoom)
                       ap.translate_view (x0 - x1, y0 - y1);
                     else if (gui_mode == rotate_zoom)
                       {
                         double daz, del;
-                        daz = (Fl::event_x () - px0) / pos(2) * 360;
-                        del = (Fl::event_y () - py0) / pos(3) * 360;
+                        daz = (Fl::event_x () - pos_x) / pos(2) * 360;
+                        del = (Fl::event_y () - pos_y) / pos(3) * 360;
                         ap.rotate_view (del, daz);
                       }
 
-                    px0 = Fl::event_x ();
-                    py0 = Fl::event_y ();
+                    pos_x = Fl::event_x ();
+                    pos_y = Fl::event_y ();
                     mark_modified ();
                   }
                 return 1;
               }
             else if (Fl::event_button () == 3)
               {
-                pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
+                pixel2status (ax_obj, pos_x, pos_y,
+                              Fl::event_x (), Fl::event_y ());
                 Matrix zoom_box (1,4,0);
-                zoom_box (0) = px0;
-                zoom_box (1) = py0;
+                zoom_box (0) = pos_x;
+                zoom_box (1) = pos_y;
                 zoom_box (2) =  Fl::event_x ();
                 zoom_box (3) =  Fl::event_y ();
                 canvas->set_zoom_box (zoom_box);
                 canvas->zoom (true);
                 canvas->redraw ();
               }
 
             break;
@@ -1359,63 +1362,71 @@ private:
                 set_currentpoint (Fl::event_x (), Fl::event_y ());
                 fp.execute_windowbuttonupfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
                 if ( Fl::event_clicks () == 1)
                   {
-                    if (ax0 && ax0.isa ("axes"))
+                    if (ax_obj && ax_obj.isa ("axes"))
                       {
                         axes::properties& ap =
-                          dynamic_cast<axes::properties&> (ax0.get_properties ());
+                          dynamic_cast<axes::properties&> (ax_obj.get_properties ());
                         ap.set_xlimmode ("auto");
                         ap.set_ylimmode ("auto");
                         ap.set_zlimmode ("auto");
                         mark_modified ();
                       }
                   }
               }
             if (Fl::event_button () == 3)
               {
                 // End of drag -- zoom.
                 if (canvas->zoom ())
                   {
                     canvas->zoom (false);
                     double x0,y0,x1,y1;
-                    if (ax0 && ax0.isa ("axes"))
+                    if (ax_obj && ax_obj.isa ("axes"))
                       {
                         axes::properties& ap =
-                          dynamic_cast<axes::properties&> (ax0.get_properties ());
-                        pixel2pos (ax0, px0, py0, x0, y0);
-                        pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
+                          dynamic_cast<axes::properties&> (ax_obj.get_properties ());
+                        pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
+                        int pos_x1 = Fl::event_x ();
+                        int pos_y1 = Fl::event_y ();
+                        pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
                         Matrix xl (1,2,0);
                         Matrix yl (1,2,0);
-                        if (x0 < x1)
+                        int dx = abs (pos_x - pos_x1);
+                        int dy = abs (pos_y - pos_y1);
+                        // Smallest zoom box must be 4 pixels square
+                        if ((dx > 4) && (dy > 4))
                           {
-                            xl(0) = x0;
-                            xl(1) = x1;
-                          }
-                        else
-                          {
-                            xl(0) = x1;
-                            xl(1) = x0;
+                            if (x0 < x1)
+                              {
+                                xl(0) = x0;
+                                xl(1) = x1;
+                              }
+                            else
+                              {
+                                xl(0) = x1;
+                                xl(1) = x0;
+                              }
+                            if (y0 < y1)
+                              {
+                                yl(0) = y0;
+                                yl(1) = y1;
+                              }
+                            else
+                              {
+                                yl(0) = y1;
+                                yl(1) = y0;
+                              }
+                            ap.zoom (xl, yl);
                           }
-                        if (y0 < y1)
-                          {
-                            yl(0) = y0;
-                            yl(1) = y1;
-                          }
-                        else
-                          {
-                            yl(0) = y1;
-                            yl(1) = y0;
-                          }
-                        ap.zoom (xl, yl);
                         mark_modified ();
                       }
                   }
               }
             break;
           }
       }
 
@@ -1763,22 +1774,22 @@ private:
   }
 };
 
 figure_manager *figure_manager::instance = 0;
 
 std::string figure_manager::fltk_idx_header="fltk index=";
 int figure_manager::curr_index = 1;
 
-static bool toolkit_registered = false;
+static bool toolkit_loaded = false;
 
 static int
 __fltk_redraw__ (void)
 {
-  if (toolkit_registered)
+  if (toolkit_loaded)
     {
       // We scan all figures and add those which use FLTK.
       graphics_object obj = gh_manager::get_object (0);
       if (obj && obj.isa ("root"))
         {
           base_properties& props = obj.get_properties ();
           Matrix children = props.get_all_children ();
 
@@ -1932,92 +1943,82 @@ public:
 
   Matrix get_screen_size (void) const
   {
     Matrix sz (1, 2, 0.0);
     sz(0) = Fl::w ();
     sz(1) = Fl::h ();
     return sz;
   }
+
+  void close (void)
+  {
+    if (toolkit_loaded)
+      {
+        munlock ("__init_fltk__");
+
+        figure_manager::close_all ();
+        gtk_manager::unload_toolkit (FLTK_GRAPHICS_TOOLKIT_NAME);
+        toolkit_loaded = false;
+
+        octave_value_list args;
+        args(0) = "__fltk_redraw__";
+        feval ("remove_input_event_hook", args, 0);
+
+        // FIXME ???
+        Fl::wait (fltk_maxtime);
+      }
+  }
 };
 
 // Initialize the fltk graphics toolkit.
 
 DEFUN_DLD (__init_fltk__, , , "")
 {
-  static bool remove_fltk_registered = false;
-
-  if (! toolkit_registered)
+  if (! toolkit_loaded)
     {
       mlock ();
 
-      graphics_toolkit::register_toolkit (new fltk_graphics_toolkit);
-      toolkit_registered = true;
+      graphics_toolkit tk (new fltk_graphics_toolkit ());
+      gtk_manager::load_toolkit (tk);
+      toolkit_loaded = true;
 
       octave_value_list args;
       args(0) = "__fltk_redraw__";
       feval ("add_input_event_hook", args, 0);
-
-      if (! remove_fltk_registered)
-        {
-          octave_add_atexit_function ("__remove_fltk__");
-
-          remove_fltk_registered = true;
-        }
     }
 
   octave_value retval;
   return retval;
 }
 
 DEFUN_DLD (__fltk_redraw__, , , "")
 {
   __fltk_redraw__ ();
 
   return octave_value ();
 }
 
-// Delete the fltk graphics toolkit.
-
-DEFUN_DLD (__remove_fltk__, , , "")
-{
-  if (toolkit_registered)
-    {
-      munlock ("__init_fltk__");
-
-      figure_manager::close_all ();
-      graphics_toolkit::unregister_toolkit (FLTK_GRAPHICS_TOOLKIT_NAME);
-      toolkit_registered = false;
-
-      octave_value_list args;
-      args(0) = "__fltk_redraw__";
-      feval ("remove_input_event_hook", args, 0);
-
-      // FIXME ???
-      Fl::wait (fltk_maxtime);
-    }
-
-  return octave_value ();
-}
-
 DEFUN_DLD (__fltk_maxtime__, args, ,"")
 {
   octave_value retval = fltk_maxtime;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         fltk_maxtime = args(0).double_value ();
       else
         error ("argument must be a real scalar");
     }
 
   return retval;
 }
 
+#endif
+
 // FIXME -- This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, ,
@@ -2025,27 +2026,32 @@ DEFUN_DLD (mouse_wheel_zoom, args, ,
 @deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{gui_mode}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         wheel_zoom_speed = args(0).double_value ();
       else
         error ("mouse_wheel_zoom: SPEED must be a real scalar");
     }
 
   return retval;
+#else
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
 DEFUN_DLD (gui_mode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
@@ -2059,16 +2065,17 @@ Allows rotating and zooming of current a
 @item 'none'\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{mouse_wheel_zoom}\n\
 @end deftypefn")
 {
+#if defined (HAVE_FLTK)
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
@@ -2093,11 +2100,14 @@ This function is currently implemented o
       else
         failed = true;
     }
 
   if (failed)
     error ("MODE must be one of the strings: \"2D\", \"3D\", or \"none\"");
 
   return octave_value (mode_str);
+#else
+  error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
+  return octave_value ();
+#endif
 }
 
-#endif
diff --git a/src/DLD-FUNCTIONS/__init_gnuplot__.cc b/src/DLD-FUNCTIONS/__init_gnuplot__.cc
new file mode 100644
--- /dev/null
+++ b/src/DLD-FUNCTIONS/__init_gnuplot__.cc
@@ -0,0 +1,193 @@
+/*
+
+Copyright (C) 2007-2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+/*
+
+To initialize:
+
+  graphics_toolkit ("gnuplot");
+  plot (randn (1e3, 1));
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "defun-dld.h"
+#include "error.h"
+#include "graphics.h"
+#include "parse.h"
+#include "variables.h"
+
+// PKG_ADD: register_graphics_toolkit ("gnuplot");
+
+static bool toolkit_loaded = false;
+
+class gnuplot_graphics_toolkit : public base_graphics_toolkit
+{
+public:
+  gnuplot_graphics_toolkit (void)
+      : base_graphics_toolkit ("gnuplot") { }
+
+  ~gnuplot_graphics_toolkit (void) { }
+
+  bool is_valid (void) const { return true; }
+
+  bool initialize (const graphics_object& go)
+    {
+      return go.isa ("figure");
+    }
+
+  void finalize (const graphics_object& go)
+    {
+      if (go.isa ("figure"))
+        {
+          const figure::properties& props =
+              dynamic_cast<const figure::properties&> (go.get_properties ());
+
+          send_quit (props.get___plot_stream__ ());
+        }
+    }
+
+  void update (const graphics_object& go, int id)
+    {
+      if (go.isa ("figure"))
+        {
+          graphics_object obj (go);
+
+          figure::properties& props =
+              dynamic_cast<figure::properties&> (obj.get_properties ());
+
+          switch (id)
+            {
+            case base_properties::ID_VISIBLE:
+              if (! props.is_visible ())
+                {
+                  send_quit (props.get___plot_stream__ ());
+                  props.set___plot_stream__ (Matrix ());
+                  props.set___enhanced__ (false);
+                }
+              break;
+            }
+        }
+    }
+
+  void redraw_figure (const graphics_object& go) const
+    {
+      octave_value_list args;
+      args(0) = go.get_handle ().as_octave_value ();
+      feval ("__gnuplot_drawnow__", args);
+    }
+
+  void print_figure (const graphics_object& go, const std::string& term,
+                     const std::string& file, bool mono,
+                     const std::string& debug_file) const
+    {
+      octave_value_list args;
+      if (! debug_file.empty ())
+        args(4) = debug_file;
+      args(3) = mono;
+      args(2) = file;
+      args(1) = term;
+      args(0) = go.get_handle ().as_octave_value ();
+      feval ("__gnuplot_drawnow__", args);
+    }
+
+  Matrix get_canvas_size (const graphics_handle&) const
+    {
+      Matrix sz (1, 2, 0.0);
+      return sz;
+    }
+
+  double get_screen_resolution (void) const
+    { return 72.0; }
+
+  Matrix get_screen_size (void) const
+    { return Matrix (1, 2, 0.0); }
+
+  void close (void)
+  {
+    if (toolkit_loaded)
+      {
+        munlock ("__init_gnuplot__");
+
+        gtk_manager::unload_toolkit ("gnuplot");
+
+        toolkit_loaded = false;
+      }
+  }
+
+private:
+
+  void send_quit (const octave_value& pstream) const
+    {
+      if (! pstream.is_empty ())
+        {
+          octave_value_list args;
+          Matrix fids = pstream.matrix_value ();
+
+          if (! error_state)
+            {
+              args(1) = "\nquit;\n";
+              args(0) = fids(0);
+              feval ("fputs", args);
+
+              args.resize (1);
+              feval ("fflush", args);
+              feval ("pclose", args);
+
+              if (fids.numel () > 1)
+                {
+                  args(0) = fids(1);
+                  feval ("pclose", args);
+
+                  if (fids.numel () > 2)
+                    {
+                      args(0) = fids(2);
+                      feval ("waitpid", args);
+                    }
+                }
+            }
+        }
+    }
+};
+
+// Initialize the fltk graphics toolkit.
+
+DEFUN_DLD (__init_gnuplot__, , , "")
+{
+  octave_value retval;
+
+  if (! toolkit_loaded)
+    {
+      mlock ();
+
+      graphics_toolkit tk (new gnuplot_graphics_toolkit ());
+      gtk_manager::load_toolkit (tk);
+
+      toolkit_loaded = true;
+    }
+
+  return retval;
+}
+
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Alexander Barth
+Copyright (C) 2007-2012 Alexander Barth
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Andy Adler
+Copyright (C) 2002-2012 Andy Adler
 Copyright (C) 2008 Thomas L. Scofield
 Copyright (C) 2010 David Grundberg
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -207,17 +207,18 @@ read_images (const std::vector<Magick::I
   dim_vector idim = dim_vector ();
   idim.resize (4);
   idim(0) = rows;
   idim(1) = columns;
   idim(2) = 1;
   idim(3) = nframes;
 
   Magick::ImageType type = imvec[0].type ();
-  const int divisor = (((1 << QuantumDepth) - 1) / ((1 << depth) - 1));
+  const int divisor = ((uint64_t (1) << QuantumDepth) - 1) / 
+                      ((uint64_t (1) << depth) - 1);
 
   switch (type)
     {
     case Magick::BilevelType:
     case Magick::GrayscaleType:
       {
         im = T (idim);
         P *vec = im.fortran_vec ();
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Kai Habel
+Copyright (C) 2002-2012 Kai Habel
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Gabriele Pannocchia
+Copyright (C) 2000-2012 Gabriele Pannocchia
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -40,39 +40,36 @@ qhull command
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-#ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "__voronoi__.oct 2007-07-24";
-#endif
+# endif
 #endif
 
 DEFUN_DLD (__voronoi__, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string caller = args(0).string_value ();
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
       return retval;
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
-Returns the approximate minimum degree permutation of a matrix.  This\n\
+Return the approximate minimum degree permutation of a matrix.  This\n\
 permutation such that the Cholesky@tie{}factorization of @code{@var{S}\n\
 (@var{p}, @var{p})} tends to be sparser than the Cholesky@tie{}factorization\n\
 of @var{S} itself.  @code{amd} is typically faster than @code{symamd} but\n\
 serves a similar purpose.\n\
 \n\
 The optional parameter @var{opts} is a structure that controls the\n\
 behavior of @code{amd}.  The fields of the structure are\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -164,18 +164,18 @@ Generalized eigenvalue problem balancing
               else if (nargout == 2)
                 {
                   retval(1) = result.balanced_matrix ();
                   retval(0) = result.balancing_matrix ();
                 }
               else
                 {
                   retval(2) = result.balanced_matrix ();
+                  retval(1) = result.permuting_vector ();
                   retval(0) = result.scaling_vector ();
-                  retval(1) = result.permuting_vector ();
                 }
 
             }
           else
             {
               FloatAEPBALANCE result (faa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
@@ -183,18 +183,18 @@ Generalized eigenvalue problem balancing
               else if (nargout == 2)
                 {
                   retval(1) = result.balanced_matrix ();
                   retval(0) = result.balancing_matrix ();
                 }
               else
                 {
                   retval(2) = result.balanced_matrix ();
+                  retval(1) = result.permuting_vector ();
                   retval(0) = result.scaling_vector ();
-                  retval(1) = result.permuting_vector ();
                 }
             }
         }
       else
         {
           if (complex_case)
             {
               ComplexAEPBALANCE result (caa, noperm, noscal);
@@ -204,36 +204,36 @@ Generalized eigenvalue problem balancing
               else if (nargout == 2)
                 {
                   retval(1) = result.balanced_matrix ();
                   retval(0) = result.balancing_matrix ();
                 }
               else
                 {
                   retval(2) = result.balanced_matrix ();
+                  retval(1) = result.permuting_vector ();
                   retval(0) = result.scaling_vector ();
-                  retval(1) = result.permuting_vector ();
                 }
             }
           else
             {
               AEPBALANCE result (aa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
                 retval(0) = result.balanced_matrix ();
               else if (nargout == 2)
                 {
                   retval(1) = result.balanced_matrix ();
                   retval(0) = result.balancing_matrix ();
                 }
               else
                 {
                   retval(2) = result.balanced_matrix ();
+                  retval(1) = result.permuting_vector ();
                   retval(0) = result.scaling_vector ();
-                  retval(1) = result.permuting_vector ();
                 }
             }
         }
     }
   else
     {
       std::string bal_job;
       if (nargout == 1)
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -307,18 +307,18 @@ update_index (Array<int>& idx, const dim
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
-The binary singleton expansion function applier does what its name\n\
-suggests: applies a binary function @var{f} element-by-element to two\n\
+The binary singleton expansion function applier performs broadcasting,\n\
+that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
 and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1,12 +1,12 @@
 /*
 
-Copyright (C) 2005-2011 Mohamed Kamoun
-Copyright (C) 2006-2011 Bill Denney
+Copyright (C) 2005-2012 Mohamed Kamoun
+Copyright (C) 2006-2012 Bill Denney
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 #include <vector>
 #include <list>
 #include <memory>
 
+#include "caseless-str.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun-dld.h"
 #include "parse.h"
 #include "variables.h"
@@ -194,28 +195,27 @@ try_cellfun_internal_ops (const octave_v
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
 }
 
 static void
 get_mapper_fun_options (const octave_value_list& args, int& nargin,
-                     bool& uniform_output, octave_value& error_handler)
+                        bool& uniform_output, octave_value& error_handler)
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
-      std::string arg = args(nargin-2).string_value ();
+      caseless_str arg = args(nargin-2).string_value ();
+
+      size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
 
-      std::transform (arg.begin (), arg.end (),
-                      arg.begin (), tolower);
-
-      if (arg == "uniformoutput")
+      if (arg.compare ("uniformoutput", compare_len))
         uniform_output = args(nargin-1).bool_value();
-      else if (arg == "errorhandler")
+      else if (arg.compare ("errorhandler", compare_len))
         {
           if (args(nargin-1).is_function_handle ()
               || args(nargin-1).is_inline_function ())
             {
               error_handler = args(nargin-1);
             }
           else if (args(nargin-1).is_string ())
             {
@@ -360,32 +360,46 @@ of the element that caused the error.  F
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (\"factorial\", @{-1,2@}, 'ErrorHandler', @@foo)\n\
 @result{} ans = [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
+Use @code{cellfun} intelligently.  The @code{cellfun} function is a\n\
+useful tool for avoiding loops.  It is often used with anonymous\n\
+function handles; however, calling an anonymous function involves an\n\
+overhead quite comparable to the overhead of an m-file function.\n\
+Passing a handle to a built-in function is faster, because the\n\
+interpreter is not involved in the internal loop.  For example:\n\
+\n\
+@example\n\
+@group\n\
+a = @{@dots{}@}\n\
+v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@det, a); # faster\n\
+@end group\n\
+@end example\n\
+\n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     {
       error ("cellfun: function requires at least 2 arguments");
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
-  bool symbol_table_lookup = false;
 
   if (! args(1).is_cell ())
     {
       error ("cellfun: C must be a cell array");
 
       return retval;
     }
 
@@ -413,56 +427,69 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
             func = octave_value (ptr_func, true);
         }
       else
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
-
-          symbol_table_lookup = true;
         }
 
       if (error_state || ! retval.empty ())
         return retval;
     }
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
+
       // The following is an optimisation because the symbol table can
       // give a more specific function class, so this can result in
       // fewer polymorphic function calls as the function gets called
       // for each value of the array.
+      {
+        if (func.is_function_handle ())
+          {
+            octave_fcn_handle* f = func.fcn_handle_value ();
 
-      if (! symbol_table_lookup )
-        {
-          if (func.is_function_handle ())
-            {
-              octave_fcn_handle* f = func.fcn_handle_value ();
+            // Overloaded function handles need to check the type of the
+            // arguments for each element of the array, so they cannot
+            // be optimised this way.
+            if (f -> is_overloaded ())
+              goto nevermind;
+          }
+
+        std::string name = func.function_value () -> name ();
+        octave_value f = symbol_table::find_function (name);
 
-              // Overloaded function handles need to check the type of
-              // the arguments for each element of the array, so they
-              // cannot be optimised this way.
+        if (f.is_defined ())
+          {
+            //Except for these two which are special cases...
+            if (name != "size" && name != "class")
+              {
+                //Try first the optimised code path for built-in functions
+                octave_value_list tmp_args = args;
+                tmp_args(0) = name;
+                retval = try_cellfun_internal_ops (tmp_args, nargin);
+                if (error_state || ! retval.empty ())
+                  return retval;
+              }
 
-              if (f -> is_overloaded ())
-                goto nevermind;
-            }
-          octave_value f = symbol_table::find_function (func.function_value ()
-                                                         -> name ());
-          if (f.is_defined ())
+            //Okay, we tried, doesn't work, let's do the best we can
+            //instead and avoid polymorphic calls for each element of
+            //the array.
             func = f;
-        }
-
+          }
+      }
     nevermind:
 
       bool uniform_output = true;
       octave_value error_handler;
-      
+
       get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
       if (error_state)
         return octave_value_list ();
 
       // Extract cell arguments.
 
       octave_value_list inputlist (nargin, octave_value ());
@@ -679,59 +706,59 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
   else
     error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __cellfun_test_num_outputs__
 %!  __cellfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f11, {1});
+%! cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
-%! x = cellfun (@f11, {1});
+%! x = cellfun (@__f11, {1});
 %! assert (__cellfun_test_num_outputs__, 1)
 
 %!test
 %! global __cellfun_test_num_outputs__
-%! cellfun (@f01, {1});
+%! cellfun (@__f01, {1});
 %! assert (__cellfun_test_num_outputs__, 0)
 
-%!error x = cellfun (@f01, {1, 2});
+%!error x = cellfun (@__f01, {1, 2});
 
 %!test
-%! assert (cellfun (@f11, {1, 2}), [1, 2])
-%! assert (cellfun (@f11, {1, 2}, 'uniformoutput', false), {1, 2})
+%! assert (cellfun (@__f11, {1, 2}), [1, 2])
+%! assert (cellfun (@__f11, {1, 2}, 'uniformoutput', false), {1, 2})
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0));
 %!  assert (a, zeros (2, 0));
 %!  assert (b, zeros (2, 0));
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0), "uniformoutput", false);
 %!  assert (a, cell (2, 0));
 %!  assert (b, cell (2, 0));
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = cellfunerror (S, varargin)
-%!    z = S;
-%!  endfunction
+%!function [z] = __cellfunerror (S, varargin)
+%!  z = S;
+%!endfunction
 
 %% First input argument can be a string, an inline function,
 %% a function_handle or an anonymous function
 %!test
 %!  A = cellfun ("islogical", {true, 0.1, false, i*2});
 %!  assert (A, [true, false, true, false]);
 %!test
 %!  A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
@@ -798,25 +825,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = cellfun (@find, {true, false; false, true}, \
 %!    "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
@@ -832,26 +859,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell arrays of character or strings
@@ -860,25 +887,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %!test
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
 %!error
@@ -894,25 +921,25 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!    "UniformOutput", true);
 %!  assert (A, [1; 0], 1e-16);
 %!test
 %!  A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
@@ -927,26 +954,26 @@ cellfun (\"factorial\", @{-1,2@}, 'Error
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
 %!    "UniformOutput", false);
 %!  assert (A, {true});
 %!test
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "ErrorHandler", @cellfunerror);
+%!    "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  a = struct ("a", 1, "b", 2); b = struct ("a", 1, "b", 3);
 %!  A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
-%!    "UniformOutput", true, "ErrorHandler", @cellfunerror);
+%!    "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% A lot of other tests
 %!error(cellfun(1))
@@ -1025,21 +1052,21 @@ function @var{func} must return a single
 concatenated into the return value and is of type matrix.  Otherwise,\n\
 if that parameter is set to @code{false}, then the outputs are\n\
 concatenated in a cell array.  For example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@(x,y) x:y, \"abc\", \"def\", \"UniformOutput\", false)\n\
 @result{} ans =\n\
-@{\n\
-  [1,1] = abcd\n\
-  [1,2] = bcde\n\
-  [1,3] = cdef\n\
-@}\n\
+    @{\n\
+      [1,1] = abcd\n\
+      [1,2] = bcde\n\
+      [1,3] = cdef\n\
+    @}\n\
 @end group\n\
 @end example\n\
 \n\
 If more than one output arguments are given then the named function\n\
 must return the number of return values that also are expected, for\n\
 example:\n\
 \n\
 @example\n\
@@ -1082,22 +1109,22 @@ respectively, the error identifier, the 
 the array elements that caused the error.  The size of the output\n\
 argument of @var{errfunc} must have the same size as the output\n\
 argument of @var{func}, otherwise a real error is thrown.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 function y = ferr (s, x), y = \"MyString\"; endfunction\n\
-arrayfun (@@str2num, [1234], \\n\
-          \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
+arrayfun (@@str2num, [1234],\n\
+           \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
 @result{} ans =\n\
-@{\n\
- [1,1] = MyString\n\
-@}\n\
+    @{\n\
+     [1,1] = MyString\n\
+    @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -1403,53 +1430,53 @@ arrayfun (@@str2num, [1234], \\n\
     }
   else
     error ("arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
-%!function r = f11 (x)
+%!function r = __f11 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
 %!  r = x;
-%! endfunction
+%!endfunction
 
-%!function f01 (x)
+%!function __f01 (x)
 %!  global __arrayfun_test_num_outputs__
 %!  __arrayfun_test_num_outputs__ = nargout;
-%! endfunction
+%!endfunction
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f11, {1});
+%! arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
-%! x = arrayfun (@f11, {1});
+%! x = arrayfun (@__f11, {1});
 %! assert (__arrayfun_test_num_outputs__, 1)
 
 %!test
 %! global __arrayfun_test_num_outputs__
-%! arrayfun (@f01, {1});
+%! arrayfun (@__f01, {1});
 %! assert (__arrayfun_test_num_outputs__, 0)
 
-%!error x = arrayfun (@f01, [1, 2]);
+%!error x = arrayfun (@__f01, [1, 2]);
 
 %!test
-%! assert (arrayfun (@f11, [1, 2]), [1, 2])
-%! assert (arrayfun (@f11, [1, 2], 'uniformoutput', false), {1, 2});
-%! assert (arrayfun (@f11, {1, 2}), {1, 2})
-%! assert (arrayfun (@f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
+%! assert (arrayfun (@__f11, [1, 2]), [1, 2])
+%! assert (arrayfun (@__f11, [1, 2], 'uniformoutput', false), {1, 2});
+%! assert (arrayfun (@__f11, {1, 2}), {1, 2})
+%! assert (arrayfun (@__f11, {1, 2}, 'uniformoutput', false), {{1}, {2}});
 
 %!assert (arrayfun (@ones, 1, [2,3], 'uniformoutput', false), {[1,1], [1,1,1]});
 
 %% Test function to check the "Errorhandler" option
-%!function [z] = arrayfunerror (S, varargin)
+%!function [z] = __arrayfunerror (S, varargin)
 %!      z = S;
-%!    endfunction
+%!endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
 %!test
 %!  arrayfun (@isequal, [false, true], [true, true]); %% No output argument
 %!error
 %!  arrayfun (@isequal); %% One or less input arguments
 %!test
 %!  A = arrayfun ("isequal", [false, true], [true, true]);
@@ -1494,25 +1521,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %!  assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
 %!  [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %!  assert (isequal (A, {true, []; [], true}));
 %!  assert (isequal (B, {true, []; [], true}));
 %!  assert (isequal (C, {true, []; [], true}));
 %!test
-%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str (x,y), true, true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str (x,y), true, true, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type numeric
 %!test
@@ -1526,26 +1553,26 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %!  assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %!  [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %!  assert (isequal (A, {true, true; [], true}));
 %!  assert (isequal (B, {true, true; [], true}));
 %!  assert (isequal (C, {10, 11; [], 12}));
 %!test
-%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  B = isfield (A(1), "message") && isfield (A(1), "index");
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type character or strings
@@ -1554,17 +1581,17 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [false, true, false, true, true, true]);
 %!test
 %!  A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %!  assert (A, [false; true]);
 %!test
 %!  A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %!  assert (A, {"abc", "def"});
 %! %#!test
-%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @arrayfunerror);
+%!   A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], "ErrorHandler", @__arrayfunerror);
 %!   B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %!   assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
 %!  assert (A, true);
@@ -1572,25 +1599,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b, "UniformOutput", true);
 %!  assert (A, true);
 %!test
 %!  a = struct ("a", 1.1, "b", 4.2); b = struct ("a", 3.1, "b", 2);
 %!  A = arrayfun (@(x,y) x.a:y.a, a, b, "UniformOutput", false);
 %!  assert (isequal (A, {[1.1, 2.1, 3.1]}));
 %!test
-%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %!  A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
-%!                "ErrorHandler", @arrayfunerror);
+%!                "ErrorHandler", @__arrayfunerror);
 %!  assert (isfield (A, "identifier"), true);
 %!  assert (isfield (A, "message"), true);
 %!  assert (isfield (A, "index"), true);
 %!  assert (isempty (A.message), false);
 %!  assert (A.index, 1);
 
 %% Input arguments can be of type cell array
 %!test
@@ -1598,25 +1625,25 @@ arrayfun (@@str2num, [1234], \\n\
 %!  assert (A, [true, false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1; 4.2}, {3.1; 2}, "UniformOutput", true);
 %!  assert (A, [true; false]);
 %!test
 %!  A = arrayfun (@(x,y) x{1} < y{1}, {1.1, 4.2}, {3.1, 2}, "UniformOutput", false);
 %!  assert (A, {true, false});
 %!test
-%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @arrayfunerror);
+%!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 %!test
 %!  A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
-%!                "UniformOutput", true, "ErrorHandler", @arrayfunerror);
+%!                "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %!  assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %!  assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %!  assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %!  assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %!  assert ([A(1).index, A(2).index], [1, 2]);
 */
 
 static void
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2008-2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -56,22 +56,23 @@ template <class CHOLT>
 static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (),
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
-  "-*- texinfo -*-\n\
+"-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, 'vector')\n\
 @deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, 'lower')\n\
+@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, 'upper')\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky@tie{}factor, @var{R}, of the symmetric positive definite\n\
 matrix @var{A}, where\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
@@ -123,16 +124,20 @@ Called with either a sparse or full matr
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
+For full matrices, if the 'lower' flag is set only the lower triangular part\n\
+of the matrix is used for the factorization, otherwise the upper triangular\n\
+part is used.\n\
+\n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool LLt = false;
@@ -150,16 +155,20 @@ sparse matrices.\n\
     {
       std::string tmp = args(n++).string_value ();
 
       if (! error_state )
         {
           if (tmp.compare ("vector") == 0)
             vecout = true;
           else if (tmp.compare ("lower") == 0)
+            // FIXME currently the option "lower" is handled by transposing the
+            //  matrix, factorizing it with the lapack function DPOTRF ('U', ...)
+            //  and finally transposing the factor. It would be more efficient to use
+            //  DPOTRF ('L', ...) in this case.
             LLt = true;
           else if (tmp.compare ("upper") == 0)
             LLt = false;
           else
             error ("chol: unexpected second or third input");
         }
       else
         error ("chol: expecting trailing string arguments");
@@ -246,17 +255,23 @@ sparse matrices.\n\
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  FloatCHOL fact (m, info);
+
+                  FloatCHOL fact;
+                  if (LLt)
+                    fact = FloatCHOL (m.transpose (), info);
+                  else
+                    fact = FloatCHOL (m, info);
+
                   if (nargout == 2 || info == 0)
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
@@ -266,17 +281,23 @@ sparse matrices.\n\
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  FloatComplexCHOL fact (m, info);
+
+                  FloatComplexCHOL fact;
+                  if (LLt)
+                    fact = FloatComplexCHOL (m.transpose (), info);
+                  else
+                    fact = FloatComplexCHOL (m, info);
+
                   if (nargout == 2 || info == 0)
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
@@ -291,17 +312,23 @@ sparse matrices.\n\
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  CHOL fact (m, info);
+                  
+                  CHOL fact;
+                  if (LLt)
+                     fact = CHOL (m.transpose (), info);
+                  else
+                    fact = CHOL (m, info);
+
                   if (nargout == 2 || info == 0)
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
@@ -311,17 +338,23 @@ sparse matrices.\n\
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  ComplexCHOL fact (m, info);
+                  
+                  ComplexCHOL fact;
+                  if (LLt)
+                    fact = ComplexCHOL (m.transpose (), info);
+                  else
+                    fact = ComplexCHOL (m, info);
+
                   if (nargout == 2 || info == 0)
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
@@ -988,16 +1021,88 @@ If @var{info} is not present, an error m
 %! R = chol(single(Ac));
 %!
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
 %!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - single(Ac),Inf) < 2e1*eps('single'))
 %!
+
+%!test
+%! cu = chol (triu (A), 'upper');
+%! cl = chol (tril (A), 'lower');
+%! assert (cu, cl', eps)
+%!
+%!test
+%! cca  = chol (Ac);
+%!
+%! ccal  = chol (Ac, 'lower');
+%! ccal2 = chol (tril (Ac), 'lower');
+%!
+%! ccau  = chol (Ac, 'upper');
+%! ccau2 = chol (triu (Ac), 'upper');
+%!
+%! assert (cca'*cca,     Ac, eps)
+%! assert (ccau'*ccau,   Ac, eps)
+%! assert (ccau2'*ccau2, Ac, eps)
+%!
+%! assert (cca, ccal',  eps)
+%! assert (cca, ccau,   eps)
+%! assert (cca, ccal2', eps)
+%! assert (cca, ccau2,  eps)
+%!
+%!test
+%! cca  = chol (single (Ac));
+%!
+%! ccal  = chol (single (Ac), 'lower');
+%! ccal2 = chol (tril (single (Ac)), 'lower');
+%!
+%! ccau  = chol (single (Ac), 'upper');
+%! ccau2 = chol (triu (single (Ac)), 'upper');
+%!
+%! assert (cca'*cca,     single (Ac), eps ('single'))
+%! assert (ccau'*ccau,   single (Ac), eps ('single'))
+%! assert (ccau2'*ccau2, single (Ac), eps ('single'))
+%!
+%! assert (cca, ccal',  eps ('single'))
+%! assert (cca, ccau,   eps ('single'))
+%! assert (cca, ccal2', eps ('single'))
+%! assert (cca, ccau2,  eps ('single'))
+
+%!test
+%! a = [12,  2,  3,  4;
+%!       2, 14,  5,  3;
+%!       3,  5, 16,  6;
+%!       4,  3,  6, 16];
+%!
+%! b = [0,  1,  2,  3;
+%!     -1,  0,  1,  2;
+%!     -2, -1,  0,  1;
+%!     -3, -2, -1,  0];
+%!
+%! ca = a + i*b;
+%!   
+%! cca  = chol (ca);
+%!
+%! ccal  = chol (ca, 'lower');
+%! ccal2 = chol (tril (ca), 'lower');
+%!
+%! ccau  = chol (ca, 'upper');
+%! ccau2 = chol (triu (ca), 'upper');
+%!
+%! assert (cca'*cca,     ca, 16*eps)
+%! assert (ccau'*ccau,   ca, 16*eps)
+%! assert (ccau2'*ccau2, ca, 16*eps)
+%!
+%! assert (cca, ccal',  16*eps)
+%! assert (cca, ccau,   16*eps)
+%! assert (cca, ccal2', 16*eps)
+%! assert (cca, ccau2,  16*eps)
+
 */
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -642,17 +642,17 @@ Ng, Oak Ridge National Laboratory.  (see
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
-Returns the elimination tree for the matrix @var{S}.  By default @var{S}\n\
+Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 'sym' or 'col', for symmetric or column elimination tree respectively\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -2,17 +2,18 @@ BEGIN {
   FS = "|";
   nfiles = 0;
 
   print "## DO NOT EDIT -- generated from module-files by config-module.awk";
   print ""
   print "EXTRA_DIST += \\"
   print "  DLD-FUNCTIONS/config-module.sh \\"
   print "  DLD-FUNCTIONS/config-module.awk \\"
-  print "  DLD-FUNCTIONS/module-files"
+  print "  DLD-FUNCTIONS/module-files \\"
+  print "  DLD-FUNCTIONS/oct-qhull.h"
   print ""
 }
 /^#.*/ { next; }
 {
   nfiles++;
   files[nfiles] = $1;
   cppflags[nfiles] = $2;
   ldflags[nfiles] = $3;
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 Andy Adler
+Copyright (C) 1999-2012 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -29,64 +29,49 @@ along with Octave; see the file COPYING.
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
-/*
-%!test
-%! b = [0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18];
-%! assert(conv2([0,1;1,2],[1,2,3;4,5,6;7,8,9]),b);
-
-%!test
-%! b = single([0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18]);
-%! assert(conv2(single([0,1;1,2]),single([1,2,3;4,5,6;7,8,9])),b);
-
-%!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6]),
-%!        [1,4,4;5,18,16;14,48,40;19,62,48;15,48,36;]);
-
-%!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6], "full"),
-%!        conv2 (1:3, 1:2, [1,2;3,4;5,6]));
-
-*/
-
-
 DEFUN_DLD (conv2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} conv2 (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
 @deftypefnx {Loadable Function} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
 @item @var{shape} = \"same\"\n\
 Return the central part of the convolution with the same size as @var{A}.\n\
+The central part of the convolution begins at the indices\n\
+@code{floor ([size(@var{B})/2] + 1)}.\n\
 \n\
 @item @var{shape} = \"valid\"\n\
 Return only the parts which do not include zero-padded edges.\n\
+The size of the result is @code{max (size (A) - size (B) + 1, 0)}.\n\
 @end table\n\
 \n\
 When the third argument is a matrix, return the convolution of the matrix\n\
 @var{m} by the vector @var{v1} in the column direction and by the vector\n\
-@var{v2} in the row direction\n\
+@var{v2} in the row direction.\n\
 @seealso{conv, convn}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
-  std::string shape = "full"; //default
+  std::string shape = "full";   // default
   bool separable = false;
   convn_type ct;
 
   if (nargin < 2)
     {
      print_usage ();
      return retval;
     }
@@ -232,41 +217,98 @@ When the third argument is a matrix, ret
              }
          }
 
      } // if (separable)
 
    return retval;
 }
 
+/*
+%!test
+%! c = [0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18];
+%! assert (conv2 ([0,1;1,2], [1,2,3;4,5,6;7,8,9]), c);
+
+%!test
+%! c = single ([0,1,2,3;1,8,12,12;4,20,24,21;7,22,25,18]);
+%! assert (conv2 (single ([0,1;1,2]), single ([1,2,3;4,5,6;7,8,9])), c);
+
+%!test
+%! c = [1,4,4;5,18,16;14,48,40;19,62,48;15,48,36];
+%! assert (conv2 (1:3, 1:2, [1,2;3,4;5,6]), c);
+
+%!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6], "full"),
+%!        conv2 (1:3, 1:2, [1,2;3,4;5,6]));
+
+%% Test shapes
+%!shared A, B, C
+%! A = rand (3, 4);
+%! B = rand (4);
+%! C = conv2 (A, B);
+%!assert (conv2 (A,B, "full"), C)
+%!assert (conv2 (A,B, "same"), C(3:5,3:6))
+%!assert (conv2 (A,B, "valid"), zeros (0, 1))
+%!assert (size (conv2 (B,A, "valid")), [2 1])
+
+%!test
+%! B = rand (5);
+%! C = conv2 (A, B);
+%!assert (conv2 (A,B, "full"), C)
+%!assert (conv2 (A,B, "same"), C(3:5,3:6))
+%!assert (conv2 (A,B, "valid"), zeros (0, 0))
+%!assert (size (conv2 (B,A, "valid")), [3 2])
+
+%% Clear shared variables so they are not reported for tests below
+%!shared
+
+%% Test cases from Bug #34893
+%!assert (conv2 ([1:5;1:5], [1:2], 'same'), [4 7 10 13 10; 4 7 10 13 10])
+%!assert (conv2 ([1:5;1:5]', [1:2]', 'same'), [4 7 10 13 10; 4 7 10 13 10]')
+%!#assert (conv2 ([1:5;1:5], [1:2], 'valid'), [4 7 10 13; 4 7 10 13])
+%!assert (conv2 ([1:5;1:5]', [1:2]', 'valid'), [4 7 10 13; 4 7 10 13]')
+
+%% Test input validation
+%!error conv2 ()
+%!error conv2 (1)
+%!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
+%% Test alternate calling form which should be 2 vectors and a matrix
+%!error conv2 (ones (2), 1, 1)
+%!error conv2 (1, ones (2), 1)
+
+*/
+
 DEFUN_DLD (convn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
-Return the n-D convolution of @var{A} and @var{B} where the size\n\
-of @var{C} is given by\n\
+@deftypefn  {Loadable Function} {@var{C} =} convn (@var{A}, @var{B})\n\
+@deftypefnx {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
+Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
+is determined by the optional @var{shape} argument which takes the following\n\
+values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
-Return the full convolution.\n\
+Return the full convolution.  (default)\n\
 \n\
 @item @var{shape} = \"same\"\n\
 Return central part of the convolution with the same size as @var{A}.\n\
+The central part of the convolution begins at the indices\n\
+@code{floor ([size(@var{B})/2] + 1)}.\n\
 \n\
 @item @var{shape} = \"valid\"\n\
 Return only the parts which do not include zero-padded edges.\n\
+The size of the result is @code{max (size (A) - size (B) + 1, 0)}.\n\
 @end table\n\
 \n\
-By default @var{shape} is @samp{\"full\"}.\n\
 @seealso{conv2, conv}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
-  std::string shape = "full"; //default
+  std::string shape = "full";   // default
   convn_type ct;
 
   if (nargin < 2 || nargin > 3)
     {
      print_usage ();
      return retval;
     }
   else if (nargin == 3)
@@ -332,8 +374,12 @@ By default @var{shape} is @samp{\"full\"
           NDArray a (args(0).array_value ());
           NDArray b (args(1).array_value ());
           retval = convn (a, b, ct);
         }
     }
 
    return retval;
 }
+
+/*
+ FIXME: Need tests for convn in addition to conv2.
+*/
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 Kai Habel
+Copyright (C) 2000-2012 Kai Habel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -36,25 +36,22 @@ 2006-05-01 Tom Holroyd
 #include <sstream>
 
 #include "Cell.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "parse.h"
 
-#ifdef HAVE_QHULL
-extern "C" {
-#include <qhull/qhull_a.h>
-}
-
-# ifdef NEED_QHULL_VERSION
+#if defined (HAVE_QHULL)
+# include "oct-qhull.h"
+# if defined (NEED_QHULL_VERSION)
 char qh_version[] = "convhulln.oct 2007-07-24";
 # endif
-#endif /* HAVE_QHULL */
+#endif
 
 DEFUN_DLD (convhulln, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts} which is a matrix\n\
 of size [n, dim] containing n points in a space of dimension dim.\n\
@@ -80,17 +77,17 @@ default arguments in @var{options}.  Use
 \n\
 If the second output @var{v} is requested the volume of the enclosing\n\
 convex hull is calculated.\n\n\
 @seealso{convhull, delaunayn, voronoin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-#ifdef HAVE_QHULL
+#if defined (HAVE_QHULL)
 
   int nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -495,28 +495,31 @@ parameters for @code{dassl}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+x(2); xdot(2)-x(1)];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %% dassl-2.m
 %%
 %% Test dassl() function
@@ -532,28 +535,31 @@ parameters for @code{dassl}.\n\
 %%   x1' + 10*x1 = 0,   x1(0) = 1
 %%   x1  + x2    = 1,   x2(0) = 0
 %%
 %%
 %% Solution
 %%
 %%  x1(t) = exp(-10*t)
 %%  x2(t) = 1 - x(1)
-%!function res = f (x, xdot, t)
+
+%!function res = __f (x, xdot, t)
 %!  res = [xdot(1)+10*x(1); x(1)+x(2)-1];
+%!endfunction
+
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [-10; 10];
 %! t = (0:0.2:1)';
 %!
 %! tol = 500 * dassl_options ("relative tolerance");
 %!
 %!
-%! [x, xdot] = dassl ("f", x0, xdot0, t);
+%! [x, xdot] = dassl ("__f", x0, xdot0, t);
 %!
 %! y = [exp(-10*t), 1-exp(-10*t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! dassl_options ("absolute tolerance", eps);
 %! assert(dassl_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jonathan Stickel
+Copyright (C) 2008-2012 Jonathan Stickel
 Copyright (C) 2010 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -299,17 +299,17 @@ Any other value indicates a failure to c
 This function is based on the @sc{arpack} package, written by R. Lehoucq,\n\
 K. Maschhoff, D. Sorensen, and C. Yang.  For more information see\n\
 @url{http://www.caam.rice.edu/software/ARPACK/}.\n\
 \n\
 @seealso{eig, svds}\n\
 @end deftypefn")
 {
   octave_value_list retval;
-
+#ifdef HAVE_ARPACK
   int nargin = args.length ();
   std::string fcn_name;
   octave_idx_type n = 0;
   octave_idx_type k = 6;
   Complex sigma = 0.;
   double sigmar, sigmai;
   bool have_sigma = false;
   std::string typ = "LM";
@@ -754,16 +754,19 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         warning ("eigs: None of the %d requested eigenvalues converged", k);
       else if (nconv < k)
         warning ("eigs: Only %d of the %d requested eigenvalues converged",
                  nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
+#else
+  error ("eigs: not available in this version of Octave");
+#endif
 
   return retval;
 }
 
 /* #### SPARSE MATRIX VERSIONS #### */
 
 /*
 
@@ -772,117 +775,117 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! n = 20;
 %! k = 4;
 %! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
 %! d0 = eig (A);
 %! d2 = sort (d0);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'la');
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sa');
 %! assert (d1, d2(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'be');
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1, 'be');
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (d1, eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! AA = speye (10);
 %! fn = @(x) AA * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! assert (eigs (fn, 10, AA, 3, 'lm', opts), [1; 1; 1],10*eps);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'la');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sa');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'be');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -892,127 +895,127 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A =  sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(d0));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1022,129 +1025,129 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1157,112 +1160,112 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! n = 20;
 %! k = 4;
 %! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
 %! d0 = eig (A);
 %! d2 = sort (d0);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'la');
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sa');
 %! assert (d1, d2(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'be');
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1, 'be');
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (eigs(A,k,4.1), eigs(A,eye(n),k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (d1, eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'la');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sa');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'be');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1272,127 +1275,127 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A =  full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(d0));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
 
@@ -1402,128 +1405,128 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %!shared n, k, A, d0
 %! n = 20;
 %! k = 4;
 %! A = full(sparse([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
 %! d0 = eig (A);
 %! [~, idx] = sort (abs(d0));
 %! d0 = d0(idx);
 %! rand("state", 42); % initialize generator to make eigs behavior reproducible
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(1:k)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'li');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! d1 = eigs(A, eye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, eye(n), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, eye(n)(q,q), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,eye(n),k,4.1)), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,eye(n),k,4.1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'sr');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'li');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!test
+%!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'si');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*eye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 
 */
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 David Bateman
+Copyright (C) 1997-2012 David Bateman
 Copyright (C) 1996-1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 David Bateman
+Copyright (C) 1997-2012 David Bateman
 Copyright (C) 1996-1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 David Bateman
+Copyright (C) 2006-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -408,17 +408,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).scalar_value ();
 
       if (error_state || (val < 0 || (! xisinf (val) && val != xround (val))))
         {
-          error ("find: N must be a nonnegative integer");
+          error ("find: N must be a non-negative integer");
           return retval;
         }
       else if (! xisinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 2010 Jaroslav Hajek, Jordi Guti√©rrez Hermoso
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -75,18 +75,18 @@ Once the end of data has been reached, @
   retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getgrgid, args, ,
@@ -111,18 +111,18 @@ Return the first entry from the group da
       if (! error_state)
         {
           if (D_NINT (dval) == dval)
             {
               gid_t gid = static_cast<gid_t> (dval);
 
               std::string msg;
 
+              retval(1) = msg;
               retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
-              retval(1) = msg;
             }
           else
             error ("getgrgid: GID must be an integer");
         }
     }
   else
     print_usage ();
 
@@ -147,18 +147,18 @@ Return the first entry from the group da
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
         {
           std::string msg;
 
+          retval(1) = msg;
           retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
-          retval(1) = msg;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -174,18 +174,18 @@ Return the internal pointer to the begin
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = static_cast<double> (octave_group::setgrent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (endgrent, args, ,
@@ -200,16 +200,16 @@ Close the group database.\n\
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = static_cast<double> (octave_group::endgrent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -79,18 +79,18 @@ opening it if necessary.  Once the end o
   retval(0) = 0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (getpwuid, args, ,
@@ -115,18 +115,18 @@ database, @code{getpwuid} returns 0.\n\
       if (! error_state)
         {
           if (D_NINT (dval) == dval)
             {
               uid_t uid = static_cast<uid_t> (dval);
 
               std::string msg;
 
+              retval(1) = msg;
               retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
-              retval(1) = msg;
             }
           else
             error ("getpwuid: UID must be an integer");
         }
     }
   else
     print_usage ();
 
@@ -151,18 +151,18 @@ database, @code{getpwname} returns 0.\n\
   if (nargin == 1)
     {
       std::string s = args(0).string_value ();
 
       if (! error_state)
         {
           std::string msg;
 
+          retval(1) = msg;
           retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
-          retval(1) = msg;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -178,18 +178,18 @@ Return the internal pointer to the begin
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (endpwent, args, ,
@@ -204,16 +204,16 @@ Close the password database.\n\
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = static_cast<double> (octave_passwd::endpwent (msg));
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague a.s., Czech Republic
+Copyright (C) 2008-2012 VZLU Prague a.s., Czech Republic
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -487,56 +487,56 @@ parameters for @code{lsode}.\n\
 %%
 %%    y1' = -y2,   y1(0) = 1
 %%    y2' =  y1,   y2(0) = 0
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = [-x(2); x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
 %!
 %! tol = 500 * lsode_options ("relative tolerance");
 %!
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [cos(t), sin(t)];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdotdot = f (x, t)
+%!function xdotdot = __f (x, t)
 %!  xdotdot = [x(2); -x(1)];
 %!test
 %!
 %! x0 = [1; 0];
 %! t = [0; 2*pi];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1, 0; 1, 0];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
-%!function xdot = f (x, t)
+%!function xdot = __f (x, t)
 %!  xdot = x;
 %!test
 %!
 %! x0 = 1;
 %! t = [0; 1];
 %! tol = 100 * dassl_options ("relative tolerance");
 %!
-%! x = lsode ("f", x0, t);
+%! x = lsode ("__f", x0, t);
 %!
 %! y = [1; e];
 %!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
 %! assert(lsode_options ("absolute tolerance") == eps);
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Carlo de Falco
+Copyright (C) 2009-2012 Carlo de Falco
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -1,16 +1,17 @@
 # FILE|CPPFLAGS|LDFLAGS|LIBRARIES
 __contourc__.cc
 __delaunayn__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 __dispatch__.cc
 __dsearchn__.cc
 __fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
 __init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
+__init_gnuplot__.cc
 __lin_interpn__.cc
 __magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
 __pchip_deriv__.cc
 __qp__.cc
 __voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 balance.cc
 besselj.cc
@@ -26,17 +27,17 @@ convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_L
 daspk.cc
 dasrt.cc
 dassl.cc
 det.cc
 dlmread.cc
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 dot.cc
 eig.cc
-eigs.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
+eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 filter.cc
 find.cc
 gammainc.cc
 gcd.cc
@@ -52,17 +53,16 @@ lookup.cc
 lsode.cc
 lu.cc
 luinc.cc
 matrix_type.cc
 max.cc
 md5sum.cc
 mgorth.cc
 nproc.cc
-onCleanup.cc
 pinv.cc
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 quad.cc
 quadcc.cc
 qz.cc|||$(LAPACK_LIBS) $(BLAS_LIBS)
 rand.cc
 rcond.cc
 regexp.cc|$(REGEX_CPPFLAGS)|$(REGEX_LDFLAGS)|$(REGEX_LIBS)
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/DLD-FUNCTIONS/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/DLD-FUNCTIONS/nproc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Iain Murray
+Copyright (C) 2012 Iain Murray
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/oct-qhull.h b/src/DLD-FUNCTIONS/oct-qhull.h
new file mode 100644
--- /dev/null
+++ b/src/DLD-FUNCTIONS/oct-qhull.h
@@ -0,0 +1,54 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_oct_qhull_h)
+#define octave_oct_qhull_h 1
+
+#include <cstdio>
+
+extern "C" {
+
+#if defined (HAVE_QHULL_LIBQHULL_H) || defined (HAVE_QHULL_QHULL_H)
+# if defined (HAVE_QHULL_LIBQHULL_H)
+#  include <qhull/libqhull.h>
+# else
+#  include <qhull/qhull.h>
+# endif
+# include <qhull/qset.h>
+# include <qhull/geom.h>
+# include <qhull/poly.h>
+# include <qhull/io.h>
+#elif defined (HAVE_LIBQHULL_H) || defined (HAVE_QHULL_H)
+# if defined (HAVE_LIBQHULL_H)
+#  include <libqhull.h>
+# else
+#  include <qhull.h>
+# endif
+# include <qset.h>
+# include <geom.h>
+# include <poly.h>
+# include <io.h>
+#endif
+
+}
+
+#endif
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
deleted file mode 100644
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
-
-Copyright (C) 2010-2011 VZLU Prague
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "defun-dld.h"
-#include "ov-base.h"
-#include "ov.h"
-#include "ov-fcn.h"
-#include "ov-usr-fcn.h"
-#include "pt-misc.h"
-#include "toplev.h"
-
-static void gripe_internal (void)
-{
-  error ("onCleanup: internal error: cloning nonempty object");
-}
-
-class octave_oncleanup : public octave_base_value, octave_auto_shlib
-{
-public:
-  octave_oncleanup (void) : fcn () { }
-  octave_oncleanup (const octave_value& fcn);
-
-  octave_base_value *clone (void) const
-    {
-      if (fcn.is_defined ())
-        gripe_internal ();
-      return empty_clone ();
-    }
-
-  octave_base_value *empty_clone (void) const { return new octave_oncleanup (); }
-
-  ~octave_oncleanup (void);
-
-  bool is_defined (void) const { return true; }
-
-  bool is_object (void) const { return true; } // do we want this?
-
-  octave_map map_value (void) const
-    { return scalar_map_value (); }
-
-  octave_scalar_map scalar_map_value (void) const;
-
-  dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
-
-  bool save_ascii (std::ostream& os);
-
-  bool load_ascii (std::istream& is);
-
-  bool save_binary (std::ostream& os, bool& save_as_floats);
-
-  bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format fmt);
-
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
-
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
-
-  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
-
-  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
-
-private:
-
-  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
-
-protected:
-
-    octave_value fcn;
-
-};
-
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_oncleanup, "onCleanup", "onCleanup");
-
-octave_oncleanup::octave_oncleanup (const octave_value& f)
-  : fcn (f)
-{
-  if (f.is_function_handle ())
-    {
-      octave_function *fptr = f.function_value (true);
-      if (fptr)
-        {
-          octave_user_function *uptr = dynamic_cast<octave_user_function *> (fptr);
-          if (uptr != 0)
-            {
-              tree_parameter_list *pl = uptr->parameter_list ();
-              if (pl != 0 && pl->length () > 0)
-                warning ("onCleanup: cleanup action takes parameters");
-            }
-        }
-      else
-        error ("onCleanup: no default dispatch for function handle");
-    }
-  else
-    {
-      fcn = octave_value ();
-      error ("onCleanup: argument must be a function handle");
-    }
-}
-
-octave_oncleanup::~octave_oncleanup (void)
-{
-  if (fcn.is_undefined ())
-    return;
-
-  unwind_protect frame;
-
-  // Clear interrupts.
-  frame.protect_var (octave_interrupt_state);
-  octave_interrupt_state = 0;
-
-  // Disallow quit().
-  frame.protect_var (quit_allowed);
-  quit_allowed = false;
-
-  // Clear errors.
-  frame.protect_var (error_state);
-  error_state = 0;
-
-  try
-    {
-      // Run the actual code.
-      fcn.do_multi_index_op (0, octave_value_list ());
-    }
-  catch (octave_interrupt_exception)
-    {
-      // Swallow the interrupt.
-      warning ("onCleanup: interrupt occured in cleanup action");
-    }
-  catch (std::bad_alloc)
-    {
-      // Swallow the exception.
-      warning ("onCleanup: out of memory occured in cleanup action");
-    }
-  catch (...) // Yes, the black hole. We're in a d-tor.
-    {
-      // This shouldn't happen, in theory.
-      error ("onCleanup: internal error: unhandled exception in cleanup action");
-    }
-
-  // We don't want to ignore errors that occur in the cleanup code, so
-  // if an error is encountered there, leave error_state alone.
-  // Otherwise, set it back to what it was before.
-  if (error_state)
-    {
-      frame.discard_top ();
-      octave_call_stack::backtrace_error_message ();
-    }
-}
-
-octave_scalar_map
-octave_oncleanup::scalar_map_value (void) const
-{
-  octave_scalar_map retval;
-  retval.setfield ("task", fcn);
-  return retval;
-}
-
-static void
-warn_save_load (void)
-{
-  warning ("onCleanup: load and save not supported");
-}
-
-bool
-octave_oncleanup::save_ascii (std::ostream& /* os */)
-{
-  warn_save_load ();
-  return true;
-}
-
-bool
-octave_oncleanup::load_ascii (std::istream& /* is */)
-{
-  warn_save_load ();
-  return true;
-}
-
-bool
-octave_oncleanup::save_binary (std::ostream& /* os */, bool& /* save_as_floats */)
-{
-  warn_save_load ();
-  return true;
-}
-
-
-bool
-octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
-                               oct_mach_info::float_format /* fmt */)
-{
-  warn_save_load ();
-  return true;
-}
-
-#if defined (HAVE_HDF5)
-bool
-octave_oncleanup::save_hdf5 (hid_t /* loc_id */, const char * /* name */,
-                             bool /* save_as_floats */)
-{
-  warn_save_load ();
-  return true;
-}
-
-bool
-octave_oncleanup::load_hdf5 (hid_t /* loc_id */, const char * /* name */)
-{
-  warn_save_load ();
-  return true;
-}
-#endif
-
-void
-octave_oncleanup::print (std::ostream& os, bool pr_as_read_syntax) const
-{
-  print_raw (os, pr_as_read_syntax);
-  newline (os);
-}
-
-void
-octave_oncleanup::print_raw (std::ostream& os, bool pr_as_read_syntax) const
-{
-  os << "onCleanup (";
-  if (fcn.is_defined ())
-    fcn.print_raw (os, pr_as_read_syntax);
-  os << ")";
-}
-
-DEFUN_DLD (onCleanup, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
-Create a special object that executes a given function upon destruction.\n\
-If the object is copied to multiple variables (or cell or struct array\n\
-elements) or returned from a function, @var{action} will be executed after\n\
-clearing the last copy of the object.  Note that if multiple local onCleanup\n\
-variables are created, the order in which they are called is unspecified.\n\
-For similar functionality @xref{The @code{unwind_protect} Statement}.\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      if (octave_oncleanup::static_type_id () < 0)
-        octave_oncleanup::register_type ();
-
-      retval = new octave_oncleanup (args(0));
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
-/*
-
-%!test
-%! old_wstate = warning ("query");
-%! unwind_protect
-%!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
-%!   warning ("off", "__MY_WARNING__");
-%!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
-%!   clear trigger
-%!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
-%! unwind_protect_cleanup
-%!   warning (old_wstate);
-%! end_unwind_protect
-
-*/
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -169,23 +169,24 @@ where @code{sigma_max (@var{x})} is the 
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
 %! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
 %! b = pinv (a);
-%! tol = 1e-14;
-%! hitol = 15*sqrt(eps);
+%! tol = 4e-14;
+%! hitol = 40*sqrt (eps);
 %! d = diag ([rand, rand, hitol, hitol]);
 %! u = rand (4);                      ## Could be singular by freak accident
 %! x = inv (u)*d*u;
-%! y = pinv (x, sqrt(eps));
-%!assert(a*b*a, a, tol);
-%!assert(b*a*b, b, tol);
-%!assert((b*a)', b*a, tol);
-%!assert((a*b)', a*b, tol);
-%!assert(x*y*x, x, -hitol);
-%!assert(y*x*y, y, -hitol);
-%!assert((x*y)', x*y, hitol);
-%!assert((y*x)', y*x, hitol);
+%! y = pinv (x, sqrt (eps));
+%!
+%!assert (a*b*a, a, tol)
+%!assert (b*a*b, b, tol)
+%!assert ((b*a)', b*a, tol)
+%!assert ((a*b)', a*b, tol)
+%!assert (x*y*x, x, -hitol)
+%!assert (y*x*y, y, -hitol)
+%!assert ((x*y)', x*y, hitol)
+%!assert ((y*x)', y*x, hitol)
 */
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2008-2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -495,17 +495,17 @@ x = @var{R} \\ @var{C}\n\
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!error <Invalid call to qr> qr ();
 %!error <Invalid call to qr> qr ([1, 2; 3, 4], 0, 2);
 
-%!function retval = testqr (q, r, a, p)
+%!function retval = __testqr (q, r, a, p)
 %!  tol = 100*eps (class(q));
 %!  retval = 0;
 %!  if (nargin == 3)
 %!    n1 = norm (q*r-a);
 %!    n2 = norm (q'*q-eye(columns(q)));
 %!    retval = (n1 < tol && n2 < tol);
 %!  else
 %!    n1 = norm (q'*q-eye(columns(q)));
@@ -513,58 +513,60 @@ x = @var{R} \\ @var{C}\n\
 %!    if (isvector (p))
 %!      n2 = norm (q*r-a(:,p));
 %!      retval = (retval && n2 < tol);
 %!    else
 %!      n2 = norm (q*r - a*p);
 %!      retval = (retval && n2 < tol);
 %!    endif
 %!  endif
+%!endfunction
+
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps;
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps;
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
@@ -620,51 +622,51 @@ x = @var{R} \\ @var{C}\n\
 
 %!test
 %!
 %! t = ones (24, 1);
 %! j = 1;
 %!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %!   a = a+1i*eps('single');
-%!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%!   [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%!   [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%!   [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%!   [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %! endif
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a'); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a'); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = a+1i*eps('single');
-%! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
-%! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
-%! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
-%! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
+%! [q,r]=qr(a,0); t(j++) = __testqr(q,r,a);
+%! [q,r]=qr(a',0); t(j++) = __testqr(q,r,a');
+%! [q,r,p]=qr(a,0); t(j++) = __testqr(q,r,a,p);
+%! [q,r,p]=qr(a',0); t(j++) = __testqr(q,r,a',p);
 %!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
@@ -1169,17 +1171,17 @@ If @var{orient} is @code{\"row\"}, full 
 DEFUN_DLD (qrdelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
 (if @var{orient} is \"col\"), or the QR@tie{}factorization of\n\
-@w{[A(1:j-1,:);A(:,j+1:n)]}, i.e., @var{A} with one row deleted (if\n\
+@w{[A(1:j-1,:);A(j+1:n,:)]}, i.e., @var{A} with one row deleted (if\n\
 @var{orient} is \"row\").\n\
 \n\
 The default value of @var{orient} is \"col\".\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
 @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{A(:,@var{j}) = []} gives @var{B}.\n\
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -469,39 +469,43 @@ variable by routines @code{dblquad} and 
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function y = f (x)
+%!function y = __f (x)
 %! y = x + 1;
+%!endfunction
+
 %!test
-%! [v, ier, nfun, err] = quad ("f", 0, 5);
+%! [v, ier, nfun, err] = quad ("__f", 0, 5);
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 &&
 %!        err < sqrt (eps))
 %!test
-%! [v, ier, nfun, err] = quad ("f", single(0), single(5));
+%! [v, ier, nfun, err] = quad ("__f", single(0), single(5));
 %! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 &&
 %!        err < sqrt (eps ("single")))
 
-%!function y = f (x)
+%!function y = __f (x)
 %!  y = x .* sin (1 ./ x) .* sqrt (abs (1 - x));
+%!endfunction
+
 %!test
-%!  [v, ier, nfun, err] = quad ("f", 0.001, 3);
+%!  [v, ier, nfun, err] = quad ("__f", 0.001, 3);
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps) && nfun > 0);
 %!test
-%!  [v, ier, nfun, err] = quad ("f", single(0.001), single(3));
+%!  [v, ier, nfun, err] = quad ("__f", single(0.001), single(3));
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps ("single")) && nfun > 0);
 
 %!error <Invalid call to quad> quad ();
 
-%!error <Invalid call to quad> quad ("f", 1, 2, 3, 4, 5);
+%!error <Invalid call to quad> quad ("__f", 1, 2, 3, 4, 5);
 
 %!test
 %! quad_options ("absolute tolerance", eps);
 %! assert(quad_options ("absolute tolerance") == eps);
 
 %!error <Invalid call to quad_options> quad_options (1, 2, 3);
 
 */
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Pedro Gonnet
+Copyright (C) 2010-2012 Pedro Gonnet
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -26,21 +26,16 @@ along with Octave; see the file COPYING.
 
 #include <stdlib.h>
 #include "lo-math.h"
 #include "lo-ieee.h"
 #include "oct.h"
 #include "parse.h"
 #include "ov-fcn-handle.h"
 
-#if ! defined (HAVE_COPYSIGN) && defined (HAVE__COPYSIGN)
-#define copysign _copysign
-#define HAVE_COPYSIGN 1
-#endif
-
 /* Define the size of the interval heap. */
 #define cquad_heapsize                  200
 
 
 /* Data of a single interval */
 typedef struct
 {
   double a, b;
@@ -1650,17 +1645,17 @@ Mathematical Software, Vol. 37, Issue 3,
     }
 
   /* If a or b are +/-Inf, transform the integral. */
   if (xisinf (a) || xisinf (b))
     {
       wrap = true;
       for (i = 0; i <= nivals; i++)
         if (xisinf (iivals[i]))
-          iivals[i] = copysign (1.0, iivals[i]);
+          iivals[i] = gnulib::copysign (1.0, iivals[i]);
         else
           iivals[i] = 2.0 * atan (iivals[i]) / M_PI;
     }
 
 
   /* Initialize the heaps. */
   for (i = 0; i < cquad_heapsize; i++)
     heap[i] = i;
@@ -2015,17 +2010,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivl->err = ncdiff * h;
           /* Check for divergence. */
           ivl->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivl->c[0] / iv->c[0] > 2);
           if (ivl->ndiv > ndiv_max && 2 * ivl->ndiv > ivl->rdepth)
             {
-              igral = copysign (octave_Inf, igral);
+              igral = gnulib::copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           /* Compute the local integral. */
           ivl->igral = h * w * ivl->c[0];
 
 
@@ -2111,17 +2106,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivr->err = ncdiff * h;
           /* Check for divergence. */
           ivr->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivr->c[0] / iv->c[0] > 2);
           if (ivr->ndiv > ndiv_max && 2 * ivr->ndiv > ivr->rdepth)
             {
-              igral = copysign (octave_Inf, igral);
+              igral = gnulib::copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           /* Compute the local integral. */
           ivr->igral = h * w * ivr->c[0];
 
 
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1998-2011 A. S. Hodel
+Copyright (C) 1998-2012 A. S. Hodel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -1019,19 +1019,19 @@ D 50 p1284, 1994.\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
-replacement from @code{1:@var{n}}. The complexity is O(@var{n}) in\n\
+replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
-O(@var{m}) memory is used as well. The randomization is performed using\n\
+O(@var{m}) memory is used as well.  The randomization is performed using\n\
 rand(). All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
 
 #ifdef USE_UNORDERED_MAP_WITH_TR1
 using std::tr1::unordered_map;
 #else
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 David Bateman
+Copyright (C) 2008-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 2002-2005 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -20,607 +20,225 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <algorithm>
+#include <list>
 #include <sstream>
 
-#include "defun-dld.h"
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "utils.h"
-
-#include "Cell.h"
-#include "oct-map.h"
-#include "str-vec.h"
-#include "quit.h"
-#include "parse.h"
-#include "oct-locbuf.h"
-
 #include <pcre.h>
 
-// Define the maximum number of retries for a pattern that
-// possibly results in an infinite recursion.
-#define PCRE_MATCHLIMIT_MAX 10
-
-// The regexp is constructed as a linked list to avoid resizing the
-// return values in arrays at each new match.
-
-// FIXME don't bother collecting and composing return values the user
-// doesn't want.
-
-class regexp_elem
-{
-public:
-  regexp_elem (const string_vector& _named_token, const Cell& _t,
-               const std::string& _m, const Matrix& _te, double _s,
-               double _e) :
-    named_token (_named_token), t (_t), m (_m), te (_te), s (_s), e (_e) { }
-
-  regexp_elem (const regexp_elem &a) : named_token (a.named_token), t (a.t),
-                                       m (a.m), te (a.te), s (a.s), e (a.e)
-                                       { }
-
-  string_vector named_token;
-  Cell t;
-  std::string m;
-  Matrix te;
-  double s;
-  double e;
-};
-
-typedef std::list<regexp_elem>::const_iterator const_iterator;
-
-#define MAXLOOKBEHIND 10
-static bool lookbehind_warned = false;
+#include "base-list.h"
+#include "oct-locbuf.h"
+#include "quit.h"
+#include "regexp.h"
+#include "str-vec.h"
 
-static int
-octregexp_list (const octave_value_list &args, const std::string &nm,
-                bool case_insensitive, std::list<regexp_elem> &lst,
-                string_vector &named, int &nopts, bool &once)
-{
-  int sz = 0;
-
-  int nargin = args.length ();
-  bool lineanchors = false;
-  bool dotexceptnewline = false;
-  bool freespacing = false;
-
-  nopts = nargin - 2;
-  once = false;
+#include "defun-dld.h"
+#include "Cell.h"
+#include "error.h"
+#include "gripes.h"
+#include "oct-map.h"
+#include "oct-obj.h"
+#include "utils.h"
 
-  std::string buffer = args(0).string_value ();
-  size_t max_length = (buffer.length () > MAXLOOKBEHIND ?
-                       MAXLOOKBEHIND: buffer.length ());
-
-  if (error_state)
-    {
-      gripe_wrong_type_arg (nm.c_str (), args(0));
-      return 0;
-    }
+static void
+parse_options (regexp::opts& options, const octave_value_list& args,
+               const std::string& who, int skip, bool& extra_args)
+{
+  int nargin = args.length ();
 
-  std::string pattern = args(1).string_value ();
+  extra_args = false;
 
-  if (error_state)
-    {
-      gripe_wrong_type_arg (nm.c_str (), args(1));
-      return 0;
-    }
-
-  for (int i = 2; i < nargin; i++)
+  for (int i = skip; i < nargin; i++)
     {
       std::string str = args(i).string_value ();
 
       if (error_state)
         {
-          error ("%s: optional arguments must be strings", nm.c_str ());
+          error ("%s: optional arguments must be character strings",
+                 who.c_str ());
           break;
         }
 
       std::transform (str.begin (), str.end (), str.begin (), tolower);
 
       if (str.find ("once", 0) == 0)
-        {
-          once = true;
-          nopts--;
-        }
+        options.once (true);
       else if (str.find ("matchcase", 0) == 0)
-        {
-          case_insensitive = false;
-          nopts--;
-        }
+        options.case_insensitive (false);
       else if (str.find ("ignorecase", 0) == 0)
-        {
-          case_insensitive = true;
-          nopts--;
-        }
+        options.case_insensitive (true);
       else if (str.find ("dotall", 0) == 0)
-        {
-          dotexceptnewline = false;
-          nopts--;
-        }
+        options.dotexceptnewline (false);
       else if (str.find ("stringanchors", 0) == 0)
-        {
-          lineanchors = false;
-          nopts--;
-        }
+        options.lineanchors (false);
       else if (str.find ("literalspacing", 0) == 0)
-        {
-          freespacing = false;
-          nopts--;
-        }
+        options.freespacing (false);
       else if (str.find ("dotexceptnewline", 0) == 0)
-        {
-          dotexceptnewline = true;
-          nopts--;
-        }
+        options.dotexceptnewline (true);
       else if (str.find ("lineanchors", 0) == 0)
-        {
-          lineanchors = true;
-          nopts--;
-        }
+        options.lineanchors (true);
       else if (str.find ("freespacing", 0) == 0)
-        {
-          freespacing = true;
-          nopts--;
-        }
-      else if (str.find ("start", 0) && str.find ("end", 0)
-               && str.find ("tokenextents", 0) && str.find ("match", 0)
-               && str.find ("tokens", 0) && str.find ("names", 0)
-               && str.find ("split", 0))
-        error ("%s: unrecognized option", nm.c_str ());
+        options.freespacing (true);
+      else if (str.find ("start", 0) == 0
+               || str.find ("end", 0) == 0
+               || str.find ("tokenextents", 0) == 0
+               || str.find ("match", 0) == 0
+               || str.find ("tokens", 0) == 0
+               || str.find ("names", 0) == 0
+               || str.find ("split", 0) == 0)
+        extra_args = true;
+      else
+        error ("%s: unrecognized option", who.c_str ());
     }
-
-  if (!error_state)
-    {
-      Cell t;
-      std::string m;
-      double s, e;
-
-      // named tokens "(?<name>...)" are only treated with PCRE not regex.
-
-      size_t pos = 0;
-      size_t new_pos;
-      int nnames = 0;
-      int inames = 0;
-      std::ostringstream buf;
-      Array<int> named_idx;
-
-      while ((new_pos = pattern.find ("(?", pos)) != std::string::npos)
-        {
-          if (pattern.at (new_pos + 2) == '<'
-              && !(pattern.at (new_pos + 3) == '='
-                   || pattern.at (new_pos + 3) == '!'))
-            {
-              // The syntax of named tokens in pcre is "(?P<name>...)" while
-              // we need a syntax "(?<name>...)", so fix that here. Also an
-              // expression like
-              // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
-              // should be perfectly legal, while pcre does not allow the same
-              // named token name on both sides of the alternative. Also fix
-              // that here by replacing name tokens by dummy names, and dealing
-              // with the dummy names later.
-
-              size_t tmp_pos = pattern.find_first_of ('>', new_pos);
-
-              if (tmp_pos == std::string::npos)
-                {
-                  error ("regexp: syntax error in pattern");
-                  break;
-                }
-
-              std::string tmp_name =
-                pattern.substr (new_pos+3, tmp_pos-new_pos-3);
-
-              bool found = false;
-
-              for (int i = 0; i < nnames; i++)
-                {
-                  if (named(i) == tmp_name)
-                    {
-                      named_idx.resize (dim_vector (inames+1, 1));
-                      named_idx(inames) = i;
-                      found = true;
-                      break;
-                    }
-                }
-
-              if (! found)
-                {
-                  named_idx.resize (dim_vector (inames+1, 1));
-                  named_idx(inames) = nnames;
-                  named.append (tmp_name);
-                  nnames++;
-                }
-
-              if (new_pos - pos > 0)
-                buf << pattern.substr (pos, new_pos-pos);
-              if (inames < 10)
-                buf << "(?P<n00" << inames++;
-              else if (inames < 100)
-                buf << "(?P<n0" << inames++;
-              else
-                buf << "(?P<n" << inames++;
-
-              pos = tmp_pos;
-            }
-          else if (pattern.at (new_pos + 2) == '<')
-            {
-              // Find lookbehind operators of arbitrary length (ie like
-              // "(?<=[a-z]*)") and replace with a maximum length operator
-              // as PCRE can not yet handle arbitrary length lookahead
-              // operators. Use the string length as the maximum length to
-              // avoid issues.
-
-              int brackets = 1;
-              size_t tmp_pos1 = new_pos + 2;
-              size_t tmp_pos2 = tmp_pos1;
-
-              while (tmp_pos1 <= pattern.length () && brackets > 0)
-                {
-                  char ch = pattern.at (tmp_pos1);
-
-                  if (ch == '(')
-                    brackets++;
-                  else if (ch == ')')
-                    {
-                      if (brackets > 1)
-                        tmp_pos2 = tmp_pos1;
-
-                      brackets--;
-                    }
-
-                  tmp_pos1++;
-                }
-
-              if (brackets != 0)
-                {
-                  buf << pattern.substr (pos, new_pos - pos) << "(?";
-                  pos = new_pos + 2;
-                }
-              else
-                {
-                  size_t tmp_pos3 = pattern.find_first_of ("*+", tmp_pos2);
-
-                  if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
-                    {
-                      if (!lookbehind_warned)
-                        {
-                          lookbehind_warned = true;
-                          warning ("%s: arbitrary length lookbehind patterns are only supported up to length %d",
-                                   nm.c_str (), MAXLOOKBEHIND);
-                        }
-
-                      buf << pattern.substr (pos, new_pos - pos) << "(";
-
-                      size_t i;
-
-                      if (pattern.at (tmp_pos3) == '*')
-                        i = 0;
-                      else
-                        i = 1;
-
-                      for (; i < max_length + 1; i++)
-                        {
-                          buf << pattern.substr (new_pos, tmp_pos3 - new_pos)
-                              << "{" << i << "}";
-                          buf << pattern.substr (tmp_pos3 + 1,
-                                                 tmp_pos1 - tmp_pos3 - 1);
-                          if (i != max_length)
-                            buf << "|";
-                        }
-                      buf << ")";
-                    }
-                  else
-                    buf << pattern.substr (pos, tmp_pos1 - pos);
-
-                  pos = tmp_pos1;
-                }
-            }
-          else
-            {
-              buf << pattern.substr (pos, new_pos - pos) << "(?";
-              pos = new_pos + 2;
-            }
-
-        }
-
-      buf << pattern.substr (pos);
-
-      if (error_state)
-        return 0;
-
-      // Compile expression
-      const char *err;
-      int erroffset;
-      std::string buf_str = buf.str ();
-
-      pcre *re = pcre_compile (buf_str.c_str (),
-                               ((case_insensitive ? PCRE_CASELESS : 0)
-                                | (dotexceptnewline ? 0 : PCRE_DOTALL)
-                                | (lineanchors ? PCRE_MULTILINE : 0)
-                                | (freespacing ? PCRE_EXTENDED : 0)),
-                               &err, &erroffset, 0);
-
-      if (re == 0)
-        {
-          error ("%s: %s at position %d of expression", nm.c_str (),
-                 err, erroffset);
-          return 0;
-        }
-
-      int subpatterns;
-      int namecount;
-      int nameentrysize;
-      char *nametable;
-      int idx = 0;
-
-      pcre_fullinfo (re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
-      pcre_fullinfo (re, 0, PCRE_INFO_NAMECOUNT, &namecount);
-      pcre_fullinfo (re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
-      pcre_fullinfo (re, 0, PCRE_INFO_NAMETABLE, &nametable);
-
-      OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
-      OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
-
-      for (int i = 0; i < namecount; i++)
-        {
-          // Index of subpattern in first two bytes MSB first of name.
-          // Extract index.
-          nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
-            | static_cast<int> (nametable[i*nameentrysize+1]);
-        }
-
-      while (true)
-        {
-          OCTAVE_QUIT;
-
-          int matches = pcre_exec (re, 0, buffer.c_str (),
-                                   buffer.length (), idx,
-                                   (idx ? PCRE_NOTBOL : 0),
-                                   ovector, (subpatterns+1)*3);
-
-          if (matches == PCRE_ERROR_MATCHLIMIT)
-            {
-              // Try harder; start with default value for MATCH_LIMIT
-              // and increase it.
-              warning ("your pattern caused PCRE to hit its MATCH_LIMIT; trying harder now, but this will be slow");
-
-              pcre_extra pe;
-
-              pcre_config (PCRE_CONFIG_MATCH_LIMIT,
-                           static_cast <void *> (&pe.match_limit));
-
-              pe.flags = PCRE_EXTRA_MATCH_LIMIT;
-
-              int i = 0;
-              while (matches == PCRE_ERROR_MATCHLIMIT
-                     && i++ < PCRE_MATCHLIMIT_MAX)
-                {
-                  OCTAVE_QUIT;
-
-                  pe.match_limit *= 10;
-                  matches = pcre_exec (re, &pe, buffer.c_str (),
-                                       buffer.length (), idx,
-                                       (idx ? PCRE_NOTBOL : 0),
-                                       ovector, (subpatterns+1)*3);
-                }
-            }
-
-          if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
-            {
-              error ("%s: internal error calling pcre_exec; error code from pcre_exec is %i",
-                     nm.c_str (), matches);
-              pcre_free (re);
-              return 0;
-            }
-          else if (matches == PCRE_ERROR_NOMATCH)
-            break;
-          else if (ovector[1] <= ovector[0])
-            {
-              // Zero sized match.  Skip to next char.
-              idx = ovector[0] + 1;
-              if (idx < buffer.length ())
-                continue;
-              else
-                break;
-            }
-          else
-            {
-              int pos_match = 0;
-              Matrix te (matches-1, 2);
-
-              for (int i = 1; i < matches; i++)
-                {
-                  if (ovector[2*i] >= 0 && ovector[2*i+1] > 0
-                      && (i == 1 || ovector[2*i] != ovector[2*i-2]
-                          || ovector[2*i-1] != ovector[2*i+1])
-                      && ovector[2*i] >= 0 && ovector[2*i+1] > 0)
-                    {
-                      te(pos_match,0) = double (ovector[2*i]+1);
-                      te(pos_match++,1) = double (ovector[2*i+1]);
-                    }
-                }
-
-              te.resize (pos_match, 2);
-
-              s = double (ovector[0]+1);
-              e = double (ovector[1]);
-
-              const char **listptr;
-              int status = pcre_get_substring_list (buffer.c_str (), ovector,
-                                                   matches, &listptr);
-
-              if (status == PCRE_ERROR_NOMEMORY)
-                {
-                  error ("%s: cannot allocate memory in pcre_get_substring_list",
-                        nm.c_str ());
-                  pcre_free (re);
-                  return 0;
-                }
-
-              Cell cell_t (dim_vector (1, pos_match));
-              string_vector named_tokens (nnames);
-              int pos_offset = 0;
-              pos_match = 0;
-
-              for (int i = 1; i < matches; i++)
-                {
-                  if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
-                    {
-                      if (i == 1 || ovector[2*i] != ovector[2*i-2]
-                          || ovector[2*i-1] != ovector[2*i+1])
-                        {
-                          if (namecount > 0)
-                            named_tokens(named_idx(i-pos_offset-1)) =
-                              std::string (*(listptr+nidx[i-pos_offset-1]));
-                          cell_t(pos_match++) =
-                            std::string (*(listptr+i));
-                        }
-                      else
-                        pos_offset++;
-                    }
-                }
-
-              m =  std::string (*listptr);
-              t = cell_t;
-
-              pcre_free_substring_list (listptr);
-
-              regexp_elem new_elem (named_tokens, t, m, te, s, e);
-              lst.push_back (new_elem);
-              idx = ovector[1];
-              sz++;
-
-              if (once || idx >= buffer.length ())
-                break;
-
-            }
-        }
-
-      pcre_free (re);
-    }
-
-  return sz;
 }
 
 static octave_value_list
-octregexp (const octave_value_list &args, int nargout, const std::string &nm,
-           bool case_insensitive)
+octregexp (const octave_value_list &args, int nargout,
+           const std::string &who, bool case_insensitive = false)
 {
   octave_value_list retval;
+
   int nargin = args.length ();
-  std::list<regexp_elem> lst;
-  string_vector named;
-  int nopts;
-  bool once;
+
+  // Make sure we have string, pattern
+  const std::string buffer = args(0).string_value ();
+  if (error_state)
+    return retval;
+
+  const std::string pattern = args(1).string_value ();
+  if (error_state)
+    return retval;
 
-  int sz = octregexp_list (args, nm, case_insensitive, lst, named, nopts, once);
+  regexp::opts options;
+  options.case_insensitive (case_insensitive);
+  bool extra_options = false;
+  parse_options (options, args, who, 2, extra_options);
+  if (error_state)
+    return retval;
+
+  regexp::match_data rx_lst = regexp_match (pattern, buffer, options, who);
+
+  string_vector named_pats = rx_lst.named_patterns ();
+
+  size_t sz = rx_lst.size ();
 
   if (! error_state)
     {
       // Converted the linked list in the correct form for the return values
 
       octave_idx_type i = 0;
       octave_scalar_map nmap;
 
       retval.resize (7);
 
       if (sz == 1)
         {
-          for (int j = 0; j < named.length (); j++)
-            nmap.assign (named(j), lst.begin()->named_token (j));
+          string_vector named_tokens = rx_lst.begin()->named_tokens ();
+
+          for (int j = 0; j < named_pats.length (); j++)
+            nmap.assign (named_pats(j), named_tokens(j));
 
           retval(5) = nmap;
         }
       else
         {
-          for (int j = 0; j < named.length (); j++)
+          for (int j = 0; j < named_pats.length (); j++)
             {
               Cell tmp (dim_vector (1, sz));
 
               i = 0;
-              for (const_iterator p = lst.begin (); p != lst.end (); p++)
-                tmp(i++) = p->named_token (j);
+              for (regexp::match_data::const_iterator p = rx_lst.begin ();
+                   p != rx_lst.end (); p++)
+                {
+                  string_vector named_tokens = p->named_tokens ();
 
-              nmap.assign (named(j), octave_value (tmp));
+                  tmp(i++) = named_tokens(j);
+                }
+
+              nmap.assign (named_pats(j), octave_value (tmp));
             }
 
           retval(5) = nmap;
         }
 
-      std::string buffer = args(0).string_value ();
-
-      if (once)
+      if (options.once ())
         {
-          retval(4) = sz ? lst.front ().t : Cell ();
-          retval(3) = sz ? lst.front ().m : std::string ();
-          retval(2) = sz ? lst.front ().te : Matrix ();
+          regexp::match_data::const_iterator p = rx_lst.begin ();
+
+          retval(4) = sz ? p->tokens () : Cell ();
+          retval(3) = sz ? p->match_string () : std::string ();
+          retval(2) = sz ? p->token_extents () : Matrix ();
 
           if (sz)
             {
-              double e = lst.front ().e;
-              double s = lst.front ().s;
+              double start = p->start ();
+              double end = p->end ();
 
-              Cell sp (dim_vector (1, 2));
-              sp(0) = buffer.substr (0, s-1);
-              sp(1) = buffer.substr (e);
+              Cell split (dim_vector (1, 2));
+              split(0) = buffer.substr (0, start-1);
+              split(1) = buffer.substr (end);
 
-              retval(6) = sp;
-              retval(1) = e;
-              retval(0) = s;
+              retval(6) = split;
+              retval(1) = end;
+              retval(0) = start;
             }
           else
             {
               retval(6) = buffer;
               retval(1) = Matrix ();
               retval(0) = Matrix ();
             }
         }
       else
         {
-          Cell t (dim_vector (1, sz));
-          Cell m (dim_vector (1, sz));
-          Cell te (dim_vector (1, sz));
-          NDArray e (dim_vector (1, sz));
-          NDArray s (dim_vector (1, sz));
-          Cell sp (dim_vector (1, sz+1));
+          Cell tokens (dim_vector (1, sz));
+          Cell match_string (dim_vector (1, sz));
+          Cell token_extents (dim_vector (1, sz));
+          NDArray end (dim_vector (1, sz));
+          NDArray start (dim_vector (1, sz));
+          Cell split (dim_vector (1, sz+1));
           size_t sp_start = 0;
 
           i = 0;
-          for (const_iterator p = lst.begin (); p != lst.end (); p++)
+          for (regexp::match_data::const_iterator p = rx_lst.begin ();
+               p != rx_lst.end (); p++)
             {
-              t(i) = p->t;
-              m(i) = p->m;
-              te(i) = p->te;
-              e(i) = p->e;
-              s(i) = p->s;
-              sp(i) = buffer.substr (sp_start, p->s-sp_start-1);
-              sp_start = p->e;
+              double s = p->start ();
+              double e = p->end ();
+
+              string_vector tmp = p->tokens ();
+              tokens(i) = Cell (dim_vector (1, tmp.length ()), tmp);
+              match_string(i) = p->match_string ();
+              token_extents(i) = p->token_extents ();
+              end(i) = e;
+              start(i) = s;
+              split(i) = buffer.substr (sp_start, s-sp_start-1);
+              sp_start = e;
               i++;
             }
 
-          sp(i) = buffer.substr (sp_start);
+          split(i) = buffer.substr (sp_start);
 
-          retval(6) = sp;
-          retval(4) = t;
-          retval(3) = m;
-          retval(2) = te;
-          retval(1) = e;
-          retval(0) = s;
+          retval(6) = split;
+          retval(4) = tokens;
+          retval(3) = match_string;
+          retval(2) = token_extents;
+          retval(1) = end;
+          retval(0) = start;
         }
 
       // Alter the order of the output arguments
-      if (nopts > 0)
+
+      if (extra_options)
         {
           int n = 0;
           octave_value_list new_retval;
           new_retval.resize (nargout);
 
           OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
           for (int j = 0; j < 6; j++)
             arg_used[j] = false;
@@ -677,17 +295,17 @@ octregexp (const octave_value_list &args
         }
     }
 
   return retval;
 }
 
 static octave_value_list
 octcellregexp (const octave_value_list &args, int nargout,
-               const std::string &nm, bool case_insensitive)
+               const std::string &who, bool case_insensitive = false)
 {
   octave_value_list retval;
 
   if (args(0).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellstr = args(0).cell_value ();
@@ -700,17 +318,17 @@ octcellregexp (const octave_value_list &
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize (cellstr.dims ());
 
               new_args(1) = cellpat(0);
 
               for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 {
                   new_args(0) = cellstr(i);
-                  octave_value_list tmp = octregexp (new_args, nargout, nm,
+                  octave_value_list tmp = octregexp (new_args, nargout, who,
                                                      case_insensitive);
 
                   if (error_state)
                     break;
 
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
@@ -720,42 +338,42 @@ octcellregexp (const octave_value_list &
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize (cellpat.dims ());
 
               new_args(0) = cellstr(0);
 
               for (octave_idx_type i = 0; i < cellpat.numel (); i++)
                 {
                   new_args(1) = cellpat(i);
-                  octave_value_list tmp = octregexp (new_args, nargout, nm,
+                  octave_value_list tmp = octregexp (new_args, nargout, who,
                                                      case_insensitive);
 
                   if (error_state)
                     break;
 
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
             }
           else if (cellstr.numel () == cellpat.numel ())
             {
 
               if (cellstr.dims () != cellpat.dims ())
-                error ("%s: Inconsistent cell array dimensions", nm.c_str ());
+                error ("%s: inconsistent cell array dimensions", who.c_str ());
               else
                 {
                   for (int j = 0; j < nargout; j++)
                     newretval[j].resize (cellstr.dims ());
 
                   for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                     {
                       new_args(0) = cellstr(i);
                       new_args(1) = cellpat(i);
 
-                      octave_value_list tmp = octregexp (new_args, nargout, nm,
+                      octave_value_list tmp = octregexp (new_args, nargout, who,
                                                          case_insensitive);
 
                       if (error_state)
                         break;
 
                       for (int j = 0; j < nargout; j++)
                         newretval[j](i) = tmp(j);
                     }
@@ -767,17 +385,17 @@ octcellregexp (const octave_value_list &
       else
         {
           for (int j = 0; j < nargout; j++)
             newretval[j].resize (cellstr.dims ());
 
           for (octave_idx_type i = 0; i < cellstr.numel (); i++)
             {
               new_args(0) = cellstr(i);
-              octave_value_list tmp = octregexp (new_args, nargout, nm,
+              octave_value_list tmp = octregexp (new_args, nargout, who,
                                                  case_insensitive);
 
               if (error_state)
                 break;
 
               for (int j = 0; j < nargout; j++)
                 newretval[j](i) = tmp(j);
             }
@@ -794,34 +412,34 @@ octcellregexp (const octave_value_list &
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
         newretval[j].resize(cellpat.dims ());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
         {
           new_args(1) = cellpat(i);
-          octave_value_list tmp = octregexp (new_args, nargout, nm,
+          octave_value_list tmp = octregexp (new_args, nargout, who,
                                              case_insensitive);
 
           if (error_state)
             break;
 
           for (int j = 0; j < nargout; j++)
             newretval[j](i) = tmp(j);
         }
 
       if (!error_state)
         {
           for (int j = 0; j < nargout; j++)
             retval(j) = octave_value (newretval[j]);
         }
     }
   else
-    retval = octregexp (args, nargout, nm, case_insensitive);
+    retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
 DEFUN_DLD (regexp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}] =} regexp (@var{str}, @var{pat})\n\
@@ -1017,19 +635,19 @@ Alternatively, use (?x) in the pattern.\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
   else if (args(0).is_cell () || args(1).is_cell ())
-    retval = octcellregexp (args, nargout, "regexp", false);
+    retval = octcellregexp (args, nargout, "regexp");
   else
-    retval = octregexp (args, nargout, "regexp", false);
+    retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
 
 ## PCRE_ERROR_MATCHLIMIT test
 %!test
@@ -1397,17 +1015,17 @@ syntax of the search pattern.\n\
 %!assert(regexpi({'asdfg-dfd','-dfd-dfd-','qasfdfdaq'},'-'),{6,[1,5,9],zeros(1,0)})
 %!assert(regexpi({'asdfg-dfd';'-dfd-dfd-';'qasfdfdaq'},{'-';'f';'q'}),{6;[3,7];[1,9]})
 %!assert(regexpi('Strings',{'t','s'}),{2,[1,7]})
 
 */
 
 
 static octave_value
-octregexprep (const octave_value_list &args, const std::string &nm)
+octregexprep (const octave_value_list &args, const std::string &who)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   // Make sure we have string, pattern, replacement
   const std::string buffer = args(0).string_value ();
   if (error_state)
@@ -1418,193 +1036,38 @@ octregexprep (const octave_value_list &a
     return retval;
 
   const std::string replacement = args(2).string_value ();
   if (error_state)
     return retval;
 
   // Pack options excluding 'tokenize' and various output
   // reordering strings into regexp arg list
-  octave_value_list regexpargs (nargin-1, octave_value ());
+  octave_value_list regexpargs (nargin-3, octave_value ());
 
-  regexpargs(0) = args (0);
-  regexpargs(1) = args (1);
-
-  int len = 2;
+  int len = 0;
   for (int i = 3; i < nargin; i++)
     {
       const std::string opt = args(i).string_value ();
       if (opt != "tokenize" && opt != "start" && opt != "end"
           && opt != "tokenextents" && opt != "match" && opt != "tokens"
           && opt != "names"  && opt != "split" && opt != "warnings")
         {
           regexpargs(len++) = args(i);
         }
     }
   regexpargs.resize (len);
 
-  // Identify replacement tokens; build a vector of group numbers in
-  // the replacement string so that we can quickly calculate the size
-  // of the replacement.
-  int tokens = 0;
-  for (size_t i=1; i < replacement.size (); i++)
-    {
-      if (replacement[i-1]=='$' && isdigit (replacement[i]))
-        {
-          tokens++;
-          i++;
-        }
-    }
-  std::vector<int> token (tokens);
-
-  int kk = 0;
-  for (size_t i = 1; i < replacement.size (); i++)
-    {
-      if (replacement[i-1]=='$' && isdigit (replacement[i]))
-        {
-          token[kk++] = replacement[i]-'0';
-          i++;
-        }
-    }
-
-  // Perform replacement
-  std::string rep;
-
-  if (tokens > 0)
-    {
-      std::list<regexp_elem> lst;
-      string_vector named;
-      int nopts;
-      bool once;
-      int sz = octregexp_list (regexpargs, nm , false, lst, named, nopts, once);
-
-      if (error_state)
-        return retval;
-      if (sz == 0)
-        {
-          retval = args(0);
-          return retval;
-        }
-
-      // Determine replacement length
-      const size_t replen = replacement.size () - 2*tokens;
-      int delta = 0;
-      const_iterator p = lst.begin ();
-      for (int i = 0; i < sz; i++)
-        {
-          OCTAVE_QUIT;
-
-          const Matrix pairs (p->te);
-          size_t pairlen = 0;
-          for (int j = 0; j < tokens; j++)
-            {
-              if (token[j] == 0)
-                pairlen += static_cast<size_t> (p->e - p->s) + 1;
-              else if (token[j] <= pairs.rows ())
-                pairlen += static_cast<size_t> (pairs(token[j]-1,1)
-                                                - pairs(token[j]-1,0)) + 1;
-            }
-          delta += static_cast<int> (replen + pairlen)
-            - static_cast<int> (p->e - p->s + 1);
-          p++;
-        }
-
-      // Build replacement string
-      rep.reserve (buffer.size () + delta);
-      size_t from = 0;
-      p = lst.begin ();
-      for (int i = 0; i < sz; i++)
-        {
-          OCTAVE_QUIT;
+  regexp::opts options;
+  bool extra_args = false;
+  parse_options (options, regexpargs, who, 0, extra_args);
+  if (error_state)
+    return retval;
 
-          const Matrix pairs (p->te);
-          rep.append (&buffer[from], static_cast<size_t> (p->s - 1) - from);
-          from = static_cast<size_t> (p->e - 1) + 1;
-          for (size_t j = 1; j < replacement.size (); j++)
-            {
-              if (replacement[j-1]=='$' && isdigit (replacement[j]))
-                {
-                  int k = replacement[j]-'0';
-                  if (k == 0)
-                    {
-                      // replace with entire match
-                      rep.append (&buffer[static_cast<size_t> (p->e - 1)],
-                                  static_cast<size_t> (p->e - p->s) + 1);
-                    }
-                  else if (k <= pairs.rows ())
-                    {
-                      // replace with group capture
-                      rep.append (&buffer[static_cast<size_t> (pairs(k-1,0)-1)],
-                                  static_cast<size_t> (pairs(k-1,1)
-                                                       - pairs(k-1,0)) + 1);
-                    }
-                  else
-                    {
-                      // replace with nothing
-                    }
-                  j++;
-                }
-              else
-                {
-                  rep.append (1, replacement[j-1]);
-                }
-              if (j+1 == replacement.size ())
-                {
-                  rep.append (1, replacement[j]);
-                }
-            }
-          p++;
-        }
-      rep.append (&buffer[from], buffer.size () - from);
-    }
-  else
-    {
-      std::list<regexp_elem> lst;
-      string_vector named;
-      int nopts;
-      bool once;
-      int sz = octregexp_list (regexpargs, nm, false, lst, named, nopts, once);
-
-      if (error_state)
-        return retval;
-      if (sz == 0)
-        {
-          retval = args (0);
-          return retval;
-        }
-
-      // Determine replacement length
-      const size_t replen = replacement.size ();
-      int delta = 0;
-      const_iterator p = lst.begin ();
-      for (int i = 0; i < sz; i++)
-        {
-          OCTAVE_QUIT;
-          delta += static_cast<int> (replen)
-            - static_cast<int> (p->e - p->s + 1);
-          p++;
-        }
-
-      // Build replacement string
-      rep.reserve (buffer.size () + delta);
-      size_t from = 0;
-      p = lst.begin ();
-      for (int i = 0; i < sz; i++)
-        {
-          OCTAVE_QUIT;
-          rep.append (&buffer[from], static_cast<size_t> (p->s - 1) - from);
-          from = static_cast<size_t> (p->e - 1) + 1;
-          rep.append (replacement);
-          p++;
-        }
-      rep.append (&buffer[from], buffer.size () - from);
-    }
-
-  retval = rep;
-  return retval;
+  return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
 DEFUN_DLD (regexprep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
 @deftypefnx {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
@@ -1667,17 +1130,17 @@ This option is present for compatibility
       else
         rep = Cell (args(2));
 
       dv0 = str.dims ();
       if (pat.numel () != 1)
         {
           dv1 = pat.dims ();
           if (rep.numel () != 1 && dv1 != rep.dims ())
-            error ("regexprep: Inconsistent cell array dimensions");
+            error ("regexprep: inconsistent cell array dimensions");
         }
       else if (rep.numel () != 1)
         dv1 = rep.dims ();
 
       if (!error_state)
         {
           Cell ret (dv0);
           octave_value_list new_args = args;
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -108,18 +108,18 @@ time.\n\
   if (nargin == 0)
     {
       if (nargout == 0)
         octave_sparse_params::print_info (octave_stdout, "");
       else if (nargout == 1)
         retval(0) =  octave_sparse_params::get_vals ();
       else if (nargout == 2)
         {
+          retval (1) = octave_sparse_params::get_vals ();
           retval (0) = octave_sparse_params::get_keys ();
-          retval (1) = octave_sparse_params::get_vals ();
         }
       else
         error ("spparms: too many output arguments");
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ross Lippert and Paul Kienzle
+Copyright (C) 2001-2012 Ross Lippert and Paul Kienzle
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -227,16 +227,22 @@ Mathematics, Manchester, England, Januar
   octave_idx_type nc = arg.columns ();
 
   if (n != nc || arg.ndims () > 2)
     {
       gripe_square_matrix_required ("sqrtm");
       return retval;
     }
 
+  if (nargout > 1)
+    {
+      retval.resize (1, 2);
+      retval(2) = -1.0;
+    }
+
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
     retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR> (arg);
   else if (arg.is_numeric_type ())
     retval(0) = do_sqrtm<Matrix, ComplexMatrix, ComplexSCHUR> (arg);
 
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 Jaroslav Hajek
+Copyright (C) 2010-2012 Jaroslav Hajek
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -41,46 +41,54 @@ along with Octave; see the file COPYING.
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static std::istringstream&
 single_num (std::istringstream& is, double& num)
 {
   char c = is.peek ();
+
+  // Skip spaces.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   if (c == 'I')
     {
       // It's infinity.
       is.get ();
       char c1 = is.get (), c2 = is.get ();
       if (c1 == 'n' && c2 == 'f')
         {
           num = octave_Inf;
-          is.peek (); // Sets eof bit.
+          is.peek (); // May sets EOF bit.
         }
       else
         is.setstate (std::ios::failbit); // indicate that read has failed.
     }
   else if (c == 'N')
     {
       // It's NA or NaN
       is.get ();
       char c1 = is.get ();
       if (c1 == 'A')
         {
           num = octave_NA;
-          is.peek (); // Sets eof bit.
+          is.peek (); // May set EOF bit.
         }
       else
         {
           char c2 = is.get ();
           if (c1 == 'a' && c2 == 'N')
             {
               num = octave_NaN;
-              is.peek (); // Sets eof bit.
+              is.peek (); // May set EOF bit.
             }
           else
             is.setstate (std::ios::failbit); // indicate that read has failed.
         }
     }
   else
     is >> num;
 
@@ -88,70 +96,122 @@ single_num (std::istringstream& is, doub
 }
 
 static std::istringstream&
 extract_num (std::istringstream& is, double& num, bool& imag, bool& have_sign)
 {
   have_sign = imag = false;
 
   char c = is.peek ();
+
+  // Skip leading spaces.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   bool negative = false;
 
   // Accept leading sign.
   if (c == '+' || c == '-')
     {
       negative = c == '-';
       is.get ();
       c = is.peek ();
       have_sign = true;
     }
 
+  // Skip spaces after sign.
+  while (isspace (c))
+    {
+      is.get ();
+      c = is.peek ();
+    }
+
   // It's i*num or just i.
   if (is_imag_unit (c))
     {
-      c = is.get ();
       imag = true;
-      char cn = is.peek ();
-      if (cn == '*')
+      is.get ();
+      c = is.peek ();
+
+      // Skip spaces after imaginary unit.
+      while (isspace (c))
+        {
+          is.get ();
+          c = is.peek ();
+        }
+
+      if (c == '*')
         {
           // Multiplier follows, we extract it as a number.
           is.get ();
           single_num (is, num);
+          if (is.good ())
+            c = is.peek ();
         }
       else
         num = 1.0;
     }
   else
     {
       // It's num, num*i, or numi.
       single_num (is, num);
       if (is.good ())
         {
           c = is.peek ();
+
+          // Skip spaces after number.
+          while (isspace (c))
+            {
+              is.get ();
+              c = is.peek ();
+            }
+
           if (c == '*')
             {
               is.get ();
-              c = is.get ();
+              c = is.peek ();
+
+              // Skip spaces after operator.
+              while (isspace (c))
+                {
+                  is.get ();
+                  c = is.peek ();
+                }
+
               if (is_imag_unit (c))
                 {
                   imag = true;
-                  is.peek ();
+                  is.get ();
+                  c = is.peek ();
                 }
               else
                 is.setstate (std::ios::failbit); // indicate that read has failed.
             }
           else if (is_imag_unit (c))
             {
               imag = true;
               is.get ();
-              is.peek ();
+              c = is.peek ();
             }
         }
     }
 
+  if (is.good ())
+    {
+      // Skip trailing spaces.
+      while (isspace (c))
+        {
+          is.get ();
+          c = is.peek ();
+        }
+    }
+
   if (negative)
     num = -num;
 
   return is;
 }
 
 static inline void
 set_component (Complex& c, double num, bool imag)
@@ -176,24 +236,22 @@ set_component (Complex& c, double num, b
 
 static Complex
 str2double1 (const std::string& str_arg)
 {
   Complex val (0.0, 0.0);
 
   std::string str = str_arg;
 
+  // FIXME -- removing all commas does too much...
   std::string::iterator se = str.end ();
-
-  // Remove commas (thousand separators) and spaces.
   se = std::remove (str.begin (), se, ',');
-  se = std::remove (str.begin (), se, ' ');
   str.erase (se, str.end ());
+  std::istringstream is (str);
 
-  std::istringstream is (str);
   double num;
   bool i1, i2, s1, s2;
 
   if (is.eof ())
     val = octave_NaN;
   else if (! extract_num (is, num, i1, s1))
     val = octave_NaN;
   else
@@ -290,26 +348,29 @@ risk of using @code{eval} on unknown dat
 
   return retval;
 }
 
 /*
 
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
+%!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i]);
+%!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double ("1,222.5"), 1222.5)
 %!assert (str2double ("i"), i)
 %!assert (str2double ("2j"), 2i)
 %!assert (str2double ("2 + j"), 2+j)
 %!assert (str2double ("i*2 + 3"), 3+2i)
 %!assert (str2double (".5*i + 3.5"), 3.5+0.5i)
 %!assert (str2double ("1e-3 + i*.25"), 1e-3 + 0.25i)
 %!assert (str2double (["2 + j";"1.25e-3";"-05"]), [2+i; 1.25e-3; -5])
 %!assert (str2double ({"2 + j","1.25e-3","-05"}), [2+i, 1.25e-3, -5])
 %!assert (str2double (1), NaN)
+%!assert (str2double ("1 2 3 4"), NaN)
 %!assert (str2double ("Hello World"), NaN)
 %!assert (str2double ("NaN"), NaN)
 %!assert (str2double ("NA"), NA)
 %!assert (str2double ("Inf"), Inf)
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jaroslav Hajek
+Copyright (C) 2009-2012 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 VZLU Prague
+Copyright (C) 2009-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -403,18 +403,23 @@ decomposition, eliminating the unnecessa
 %!error <Invalid call to svd> [u, v] = svd ([1, 2; 3, 4]);
 
 */
 
 DEFUN_DLD (svd_driver, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{val} =} svd_driver ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
+@deftypefnx {Loadable Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
 Currently recognized values are \"gesvd\" and \"gesdd\".  The default\n\
 is \"gesvd\".\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{svd}\n\
 @end deftypefn")
 {
   static const char *driver_names[] = { "gesvd", "gesdd", 0 };
 
   return SET_INTERNAL_VARIABLE_CHOICES (svd_driver, driver_names);
 }
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 David Bateman
+Copyright (C) 2005-2012 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 Michael Weitzel
+Copyright (C) 2007-2012 Michael Weitzel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 Andreas Stahel
+Copyright (C) 2002-2012 Andreas Stahel
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 David Bateman
+Copyright (C) 2007-2012 David Bateman
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -1,12 +1,12 @@
 // urlwrite and urlread, a curl front-end for octave
 /*
 
-Copyright (C) 2006-2011 Alexander Barth
+Copyright (C) 2006-2012 Alexander Barth
 Copyright (C) 2009 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 #include "glob-match.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "oct-map.h"
+#include "oct-refcount.h"
 #include "unwind-prot.h"
 
 #ifdef HAVE_CURL
 
 #include <curl/curl.h>
 #include <curl/curlver.h>
 #include <curl/easy.h>
 
@@ -136,17 +137,17 @@ private:
         return ascii;
       }
 
     bool is_binary (void) const
       {
         return !ascii;
       }
 
-    size_t count;
+    octave_refcount<size_t> count;
     std::string host;
     bool valid;
     bool ascii;
     mutable CURLcode errnum;
 
   private:
     CURL *curl;
 
@@ -800,43 +801,43 @@ urlwrite (\"http://www.google.com/search
       error ("urlwrite: unable to open file");
       return retval;
     }
 
   unwind_protect_safe frame;
 
   frame.add_fcn (cleanup_urlwrite, filename);
 
-  bool res;
-  curl_handle curl = curl_handle (url, method, param, ofile, res);
+  bool ok;
+  curl_handle curl = curl_handle (url, method, param, ofile, ok);
 
   ofile.close ();
 
   if (!error_state)
     frame.discard ();
   else
     frame.run ();
 
   if (nargout > 0)
     {
-      if (res)
+      if (ok)
         {
           retval(2) = std::string ();
           retval(1) = true;
           retval(0) = octave_env::make_absolute (filename);
         }
       else
         {
           retval(2) = curl.lasterror ();
           retval(1) = false;
           retval(0) = std::string ();
         }
     }
 
-  if (nargout < 2 && res)
+  if (nargout < 2 && ! ok)
     error ("urlwrite: curl: %s", curl.lasterror ().c_str ());
 
 #else
   error ("urlwrite: not available in this version of Octave");
 #endif
 
   return retval;
 }
@@ -934,28 +935,28 @@ s = urlread (\"http://www.google.com/sea
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
-  bool res;
-  curl_handle curl = curl_handle (url, method, param, buf, res);
+  bool ok;
+  curl_handle curl = curl_handle (url, method, param, buf, ok);
 
   if (nargout > 0)
     {
+      // Return empty string if no error occured.
+      retval(2) = ok ? "" : curl.lasterror ();
+      retval(1) = ok;
       retval(0) = buf.str ();
-      retval(1) = res;
-      // Return empty string if no error occured.
-      retval(2) = res ? "" : curl.lasterror ();
     }
 
-  if (nargout < 2 && !res)
+  if (nargout < 2 && ! ok)
     error ("urlread: curl: %s", curl.lasterror().c_str());
 
 #else
   error ("urlread: not available in this version of Octave");
 #endif
 
   return retval;
 }
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's src directory
 #
-# Copyright (C) 1993-2011 John W. Eaton
+# Copyright (C) 1993-2012 John W. Eaton
 #
 # This file is part of Octave.
 #
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 #
@@ -174,16 +174,17 @@ OV_INCLUDES = \
   ov-flt-complex.h \
   ov-flt-cx-diag.h \
   ov-flt-cx-mat.h \
   ov-flt-re-diag.h \
   ov-flt-re-mat.h \
   ov-lazy-idx.h \
   ov-mex-fcn.h \
   ov-null-mat.h \
+  ov-oncleanup.h \
   ov-perm.h \
   ov-range.h \
   ov-re-diag.h \
   ov-re-mat.h \
   ov-scalar.h \
   ov-str-mat.h \
   ov-struct.h \
   ov-type-conv.h \
@@ -225,17 +226,16 @@ PT_INCLUDES = \
   pt-select.h \
   pt-stmt.h \
   pt-unop.h \
   pt-walk.h \
   pt.h
 
 octinclude_HEADERS = \
   Cell.h \
-  base-list.h \
   builtins.h \
   c-file-ptr-stream.h \
   comment-list.h \
   cutils.h \
   data.h \
   debug.h \
   defun-dld.h \
   defun-int.h \
@@ -352,16 +352,17 @@ OV_SRC = \
   ov-flt-complex.cc \
   ov-flt-cx-diag.cc \
   ov-flt-cx-mat.cc \
   ov-flt-re-diag.cc \
   ov-flt-re-mat.cc \
   ov-lazy-idx.cc \
   ov-mex-fcn.cc \
   ov-null-mat.cc \
+  ov-oncleanup.cc \
   ov-perm.cc \
   ov-range.cc \
   ov-re-diag.cc \
   ov-re-mat.cc \
   ov-scalar.cc \
   ov-str-mat.cc \
   ov-struct.cc \
   ov-typeinfo.cc \
@@ -509,17 +510,17 @@ liboctinterp_la_CPPFLAGS = @OCTINTERP_DL
 include link-deps.mk
 
 liboctinterp_la_LIBADD = \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
   $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
-liboctinterp_current = 0
+liboctinterp_current = 1
 liboctinterp_revision = 0
 liboctinterp_age = 0
 
 liboctinterp_version_info = $(liboctinterp_current):$(liboctinterp_revision):$(liboctinterp_age)
 
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
diff --git a/src/OPERATORS/op-b-b.cc b/src/OPERATORS/op-b-b.cc
--- a/src/OPERATORS/op-b-b.cc
+++ b/src/OPERATORS/op-b-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-b-bm.cc b/src/OPERATORS/op-b-bm.cc
--- a/src/OPERATORS/op-b-bm.cc
+++ b/src/OPERATORS/op-b-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-b-sbm.cc b/src/OPERATORS/op-b-sbm.cc
--- a/src/OPERATORS/op-b-sbm.cc
+++ b/src/OPERATORS/op-b-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-bm-b.cc b/src/OPERATORS/op-bm-b.cc
--- a/src/OPERATORS/op-bm-b.cc
+++ b/src/OPERATORS/op-bm-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Cai Jianming
+Copyright (C) 2001-2012 Cai Jianming
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-bm-bm.cc b/src/OPERATORS/op-bm-bm.cc
--- a/src/OPERATORS/op-bm-bm.cc
+++ b/src/OPERATORS/op-bm-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-bm-sbm.cc b/src/OPERATORS/op-bm-sbm.cc
--- a/src/OPERATORS/op-bm-sbm.cc
+++ b/src/OPERATORS/op-bm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cdm-cdm.cc b/src/OPERATORS/op-cdm-cdm.cc
--- a/src/OPERATORS/op-cdm-cdm.cc
+++ b/src/OPERATORS/op-cdm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-cm.cc b/src/OPERATORS/op-cdm-cm.cc
--- a/src/OPERATORS/op-cdm-cm.cc
+++ b/src/OPERATORS/op-cdm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-cs.cc b/src/OPERATORS/op-cdm-cs.cc
--- a/src/OPERATORS/op-cdm-cs.cc
+++ b/src/OPERATORS/op-cdm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-dm.cc b/src/OPERATORS/op-cdm-dm.cc
--- a/src/OPERATORS/op-cdm-dm.cc
+++ b/src/OPERATORS/op-cdm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-m.cc b/src/OPERATORS/op-cdm-m.cc
--- a/src/OPERATORS/op-cdm-m.cc
+++ b/src/OPERATORS/op-cdm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cdm-s.cc b/src/OPERATORS/op-cdm-s.cc
--- a/src/OPERATORS/op-cdm-s.cc
+++ b/src/OPERATORS/op-cdm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cell.cc b/src/OPERATORS/op-cell.cc
--- a/src/OPERATORS/op-cell.cc
+++ b/src/OPERATORS/op-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-class.cc b/src/OPERATORS/op-class.cc
--- a/src/OPERATORS/op-class.cc
+++ b/src/OPERATORS/op-class.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cdm.cc b/src/OPERATORS/op-cm-cdm.cc
--- a/src/OPERATORS/op-cm-cdm.cc
+++ b/src/OPERATORS/op-cm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-cs.cc b/src/OPERATORS/op-cm-cs.cc
--- a/src/OPERATORS/op-cm-cs.cc
+++ b/src/OPERATORS/op-cm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-dm.cc b/src/OPERATORS/op-cm-dm.cc
--- a/src/OPERATORS/op-cm-dm.cc
+++ b/src/OPERATORS/op-cm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-m.cc b/src/OPERATORS/op-cm-m.cc
--- a/src/OPERATORS/op-cm-m.cc
+++ b/src/OPERATORS/op-cm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-pm.cc b/src/OPERATORS/op-cm-pm.cc
--- a/src/OPERATORS/op-cm-pm.cc
+++ b/src/OPERATORS/op-cm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-s.cc b/src/OPERATORS/op-cm-s.cc
--- a/src/OPERATORS/op-cm-s.cc
+++ b/src/OPERATORS/op-cm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cs-cm.cc b/src/OPERATORS/op-cs-cm.cc
--- a/src/OPERATORS/op-cs-cm.cc
+++ b/src/OPERATORS/op-cs-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-cs.cc b/src/OPERATORS/op-cs-cs.cc
--- a/src/OPERATORS/op-cs-cs.cc
+++ b/src/OPERATORS/op-cs-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-m.cc b/src/OPERATORS/op-cs-m.cc
--- a/src/OPERATORS/op-cs-m.cc
+++ b/src/OPERATORS/op-cs-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-s.cc b/src/OPERATORS/op-cs-s.cc
--- a/src/OPERATORS/op-cs-s.cc
+++ b/src/OPERATORS/op-cs-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-dm-cdm.cc b/src/OPERATORS/op-dm-cdm.cc
--- a/src/OPERATORS/op-dm-cdm.cc
+++ b/src/OPERATORS/op-dm-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-cm.cc b/src/OPERATORS/op-dm-cm.cc
--- a/src/OPERATORS/op-dm-cm.cc
+++ b/src/OPERATORS/op-dm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-cs.cc b/src/OPERATORS/op-dm-cs.cc
--- a/src/OPERATORS/op-dm-cs.cc
+++ b/src/OPERATORS/op-dm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-dm.cc b/src/OPERATORS/op-dm-dm.cc
--- a/src/OPERATORS/op-dm-dm.cc
+++ b/src/OPERATORS/op-dm-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-m.cc b/src/OPERATORS/op-dm-m.cc
--- a/src/OPERATORS/op-dm-m.cc
+++ b/src/OPERATORS/op-dm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-s.cc b/src/OPERATORS/op-dm-s.cc
--- a/src/OPERATORS/op-dm-s.cc
+++ b/src/OPERATORS/op-dm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy, Jaroslav Hajek
+Copyright (C) 2009-2012 Jason Riedy, Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dm-template.cc b/src/OPERATORS/op-dm-template.cc
--- a/src/OPERATORS/op-dm-template.cc
+++ b/src/OPERATORS/op-dm-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-dms-template.cc b/src/OPERATORS/op-dms-template.cc
--- a/src/OPERATORS/op-dms-template.cc
+++ b/src/OPERATORS/op-dms-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-double-conv.cc b/src/OPERATORS/op-double-conv.cc
--- a/src/OPERATORS/op-double-conv.cc
+++ b/src/OPERATORS/op-double-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcdm.cc b/src/OPERATORS/op-fcdm-fcdm.cc
--- a/src/OPERATORS/op-fcdm-fcdm.cc
+++ b/src/OPERATORS/op-fcdm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcm.cc b/src/OPERATORS/op-fcdm-fcm.cc
--- a/src/OPERATORS/op-fcdm-fcm.cc
+++ b/src/OPERATORS/op-fcdm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fcs.cc b/src/OPERATORS/op-fcdm-fcs.cc
--- a/src/OPERATORS/op-fcdm-fcs.cc
+++ b/src/OPERATORS/op-fcdm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fdm.cc b/src/OPERATORS/op-fcdm-fdm.cc
--- a/src/OPERATORS/op-fcdm-fdm.cc
+++ b/src/OPERATORS/op-fcdm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fm.cc b/src/OPERATORS/op-fcdm-fm.cc
--- a/src/OPERATORS/op-fcdm-fm.cc
+++ b/src/OPERATORS/op-fcdm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcdm-fs.cc b/src/OPERATORS/op-fcdm-fs.cc
--- a/src/OPERATORS/op-fcdm-fs.cc
+++ b/src/OPERATORS/op-fcdm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcdm.cc b/src/OPERATORS/op-fcm-fcdm.cc
--- a/src/OPERATORS/op-fcm-fcdm.cc
+++ b/src/OPERATORS/op-fcm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fdm.cc b/src/OPERATORS/op-fcm-fdm.cc
--- a/src/OPERATORS/op-fcm-fdm.cc
+++ b/src/OPERATORS/op-fcm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fm.cc b/src/OPERATORS/op-fcm-fm.cc
--- a/src/OPERATORS/op-fcm-fm.cc
+++ b/src/OPERATORS/op-fcm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcm-pm.cc b/src/OPERATORS/op-fcm-pm.cc
--- a/src/OPERATORS/op-fcm-pm.cc
+++ b/src/OPERATORS/op-fcm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcn.cc b/src/OPERATORS/op-fcn.cc
--- a/src/OPERATORS/op-fcn.cc
+++ b/src/OPERATORS/op-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fcm.cc b/src/OPERATORS/op-fcs-fcm.cc
--- a/src/OPERATORS/op-fcs-fcm.cc
+++ b/src/OPERATORS/op-fcs-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fcs.cc b/src/OPERATORS/op-fcs-fcs.cc
--- a/src/OPERATORS/op-fcs-fcs.cc
+++ b/src/OPERATORS/op-fcs-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fm.cc b/src/OPERATORS/op-fcs-fm.cc
--- a/src/OPERATORS/op-fcs-fm.cc
+++ b/src/OPERATORS/op-fcs-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fcs-fs.cc b/src/OPERATORS/op-fcs-fs.cc
--- a/src/OPERATORS/op-fcs-fs.cc
+++ b/src/OPERATORS/op-fcs-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcdm.cc b/src/OPERATORS/op-fdm-fcdm.cc
--- a/src/OPERATORS/op-fdm-fcdm.cc
+++ b/src/OPERATORS/op-fdm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcm.cc b/src/OPERATORS/op-fdm-fcm.cc
--- a/src/OPERATORS/op-fdm-fcm.cc
+++ b/src/OPERATORS/op-fdm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fcs.cc b/src/OPERATORS/op-fdm-fcs.cc
--- a/src/OPERATORS/op-fdm-fcs.cc
+++ b/src/OPERATORS/op-fdm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fdm.cc b/src/OPERATORS/op-fdm-fdm.cc
--- a/src/OPERATORS/op-fdm-fdm.cc
+++ b/src/OPERATORS/op-fdm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fm.cc b/src/OPERATORS/op-fdm-fm.cc
--- a/src/OPERATORS/op-fdm-fm.cc
+++ b/src/OPERATORS/op-fdm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fdm-fs.cc b/src/OPERATORS/op-fdm-fs.cc
--- a/src/OPERATORS/op-fdm-fs.cc
+++ b/src/OPERATORS/op-fdm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-float-conv.cc b/src/OPERATORS/op-float-conv.cc
--- a/src/OPERATORS/op-float-conv.cc
+++ b/src/OPERATORS/op-float-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcdm.cc b/src/OPERATORS/op-fm-fcdm.cc
--- a/src/OPERATORS/op-fm-fcdm.cc
+++ b/src/OPERATORS/op-fm-fcdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcm.cc b/src/OPERATORS/op-fm-fcm.cc
--- a/src/OPERATORS/op-fm-fcm.cc
+++ b/src/OPERATORS/op-fm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fcs.cc b/src/OPERATORS/op-fm-fcs.cc
--- a/src/OPERATORS/op-fm-fcs.cc
+++ b/src/OPERATORS/op-fm-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fdm.cc b/src/OPERATORS/op-fm-fdm.cc
--- a/src/OPERATORS/op-fm-fdm.cc
+++ b/src/OPERATORS/op-fm-fdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fm-pm.cc b/src/OPERATORS/op-fm-pm.cc
--- a/src/OPERATORS/op-fm-pm.cc
+++ b/src/OPERATORS/op-fm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fcm.cc b/src/OPERATORS/op-fs-fcm.cc
--- a/src/OPERATORS/op-fs-fcm.cc
+++ b/src/OPERATORS/op-fs-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fcs.cc b/src/OPERATORS/op-fs-fcs.cc
--- a/src/OPERATORS/op-fs-fcs.cc
+++ b/src/OPERATORS/op-fs-fcs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fm.cc b/src/OPERATORS/op-fs-fm.cc
--- a/src/OPERATORS/op-fs-fm.cc
+++ b/src/OPERATORS/op-fs-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-fs-fs.cc b/src/OPERATORS/op-fs-fs.cc
--- a/src/OPERATORS/op-fs-fs.cc
+++ b/src/OPERATORS/op-fs-fs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i16-i16.cc b/src/OPERATORS/op-i16-i16.cc
--- a/src/OPERATORS/op-i16-i16.cc
+++ b/src/OPERATORS/op-i16-i16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i32-i32.cc b/src/OPERATORS/op-i32-i32.cc
--- a/src/OPERATORS/op-i32-i32.cc
+++ b/src/OPERATORS/op-i32-i32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i64-i64.cc b/src/OPERATORS/op-i64-i64.cc
--- a/src/OPERATORS/op-i64-i64.cc
+++ b/src/OPERATORS/op-i64-i64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-i8-i8.cc b/src/OPERATORS/op-i8-i8.cc
--- a/src/OPERATORS/op-i8-i8.cc
+++ b/src/OPERATORS/op-i8-i8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int-concat.cc b/src/OPERATORS/op-int-concat.cc
--- a/src/OPERATORS/op-int-concat.cc
+++ b/src/OPERATORS/op-int-concat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int-conv.cc b/src/OPERATORS/op-int-conv.cc
--- a/src/OPERATORS/op-int-conv.cc
+++ b/src/OPERATORS/op-int-conv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -699,17 +699,17 @@ octave_value elem_xpow (FloatNDArray a, 
 #define OCTAVE_MM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun (a_dims, b_dims)) \
+        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           { \
             return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
@@ -725,17 +725,17 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun (a_dims, b_dims)) \
+        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           { \
             return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
@@ -751,17 +751,17 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun (a_dims, b_dims)) \
+        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           { \
             return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
@@ -777,17 +777,17 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun (a_dims, b_dims)) \
+        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           { \
             return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
@@ -803,17 +803,17 @@ octave_value elem_xpow (FloatNDArray a, 
 \
   octave_value \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
-        if (is_valid_bsxfun (a_dims, b_dims)) \
+        if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           { \
             return bsxfun_pow (a, b); \
           } \
         else \
           { \
             gripe_nonconformant ("operator .^", a_dims, b_dims);  \
             return octave_value (); \
           } \
diff --git a/src/OPERATORS/op-m-cdm.cc b/src/OPERATORS/op-m-cdm.cc
--- a/src/OPERATORS/op-m-cdm.cc
+++ b/src/OPERATORS/op-m-cdm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-cm.cc b/src/OPERATORS/op-m-cm.cc
--- a/src/OPERATORS/op-m-cm.cc
+++ b/src/OPERATORS/op-m-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-cs.cc b/src/OPERATORS/op-m-cs.cc
--- a/src/OPERATORS/op-m-cs.cc
+++ b/src/OPERATORS/op-m-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-dm.cc b/src/OPERATORS/op-m-dm.cc
--- a/src/OPERATORS/op-m-dm.cc
+++ b/src/OPERATORS/op-m-dm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-pm.cc b/src/OPERATORS/op-m-pm.cc
--- a/src/OPERATORS/op-m-pm.cc
+++ b/src/OPERATORS/op-m-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-s.cc b/src/OPERATORS/op-m-s.cc
--- a/src/OPERATORS/op-m-s.cc
+++ b/src/OPERATORS/op-m-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-pm-cm.cc b/src/OPERATORS/op-pm-cm.cc
--- a/src/OPERATORS/op-pm-cm.cc
+++ b/src/OPERATORS/op-pm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-fcm.cc b/src/OPERATORS/op-pm-fcm.cc
--- a/src/OPERATORS/op-pm-fcm.cc
+++ b/src/OPERATORS/op-pm-fcm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-fm.cc b/src/OPERATORS/op-pm-fm.cc
--- a/src/OPERATORS/op-pm-fm.cc
+++ b/src/OPERATORS/op-pm-fm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-m.cc b/src/OPERATORS/op-pm-m.cc
--- a/src/OPERATORS/op-pm-m.cc
+++ b/src/OPERATORS/op-pm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-pm.cc b/src/OPERATORS/op-pm-pm.cc
--- a/src/OPERATORS/op-pm-pm.cc
+++ b/src/OPERATORS/op-pm-pm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Jason Riedy
+Copyright (C) 2009-2012 Jason Riedy
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-pm-template.cc b/src/OPERATORS/op-pm-template.cc
--- a/src/OPERATORS/op-pm-template.cc
+++ b/src/OPERATORS/op-pm-template.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-cm.cc b/src/OPERATORS/op-s-cm.cc
--- a/src/OPERATORS/op-s-cm.cc
+++ b/src/OPERATORS/op-s-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-cs.cc b/src/OPERATORS/op-s-cs.cc
--- a/src/OPERATORS/op-s-cs.cc
+++ b/src/OPERATORS/op-s-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-m.cc b/src/OPERATORS/op-s-m.cc
--- a/src/OPERATORS/op-s-m.cc
+++ b/src/OPERATORS/op-s-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-s.cc b/src/OPERATORS/op-s-s.cc
--- a/src/OPERATORS/op-s-s.cc
+++ b/src/OPERATORS/op-s-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-b.cc b/src/OPERATORS/op-sbm-b.cc
--- a/src/OPERATORS/op-sbm-b.cc
+++ b/src/OPERATORS/op-sbm-b.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-bm.cc b/src/OPERATORS/op-sbm-bm.cc
--- a/src/OPERATORS/op-sbm-bm.cc
+++ b/src/OPERATORS/op-sbm-bm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/OPERATORS/op-str-m.cc b/src/OPERATORS/op-str-m.cc
--- a/src/OPERATORS/op-str-m.cc
+++ b/src/OPERATORS/op-str-m.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-str-s.cc b/src/OPERATORS/op-str-s.cc
--- a/src/OPERATORS/op-str-s.cc
+++ b/src/OPERATORS/op-str-s.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-struct.cc b/src/OPERATORS/op-struct.cc
--- a/src/OPERATORS/op-struct.cc
+++ b/src/OPERATORS/op-struct.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui16-ui16.cc b/src/OPERATORS/op-ui16-ui16.cc
--- a/src/OPERATORS/op-ui16-ui16.cc
+++ b/src/OPERATORS/op-ui16-ui16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui32-ui32.cc b/src/OPERATORS/op-ui32-ui32.cc
--- a/src/OPERATORS/op-ui32-ui32.cc
+++ b/src/OPERATORS/op-ui32-ui32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui64-ui64.cc b/src/OPERATORS/op-ui64-ui64.cc
--- a/src/OPERATORS/op-ui64-ui64.cc
+++ b/src/OPERATORS/op-ui64-ui64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/OPERATORS/op-ui8-ui8.cc b/src/OPERATORS/op-ui8-ui8.cc
--- a/src/OPERATORS/op-ui8-ui8.cc
+++ b/src/OPERATORS/op-ui8-ui8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-os.cc b/src/TEMPLATE-INST/Array-os.cc
--- a/src/TEMPLATE-INST/Array-os.cc
+++ b/src/TEMPLATE-INST/Array-os.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-sym.cc b/src/TEMPLATE-INST/Array-sym.cc
--- a/src/TEMPLATE-INST/Array-sym.cc
+++ b/src/TEMPLATE-INST/Array-sym.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/TEMPLATE-INST/Array-tc.cc b/src/TEMPLATE-INST/Array-tc.cc
--- a/src/TEMPLATE-INST/Array-tc.cc
+++ b/src/TEMPLATE-INST/Array-tc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-utils.h"
+#include "singleton-cleanup.h"
 
 #include "comment-list.h"
 #include "error.h"
 
 octave_comment_buffer *octave_comment_buffer::instance = 0;
 
 octave_comment_list *
 octave_comment_list::dup (void) const
@@ -47,17 +48,22 @@ octave_comment_list::dup (void) const
 }
 
 bool
 octave_comment_buffer::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_comment_buffer ();
+    {
+      instance = new octave_comment_buffer ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create comment buffer object");
 
       retval = false;
     }
 
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -100,16 +100,18 @@ public:
 class
 octave_comment_buffer
 {
 public:
 
   octave_comment_buffer (void)
     : comment_list (new octave_comment_list ()) { }
 
+  ~octave_comment_buffer (void) { delete comment_list; }
+
   static bool instance_ok (void);
 
   static void append
     (const std::string& s,
      octave_comment_elt::comment_type t = octave_comment_elt::unknown);
 
   static octave_comment_list *get_comment (void);
 
@@ -117,11 +119,13 @@ private:
 
   void do_append (const std::string& s, octave_comment_elt::comment_type t);
 
   octave_comment_list *do_get_comment (void);
 
   octave_comment_list *comment_list;
 
   static octave_comment_buffer *instance;
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
 };
 
 #endif
diff --git a/src/cutils.c b/src/cutils.c
--- a/src/cutils.c
+++ b/src/cutils.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/cutils.h b/src/cutils.h
--- a/src/cutils.h
+++ b/src/cutils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -2155,17 +2155,17 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function ret = testcat (t1, t2, tr, cmplx)
+%!function ret = __testcat (t1, t2, tr, cmplx)
 %! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
 %!
 %! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
@@ -2232,77 +2232,78 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
 %!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
 %!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
 %!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
 %!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
 %!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
 %! endif
 %! ret = true;
-
-%!assert (testcat('double', 'double', 'double'));
-%!assert (testcat('single', 'double', 'single'));
-%!assert (testcat('double', 'single', 'single'));
-%!assert (testcat('single', 'single', 'single'));
-
-%!assert (testcat('double', 'int8', 'int8', false));
-%!assert (testcat('int8', 'double', 'int8', false));
-%!assert (testcat('single', 'int8', 'int8', false));
-%!assert (testcat('int8', 'single', 'int8', false));
-%!assert (testcat('int8', 'int8', 'int8', false));
-%!assert (testcat('double', 'int16', 'int16', false));
-%!assert (testcat('int16', 'double', 'int16', false));
-%!assert (testcat('single', 'int16', 'int16', false));
-%!assert (testcat('int16', 'single', 'int16', false));
-%!assert (testcat('int16', 'int16', 'int16', false));
-%!assert (testcat('double', 'int32', 'int32', false));
-%!assert (testcat('int32', 'double', 'int32', false));
-%!assert (testcat('single', 'int32', 'int32', false));
-%!assert (testcat('int32', 'single', 'int32', false));
-%!assert (testcat('int32', 'int32', 'int32', false));
-%!assert (testcat('double', 'int64', 'int64', false));
-%!assert (testcat('int64', 'double', 'int64', false));
-%!assert (testcat('single', 'int64', 'int64', false));
-%!assert (testcat('int64', 'single', 'int64', false));
-%!assert (testcat('int64', 'int64', 'int64', false));
-
-%!assert (testcat('double', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'double', 'uint8', false));
-%!assert (testcat('single', 'uint8', 'uint8', false));
-%!assert (testcat('uint8', 'single', 'uint8', false));
-%!assert (testcat('uint8', 'uint8', 'uint8', false));
-%!assert (testcat('double', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'double', 'uint16', false));
-%!assert (testcat('single', 'uint16', 'uint16', false));
-%!assert (testcat('uint16', 'single', 'uint16', false));
-%!assert (testcat('uint16', 'uint16', 'uint16', false));
-%!assert (testcat('double', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'double', 'uint32', false));
-%!assert (testcat('single', 'uint32', 'uint32', false));
-%!assert (testcat('uint32', 'single', 'uint32', false));
-%!assert (testcat('uint32', 'uint32', 'uint32', false));
-%!assert (testcat('double', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'double', 'uint64', false));
-%!assert (testcat('single', 'uint64', 'uint64', false));
-%!assert (testcat('uint64', 'single', 'uint64', false));
-%!assert (testcat('uint64', 'uint64', 'uint64', false));
-
-%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (3, [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4]);
-%!assert (cat (3, [], [], []), zeros (0, 0, 3));
-
-%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2));
-%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4]);
-%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4]);
-%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4]);
-
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) );
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) );
+%!endfunction
+
+%!assert (__testcat('double', 'double', 'double'))
+%!assert (__testcat('single', 'double', 'single'))
+%!assert (__testcat('double', 'single', 'single'))
+%!assert (__testcat('single', 'single', 'single'))
+
+%!assert (__testcat('double', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'double', 'int8', false))
+%!assert (__testcat('single', 'int8', 'int8', false))
+%!assert (__testcat('int8', 'single', 'int8', false))
+%!assert (__testcat('int8', 'int8', 'int8', false))
+%!assert (__testcat('double', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'double', 'int16', false))
+%!assert (__testcat('single', 'int16', 'int16', false))
+%!assert (__testcat('int16', 'single', 'int16', false))
+%!assert (__testcat('int16', 'int16', 'int16', false))
+%!assert (__testcat('double', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'double', 'int32', false))
+%!assert (__testcat('single', 'int32', 'int32', false))
+%!assert (__testcat('int32', 'single', 'int32', false))
+%!assert (__testcat('int32', 'int32', 'int32', false))
+%!assert (__testcat('double', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'double', 'int64', false))
+%!assert (__testcat('single', 'int64', 'int64', false))
+%!assert (__testcat('int64', 'single', 'int64', false))
+%!assert (__testcat('int64', 'int64', 'int64', false))
+
+%!assert (__testcat('double', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'double', 'uint8', false))
+%!assert (__testcat('single', 'uint8', 'uint8', false))
+%!assert (__testcat('uint8', 'single', 'uint8', false))
+%!assert (__testcat('uint8', 'uint8', 'uint8', false))
+%!assert (__testcat('double', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'double', 'uint16', false))
+%!assert (__testcat('single', 'uint16', 'uint16', false))
+%!assert (__testcat('uint16', 'single', 'uint16', false))
+%!assert (__testcat('uint16', 'uint16', 'uint16', false))
+%!assert (__testcat('double', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'double', 'uint32', false))
+%!assert (__testcat('single', 'uint32', 'uint32', false))
+%!assert (__testcat('uint32', 'single', 'uint32', false))
+%!assert (__testcat('uint32', 'uint32', 'uint32', false))
+%!assert (__testcat('double', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'double', 'uint64', false))
+%!assert (__testcat('single', 'uint64', 'uint64', false))
+%!assert (__testcat('uint64', 'single', 'uint64', false))
+%!assert (__testcat('uint64', 'uint64', 'uint64', false))
+
+%!assert (cat (3, [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
+%!assert (cat (3, [], [], []), zeros (0, 0, 3))
+
+%!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
+%!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
+%!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
+%!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
+%!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
+
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) )
 
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
@@ -3921,16 +3922,19 @@ val = zeros (m,n, \"uint8\")\n\
 %!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
 %!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
 %!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex inf\n\
+\n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the IEEE representation for positive infinity.\n\
 \n\
@@ -3978,16 +3982,19 @@ DEFALIAS (inf, Inf);
 %!error(inf (2, 3,'int8'));
 %!error(inf (3, 2,'int8'));
 %!error(inf (3, 4, 5, 'int8'));
 
  */
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex nan\n\
+\n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the IEEE symbol NaN (Not a Number).\n\
 NaN is the result of operations which do not produce a well defined numerical\n\
@@ -4293,16 +4300,21 @@ either \"double\" or \"single\".\n\
 @seealso{realmax, intmin}\n\
 @end deftypefn")
 {
   return fill_matrix (args, DBL_MIN, FLT_MIN, "realmin");
 }
 
 DEFUN (I, args, ,
   "-*- texinfo -*-\n\
+@c List other forms of function in documentation index\n\
+@findex i\n\
+@findex j\n\
+@findex J\n\
+\n\
 @deftypefn  {Built-in Function} {} I\n\
 @deftypefnx {Built-in Function} {} I (@var{n})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} I (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the pure imaginary unit, defined as\n\
 @tex\n\
@@ -5588,19 +5600,23 @@ This function and @w{@xcode{x ./ y}} are
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
-@var{y} power.\n\
+@var{y} power.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+\n\
 This function and @w{@xcode{x .^ y}} are equivalent.\n\
-@seealso{mpower}\n\
+@seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
@@ -5969,16 +5985,18 @@ ordered lists.\n\
         {
           error ("sort: DIM must be a valid dimension");
           return retval;
         }
     }
 
   if (return_idx)
     {
+      retval.resize (2);
+
       Array<octave_idx_type> sidx;
 
       retval (0) = arg.sort (sidx, dim, smode);
       retval (1) = idx_vector (sidx, dv(dim)); // No checking, the extent is known.
     }
   else
     retval(0) = arg.sort (dim, smode);
 
@@ -6623,29 +6641,34 @@ template <class NDT>
 static NDT
 do_accumdim_sum (const idx_vector& idx, const NDT& vals,
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
-    error ("accumarray: index out of range");
-
-  dim_vector rdv = vals.dims ();
+    error ("accumdim: index out of range");
+
+  dim_vector vals_dim = vals.dims (), rdv = vals_dim;
+
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
   NDT retval (rdv, T());
 
+  if (idx.length () != vals_dim(dim))
+    error ("accumdim: dimension mismatch");
+
   retval.idx_add_nd (idx, vals, dim);
+
   return retval;
 }
 
 DEFUN (__accumdim_sum__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/src/data.h b/src/data.h
--- a/src/data.h
+++ b/src/data.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 John W. Eaton
+Copyright (C) 2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 Copyright (C) 2007-2009 John Swensen
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <deque>
 #include <fstream>
 #include <iomanip>
 #include <iostream>
 #include <set>
 #include <string>
 
 #include "file-stat.h"
+#include "singleton-cleanup.h"
 
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "utils.h"
@@ -245,16 +246,38 @@ parse_dbfunction_params (const char *who
             }
 
           if (error_state)
             break;
         }
     }
 }
 
+bool
+bp_table::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new bp_table ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create breakpoint table!");
+      retval = false;
+    }
+
+  return retval;
+}
+
 bp_table::intmap
 bp_table::do_add_breakpoint (const std::string& fname,
                              const bp_table::intmap& line)
 {
   intmap retval;
 
   octave_idx_type len = line.size ();
 
@@ -280,17 +303,17 @@ bp_table::do_add_breakpoint (const std::
                     {
                       bp_set.insert (fname);
                     }
                 }
             }
         }
     }
   else
-    error ("add_breakpoint: unable to find the function requested\n");
+    error ("add_breakpoint: unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 int
@@ -335,17 +358,17 @@ bp_table::do_remove_breakpoint (const st
                     bp_set.erase (it);
 
                 }
 
               retval = results.length ();
             }
         }
       else
-        error ("remove_breakpoint: unable to find the function requested\n");
+        error ("remove_breakpoint: unable to find the requested function\n");
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
@@ -375,17 +398,17 @@ bp_table::do_remove_all_breakpoints_in_f
           bp_set_iterator it = bp_set.find (fname);
           if (it != bp_set.end ())
             bp_set.erase (it);
 
         }
     }
   else if (! silent)
     error ("remove_all_breakpoint_in_file: "
-           "unable to find the function requested\n");
+           "unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 void
 bp_table::do_remove_all_breakpoints (void)
@@ -476,30 +499,41 @@ intmap_to_ov (const bp_table::intmap& li
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{rline} =} dbstop (@var{func}, @var{line}, @dots{})\n\
-Set a breakpoint in a function\n\
-@table @code\n\
+@deftypefn  {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line}, @dots{})\n\
+Set a breakpoint in function @var{func}.\n\
+\n\
+Arguments are\n\
+\n\
+@table @var\n\
 @item func\n\
-String representing the function name.  When already in debug\n\
+Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 \n\
 @item line\n\
-Line number you would like the breakpoint to be set on.  Multiple\n\
-lines might be given as separate arguments or as a vector.\n\
+Line number where the breakpoint should be set.  Multiple\n\
+lines may be given as separate arguments or as a vector.\n\
 @end table\n\
 \n\
-The rline returned is the real line that the breakpoint was set at.\n\
-@seealso{dbclear, dbstatus, dbstep}\n\
+When called with a single argument @var{func}, the breakpoint\n\
+is set at the first executable line in the named function.\n\
+\n\
+The optional output @var{rline} is the real line number where the\n\
+breakpoint was set.  This can differ from specified line if\n\
+the line is not executable.  For example, if a breakpoint attempted on a\n\
+blank line then Octave will set the real breakpoint at the\n\
+next executable line.\n\
+@seealso{dbclear, dbstatus, dbstep, debug_on_error, debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   bp_table::intmap retval;
   std::string symbol_name;
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbstop", args, symbol_name, lines);
 
@@ -509,29 +543,36 @@ The rline returned is the real line that
   if (! error_state)
     retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dbclear (@var{func}, @var{line}, @dots{})\n\
-Delete a breakpoint in a function\n\
-@table @code\n\
+@deftypefn  {Loadable Function} {} dbclear (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {} dbclear (\"@var{func}\", @var{line}, @dots{})\n\
+Delete a breakpoint in the function @var{func}.\n\
+\n\
+Arguments are\n\
+\n\
+@table @var\n\
 @item func\n\
-String representing the function name.  When already in debug\n\
+Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 \n\
 @item line\n\
-Line number where you would like to remove the breakpoint.  Multiple\n\
-lines might be given as separate arguments or as a vector.\n\
+Line number from which to remove a breakpoint.  Multiple\n\
+lines may be given as separate arguments or as a vector.\n\
 @end table\n\
-No checking is done to make sure that the line you requested is really\n\
-a breakpoint.  If you get the wrong line nothing will happen.\n\
+\n\
+When called without a line number specification all breakpoints\n\
+in the named function are cleared.\n\
+\n\
+If the requested line is not a breakpoint no action is performed.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
@@ -539,36 +580,53 @@ a breakpoint.  If you get the wrong line
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {lst =} dbstatus (@var{func})\n\
-Return a vector containing the lines on which a function has\n\
-breakpoints set.\n\
-@table @code\n\
-@item func\n\
-String representing the function name.  When already in debug\n\
-mode this should be left out.\n\
+@deftypefn  {Loadable Function} {} dbstatus ()\n\
+@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus ()\n\
+@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
+Report the location of active breakpoints.\n\
+\n\
+When called with no input or output arguments, print the list of\n\
+all functions with breakpoints and the line numbers where those\n\
+breakpoints are set.\n\
+If a function name @var{func} is specified then only report breakpoints\n\
+for the named function.\n\
+\n\
+The optional return argument @var{brk_list} is a struct array with the\n\
+following fields.\n\
+\n\
+@table @asis\n\
+@item name\n\
+The name of the function with a breakpoint.\n\
+\n\
+@item file\n\
+The name of the m-file where the function code is located.\n\
+\n\
+@item line\n\
+A line number, or vector of line numbers, with a breakpoint.\n\
 @end table\n\
+\n\
 @seealso{dbclear, dbwhere}\n\
 @end deftypefn")
 {
   octave_map retval;
   int nargin = args.length ();
   octave_value_list fcn_list;
   bp_table::fname_line_map bp_list;
   std::string symbol_name;
 
   if (nargin != 0 && nargin != 1)
     {
-      error ("dbstatus: only zero or one arguements accepted\n");
+      error ("dbstatus: only zero or one arguments accepted\n");
       return octave_value ();
     }
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           symbol_name = args(0).string_value ();
@@ -592,22 +650,26 @@ mode this should be left out.\n\
 
   if (nargout == 0)
     {
       // Print out the breakpoint information.
 
       for (bp_table::fname_line_map_iterator it = bp_list.begin ();
            it != bp_list.end (); it++)
         {
-          octave_stdout << "breakpoint in " << it->first << " at line(s) ";
-
           bp_table::intmap m = it->second;
 
           size_t nel = m.size ();
 
+          octave_stdout << "breakpoint in " << it->first;
+          if (nel > 1)
+            octave_stdout << " at lines ";
+          else
+            octave_stdout << " at line ";
+
           for (size_t j = 0; j < nel; j++)
             octave_stdout << m[j] << ((j < nel - 1) ? ", " : ".");
 
           if (nel > 0)
             octave_stdout << std::endl;
         }
       return octave_value ();
     }
@@ -635,18 +697,19 @@ mode this should be left out.\n\
 
       return octave_value (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbwhere ()\n\
-Show where we are in the code\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+In debugging mode, report the current file and line number where\n\
+execution is stopped.\n\
+@seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_user_code *dbg_fcn = get_user_code ();
 
   if (dbg_fcn)
     {
@@ -676,17 +739,17 @@ Show where we are in the code\n\
               if (! line.empty ())
                 octave_stdout << l << ": " << line << std::endl;
             }
         }
       else
         octave_stdout << " <unknown line>" << std::endl;
     }
   else
-    error ("dbwhere: must be inside of a user function to use dbwhere\n");
+    error ("dbwhere: must be inside a user function to use dbwhere\n");
 
   return retval;
 }
 
 // Copied and modified from the do_type command in help.cc
 // Maybe we could share some code?
 void
 do_dbtype (std::ostream& os, const std::string& name, int start, int end)
@@ -726,19 +789,31 @@ do_dbtype (std::ostream& os, const std::
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dbtype ()\n\
-List script file with line numbers.\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+@deftypefn  {Loadable Function} {} dbtype ()\n\
+@deftypefnx {Loadable Function} {} dbtype (\"startl:endl\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"startl:end\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl:endl\")\n\
+@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl:end\")\n\
+When in debugging mode and called with no arguments, list the script file\n\
+being debugged with line numbers.  An optional range specification,\n\
+specified as a string, can be used to list only a portion of the file.\n\
+The special keyword \"end\" is a valid line number specification.\n\
+\n\
+When called with the name of a function, list that script file\n\
+with line numbers.\n\
+@seealso{dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
@@ -747,89 +822,99 @@ List script file with line numbers.\n\
       switch (nargin)
         {
         case 0: // dbtype
           dbg_fcn = get_user_code ();
 
           if (dbg_fcn)
             do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
           else
-            error ("dbtype: must be in a user function to give no arguments to dbtype\n");
+            error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
           break;
 
         case 1: // (dbtype func) || (dbtype start:end)
-          dbg_fcn = get_user_code (argv[1]);
+          {
+            std::string arg = argv[1];
+
+            size_t ind = arg.find (':');
 
-          if (dbg_fcn)
-            do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
-          else
-            {
-              dbg_fcn = get_user_code ();
+            if (ind != std::string::npos)  // (dbtype start:end)
+              {  
+                dbg_fcn = get_user_code ();
 
-              if (dbg_fcn)
-                {
-                  std::string arg = argv[1];
-
-                  size_t ind = arg.find (':');
+                if (dbg_fcn)
+                  {
+                    std::string start_str = arg.substr (0, ind);
+                    std::string end_str = arg.substr (ind + 1);
 
-                  if (ind != std::string::npos)
-                    {
-                      std::string start_str = arg.substr (0, ind);
-                      std::string end_str = arg.substr (ind + 1);
+                    int start, end;
+                    start = atoi (start_str.c_str ());
+                    if (end_str == "end")
+                      end = INT_MAX;
+                    else
+                      end = atoi (end_str.c_str ());
 
-                      int start = atoi (start_str.c_str ());
-                      int end = atoi (end_str.c_str ());
+                    if (std::min (start, end) <= 0)
+                      error ("dbtype: start and end lines must be >= 1\n");
 
-                      if (std::min (start, end) <= 0)
-                        error ("dbtype: start and end lines must be >= 1\n");
+                    if (start <= end)
+                      do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
+                    else
+                      error ("dbtype: start line must be less than end line\n");
+                  }
+              }
+            else  // (dbtype func)
+              {
+                dbg_fcn = get_user_code (arg);
 
-                      if (start <= end)
-                        do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
-                      else
-                        error ("dbtype: start line must be less than end line\n");
-                    }
-                  else
-                    error ("dbtype: line specification must be `start:end'");
-                }
-            }
+                if (dbg_fcn)
+                  do_dbtype (octave_stdout, dbg_fcn->name (), 0, INT_MAX);
+                else
+                  error ("dbtype: function <%s> not found\n", arg.c_str ());
+              }
+          }
           break;
 
         case 2: // (dbtype func start:end) , (dbtype func start)
           dbg_fcn = get_user_code (argv[1]);
 
           if (dbg_fcn)
             {
               std::string arg = argv[2];
-              int start = 0;
-              int end = 0;
+              int start, end;
               size_t ind = arg.find (':');
 
               if (ind != std::string::npos)
                 {
                   std::string start_str = arg.substr (0, ind);
                   std::string end_str = arg.substr (ind + 1);
 
                   start = atoi (start_str.c_str ());
-                  end = atoi (end_str.c_str ());
-
+                  if (end_str == "end")
+                    end = INT_MAX;
+                  else
+                    end = atoi (end_str.c_str ());
                 }
               else
                 {
                   start = atoi (arg.c_str ());
                   end = start;
                 }
 
               if (std::min (start, end) <= 0)
                 error ("dbtype: start and end lines must be >= 1\n");
 
               if (start <= end)
                 do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
               else
                 error ("dbtype: start line must be less than end line\n");
             }
+          else
+            error ("dbtype: function <%s> not found\n", argv[1].c_str ());
+
           break;
 
         default:
           error ("dbtype: expecting zero, one, or two arguments\n");
         }
     }
 
   return retval;
@@ -859,17 +944,17 @@ do_dbstack (const octave_value_list& arg
           n = atoi (s_arg.c_str ());
         }
       else
         n = args(0).int_value ();
 
       if (n > 0)
         nskip = n;
       else
-        error ("dbstack: expecting N to be a nonnegative integer");
+        error ("dbstack: N must be a non-negative integer");
     }
 
   if (! error_state)
     {
       octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
 
       if (nargout == 0)
         {
@@ -932,20 +1017,48 @@ do_dbstack (const octave_value_list& arg
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
-Print or return current stack information.  With optional argument\n\
-@var{n}, omit the @var{n} innermost stack frames.\n\
-@seealso{dbclear, dbstatus, dbstop}\n\
+@deftypefn  {Loadable Function} {} dbstack ()\n\
+@deftypefnx {Loadable Function} {} dbstack (@var{n})\n\
+@deftypefnx {Loadable Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
+Display or return current debugging function stack information.\n\
+With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
+\n\
+The optional return argument @var{stack} is a struct array with the\n\
+following fields:\n\
+\n\
+@table @asis\n\
+@item file\n\
+The name of the m-file where the function code is located.\n\
+\n\
+@item name\n\
+The name of the function with a breakpoint.\n\
+\n\
+@item line\n\
+The line number of an active breakpoint.\n\
+\n\
+@item column\n\
+The column number of the line where the breakpoint begins.\n\
+\n\
+@item scope\n\
+Undocumented.\n\
+\n\
+@item context\n\
+Undocumented.\n\
+@end table\n\
+\n\
+The return argument @var{idx} specifies which element of the @var{stack}\n\
+struct array is currently active.\n\
+@seealso{dbup, dbdown, dbwhere, dbstatus}\n\
 @end deftypefn")
 {
   return do_dbstack (args, nargout, octave_stdout);
 }
 
 static void
 do_dbupdown (const octave_value_list& args, const std::string& who)
 {
@@ -976,56 +1089,59 @@ do_dbupdown (const octave_value_list& ar
 }
 
 DEFUN (dbup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} dbup\n\
 @deftypefnx {Loadable Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move up one frame.\n\
-@seealso{dbstack}\n\
+@seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
 DEFUN (dbdown, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} dbdown\n\
 @deftypefnx {Loadable Function} {} dbdown (@var{n})\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move down one frame.\n\
-@seealso{dbstack}\n\
+@seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
 
   return retval;
 }
 
 DEFUN (dbstep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbstep\n\
 @deftypefnx {Command} {} dbstep @var{n}\n\
 @deftypefnx {Command} {} dbstep in\n\
 @deftypefnx {Command} {} dbstep out\n\
+@deftypefnx {Command} {} dbnext @dots{}\n\
 In debugging mode, execute the next @var{n} lines of code.\n\
-If @var{n} is omitted , execute the next single line of code.\n\
-If the next line of code is itself\n\
-defined in terms of an m-file remain in the existing function.\n\
+If @var{n} is omitted, execute the next single line of code.\n\
+If the next line of code is itself defined in terms of an m-file remain in\n\
+the existing function.\n\
 \n\
 Using @code{dbstep in} will cause execution of the next line to step into\n\
 any m-files defined on the next line.  Using @code{dbstep out} will cause\n\
 execution to continue until the current function returns.\n\
+\n\
+@code{dbnext} is an alias for @code{dbstep}.\n\
 @seealso{dbcont, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       int nargin = args.length ();
 
       if (nargin > 1)
@@ -1061,17 +1177,17 @@ execution to continue until the current 
                           tree_evaluator::dbstep_flag = n;
                         }
                       else
                         error ("dbstep: invalid argument");
                     }
                 }
             }
           else
-            error ("dbstep: expecting character string as argument");
+            error ("dbstep: input argument must be a character string");
         }
       else
         {
           Vdebugging = false;
 
           tree_evaluator::dbstep_flag = 1;
         }
     }
@@ -1081,17 +1197,17 @@ execution to continue until the current 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
 DEFUN (dbcont, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont\n\
-In debugging mode, quit debugging mode and continue execution.\n\
+Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
         {
           Vdebugging = false;
@@ -1105,18 +1221,19 @@ In debugging mode, quit debugging mode a
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbquit\n\
-In debugging mode, quit debugging mode and return to the top level.\n\
-@seealso{dbstep, dbcont}\n\
+Quit debugging mode immediately without further code execution and\n\
+return to the Octave prompt.\n\
+@seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
         {
           Vdebugging = false;
 
@@ -1131,18 +1248,18 @@ In debugging mode, quit debugging mode a
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} isdebugmode ()\n\
-Return true if debug mode is on, otherwise false.\n\
-@seealso{dbstack, dbclear, dbstop, dbstatus}\n\
+Return true if in debugging mode, otherwise false.\n\
+@seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Vdebugging;
   else
     print_usage ();
diff --git a/src/debug.h b/src/debug.h
--- a/src/debug.h
+++ b/src/debug.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -50,31 +50,17 @@ public:
   typedef intmap::const_iterator const_intmap_iterator;
   typedef intmap::iterator intmap_iterator;
 
   typedef std::map <std::string, intmap> fname_line_map;
 
   typedef fname_line_map::const_iterator const_fname_line_map_iterator;
   typedef fname_line_map::iterator fname_line_map_iterator;
 
-  static bool instance_ok (void)
-  {
-    bool retval = true;
-
-    if (! instance)
-      instance = new bp_table ();
-
-    if (! instance)
-      {
-        ::error ("unable to create breakpoint table!");
-        retval = false;
-      }
-
-    return retval;
-  }
+  static bool instance_ok (void);
 
   // Add a breakpoint at the nearest executable line.
   static intmap add_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_add_breakpoint (fname, lines) : intmap ();
   }
@@ -122,16 +108,18 @@ private:
   typedef std::set<std::string>::const_iterator const_bp_set_iterator;
   typedef std::set<std::string>::iterator bp_set_iterator;
 
   // Set of function names containing at least one breakpoint.
   std::set<std::string> bp_set;
 
   static bp_table *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines);
 
   int do_remove_breakpoint (const std::string&, const intmap& lines);
 
   intmap do_remove_all_breakpoints_in_file (const std::string& fname,
                                             bool silent);
 
   void do_remove_all_breakpoints (void);
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -403,21 +403,26 @@ install_defaults (void)
 
   set_site_defaults_file ();
 }
 
 DEFUN (EDITOR, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} EDITOR (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the editor to\n\
 use with the @code{edit_history} command.  The default value is taken from\n\
 the environment variable @w{@env{EDITOR}} when Octave starts.  If the\n\
 environment variable is not initialized, @w{@env{EDITOR}} will be set to\n\
 @code{\"emacs\"}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
 /*
 %!error (EDITOR (1, 2));
@@ -429,21 +434,26 @@ environment variable is not initialized,
 %! EDITOR (orig_val);
 %! assert (EDITOR (), orig_val);
 */
 
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to append to the shell PATH when executing external\n\
 programs.  The initial value of is taken from the environment variable\n\
 @w{@env{OCTAVE_EXEC_PATH}}, but that value can be overridden by\n\
 the command line argument @option{--exec-path PATH}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
   if (args.length () > 0)
     set_exec_path (VEXEC_PATH);
 
   return retval;
@@ -459,18 +469,23 @@ the command line argument @option{--exec
 %! EXEC_PATH (orig_val);
 %! assert (EXEC_PATH (), orig_val);
 */
 
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
 /*
 %!error (IMAGE_PATH (1, 2));
 %!test
diff --git a/src/defaults.h.in b/src/defaults.h.in
--- a/src/defaults.h.in
+++ b/src/defaults.h.in
@@ -1,12 +1,12 @@
 // defaults.h.in
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -182,18 +182,18 @@ system-dependent error message.\n\
         gripe_wrong_type_arg ("readdir", args(0));
       else
         {
           dir_entry dir (dirname);
 
           if (dir)
             {
               string_vector dirlist = dir.read ();
+              retval(1) = 0.0;
               retval(0) = Cell (dirlist.sort ());
-              retval(1) = 0.0;
             }
           else
             {
               retval(2) = dir.error ();
             }
         }
     }
   else
@@ -482,22 +482,20 @@ system-dependent error message.\n\
         gripe_wrong_type_arg ("readlink", args(0));
       else
         {
           std::string result;
           std::string msg;
 
           int status = octave_readlink (symlink, result, msg);
 
-          retval(0) = result;
-
-          retval(1) = status;
-
           if (status < 0)
             retval(2) = msg;
+          retval(1) = status;
+          retval(0) = result;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -767,14 +765,19 @@ Query or set the character used to separ
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} confirm_recursive_rmdir (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will ask for confirmation before recursively removing a directory tree.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (confirm_recursive_rmdir);
 }
diff --git a/src/dirfns.h b/src/dirfns.h
--- a/src/dirfns.h
+++ b/src/dirfns.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -22,23 +22,25 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdlib>
 
 #if defined (OCTAVE_USE_WINDOWS_API)
-#include <Windows.h>
+#include <windows.h>
 #elif defined (HAVE_FRAMEWORK_CARBON)
 #include <Carbon/Carbon.h>
 #elif defined (HAVE_X_WINDOWS)
 #include <X11/Xlib.h>
 #endif
 
+#include "singleton-cleanup.h"
+
 #include "display.h"
 #include "error.h"
 
 display_info *display_info::instance = 0;
 
 void
 display_info::init (bool query)
 {
@@ -113,16 +115,18 @@ display_info::init (bool query)
                   double ht_mm = DisplayHeightMM (display, screen_number);
                   double wd_mm = DisplayWidthMM (display, screen_number);
 
                   rx = wd * 25.4 / wd_mm;
                   ry = ht * 25.4 / ht_mm;
                 }
               else
                 warning ("X11 display has no default screen");
+
+              XCloseDisplay (display);
             }
           else
             warning ("unable to open X11 DISPLAY");
         }
       else
         warning ("X11 DISPLAY environment variable not set");
 #else
 
@@ -133,17 +137,22 @@ display_info::init (bool query)
 }
 
 bool
 display_info::instance_ok (bool query)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new display_info (query);
+    {
+      instance = new display_info (query);
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create display_info object!");
 
       retval = false;
     }
 
diff --git a/src/display.h b/src/display.h
--- a/src/display.h
+++ b/src/display.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -68,16 +68,18 @@ public:
   {
     instance_ok (false);
   }
 
 private:
 
   static display_info *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // Height, width, and depth of the display.
   int ht;
   int wd;
   int dp;
 
   // X- and Y- Resolution of the display in dots (pixels) per inch.
   double rx;
   double ry;
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -22,19 +22,20 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <list>
 
+#include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
-#include "file-stat.h"
+#include "singleton-cleanup.h"
 
 #include <defaults.h>
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "ov-fcn.h"
 #include "ov-dld-fcn.h"
 #include "ov-mex-fcn.h"
@@ -73,16 +74,18 @@ private:
   void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
 
   octave_shlib do_find_file (const std::string& file_name) const;
 
   void do_display (void) const;
 
   static octave_shlib_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   std::list<octave_shlib> lib_list;
 
   // No copying!
 
   octave_shlib_list (const octave_shlib_list&);
@@ -143,17 +146,22 @@ octave_shlib_list::do_display (void) con
 }
 
 bool
 octave_shlib_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_shlib_list ();
+    {
+      instance = new octave_shlib_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create shared library list object!");
 
       retval = false;
     }
 
@@ -208,16 +216,18 @@ private:
   ~octave_mex_file_list (void) { }
 
   void do_append (const octave_shlib& shl);
 
   void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
 
   static octave_mex_file_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   std::list<octave_shlib> file_list;
 
   // No copying!
 
   octave_mex_file_list (const octave_mex_file_list&);
@@ -253,17 +263,22 @@ octave_mex_file_list::do_remove (octave_
 }
 
 bool
 octave_mex_file_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_mex_file_list ();
+    {
+      instance = new octave_mex_file_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create shared library list object!");
 
       retval = false;
     }
 
@@ -290,17 +305,22 @@ octave_dynamic_loader *octave_dynamic_lo
 bool octave_dynamic_loader::doing_load = false;
 
 bool
 octave_dynamic_loader::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_dynamic_loader ();
+    {
+      instance = new octave_dynamic_loader ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create dynamic loader object!");
 
       retval = false;
     }
 
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -59,16 +59,18 @@ private:
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
                 const std::string& file_name = std::string (),
                 bool relative = false);
 
   octave_function *
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -114,19 +114,16 @@ int warning_state = 0;
 int buffer_error_messages = 0;
 
 // TRUE means error messages are turned off.
 bool discard_error_messages = false;
 
 // TRUE means warning messages are turned off.
 bool discard_warning_messages = false;
 
-// The message buffer.
-static std::ostringstream *error_message_buffer = 0;
-
 void
 reset_error_handler (void)
 {
   error_state = 0;
   warning_state = 0;
   buffer_error_messages = 0;
   discard_error_messages = false;
 }
@@ -258,26 +255,17 @@ verror (bool save_last_error, std::ostre
           octave_idx_type curr_frame = -1;
 
           Vlast_error_stack = octave_call_stack::backtrace (0, curr_frame);
         }
       else
         Vlast_error_stack = initialize_last_error_stack ();
     }
 
-  if (buffer_error_messages)
-    {
-      if (error_message_buffer)
-        msg_string = "error: " + msg_string;
-      else
-        error_message_buffer = new std::ostringstream ();
-
-      *error_message_buffer << msg_string;
-    }
-  else
+  if (! buffer_error_messages)
     {
       octave_diary << msg_string;
       os << msg_string;
     }
 }
 
 // Note that we don't actually print any message if the error string
 // is just "" or "\n".  This allows error ("") and error ("\n") to
@@ -559,17 +547,18 @@ check_state (const std::string& state)
     return 1;
   else if (state == "error")
     return 2;
   else
     return -1;
 }
 
 // For given warning ID, return 0 if warnings are disabled, 1 if
-// enabled, and 2 if this ID should be an error instead of a warning.
+// enabled, and 2 if the given ID should be an error instead of a
+// warning.
 
 int
 warning_enabled (const std::string& id)
 {
   int retval = 0;
 
   int all_state = -1;
   int id_state = -1;
@@ -605,18 +594,19 @@ warning_enabled (const std::string& id)
                 id_found = true;
             }
 
           if (all_found && id_found)
             break;
         }
     }
 
+  // If "all" is not present, assume warnings are enabled.
   if (all_state == -1)
-    panic_impossible ();
+    all_state = 1;
 
   if (all_state == 0)
     {
       if (id_state >= 0)
         retval = id_state;
     }
   else if (all_state == 1)
     {
@@ -1100,37 +1090,46 @@ error: nargin != 1\n\
 
   return retval;
 }
 
 DEFUN (warning, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
+@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
+@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
 to go on.\n\
 \n\
 The optional message identifier allows users to enable or disable\n\
 warnings tagged by @var{id}.  The special identifier @samp{\"all\"} may\n\
 be used to set the state of all warnings.\n\
 \n\
-@deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
-@deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
-Set or query the state of a particular warning using the identifier\n\
-@var{id}.  If the identifier is omitted, a value of @samp{\"all\"} is\n\
-assumed.  If you set the state of a warning to @samp{\"error\"}, the\n\
-warning named by @var{id} is handled as if it were an error instead.\n\
+If the first argument is @samp{\"on\"} or @samp{\"off\"}, set the state\n\
+of a particular warning using the identifier @var{id}.  If the first\n\
+argument is @samp{\"query\"}, query the state of this warning instead.\n\
+If the identifier is omitted, a value of @samp{\"all\"} is assumed.  If\n\
+you set the state of a warning to @samp{\"error\"}, the warning named by\n\
+@var{id} is handled as if it were an error instead.  So, for example, the\n\
+following handles all warnings as errors:\n\
+\n\
+@example\n\
+@group\n\
+warning (\"error\");\n\
+@end group\n\
+@end example\n\
 @seealso{warning_ids}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
   int argc = nargin + 1;
 
@@ -1484,18 +1483,18 @@ initialize_default_warning_state (void)
 
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
-Query or set the last error message structure.  When called without arguments\n\
-, return a structure containing the last error message and other\n\
+Query or set the last error message structure.  When called without\n\
+arguments, return a structure containing the last error message and other\n\
 information related to this error.  The elements of the structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
 \n\
 @item 'identifier'\n\
 The message identifier of this error message\n\
@@ -1582,17 +1581,17 @@ set to their default values.\n\
                   const std::string tmp =
                     new_err.getfield("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
               if (! error_state && new_err.contains ("stack"))
                 {
                   octave_scalar_map new_err_stack =
-                    new_err.getfield("identifier").scalar_map_value ();
+                    new_err.getfield("stack").scalar_map_value ();
 
                   if (! error_state && new_err_stack.contains ("file"))
                     {
                       const std::string tmp =
                         new_err_stack.getfield("file").string_value ();
                       new_error_file = tmp;
                     }
 
@@ -1769,42 +1768,57 @@ to check for the proper number of argume
   handle_message (usage_with_id, "", "unknown", args);
   return retval;
 }
 
 DEFUN (beep_on_error, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} beep_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} beep_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to ring the terminal bell before printing an error message.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
 DEFUN (debug_on_error, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} debug_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} debug_on_warning (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_warning);
 }
 
 std::string
 last_error_message (void)
 {
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -38,19 +38,22 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <cerrno>
 #include <climits>
 #include <cstdio>
 
 #include <iostream>
+#include <locale>
 #include <stack>
+#include <stdexcept>
 #include <vector>
 
+#include <fcntl.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #ifdef HAVE_ZLIB_H
 #include <zlib.h>
 #endif
 
 #include "error.h"
@@ -1064,17 +1067,17 @@ converted.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
++@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{locale})\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
 @item Inf\n\
@@ -1103,17 +1106,20 @@ conversions.\n\
 The number of items successfully read is returned in @var{count}.\n\
 \n\
 If an error occurs, @var{errmsg} contains a system-dependent error message.\n\
 \n\
 In the second form, read from @var{fid} according to @var{template},\n\
 with each conversion specifier in @var{template} corresponding to a\n\
 single scalar return value.  This form is more `C-like', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
-conversions is returned in @var{count}\n\
+conversions is returned in @var{count}. It permits to explicitly\n\
+specify a locale to take into account langage specific features, \n\
+such as decimal separator. This operation restores the previous locales\n\
+setting at the end of the conversion.\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
 @seealso{scanf, sscanf, fread, fprintf, fgets, fputs}\n\
 @end deftypefn")
 {
@@ -1125,17 +1131,35 @@ complete description of the syntax of th
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
         {
           if (args(1).is_string ())
-            retval = os.oscanf (args(1), who);
+            {
+              std::locale oldloc;
+              try
+                {
+                  // Use args(2) val as the new locale setting. Keep
+                  // old val for restoring afterwards.
+                  oldloc = 
+                    os.imbue (std::locale (args(2).string_value ().c_str ()));
+                  
+                }
+              catch (std::runtime_error)
+                {
+                  // Display a warning if the specified locale is unknown
+                  warning ("fscanf: invalid locale. Try `locale -a' for a list of supported values.");
+                  oldloc = std::locale::classic ();
+                }
+              retval = os.oscanf (args(1), who);
+              os.imbue (oldloc);
+            }
           else
             ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     {
       retval(2) = "unknown error";
       retval(1) = 0.0;
@@ -1193,17 +1217,17 @@ get_sscanf_data (const octave_value& val
     ::error ("sscanf: argument STRING must be a string");
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{locale})\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.  In addition to the values\n\
 returned by @code{fscanf}, the index of the next character to be read\n\
 is returned in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
 {
@@ -1218,18 +1242,32 @@ is returned in @var{pos}.\n\
       std::string data = get_sscanf_data (args(0));
 
       if (! error_state)
         {
           octave_stream os = octave_istrstream::create (data);
 
           if (os.is_valid ())
             {
-              if (args(1).is_string ())
-                retval = os.oscanf (args(1), who);
+              if (args(1).is_string ()) 
+                {
+                  // Use args(2) val as the new locale setting. As the os
+                  // object is short lived, we don't need to restore
+                  // locale afterwards.
+                  try
+                    {  
+                      os.imbue (std::locale (args(2).string_value ().c_str ()));
+                    }
+                  catch (std::runtime_error)
+                    {
+                      // Display a warning if the specified locale is unknown
+                      warning ("sscanf: invalid locale. Try `locale -a' for a list of supported values.");
+                    }
+                  retval = os.oscanf (args(1), who);
+                }              
               else
                 ::error ("%s: format TEMPLATE must be a string", who.c_str ());
             }
           else
             ::error ("%s: unable to create temporary input buffer",
                      who.c_str ());
         }
       else
@@ -1287,20 +1325,26 @@ is returned in @var{pos}.\n\
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
+/*
+%!test
+%! assert(sscanf('1,2', '%f', 'C'), 1)
+%! assert(sscanf('1,2', '%f', 'fr_FR'), 1.2)
+*/
+
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
-@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
+@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}]] =} scanf (@var{template}, @var{locale}))\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
@@ -1873,16 +1917,19 @@ use @code{fclose} for the same purpose.\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tmpnam", Ftmpnam, args, ,
  "-*- texinfo -*-\n\
+@c List other forms of function in documentation index\n\
+@findex octave_tmp_file_name\n\
+\n\
 @deftypefn  {Built-in Function} {} tmpnam ()\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir})\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @code{\"oct-\"} is used.\n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 is used.  If @var{dir} is provided, it must exist, otherwise the default\n\
@@ -1976,17 +2023,17 @@ DEFUN (mkstemp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (@var{template}, @var{delete})\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name created from @var{template}.  The last six characters of @var{template}\n\
 must be @code{XXXXXX} and these are replaced with a string that makes the\n\
 filename unique.  The file is then created with mode read/write and\n\
 permissions that are system dependent (on GNU/Linux systems, the permissions\n\
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
-with the @w{@code{O_EXCL}} flag.\n\
+in binary mode and with the @w{@code{O_EXCL}} flag.\n\
 \n\
 If the optional argument @var{delete} is supplied and is true,\n\
 the file will be deleted automatically when Octave exits, or when\n\
 the function @code{purge_tmp_files} is called.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of\n\
 the file, and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
 is -1, @var{name} is empty, and @var{msg} contains a system-dependent\n\
@@ -2006,26 +2053,26 @@ error message.\n\
     {
       std::string tmpl8 = args(0).string_value ();
 
       if (! error_state)
         {
           OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
           strcpy (tmp, tmpl8.c_str ());
 
-          int fd = gnulib::mkstemp (tmp);
+          int fd = gnulib::mkostemp (tmp, O_BINARY);
 
           if (fd < 0)
             {
               retval(2) = gnulib::strerror (errno);
               retval(0) = fd;
             }
           else
             {
-              const char *fopen_mode = "w+";
+              const char *fopen_mode = "w+b";
 
               FILE *fid = fdopen (fd, fopen_mode);
 
               if (fid)
                 {
                   std::string nm = tmp;
 
                   std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
@@ -2172,46 +2219,51 @@ this system.  The name of this directory
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
-Return the value required to request that @code{fseek} perform\n\
+Return the numerical value to pass to @code{fseek} to perform\n\
 one of the following actions:\n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
 @item SEEK_CUR\n\
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
 Position file relative to the end.\n\
 @end table\n\
+@seealso{fseek}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_SET", args, -1);
 }
 
 DEFUNX ("SEEK_CUR", FSEEK_CUR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_CUR ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the current position.\n\
+@seealso{SEEK_SET, SEEK_END}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_CUR", args, 0);
 }
 
 DEFUNX ("SEEK_END", FSEEK_END, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_END ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the end of the file.\n\
+@seealso{SEEK_SET, SEEK_CUR}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args,
              const octave_value& val)
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ## 
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ## 
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #if defined (HAVE_OPENGL)
 
 #include <iostream>
 
 #include <lo-mappers.h>
 #include "oct-locbuf.h"
+#include "oct-refcount.h"
 #include "gl-render.h"
 #include "txt-eng.h"
 #include "txt-eng-ft.h"
 
 #define LIGHT_MODE GL_FRONT_AND_BACK
 
 // Win32 API requires the CALLBACK attributes for
 // GLU callback functions. Define it to empty on
@@ -2455,25 +2456,25 @@ opengl_renderer::draw_hggroup (const hgg
 }
 
 void
 opengl_renderer::draw_text (const text::properties& props)
 {
   if (props.get_string ().is_empty ())
     return;
 
-  const Matrix pos = xform.scale (props.get_data_position ());
+  Matrix pos = xform.scale (props.get_data_position ());
   const Matrix bbox = props.get_extent_matrix ();
 
   // FIXME: handle margin and surrounding box
   bool blend = glIsEnabled (GL_BLEND);
 
   glEnable (GL_BLEND);
   glEnable (GL_ALPHA_TEST);
-  glRasterPos3d (pos(0), pos(1), pos(2));
+  glRasterPos3d (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0);
   glBitmap(0, 0, 0, 0, bbox(0), bbox(1), 0);
   glDrawPixels (bbox(2), bbox(3),
                 GL_RGBA, GL_UNSIGNED_BYTE, props.get_pixels ().data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
 }
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Shai Ayal
+Copyright (C) 2009-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -74,17 +74,18 @@ glps_renderer::draw (const graphics_obje
 
       while (state == GL2PS_OVERFLOW)
         {
           buffsize += 1024*1024;
           gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
                           gl2ps_term, GL2PS_BSP_SORT,
                           (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
                            | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
-                           | GL2PS_BEST_ROOT | gl2ps_text),
+                           | GL2PS_BEST_ROOT | gl2ps_text
+                           | GL2PS_NO_PS3_SHADING),
                           GL_RGBA, 0, NULL, 0, 0, 0,
                           buffsize, fp, "" );
 
           opengl_renderer::draw (go);
           state = gl2psEndPage ();
         }
 
       gnulib::fclose (fp);
diff --git a/src/gl2ps-renderer.h b/src/gl2ps-renderer.h
--- a/src/gl2ps-renderer.h
+++ b/src/gl2ps-renderer.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Shai Ayal
+Copyright (C) 2009-2012 Shai Ayal
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/graphics.cc b/src/graphics.cc
old mode 100755
new mode 100644
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -31,28 +31,29 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 #include <list>
 #include <map>
 #include <set>
 #include <string>
 #include <sstream>
 
+#include "cmd-edit.h"
 #include "file-ops.h"
 #include "file-stat.h"
-
-#include "cmd-edit.h"
+#include "oct-locbuf.h"
+#include "singleton-cleanup.h"
+
 #include "cutils.h"
 #include "defun.h"
 #include "display.h"
 #include "error.h"
 #include "graphics.h"
 #include "input.h"
 #include "ov.h"
-#include "oct-locbuf.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-fcn-handle.h"
 #include "pager.h"
 #include "parse.h"
 #include "toplev.h"
 #include "txt-eng-ft.h"
 #include "unwind-prot.h"
@@ -278,17 +279,18 @@ default_axes_tick (void)
   m(4) = 0.8;
   m(5) = 1.0;
   return m;
 }
 
 static Matrix
 default_axes_ticklength (void)
 {
-  Matrix m (1, 2, 0.01);
+  Matrix m (1, 2, 0.0);
+  m(0) = 0.01;
   m(1) = 0.025;
   return m;
 }
 
 static Matrix
 default_figure_position (void)
 {
   Matrix m (1, 4, 0.0);
@@ -345,17 +347,18 @@ default_control_sliderstep (void)
 
 static Matrix
 default_panel_position (void)
 {
   Matrix retval (1, 4, 0.0);
 
   retval(0) = 0;
   retval(1) = 0;
-  retval(2) = retval(3) = 0.5;
+  retval(2) = 0.5;
+  retval(3) = 0.5;
 
   return retval;
 }
 
 static double
 convert_font_size (double font_size, const caseless_str& from_units,
                    const caseless_str& to_units, double parent_height = 0)
 {
@@ -2317,16 +2320,124 @@ graphics_handle
 gca (void)
 {
   octave_value val = xget (gcf (), "currentaxes");
 
   return val.is_empty () ? octave_NaN : val.double_value ();
 }
 
 static void
+delete_graphics_object (const graphics_handle& h)
+{
+  if (h.ok ())
+    {
+      graphics_object obj = gh_manager::get_object (h);
+
+      // Don't do recursive deleting, due to callbacks
+      if (! obj.get_properties ().is_beingdeleted ())
+        {
+          graphics_handle parent_h = obj.get_parent ();
+
+          graphics_object parent_obj =
+            gh_manager::get_object (parent_h);
+
+          // NOTE: free the handle before removing it from its
+          //       parent's children, such that the object's
+          //       state is correct when the deletefcn callback
+          //       is executed
+
+          gh_manager::free (h);
+
+          // A callback function might have already deleted
+          // the parent
+          if (parent_obj.valid_object ())
+            parent_obj.remove_child (h);
+
+          Vdrawnow_requested = true;
+        }
+    }
+}
+
+static void
+delete_graphics_object (double val)
+{
+  delete_graphics_object (gh_manager::lookup (val));
+}
+
+static void
+delete_graphics_objects (const NDArray vals)
+{
+  for (octave_idx_type i = 0; i < vals.numel (); i++)
+    delete_graphics_object (vals.elem (i));
+}
+
+static void
+close_figure (const graphics_handle& handle)
+{
+  octave_value closerequestfcn = xget (handle, "closerequestfcn");
+
+  OCTAVE_SAFE_CALL (gh_manager::execute_callback, (handle, closerequestfcn));
+}
+
+static void
+force_close_figure (const graphics_handle& handle)
+{
+  // Remove the deletefcn and closerequestfcn callbacks and delete the
+  // object directly.
+
+  xset (handle, "deletefcn", Matrix ());
+  xset (handle, "closerequestfcn", Matrix ());
+
+  delete_graphics_object (handle);
+}
+
+void
+gh_manager::do_close_all_figures (void)
+{
+  // FIXME -- should we process or discard pending events?
+
+  event_queue.clear ();
+
+  // Don't use figure_list_iterator because we'll be removing elements
+  // from the list elsewhere.
+
+  Matrix hlist = do_figure_handle_list (true);
+
+  for (octave_idx_type i = 0; i < hlist.numel (); i++)
+    {
+      graphics_handle h = gh_manager::lookup (hlist(i));
+
+      if (h.ok ())
+        close_figure (h);
+    }
+
+  // They should all be closed now.  If not, force them to close.
+
+  hlist = do_figure_handle_list (true);
+
+  for (octave_idx_type i = 0; i < hlist.numel (); i++)
+    {
+      graphics_handle h = gh_manager::lookup (hlist(i));
+
+      if (h.ok ())
+        force_close_figure (h);
+    }
+
+  // None left now, right?
+
+  hlist = do_figure_handle_list (true);
+
+  assert (hlist.numel () == 0);
+
+  // Clear all callback objects from our list.
+
+  callback_objects.clear ();
+}
+
+static void
 adopt (const graphics_handle& p, const graphics_handle& h)
 {
   graphics_object parent_obj = gh_manager::get_object (p);
   parent_obj.adopt (h);
 }
 
 static bool
 is_handle (const graphics_handle& h)
@@ -2411,16 +2522,17 @@ base_graphics_toolkit::initialize (const
 
 void
 base_graphics_toolkit::finalize (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (h);
 
   finalize (go);
 }
+
 // ---------------------------------------------------------------------
 
 void
 base_properties::set_from_list (base_graphics_object& obj,
                                 property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
@@ -2648,145 +2760,16 @@ base_properties::delete_listener (const 
   property p = get_property (nm);
 
   if (! error_state && p.ok ())
     p.delete_listener (v, mode);
 }
 
 // ---------------------------------------------------------------------
 
-class gnuplot_toolkit : public base_graphics_toolkit
-{
-public:
-  gnuplot_toolkit (void)
-      : base_graphics_toolkit ("gnuplot") { }
-
-  ~gnuplot_toolkit (void) { }
-
-  bool is_valid (void) const { return true; }
-
-  bool initialize (const graphics_object& go)
-    {
-      return go.isa ("figure");
-    }
-
-  void finalize (const graphics_object& go)
-    {
-      if (go.isa ("figure"))
-        {
-          const figure::properties& props =
-              dynamic_cast<const figure::properties&> (go.get_properties ());
-
-          send_quit (props.get___plot_stream__ ());
-        }
-    }
-
-  void update (const graphics_object& go, int id)
-    {
-      if (go.isa ("figure"))
-        {
-          graphics_object obj (go);
-
-          figure::properties& props =
-              dynamic_cast<figure::properties&> (obj.get_properties ());
-
-          switch (id)
-            {
-            case base_properties::ID_VISIBLE:
-              if (! props.is_visible ())
-                {
-                  send_quit (props.get___plot_stream__ ());
-                  props.set___plot_stream__ (Matrix ());
-                  props.set___enhanced__ (false);
-                }
-              break;
-            }
-        }
-    }
-
-  void redraw_figure (const graphics_object& go) const
-    {
-      octave_value_list args;
-      args(0) = go.get_handle ().as_octave_value ();
-      feval ("__gnuplot_drawnow__", args);
-    }
-
-  void print_figure (const graphics_object& go, const std::string& term,
-                     const std::string& file, bool mono,
-                     const std::string& debug_file) const
-    {
-      octave_value_list args;
-      if (! debug_file.empty ())
-        args(4) = debug_file;
-      args(3) = mono;
-      args(2) = file;
-      args(1) = term;
-      args(0) = go.get_handle ().as_octave_value ();
-      feval ("__gnuplot_drawnow__", args);
-    }
-
-  Matrix get_canvas_size (const graphics_handle&) const
-    {
-      Matrix sz (1, 2, 0.0);
-      return sz;
-    }
-
-  double get_screen_resolution (void) const
-    { return 72.0; }
-
-  Matrix get_screen_size (void) const
-    { return Matrix (1, 2, 0.0); }
-
-private:
-  void send_quit (const octave_value& pstream) const
-    {
-      if (! pstream.is_empty ())
-        {
-          octave_value_list args;
-          Matrix fids = pstream.matrix_value ();
-
-          if (! error_state)
-            {
-              args(1) = "\nquit;\n";
-              args(0) = fids(0);
-              feval ("fputs", args);
-
-              args.resize (1);
-              feval ("fflush", args);
-              feval ("pclose", args);
-
-              if (fids.numel () > 1)
-                {
-                  args(0) = fids(1);
-                  feval ("pclose", args);
-
-                  if (fids.numel () > 2)
-                    {
-                      args(0) = fids(2);
-                      feval ("waitpid", args);
-                    }
-                }
-            }
-        }
-    }
-};
-
-graphics_toolkit
-graphics_toolkit::default_toolkit (void)
-{
-  if (available_toolkits.size () == 0)
-    register_toolkit (new gnuplot_toolkit ());
-
-  return available_toolkits["gnuplot"];
-}
-
-std::map<std::string, graphics_toolkit> graphics_toolkit::available_toolkits;
-
-// ---------------------------------------------------------------------
-
 void
 base_graphics_object::update_axis_limits (const std::string& axis_type)
 {
   if (valid_object ())
     {
       graphics_object parent_obj = gh_manager::get_object (get_parent ());
 
       if (parent_obj)
@@ -2931,17 +2914,18 @@ root_figure::properties::set_currentfigu
 
   if (error_state)
     return;
 
   if (xisnan (val.value ()) || is_handle (val))
     {
       currentfigure = val;
 
-      gh_manager::push_figure (val);
+      if (val.ok ())
+        gh_manager::push_figure (val);
     }
   else
     gripe_set_invalid ("currentfigure");
 }
 
 void
 root_figure::properties::set_callbackobject (const octave_value& v)
 {
@@ -5693,17 +5677,17 @@ axes::properties::get_axis_limits (doubl
               //         Is there another way?
               retval = default_lim ();
               retval(0) = pow (10., retval(0));
               retval(1) = pow (10., retval(1));
               return retval;
             }
           if ((min_val <= 0 && max_val > 0))
             {
-              warning ("axis: omitting nonpositive data in log plot");
+              warning ("axis: omitting non-positive data in log plot");
               min_val = min_pos;
             }
           // FIXME -- maybe this test should also be relative?
           if (std::abs (min_val - max_val) < sqrt (DBL_EPSILON))
             {
               min_val *= 0.9;
               max_val *= 1.1;
             }
@@ -5740,18 +5724,18 @@ axes::properties::get_axis_limits (doubl
           // Prevent round-off from cropping ticks
           min_val = std::min (min_val, tick_sep * min_tick);
           max_val = std::max (max_val, tick_sep * max_tick);
         }
     }
 
   retval.resize (1, 2);
 
+  retval(1) = max_val;
   retval(0) = min_val;
-  retval(1) = max_val;
 
   return retval;
 }
 
 void
 axes::properties::calc_ticks_and_lims (array_property& lims,
                                        array_property& ticks,
                                        array_property& mticks,
@@ -7387,17 +7371,26 @@ gh_manager::gh_manager (void)
   : handle_map (), handle_free_list (),
     next_handle (-1.0 - (rand () + 1.0) / (RAND_MAX + 2.0)),
     figure_list (), graphics_lock (),  event_queue (),
     callback_objects (), event_processing (0)
 {
   handle_map[0] = graphics_object (new root_figure ());
 
   // Make sure the default graphics toolkit is registered.
-  graphics_toolkit::default_toolkit ();
+  gtk_manager::default_toolkit ();
+}
+
+void
+gh_manager::create_instance (void)
+{
+  instance = new gh_manager ();
+
+  if (instance)
+    singleton_cleanup_list::add (cleanup_instance);
 }
 
 graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
                                      const graphics_handle& p,
                                      bool integer_figure_handle,
                                      bool do_createfcn,
                                      bool do_notify_toolkit)
@@ -8151,32 +8144,32 @@ values or lists respectively.\n\
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
+  bool use_cell_format = false;
+
   if (nargin == 1 || nargin == 2)
     {
       if (args(0).is_empty())
         {
           retval = Matrix ();
           return retval;
         }
 
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           octave_idx_type len = hcv.length ();
 
-          vals.resize (dim_vector (len, 1));
-
           if (nargin == 1 && len > 1)
             {
               std::string t0 = get_graphics_object_type (hcv(0));
 
               if (! error_state)
                 {
                   for (octave_idx_type n = 1; n < len; n++)
                     {
@@ -8192,70 +8185,118 @@ values or lists respectively.\n\
                         }
                     }
 
                 }
             }
 
           if (! error_state)
             {
-              for (octave_idx_type n = 0; n < len; n++)
+              if (nargin > 1 && args(1).is_cellstr ())
                 {
-                  graphics_object obj = gh_manager::get_object (hcv(n));
-
-                  if (obj)
+                  Array<std::string> plist = args(1).cellstr_value ();
+
+                  if (! error_state)
                     {
-                      if (nargin == 1)
-                        vals(n) = obj.get ();
-                      else
+                      octave_idx_type plen = plist.numel ();
+
+                      use_cell_format = true;
+
+                      vals.resize (dim_vector (len, plen));
+
+                      for (octave_idx_type n = 0; ! error_state && n < len; n++)
                         {
-                          caseless_str property = args(1).string_value ();
-
-                          if (! error_state)
-                            vals(n) = obj.get (property);
+                          graphics_object obj = gh_manager::get_object (hcv(n));
+
+                          if (obj)
+                            {
+                              for (octave_idx_type m = 0; ! error_state && m < plen; m++)
+                                {
+                                  caseless_str property = plist(m);
+
+                                  vals(n, m) = obj.get (property);
+                                }
+                            }
                           else
                             {
-                              error ("get: expecting property name as second argument");
+                              error ("get: invalid handle (= %g)", hcv(n));
                               break;
                             }
                         }
                     }
                   else
+                    error ("get: expecting property name or cell array of property names as second argument");
+                }
+              else
+                {
+                  caseless_str property;
+
+                  if (nargin > 1)
                     {
-                      error ("get: invalid handle (= %g)", hcv(n));
-                      break;
+                      property = args(1).string_value ();
+
+                      if (error_state)
+                        error ("get: expecting property name or cell array of property names as second argument");
+                    }
+
+                  vals.resize (dim_vector (len, 1));
+
+                  if (! error_state)
+                    {
+                      for (octave_idx_type n = 0; ! error_state && n < len; n++)
+                        {
+                          graphics_object obj = gh_manager::get_object (hcv(n));
+
+                          if (obj)
+                            {
+                              if (nargin == 1)
+                                vals(n) = obj.get ();
+                              else
+                                vals(n) = obj.get (property);
+                            }
+                          else
+                            {
+                              error ("get: invalid handle (= %g)", hcv(n));
+                              break;
+                            }
+                        }
                     }
                 }
             }
         }
       else
         error ("get: expecting graphics handle as first argument");
     }
   else
     print_usage ();
 
   if (! error_state)
     {
-      octave_idx_type len = vals.numel ();
-
-      if (len == 0)
-        retval = Matrix ();
-      else if (len == 1)
-        retval = vals(0);
-      else if (len > 1 && nargin == 1)
-        {
-          OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, len);
-
-          for (octave_idx_type n = 0; n < len; n++)
-            tmp[n] = vals(n).scalar_map_value ();
-
-          retval = octave_map::cat (0, len, tmp);
-        }
+      if (use_cell_format)
+        retval = vals;
       else
-        retval = vals;
+        {
+          octave_idx_type len = vals.numel ();
+
+          if (len == 0)
+            retval = Matrix ();
+          else if (len == 1)
+            retval = vals(0);
+          else if (len > 1 && nargin == 1)
+            {
+              OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, len);
+
+              for (octave_idx_type n = 0; n < len; n++)
+                tmp[n] = vals(n).scalar_map_value ();
+
+              retval = octave_map::cat (0, len, tmp);
+            }
+          else
+            retval = vals;
+        }
     }
 
   return retval;
 }
 
 /*
 %!assert (get (findobj (0, 'Tag', 'nonexistenttag'), 'nonexistentproperty'), [])
 */
@@ -8719,50 +8760,17 @@ Undocumented internal function.\n\
                 {
                   error ("delete: invalid graphics object (= %g)",
                          vals.elem (i));
                   break;
                 }
             }
 
           if (! error_state)
-            {
-              for (octave_idx_type i = 0; i < vals.numel (); i++)
-                {
-                  h = gh_manager::lookup (vals.elem (i));
-
-                  if (h.ok ())
-                    {
-                      graphics_object obj = gh_manager::get_object (h);
-
-                      // Don't do recursive deleting, due to callbacks
-                      if (! obj.get_properties ().is_beingdeleted ())
-                        {
-                          graphics_handle parent_h = obj.get_parent ();
-
-                          graphics_object parent_obj =
-                            gh_manager::get_object (parent_h);
-
-                          // NOTE: free the handle before removing it from its
-                          //       parent's children, such that the object's
-                          //       state is correct when the deletefcn callback
-                          //       is executed
-
-                          gh_manager::free (h);
-
-                          // A callback function might have already deleted
-                          // the parent
-                          if (parent_obj.valid_object ())
-                            parent_obj.remove_child (h);
-
-                          Vdrawnow_requested = true;
-                        }
-                    }
-                }
-            }
+            delete_graphics_objects (vals);
         }
       else
         error ("delete: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
@@ -8934,61 +8942,138 @@ Internal function: returns the pixel siz
         error ("__image_pixel_size__: argument is not a handle");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+gtk_manager *gtk_manager::instance = 0;
+
+void
+gtk_manager::create_instance (void)
+{
+  instance = new gtk_manager ();
+
+  if (instance)
+    singleton_cleanup_list::add (cleanup_instance);
+}
+
+graphics_toolkit
+gtk_manager::do_get_toolkit (void) const
+{
+  graphics_toolkit retval;
+
+  const_loaded_toolkits_iterator pl = loaded_toolkits.find (dtk);
+
+  if (pl == loaded_toolkits.end ())
+    {
+      const_available_toolkits_iterator pa = available_toolkits.find (dtk);
+
+      if (pa != available_toolkits.end ())
+        {
+          octave_value_list args;
+          args(0) = dtk;
+          feval ("graphics_toolkit", args);
+
+          if (! error_state)
+            pl = loaded_toolkits.find (dtk);
+
+          if (error_state || pl == loaded_toolkits.end ())
+            error ("failed to load %s graphics toolkit", dtk.c_str ());
+          else
+            retval = pl->second;
+        }
+      else
+        error ("default graphics toolkit `%s' is not available!",
+               dtk.c_str ());
+    }
+  else
+    retval = pl->second;
+
+  return retval;
+}
+
 DEFUN (available_graphics_toolkits, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
+@seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  return octave_value (graphics_toolkit::available_toolkits_list ());
+  return octave_value (gtk_manager::available_toolkits_list ());
+}
+
+DEFUN (register_graphics_toolkit, args, ,
+   "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} register_graphics_toolkit (@var{toolkit})\n\
+List @var{toolkit} as an available graphics toolkit.\n\
+@seealso{available_graphics_toolkits}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  gh_manager::auto_lock guard;
+
+  if (args.length () == 1)
+    {
+      std::string name = args(0).string_value ();
+
+      if (! error_state)
+        gtk_manager::register_toolkit (name);
+      else
+        error ("register_graphics_toolkit: expecting character string");
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
+DEFUN (loaded_graphics_toolkits, , ,
+   "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} loaded_graphics_toolkits ()\n\
+Return a cell array of the currently loaded graphics toolkits.\n\
+@seealso{available_graphics_toolkits}\n\
+@end deftypefn")
+{
+  gh_manager::auto_lock guard;
+
+  return octave_value (gtk_manager::loaded_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} drawnow ()\n\
 @deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
 @deftypefnx {Built-in Function} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.  The event queue is flushed and\n\
 any callbacks generated are executed.  With the optional argument\n\
 @code{\"expose\"}, only graphic objects are updated and no other events or\n\
 callbacks are processed.\n\
 The third calling form of @code{drawnow} is for debugging and is\n\
 undocumented.\n\
 @end deftypefn")
 {
   static int drawnow_executing = 0;
-  static bool __go_close_all_registered__ = false;
 
   octave_value retval;
 
   gh_manager::lock ();
 
   unwind_protect frame;
   frame.protect_var (Vdrawnow_requested, false);
 
   frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
-      if (! __go_close_all_registered__)
-        {
-          octave_add_atexit_function ("__go_close_all__");
-
-          __go_close_all_registered__ = true;
-        }
-
       if (args.length () == 0 || args.length () == 1)
         {
           Matrix hlist = gh_manager::figure_handle_list (true);
 
           for (int i = 0; ! error_state && i < hlist.length (); i++)
             {
               graphics_handle h = gh_manager::lookup (hlist(i));
 
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "caseless-str.h"
 #include "lo-ieee.h"
 
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
+#include "oct-refcount.h"
 #include "ov.h"
 #include "txt-eng-ft.h"
 
 // FIXME -- maybe this should be a configure option?
 // Matlab defaults to "Helvetica", but that causes problems for many
 // gnuplot users.
 #if !defined (OCTAVE_DEFAULT_FONTNAME)
 #define OCTAVE_DEFAULT_FONTNAME "*"
@@ -477,17 +478,17 @@ protected:
 
 private:
   typedef std::map<listener_mode, octave_value_list> listener_map;
   typedef std::map<listener_mode, octave_value_list>::iterator listener_map_iterator;
   typedef std::map<listener_mode, octave_value_list>::const_iterator listener_map_const_iterator;
 
 private:
   int id;
-  int count;
+  octave_refcount<int> count;
   std::string name;
   graphics_handle parent;
   bool hidden;
   listener_map listeners;
 };
 
 // ---------------------------------------------------------------------
 
@@ -1905,17 +1906,17 @@ public:
 
   property (const property& p) : rep (p.rep)
     {
       rep->count++;
     }
 
   ~property (void)
     {
-      if (--rep->count <= 0)
+      if (--rep->count == 0)
         delete rep;
     }
 
   bool ok (void) const
     { return rep->ok (); }
 
   std::string get_name (void) const
     { return rep->get_name (); }
@@ -1960,17 +1961,17 @@ public:
   property& operator = (const octave_value& val)
     {
       *rep = val;
       return *this;
     }
 
   property& operator = (const property& p)
     {
-      if (rep && --rep->count <= 0)
+      if (rep && --rep->count == 0)
         delete rep;
 
       rep = p.rep;
       rep->count++;
 
       return *this;
     }
 
@@ -2126,19 +2127,23 @@ public:
   // Callback function executed just prior to deleting the given
   // graphics object.  This allows the graphics toolkit to perform
   // toolkit-specific cleanup operations before an object is deleted.
   virtual void finalize (const graphics_object&)
     { gripe_invalid ("base_graphics_toolkit::finalize"); }
 
   void finalize (const graphics_handle&);
 
+  // Close the graphics toolkit.
+  virtual void close (void)
+  { gripe_invalid ("base_graphics_toolkit::close"); }
+
 private:
   std::string name;
-  int count;
+  octave_refcount<int> count;
 
 private:
   void gripe_invalid (const std::string& fname) const
     {
       if (! is_valid ())
         error ("%s: invalid graphics toolkit", fname.c_str ());
     }
 };
@@ -2223,58 +2228,210 @@ public:
   // This is called only for explicitly deleted object. Children are
   // deleted implicitly and graphics toolkit isn't notified.
   void finalize (const graphics_object& go)
     { rep->finalize (go); }
 
   void finalize (const graphics_handle& h)
     { rep->finalize (h); }
 
-  OCTINTERP_API static graphics_toolkit default_toolkit (void);
-
-  static void register_toolkit (const graphics_toolkit& b)
-    { available_toolkits[b.get_name ()] = b; }
+  // Close the graphics toolkit.
+  void close (void) { rep->close (); }
+
+private:
+
+  base_graphics_toolkit *rep;
+};
+
+class gtk_manager
+{
+public:
+
+  static graphics_toolkit get_toolkit (void)
+  {
+    return instance_ok () ? instance->do_get_toolkit () : graphics_toolkit ();
+  }
+
+  static void register_toolkit (const std::string& name)
+  {
+    if (instance_ok ())
+      instance->do_register_toolkit (name);
+  }
 
   static void unregister_toolkit (const std::string& name)
-    { available_toolkits.erase (name); }
+  {
+    if (instance_ok ())
+      instance->do_unregister_toolkit (name);
+  }
+
+  static void load_toolkit (const graphics_toolkit& tk)
+  {
+    if (instance_ok ())
+      instance->do_load_toolkit (tk);
+  }
+
+  static void unload_toolkit (const std::string& name)
+  {
+    if (instance_ok ())
+      instance->do_unload_toolkit (name);
+  }
 
   static graphics_toolkit find_toolkit (const std::string& name)
   {
-    const_available_toolkits_iterator p = available_toolkits.find (name);
-
-    if (p != available_toolkits.end ())
-      return p->second;
-    else
-      return default_toolkit ();
+    return instance_ok ()
+      ? instance->do_find_toolkit (name) : graphics_toolkit ();
   }
 
   static Cell available_toolkits_list (void)
   {
+    return instance_ok () ? instance->do_available_toolkits_list () : Cell ();
+  }
+
+  static Cell loaded_toolkits_list (void)
+  {
+    return instance_ok () ? instance->do_loaded_toolkits_list () : Cell ();
+  }
+
+  static void unload_all_toolkits (void)
+  {
+    if (instance_ok ())
+      instance->do_unload_all_toolkits ();
+  }
+
+  static std::string default_toolkit (void)
+  {
+    return instance_ok () ? instance->do_default_toolkit () : std::string ();
+  }
+
+private:
+
+  // FIXME -- default toolkit should be configurable.
+
+  gtk_manager (void)
+    : dtk ("gnuplot"), available_toolkits (), loaded_toolkits () { }
+
+  ~gtk_manager (void) { }
+
+  static void create_instance (void);
+
+  static bool instance_ok (void)
+  {
+    bool retval = true;
+
+    if (! instance)
+      create_instance ();
+
+    if (! instance)
+      {
+        ::error ("unable to create gh_manager!");
+
+        retval = false;
+      }
+
+    return retval;
+  }
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
+  static gtk_manager *instance;
+
+  // The name of the default toolkit.
+  std::string dtk;
+
+  // The list of toolkits that we know about.
+  std::set<std::string> available_toolkits;
+
+  // The list of toolkits we have actually loaded.
+  std::map<std::string, graphics_toolkit> loaded_toolkits;
+
+  typedef std::set<std::string>::iterator available_toolkits_iterator;
+
+  typedef std::set<std::string>::const_iterator
+    const_available_toolkits_iterator;
+
+  typedef std::map<std::string, graphics_toolkit>::iterator
+    loaded_toolkits_iterator;
+
+  typedef std::map<std::string, graphics_toolkit>::const_iterator
+    const_loaded_toolkits_iterator;
+
+  graphics_toolkit do_get_toolkit (void) const;
+
+  void do_register_toolkit (const std::string& name)
+  {
+    available_toolkits.insert (name);
+  }
+
+  void do_unregister_toolkit (const std::string& name)
+  {
+    available_toolkits.erase (name);
+  }
+
+  void do_load_toolkit (const graphics_toolkit& tk)
+  {
+    loaded_toolkits[tk.get_name ()] = tk;
+  }
+
+  void do_unload_toolkit (const std::string& name)
+  {
+    loaded_toolkits.erase (name);
+  }
+
+  graphics_toolkit do_find_toolkit (const std::string& name) const
+  {
+    const_loaded_toolkits_iterator p = loaded_toolkits.find (name);
+
+    if (p != loaded_toolkits.end ())
+      return p->second;
+    else
+      return graphics_toolkit ();
+  }
+
+  Cell do_available_toolkits_list (void) const
+  {
     Cell m (1 , available_toolkits.size ());
-    const_available_toolkits_iterator p;
-    int i;
-
-    for (i = 0, p = available_toolkits.begin ();
-         p !=  available_toolkits.end (); p++, i++)
-      m(i) = p->first;
+    
+    octave_idx_type i = 0;
+    for (const_available_toolkits_iterator p = available_toolkits.begin ();
+         p !=  available_toolkits.end (); p++)
+      m(i++) = *p;
 
     return m;
   }
 
-private:
-  base_graphics_toolkit *rep;
-
-  static OCTINTERP_API std::map<std::string, graphics_toolkit>
-    available_toolkits;
-
-  typedef std::map<std::string, graphics_toolkit>::iterator
-    available_toolkits_iterator;
-
-  typedef std::map<std::string, graphics_toolkit>::const_iterator
-    const_available_toolkits_iterator;
+  Cell do_loaded_toolkits_list (void) const
+  {
+    Cell m (1 , loaded_toolkits.size ());
+    
+    octave_idx_type i = 0;
+    for (const_loaded_toolkits_iterator p = loaded_toolkits.begin ();
+         p !=  loaded_toolkits.end (); p++)
+      m(i++) = p->first;
+
+    return m;
+  }
+
+  void do_unload_all_toolkits (void)
+  {
+    while (! loaded_toolkits.empty ())
+      {
+        loaded_toolkits_iterator p = loaded_toolkits.begin ();
+
+        std::string name = p->first;
+
+        p->second.close ();
+
+        // The toolkit may have unloaded itself.  If not, we'll do
+        // it here.
+        if (loaded_toolkits.find (name) != loaded_toolkits.end ())
+          unload_toolkit (name);
+      }
+  }
+
+  std::string do_default_toolkit (void) { return dtk; }
 };
 
 // ---------------------------------------------------------------------
 
 class base_graphics_object;
 class graphics_object;
 
 class OCTINTERP_API base_properties
@@ -2734,17 +2891,17 @@ protected:
   virtual void update (const graphics_object& go, int id)
     {
       if (toolkit_flag)
         get_toolkit ().update (go, id);
     }
 
 protected:
   // A reference count.
-  int count;
+  octave_refcount<int> count;
 
   // A flag telling whether this object is a valid object
   // in the backend context.
   bool toolkit_flag;
 
   // No copying!
 
   base_graphics_object (const base_graphics_object&) : count (0) { }
@@ -3005,17 +3162,17 @@ public:
 
 private:
   properties xproperties;
 
 public:
 
   root_figure (void) : xproperties (0, graphics_handle ()), default_properties () { }
 
-  ~root_figure (void) { xproperties.delete_children (); }
+  ~root_figure (void) { }
 
   void mark_modified (void) { }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Now override with our defaults.  If the default_properties
     // list includes the properties for all defaults (line,
     // surface, etc.) then we don't have to know the type of OBJ
@@ -3116,31 +3273,31 @@ public:
 
     void remove_child (const graphics_handle& h);
 
     void set_visible (const octave_value& val);
 
     graphics_toolkit get_toolkit (void) const
       {
         if (! toolkit)
-          toolkit = graphics_toolkit::default_toolkit ();
+          toolkit = gtk_manager::get_toolkit ();
 
         return toolkit;
       }
 
     void set_toolkit (const graphics_toolkit& b);
 
     void set___graphics_toolkit__ (const octave_value& val)
     {
       if (! error_state)
         {
           if (val.is_string ())
             {
               std::string nm = val.string_value ();
-              graphics_toolkit b = graphics_toolkit::find_toolkit (nm);
+              graphics_toolkit b = gtk_manager::find_toolkit (nm);
               if (b.get_name () != nm)
                 {
                   error ("set___graphics_toolkit__: invalid graphics toolkit");
                 }
               else
                 {
                   set_toolkit (b);
                   mark_modified ();
@@ -3253,20 +3410,17 @@ private:
 
 public:
   figure (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
   {
     xproperties.override_defaults (*this);
   }
 
-  ~figure (void)
-  {
-    xproperties.delete_children ();
-  }
+  ~figure (void) { }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Allow parent (root figure) to override first (properties knows how
     // to find the parent object).
     xproperties.override_defaults (obj);
 
     // Now override with our defaults.  If the default_properties
@@ -3857,17 +4011,17 @@ private:
 public:
   axes (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
   {
     xproperties.override_defaults (*this);
     xproperties.update_transform ();
   }
 
-  ~axes (void) { xproperties.delete_children (); }
+  ~axes (void) { }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Allow parent (figure) to override first (properties knows how
     // to find the parent object).
     xproperties.override_defaults (obj);
 
     // Now override with our defaults.  If the default_properties
@@ -3994,17 +4148,17 @@ private:
 
 public:
   line (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~line (void) { xproperties.delete_children (); }
+  ~line (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4134,17 +4288,17 @@ private:
 public:
   text (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.set_clipping ("off");
     xproperties.override_defaults (*this);
   }
 
-  ~text (void) { xproperties.delete_children (); }
+  ~text (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4258,17 +4412,17 @@ private:
 
 public:
   image (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~image (void) { xproperties.delete_children (); }
+  ~image (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4376,17 +4530,17 @@ private:
 
 public:
   patch (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~patch (void) { xproperties.delete_children (); }
+  ~patch (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4529,17 +4683,17 @@ private:
 
 public:
   surface (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~surface (void) { xproperties.delete_children (); }
+  ~surface (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4597,17 +4751,17 @@ private:
 
 public:
   hggroup (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~hggroup (void) { xproperties.delete_children (); }
+  ~hggroup (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
   void update_axis_limits (const std::string& axis_type);
@@ -4661,17 +4815,17 @@ private:
 
 public:
   uimenu (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uimenu (void) { xproperties.delete_children (); }
+  ~uimenu (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
 };
@@ -4707,17 +4861,17 @@ private:
 
 public:
   uicontextmenu (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uicontextmenu (void) { xproperties.delete_children (); }
+  ~uicontextmenu (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
 };
@@ -4800,17 +4954,17 @@ private:
 
 public:
   uicontrol (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uicontrol (void) { xproperties.delete_children (); }
+  ~uicontrol (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4866,17 +5020,17 @@ private:
 
 public:
   uipanel (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uipanel (void) { xproperties.delete_children (); }
+  ~uipanel (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 };
 
@@ -4905,17 +5059,17 @@ private:
 
 public:
   uitoolbar (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uitoolbar (void) { xproperties.delete_children (); }
+  ~uitoolbar (void) { }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Allow parent (figure) to override first (properties knows how
     // to find the parent object).
     xproperties.override_defaults (obj);
 
     // Now override with our defaults.  If the default_properties
@@ -5003,17 +5157,17 @@ private:
 
 public:
   uipushtool (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uipushtool (void) { xproperties.delete_children (); }
+  ~uipushtool (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
 };
@@ -5056,17 +5210,17 @@ private:
 
 public:
   uitoggletool (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
   {
     xproperties.override_defaults (*this);
   }
 
-  ~uitoggletool (void) { xproperties.delete_children (); }
+  ~uitoggletool (void) { }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
 };
@@ -5092,17 +5246,17 @@ public:
 
   base_graphics_event (void) : count (1) { }
 
   virtual ~base_graphics_event (void) { }
 
   virtual void execute (void) = 0;
 
 private:
-  int count;
+  octave_refcount<int> count;
 };
 
 class
 graphics_event
 {
 public:
   typedef void (*event_fcn) (void*);
 
@@ -5164,33 +5318,37 @@ private:
 class OCTINTERP_API gh_manager
 {
 protected:
 
   gh_manager (void);
 
 public:
 
+  static void create_instance (void);
+
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
-      instance = new gh_manager ();
+      create_instance ();
 
     if (! instance)
       {
         ::error ("unable to create gh_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static graphics_handle get_handle (bool integer_figure_handle)
   {
     return instance_ok ()
       ? instance->do_get_handle (integer_figure_handle) : graphics_handle ();
   }
 
   static void free (const graphics_handle& h)
   {
@@ -5377,16 +5535,22 @@ public:
     graphics_object go = get_object (h);
 
     if (go.valid_object ())
       retval = go.is_handle_visible ();
 
     return retval;
   }
 
+  static void close_all_figures (void)
+  {
+    if (instance_ok ())
+      instance->do_close_all_figures ();
+  }
+
 public:
   class auto_lock : public octave_autolock
   {
   public:
     auto_lock (bool wait = true)
       : octave_autolock (instance_ok ()
                          ? instance->graphics_lock
                          : octave_mutex (),
@@ -5542,16 +5706,18 @@ private:
   
   void do_post_function (graphics_event::event_fcn fcn, void* fcn_data);
 
   void do_post_set (const graphics_handle& h, const std::string name,
                     const octave_value& value, bool notify_toolkit = true);
 
   int do_process_events (bool force = false);
 
+  void do_close_all_figures (void);
+
   static void restore_gcbo (void)
   {
     if (instance_ok ())
       instance->do_restore_gcbo ();
   }
 
   void do_restore_gcbo (void);
 
@@ -5567,9 +5733,11 @@ void get_children_limits (double& min_va
 OCTINTERP_API int calc_dimensions (const graphics_object& gh);
 
 // This function is NOT equivalent to the scripting language function gcf.
 OCTINTERP_API graphics_handle gcf (void);
 
 // This function is NOT equivalent to the scripting language function gca.
 OCTINTERP_API graphics_handle gca (void);
 
+OCTINTERP_API void close_all_figures (void);
+
 #endif
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -234,25 +234,29 @@ Array index or function argument delimit
 @deftypefn {Operator} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
 @end deftypefn"),
 
   pair_type ("**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} **\n\
-Power operator.\n\
-@seealso{power, ^, .**, .^}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ^\n\
-Power operator.\n\
-@seealso{power, **, .^, .**}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, **, .^, .**, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("+",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
@@ -299,25 +303,31 @@ transpose, @emph{not} the complex conjug
 @deftypefn {Operator} {} .*\n\
 Element by element multiplication operator.\n\
 @seealso{*, times}\n\
 @end deftypefn"),
 
   pair_type (".**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
-Element by element power operator.\n\
-@seealso{**, ^, .^, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{**, ^, .^, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type (".^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .^\n\
-Element by element power operator.\n\
-@seealso{.**, ^, **, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{.**, ^, **, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("./",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ./\n\
 Element by element right division operator.\n\
 @seealso{/, .\\, rdivide, mrdivide}\n\
 @end deftypefn"),
@@ -612,17 +622,17 @@ endif\n\
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
     "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} for @var{i} = @var{range}\n\
+@deftypefn  {Keyword} {} for @var{i} = @var{range}\n\
 @deftypefnx {Keyword} {} for (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
@@ -637,23 +647,16 @@ endparfor\n\
 Declare variables as persistent.  A variable that has been declared\n\
 persistent within a function will retain its contents in memory between\n\
 subsequent calls to the same function.  The difference between persistent\n\
 variables and global variables is that persistent variables are local in \n\
 scope to a particular function and are not visible elsewhere.\n\
 @seealso{global}\n\
 @end deftypefn"),
 
-  pair_type ("replot",
-    "-*- texinfo -*-\n\
-@deftypefn {Keyword} {} replot\n\
-Replot a graphic.\n\
-@seealso{plot}\n\
-@end deftypefn"),
-
   pair_type ("return",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} return\n\
 Return from a function.\n\
 @seealso{function}\n\
 @end deftypefn"),
 
   pair_type ("static",
@@ -1263,83 +1266,108 @@ Undocumented internal function.\n\
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} doc_cache_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave documentation cache file.  A cache file significantly improves\n\
 the performance of the @code{lookfor} command.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/doc-cache},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_DOC_CACHE_FILE}}, or the command line argument\n\
 @samp{--doc-cache-file NAME}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
 DEFUN (info_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} info_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
 which @var{octave-home} is the root directory of the Octave installation.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_INFO_FILE}}, or the command line argument\n\
 @samp{--info-file NAME}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
 DEFUN (info_program, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_program (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} info_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 info program to run.  The default value is\n\
 @file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 @var{version} is the Octave version number, and @var{arch}\n\
 is the system type (for example, @code{i686-pc-linux-gnu}).  The\n\
 default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_INFO_PROGRAM}}, or the command line argument\n\
 @samp{--info-program NAME}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{info_file, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
 }
 
 DEFUN (makeinfo_program, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} makeinfo_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} suppress_verbose_help_message (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -744,27 +744,25 @@ get_debug_input (const std::string& prom
       symbol_table::scope_id scope = symbol_table::top_scope ();
       frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
       // This is the same as yyparse in parse.y.
       int retval = octave_parse ();
 
       if (retval == 0 && global_command)
         {
-          global_command->accept (*current_evaluator);
+          unwind_protect inner_frame;
 
-          // FIXME -- To avoid a memory leak, global_command should be
-          // deleted, I think.  But doing that here causes trouble if
-          // an error occurs while executing a debugging command
-          // (dbstep, for example). It's not clear to me why that
-          // happens.
-          //
-          // delete global_command;
-          //
-          // global_command = 0;
+          // Use an unwind-protect cleanup function so that the
+          // global_command list will be deleted in the event of an
+          // interrupt.
+
+          inner_frame.add_fcn (cleanup_statement_list, &global_command);
+
+          global_command->accept (*current_evaluator);
 
           if (octave_completion_matches_called)
             octave_completion_matches_called = false;
         }
 
       // Unmark forced variables.
       // Restore previous value of global_command.
       frame.run_top (2);
@@ -1355,16 +1353,17 @@ periodically when Octave is waiting for 
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} PS1 (@var{new_val}, \"local\")\n\
 Query or set the primary prompt string.  When executing interactively,\n\
 Octave displays the primary prompt when it is ready to read a command.\n\
 \n\
 The default value of the primary prompt string is @code{\"\\s:\\#> \"}.\n\
 To change it, use a command like\n\
 \n\
 @example\n\
 PS1 (\"\\\\u@@\\\\H> \")\n\
@@ -1380,68 +1379,88 @@ You can also use ANSI escape sequences i
 This can be useful for coloring the prompt.  For example,\n\
 \n\
 @example\n\
 PS1 (\"\\\\[\\\\033[01;31m\\\\]\\\\s:\\\\#> \\\\[\\\\033[0m\\]\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will give the default Octave prompt a red coloring.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{PS2, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS1);
 }
 
 DEFUN (PS2, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS2 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} PS2 (@var{new_val}, \"local\")\n\
 Query or set the secondary prompt string.  The secondary prompt is\n\
 printed when Octave is expecting additional input to complete a\n\
 command.  For example, if you are typing a @code{for} loop that spans several\n\
 lines, Octave will print the secondary prompt at the beginning of\n\
 each line after the first.  The default value of the secondary prompt\n\
 string is @code{\"> \"}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{PS1, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
 DEFUN (PS4, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS4 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} PS4 (@var{new_val}, \"local\")\n\
 Query or set the character string used to prefix output produced\n\
 when echoing commands is enabled.\n\
 The default value is @code{\"+ \"}.\n\
 @xref{Diary and Echo Commands}, for a description of echoing commands.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{echo, echo_executing_commands, PS1, PS2}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS4);
 }
 
 DEFUN (completion_append_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} completion_append_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} completion_append_char (@var{new_val}, \"local\")\n\
 Query or set the internal character variable that is appended to\n\
 successful command-line completion attempts.  The default\n\
 value is @code{\" \"} (a single space).\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
 DEFUN (echo_executing_commands, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} echo_executing_commands (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls the echo state.\n\
 It may be the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
 Echo commands read from script files.\n\
 \n\
 @item 2\n\
@@ -1451,16 +1470,20 @@ Echo commands from functions.\n\
 Echo commands read from command line.\n\
 @end table\n\
 \n\
 More than one state can be active at once.  For example, a value of 3 is\n\
 equivalent to the command @kbd{echo on all}.\n\
 \n\
 The value of @code{echo_executing_commands} may be set by the @kbd{echo}\n\
 command or the command line option @option{--echo-commands}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 DEFUN (__request_drawnow__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __request_drawnow__ ()\n\
@@ -1501,16 +1524,17 @@ Undocumented internal function.\n\
 
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} filemarker ()\n\
 @deftypefnx {Built-in Function} {} filemarker (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} filemarker (@var{new_val}, \"local\")\n\
 Query or set the character used to separate filename from the\n\
 the subfunction names contained within the file.  This can be used in\n\
 a generic manner to interact with subfunctions.  For example,\n\
 \n\
 @example\n\
 help ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
@@ -1521,16 +1545,20 @@ debugging it allows easier placement of 
 For example,\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 will set a breakpoint at the first line of the subfunction @code{mysubfunc}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   char tmp = Vfilemarker;
   octave_value retval = SET_INTERNAL_VARIABLE (filemarker);
 
   // The character passed must not be a legal character for a function name
   if (! error_state && (::isalnum (Vfilemarker) || Vfilemarker == '_'))
     {
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -38,16 +38,20 @@ extern OCTINTERP_API YY_BUFFER_STATE cre
 extern OCTINTERP_API YY_BUFFER_STATE current_buffer (void);
 
 // Connect to new buffer buffer.
 extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
 
 // Delete a buffer.
 extern OCTINTERP_API void delete_buffer (YY_BUFFER_STATE buf);
 
+extern OCTINTERP_API void clear_all_buffers (void);
+
+extern OCTINTERP_API void cleanup_parser (void);
+
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
 extern void prep_lexer_for_script_file (void);
 extern void prep_lexer_for_function_file (void);
 
 // For communication between the lexer and parser.
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -78,16 +78,17 @@ along with Octave; see the file COPYING.
 #include <oct-gperf.h>
 
 #if defined (GNULIB_NAMESPACE)
 // Calls to the following functions appear in the generated output from
 // flex without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define fwrite GNULIB_NAMESPACE::fwrite
+#define isatty GNULIB_NAMESPACE::isatty
 #define malloc GNULIB_NAMESPACE::malloc
 #define realloc GNULIB_NAMESPACE::realloc
 #endif
 
 #if ! (defined (FLEX_SCANNER) \
        && defined (YY_FLEX_MAJOR_VERSION) && YY_FLEX_MAJOR_VERSION >= 2 \
        && defined (YY_FLEX_MINOR_VERSION) && YY_FLEX_MINOR_VERSION >= 5)
 #error lex.l requires flex version 2.5.4 or later
@@ -1136,19 +1137,21 @@ reset_parser (void)
   if (! (reading_script_file || reading_fcn_file || reading_classdef_file))
     {
       current_input_column = 1;
       input_line_number = command_editor::current_command_number ();
     }
 
   // Only ask for input from stdin if we are expecting interactive
   // input.
-  if ((interactive || forced_interactive)
+
+  if (! quitting_gracefully
+      && (interactive || forced_interactive)
       && ! (reading_fcn_file
-        || reading_classdef_file
+            || reading_classdef_file
             || reading_script_file
             || get_input_from_eval_string
             || input_from_startup_file))
     yyrestart (stdin);
 
   // Clear the buffer for help text.
   while (! help_buf.empty ())
     help_buf.pop ();
@@ -1411,16 +1414,32 @@ switch_to_buffer (YY_BUFFER_STATE buf)
 // Delete a buffer.
 
 void
 delete_buffer (YY_BUFFER_STATE buf)
 {
   yy_delete_buffer (buf);
 }
 
+// Delete all buffers from the stack.
+void
+clear_all_buffers (void)
+{                 
+  while (current_buffer ())
+    octave_pop_buffer_state ();
+}
+
+void
+cleanup_parser (void)
+{
+  reset_parser ();
+
+  clear_all_buffers ();
+}
+
 // Restore a buffer (for unwind-prot).
 
 void
 restore_input_buffer (void *buf)
 {
   switch_to_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "pathsearch.h"
+#include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "input.h"
 #include "load-path.h"
 #include "pager.h"
 #include "parse.h"
 #include "toplev.h"
@@ -285,17 +286,22 @@ load_path::dir_info::get_method_file_map
 }
 
 bool
 load_path::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new load_path ();
+    {
+      instance = new load_path ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create load path object!");
 
       retval = false;
     }
 
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -438,16 +438,18 @@ private:
   mutable fcn_map_type fcn_map;
 
   mutable private_fcn_map_type private_fcn_map;
 
   mutable method_map_type method_map;
 
   static load_path *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static hook_fcn_ptr add_hook;
 
   static hook_fcn_ptr remove_hook;
 
   static std::string command_line_path;
 
   static std::string sys_path;
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -1560,17 +1560,17 @@ The command\n\
 \n\
 @example\n\
 save -binary data a b*\n\
 @end example\n\
 \n\
 @noindent\n\
 saves the variable @samp{a} and all variables beginning with @samp{b} to\n\
 the file @file{data} in Octave's binary format.\n\
-@seealso{load, default_save_options, dlmread, csvread, fread}\n\
+@seealso{load, default_save_options, save_header_format_string, dlmread, csvread, fread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length ();
 
   string_vector argv = args.make_argv ();
 
@@ -1743,99 +1743,129 @@ the file @file{data} in Octave's binary 
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
 }
 
 DEFUN (default_save_options, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} default_save_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} default_save_options (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} default_save_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the default options\n\
 for the @code{save} command, and defines the default format.\n\
 Typical values include @code{\"-ascii\"}, @code{\"-text -zip\"}.\n\
 The default value is @option{-text}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{save}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (default_save_options);
 }
 
 DEFUN (octave_core_file_limit, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} octave_core_file_limit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum amount\n\
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).  If\n\
 @var{octave_core_file_options} flags specify a binary format,\n\
 then @var{octave_core_file_limit} will be approximately the maximum\n\
 size of the file.  If a text file format is used, then the file could\n\
 be much larger than the limit.  The default value is -1 (unlimited)\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
 DEFUN (octave_core_file_name, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} octave_core_file_name (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
 The default value is @code{\"octave-core\"}\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
 }
 
 DEFUN (octave_core_file_options, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} octave_core_file_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options used for\n\
 saving the workspace data if Octave aborts.  The value of\n\
 @code{octave_core_file_options} should follow the same format as the\n\
 options for the @code{save} function.  The default value is Octave's binary\n\
 format.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_options);
 }
 
 DEFUN (save_header_format_string, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_header_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_header_format_string (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} save_header_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format\n\
 string used for the comment line written at the beginning of\n\
 text-format data files saved by Octave.  The format string is\n\
 passed to @code{strftime} and should begin with the character\n\
 @samp{#} and contain no newline characters.  If the value of\n\
 @code{save_header_format_string} is the empty string,\n\
 the header comment is omitted from text-format data files.  The\n\
 default value is\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 \"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end smallexample\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{strftime, save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (save_header_format_string);
 }
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-ascii-helper.cc b/src/ls-ascii-helper.cc
--- a/src/ls-ascii-helper.cc
+++ b/src/ls-ascii-helper.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Benjamin Lindner
+Copyright (C) 2009-2012 Benjamin Lindner
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-ascii-helper.h b/src/ls-ascii-helper.h
--- a/src/ls-ascii-helper.h
+++ b/src/ls-ascii-helper.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Benjamin Lindner
+Copyright (C) 2009-2012 Benjamin Lindner
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-hdf5.h b/src/ls-hdf5.h
--- a/src/ls-hdf5.h
+++ b/src/ls-hdf5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat-ascii.h b/src/ls-mat-ascii.h
--- a/src/ls-mat-ascii.h
+++ b/src/ls-mat-ascii.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat4.h b/src/ls-mat4.h
--- a/src/ls-mat4.h
+++ b/src/ls-mat4.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-mat5.h b/src/ls-mat5.h
--- a/src/ls-mat5.h
+++ b/src/ls-mat5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -414,14 +414,19 @@ save_three_d (std::ostream& os, const oc
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} save_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 digits to keep when saving data in text format.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1, INT_MAX);
 }
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-oct-binary.h b/src/ls-oct-binary.h
--- a/src/ls-oct-binary.h
+++ b/src/ls-oct-binary.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-utils.cc b/src/ls-utils.cc
--- a/src/ls-utils.cc
+++ b/src/ls-utils.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ls-utils.h b/src/ls-utils.h
--- a/src/ls-utils.h
+++ b/src/ls-utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/main.c b/src/main.c
--- a/src/main.c
+++ b/src/main.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -62,30 +62,30 @@ abs (3 + 4i)\n\
     retval = args(0).abs ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(abs (1), 1);
-%!assert(abs (-3.5), 3.5);
-%!assert(abs (3+4i), 5);
-%!assert(abs (3-4i), 5);
-%!assert(abs ([1.1, 3i; 3+4i, -3-4i]), [1.1, 3; 5, 5]);
+%!assert (abs (1), 1)
+%!assert (abs (-3.5), 3.5)
+%!assert (abs (3+4i), 5)
+%!assert (abs (3-4i), 5)
+%!assert (abs ([1.1, 3i; 3+4i, -3-4i]), [1.1, 3; 5, 5])
 
-%!assert(abs (single(1)), single(1));
-%!assert(abs (single(-3.5)), single(3.5));
-%!assert(abs (single(3+4i)), single(5));
-%!assert(abs (single(3-4i)), single(5));
-%!assert(abs (single([1.1, 3i; 3+4i, -3-4i])), single([1.1, 3; 5, 5]));
+%!assert (abs (single (1)), single (1))
+%!assert (abs (single (-3.5)), single (3.5))
+%!assert (abs (single (3+4i)), single (5))
+%!assert (abs (single (3-4i)), single (5))
+%!assert (abs (single ([1.1, 3i; 3+4i, -3-4i])), single ([1.1, 3; 5, 5]))
 
-%!error abs ();
-%!error abs (1, 2);
+%!error abs ()
+%!error abs (1, 2)
 */
 
 DEFUN (acos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
@@ -95,32 +95,32 @@ Compute the inverse cosine in radians fo
     retval = args(0).acos ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
-%! assert(acos (x), v, sqrt(eps));
 
 %!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
+%! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! assert (acos (x), v, sqrt (eps));
+
+%!test
 %! x = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
-%! assert(acos (x), v, sqrt(eps('single')));
+%! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! assert (acos (x), v, sqrt (eps ('single')));
 
-%!error acos ();
-%!error acos (1, 2);
+%!error acos ()
+%!error acos (1, 2)
 */
 
 DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
@@ -131,27 +131,27 @@ Compute the inverse hyperbolic cosine fo
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
+%! x = [1, 0, -1, 0];
 %! v = [0, pi/2*i, pi*i, pi/2*i];
-%! x = [1, 0, -1, 0];
-%! assert(acosh (x), v, sqrt(eps));
+%! assert (acosh (x), v, sqrt (eps));
 
 %!test
-%! v = single([0, pi/2*i, pi*i, pi/2*i]);
-%! x = single([1, 0, -1, 0]);
-%! assert(acosh (x), v, sqrt (eps('single')));
+%! x = single ([1, 0, -1, 0]);
+%! v = single ([0, pi/2*i, pi*i, pi/2*i]);
+%! assert (acosh (x), v, sqrt (eps ('single')));
 
-%!error acosh ();
-%!error acosh (1, 2);
+%!error acosh ()
+%!error acosh (1, 2)
 */
 
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
 @end deftypefn")
 {
@@ -192,36 +192,36 @@ arg (3 + 4i)\n\
     retval = args(0).arg ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(arg (1), 0);
-%!assert(arg (i), pi/2);
-%!assert(arg (-1), pi);
-%!assert(arg (-i), -pi/2);
-%!assert(arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2]);
+%!assert (arg (1), 0)
+%!assert (arg (i), pi/2)
+%!assert (arg (-1), pi)
+%!assert (arg (-i), -pi/2)
+%!assert (arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2])
 
-%!assert(arg (single(1)), single(0));
-%!assert(arg (single(i)), single(pi/2));
+%!assert (arg (single (1)), single (0))
+%!assert (arg (single (i)), single (pi/2))
 %!test
 %! if (ismac ())
 %!   ## Avoid failing for a MacOS feature
-%!   assert(arg (single(-1)), single(pi), 2*eps(single(1)));
+%!   assert (arg (single (-1)), single (pi), 2*eps (single (1)));
 %! else
-%!   assert(arg (single(-1)), single(pi));
+%!   assert (arg (single (-1)), single (pi));
 %! endif
-%!assert(arg (single(-i)), single(-pi/2));
-%!assert(arg (single([1, i; -1, -i])), single([0, pi/2; pi, -pi/2]), 2e1*eps('single'));
+%!assert (arg (single (-i)), single (-pi/2))
+%!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ('single'))
 
-%!error arg ();
-%!error arg (1, 2);
+%!error arg ()
+%!error arg (1, 2)
 */
 
 DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
@@ -234,21 +234,22 @@ Compute the inverse sine in radians for 
 
   return retval;
 }
 
 /*
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
+%! x = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
 %! v = [0, pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6, 0];
-%! x = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
-%! assert(all (abs (asin (x) - v) < sqrt (eps)));
-%!error asin ();
-%!error asin (1, 2);
+%! assert (all (abs (asin (x) - v) < sqrt (eps)));
+
+%!error asin ()
+%!error asin (1, 2)
 */
 
 DEFUN (asinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
@@ -261,25 +262,25 @@ Compute the inverse hyperbolic sine for 
 
   return retval;
 }
 
 /*
 %!test
 %! v = [0, pi/2*i, 0, -pi/2*i];
 %! x = [0, i, 0, -i];
-%! assert(asinh (x), v,  sqrt (eps));
+%! assert (asinh (x), v,  sqrt (eps));
 
 %!test
-%! v = single([0, pi/2*i, 0, -pi/2*i]);
-%! x = single([0, i, 0, -i]);
-%! assert(asinh (x), v,  sqrt (eps('single')));
+%! v = single ([0, pi/2*i, 0, -pi/2*i]);
+%! x = single ([0, i, 0, -i]);
+%! assert (asinh (x), v,  sqrt (eps ('single')));
 
-%!error asinh ();
-%!error asinh (1, 2);
+%!error asinh ()
+%!error asinh (1, 2)
 */
 
 DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
@@ -289,32 +290,32 @@ Compute the inverse tangent in radians f
     retval = args(0).atan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
-%! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
-%! assert(atan (x), v, sqrt (eps));
 
 %!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! v = single([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
-%! x = single([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert(atan (x), v, sqrt (eps('single')));
+%! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
+%! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
+%! assert (atan (x), v, sqrt (eps));
 
-%!error atan ();
-%!error atan (1, 2);
+%!test
+%! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
+%! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
+%! assert (atan (x), v, sqrt (eps ('single')));
+
+%!error atan ()
+%!error atan (1, 2)
 */
 
 DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
@@ -327,25 +328,25 @@ Compute the inverse hyperbolic tangent f
 
   return retval;
 }
 
 /*
 %!test
 %! v = [0, 0];
 %! x = [0, 0];
-%! assert(atanh (x), v, sqrt (eps));
+%! assert (atanh (x), v, sqrt (eps));
 
 %!test
-%! v = single([0, 0]);
-%! x = single([0, 0]);
-%! assert(atanh (x), v, sqrt (eps('single')));
+%! v = single ([0, 0]);
+%! x = single ([0, 0]);
+%! assert (atanh (x), v, sqrt (eps ('single')));
 
-%!error atanh ();
-%!error atanh (1, 2);
+%!error atanh ()
+%!error atanh (1, 2)
 */
 
 DEFUN (cbrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cbrt (@var{x})\n\
 Compute the real cube root of each element of @var{x}.\n\
 Unlike @code{@var{x}^(1/3)}, the result will be negative if @var{x} is\n\
 negative.\n\
@@ -365,16 +366,19 @@ negative.\n\
 %!assert (cbrt (64), 4)
 %!assert (cbrt (-125), -5)
 %!assert (cbrt (0), 0)
 %!assert (cbrt (Inf), Inf)
 %!assert (cbrt (-Inf), -Inf)
 %!assert (cbrt (NaN), NaN)
 %!assert (cbrt (2^300), 2^100)
 %!assert (cbrt (125*2^300), 5*2^100)
+
+%!error cbrt ()
+%!error cbrt (1, 2)
 */
 
 DEFUN (ceil, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  This is equivalent to\n\
 rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
@@ -394,29 +398,29 @@ ceil ([-2.7, 2.7])\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %% double precision
-%!assert(ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1]);
+%!assert (ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1])
 
-%% compelx double precison
-%!assert(ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i]);
+%% complex double precison
+%!assert (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i])
 
 %% single precision
-%!assert(ceil (single([2, 1.1, -1.1, -1])), single([2, 2, -1, -1]));
+%!assert (ceil (single ([2, 1.1, -1.1, -1])), single ([2, 2, -1, -1]))
 
-%% compelx single preci
-%!assert(ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single([2+2i, 2+2i, -1-i, -1-i]));
+%% complex single precision
+%!assert (ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 2+2i, -1-i, -1-i]))
 
-%!error ceil ();
-%!error ceil (1, 2);
+%!error ceil ()
+%!error ceil (1, 2)
 */
 
 DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
@@ -432,30 +436,30 @@ Return the complex conjugate of @var{z},
     retval = args(0).conj ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(conj (1), 1);
-%!assert(conj (i), -i)
-%!assert(conj (1+i), 1-i)
-%!assert(conj (1-i), 1+i)
-%!assert(conj ([-1, -i; -1+i, -1-i]), [-1, i; -1-i, -1+i]);
+%!assert (conj (1), 1)
+%!assert (conj (i), -i)
+%!assert (conj (1+i), 1-i)
+%!assert (conj (1-i), 1+i)
+%!assert (conj ([-1, -i; -1+i, -1-i]), [-1, i; -1-i, -1+i])
 
-%!assert(conj (single(1)), single(1));
-%!assert(conj (single(i)), single(-i))
-%!assert(conj (single(1+i)), single(1-i))
-%!assert(conj (single(1-i)), single(1+i))
-%!assert(conj (single([-1, -i; -1+i, -1-i])), single([-1, i; -1-i, -1+i]));
+%!assert (conj (single (1)), single (1))
+%!assert (conj (single (i)), single (-i))
+%!assert (conj (single (1+i)), single (1-i))
+%!assert (conj (single (1-i)), single (1+i))
+%!assert (conj (single ([-1, -i; -1+i, -1-i])), single ([-1, i; -1-i, -1+i]))
 
-%!error conj ();
-%!error conj (1, 2);
+%!error conj ()
+%!error conj (1, 2)
 */
 
 DEFUN (cos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
@@ -465,32 +469,34 @@ Compute the cosine for each element of @
     retval = args(0).cos ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
+
+%!test
 %! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
-%! assert(cos (x), v, sqrt (eps));
+%! assert (cos (x), v, sqrt (eps));
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! x = single([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
-%! v = single([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
-%! assert(cos (x), v, sqrt (eps('single')));
+%! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
+%! assert (cos (x), v, sqrt (eps ('single')));
 
-%!error cos ();
-%!error cos (1, 2);
+%!error cos ()
+%!error cos (1, 2)
 */
 
 DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
@@ -503,25 +509,25 @@ Compute the hyperbolic cosine for each e
 
   return retval;
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [1, 0, -1, 0];
-%! assert(cosh (x), v, sqrt (eps));
+%! assert (cosh (x), v, sqrt (eps));
 
 %!test
-%! x = single([0, pi/2*i, pi*i, 3*pi/2*i]);
-%! v = single([1, 0, -1, 0]);
-%! assert(cosh (x), v, sqrt (eps ('single')));
+%! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
+%! v = single ([1, 0, -1, 0]);
+%! assert (cosh (x), v, sqrt (eps ('single')));
 
-%!error cosh ();
-%!error cosh (1, 2);
+%!error cosh ()
+%!error cosh (1, 2)
 */
 
 DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
 Compute the error function,\n\
 @tex\n\
 $$\n\
@@ -551,38 +557,41 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! a = -1i*sqrt(-1/(6.4187*6.4187));
-%! assert (erf(a), erf(real(a)));
+%! a = -1i*sqrt (-1/(6.4187*6.4187));
+%! assert (erf (a), erf (real (a)));
 
 %!test
-%! x=[0,.5,1];
-%! v=[0, .520499877813047, .842700792949715];
-%! assert(all(abs(erf(x)-v)<1.e-10) &&  all(abs(erf(-x)+v)<1.e-10) && all(abs(erfc(x)+v-1)<1.e-10) && all(abs(erfinv(v)-x)<1.e-10));
+%! x = [0,.5,1];
+%! v = [0, .520499877813047, .842700792949715];
+%! assert (all (abs (erf (x)-v) < 1.e-10));
+%! assert (all (abs (erf (-x)+v) < 1.e-10));
+%! assert (all (abs (erfc (x)+v-1) < 1.e-10));
+%! assert (all (abs (erfinv (v)-x) < 1.e-10));
 
 %!test
-%! a = -1i*sqrt(single (-1/(6.4187*6.4187)));
-%! assert (erf(a), erf(real(a)));
+%! a = -1i*sqrt (single (-1/(6.4187*6.4187)));
+%! assert (erf (a), erf (real (a)));
 
 %!test
-%! x=single ([0,.5,1]);
-%! v=single ([0, .520499877813047, .842700792949715]);
-%! assert(all(abs(erf(x)-v)<1.e-6) &&  all(abs(erf(-x)+v)<1.e-6) && all(abs(erfc(x)+v-1)<1.e-6) && all(abs(erfinv(v)-x)<1.e-6));
+%! x = single ([0,.5,1]);
+%! v = single ([0, .520499877813047, .842700792949715]);
+%! assert (all (abs (erf (x)-v) < 1.e-6));
+%! assert (all (abs (erf (-x)+v) < 1.e-6));
+%! assert (all (abs (erfc (x)+v-1) < 1.e-6));
+%! assert (all (abs (erfinv (v)-x) < 1.e-6));
 
-%% test/octave.test/arith/erf-2.m
-%!error erf();
-
-%% test/octave.test/arith/erf-3.m
-%!error erf(1,2);
+%!error erf ()
+%!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
@@ -608,16 +617,19 @@ Compute the inverse error function, i.e.
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
 %!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), 1e-8)
 %% backward - loss of accuracy
 %!assert (erfinv (erf ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
 %!assert (erfinv (erf (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
 %% exceptional
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
+
+%!error erfinv ()
+%!error erfinv (1, 2)
 */
 
 DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Compute the complementary error function,\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
@@ -634,18 +646,21 @@ Compute the complementary error function
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! a = -1i*sqrt(-1/(6.4187*6.4187));
-%! assert (erfc(a), erfc(real(a)));
+%! a = -1i*sqrt (-1/(6.4187*6.4187));
+%! assert (erfc (a), erfc (real (a)));
+
+%!error erfc ()
+%!error erfc (1, 2)
 */
 
 DEFUN (erfcx, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfcx (@var{z})\n\
 Compute the scaled complementary error function,\n\
 @tex\n\
 $$\n\
@@ -666,16 +681,23 @@ exp (z^2) * erfc (x)\n\
   if (args.length () == 1)
     retval = args(0).erfcx ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%% FIXME: Need a test for erfcx
+
+%!error erfcx ()
+%!error erfcx (1, 2)
+*/
+
 DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute\n\
 @tex\n\
 $e^{x}$\n\
 @end tex\n\
 @ifnottex\n\
@@ -691,26 +713,26 @@ exponential, see @ref{Linear Algebra}.\n
     retval = args(0).exp ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps));
-%!assert(exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps));
-%!assert(exp (single([0, 1, -1, -1000])), single([1, e, 1/e, 0]), sqrt (eps('single')));
-%!assert(exp (single(1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps('single')));
+%!assert (exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps))
+%!assert (exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps))
+%!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ('single')))
+%!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ('single')))
 
-%!error exp ();
-%!error exp (1, 2);
+%!assert (exp ([Inf, -Inf, NaN]), [Inf 0 NaN])
+%!assert (exp (single ([Inf, -Inf, NaN])), single ([Inf 0 NaN]))
 
-%!assert(exp (Inf) == Inf && exp (-Inf) == 0 && isnan (exp (NaN)));
-%!assert(exp (Inf ('single')) == Inf('single') && exp (-Inf('single')) == 0 && isnan (exp (NaN('single'))));
+%!error exp ()
+%!error exp (1, 2)
 */
 
 DEFUN (expm1, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} expm1 (@var{x})\n\
 Compute\n\
 @tex\n\
 $ e^{x} - 1 $\n\
@@ -726,16 +748,26 @@ accurately in the neighborhood of zero.\
   if (args.length () == 1)
     retval = args(0).expm1 ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (expm1 (2*eps), 2*eps, 1e-29)
+
+%!assert (expm1 ([Inf, -Inf, NaN]), [Inf -1 NaN])
+%!assert (expm1 (single ([Inf, -Inf, NaN])), single ([Inf -1 NaN]))
+
+%!error expm1 ()
+%!error expm1 (1, 2)
+*/
+
 DEFUN (isfinite, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} isfinite (@var{x})\n\
 @deftypefnx {Mapping Function} {} finite (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 finite values and false where they are not.\n\
 For example:\n\
 \n\
@@ -753,23 +785,26 @@ finite ([13, Inf, NA, NaN])\n\
     retval = args(0).finite ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(!(finite (Inf)));
-%!assert(!(finite (NaN)));
-%!assert(finite (rand(1,10)));
+%!assert (!finite (Inf))
+%!assert (!finite (NaN))
+%!assert (finite (rand (1,10)))
 
-%!assert(!(finite (single(Inf))));
-%!assert(!(finite (single(NaN))));
-%!assert(finite (single(rand(1,10))));
+%!assert (!finite (single (Inf)))
+%!assert (!finite (single (NaN)))
+%!assert (finite (single (rand (1,10))))
+
+%!error finite ()
+%!error finite (1, 2)
 */
 
 DEFUN (fix, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.  This\n\
 is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
@@ -788,23 +823,23 @@ fix ([-2.7, 2.7])\n\
     retval = args(0).fix ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(fix ([1.1, 1, -1.1, -1]), [1, 1, -1, -1]);
-%!assert(fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]), [1+i, 1+i, -1-i, -1-i]);
-%!assert(fix (single([1.1, 1, -1.1, -1])), single([1, 1, -1, -1]));
-%!assert(fix (single([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single([1+i, 1+i, -1-i, -1-i]));
+%!assert (fix ([1.1, 1, -1.1, -1]), [1, 1, -1, -1])
+%!assert (fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]), [1+i, 1+i, -1-i, -1-i])
+%!assert (fix (single ([1.1, 1, -1.1, -1])), single ([1, 1, -1, -1]))
+%!assert (fix (single ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single ([1+i, 1+i, -1-i, -1-i]))
 
-%!error fix ();
-%!error fix (1, 2);
+%!error fix ()
+%!error fix (1, 2)
 */
 
 DEFUN (floor, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  This is equivalent to\n\
 rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
@@ -823,23 +858,23 @@ floor ([-2.7, 2.7])\n\
     retval = args(0).floor ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(floor ([2, 1.1, -1.1, -1]), [2, 1, -2, -1]);
-%!assert(floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 1+i, -2-2i, -1-i]);
-%!assert(floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]));
-%!assert(floor (single([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single([2+2i, 1+i, -2-2i, -1-i]));
+%!assert (floor ([2, 1.1, -1.1, -1]), [2, 1, -2, -1])
+%!assert (floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 1+i, -2-2i, -1-i])
+%!assert (floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]))
+%!assert (floor (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 1+i, -2-2i, -1-i]))
 
-%!error floor ();
-%!error floor (1, 2);
+%!error floor ()
+%!error floor (1, 2)
 */
 
 DEFUN (gamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gamma (@var{z})\n\
 Compute the Gamma function,\n\
 @tex\n\
 $$\n\
@@ -869,41 +904,41 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! a = -1i*sqrt(-1/(6.4187*6.4187));
-%! assert (gamma(a), gamma(real(a)));
+%! a = -1i*sqrt (-1/(6.4187*6.4187));
+%! assert (gamma (a), gamma (real (a)));
 
 %!test
 %! x = [.5, 1, 1.5, 2, 3, 4, 5];
 %! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert(gamma(x), v, sqrt(eps))
+%! assert (gamma (x), v, sqrt (eps));
 
 %!test
-%! a = single(-1i*sqrt(-1/(6.4187*6.4187)));
-%! assert (gamma(a), gamma(real(a)));
+%! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
+%! assert (gamma (a), gamma (real (a)));
 
 %!test
-%! x = single([.5, 1, 1.5, 2, 3, 4, 5]);
-%! v = single([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert(gamma(x), v, sqrt(eps('single')))
+%! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
+%! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
+%! assert (gamma (x), v, sqrt (eps ('single')));
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 1, Inf];
-%! assert (gamma(x), v);
-%! assert (gamma(single (x)), single (v));
+%! assert (gamma (x), v);
+%! assert (gamma (single (x)), single (v));
 
-%!error gamma();
-%!error gamma(1,2);
+%!error gamma ()
+%!error gamma (1, 2)
 */
 
 DEFUN (imag, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
@@ -913,28 +948,28 @@ Return the imaginary part of @var{z} as 
     retval = args(0).imag ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(imag (1), 0);
-%!assert(imag (i), 1);
-%!assert(imag (1+i), 1);
-%!assert(imag ([i, 1; 1, i]), full (eye (2)));
+%!assert (imag (1), 0)
+%!assert (imag (i), 1)
+%!assert (imag (1+i), 1)
+%!assert (imag ([i, 1; 1, i]), full (eye (2)))
 
-%!assert(imag (single(1)), single(0));
-%!assert(imag (single(i)), single(1));
-%!assert(imag (single(1+i)), single(1));
-%!assert(imag (single([i, 1; 1, i])), full (eye (2,'single')));
+%!assert (imag (single (1)), single (0))
+%!assert (imag (single (i)), single (1))
+%!assert (imag (single (1+i)), single (1))
+%!assert (imag (single ([i, 1; 1, i])), full (eye (2,'single')))
 
-%!error imag ();
-%!error imag (1, 2);
+%!error imag ()
+%!error imag (1, 2)
 */
 
 DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters or digits and false where they are not.  This is equivalent to\n\
 (@code{isalpha (@var{s}) | isdigit (@var{s})}).\n\
@@ -947,25 +982,25 @@ letters or digits and false where they a
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("A"):toascii("Z"))+1) = 1;
-%! result ((toascii("0"):toascii("9"))+1) = 1;
-%! result ((toascii("a"):toascii("z"))+1) = 1;
-%! assert(all (isalnum (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("A":"Z") + 1) = true;
+%! result(toascii ("0":"9") + 1) = true;
+%! result(toascii ("a":"z") + 1) = true;
+%! assert (all (isalnum (charset) == result));
 
-%!error isalnum (1, 2);
-%!error isalnum ();
+%!error isalnum ()
+%!error isalnum (1, 2)
 */
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters and false where they are not.  This is equivalent to\n\
 (@code{islower (@var{s}) | isupper (@var{s})}).\n\
@@ -978,24 +1013,24 @@ letters and false where they are not.  T
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("A"):toascii("Z"))+1) = 1;
-%! result ((toascii("a"):toascii("z"))+1) = 1;
-%! assert(all (isalpha (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("A":"Z") + 1) = true;
+%! result(toascii ("a":"z") + 1) = true;
+%! assert (all (isalpha (charset) == result));
 
-%!error isalpha (1, 2);
-%!error isalpha ();
+%!error isalpha ()
+%!error isalpha (1, 2)
 */
 
 DEFUNX ("isascii", Fisascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 ASCII characters (in the range 0 to 127 decimal) and false where they are\n\
 not.\n\
@@ -1007,22 +1042,22 @@ not.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = ones (1, 128);
-%! assert(all (isascii (charset) == result));
+%! charset = char (0:127);
+%! result = true (1, 128);
+%! assert (all (isascii (charset) == result));
 
-%!error isascii (1, 2);
-%!error isascii ();
+%!error isascii ()
+%!error isascii (1, 2)
 */
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 control characters and false where they are not.\n\
 @seealso{ispunct, isspace, isalpha, isdigit}\n\
@@ -1033,26 +1068,25 @@ control characters and false where they 
     retval = args(0).xiscntrl ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% test/octave.test/string/iscntrl-1.m
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result (1:32) = 1;
-%! result (128) = 1;
-%! assert(all (iscntrl (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(1:32) = true;
+%! result(128) = true;
+%! assert (all (iscntrl (charset) == result));
 
-%!error iscntrl (1, 2);
-%!error iscntrl ();
+%!error iscntrl ()
+%!error iscntrl (1, 2)
 */
 
 DEFUNX ("isdigit", Fisdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 decimal digits (0-9) and false where they are not.\n\
 @seealso{isxdigit, isalpha, isletter, ispunct, isspace, iscntrl}\n\
@@ -1064,23 +1098,23 @@ decimal digits (0-9) and false where the
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("0"):toascii("9"))+1) = 1;
-%! assert(all (isdigit (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("0":"9") + 1) = true;
+%! assert (all (isdigit (charset) == result));
 
-%!error isdigit (1, 2);
-%!error isdigit ();
+%!error isdigit ()
+%!error isdigit (1, 2)
 */
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 are infinite and false where they are not.\n\
 For example:\n\
@@ -1099,27 +1133,30 @@ isinf ([13, Inf, NA, NaN])\n\
     retval = args(0).isinf ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(isinf (Inf));
-%!assert(!isinf (NaN));
-%!assert(!(isinf (NA)));
-%!assert(isinf (rand(1,10)), false(1,10));
-%!assert(isinf([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false]);
+%!assert (isinf (Inf))
+%!assert (!isinf (NaN))
+%!assert (!isinf (NA))
+%!assert (isinf (rand(1,10)), false (1,10))
+%!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
 
-%!assert(isinf (single(Inf)));
-%!assert(!(isinf (single(NaN))));
-%!assert(!(isinf (single(NA))));
-%!assert(isinf (single(rand(1,10))), false(1,10));
-%!assert(isinf(single([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false]);
+%!assert (isinf (single (Inf)))
+%!assert (!isinf (single (NaN)))
+%!assert (!isinf (single (NA)))
+%!assert (isinf (single (rand(1,10))), false (1,10))
+%!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
+
+%!error isinf ()
+%!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (but not the space character) and false where they are\n\
 not.\n\
@@ -1132,23 +1169,23 @@ not.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result (34:127) = 1;
-%! assert(all (isgraph (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(34:127) = true;
+%! assert (all (isgraph (charset) == result));
 
-%!error isgraph (1, 2);
-%!error isgraph ();
+%!error isgraph ()
+%!error isgraph (1, 2)
 */
 
 DEFUNX ("islower", Fislower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 lowercase letters and false where they are not.\n\
 @seealso{isupper, isalpha, isletter, isalnum}\n\
@@ -1160,23 +1197,23 @@ lowercase letters and false where they a
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("a"):toascii("z"))+1) = 1;
-%! assert(all (islower (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("a":"z") + 1) = true;
+%! assert (all (islower (charset) == result));
 
-%!error islower (1, 2);
-%!error islower ();
+%!error islower ()
+%!error islower (1, 2)
 */
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NA (missing) values and false where they are not.\n\
 For example:\n\
@@ -1195,27 +1232,30 @@ isna ([13, Inf, NA, NaN])\n\
     retval = args(0).isna ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(!(isna (Inf)));
-%!assert(!isna (NaN));
-%!assert(isna (NA));
-%!assert(isna (rand(1,10)), false(1,10));
-%!assert(isna([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true]);
+%!assert (!isna (Inf))
+%!assert (!isna (NaN))
+%!assert (isna (NA))
+%!assert (isna (rand(1,10)), false (1,10))
+%!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
 
-%!assert(!(isna (single(Inf))));
-%!assert(!isna (single(NaN)));
-%!assert(isna (single(NA)));
-%!assert(isna (single(rand(1,10))), false(1,10));
-%!assert(isna(single([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true]);
+%!assert (!isna (single (Inf)))
+%!assert (!isna (single (NaN)))
+%!assert (isna (single (NA)))
+%!assert (isna (single (rand(1,10))), false (1,10))
+%!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
+
+%!error isna ()
+%!error isna (1, 2)
 */
 
 DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NaN values and false where they are not.\n\
 NA values are also considered NaN values.  For example:\n\
@@ -1234,27 +1274,30 @@ isnan ([13, Inf, NA, NaN])\n\
     retval = args(0).isnan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(!(isnan (Inf)));
-%!assert(isnan (NaN));
-%!assert(isnan (NA));
-%!assert(isnan (rand(1,10)), false(1,10));
-%!assert(isnan([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true]);
+%!assert (!isnan (Inf))
+%!assert (isnan (NaN))
+%!assert (isnan (NA))
+%!assert (isnan (rand(1,10)), false (1,10))
+%!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
 
-%!assert(!(isnan (single(Inf))));
-%!assert(isnan (single(NaN)));
-%!assert(isnan (single(NA)));
-%!assert(isnan (single(rand(1,10))), false(1,10));
-%!assert(isnan(single([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true]);
+%!assert (!isnan (single (Inf)))
+%!assert (isnan (single (NaN)))
+%!assert (isnan (single (NA)))
+%!assert (isnan (single (rand(1,10))), false (1,10))
+%!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
+
+%!error isnan ()
+%!error isnan (1, 2)
 */
 
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (including the space character) and false where they\n\
 are not.\n\
@@ -1267,26 +1310,23 @@ are not.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result (33:127) = 1;
-%! if (ispc () && ! isunix ())
-%!   result(10) = 1;
-%! endif
-%! assert(all (isprint (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(33:127) = true;
+%! assert (all (isprint (charset) == result));
 
-%!error isprint (1, 2);
-%!error isprint ();
+%!error isprint ()
+%!error isprint (1, 2)
 */
 
 DEFUNX ("ispunct", Fispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 punctuation characters and false where they are not.\n\
 @seealso{isalpha, isdigit, isspace, iscntrl}\n\
@@ -1298,26 +1338,26 @@ punctuation characters and false where t
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result (34:48) = 1;
-%! result (59:65) = 1;
-%! result (92:97) = 1;
-%! result (124:127) = 1;
-%! assert(all (ispunct (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(34:48) = true;
+%! result(59:65) = true;
+%! result(92:97) = true;
+%! result(124:127) = true;
+%! assert (all (ispunct (charset) == result));
 
-%!error ispunct (1, 2);
-%!error ispunct ();
+%!error ispunct ()
+%!error ispunct (1, 2)
 */
 
 DEFUNX ("isspace", Fisspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 whitespace characters (space, formfeed, newline, carriage return, tab, and\n\
 vertical tab) and false where they are not.\n\
@@ -1330,23 +1370,23 @@ vertical tab) and false where they are n
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result (toascii (" \f\n\r\t\v")+1) = 1;
-%! assert(all (isspace (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii (" \f\n\r\t\v") + 1) = true;
+%! assert (all (isspace (charset) == result));
 
-%!error isspace (1, 2);
-%!error isspace ();
+%!error isspace ()
+%!error isspace (1, 2)
 */
 
 DEFUNX ("isupper", Fisupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 uppercase letters and false where they are not.\n\
 @seealso{islower, isalpha, isletter, isalnum}\n\
@@ -1358,23 +1398,23 @@ uppercase letters and false where they a
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("A"):toascii("Z"))+1) = 1;
-%! assert(all (isupper (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("A":"Z") + 1) = true;
+%! assert (all (isupper (charset) == result));
 
-%!error isupper (1, 2);
-%!error isupper ();
+%!error isupper ()
+%!error isupper (1, 2)
 */
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 hexadecimal digits (0-9 and @nospell{a-fA-F}).\n\
 @seealso{isdigit}\n\
@@ -1386,25 +1426,25 @@ hexadecimal digits (0-9 and @nospell{a-f
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! charset = setstr (0:127);
-%! result = zeros (1, 128);
-%! result ((toascii("A"):toascii("F"))+1) = 1;
-%! result ((toascii("0"):toascii("9"))+1) = 1;
-%! result ((toascii("a"):toascii("f"))+1) = 1;
-%! assert(all (isxdigit (charset) == result));
+%! charset = char (0:127);
+%! result = false (1, 128);
+%! result(toascii ("A":"F") + 1) = true;
+%! result(toascii ("0":"9") + 1) = true;
+%! result(toascii ("a":"f") + 1) = true;
+%! assert (all (isxdigit (charset) == result));
 
-%!error isxdigit (1, 2);
-%!error isxdigit ();
+%!error isxdigit ()
+%!error isxdigit (1, 2)
 */
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
@@ -1416,41 +1456,41 @@ Return the natural logarithm of the gamm
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! a = -1i*sqrt(-1/(6.4187*6.4187));
+%! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (lgamma(a), lgamma(real(a)));
 
 %!test
 %! x = [.5, 1, 1.5, 2, 3, 4, 5];
 %! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert(lgamma(x), log(v), sqrt(eps))
+%! assert (lgamma(x), log(v), sqrt (eps))
 
 %!test
-%! a = single(-1i*sqrt(-1/(6.4187*6.4187)));
+%! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
 %! assert (lgamma(a), lgamma(real(a)));
 
 %!test
-%! x = single([.5, 1, 1.5, 2, 3, 4, 5]);
-%! v = single([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert(lgamma(x), log(v), sqrt(eps ('single')))
+%! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
+%! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
+%! assert (lgamma(x), log(v), sqrt (eps ('single')))
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 0, Inf];
 %! assert (lgamma(x), v);
-%! assert (lgamma(single (x)), single(v));
+%! assert (lgamma(single (x)), single (v));
 
-%!error lgamma();
-%!error lgamma(1,2);
+%!error lgamma()
+%!error lgamma(1,2)
 */
 
 DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm,\n\
 @tex\n\
 $\\ln{(x)},$\n\
@@ -1468,24 +1508,24 @@ matrix logarithm, see @ref{Linear Algebr
     retval = args(0).log ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(log ([1, e, e^2]), [0, 1, 2], sqrt (eps));
-%!assert(log ([-0.5, -1.5, -2.5]), log([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps));
+%!assert (log ([1, e, e^2]), [0, 1, 2], sqrt (eps))
+%!assert (log ([-0.5, -1.5, -2.5]), log([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
 
-%!assert(log (single([1, e, e^2])), single([0, 1, 2]), sqrt (eps('single')));
-%!assert(log (single([-0.5, -1.5, -2.5])), single(log([0.5, 1.5, 2.5]) + pi*1i), 4*eps('single'));
+%!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ('single')))
+%!assert (log (single ([-0.5, -1.5, -2.5])), single (log([0.5, 1.5, 2.5]) + pi*1i), 4*eps ('single'))
 
-%!error log ();
-%!error log (1, 2);
+%!error log ()
+%!error log (1, 2)
 */
 
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
@@ -1495,21 +1535,21 @@ Compute the base-10 logarithm of each el
     retval = args(0).log10 ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps));
-%!assert(log10 (single([0.01, 0.1, 1, 10, 100])), single([-2, -1, 0, 1, 2]), sqrt (eps ('single')));
+%!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
+%!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ('single')))
 
-%!error log10 ();
-%!error log10 (1, 2);
+%!error log10 ()
+%!error log10 (1, 2)
 */
 
 DEFUN (log1p, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
 Compute\n\
 @tex\n\
 $\\ln{(1 + x)}$\n\
@@ -1525,16 +1565,24 @@ accurately in the neighborhood of zero.\
   if (args.length () == 1)
     retval = args(0).log1p ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
+%!assert (log1p (single ([0, 2*eps, -2*eps])), single([0, 2*eps, -2*eps]), 1e-29)
+
+%!error log1p ()
+%!error log1p (1, 2)
+*/
+
 DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1542,28 +1590,28 @@ Return the real part of @var{z}.\n\
     retval = args(0).real ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(real (1), 1);
-%!assert(real (i), 0);
-%!assert(real (1+i), 1);
-%!assert(real ([1, i; i, 1]), full (eye (2)));
+%!assert (real (1), 1)
+%!assert (real (i), 0)
+%!assert (real (1+i), 1)
+%!assert (real ([1, i; i, 1]), full (eye (2)))
 
-%!assert(real (single(1)), single(1));
-%!assert(real (single(i)), single(0));
-%!assert(real (single(1+i)), single(1));
-%!assert(real (single([1, i; i, 1])), full (eye (2,'single')));
+%!assert (real (single (1)), single (1))
+%!assert (real (single (i)), single (0))
+%!assert (real (single (1+i)), single (1))
+%!assert (real (single ([1, i; i, 1])), full (eye (2,'single')))
 
-%!error real ();
-%!error real (1, 2);
+%!error real ()
+%!error real (1, 2)
 */
 
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.  If there\n\
 are two nearest integers, return the one further away from zero.\n\
@@ -1582,34 +1630,34 @@ round ([-2.7, 2.7])\n\
     retval = args(0).round ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(round (1), 1);
-%!assert(round (1.1), 1);
-%!assert(round (5.5), 6);
-%!assert(round (i), i);
-%!assert(round (2.5+3.5i), 3+4i);
-%!assert(round (-2.6), -3);
-%!assert(round ([1.1, -2.4; -3.7, 7.1]), [1, -2; -4, 7]);
+%!assert (round (1), 1)
+%!assert (round (1.1), 1)
+%!assert (round (5.5), 6)
+%!assert (round (i), i)
+%!assert (round (2.5+3.5i), 3+4i)
+%!assert (round (-2.6), -3)
+%!assert (round ([1.1, -2.4; -3.7, 7.1]), [1, -2; -4, 7])
 
-%!assert(round (single(1)), single(1));
-%!assert(round (single(1.1)), single(1));
-%!assert(round (single(5.5)), single(6));
-%!assert(round (single(i)), single(i));
-%!assert(round (single(2.5+3.5i)), single(3+4i));
-%!assert(round (single(-2.6)), single(-3));
-%!assert(round (single([1.1, -2.4; -3.7, 7.1])), single([1, -2; -4, 7]));
+%!assert (round (single (1)), single (1))
+%!assert (round (single (1.1)), single (1))
+%!assert (round (single (5.5)), single (6))
+%!assert (round (single (i)), single (i))
+%!assert (round (single (2.5+3.5i)), single (3+4i))
+%!assert (round (single (-2.6)), single (-3))
+%!assert (round (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
 
-%!error round ();
-%!error round (1, 2);
+%!error round ()
+%!error round (1, 2)
 */
 
 DEFUN (roundb, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} roundb (@var{x})\n\
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
@@ -1620,16 +1668,39 @@ return @code{roundb (real (@var{x})) + r
   if (args.length () == 1)
     retval = args(0).roundb ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (roundb (1), 1)
+%!assert (roundb (1.1), 1)
+%!assert (roundb (1.5), 2)
+%!assert (roundb (4.5), 4)
+%!assert (roundb (i), i)
+%!assert (roundb (2.5+3.5i), 2+4i)
+%!assert (roundb (-2.6), -3)
+%!assert (roundb ([1.1, -2.4; -3.7, 7.1]), [1, -2; -4, 7])
+
+%!assert (roundb (single (1)), single (1))
+%!assert (roundb (single (1.1)), single (1))
+%!assert (roundb (single (1.5)), single (2))
+%!assert (roundb (single (4.5)), single (4))
+%!assert (roundb (single (i)), single (i))
+%!assert (roundb (single (2.5+3.5i)), single (2+4i))
+%!assert (roundb (single (-2.6)), single (-3))
+%!assert (roundb (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
+
+%!error roundb ()
+%!error roundb (1, 2)
+*/
+
 DEFUN (sign, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sign (@var{x})\n\
 Compute the @dfn{signum} function, which is defined as\n\
 @tex\n\
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
@@ -1654,28 +1725,28 @@ For complex arguments, @code{sign} retur
     retval = args(0).signum ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(sign (-2) , -1);
-%!assert(sign (3), 1);
-%!assert(sign (0), 0);
-%!assert(sign ([1, -pi; e, 0]), [1, -1; 1, 0]);
+%!assert (sign (-2) , -1)
+%!assert (sign (0), 0)
+%!assert (sign (3), 1)
+%!assert (sign ([1, -pi; e, 0]), [1, -1; 1, 0])
 
-%!assert(sign (single(-2)) , single(-1));
-%!assert(sign (single(3)), single(1));
-%!assert(sign (single(0)), single(0));
-%!assert(sign (single([1, -pi; e, 0])), single([1, -1; 1, 0]));
+%!assert (sign (single (-2)) , single (-1))
+%!assert (sign (single (0)), single (0))
+%!assert (sign (single (3)), single (1))
+%!assert (sign (single ([1, -pi; e, 0])), single ([1, -1; 1, 0]))
 
-%!error sign ();
-%!error sign (1, 2);
+%!error sign ()
+%!error sign (1, 2)
 */
 
 DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
@@ -1685,32 +1756,32 @@ Compute the sine for each element of @va
     retval = args(0).sin ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
-%! assert(sin (x), v, sqrt (eps));
 
 %!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! x = single([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
-%! v = single([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
-%! assert(sin (x), v, sqrt (eps('single')));
+%! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
+%! assert (sin (x), v, sqrt (eps));
 
-%!error sin ();
-%!error sin (1, 2);
+%!test
+%! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single ([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
+%! assert (sin (x), v, sqrt (eps ('single')));
+
+%!error sin ()
+%!error sin (1, 2)
 */
 
 DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
@@ -1723,25 +1794,25 @@ Compute the hyperbolic sine for each ele
 
   return retval;
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [0, i, 0, -i];
-%! assert(sinh (x), v, sqrt (eps));
+%! assert (sinh (x), v, sqrt (eps));
 
 %!test
-%! x = single([0, pi/2*i, pi*i, 3*pi/2*i]);
-%! v = single([0, i, 0, -i]);
-%! assert(sinh (x), v, sqrt (eps('single')));
+%! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
+%! v = single ([0, i, 0, -i]);
+%! assert (sinh (x), v, sqrt (eps ('single')));
 
-%!error sinh ();
-%!error sinh (1, 2);
+%!error sinh ()
+%!error sinh (1, 2)
 */
 
 DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of each element of @var{x}.  If @var{x} is negative,\n\
 a complex result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
@@ -1753,28 +1824,28 @@ a complex result is returned.  To comput
     retval = args(0).sqrt ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(sqrt (4), 2)
-%!assert(sqrt (-1), i)
-%!assert(sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps));
-%!assert(sqrt([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt(eps));
+%!assert (sqrt (4), 2)
+%!assert (sqrt (-1), i)
+%!assert (sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps))
+%!assert (sqrt ([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt (eps))
 
-%!assert(sqrt (single(4)), single(2))
-%!assert(sqrt (single(-1)), single(i))
-%!assert(sqrt (single(1+i)), single(exp (0.5 * log (1+i))), sqrt (eps('single')));
-%!assert(sqrt(single([4, -4; i, 1-i])), single([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt(eps('single')));
+%!assert (sqrt (single (4)), single (2))
+%!assert (sqrt (single (-1)), single (i))
+%!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ('single')))
+%!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ('single')))
 
-%!error sqrt ();
-%!error sqrt (1, 2);
+%!error sqrt ()
+%!error sqrt (1, 2)
 */
 
 DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
@@ -1784,32 +1855,32 @@ Compute the tangent for each element of 
     retval = args(0).tan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!test
+%!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
-%! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
-%! assert(tan (x), v,  sqrt (eps));
 
 %!test
-%! rt2 = sqrt (2);
-%! rt3 = sqrt (3);
-%! x = single([0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
-%! v = single([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert(tan (x), v,  sqrt (eps('single')));
+%! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
+%! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
+%! assert (tan (x), v,  sqrt (eps));
 
-%!error tan ();
-%!error tan (1, 2);
+%!test
+%! x = single ([0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
+%! v = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
+%! assert (tan (x), v,  sqrt (eps ('single')));
+
+%!error tan ()
+%!error tan (1, 2)
 */
 
 DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
@@ -1822,25 +1893,25 @@ Compute hyperbolic tangent for each elem
 
   return retval;
 }
 
 /*
 %!test
 %! x = [0, pi*i];
 %! v = [0, 0];
-%! assert(tanh (x), v, sqrt (eps));
+%! assert (tanh (x), v, sqrt (eps));
 
 %!test
-%! x = single([0, pi*i]);
-%! v = single([0, 0]);
-%! assert(tanh (x), v, sqrt (eps('single')));
+%! x = single ([0, pi*i]);
+%! v = single ([0, 0]);
+%! assert (tanh (x), v, sqrt (eps ('single')));
 
-%!error tanh ();
-%!error tanh (1, 2);
+%!error tanh ()
+%!error tanh (1, 2)
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
 Return ASCII representation of @var{s} in a matrix.  For example:\n\
 \n\
 @example\n\
@@ -1858,24 +1929,25 @@ toascii (\"ASCII\")\n\
     retval = args(0).xtoascii ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(toascii (char (0:127)), 0:127);
-%!assert(toascii (" ":"@"), 32:64);
-%!assert(toascii ("A":"Z"), 65:90);
-%!assert(toascii ("[":"`"), 91:96);
-%!assert(toascii ("a":"z"), 97:122);
-%!assert(toascii ("{":"~"), 123:126);
-%!error toascii (1, 2);
-%!error toascii (1, 2);
+%!assert (toascii (char (0:127)), 0:127)
+%!assert (toascii (" ":"@"), 32:64)
+%!assert (toascii ("A":"Z"), 65:90)
+%!assert (toascii ("[":"`"), 91:96)
+%!assert (toascii ("a":"z"), 97:122)
+%!assert (toascii ("{":"~"), 123:126)
+
+%!error toascii ()
+%!error toascii (1, 2)
 */
 
 DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} tolower (@var{s})\n\
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each uppercase\n\
 character replaced by the corresponding lowercase one; non-alphabetic\n\
@@ -1897,36 +1969,36 @@ tolower (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
 /*
-%!error <Invalid call to tolower> tolower();
-%!error <Invalid call to tolower> lower();
-%!error tolower (1, 2);
-%!assert(tolower("OCTAVE"), "octave");
-%!assert(tolower("123OCTave!_&"), "123octave!_&");
-%!assert(tolower({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}});
-%!assert(tolower(["ABC"; "DEF"]), ["abc"; "def"]);
-%!assert(tolower({["ABC"; "DEF"]}), {["abc";"def"]});
-%!assert(tolower(68), "d");
-%!assert(tolower({[68, 68; 68, 68]}), {["dd";"dd"]});
+%!assert (tolower("OCTAVE"), "octave")
+%!assert (tolower("123OCTave!_&"), "123octave!_&")
+%!assert (tolower({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
+%!assert (tolower(["ABC"; "DEF"]), ["abc"; "def"])
+%!assert (tolower({["ABC"; "DEF"]}), {["abc";"def"]})
+%!assert (tolower(68), "d")
+%!assert (tolower({[68, 68; 68, 68]}), {["dd";"dd"]})
 %!test
 %!  a(3,3,3,3) = "D";
 %!  assert(tolower(a)(3,3,3,3), "d");
 
 %!test
-%! charset = setstr (0:127);
+%! charset = char (0:127);
 %! result = charset;
-%! result ((toascii("A"):toascii("Z"))+1) \
-%! = result ((toascii("a"):toascii("z"))+1);
-%! assert(all (tolower (charset) == result));
+%! result(toascii ("A":"Z") + 1) = result(toascii ("a":"z") + 1);
+%! assert (all (tolower (charset) == result));
+
+%!error <Invalid call to tolower> tolower()
+%!error <Invalid call to tolower> lower()
+%!error tolower (1, 2)
 */
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} toupper (@var{s})\n\
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
 character replaced by the corresponding uppercase one; non-alphabetic\n\
@@ -1948,32 +2020,32 @@ toupper (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (upper, toupper);
 
 /*
-%!error <Invalid call to toupper> toupper();
-%!error <Invalid call to toupper> upper();
-%!error toupper (1, 2);
-%!assert(toupper("octave"), "OCTAVE");
-%!assert(toupper("123OCTave!_&"), "123OCTAVE!_&");
-%!assert(toupper({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}});
-%!assert(toupper(["abc"; "def"]), ["ABC"; "DEF"]);
-%!assert(toupper({["abc"; "def"]}), {["ABC";"DEF"]});
-%!assert(toupper(100), "D");
-%!assert(toupper({[100, 100; 100, 100]}), {["DD";"DD"]});
+%!assert (toupper ("octave"), "OCTAVE")
+%!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
+%!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
+%!assert (toupper (["abc"; "def"]), ["ABC"; "DEF"])
+%!assert (toupper ({["abc"; "def"]}), {["ABC";"DEF"]})
+%!assert (toupper (100), "D")
+%!assert (toupper ({[100, 100; 100, 100]}), {["DD";"DD"]})
 %!test
 %!  a(3,3,3,3) = "d";
-%!  assert(toupper(a)(3,3,3,3), "D");
+%!  assert(toupper (a)(3,3,3,3), "D");
 %!test
-%! charset = setstr (0:127);
+%! charset = char (0:127);
 %! result = charset;
-%! result ((toascii("a"):toascii("z"))+1) \
-%! = result ((toascii("A"):toascii("Z"))+1);
-%! assert(all (toupper (charset) == result));
+%! result(toascii  ("a":"z") + 1) = result(toascii  ("A":"Z") + 1);
+%! assert (all (toupper (charset) == result));
+
+%!error <Invalid call to toupper> toupper()
+%!error <Invalid call to toupper> upper()
+%!error toupper (1, 2)
 */
 
 DEFALIAS (gammaln, lgamma);
 
 DEFALIAS (finite, isfinite);
diff --git a/src/matherr.c b/src/matherr.c
--- a/src/matherr.c
+++ b/src/matherr.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1997-2011 John W. Eaton
+Copyright (C) 1997-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 John W. Eaton
+Copyright (C) 2006-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mex.h b/src/mex.h
--- a/src/mex.h
+++ b/src/mex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Paul Kienzle
+Copyright (C) 2001-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mexproto.h b/src/mexproto.h
--- a/src/mexproto.h
+++ b/src/mexproto.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2006-2011 Paul Kienzle
+Copyright (C) 2006-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mk-errno-list b/src/mk-errno-list
--- a/src/mk-errno-list
+++ b/src/mk-errno-list
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 2005-2011 John W. Eaton
+# Copyright (C) 2005-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mk-pkg-add b/src/mk-pkg-add
--- a/src/mk-pkg-add
+++ b/src/mk-pkg-add
@@ -1,11 +1,11 @@
 #! /bin/sh -e
 #
-# Copyright (C) 2005-2011 John W. Eaton
+# Copyright (C) 2005-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkdefs b/src/mkdefs
--- a/src/mkdefs
+++ b/src/mkdefs
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1996-2011 John W. Eaton
+# Copyright (C) 1996-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkdocs b/src/mkdocs
--- a/src/mkdocs
+++ b/src/mkdocs
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1999-2011 John W. Eaton
+# Copyright (C) 1999-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mkoctfile.cc.in b/src/mkoctfile.cc.in
old mode 100755
new mode 100644
--- a/src/mkoctfile.cc.in
+++ b/src/mkoctfile.cc.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/mkoctfile.in b/src/mkoctfile.in
--- a/src/mkoctfile.in
+++ b/src/mkoctfile.in
@@ -1,14 +1,14 @@
 #! /bin/sh
 ##
 ## mkoctfile -- create a .oct file suitable for dynamic linking by
 ## Octave.
 ##
-## Copyright (C) 1996-2011 John W. Eaton
+## Copyright (C) 1996-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/src/mkops b/src/mkops
--- a/src/mkops
+++ b/src/mkops
@@ -1,11 +1,11 @@
 #! /bin/sh
 #
-# Copyright (C) 1997-2011 John W. Eaton
+# Copyright (C) 1997-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
diff --git a/src/mxarray.h.in b/src/mxarray.h.in
--- a/src/mxarray.h.in
+++ b/src/mxarray.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Paul Kienzle
+Copyright (C) 2001-2012 Paul Kienzle
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-conf.h.in b/src/oct-conf.h.in
--- a/src/oct-conf.h.in
+++ b/src/oct-conf.h.in
@@ -1,12 +1,12 @@
 // oct-conf.h.in
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -55,16 +55,28 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_ARFLAGS
 #define OCTAVE_CONF_ARFLAGS %OCTAVE_CONF_ARFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_AR
 #define OCTAVE_CONF_AR %OCTAVE_CONF_AR%
 #endif
 
+#ifndef OCTAVE_CONF_ARPACK_CPPFLAGS
+#define OCTAVE_CONF_ARPACK_CPPFLAGS %OCTAVE_CONF_ARPACK_CPPFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_ARPACK_LDFLAGS
+#define OCTAVE_CONF_ARPACK_LDFLAGS %OCTAVE_CONF_ARPACK_LDFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_ARPACK_LIBS
+#define OCTAVE_CONF_ARPACK_LIBS %OCTAVE_CONF_ARPACK_LIBS%
+#endif
+
 #ifndef OCTAVE_CONF_BLAS_LIBS
 #define OCTAVE_CONF_BLAS_LIBS %OCTAVE_CONF_BLAS_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_CAMD_CPPFLAGS
 #define OCTAVE_CONF_CAMD_CPPFLAGS %OCTAVE_CONF_CAMD_CPPFLAGS%
 #endif
 
diff --git a/src/oct-errno.cc.in b/src/oct-errno.cc.in
--- a/src/oct-errno.cc.in
+++ b/src/oct-errno.cc.in
@@ -1,12 +1,12 @@
 // oct-errno.cc.in
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -22,16 +22,18 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cerrno>
 
+#include "singleton-cleanup.h"
+
 #include "oct-errno.h"
 #include "oct-map.h"
 #include "error.h"
 
 octave_errno *octave_errno::instance = 0;
 
 octave_errno::octave_errno (void)
 {
@@ -287,17 +289,22 @@ octave_errno::octave_errno (void)
 }
 
 bool
 octave_errno::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_errno ();
+    {
+      instance = new octave_errno ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create errno object!");
 
       retval = false;
     }
 
diff --git a/src/oct-errno.h b/src/oct-errno.h
--- a/src/oct-errno.h
+++ b/src/oct-errno.h
@@ -1,12 +1,12 @@
 // oct-errno.h.in
 /*
 
-Copyright (C) 2005-2011 John W. Eaton
+Copyright (C) 2005-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -38,16 +38,18 @@ protected:
   octave_errno (void);
 
 public:
 
   ~octave_errno (void) { }
 
   static bool instance_ok (void);
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static int lookup (const std::string& name);
 
   static octave_scalar_map list (void);
 
   static int get (void) { return errno; }
 
   static int set (int val)
   {
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-fstrm.h b/src/oct-fstrm.h
--- a/src/oct-fstrm.h
+++ b/src/oct-fstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-hdf5.h b/src/oct-hdf5.h
--- a/src/oct-hdf5.h
+++ b/src/oct-hdf5.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -729,36 +729,46 @@ variable @w{@env{OCTAVE_HISTFILE}}.\n\
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} history_timestamp_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format string\n\
 for the comment line that is written to the history file when Octave\n\
 exits.  The format string is passed to @code{strftime}.  The default\n\
 value is\n\
 \n\
 @example\n\
 \"# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end example\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{strftime, history_file, history_size, saving_history}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
 }
 
 DEFUN (saving_history, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} saving_history ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} saving_history (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} saving_history (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{history_control, history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
 {
   bool old_saving_history = ! command_history::ignoring_entries ();
 
   bool tmp = old_saving_history;
 
   octave_value retval = set_internal_variable (tmp, args, nargout,
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-iostrm.cc b/src/oct-iostrm.cc
--- a/src/oct-iostrm.cc
+++ b/src/oct-iostrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -750,24 +750,29 @@ octave_map::cat (int dim, octave_idx_typ
             {
               retval.xkeys = map_list[idx].xkeys;
               break;
             }
         }
 
       // Try the fast case.
       bool all_same = true;
-      for (octave_idx_type i = 0; i < n; i++)
+
+      if (nf > 0)
         {
-          all_same = map_list[idx].xkeys.is_same (map_list[i].xkeys);
-          if (! all_same)
-            break;
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              all_same = map_list[idx].xkeys.is_same (map_list[i].xkeys);
+
+              if (! all_same)
+                break;
+            }
         }
 
-      if (all_same)
+      if (all_same && nf > 0)
         do_cat (dim, n, map_list, retval);
       else
         {
           if (nf > 0)
             {
               // permute all structures to correct order.
               OCTAVE_LOCAL_BUFFER (octave_map, new_map_list, n);
 
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -48,18 +48,18 @@ octave_fields
   private:
     fields_rep& operator = (const fields_rep&); // no assignment!
   };
 
   fields_rep *rep;
 
   static fields_rep *nil_rep (void)
     {
-      static fields_rep *nr = new fields_rep ();
-      return nr;
+      static fields_rep nr;
+      return &nr;
     }
 
 public:
 
   octave_fields (void) : rep (nil_rep ()) { rep->count++; }
   octave_fields (const string_vector&);
   octave_fields (const char * const *);
 
@@ -68,18 +68,22 @@ public:
       if (--rep->count == 0)
         delete rep;
     }
 
   void make_unique (void)
     {
       if (rep->count > 1)
         {
-          --rep->count;
-          rep = new fields_rep (*rep);
+          fields_rep *r = new fields_rep (*rep);
+
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = r;
         }
     }
 
   octave_fields (const octave_fields& o) : rep (o.rep) { rep->count++; }
 
   octave_fields&
   operator = (const octave_fields& o)
     {
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 David Grundberg
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -1894,18 +1894,16 @@ fold (tree_binary_expression *e)
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
-  octave_value::binary_op op_type = e->op_type ();
-
   if (op1->is_constant () && op2->is_constant ())
     {
       octave_value tmp = e->rvalue1 ();
 
       if (! (error_state || warning_state))
         {
           tree_constant *tc_retval
             = new tree_constant (tmp, op1->line (), op1->column ());
@@ -3261,17 +3259,17 @@ static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
   if (! s.empty ())
     {
       size_t offset = s.find_first_not_of (" \t");
 
-      retval = (s.substr (offset, 9) == "Copyright");
+      retval = (s.substr (offset, 9) == "Copyright" || s.substr (offset, 6) == "Author");
     }
 
   return retval;
 }
 
 static int
 text_getc (FILE *f)
 {
@@ -3560,17 +3558,21 @@ parse_fcn_file (const std::string& ff, c
           lexer_flags.parsing_class_method = ! dispatch_type.empty ();
 
           frame.protect_var (global_command);
 
           global_command = 0;
 
           int status = yyparse ();
 
-          delete global_command;
+          // Use an unwind-protect cleanup function so that the
+          // global_command list will be deleted in the event of an
+          // interrupt.
+
+          frame.add_fcn (cleanup_statement_list, &global_command);
 
           fcn_ptr = primary_fcn_ptr;
 
           if (status != 0)
             error ("parse error while reading %s file %s",
                    file_type.c_str(), ff.c_str ());
           else if (reading_fcn_file && endfunction_found
                    && max_function_depth > 1)
@@ -3603,17 +3605,17 @@ get_help_from_file (const std::string& n
   std::string retval;
 
   file = fcn_file_in_path (nm);
 
   if (! file.empty ())
     {
       symbol_found = true;
 
-      FILE *fptr = fopen (file.c_str (), "r");
+      FILE *fptr = gnulib::fopen (file.c_str (), "r");
 
       if (fptr)
         {
           unwind_protect frame;
           frame.add_fcn (safe_fclose, fptr);
 
           bool eof;
           retval = gobble_leading_white_space (fptr, eof);
@@ -4340,16 +4342,24 @@ eval_string (const std::string& s, bool 
       // Unmark forced variables.
       // Restore previous value of global_command.
       frame.run_top (2);
 
       if (parse_status == 0)
         {
           if (command_list)
             {
+              unwind_protect inner_frame;
+
+              // Use an unwind-protect cleanup function so that the
+              // global_command list will be deleted in the event of an
+              // interrupt.
+
+              inner_frame.add_fcn (cleanup_statement_list, &command_list);
+
               tree_statement *stmt = 0;
 
               if (command_list->length () == 1
                   && (stmt = command_list->front ())
                   && stmt->is_expression ())
                 {
                   tree_expression *expr = stmt->expression ();
 
@@ -4376,20 +4386,16 @@ eval_string (const std::string& s, bool 
                   if (nargout == 0)
                     retval = octave_value_list ();
                 }
               else if (nargout == 0)
                 command_list->accept (*current_evaluator);
               else
                 error ("eval: invalid use of statement list");
 
-              delete command_list;
-
-              command_list = 0;
-
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
           else if (parser_end_of_input)
             break;
@@ -4423,19 +4429,30 @@ eval_string (const octave_value& arg, bo
     {
       error ("eval: expecting std::string argument");
       return octave_value (-1);
     }
 
   return eval_string (s, silent, parse_status, nargout);
 }
 
+void
+cleanup_statement_list (tree_statement_list **lst)
+{
+  if (*lst)
+    {
+      delete *lst;
+      *lst = 0;
+    }
+}
+
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} eval (@var{try})\n\
+@deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
 The following example makes the variable @var{a} with the approximate\n\
 value 3.1416 available.\n\
 \n\
@@ -4449,16 +4466,21 @@ string is evaluated, as the following ex
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
       'printf (\"This error occurred:\\n%s\\n\", lasterr ());');\n\
      @print{} This error occurred:\n\
         This is a bad example\n\
 @end group\n\
 @end example\n\
+\n\
+Consider using try/catch blocks instead if you are only using @code{eval}\n\
+as an error-capturing mechanism rather than for the execution of arbitrary\n\
+code strings.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
@@ -4495,102 +4517,53 @@ eval ('error (\"This is a bad example\")
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%% test/octave.test/eval/eval-1.m
-%!#test
+%!shared x
 %! x = 1;
-%! assert(eval ("x"),1);
-
-%% test/octave.test/eval/eval-2.m
-%!test
-%! x = 1;
-%! assert(eval ("x;"));
-
-%% test/octave.test/eval/eval-3.m
+
+%!assert (eval ("x"), 1)
+%!assert (eval ("x;"))
+%!assert (eval ("x;"), 1);
+
 %!test
-%! x = 1;
-%! assert(eval ("x;"),1);
-
-%% FIXME
-%% Disable this test as adding the ";" is redundant with eval-1 and
-%% in any case is a syntax error with assert
-%% test/octave.test/eval/eval-4.m
-%!#test
-%! x = 1;
-%! assert(eval ("x");,1);
-
-%% test/octave.test/eval/eval-5.m
+%! y = eval ("x");
+%! assert (y, 1);
+
+%!test
+%! y = eval ("x;");
+%! assert (y, 1);
+
+%!test
+%! eval ("x = 1;")
+%! assert (x,1);
+
 %!test
 %! eval ("flipud = 2;");
-%! assert(flipud,2);
-
-%% test/octave.test/eval/eval-6.m
-%!function y = f ()
+%! assert (flipud, 2);
+
+%!function y = __f ()
 %!  eval ("flipud = 2;");
 %!  y = flipud;
-%!test
-%! assert(f,2);
-
-%% test/octave.test/eval/eval-7.m
-%!#test
-%! eval ("x = 1");
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-8.m
-%!test
-%! eval ("x = 1;")
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-9.m
-%!test
-%! eval ("x = 1;");
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-10.m
-%!#test
-%! eval ("x = 1")
-%! assert(x,1);
-
-%% test/octave.test/eval/eval-11.m
-%!test
-%! x = 1;
-%! y = eval ("x");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-12.m
-%!test
-%! x = 1;
-%! y = eval ("x;");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-13.m
-%!test
-%! x = 1;
-%! y = eval ("x;");
-%! assert(y,1);
-
-%% test/octave.test/eval/eval-14.m
-%!test
-%! x = 1;
-%! y = eval ("x");
-%! assert(y,1);
+%!endfunction
+%!assert (__f(), 2)
 
 */
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
 may be either @code{\"base\"} or @code{\"caller\"}.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
@@ -4630,20 +4603,22 @@ may be either @code{\"base\"} or @code{\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} evalin (@var{context}, @var{try})\n\
+@deftypefnx {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
 Like @code{eval}, except that the expressions are evaluated in the\n\
 context @var{context}, which may be either @code{\"caller\"} or\n\
 @code{\"base\"}.\n\
+@seealso{eval, assignin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
diff --git a/src/oct-prcstrm.cc b/src/oct-prcstrm.cc
--- a/src/oct-prcstrm.cc
+++ b/src/oct-prcstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-prcstrm.h b/src/oct-prcstrm.h
--- a/src/oct-prcstrm.h
+++ b/src/oct-prcstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-procbuf.h b/src/oct-procbuf.h
--- a/src/oct-procbuf.h
+++ b/src/oct-procbuf.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -35,18 +35,19 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <Array.h>
 
 #include "byte-swap.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
+#include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "quit.h"
 
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "utils.h"
@@ -3911,17 +3912,22 @@ octave_stream::mode_as_string (int mode)
 octave_stream_list *octave_stream_list::instance = 0;
 
 bool
 octave_stream_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_stream_list ();
+    {
+      instance = new octave_stream_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create stream list object!");
 
       retval = false;
     }
 
@@ -4170,19 +4176,19 @@ octave_stream_list::do_get_info (int fid
   string_vector retval;
 
   octave_stream os = do_lookup (fid);
 
   if (os.is_valid ())
     {
       retval.resize (3);
 
-      retval(0) = os.name ();
+      retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
       retval(1) = octave_stream::mode_as_string (os.mode ());
-      retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
+      retval(0) = os.name ();
     }
   else
     ::error ("invalid file id = %d", fid);
 
   return retval;
 }
 
 string_vector
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -32,16 +32,17 @@ class octave_value_list;
 #include <sstream>
 #include <string>
 #include <map>
 
 #include "Array.h"
 #include "data-conv.h"
 #include "lo-utils.h"
 #include "mach-info.h"
+#include "oct-refcount.h"
 
 class
 OCTINTERP_API
 scanf_format_elt
 {
 public:
 
   enum special_conversion
@@ -365,16 +366,22 @@ public:
   virtual std::istream *input_stream (void) { return 0; }
 
   // If the derived class provides this function and it returns a
   // pointer to a valid ostream, flush(), write(), and printf() will
   // automatically work for this stream.
 
   virtual std::ostream *output_stream (void) { return 0; }
 
+  // If the derived class is locale-aware, it must implement this function 
+  // in order to set a new locale. By default, this function avoids messing 
+  // with locales and ignores its input argument.
+  virtual std::locale imbue ( const std::locale & loc ) 
+    { return std::locale::classic (); }
+  
   // Return TRUE if this stream is open.
 
   bool is_open (void) const { return open_state; }
 
   virtual void do_close (void) { }
 
   void close (void)
     {
@@ -422,17 +429,17 @@ protected:
 
   // Clear stream state.
 
   void clearerr (void);
 
 private:
 
   // A reference count.
-  octave_idx_type count;
+  octave_refcount<octave_idx_type> count;
 
   // The permission bits for the file.  Should be some combination of
   // std::ios::open_mode bits.
   int md;
 
   // Data format.
   oct_mach_info::float_format flt_fmt;
 
@@ -607,17 +614,33 @@ public:
   {
     return rep ? rep->input_stream () : 0;
   }
 
   std::ostream *output_stream (void)
   {
     return rep ? rep->output_stream () : 0;
   }
-
+  
+  std::locale imbue (const std::locale & loc )
+    {
+      if (!rep) return std::locale::classic ();
+      
+      std::istream *is = rep->input_stream ();
+      std::ostream *os = rep->output_stream ();
+      
+      if (os) 
+        {
+          if (is)
+            (void) is->imbue (loc);
+          return os->imbue (loc);
+        }
+      return is ? is->imbue (loc) : std::locale::classic ();
+    }
+  
   void clearerr (void) { if (rep) rep->clearerr (); }
 
 private:
 
   // The actual representation of this stream.
   octave_base_stream *rep;
 
   bool stream_ok (bool clear = true) const
@@ -684,16 +707,18 @@ private:
   typedef std::map<int, octave_stream> ostrl_map;
 
   ostrl_map list;
 
   mutable ostrl_map::const_iterator lookup_cache;
 
   static octave_stream_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int do_insert (octave_stream& os);
 
   octave_stream do_lookup (int fid, const std::string& who = std::string ()) const;
   octave_stream do_lookup (const octave_value& fid,
                            const std::string& who = std::string ()) const;
 
   int do_remove (int fid, const std::string& who = std::string ());
   int do_remove (const octave_value& fid, const std::string& who = std::string ());
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/oct.h b/src/oct.h
--- a/src/oct.h
+++ b/src/oct.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/octave-config.cc.in b/src/octave-config.cc.in
--- a/src/octave-config.cc.in
+++ b/src/octave-config.cc.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Michael Goffioul
+Copyright (C) 2008-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/octave-config.in b/src/octave-config.in
--- a/src/octave-config.in
+++ b/src/octave-config.in
@@ -1,13 +1,13 @@
 #! /bin/sh -
 ##
 ## octave-config - reports some configuration values for Octave
 ##
-## Copyright (C) 2001-2011 John W. Eaton
+## Copyright (C) 2001-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -829,19 +829,20 @@ octave_main (int argc, char **argv, int 
 
   atexit (do_octave_atexit);
 
   // Is input coming from a terminal?  If so, we are probably
   // interactive.
 
   // If stdin is not a tty, then we are reading commands from a pipe or
   // a redirected file.
-  stdin_is_tty = isatty (fileno (stdin));
+  stdin_is_tty = gnulib::isatty (fileno (stdin));
 
-  interactive = (! embedded && stdin_is_tty && isatty (fileno (stdout)));
+  interactive = (! embedded && stdin_is_tty
+                 && gnulib::isatty (fileno (stdout)));
 
   if (! interactive && ! forced_line_editing)
     line_editing = false;
 
   // Force default line editor if we don't want readline editing.
   if (! line_editing)
     command_editor::force_default_editor ();
 
@@ -896,17 +897,21 @@ octave_main (int argc, char **argv, int 
       // If we are running an executable script (#! /bin/octave) then
       // we should only see the args passed to the script.
 
       intern_argv (remaining_args, argv+last_arg_idx);
 
       execute_command_line_file (argv[last_arg_idx]);
 
       if (! persist)
-        clean_up_and_exit (error_state ? 1 : 0);
+        {
+          quitting_gracefully = true;
+
+          clean_up_and_exit (error_state ? 1 : 0);
+        }
     }
 
   // Avoid counting commands executed from startup files.
 
   command_editor::reset_current_command_number (1);
 
   // Now argv should have the full set of args.
   intern_argv (argc, argv);
@@ -935,16 +940,18 @@ octave_main (int argc, char **argv, int 
       return 1;
     }
 
   int retval = main_loop ();
 
   if (retval == 1 && ! error_state)
     retval = 0;
 
+  quitting_gracefully = true;
+
   clean_up_and_exit (retval);
 
   return 0;
 }
 
 DEFUN (argv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argv ()\n\
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -1,12 +1,12 @@
 %{
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at
 your option) any later version.
 
diff --git a/src/octave.h b/src/octave.h
--- a/src/octave.h
+++ b/src/octave.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-diag.h b/src/ov-base-diag.h
--- a/src/ov-base-diag.h
+++ b/src/ov-base-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1998-2011 John W. Eaton
+Copyright (C) 1998-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -1525,33 +1525,38 @@ install_base_type_conversions (void)
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
 DEFUN (sparse_auto_mutate, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
-automatically mutate sparse matrices to real matrices to save memory.\n\
+automatically mutate sparse matrices to full matrices to save memory.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
-s = speye(3);\n\
+s = speye (3);\n\
 sparse_auto_mutate (false)\n\
-s (:, 1) = 1;\n\
+s(:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
 sparse_auto_mutate (true)\n\
-s (1, :) = 1;\n\
+s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
 
 %!test
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -162,19 +162,19 @@ DEF_CLASS_TO_BTYP (char, btyp_char);
 
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n, c) \
   int t::t_id (-1); \
   const std::string t::t_name (n); \
   const std::string t::c_name (c); \
   void t::register_type (void) \
     { \
-      t_id = octave_value_typeinfo::register_type (t::t_name, \
-                                                   t::c_name, \
-                                                   octave_value (new t ())); \
+      static t exemplar; \
+      octave_value v (&exemplar, true); \
+      t_id = octave_value_typeinfo::register_type (t::t_name, t::c_name, v); \
     }
 
 // A base value type, so that derived types only have to redefine what
 // they need (if they are derived from octave_base_value instead of
 // octave_value).
 
 class
 OCTINTERP_API
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2007-2011 John W. Eaton
+Copyright (C) 2007-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-colon.cc b/src/ov-colon.cc
--- a/src/ov-colon.cc
+++ b/src/ov-colon.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -74,16 +74,25 @@ public:
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
+  // Use this to give a more specific error message
+  idx_vector index_vector (void) const
+  {
+    error (
+           "attempted to use a complex scalar as an index\n"
+           "       (forgot to initialize i or j?)");
+    return idx_vector ();
+  }
+
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
               && ! (lo_ieee_isnan (std::real (scalar))
                     || lo_ieee_isnan (std::imag (scalar))));
     }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
diff --git a/src/ov-cs-list.cc b/src/ov-cs-list.cc
--- a/src/ov-cs-list.cc
+++ b/src/ov-cs-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cs-list.h b/src/ov-cs-list.h
--- a/src/ov-cs-list.h
+++ b/src/ov-cs-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2002-2011 John W. Eaton
+Copyright (C) 2002-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-diag.cc b/src/ov-cx-diag.cc
--- a/src/ov-cx-diag.cc
+++ b/src/ov-cx-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-diag.h b/src/ov-cx-diag.h
--- a/src/ov-cx-diag.h
+++ b/src/ov-cx-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-dld-fcn.cc b/src/ov-dld-fcn.cc
--- a/src/ov-dld-fcn.cc
+++ b/src/ov-dld-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 Copyright (C) 2010 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -1754,30 +1754,65 @@ are ignored in the lookup.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!function y = testrecursionfunc (f, x, n)
+
+%!function y = __testrecursionfunc (f, x, n)
 %!  if (nargin < 3)
 %!    n = 0;
 %!  endif
 %!  if (n > 2)
 %!    y = f (x);
 %!  else
 %!    n++;
-%!    y = testrecursionfunc (@(x) f(2*x), x, n);
+%!    y = __testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
-%!test
-%! assert (testrecursionfunc (@(x) x, 1), 8);
+%!endfunction
+%!
+%!assert (__testrecursionfunc (@(x) x, 1), 8)
+
 */
 
+DEFUN (is_function_handle, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
+Return true if @var{x} is a function handle.\n\
+@seealso{isa, typeinfo, class}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    retval = args(0).is_function_handle ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!shared fh
+%! fh = @(x) x;
+
+%!assert (is_function_handle (fh))
+%!assert (! is_function_handle ({fh}))
+%!assert (! is_function_handle (1))
+%!error is_function_handle ();
+%!error is_function_handle (1, 2);
+
+*/
+
+
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
@@ -1953,15 +1988,15 @@ octave_fcn_binder::do_multi_index_op (in
     }
   else
      retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
 
   return retval;
 }
 
 /*
-%!function r = f (g, i)
+%!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
 %!test
 %! x = [1,2;3,4];
-%! assert (f (@(i) x(:,i), 1), [1;3]);
+%! assert (__f (@(i) x(:,i), 1), [1;3]);
 */
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -656,30 +656,30 @@ If the second argument is an integer @va
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      std::string fun = args(0).string_value ();
-
-      if (! error_state)
+      if (args(0).is_string ())
         {
+          std::string fun = args(0).string_value ();
           string_vector fargs;
 
           if (nargin == 1)
             {
               bool is_arg = false;
               bool in_string = false;
               std::string tmp_arg;
               size_t i = 0;
+              size_t fun_length = fun.length ();
 
-              while (i < fun.length ())
+              while (i < fun_length)
                 {
                   bool terminate_arg = false;
                   char c = fun[i++];
 
                   if (in_string)
                     {
                       if (c == '\'' || c == '\"')
                         in_string = false;
@@ -693,62 +693,79 @@ If the second argument is an integer @va
                   else if (! isalpha (c) && c != '_')
                     if (! is_arg)
                       continue;
                     else if (isdigit (c))
                       tmp_arg.append (1, c);
                     else
                       {
                         // Before we do anything remove trailing whitespaces.
-                        while (i < fun.length () && isspace (c))
+                        while (i < fun_length && isspace (c))
                           c = fun[i++];
 
                         // Do we have a variable or a function?
                         if (c != '(')
                           terminate_arg = true;
                         else
                           {
                             tmp_arg = std::string ();
                             is_arg = false;
                           }
                       }
+                  else if (! is_arg)
+                    {
+                      if (c == 'e' || c == 'E')
+                        {
+                          // possible number in exponent form, not arg
+                          if (isdigit (fun[i])
+                              || fun[i] == '-' || fun[i] == '+')
+                            continue;
+                        }
+                      is_arg = true;
+                      tmp_arg.append (1, c);
+                    }
                   else
                     {
                       tmp_arg.append (1, c);
-                      is_arg = true;
                     }
 
-                  if (terminate_arg || (i == fun.length () && is_arg))
+                  if (terminate_arg || (i == fun_length && is_arg))
                     {
                       bool have_arg = false;
 
                       for (int j = 0; j < fargs.length (); j++)
                         if (tmp_arg == fargs (j))
                           {
                             have_arg = true;
                             break;
                           }
 
                       if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
                           tmp_arg != "NaN" && tmp_arg != "nan" &&
                           tmp_arg != "Inf" && tmp_arg != "inf" &&
                           tmp_arg != "NA" && tmp_arg != "pi" &&
-                          tmp_arg != "eps")
+                          tmp_arg != "e" && tmp_arg != "eps")
                         fargs.append (tmp_arg);
 
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
 
               // Sort the arguments into ascii order.
               fargs.sort ();
             }
           else if (nargin == 2 && args(1).is_numeric_type ())
             {
+              if (! args(1).is_scalar_type ()) 
+                {
+                  error ("inline: N must be an integer");
+                  return retval;
+                }
+              
               int n = args(1).int_value ();
 
               if (! error_state)
                 {
                   if (n >= 0)
                     {
                       fargs.resize (n+1);
 
@@ -758,37 +775,38 @@ If the second argument is an integer @va
                         {
                           std::ostringstream buf;
                           buf << "P" << i;
                           fargs(i) = buf.str ();
                         }
                     }
                   else
                     {
-                      error ("inline: N must be positive or zero");
+                      error ("inline: N must be a positive integer or zero");
                       return retval;
                     }
                 }
               else
                 {
                   error ("inline: N must be an integer");
                   return retval;
                 }
             }
           else
             {
               fargs.resize (nargin - 1);
 
               for (int i = 1; i < nargin; i++)
                 {
-                  std::string s = args(i).string_value ();
-
-                  if (! error_state)
-                    fargs(i-1) = s;
-                  else
+                  if (args(i).is_string ())
+                    {
+                      std::string s = args(i).string_value ();
+                      fargs(i-1) = s;
+                    }
+                    else
                     {
                       error ("inline: expecting string arguments");
                       return retval;
                     }
                 }
             }
 
           retval = octave_value (new octave_fcn_inline (fun, fargs));
@@ -799,19 +817,27 @@ If the second argument is an integer @va
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!shared fn
-%! fn = inline ("x.^2 + 1","x");
+%! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
+%% FIXME: Need tests for other 2 calling forms of inline()
+
+%% Test input validation 
+%!error inline ()
+%!error <STR argument must be a string> inline (1)
+%!error <N must be an integer> inline ("2", ones (2,2))
+%!error <N must be a positive integer> inline ("2", -1)
+%!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
@@ -832,16 +858,26 @@ Note that @code{char (@var{fun})} is equ
         error ("formula: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (formula (fn), "x.^2 + 1")
+%!assert (formula (fn), char (fn))
+
+%% Test input validation
+%!error formula ()
+%!error formula (1, 2)
+%!error <FUN must be an inline function> formula (1)
+*/
+
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of\n\
 the arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
@@ -868,16 +904,27 @@ the arguments of the inline function @va
         error ("argnames: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!assert (argnames (fn), {"x"})
+%!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
+%!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
+
+%% Test input validation
+%!error argnames ()
+%!error argnames (1, 2)
+%!error <FUN must be an inline function> argnames (1)
+*/
+
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
 by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
 @code{.*}, @code{./}, etc.\n\
 \n\
 This may be useful, for example, when using inline functions with\n\
@@ -887,16 +934,17 @@ is expected.\n\
 @example\n\
 @group\n\
 fcn = vectorize (inline (\"x^2 - 1\"))\n\
    @result{} fcn = f(x) = x.^2 - 1\n\
 quadv (fcn, 0, 3)\n\
    @result{} 6\n\
 @end group\n\
 @end example\n\
+@seealso{inline, formula, argnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -909,17 +957,17 @@ quadv (fcn, 0, 3)\n\
       else
         {
           old = args(0).fcn_inline_value (true);
           func_is_string = false;
 
           if (old)
             old_func = old->fcn_text ();
           else
-            error ("vectorize: must be a string or inline function");
+            error ("vectorize: FUN must be a string or inline function");
         }
 
       if (! error_state)
         {
           std::string new_func;
           size_t i = 0;
 
           while (i < old_func.length ())
@@ -950,8 +998,23 @@ quadv (fcn, 0, 3)\n\
                                    (new_func, old->fcn_arg_names ()));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!assert (char (vectorize (fn)), "x.^2 + 1")
+%!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
+%!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
+%!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
+%!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
+%!assert (vectorize ("2**x^5"), "2.**x.^5")
+
+%% Test input validation
+%!error vectorize ()
+%!error vectorize (1, 2)
+%!error <FUN must be a string or inline function> vectorize (1)
+*/
+
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn.cc b/src/ov-fcn.cc
--- a/src/ov-fcn.cc
+++ b/src/ov-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-diag.cc b/src/ov-flt-cx-diag.cc
--- a/src/ov-flt-cx-diag.cc
+++ b/src/ov-flt-cx-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-diag.h b/src/ov-flt-cx-diag.h
--- a/src/ov-flt-cx-diag.h
+++ b/src/ov-flt-cx-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-re-diag.cc b/src/ov-flt-re-diag.cc
--- a/src/ov-flt-re-diag.cc
+++ b/src/ov-flt-re-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-re-diag.h b/src/ov-flt-re-diag.h
--- a/src/ov-flt-re-diag.h
+++ b/src/ov-flt-re-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-int-traits.h b/src/ov-int-traits.h
--- a/src/ov-int-traits.h
+++ b/src/ov-int-traits.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int16.h b/src/ov-int16.h
--- a/src/ov-int16.h
+++ b/src/ov-int16.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int32.h b/src/ov-int32.h
--- a/src/ov-int32.h
+++ b/src/ov-int32.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int64.h b/src/ov-int64.h
--- a/src/ov-int64.h
+++ b/src/ov-int64.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-int8.h b/src/ov-int8.h
--- a/src/ov-int8.h
+++ b/src/ov-int8.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-lazy-idx.cc b/src/ov-lazy-idx.cc
--- a/src/ov-lazy-idx.cc
+++ b/src/ov-lazy-idx.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-lazy-idx.h b/src/ov-lazy-idx.h
--- a/src/ov-lazy-idx.h
+++ b/src/ov-lazy-idx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2010-2011 VZLU Prague
+Copyright (C) 2010-2012 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-mex-fcn.h b/src/ov-mex-fcn.h
--- a/src/ov-mex-fcn.h
+++ b/src/ov-mex-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-null-mat.h b/src/ov-null-mat.h
--- a/src/ov-null-mat.h
+++ b/src/ov-null-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-oncleanup.cc b/src/ov-oncleanup.cc
new file mode 100644
--- /dev/null
+++ b/src/ov-oncleanup.cc
@@ -0,0 +1,227 @@
+/*
+
+Copyright (C) 2010-2012 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "defun.h"
+#include "ov-oncleanup.h"
+#include "ov-fcn.h"
+#include "ov-usr-fcn.h"
+#include "pt-misc.h"
+#include "toplev.h"
+
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_oncleanup, "onCleanup",
+                                     "onCleanup");
+
+octave_oncleanup::octave_oncleanup (const octave_value& f)
+  : fcn (f)
+{
+  if (f.is_function_handle ())
+    {
+      octave_function *fptr = f.function_value (true);
+      if (fptr)
+        {
+          octave_user_function *uptr
+            = dynamic_cast<octave_user_function *> (fptr);
+
+          if (uptr != 0)
+            {
+              tree_parameter_list *pl = uptr->parameter_list ();
+
+              if (pl != 0 && pl->length () > 0)
+                warning ("onCleanup: cleanup action takes parameters");
+            }
+        }
+      else
+        error ("onCleanup: no default dispatch for function handle");
+    }
+  else
+    {
+      fcn = octave_value ();
+      error ("onCleanup: argument must be a function handle");
+    }
+}
+
+octave_oncleanup::~octave_oncleanup (void)
+{
+  if (fcn.is_undefined ())
+    return;
+
+  unwind_protect frame;
+
+  // Clear interrupts.
+  frame.protect_var (octave_interrupt_state);
+  octave_interrupt_state = 0;
+
+  // Disallow quit().
+  frame.protect_var (quit_allowed);
+  quit_allowed = false;
+
+  // Clear errors.
+  frame.protect_var (error_state);
+  error_state = 0;
+
+  try
+    {
+      // Run the actual code.
+      fcn.do_multi_index_op (0, octave_value_list ());
+    }
+  catch (octave_interrupt_exception)
+    {
+      // Swallow the interrupt.
+      warning ("onCleanup: interrupt occured in cleanup action");
+    }
+  catch (std::bad_alloc)
+    {
+      // Swallow the exception.
+      warning ("onCleanup: out of memory occured in cleanup action");
+    }
+  catch (...) // Yes, the black hole. We're in a d-tor.
+    {
+      // This shouldn't happen, in theory.
+      error ("onCleanup: internal error: unhandled exception in cleanup action");
+    }
+
+  // We don't want to ignore errors that occur in the cleanup code, so
+  // if an error is encountered there, leave error_state alone.
+  // Otherwise, set it back to what it was before.
+  if (error_state)
+    {
+      frame.discard_top ();
+      octave_call_stack::backtrace_error_message ();
+    }
+}
+
+octave_scalar_map
+octave_oncleanup::scalar_map_value (void) const
+{
+  octave_scalar_map retval;
+  retval.setfield ("task", fcn);
+  return retval;
+}
+
+static void
+warn_save_load (void)
+{
+  warning ("onCleanup: load and save not supported");
+}
+
+bool
+octave_oncleanup::save_ascii (std::ostream& /* os */)
+{
+  warn_save_load ();
+  return true;
+}
+
+bool
+octave_oncleanup::load_ascii (std::istream& /* is */)
+{
+  warn_save_load ();
+  return true;
+}
+
+bool
+octave_oncleanup::save_binary (std::ostream& /* os */, bool& /* save_as_floats */)
+{
+  warn_save_load ();
+  return true;
+}
+
+bool
+octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
+                               oct_mach_info::float_format /* fmt */)
+{
+  warn_save_load ();
+  return true;
+}
+
+#if defined (HAVE_HDF5)
+bool
+octave_oncleanup::save_hdf5 (hid_t /* loc_id */, const char * /* name */,
+                             bool /* save_as_floats */)
+{
+  warn_save_load ();
+  return true;
+}
+
+bool
+octave_oncleanup::load_hdf5 (hid_t /* loc_id */, const char * /* name */)
+{
+  warn_save_load ();
+  return true;
+}
+#endif
+
+void
+octave_oncleanup::print (std::ostream& os, bool pr_as_read_syntax) const
+{
+  print_raw (os, pr_as_read_syntax);
+  newline (os);
+}
+
+void
+octave_oncleanup::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+{
+  os << "onCleanup (";
+  if (fcn.is_defined ())
+    fcn.print_raw (os, pr_as_read_syntax);
+  os << ")";
+}
+
+DEFUN (onCleanup, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
+Create a special object that executes a given function upon destruction.\n\
+If the object is copied to multiple variables (or cell or struct array\n\
+elements) or returned from a function, @var{action} will be executed after\n\
+clearing the last copy of the object.  Note that if multiple local onCleanup\n\
+variables are created, the order in which they are called is unspecified.\n\
+For similar functionality @xref{The @code{unwind_protect} Statement}.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (args.length () == 1)
+    retval = octave_value (new octave_oncleanup (args(0)));
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+
+%!test
+%! old_wstate = warning ("query");
+%! unwind_protect
+%!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
+%!   warning ("off", "__MY_WARNING__");
+%!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
+%!   clear trigger
+%!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
+%! unwind_protect_cleanup
+%!   warning (old_wstate);
+%! end_unwind_protect
+
+*/
diff --git a/src/ov-oncleanup.h b/src/ov-oncleanup.h
new file mode 100644
--- /dev/null
+++ b/src/ov-oncleanup.h
@@ -0,0 +1,101 @@
+/*
+
+Copyright (C) 2010-2012 VZLU Prague
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iosfwd>
+
+#include "ov-base.h"
+#include "ov-struct.h"
+#include "ov.h"
+
+static void
+gripe_internal (void)
+{
+  error ("onCleanup: internal error: cloning nonempty object");
+}
+
+class octave_oncleanup : public octave_base_value
+{
+public:
+  octave_oncleanup (void) : fcn () { }
+
+  octave_oncleanup (const octave_value& fcn);
+
+  octave_base_value *clone (void) const
+  {
+    if (fcn.is_defined ())
+      gripe_internal ();
+
+    return empty_clone ();
+  }
+
+  octave_base_value *empty_clone (void) const
+  {
+    return new octave_oncleanup ();
+  }
+
+  ~octave_oncleanup (void);
+
+  bool is_defined (void) const { return true; }
+
+  bool is_object (void) const { return true; } // do we want this?
+
+  octave_map map_value (void) const { return scalar_map_value (); }
+
+  octave_scalar_map scalar_map_value (void) const;
+
+  dim_vector dims (void) const
+  {
+    static dim_vector dv (1, 1);
+    return dv;
+  }
+
+  bool save_ascii (std::ostream& os);
+
+  bool load_ascii (std::istream& is);
+
+  bool save_binary (std::ostream& os, bool& save_as_floats);
+
+  bool load_binary (std::istream& is, bool swap,
+                    oct_mach_info::float_format fmt);
+
+#if defined (HAVE_HDF5)
+  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+
+  bool load_hdf5 (hid_t loc_id, const char *name);
+#endif
+
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+private:
+
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+
+protected:
+
+  octave_value fcn;
+};
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -644,32 +644,37 @@ octave_range::as_mxArray (void) const
 
   return retval;
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
 ranges are allowed as indices.  This might be useful for @sc{matlab}\n\
 compatibility; however, it is still not entirely compatible because\n\
 @sc{matlab} treats the range expression differently in different contexts.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (allow_noninteger_range_as_index);
 }
 
 /*
 %!test
 %! x = 0:10;
 %! save = allow_noninteger_range_as_index ();
 %! warn_state = warning ("query", "Octave:noninteger-range-as-index");
 %! unwind_protect
-%!   save = allow_noninteger_range_as_index (false);
+%!   allow_noninteger_range_as_index (false);
 %!   fail ('x(2.1:5)');
 %!   assert (x(2:5), 1:4);
 %!   allow_noninteger_range_as_index (true);
 %!   warning ("off", "Octave:noninteger-range-as-index");
 %!   assert (x(2.49:5), 1:3);
 %!   assert (x(2.5:5), 2:4);
 %!   assert (x(2.51:5), 2:4);
 %! unwind_protect_cleanup
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-diag.cc b/src/ov-re-diag.cc
--- a/src/ov-re-diag.cc
+++ b/src/ov-re-diag.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-diag.h b/src/ov-re-diag.h
--- a/src/ov-re-diag.h
+++ b/src/ov-re-diag.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -2211,29 +2211,39 @@ the named fields.\n\
 %!  assert (fieldnames (y), {"d"; "b"; "c"});
 %!  assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print,
                                             -1, INT_MAX);
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
 array contents.  If true, values of struct array elements are printed.\n\
 This variable does not affect scalar structures.  Their elements\n\
 are always printed.  In both cases, however, printing will be limited to\n\
 the number of levels specified by @var{struct_levels_to_print}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_struct_array_contents);
 }
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -19,35 +19,41 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "ov-typeinfo.h"
+#include "Array.h"
+#include "singleton-cleanup.h"
 
 #include "defun.h"
 #include "error.h"
+#include "ov-typeinfo.h"
 
 const int
 octave_value_typeinfo::init_tab_sz (16);
 
 octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
-#include <Array.h>
-
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
+
   if (! instance)
-    instance = new octave_value_typeinfo ();
+    {
+      instance = new octave_value_typeinfo ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create value type info object!");
 
       retval = false;
     }
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -203,22 +203,26 @@ protected:
       compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
       cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
       assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
       pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
       type_conv_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       widening_ops (dim_vector (init_tab_sz, init_tab_sz), 0)  { }
 
+  ~octave_value_typeinfo (void) { }
+
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int num_types;
 
   Array<std::string> types;
 
   Array<octave_value> vals;
 
   Array<void *> unary_class_ops;
 
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint16.h b/src/ov-uint16.h
--- a/src/ov-uint16.h
+++ b/src/ov-uint16.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint32.h b/src/ov-uint32.h
--- a/src/ov-uint32.h
+++ b/src/ov-uint32.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint64.h b/src/ov-uint64.h
--- a/src/ov-uint64.h
+++ b/src/ov-uint64.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-uint8.h b/src/ov-uint8.h
--- a/src/ov-uint8.h
+++ b/src/ov-uint8.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 John W. Eaton
+Copyright (C) 2004-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -46,16 +46,17 @@ along with Octave; see the file COPYING.
 #include "pt-walk.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "parse.h"
 #include "profiler.h"
 #include "variables.h"
+#include "ov-fcn-handle.h"
 
 // Whether to optimize subsasgn method calls.
 static bool Voptimize_subsasgn_calls = true;
 
 // User defined scripts.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_script);
 
@@ -624,65 +625,65 @@ octave_user_function::bind_automatic_var
           symbol_table::mark_automatic (".ignored.");
         }
     }
 }
 
 DEFUN (nargin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargin ()\n\
-@deftypefnx {Built-in Function} {} nargin (@var{fcn_name})\n\
+@deftypefnx {Built-in Function} {} nargin (@var{fcn})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
-Octave.  If called with the optional argument @var{fcn_name}, return the\n\
-maximum number of arguments the named function can accept, or -1 if the\n\
-function accepts a variable number of arguments.\n\
+Octave.\n\
+\n\
+If called with the optional argument @var{fcn}, a function name or handle,\n\
+return the declared number of arguments that the function can accept.\n\
+If the last argument is @var{varargin} the returned value is negative.\n\
+This feature does not work on builtin functions.\n\
 @seealso{nargout, varargin, isargout, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string fname = args(0).string_value ();
+      octave_value func = args(0);
 
-      if (! error_state)
+      if (func.is_string ())
         {
-          octave_value fcn_val = symbol_table::find_function (fname);
-
-          if (fcn_val.is_user_function ())
-            {
-              octave_user_function *fcn = fcn_val.user_function_value (true);
+          std::string name = func.string_value ();
+          func = symbol_table::find_function (name);
+          if (func.is_undefined ())
+            error ("nargout: invalid function name: %s", name.c_str ());
+        }
 
-              if (fcn)
-                {
-                  if (fcn->takes_varargs ())
-                    retval = -1;
-                  else
-                    {
-                      tree_parameter_list *param_list = fcn->parameter_list ();
+      octave_function *fcn_val = func.function_value ();
+      if (fcn_val)
+        {
+          octave_user_function *fcn = fcn_val->user_function_value (true);
 
-                      retval = param_list ? param_list->length () : 0;
-                    }
-                }
-              else
-                error ("nargin: loading user-defined function failed");
+          if (fcn)
+            {
+              tree_parameter_list *param_list = fcn->parameter_list ();
+
+              retval = param_list ? param_list->length () : 0;
+              if (fcn->takes_varargs ())
+                retval = -1 - retval;
             }
           else
             {
-              // FIXME -- what about built-in functions or functions
-              // defined in .oct files or .mex files?
-
-              error ("nargin: FCN_NAME must be a user-defined function");
+              // Matlab gives up for histc, so maybe it's ok we give up somtimes too.
+              error ("nargin: nargin information not available for builtin functions");
             }
         }
       else
-        error ("nargin: FCN_NAME must be a string");
+        error ("nargin: FCN must be a string or function handle");
     }
   else if (nargin == 0)
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
@@ -690,21 +691,22 @@ function accepts a variable number of ar
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargout ()\n\
-@deftypefnx {Built-in Function} {} nargout (@var{fcn_name})\n\
+@deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
 Within a function, return the number of values the caller expects to\n\
-receive.  If called with the optional argument @var{fcn_name}, return the\n\
-maximum number of values the named function can produce, or -1 if the\n\
-function can produce a variable number of values.\n\
+receive.  If called with the optional argument @var{fcn}, a function\n\
+name or handle, return the number of declared output values that the\n\
+function can produce. If the final output argument is @var{varargout}\n\
+the returned value is negative.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 f ()\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -713,50 +715,94 @@ will cause @code{nargout} to return 0 in
 @example\n\
 [s, t] = f ()\n\
 @end example\n\
 \n\
 @noindent\n\
 will cause @code{nargout} to return 2 inside the function\n\
 @code{f}.\n\
 \n\
-At the top level, @code{nargout} is undefined.\n\
+In the second usage,\n\
+\n\
+@example\n\
+nargout (@@histc) \% or nargout ('histc')\n\
+@end example\n\
+\n\
+will return 2, because @code{histc} has two outputs, whereas\n\
+\n\
+@example\n\
+nargout (@@deal)\n\
+@end example\n\
+\n\
+will return -1, because @code{deal} has a variable number of outputs.\n\
+\n\
+At the top level, @code{nargout} with no argument is undefined.\n\
+@code{nargout} does not work on builtin functions.\n\
+@code{nargout} returns -1 for all anonymous functions.\n\
 @seealso{nargin, varargin, isargout, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      std::string fname = args(0).string_value ();
+      octave_value func = args(0);
 
-      if (! error_state)
+      if (func.is_string ())
+        {
+          std::string name = func.string_value ();
+          func = symbol_table::find_function (name);
+          if (func.is_undefined ())
+            error ("nargout: invalid function name: %s", name.c_str ());
+        }
+
+      if (func.is_inline_function ())
         {
-          octave_value fcn_val = symbol_table::find_user_function (fname);
+          retval = 1;
+          return retval;
+        }
+
+      if (func.is_function_handle ())
+        {
+          octave_fcn_handle *fh = func.fcn_handle_value ();
+          std::string fh_nm = fh->fcn_name ();
 
-          octave_user_function *fcn = fcn_val.user_function_value (true);
+          if (fh_nm == octave_fcn_handle::anonymous)
+            {
+              retval = -1;
+              return retval;
+            }
+        }
+
+      octave_function *fcn_val = func.function_value ();
+      if (fcn_val)
+        {
+          octave_user_function *fcn = fcn_val->user_function_value (true);
 
           if (fcn)
             {
+              tree_parameter_list *ret_list = fcn->return_list ();
+          
+              retval = ret_list ? ret_list->length () : 0;
+
               if (fcn->takes_var_return ())
-                retval = -1;
-              else
-                {
-                  tree_parameter_list *ret_list = fcn->return_list ();
-
-                  retval = ret_list ? ret_list->length () : 0;
-                }
+                retval = -1 - retval;
             }
           else
-            error ("nargout: invalid function");
+            {
+              // JWE said this information is not available (currently, 2011-03-10)
+              // without making intrusive changes to Octave.
+              // Matlab gives up for histc, so maybe it's ok we give up somtimes too.
+              error ("nargout: nargout information not available for builtin functions.");
+            }
         }
       else
-        error ("nargout: FCN_NAME must be a string");
+        error ("nargout: FCN must be a string or function handle");
     }
   else if (nargin == 0)
     {
       if (! symbol_table::at_top_level ())
         {
           retval = symbol_table::varval (".nargout.");
 
           if (retval.is_undefined ())
@@ -770,19 +816,24 @@ At the top level, @code{nargout} is unde
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 subsasgn method of a user-defined class.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
 
 static bool val_in_table (const Matrix& table, double val)
 {
   if (table.is_empty ())
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -60,16 +60,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-cx-mat.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-struct.h"
 #include "ov-class.h"
+#include "ov-oncleanup.h"
 #include "ov-cs-list.h"
 #include "ov-colon.h"
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-fcn-inline.h"
 #include "ov-typeinfo.h"
@@ -2684,16 +2685,17 @@ install_types (void)
   octave_float_diag_matrix::register_type ();
   octave_float_complex_matrix::register_type ();
   octave_float_complex_diag_matrix::register_type ();
   octave_perm_matrix::register_type ();
   octave_null_matrix::register_type ();
   octave_null_str::register_type ();
   octave_null_sq_str::register_type ();
   octave_lazy_index::register_type ();
+  octave_oncleanup::register_type ();
 }
 
 DEFUN (sizeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -310,30 +310,38 @@ public:
     if (--rep->count == 0)
       delete rep;
   }
 
   void make_unique (void)
     {
       if (rep->count > 1)
         {
-          --rep->count;
-          rep = rep->unique_clone ();
+	  octave_base_value *r = rep->unique_clone ();
+
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = r;
         }
     }
 
   // This uniquifies the value if it is referenced by more than a certain
   // number of shallow copies. This is useful for optimizations where we
   // know a certain copy, typically within a cell array, to be obsolete.
   void make_unique (int obsolete_copies)
     {
       if (rep->count > obsolete_copies + 1)
         {
-          --rep->count;
-          rep = rep->unique_clone ();
+          octave_base_value *r = rep->unique_clone ();
+
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = r;
         }
     }
 
   // Simple assignment.
 
   octave_value& operator = (const octave_value& a)
     {
       if (rep != a.rep)
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -25,26 +25,26 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <fstream>
 #include <iostream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "oct-env.h"
+#include "singleton-cleanup.h"
 
-#include "procstream.h"
-
-#include <defaults.h>
+#include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "pager.h"
+#include "procstream.h"
 #include "sighandlers.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Our actual connection to the external pager.
 static oprocstream *external_pager = 0;
 
@@ -306,109 +306,159 @@ octave_pager_stream::octave_pager_stream
 }
 
 octave_pager_stream::~octave_pager_stream (void)
 {
   flush ();
   delete pb;
 }
 
-octave_pager_stream&
+std::ostream&
 octave_pager_stream::stream (void)
 {
-  if (! instance)
-    instance = new octave_pager_stream ();
-
-  return *instance;
+  return instance_ok () ? *instance : std::cout;
 }
 
 void
 octave_pager_stream::flush_current_contents_to_diary (void)
 {
-  if (pb)
-    pb->flush_current_contents_to_diary ();
+  if (instance_ok ())
+    instance->do_flush_current_contents_to_diary ();
 }
 
 void
 octave_pager_stream::set_diary_skip (void)
 {
-  if (pb)
-    pb->set_diary_skip ();
+  if (instance_ok ())
+    instance->do_set_diary_skip ();
 }
 
 // Reinitialize the pager buffer to avoid hanging on to large internal
 // buffers when they might not be needed.  This function should only be
 // called when the pager is not in use.  For example, just before
 // getting command-line input.
 
 void
 octave_pager_stream::reset (void)
 {
-  if (! instance)
-    instance = new octave_pager_stream ();
+  if (instance_ok ())
+    instance->do_reset ();
+}
 
-  instance->do_reset ();
+void
+octave_pager_stream::do_flush_current_contents_to_diary (void)
+{
+  if (pb)
+    pb->flush_current_contents_to_diary ();
+}
+
+void
+octave_pager_stream::do_set_diary_skip (void)
+{
+  if (pb)
+    pb->set_diary_skip ();
 }
 
 void
 octave_pager_stream::do_reset (void)
 {
   delete pb;
   pb = new octave_pager_buf ();
   rdbuf (pb);
   setf (unitbuf);
 }
 
+bool
+octave_pager_stream::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new octave_pager_stream ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create pager_stream object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
+
 octave_diary_stream *octave_diary_stream::instance = 0;
 
 octave_diary_stream::octave_diary_stream (void) : std::ostream (0), db (0)
 {
   db = new octave_diary_buf ();
   rdbuf (db);
   setf (unitbuf);
 }
 
 octave_diary_stream::~octave_diary_stream (void)
 {
   flush ();
   delete db;
 }
 
-octave_diary_stream&
+std::ostream&
 octave_diary_stream::stream (void)
 {
-  if (! instance)
-    instance = new octave_diary_stream ();
-
-  return *instance;
+  return instance_ok () ? *instance : std::cout;
 }
 
 // Reinitialize the diary buffer to avoid hanging on to large internal
 // buffers when they might not be needed.  This function should only be
 // called when the pager is not in use.  For example, just before
 // getting command-line input.
 
 void
 octave_diary_stream::reset (void)
 {
-  if (! instance)
-    instance = new octave_diary_stream ();
-
-  instance->do_reset ();
+  if (instance_ok ())
+    instance->do_reset ();
 }
 
 void
 octave_diary_stream::do_reset (void)
 {
   delete db;
   db = new octave_diary_buf ();
   rdbuf (db);
   setf (unitbuf);
 }
 
+bool
+octave_diary_stream::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new octave_diary_stream ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create diary_stream object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
+
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
       unwind_protect frame;
 
       frame.protect_var (really_flush_to_pager);
@@ -432,34 +482,34 @@ close_diary_file (void)
   // function foo ()
   //   diary on;
   //   ...
   //   diary off;
   // endfunction
   //
   // will do the right thing.
 
-  octave_stdout.flush_current_contents_to_diary ();
+  octave_pager_stream::flush_current_contents_to_diary ();
 
   if (external_diary_file.is_open ())
     {
       octave_diary.flush ();
       external_diary_file.close ();
     }
 }
 
 static void
 open_diary_file (void)
 {
   close_diary_file ();
 
   // If there is pending output in the pager buf, it should not go
   // into the diary file.
 
-  octave_stdout.set_diary_skip ();
+  octave_pager_stream::set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
@@ -585,58 +635,78 @@ terminal window in characters (rows and 
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
-@deftypefnx {Built-in Function} {@var{val} =} page_output_immediately (@var{new_val})\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
 DEFUN (page_screen_output, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} page_screen_output ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} page_screen_output (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether output intended\n\
 for the terminal window that is longer than one page is sent through a\n\
 pager.  This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
 DEFUN (PAGER, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} PAGER (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the program to use\n\
 to display terminal output on your system.  The default value is\n\
 normally @code{\"less\"}, @code{\"more\"}, or\n\
 @code{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{more, page_screen_output, page_output_immediately, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 DEFUN (PAGER_FLAGS, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} PAGER_FLAGS (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options to pass\n\
 to the pager.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{PAGER}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER_FLAGS);
 }
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -57,30 +57,38 @@ octave_pager_stream : public std::ostrea
 protected:
 
   octave_pager_stream (void);
 
 public:
 
   ~octave_pager_stream (void);
 
-  void flush_current_contents_to_diary (void);
+  static void flush_current_contents_to_diary (void);
 
-  void set_diary_skip (void);
+  static void set_diary_skip (void);
 
-  static octave_pager_stream& stream (void);
+  static std::ostream& stream (void);
 
   static void reset (void);
 
 private:
 
+  void do_flush_current_contents_to_diary (void);
+
+  void do_set_diary_skip (void);
+
   void do_reset (void);
 
   static octave_pager_stream *instance;
 
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   octave_pager_buf *pb;
 
   // No copying!
 
   octave_pager_stream (const octave_pager_stream&);
 
   octave_pager_stream& operator = (const octave_pager_stream&);
 };
@@ -105,26 +113,30 @@ octave_diary_stream : public std::ostrea
 protected:
 
   octave_diary_stream (void);
 
 public:
 
   ~octave_diary_stream (void);
 
-  static octave_diary_stream& stream (void);
+  static std::ostream& stream (void);
 
   static void reset (void);
 
 private:
 
   void do_reset (void);
 
   static octave_diary_stream *instance;
 
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   octave_diary_buf *db;
 
   // No copying!
 
   octave_diary_stream (const octave_diary_stream&);
 
   octave_diary_stream& operator = (const octave_diary_stream&);
 };
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 
 extern void reset_parser (void);
 extern int octave_lex (void);
 extern int octave_parse (void);
 
 class tree;
 class tree_matrix;
 class tree_identifier;
+class tree_statement_list;
 class octave_function;
 
 #include "oct-obj.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
 // The current input line number.
@@ -108,9 +109,11 @@ extern OCTINTERP_API octave_value_list
 feval (const octave_value_list& args, int nargout = 0);
 
 extern OCTINTERP_API octave_value_list
 eval_string (const std::string&, bool silent, int& parse_status, int hargout);
 
 extern OCTINTERP_API octave_value
 eval_string (const std::string&, bool silent, int& parse_status);
 
+extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
+
 #endif
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -3947,16 +3947,17 @@ to produce a more readable output with l
 
   return retval;
 }
 
 DEFUN (fixed_point_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fixed_point_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} fixed_point_format (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 use a scaled format to print matrix values such that the largest\n\
 element may be written with a single leading digit with the scaling\n\
 factor is printed on the first line of output.  For example:\n\
 \n\
 @example\n\
 @group\n\
 octave:1> logspace (1, 7, 5)'\n\
@@ -3971,50 +3972,60 @@ ans =\n\
   1.00000\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Notice that first value appears to be zero when it is actually 1.  For\n\
 this reason, you should be careful when setting\n\
 @code{fixed_point_format} to a nonzero value.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{format, output_max_field_width, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} print_empty_dimensions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
 @end example\n\
 \n\
 @noindent\n\
 will print\n\
 \n\
 @example\n\
 ans = [](3x0)\n\
 @end example\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_empty_dimensions);
 }
 
 DEFUN (split_long_rows, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} split_long_rows ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} split_long_rows (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} split_long_rows (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether rows of a matrix\n\
 may be split when displayed to a terminal window.  If the rows are split,\n\
 Octave will display the matrix in a series of smaller pieces, each of\n\
 which can fit within the limits of your terminal width and each set of\n\
 rows is labeled so that you can easily see which columns are currently\n\
 being displayed.  For example:\n\
 \n\
 @example\n\
@@ -4028,37 +4039,51 @@ ans =\n\
   0.75697  0.51942  0.40031  0.61784  0.92309  0.40201\n\
 \n\
  Columns 7 through 10:\n\
 \n\
   0.90174  0.11854  0.72313  0.73326\n\
   0.44672  0.94303  0.56564  0.82150\n\
 @end group\n\
 @end example\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (split_long_rows);
 }
 
 DEFUN (output_max_field_width, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_max_field_width ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} output_max_field_width (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum width\n\
 of a numeric output field.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0, INT_MAX);
 }
 
 DEFUN (output_precision, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} output_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_max_field_width}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1, INT_MAX);
 }
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/procstream.cc b/src/procstream.cc
--- a/src/procstream.cc
+++ b/src/procstream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/profiler.cc b/src/profiler.cc
--- a/src/profiler.cc
+++ b/src/profiler.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Daniel Kraft
+Copyright (C) 2012 Daniel Kraft
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/profiler.h b/src/profiler.h
--- a/src/profiler.h
+++ b/src/profiler.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2011 Daniel Kraft
+Copyright (C) 2012 Daniel Kraft
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-all.h b/src/pt-all.h
--- a/src/pt-all.h
+++ b/src/pt-all.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -68,17 +68,17 @@ static const char *former_built_in_varia
   "beep_on_error",
   "completion_append_char",
   "crash_dumps_octave_core",
   "current_script_file_name",
   "debug_on_error",
   "debug_on_interrupt",
   "debug_on_warning",
   "debug_symtab_lookups",
-  "default_save_format",
+  "default_save_options",
   "echo_executing_commands",
   "fixed_point_format",
   "gnuplot_binary",
   "gnuplot_command_axes",
   "gnuplot_command_end",
   "gnuplot_command_plot",
   "gnuplot_command_replot",
   "gnuplot_command_splot",
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -277,25 +277,30 @@ tree_boolean_expression::dup (symbol_tab
 
   return new_be;
 }
 
 DEFUN (do_braindead_shortcircuit_evaluation, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} do_braindead_shortcircuit_evaluation ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} do_braindead_shortcircuit_evaluation (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} do_braindead_shortcircuit_evaluation (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 do short-circuit evaluation of @samp{|} and @samp{&} operators inside the\n\
 conditions of if or while statements.\n\
 \n\
 This feature is only provided for compatibility with @sc{matlab} and should\n\
 not be used unless you are porting old code that relies on this feature.\n\
 \n\
 To obtain short-circuit behavior for logical expressions in new programs,\n\
 you should always use the @samp{&&} and @samp{||} operators.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
 
 /*
 
 %!test
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2001-2011 Ben Sapp
+Copyright (C) 2001-2012 Ben Sapp
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cbinop.h b/src/pt-cbinop.h
--- a/src/pt-cbinop.h
+++ b/src/pt-cbinop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 Jaroslav Hajek
+Copyright (C) 2008-2012 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1999-2011 John W. Eaton
+Copyright (C) 1999-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -29,18 +29,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 
 // We are likely to have a lot of tree_constant objects to allocate,
 // so make the grow_size large.
-octave_allocator
-tree_constant::allocator (sizeof (tree_constant), 1024);
+DEFINE_OCTAVE_ALLOCATOR2 (tree_constant, 1024);
 
 void
 tree_constant::print (std::ostream& os, bool pr_as_read_syntax, bool pr_orig_text)
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print (os, pr_as_read_syntax);
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -50,20 +50,16 @@ public:
   tree_constant (const octave_value& v, const std::string& ot,
                  int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text (ot) { }
 
   ~tree_constant (void) { }
 
   bool has_magic_end (void) const { return false; }
 
-  void *operator new (size_t size) { return allocator.alloc (size); }
-
-  void operator delete (void *p, size_t size) { allocator.free (p, size); }
-
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
   void maybe_mutate (void) { val.maybe_mutate (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
               bool pr_orig_txt = true);
@@ -86,25 +82,24 @@ public:
   // pretty printing.
 
   void stash_original_text (const std::string& s) { orig_text = s; }
 
   std::string original_text (void) const { return orig_text; }
 
 private:
 
-  // For custom memory management.
-  static octave_allocator allocator;
-
   // The actual value that this constant refers to.
   octave_value val;
 
   // The original text form of this constant.
   std::string orig_text;
 
   // No copying!
 
   tree_constant (const tree_constant&);
 
   tree_constant& operator = (const tree_constant&);
+
+  DECLARE_OCTAVE_ALLOCATOR
 };
 
 #endif
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -318,17 +318,16 @@ tree_evaluator::visit_simple_for_command
 
     if (rhs.is_range ())
       {
         Range rng = rhs.range_value ();
 
         octave_idx_type steps = rng.nelem ();
         double b = rng.base ();
         double increment = rng.inc ();
-        bool quit = false;
 
         for (octave_idx_type i = 0; i < steps; i++)
           {
             // Use multiplication here rather than declaring a
             // temporary variable outside the loop and using
             //
             //   tmp_val += increment
             //
@@ -358,18 +357,16 @@ tree_evaluator::visit_simple_for_command
         quit_loop_now ();
       }
     else if (rhs.is_matrix_type () || rhs.is_cell () || rhs.is_string ()
              || rhs.is_map ())
       {
         // A matrix or cell is reshaped to 2 dimensions and iterated by
         // columns.
 
-        bool quit = false;
-
         dim_vector dv = rhs.dims ().redim (2);
 
         octave_idx_type nrows = dv(0), steps = dv(1);
 
         if (steps > 0)
           {
             octave_value arg = rhs;
             if (rhs.ndims () > 2)
@@ -1191,19 +1188,24 @@ tree_evaluator::do_keyboard (const octav
 {
   return ::do_keyboard (args);
 }
 
 DEFUN (max_recursion_depth, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} max_recursion_depth (@var{new_val}, \"local\")\n\
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.  If the limit is exceeded, an error message is\n\
 printed and control returns to the top level.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 /*
 %!error (max_recursion_depth (1, 2));
 %!test
@@ -1214,20 +1216,25 @@ printed and control returns to the top l
 %! max_recursion_depth (orig_val);
 %! assert (max_recursion_depth (), orig_val);
 */
 
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
 
 /*
 %!error (silent_functions (1, 2));
 %!test
diff --git a/src/pt-eval.h b/src/pt-eval.h
--- a/src/pt-eval.h
+++ b/src/pt-eval.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -136,32 +136,34 @@ tree_anon_fcn_handle::rvalue1 (int)
   octave_value ov_fcn (uf);
 
   octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
 
   return fh;
 }
 
 /*
-%!function r = f2 (f, x)
+%!function r = __f2 (f, x)
 %!  r = f (x);
-%!function f = f1 (k)
-%!  f = @(x) f2 (@(y) y-k, x);
+%!endfunction
+%!function f = __f1 (k)
+%!  f = @(x) __f2 (@(y) y-k, x);
+%!endfunction
+
+%!assert ((__f1 (3)) (10) == 7)
+
 %!test
-%! assert ((f1 (3)) (10) == 7)
-%!
-%!shared g
 %! g = @(t) feval (@(x) t*x, 2);
-%!assert (g(0.5) == 1)
-%!
-%!shared f, g, h
+%! assert (g(0.5) == 1);
+
+%!test
 %! h = @(x) sin (x);
 %! g = @(f, x) h (x);
 %! f = @() g (@(x) h, pi);
-%!assert (f () == sin (pi))
+%! assert (f () == sin (pi));
 */
 
 octave_value_list
 tree_anon_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2003-2011 John W. Eaton
+Copyright (C) 2003-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -108,16 +108,23 @@ tree_index_expression::~tree_index_expre
   delete expr;
 
   while (! args.empty ())
     {
       std::list<tree_argument_list *>::iterator p = args.begin ();
       delete *p;
       args.erase (p);
     }
+
+  while (! dyn_field.empty ())
+    {
+      std::list<tree_expression *>::iterator p = dyn_field.begin ();
+      delete *p;
+      dyn_field.erase (p);
+    }
 }
 
 bool
 tree_index_expression::has_magic_end (void) const
 {
   for (std::list<tree_argument_list *>::const_iterator p = args.begin ();
        p != args.end ();
        p++)
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -86,16 +86,17 @@ tree_do_until_command::accept (tree_walk
 {
   tw.visit_do_until_command (*this);
 }
 
 // For.
 
 tree_simple_for_command::~tree_simple_for_command (void)
 {
+  delete lhs;
   delete expr;
   delete maxproc;
   delete list;
   delete lead_comm;
   delete trail_comm;
 }
 
 tree_command *
@@ -114,16 +115,17 @@ tree_simple_for_command::dup (symbol_tab
 void
 tree_simple_for_command::accept (tree_walker& tw)
 {
   tw.visit_simple_for_command (*this);
 }
 
 tree_complex_for_command::~tree_complex_for_command (void)
 {
+  delete lhs;
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_complex_for_command::dup (symbol_table::scope_id scope,
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -1386,29 +1386,34 @@ tree_matrix::accept (tree_walker& tw)
 %!assert (class ([cell(1), struct('foo', 'bar')]), 'cell')
 %!error [struct('foo', 'bar'), cell(1)];
 */
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
 value is @code{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
      @result{} \"theseXX\"\n\
         \"areXXXX\"\n\
         \"strings\"\n\
 @end group\n\
 @end example\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
 %!error (string_fill_char (1, 2));
 %% string_fill_char() function call must be outside of %!test block
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt-walk.h b/src/pt-walk.h
--- a/src/pt-walk.h
+++ b/src/pt-walk.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt.cc b/src/pt.cc
--- a/src/pt.cc
+++ b/src/pt.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/pt.h b/src/pt.h
--- a/src/pt.h
+++ b/src/pt.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include <new>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "oct-syscalls.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 
 #include "debug.h"
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "load-save.h"
 #include "oct-map.h"
 #include "pager.h"
@@ -179,25 +180,18 @@ my_friendly_exit (const char *sig_name, 
           MINGW_SIGNAL_CLEANUP ();
 
           exit (1);
         }
       else
         {
           octave_set_signal_handler (sig_number, SIG_DFL);
 
-#if defined (HAVE_RAISE)
-          raise (sig_number);
-#elif defined (HAVE_KILL)
-          kill (getpid (), sig_number);
-#else
-          exit (1);
-#endif
+          gnulib::raise (sig_number);
         }
-
     }
 }
 
 sig_handler *
 octave_set_signal_handler (int sig, sig_handler *handler,
                            bool restart_syscalls)
 {
   struct sigaction act, oact;
@@ -799,17 +793,22 @@ make_sig_struct (void)
 octave_child_list::octave_child_list_rep *octave_child_list::instance = 0;
 
 bool
 octave_child_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_child_list_rep ();
+    {
+      instance = new octave_child_list_rep ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create child list object!");
 
       retval = false;
     }
 
@@ -950,20 +949,25 @@ Return a structure containing Unix signa
 %!assert (isstruct (SIG ()));
 %!assert (! isempty (SIG ()));
 */
 
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 /*
 %!error (debug_on_interrupt (1, 2));
 %!test
@@ -974,19 +978,24 @@ before reaching the debugging mode, a no
 %! debug_on_interrupt (orig_val);
 %! assert (debug_on_interrupt (), orig_val);
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a hangup signal.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
 /*
 %!error (sighup_dumps_octave_core (1, 2));
 %!test
@@ -997,19 +1006,24 @@ a hangup signal.\n\
 %! sighup_dumps_octave_core (orig_val);
 %! assert (sighup_dumps_octave_core (), orig_val);
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a terminate signal.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
 
 /*
 %!error (sigterm_dumps_octave_core (1, 2));
 %!test
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -165,11 +165,13 @@ public:
 
   static void remove (pid_t pid);
 
 private:
 
   static bool instance_ok (void);
 
   static octave_child_list_rep *instance;
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
 };
 
 #endif
diff --git a/src/siglist.c b/src/siglist.c
--- a/src/siglist.c
+++ b/src/siglist.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/siglist.h b/src/siglist.h
--- a/src/siglist.h
+++ b/src/siglist.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2000-2011 John W. Eaton
+Copyright (C) 2000-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse-xpow.h b/src/sparse-xpow.h
--- a/src/sparse-xpow.h
+++ b/src/sparse-xpow.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2004-2011 David Bateman
+Copyright (C) 2004-2012 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -172,17 +172,17 @@ to have a common size.\n\
                    m = args(3).idx_type_value ();
                    n = args(4).idx_type_value ();
                  }
                else
                  error ("sparse: expecting scalar dimensions");
 
 
                if (! error_state && (m < 0 || n < 0))
-                 error ("sparse: dimensions must be nonnegative");
+                 error ("sparse: dimensions must be non-negative");
              }
            else if (nargin != 3)
              print_usage ();
 
            if (! error_state)
              {
                idx_vector i = args(0).index_vector ();
                idx_vector j = args(1).index_vector ();
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1994-2011 John W. Eaton
+Copyright (C) 1994-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -857,35 +857,36 @@ DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
 Return a string containing the elements of @var{arg} listed in\n\
 columns with an overall maximum width of @var{width}.  The argument\n\
 @var{arg} must be a cell array of character strings or a character array.\n\
 If @var{width} is not specified, the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
 For example:\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@example\n\
+@smallexample\n\
 @group\n\
 list_in_columns (@{\"abc\", \"def\", \"ghijkl\", \"mnop\", \"qrs\", \"tuv\"@}, 20)\n\
      @result{} ans = abc     mnop\n\
             def     qrs\n\
             ghijkl  tuv\n\
 \n\
 whos ans\n\
      @result{}\n\
      Variables in the current scope:\n\
 \n\
        Attr Name        Size                     Bytes  Class\n\
        ==== ====        ====                     =====  =====\n\
             ans         1x37                        37  char\n\
 \n\
      Total is 37 elements using 37 bytes\n\
 @end group\n\
-@end example\n\
+@end smallexample\n\
 \n\
 @seealso{terminal_size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -20,34 +20,35 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "file-ops.h"
+#include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
-#include "file-ops.h"
-#include "file-stat.h"
+#include "singleton-cleanup.h"
 
+#include "debug.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "input.h"
 #include "load-path.h"
-#include "symtab.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-arg-list.h"
+#include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
-#include "debug.h"
 
 symbol_table *symbol_table::instance = 0;
 
 symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
 
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
@@ -65,16 +66,24 @@ symbol_table::scope_id symbol_table::xcu
 
 symbol_table::context_id symbol_table::xcurrent_context = 0;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
+symbol_table::scope_id_cache::create_instance (void)
+{
+  instance = new scope_id_cache ();
+
+  singleton_cleanup_list::add (cleanup_instance);
+}
+
+void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
   octave_value val = varval (xcurrent_context);
 
   os << prefix << name;
 
   if (val.is_defined ())
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -26,22 +26,23 @@ along with Octave; see the file COPYING.
 
 #include <deque>
 #include <list>
 #include <map>
 #include <set>
 #include <string>
 
 #include "glob-match.h"
-#include "regex-match.h"
+#include "regexp.h"
 
 class tree_argument_list;
 class octave_user_function;
 
 #include "oct-obj.h"
+#include "oct-refcount.h"
 #include "ov.h"
 
 class
 OCTINTERP_API
 symbol_table
 {
 public:
 
@@ -76,22 +77,24 @@ public:
         return instance->do_free (scope);
     }
 
     static std::list<scope_id> scopes (void)
     {
       return instance_ok () ? instance->do_scopes () : std::list<scope_id> ();
     }
 
+    static void create_instance (void);
+
     static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
-        instance = new scope_id_cache ();
+        create_instance ();
 
       if (! instance)
         {
           ::error ("unable to create scope_id_cache object!");
 
           retval = false;
         }
 
@@ -103,16 +106,18 @@ public:
     // No copying!
 
     scope_id_cache (const scope_id_cache&);
 
     scope_id_cache& operator = (const scope_id_cache&);
 
     static scope_id_cache *instance;
 
+    static void cleanup_instance (void) { delete instance; instance = 0; }
+
     // The next available scope not in the free list.
     scope_id next_available;
 
     // The set of scope IDs that are currently allocated.
     std::set<scope_id> in_use;
 
     // The set of scope IDs that are currently available.
     std::set<scope_id> free_list;
@@ -378,17 +383,17 @@ public:
       std::string name;
 
       std::deque<octave_value> value_stack;
 
       unsigned int storage_class;
 
       fcn_info *finfo;
 
-      size_t count;
+      octave_refcount<size_t> count;
 
     private:
 
       // No copying!
 
       symbol_record_rep (const symbol_record_rep& ov);
 
       symbol_record_rep& operator = (const symbol_record_rep&);
@@ -719,17 +724,17 @@ public:
       octave_value cmdline_function;
 
       octave_value autoload_function;
 
       octave_value function_on_path;
 
       octave_value built_in_function;
 
-      size_t count;
+      octave_refcount<size_t> count;
 
     private:
 
       octave_value xfind (const octave_value_list& args, bool local_funcs);
 
       octave_value x_builtin_find (void);
 
       // No copying!
@@ -1674,26 +1679,26 @@ public:
     return retval;
   }
 
   static std::list<symbol_record>
   regexp_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
-    regex_match pat (pattern);
+    ::regexp pat (pattern);
 
     for (global_table_const_iterator p = global_table.begin ();
          p != global_table.end (); p++)
       {
         // We generate a list of symbol_record objects so that
         // the results from regexp_variables and regexp_global_variables
         // may be handled the same way.
 
-        if (pat.match (p->first))
+        if (pat.is_match (p->first))
           retval.push_back (symbol_record (p->first, p->second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record> glob_variables (const string_vector& patterns)
@@ -2305,25 +2310,25 @@ private:
             if (pattern.match (sr.name ()))
               sr.clear ();
           }
       }
   }
 
   void do_clear_variable_regexp (const std::string& pat)
   {
-    regex_match pattern (pat);
+    ::regexp pattern (pat);
 
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
         symbol_record& sr = p->second;
 
         if (sr.is_defined () || sr.is_global ())
           {
-            if (pattern.match (sr.name ()))
+            if (pattern.is_match (sr.name ()))
               sr.clear ();
           }
       }
   }
 
   void do_mark_automatic (const std::string& name)
   {
     do_insert (name).mark_automatic ();
@@ -2380,21 +2385,21 @@ private:
     return retval;
   }
 
   std::list<symbol_record> do_regexp (const std::string& pattern,
                                       bool vars_only = false) const
   {
     std::list<symbol_record> retval;
 
-    regex_match pat (pattern);
+    ::regexp pat (pattern);
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
-        if (pat.match (p->first))
+        if (pat.is_match (p->first))
           {
             const symbol_record& sr = p->second;
 
             if (vars_only && ! sr.is_variable ())
               continue;
 
             retval.push_back (sr);
           }
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1996-2011 John W. Eaton
+Copyright (C) 1996-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -140,18 +140,18 @@ system-dependent error message.\n\
               int i_new = new_stream.file_number ();
 
               if (i_old >= 0 && i_new >= 0)
                 {
                   std::string msg;
 
                   int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
+                  retval(1) = msg;
                   retval(0) = status;
-                  retval(1) = msg;
                 }
             }
         }
       else
         error ("dup2: invalid stream");
     }
   else
     print_usage ();
@@ -219,18 +219,18 @@ error message.\n\
             }
 
           if (! error_state)
             {
               std::string msg;
 
               int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
+              retval(1) = msg;
               retval(0) = status;
-              retval(1) = msg;
             }
         }
       else
         error ("exec: FILE must be a string");
     }
   else
     print_usage ();
 
@@ -342,19 +342,19 @@ exit status, it will linger until Octave
                       octave_stream is = octave_stdiostream::create (nm, ifile,
                           std::ios::in);
 
                       octave_stream os = octave_stdiostream::create (nm, ofile,
                           std::ios::out);
 
                       Cell file_ids (1, 2);
 
-                      retval(0) = octave_stream_list::insert (os);
+                      retval(2) = pid;
                       retval(1) = octave_stream_list::insert (is);
-                                          retval(2) = pid;
+                      retval(0) = octave_stream_list::insert (os);
                     }
                                   else
                     error (msg.c_str ());
                 }
             }
           else
             error ("popen2: arguments must be character strings");
         }
@@ -491,18 +491,18 @@ system-dependent error message.\n\
               if (fid < 0)
                 error ("fcntl: invalid file id");
               else
                 {
                   std::string msg;
 
                   int status = octave_fcntl (fid, req, arg, msg);
 
+                  retval(1) = msg;
                   retval(0) = status;
-                  retval(1) = msg;
                 }
             }
         }
       else
         error ("fcntl: FID, REQUEST, and ARG must be integers");
     }
   else
     print_usage ();
@@ -541,18 +541,18 @@ action.  A system dependent error messag
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
       pid_t pid = octave_syscalls::fork (msg);
 
+      retval(1) = msg;
       retval(0) = pid;
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getpgrp", Fgetpgrp, args, ,
@@ -567,18 +567,18 @@ Return the process group id of the curre
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       std::string msg;
 
+      retval(1) = msg;
       retval(0) = octave_syscalls::getpgrp (msg);
-      retval(1) = msg;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getpid", Fgetpid, args, ,
@@ -860,20 +860,19 @@ system-dependent error message.\n\
           std::string nm;
 
           octave_stream is = octave_stdiostream::create (nm, ifile,
                                                          std::ios::in);
 
           octave_stream os = octave_stdiostream::create (nm, ofile,
                                                          std::ios::out);
 
+          retval(2) = status;
           retval(1) = octave_stream_list::insert (os);
           retval(0) = octave_stream_list::insert (is);
-
-          retval(2) = status;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -1265,18 +1264,18 @@ system-dependent error message.\n\
       if (args(0).is_string ())
         {
           std::string name = args(0).string_value ();
 
           std::string msg;
 
           int status = octave_unlink (name, msg);
 
+          retval(1) = msg;
           retval(0) = status;
-          retval(1) = msg;
         }
       else
         error ("unlink: FILE must be a string");
     }
   else
     print_usage ();
 
   return retval;
@@ -1349,19 +1348,19 @@ information about the subprocess that ex
           if (! error_state)
             {
               std::string msg;
 
               int status = 0;
 
               pid_t result = octave_syscalls::waitpid (pid, &status, options, msg);
 
-              retval(0) = result;
+              retval(2) = msg;
               retval(1) = status;
-              retval(2) = msg;
+              retval(0) = result;
             }
           else
             error ("waitpid: OPTIONS must be an integer");
         }
       else
         error ("waitpid: PID must be an integer value");
     }
   else
@@ -1639,218 +1638,263 @@ const_value (const octave_value_list& ar
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
-#if defined (F_DUPFD)
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
-Return the value required to request that @code{fcntl} return a\n\
+Return the numerical value to pass to @code{fcntl} to return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
-}
+#else
+  error ("F_DUPFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFD)
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFD)
   return const_value (args, F_GETFD);
-}
+#else
+  error ("F_GETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_GETFL)
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_GETFL)
   return const_value (args, F_GETFL);
-}
+#else
+  error ("F_GETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFD)
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
+#if defined (F_SETFD)
   return const_value (args, F_SETFD);
-}
+#else
+  error ("F_SETFD: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (F_SETFL)
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
+#if defined (F_SETFL)
   return const_value (args, F_SETFL);
-}
+#else
+  error ("F_SETFL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_APPEND)
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_APPEND)
   return const_value (args, O_APPEND);
-}
+#else
+  error ("O_APPEND: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_ASYNC)
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
-}
+#else
+  error ("O_ASYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_CREAT)
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be\n\
 created if it does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_CREAT)
   return const_value (args, O_CREAT);
-}
+#else
+  error ("O_CREAT: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_EXCL)
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_EXCL)
   return const_value (args, O_EXCL);
-}
+#else
+  error ("O_EXCL: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_NONBLOCK)
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
-}
+#else
+  error ("O_NONBLOCK: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDONLY)
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
-}
+#else
+  error ("O_RDONLY: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_RDWR)
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both\n\
 reading and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_RDWR)
   return const_value (args, O_RDWR);
-}
+#else
+  error ("O_RDWR: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_SYNC)
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_SYNC)
   return const_value (args, O_SYNC);
-}
+#else
+  error ("O_SYNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_TRUNC)
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should\n\
 be truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
+#if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
-}
+#else
+  error ("O_TRUNC: not available on this system");
+  return octave_value ();
 #endif
+}
 
-#if defined (O_WRONLY)
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
+#if defined (O_WRONLY)
   return const_value (args, O_WRONLY);
+#else
+  error ("O_WRONLY: not available on this system");
+  return octave_value ();
+#endif
 }
-#endif
 
 #if !defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WNOHANG ()\n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -283,17 +283,17 @@ sysdep_cleanup (void)
 // It doesn't matter whether an input \n is mapped to \r, or vice versa.
 
 void
 raw_mode (bool on, bool wait)
 {
   static bool curr_on = false;
 
   int tty_fd = STDIN_FILENO;
-  if (! isatty (tty_fd))
+  if (! gnulib::isatty (tty_fd))
     {
       if (interactive)
         error ("stdin is not a tty!");
       return;
     }
 
   if (on == curr_on)
     return;
@@ -891,12 +891,12 @@ tilde_expand (\"~/bin\")\n\
 }
 
 /*
 %!test
 %! if (isempty (getenv ("HOME")))
 %!   setenv ("HOME", "foobar");
 %! endif
 %! home = getenv ("HOME");
-%! assert (tilde_expand ("~/foobar"), [home filesep() "foobar"]);
+%! assert (tilde_expand ("~/foobar"), strcat (home, "/foobar"));
 %! assert (tilde_expand ("/foo/bar"), "/foo/bar");
 %! assert (tilde_expand ("foo/bar"), "foo/bar");
 */
diff --git a/src/sysdep.h b/src/sysdep.h
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1995-2011 John W. Eaton
+Copyright (C) 1995-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -39,46 +39,48 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "oct-env.h"
+#include "oct-locbuf.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "oct-locbuf.h"
 
-#include <defaults.h>
+#include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
+#include "graphics.h"
 #include "input.h"
 #include "lex.h"
-#include <oct-conf.h>
+#include "oct-conf.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-obj.h"
+#include "ov.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
-#include "ov.h"
 #include "pt-eval.h"
 #include "pt-jump.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
-#include <version.h>
+#include "version.h"
 
 void (*octave_exit) (int) = ::exit;
 
 // TRUE means the quit() call is allowed.
 bool quit_allowed = true;
 
 // TRUE means we are exiting via the builtin exit or quit functions.
 bool quitting_gracefully = false;
@@ -92,16 +94,29 @@ bool octave_interpreter_ready = false;
 // TRUE means we've processed all the init code and we are good to go.
 bool octave_initialized = false;
 
 // Current command to execute.
 tree_statement_list *global_command = 0;
 
 octave_call_stack *octave_call_stack::instance = 0;
 
+void
+octave_call_stack::create_instance (void)
+{
+  instance = new octave_call_stack ();
+
+  if (instance)
+    {
+      instance->do_push (0, symbol_table::top_scope (), 0);
+
+      singleton_cleanup_list::add (cleanup_instance);
+    }
+}
+
 int
 octave_call_stack::do_current_line (void) const
 {
   tree_statement *stmt = do_current_statement ();
 
   return stmt ? stmt->line () : -1;
 }
 
@@ -566,21 +581,23 @@ main_loop (void)
 
           // This is the same as yyparse in parse.y.
           retval = octave_parse ();
 
           if (retval == 0)
             {
               if (global_command)
                 {
-                  global_command->accept (*current_evaluator);
+                  // Use an unwind-protect cleanup function so that the
+                  // global_command list will be deleted in the event of
+                  // an interrupt.
 
-                  delete global_command;
+                  frame.add_fcn (cleanup_statement_list, &global_command);
 
-                  global_command = 0;
+                  global_command->accept (*current_evaluator);
 
                   octave_quit ();
 
                   if (! (interactive || forced_interactive))
                     {
                       bool quit = (tree_return_command::returning
                                    || tree_break_command::breaking);
 
@@ -640,47 +657,23 @@ main_loop (void)
             << std::endl;
         }
     }
   while (retval == 0);
 
   return retval;
 }
 
-// Call a function with exceptions handled to avoid problems with
-// errors while shutting down.
-
-#define IGNORE_EXCEPTION(E) \
-  catch (E) \
-    { \
-      std::cerr << "error: ignoring " #E " while preparing to exit" << std::endl; \
-      recover_from_exception (); \
-    }
-
-#define SAFE_CALL(F, ARGS) \
-  try \
-    { \
-      F ARGS; \
-    } \
-  IGNORE_EXCEPTION (octave_interrupt_exception) \
-  IGNORE_EXCEPTION (octave_execution_exception) \
-  IGNORE_EXCEPTION (std::bad_alloc)
-
 // Fix up things before exiting.
 
 void
 clean_up_and_exit (int retval)
 {
   do_octave_atexit ();
 
-  // Clean up symbol table.
-  SAFE_CALL (symbol_table::cleanup, ());
-
-  SAFE_CALL (sysdep_cleanup, ())
-
   if (octave_exit)
     (*octave_exit) (retval == EOF ? 0 : retval);
 }
 
 DEFUN (quit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
@@ -700,19 +693,23 @@ Octave's exit status.  The default value
           int tmp = args(0).nint_value ();
 
           if (! error_state)
             exit_status = tmp;
         }
 
       if (! error_state)
         {
-          quitting_gracefully = true;
+          // Instead of simply calling exit, we simulate an interrupt
+          // with a request to exit cleanly so that no matter where the
+          // call to quit occurs, we will run the unwind_protect stack,
+          // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
+          // exiting.
 
-          // Simulate interrupt.
+          quitting_gracefully = true;
 
           octave_interrupt_state = -1;
 
           octave_throw_interrupt_exception ();
         }
     }
 
   return retval;
@@ -811,70 +808,76 @@ run_command_and_return_output (const std
 
       int cmd_status = cmd->close ();
 
       if (WIFEXITED (cmd_status))
         cmd_status = WEXITSTATUS (cmd_status);
       else
         cmd_status = 127;
 
+      retval(1) = output_buf.str ();
       retval(0) = cmd_status;
-      retval(1) = output_buf.str ();
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{status}, @var{output}]} system (@var{string}, @var{return_output}, @var{type})\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{output}]} shell_cmd (@var{string}, @var{return_output}, @var{type})\n\
+@deftypefn  {Built-in Function} {} system (\"@var{string}\")\n\
+@deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output})\n\
+@deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output}, @var{type})\n\
+@deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} system (@dots{})\n\
 Execute a shell command specified by @var{string}.\n\
-If the optional argument @var{type} is @code{\"async\"}, the process\n\
-is started in the background and the process id of the child process\n\
-is returned immediately.  Otherwise, the process is started, and\n\
-Octave waits until it exits.  If the @var{type} argument is omitted, a\n\
-value of @code{\"sync\"} is assumed.\n\
+If the optional argument @var{type} is \"async\", the process\n\
+is started in the background and the process ID of the child process\n\
+is returned immediately.  Otherwise, the child process is started and\n\
+Octave waits until it exits.  If the @var{type} argument is omitted, it\n\
+defaults to the value \"sync\".\n\
 \n\
-If the optional argument @var{return_output} is true and the subprocess\n\
-is started synchronously, or if @var{system} is called with one input\n\
-argument and one or more output arguments, the output from the command\n\
-is returned.  Otherwise, if the subprocess is executed synchronously, its\n\
-output is sent to the standard output.  To send the output of a command\n\
-executed with @code{system} through the pager, use a command like\n\
+If @var{system} is called with one or more output arguments, or if the\n\
+optional argument @var{return_output} is true and the subprocess is started\n\
+synchronously, then the output from the command is returned as a variable.  \n\
+Otherwise, if the subprocess is executed synchronously, its output is sent\n\
+to the standard output.  To send the output of a command executed with\n\
+@code{system} through the pager, use a command like\n\
 \n\
 @example\n\
-disp (system (cmd, 1));\n\
+@group\n\
+[output, text] = system (\"cmd\");\n\
+disp (text);\n\
+@end group\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
 \n\
 @example\n\
-printf (\"%s\\n\", system (cmd, 1));\n\
+printf (\"%s\\n\", nthargout (2, \"system\", \"cmd\"));\n\
 @end example\n\
 \n\
 The @code{system} function can return two values.  The first is the\n\
 exit status of the command and the second is any output from the\n\
 command that was written to the standard output stream.  For example,\n\
 \n\
 @example\n\
 [status, output] = system (\"echo foo; exit 2\");\n\
 @end example\n\
 \n\
 @noindent\n\
 will set the variable @code{output} to the string @samp{foo}, and the\n\
 variable @code{status} to the integer @samp{2}.\n\
 \n\
 For commands run asynchronously, @var{status} is the process id of the\n\
 command shell that is started to run the command.\n\
+@seealso{unix, dos}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   int nargin = args.length ();
 
@@ -995,30 +998,26 @@ command shell that is started to run the
         error ("system: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFALIAS (shell_cmd, system);
-
 /*
-%!error (system ());
-%!error (system (1, 2, 3));
 %!test
-%! if (ispc ())
-%!   cmd = "dir";
-%! else
-%!   cmd = "ls";
-%! endif
+%! cmd = ls_command ();
 %! [status, output] = system (cmd);
+%! assert (status, 0);
 %! assert (ischar (output));
 %! assert (! isempty (output));
+
+%!error system ()
+%!error system (1, 2, 3)
 */
 
 // FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::list<std::string> octave_atexit_functions;
 
 void
 do_octave_atexit (void)
@@ -1026,57 +1025,81 @@ do_octave_atexit (void)
   static bool deja_vu = false;
 
   while (! octave_atexit_functions.empty ())
     {
       std::string fcn = octave_atexit_functions.front ();
 
       octave_atexit_functions.pop_front ();
 
-      SAFE_CALL (reset_error_handler, ())
+      OCTAVE_SAFE_CALL (reset_error_handler, ());
 
-      SAFE_CALL (feval, (fcn, octave_value_list (), 0))
+      OCTAVE_SAFE_CALL (feval, (fcn, octave_value_list (), 0));
 
-      SAFE_CALL (flush_octave_stdout, ())
+      OCTAVE_SAFE_CALL (flush_octave_stdout, ());
     }
 
   if (! deja_vu)
     {
       deja_vu = true;
 
       // Do this explicitly so that destructors for mex file objects
       // are called, so that functions registered with mexAtExit are
       // called.
-      SAFE_CALL (clear_mex_functions, ())
+      OCTAVE_SAFE_CALL (clear_mex_functions, ());
 
-        SAFE_CALL (command_editor::restore_terminal_state, ())
+      OCTAVE_SAFE_CALL (command_editor::restore_terminal_state, ());
 
       // FIXME -- is this needed?  Can it cause any trouble?
-      SAFE_CALL (raw_mode, (0))
+      OCTAVE_SAFE_CALL (raw_mode, (0));
 
-      SAFE_CALL (octave_history_write_timestamp, ())
+      OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
 
       if (! command_history::ignoring_entries ())
-        SAFE_CALL (command_history::clean_up_and_save, ())
+        OCTAVE_SAFE_CALL (command_history::clean_up_and_save, ());
+
+      OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
 
-      SAFE_CALL (close_files, ())
+      OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
+
+      OCTAVE_SAFE_CALL (close_files, ());
 
-      SAFE_CALL (cleanup_tmp_files, ())
+      OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
+
+      OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
 
-      SAFE_CALL (flush_octave_stdout, ())
+      OCTAVE_SAFE_CALL (cleanup_parser, ());
+
+      OCTAVE_SAFE_CALL (sysdep_cleanup, ());
+
+      OCTAVE_SAFE_CALL (flush_octave_stdout, ());
 
       if (! quitting_gracefully && (interactive || forced_interactive))
         {
           octave_stdout << "\n";
 
           // Yes, we want this to be separate from the call to
           // flush_octave_stdout above.
 
-          SAFE_CALL (flush_octave_stdout, ())
+          OCTAVE_SAFE_CALL (flush_octave_stdout, ());
         }
+
+      // Don't call singleton_cleanup_list::cleanup until we have the
+      // problems with registering/unregistering types worked out.  For
+      // example, uncomment the following line, then use the make_int
+      // function from the examples directory to create an integer
+      // object and then exit Octave.  Octave should crash with a
+      // segfault when cleaning up the typinfo singleton.  We need some
+      // way to force new octave_value_X types that are created in
+      // .oct files to be unregistered when the .oct file shared library
+      // is unloaded.
+      //
+      // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
+
+      OCTAVE_SAFE_CALL (octave_chunk_buffer::clear, ());
     }
 }
 
 void
 octave_add_atexit_function (const std::string& fname)
 {
   octave_atexit_functions.push_front (fname);
 }
@@ -1217,16 +1240,19 @@ specified option.\n\
       { false, "ALL_CXXFLAGS", OCTAVE_CONF_ALL_CXXFLAGS },
       { false, "ALL_FFLAGS", OCTAVE_CONF_ALL_FFLAGS },
       { false, "ALL_LDFLAGS", OCTAVE_CONF_ALL_LDFLAGS },
       { false, "AMD_CPPFLAGS", OCTAVE_CONF_AMD_CPPFLAGS },
       { false, "AMD_LDFLAGS", OCTAVE_CONF_AMD_LDFLAGS },
       { false, "AMD_LIBS", OCTAVE_CONF_AMD_LIBS },
       { false, "AR", OCTAVE_CONF_AR },
       { false, "ARFLAGS", OCTAVE_CONF_ARFLAGS },
+      { false, "ARPACK_CPPFLAGS", OCTAVE_CONF_ARPACK_CPPFLAGS },
+      { false, "ARPACK_LDFLAGS", OCTAVE_CONF_ARPACK_LDFLAGS },
+      { false, "ARPACK_LIBS", OCTAVE_CONF_ARPACK_LIBS },
       { false, "BLAS_LIBS", OCTAVE_CONF_BLAS_LIBS },
       { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
       { false, "CAMD_CPPFLAGS", OCTAVE_CONF_CAMD_CPPFLAGS },
       { false, "CAMD_LDFLAGS", OCTAVE_CONF_CAMD_LDFLAGS },
       { false, "CAMD_LIBS", OCTAVE_CONF_CAMD_LIBS },
       { false, "CC", OCTAVE_CONF_CC },
       { false, "CC_VERSION", OCTAVE_CONF_CC_VERSION },
       { false, "CCOLAMD_CPPFLAGS", OCTAVE_CONF_CCOLAMD_CPPFLAGS },
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -107,32 +107,30 @@ protected:
 public:
 
   typedef std::deque<call_stack_elt>::iterator iterator;
   typedef std::deque<call_stack_elt>::const_iterator const_iterator;
 
   typedef std::deque<call_stack_elt>::reverse_iterator reverse_iterator;
   typedef std::deque<call_stack_elt>::const_reverse_iterator const_reverse_iterator;
 
+  static void create_instance (void);
+  
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
-      {
-        instance = new octave_call_stack ();
+      create_instance ();
 
-        if (instance)
-          instance->do_push (0, symbol_table::top_scope (), 0);
-        else
-          {
-            ::error ("unable to create call stack object!");
+    if (! instance)
+      {
+        ::error ("unable to create call stack object!");
 
-            retval = false;
-          }
+        retval = false;
       }
 
     return retval;
   }
 
   // Current function (top of stack).
   static octave_function *current (void)
   {
@@ -295,16 +293,18 @@ private:
 
   // The current call stack.
   std::deque<call_stack_elt> cs;
 
   size_t curr_frame;
 
   static octave_call_stack *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int do_current_line (void) const;
 
   int do_current_column (void) const;
 
   int do_caller_user_code_line (void) const;
 
   int do_caller_user_code_column (void) const;
 
@@ -413,9 +413,43 @@ private:
       }
   }
 
   void do_clear (void) { cs.clear (); }
 
   void do_backtrace_error_message (void) const;
 };
 
+// Call a function with exceptions handled to avoid problems with
+// errors while shutting down.
+
+#define OCTAVE_IGNORE_EXCEPTION(E) \
+  catch (E) \
+    { \
+      std::cerr << "error: ignoring " #E " while preparing to exit" << std::endl; \
+      recover_from_exception (); \
+    }
+
+#define OCTAVE_SAFE_CALL(F, ARGS) \
+  do \
+    { \
+      try \
+        { \
+          unwind_protect frame; \
+ \
+          frame.protect_var (Vdebug_on_error); \
+          frame.protect_var (Vdebug_on_warning); \
+ \
+          Vdebug_on_error = false; \
+          Vdebug_on_warning = false; \
+ \
+          F ARGS; \
+        } \
+      OCTAVE_IGNORE_EXCEPTION (octave_interrupt_exception) \
+      OCTAVE_IGNORE_EXCEPTION (octave_execution_exception) \
+      OCTAVE_IGNORE_EXCEPTION (std::bad_alloc) \
+ \
+      if (error_state) \
+        error_state = 0; \
+    } \
+  while (0)
+
 #endif
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -19,24 +19,26 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#if HAVE_FREETYPE
+#if defined (HAVE_FREETYPE)
 
-#if HAVE_FONTCONFIG
+#if defined (HAVE_FONTCONFIG)
 #include <fontconfig/fontconfig.h>
 #endif
 
 #include <iostream>
 
+#include "singleton-cleanup.h"
+
 #include "error.h"
 #include "pr-output.h"
 #include "txt-eng-ft.h"
 
 // FIXME -- maybe issue at most one warning per glyph/font/size/weight
 // combination.
 
 static void
@@ -67,28 +69,35 @@ class
 ft_manager
 {
 public:
   static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
-        instance = new ft_manager ();
+        {
+          instance = new ft_manager ();
+
+          if (instance)
+            singleton_cleanup_list::add (cleanup_instance);
+        }
 
       if (! instance)
         {
           ::error ("unable to create ft_manager!");
 
           retval = false;
         }
 
       return retval;
     }
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static FT_Face get_font (const std::string& name, const std::string& weight,
                            const std::string& angle, double size)
     { return (instance_ok ()
               ? instance->do_get_font (name, weight, angle, size)
               : 0); }
 
 private:
 
@@ -97,56 +106,58 @@ private:
 private:
 
   // No copying!
 
   ft_manager (const ft_manager&);
 
   ft_manager& operator = (const ft_manager&);
 
-  ft_manager (void) : library ()
-#if HAVE_FONTCONFIG
-    , fc_init_done (false)
-#endif
+  ft_manager (void)
+    : library (), freetype_initialized (false), fontconfig_initialized (false)
     {
       if (FT_Init_FreeType (&library))
-        {
-          ::error ("unable to initialize freetype library");
-        }
+        ::error ("unable to initialize freetype library");
+      else
+        freetype_initialized = true;
 
-#if HAVE_FONTCONFIG
-      fc_init_done = false;
+#if defined (HAVE_FONTCONFIG)
       if (! FcInit ())
-        {
-          ::error ("unable to initialize fontconfig library");
-        }
+        ::error ("unable to initialize fontconfig library");
       else
-        {
-          fc_init_done = true;
-        }
+        fontconfig_initialized = true;
 #endif
     }
 
   ~ft_manager (void)
     {
-#if HAVE_FONTCONFIG
-      FcFini ();
-      fc_init_done = false;
+      if (freetype_initialized)
+        FT_Done_FreeType (library);
+
+#if defined (HAVE_FONTCONFIG)
+      // FIXME -- Skip the call to FcFini because it can trigger the
+      // assertion
+      //
+      //   octave: fccache.c:507: FcCacheFini: Assertion `fcCacheChains[i] == ((void *)0)' failed.
+      //
+      // if (fontconfig_initialized)
+      //   FcFini ();
 #endif
     }
 
+
   FT_Face do_get_font (const std::string& name, const std::string& weight,
                        const std::string& angle, double size)
     {
       FT_Face retval = 0;
 
       std::string file;
 
-#if HAVE_FONTCONFIG
-      if (fc_init_done)
+#if defined (HAVE_FONTCONFIG)
+      if (fontconfig_initialized)
         {
           int fc_weight, fc_angle;
 
           if (weight == "bold")
             fc_weight = FC_WEIGHT_BOLD;
           else if (weight == "light")
             fc_weight = FC_WEIGHT_LIGHT;
           else if (weight == "demi")
@@ -213,19 +224,18 @@ private:
       if (! file.empty () && FT_New_Face (library, file.c_str (), 0, &retval))
         ::warning ("ft_manager: unable to load font: %s", file.c_str ());
 
       return retval;
     }
 
 private:
   FT_Library library;
-#if HAVE_FONTCONFIG
-  bool fc_init_done;
-#endif
+  bool freetype_initialized;
+  bool fontconfig_initialized;
 };
 
 ft_manager* ft_manager::instance = 0;
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
     : text_processor (), face (0), bbox (1, 4, 0.0),
diff --git a/src/txt-eng-ft.h b/src/txt-eng-ft.h
--- a/src/txt-eng-ft.h
+++ b/src/txt-eng-ft.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/txt-eng.h b/src/txt-eng.h
--- a/src/txt-eng.h
+++ b/src/txt-eng.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 Michael Goffioul
+Copyright (C) 2009-2012 Michael Goffioul
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -31,16 +31,18 @@ along with Octave; see the file COPYING.
 
 #include <fstream>
 #include <iostream>
 #include <string>
 
 #include <sys/types.h>
 #include <unistd.h>
 
+#include "vasnprintf.h"
+
 #include "quit.h"
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "oct-cmplx.h"
@@ -1189,148 +1191,68 @@ float_identity_matrix (octave_idx_type n
 
       for (octave_idx_type i = 0; i < n; i++)
         m (i, i) = 1.0;
     }
 
   return m;
 }
 
-int
+size_t
 octave_format (std::ostream& os, const char *fmt, ...)
 {
-  int retval = -1;
+  size_t retval;
 
   va_list args;
   va_start (args, fmt);
 
   retval = octave_vformat (os, fmt, args);
 
   va_end (args);
 
   return retval;
 }
 
-int
+size_t
 octave_vformat (std::ostream& os, const char *fmt, va_list args)
 {
-  int retval = -1;
+  std::string s = octave_vasprintf (fmt, args);
 
-#if defined (__GNUG__) && !CXX_ISO_COMPLIANT_LIBRARY
+  os << s;
 
-  std::streambuf *sb = os.rdbuf ();
+  return s.length ();
+}
 
-  if (sb)
-    {
-      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+std::string
+octave_vasprintf (const char *fmt, va_list args)
+{
+  std::string retval;
+
+  char *result;
 
-      retval = sb->vform (fmt, args);
+  int status = gnulib::vasprintf (&result, fmt, args);
 
-      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+  if (status >= 0)
+    {
+      retval = result;
+      ::free (result);
     }
 
-#else
-
-  char *s = octave_vsnprintf (fmt, args);
-
-  if (s)
-    {
-      os << s;
-
-      retval = strlen (s);
-    }
-
-#endif
-
   return retval;
 }
 
-// We manage storage.  User should not free it, and its contents are
-// only valid until next call to vsnprintf.
-
-// Interrupts might happen if someone makes a call with something that
-// will require a very large buffer.  If we are interrupted in that
-// case, we should make the buffer size smaller for the next call.
-
-#define BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_FOR_VSNPRINTF \
-  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_1; \
-  delete [] buf; \
-  buf = 0; \
-  size = initial_size; \
-  octave_rethrow_exception (); \
-  BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_2
-
-#if defined __GNUC__ && defined __va_copy
-#define SAVE_ARGS(saved_args, args) __va_copy (saved_args, args)
-#elif defined va_copy
-#define SAVE_ARGS(saved_args, args) va_copy (saved_args, args)
-#else
-#define SAVE_ARGS(saved_args, args) saved_args = args
-#endif
-
-char *
-octave_vsnprintf (const char *fmt, va_list args)
+std::string
+octave_asprintf (const char *fmt, ...)
 {
-  static const size_t initial_size = 100;
-
-  static size_t size = initial_size;
-
-  static char *buf = 0;
-
-  volatile int nchars = 0;
-
-  if (! buf)
-    buf = new char [size];
-
-  if (! buf)
-    return 0;
-
-  while (1)
-    {
-      va_list saved_args;
-
-      SAVE_ARGS (saved_args, args);
-
-      BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE_FOR_VSNPRINTF;
-
-      nchars = octave_raw_vsnprintf (buf, size, fmt, saved_args);
-
-      va_end (saved_args);
-
-      END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-      // Cast to avoid signed/unsigned comparison is safe due to
-      // short-circuiting
-      if (nchars > -1 && static_cast<size_t>(nchars) < size)
-        break;
-      else
-        {
-          delete [] buf;
-
-          size = nchars + 1;;
-
-          buf = new char [size];
-
-          if (! buf)
-            return 0;
-        }
-    }
-
-  return buf;
-}
-
-char *
-octave_snprintf (const char *fmt, ...)
-{
-  char *retval = 0;
+  std::string retval;
 
   va_list args;
   va_start (args, fmt);
 
-  retval = octave_vsnprintf (fmt, args);
+  retval = octave_vasprintf (fmt, args);
 
   va_end (args);
 
   return retval;
 }
 
 void
 octave_sleep (double seconds)
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -98,25 +98,26 @@ extern OCTINTERP_API octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx);
 
 extern OCTINTERP_API Matrix
 identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
 extern OCTINTERP_API FloatMatrix
 float_identity_matrix (octave_idx_type nr, octave_idx_type nc);
 
-extern OCTINTERP_API int
+extern OCTINTERP_API size_t
 octave_format (std::ostream& os, const char *fmt, ...);
 
-extern OCTINTERP_API int
+extern OCTINTERP_API size_t
 octave_vformat (std::ostream& os, const char *fmt, va_list args);
 
-extern OCTINTERP_API char *octave_vsnprintf (const char *fmt, va_list args);
+extern OCTINTERP_API std::string
+octave_vasprintf (const char *fmt, va_list args);
 
-extern OCTINTERP_API char *octave_snprintf (const char *fmt, ...);
+extern OCTINTERP_API std::string octave_asprintf (const char *fmt, ...);
 
 extern OCTINTERP_API void octave_sleep (double seconds);
 
 extern OCTINTERP_API
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args,
                    int nargout);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <iomanip>
 #include <set>
 #include <string>
 
 #include "file-stat.h"
 #include "oct-env.h"
 #include "file-ops.h"
 #include "glob-match.h"
-#include "regex-match.h"
+#include "regexp.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
@@ -2045,19 +2045,17 @@ name_matches_any_pattern (const std::str
 
   for (int k = idx; k < argc; k++)
     {
       std::string patstr = argv[k];
       if (! patstr.empty ())
         {
           if (have_regexp)
             {
-              regex_match pattern (patstr);
-
-              if (pattern.match (nm))
+              if (is_regexp_match (patstr, nm))
                 {
                   retval = true;
                   break;
                 }
             }
           else
             {
               glob_match pattern (patstr);
@@ -2457,16 +2455,17 @@ without the dash as well.\n\
 
   return retval;
 }
 
 DEFUN (whos_line_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} whos_line_format (@var{new_val}, \"local\")\n\
 Query or set the format string used by the command @code{whos}.\n\
 \n\
 A full format string is:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 %[modifier]<command>[:width[:left-min[:balance]]];\n\
 @end smallexample\n\
@@ -2518,30 +2517,39 @@ The parameters @code{left-min} and @code
 column-aligned modifier is used with the command @samp{%s}.\n\
 @code{balance} specifies the column number within the field width which will\n\
 be aligned between entries.  Numbering starts from 0 which indicates the\n\
 leftmost column.  @code{left-min} specifies the minimum field width to the\n\
 left of the specified balance column.\n\
 \n\
 The default format is\n\
 @code{\"  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\\n\"}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 static std::string Vmissing_function_hook = "unimplemented";
 
 DEFUN (missing_function_hook, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} missing_function_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 an unknown identifier is requested.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (missing_function_hook);
 }
 
 void maybe_missing_function_hook (const std::string& name)
 {
   // Don't do this if we're handling errors.
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/version.h.in b/src/version.h.in
--- a/src/version.h.in
+++ b/src/version.h.in
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1992-2011 John W. Eaton
+Copyright (C) 1992-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -83,10 +83,9 @@ For more information, visit http://www.o
 
 #define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS ("")
 
 #define OCTAVE_STARTUP_MESSAGE \
   X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
     ("  For details, type `warranty'.") "\n\n" \
   "For information about changes from previous versions, type `news'."
-
 #endif
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2008 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/xgl2ps.c b/src/xgl2ps.c
--- a/src/xgl2ps.c
+++ b/src/xgl2ps.c
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2009-2011 John W. Eaton
+Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xnorm.cc b/src/xnorm.cc
--- a/src/xnorm.cc
+++ b/src/xnorm.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xnorm.h b/src/xnorm.h
--- a/src/xnorm.h
+++ b/src/xnorm.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2008-2011 VZLU Prague, a.s.
+Copyright (C) 2008-2012 VZLU Prague, a.s.
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 Copyright (C) 2009-2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -1240,17 +1240,17 @@ elem_xpow (const NDArray& a, const NDArr
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           //Potentially complex results
           NDArray xa = octave_value_extract<NDArray> (a);
           NDArray xb = octave_value_extract<NDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
@@ -1328,17 +1328,17 @@ elem_xpow (const NDArray& a, const Compl
 octave_value
 elem_xpow (const NDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
@@ -1427,17 +1427,17 @@ elem_xpow (const ComplexNDArray& a, doub
 octave_value
 elem_xpow (const ComplexNDArray& a, const NDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
@@ -1477,17 +1477,17 @@ elem_xpow (const ComplexNDArray& a, cons
 octave_value
 elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
@@ -2593,17 +2593,17 @@ elem_xpow (const FloatNDArray& a, const 
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           //Potentially complex results
           FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
           FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
@@ -2681,17 +2681,17 @@ elem_xpow (const FloatNDArray& a, const 
 octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
@@ -2780,17 +2780,17 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
@@ -2830,17 +2830,17 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun (a_dims, b_dims))
+      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
         {
           gripe_nonconformant ("operator .^", a_dims, b_dims);
           return octave_value ();
         }
diff --git a/src/xpow.h b/src/xpow.h
--- a/src/xpow.h
+++ b/src/xpow.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 1993-2011 John W. Eaton
+Copyright (C) 1993-2012 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
+Copyright (C) 2005-2012 Ludwig Schwardt, Kevin Ruland
 
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
+Copyright (C) 2005-2012 Ludwig Schwardt, Kevin Ruland
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -1,11 +1,11 @@
 # Makefile for octave's test directory
 #
-# Copyright (C) 1994-2011 John W. Eaton
+# Copyright (C) 1994-2012 John W. Eaton
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -18,29 +18,27 @@
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
   test_args.m \
-  test_contin.m \
   test_diag_perm.m \
   test_error.m \
   test_eval-catch.m \
   test_for.m \
   test_func.m \
   test_global.m \
   test_if.m \
-  test_index-wfi-f.m \
-  test_index-wfi-t.m \
+  test_index.m \
   test_io.m \
-  test_logical-wfi-f.m \
-  test_logical-wfi-t.m \
+  test_line_continue.m \
+  test_logical_index.m \
   test_null_assign.m \
   test_parser.m \
   test_prefer.m \
   test_range.m \
   test_recursion.m \
   test_return.m \
   test_slice.m \
   test_struct.m \
diff --git a/test/build_bc_overload_tests.sh b/test/build_bc_overload_tests.sh
--- a/test/build_bc_overload_tests.sh
+++ b/test/build_bc_overload_tests.sh
@@ -1,11 +1,11 @@
 #! /bin/sh
 
-# Copyright (C) 2010-2011 VZLU Prague
+# Copyright (C) 2010-2012 VZLU Prague
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -42,35 +42,38 @@ else
   echo "usage: build_bc_overload_tests.sh expected-results-file" 1>&2
   exit 1
 fi
 
 for class in $CLASSES; do
   DIR="@$class"
   test -d $DIR || mkdir $DIR || { echo "error: could not create $DIR"; exit; }
   cat > $DIR/tbcover.m << EOF
-% DO NOT EDIT - generated automatically
+% !!! DO NOT EDIT !!!
+% generated automatically by build_bc_overload_tests.sh
 function s = tbcover (x, y)
   s = '$class';
 EOF
 done
 
 cat > tbcover.m << EOF
-% DO NOT EDIT - generated automatically
+% !!! DO NOT EDIT !!!
+% generated automatically by build_bc_overload_tests.sh
 function s = tbcover (x, y)
   s = 'none';
 EOF
 
 if test "$1" = "overloads_only" ; then
   exit
 fi
 
 cat > test_bc_overloads.m << EOF
-## THIS IS AN AUTOMATICALLY GENERATED FILE --- DO NOT EDIT ---
-## instead modify build_bc_overload_tests.sh to generate the tests that you want.
+## !!! DO NOT EDIT !!!
+## THIS IS AN AUTOMATICALLY GENERATED FILE
+## modify build_bc_overload_tests.sh to generate the tests you need.
 
 %!shared ex
 %! ex.double = 1;
 %! ex.single = single(1);
 %! ex.logical = true;
 %! ex.char = 'char';
 %! ex.int8  = int8 (1);
 %! ex.int16 = int16 (1);
diff --git a/test/build_bc_overloads_expected.m b/test/build_bc_overloads_expected.m
--- a/test/build_bc_overloads_expected.m
+++ b/test/build_bc_overloads_expected.m
@@ -1,12 +1,12 @@
 % this script is intended to be Matlab compatible
 % first, run the script
 %
-%   ./build_bc_overloads_tests.sh overloads_onely
+%   ./build_bc_overloads_tests.sh overloads_only
 %
 % to generate the overloaded functions.
 %
 ex.double = 1;
 ex.single = single(1);
 ex.logical = true;
 ex.char = 'char';
 ex.int8  = int8 (1);
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -1,11 +1,11 @@
 #!/bin/sh
 
-# Copyright (C) 2006-2011 David Bateman
+# Copyright (C) 2006-2012 David Bateman
 #
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 3 of the License, or (at
 # your option) any later version.
 # 
@@ -116,18 +116,19 @@ esac
 if $preset; then
     TESTS=test_sparse.m
 else
     TESTS=test_sprandom.m
 fi
 
 # create initial file
 cat >$TESTS <<EOF
-## THIS IS AN AUTOMATICALLY GENERATED FILE --- DO NOT EDIT ---
-## instead modify build_sparse_tests.sh to generate the tests that you want.
+## !!! DO NOT EDIT !!!
+## THIS IS AN AUTOMATICALLY GENERATED FILE
+## modify build_sparse_tests.sh to generate the tests you need.
 EOF
 
 
 # define all functions
 
 
 # =======================================================
 # Section separator
@@ -145,271 +146,273 @@ EOF
 # Specific preset tests
 
 # =======================================================
 # If a sparse operation yields zeros, then those elements 
 # of the returned sparse matrix should be eaten.
 gen_eat_zeros() {
 cat >>$TESTS <<EOF
 %% Make sure newly introduced zeros get eaten
-%!assert(nnz(sparse([bf,bf,1]).^realmax),1);
-%!assert(nnz(sparse([1,bf,bf]).^realmax),1);
-%!assert(nnz(sparse([bf,bf,bf]).^realmax),0); 
+%!assert (nnz (sparse ([bf,bf,1]).^realmax), 1)
+%!assert (nnz (sparse ([1,bf,bf]).^realmax), 1)
+%!assert (nnz (sparse ([bf,bf,bf]).^realmax), 0)
 
-%!assert(nnz(sparse([bf;bf;1]).^realmax),1);
-%!assert(nnz(sparse([1;bf;bf]).^realmax),1);
-%!assert(nnz(sparse([0.5;bf;bf]).^realmax),0);
+%!assert (nnz (sparse ([bf;bf;1]).^realmax), 1)
+%!assert (nnz (sparse ([1;bf;bf]).^realmax), 1)
+%!assert (nnz (sparse ([0.5;bf;bf]).^realmax), 0)
 
-%!assert(nnz(sparse([bf,bf,1])*realmin),1);
-%!assert(nnz(sparse([1,bf,bf])*realmin),1);
-%!assert(nnz(sparse([bf,bf,bf])*realmin),0);
+%!assert (nnz (sparse ([bf,bf,1])*realmin), 1)
+%!assert (nnz (sparse ([1,bf,bf])*realmin), 1)
+%!assert (nnz (sparse ([bf,bf,bf])*realmin), 0)
 
-%!assert(nnz(sparse([bf;bf;1])*realmin),1);
-%!assert(nnz(sparse([1;bf;bf])*realmin),1);
-%!assert(nnz(sparse([bf;bf;bf])*realmin),0);
+%!assert (nnz (sparse ([bf;bf;1])*realmin), 1)
+%!assert (nnz (sparse ([1;bf;bf])*realmin), 1)
+%!assert (nnz (sparse ([bf;bf;bf])*realmin), 0)
 
 EOF
 }
 
 gen_specific() {
 cat >>$TESTS <<EOF
 
 %!test # segfault test from edd@debian.org
 %! n = 510;
-%! sparse(kron((1:n)', ones(n,1)), kron(ones(n,1), (1:n)'), ones(n)); 
+%! sparse (kron ((1:n)', ones(n,1)), kron (ones(n,1), (1:n)'), ones (n)); 
 
 %% segfault tests from Fabian@isas-berlin.de
 %% Note that the last four do not fail, but rather give a warning
 %% of a singular matrix, which is consistent with the full matrix
-%% behaviour. They are therefore disabled.. 
+%% behaviour.  They are therefore disabled.
 %!testif HAVE_UMFPACK
-%! assert(inv(sparse([1,1;1,1+i])),sparse([1-1i,1i;1i,-1i]),10*eps);
-% !error inv( sparse( [1,1;1,1]   ) );
-% !error inv( sparse( [0,0;0,1]   ) );
-% !error inv( sparse( [0,0;0,1+i] ) );
-% !error inv( sparse( [0,0;0,0]   ) );
+%! assert (inv (sparse ([1,1;1,1+i])), sparse([1-1i,1i;1i,-1i]), 10*eps);
+%#!error inv ( sparse ([1,1;1,1]  ) );
+%#!error inv ( sparse ([0,0;0,1]  ) );
+%#!error inv ( sparse ([0,0;0,1+i]) );
+%#!error inv ( sparse ([0,0;0,0]  ) );
 
 %% error handling in constructor
-%!error sparse(1,[2,3],[1,2,3]);
-%!error sparse([1,1],[1,1],[1,2],3,3,"bogus");
-%!error sparse([1,3],[1,-4],[3,5],2,2);
-%!error sparse([1,3],[1,-4],[3,5i],2,2);
-%!error sparse(-1,-1,1);
+%!error sparse (1,[2,3],[1,2,3])
+%!error sparse ([1,1],[1,1],[1,2],3,3,"bogus")
+%!error sparse ([1,3],[1,-4],[3,5],2,2)
+%!error sparse ([1,3],[1,-4],[3,5i],2,2)
+%!error sparse (-1,-1,1)
 EOF
 }
 
 
 gen_specific_tests() {
     gen_section
     gen_specific
     gen_section
     echo '%!shared bf' >> $TESTS
     echo '%!test bf=realmin;' >> $TESTS
     gen_eat_zeros
     echo '%!test bf=realmin+realmin*1i;' >> $TESTS
     gen_eat_zeros
     cat >>$TESTS <<EOF
-%!assert(nnz(sparse([-1,realmin,realmin]).^1.5),1);
-%!assert(nnz(sparse([-1,realmin,realmin,1]).^1.5),2);
+%!assert (nnz (sparse ([-1,realmin,realmin]).^1.5), 1)
+%!assert (nnz (sparse ([-1,realmin,realmin,1]).^1.5), 2)
 
-%!assert(nnz(sparse(1,1,0)),0); # Make sure scalar v==0 doesn't confuse matters
-%!assert(nnz(sparse(eye(3))*0),0);
-%!assert(nnz(sparse(eye(3))-sparse(eye(3))),0);
+## Make sure scalar v==0 doesn't confuse matters
+%!assert (nnz (sparse (1,1,0)), 0)
+%!assert (nnz (sparse (eye (3))*0), 0)
+%!assert (nnz (sparse (eye (3))-sparse (eye (3))), 0)
 
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("off", "Octave:divide-by-zero");
-%! assert(full(sparse(eye(3))/0),full(eye(3)/0));
+%! assert (full (sparse (eye (3))/0), full (eye (3)/0));
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
 EOF
 }
 
 
 # =======================================================
 # Main function definition
 
 gen_function() {
     if $preset; then
 	cat >>$TESTS <<EOF
 ##
 ## test_sparse
 ##
 ##    run preset sparse tests.  All should pass.
-function [passes,tests] = test_sparse
-  disp("writing test output to sptest.log");
-  test("test_sparse","normal","sptest.log");
+function [passes, tests] = test_sparse
+  disp ("writing test output to sptest.log");
+  test ("test_sparse", "normal", "sptest.log");
 endfunction
 
 EOF
     else
 	cat >>$TESTS <<EOF
 ##
 ## test_sprandom
 ##
 ##  total_passes=0; total_tests=0;
 ##  for i=1:10
 ##     [passes,tests] = sprandomtest;
 ##    total_passes += passes;
 ##    total_tests += tests;
 ##  end
 ##  The test log is appended to sprandomtest.log
 function [passes,total] = test_sprandom
-  warning("untested --- fix the source in build_sparse_tests.sh");
-  disp("appending test output to sprandomtest.log");
-  fid = fopen("sprandomtest.log","at");
-  test("test_sprandom","normal",fid);
+  warning ("untested --- fix the source in build_sparse_tests.sh");
+  disp ("appending test output to sprandomtest.log");
+  fid = fopen ("sprandomtest.log", "at");
+  test ("test_sprandom", "normal", fid);
   ##[passes, total] = test("sprandomtest","normal",fid);
-  fclose(fid);
+  fclose (fid);
 endfunction
 
 EOF
     fi
     
 }
 
 
 # =======================================================
 # matrix ops
 
 # test ordered comparisons: uses as,af,bs,bf
 gen_ordering_tests() {
     cat >>$TESTS <<EOF
 %% real values can be ordered (uses as,af)
-%!assert(as<=bf,sparse(af<=bf))
-%!assert(bf<=as,sparse(bf<=af))
+%!assert (as<=bf, sparse (af<=bf))
+%!assert (bf<=as, sparse (bf<=af))
 
-%!assert(as>=bf,sparse(af>=bf))
-%!assert(bf>=as,sparse(bf>=af))
+%!assert (as>=bf, sparse (af>=bf))
+%!assert (bf>=as, sparse (bf>=af))
 
-%!assert(as<bf,sparse(af<bf))
-%!assert(bf<as,sparse(bf<af))
+%!assert (as<bf, sparse (af<bf))
+%!assert (bf<as, sparse (bf<af))
 
-%!assert(as>bf,sparse(af>bf))
-%!assert(bf>as,sparse(bf>af))
+%!assert (as>bf, sparse (af>bf))
+%!assert (bf>as, sparse (bf>af))
 
 EOF
 }
 
 gen_sparsesparse_ordering_tests() {
     cat >>$TESTS <<EOF
-%!assert(as<=bs,sparse(af<=bf))
-%!assert(as>=bs,sparse(af>=bf))
-%!assert(as<bs,sparse(af<bf))
-%!assert(as>bs,sparse(af>bf))
+%!assert (as<=bs, sparse (af<=bf))
+%!assert (as>=bs, sparse (af>=bf))
+%!assert (as<bs, sparse (af<bf))
+%!assert (as>bs, sparse (af>bf))
 EOF
 }
 
 # test element-wise binary operations: uses as,af,bs,bf,scalar
 gen_elementop_tests() {
     cat >>$TESTS <<EOF
 %% Elementwise binary tests (uses as,af,bs,bf,scalar)
-%!assert(as==bs,sparse(af==bf))
-%!assert(bf==as,sparse(bf==af))
+%!assert (as==bs, sparse (af==bf))
+%!assert (bf==as, sparse (bf==af))
 
-%!assert(as!=bf,sparse(af!=bf))
-%!assert(bf!=as,sparse(bf!=af))
+%!assert (as!=bf, sparse (af!=bf))
+%!assert (bf!=as, sparse (bf!=af))
 
-%!assert(as+bf,af+bf)
-%!assert(bf+as,bf+af)
+%!assert (as+bf, af+bf)
+%!assert (bf+as, bf+af)
 
-%!assert(as-bf,af-bf)
-%!assert(bf-as,bf-af)
+%!assert (as-bf, af-bf)
+%!assert (bf-as, bf-af)
 
-%!assert(as.*bf,sparse(af.*bf))
-%!assert(bf.*as,sparse(bf.*af))
+%!assert (as.*bf, sparse (af.*bf))
+%!assert (bf.*as, sparse (bf.*af))
 
-%!assert(as./bf,sparse(af./bf),100*eps)
-%!assert(bf.\as,sparse(bf.\af),100*eps)
+%!assert (as./bf, sparse (af./bf), 100*eps)
+%!assert (bf.\as, sparse (bf.\af), 100*eps)
 
 %!test
 %! sv = as.^bf;
 %! fv = af.^bf;
-%! idx = find(af~=0);
-%! assert(sv(:)(idx),sparse(fv(:)(idx)),100*eps)
+%! idx = find (af~=0);
+%! assert (sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 gen_sparsesparse_elementop_tests() {
     cat >>$TESTS <<EOF
-%!assert(as==bs,sparse(af==bf))
-%!assert(as!=bs,sparse(af!=bf))
-%!assert(as+bs,sparse(af+bf))
-%!assert(as-bs,sparse(af-bf))
-%!assert(as.*bs,sparse(af.*bf))
-%!xtest assert(as./bs,sparse(af./bf),100*eps);
+%!assert (as==bs, sparse (af==bf))
+%!assert (as!=bs, sparse (af!=bf))
+%!assert (as+bs, sparse (af+bf))
+%!assert (as-bs, sparse (af-bf))
+%!assert (as.*bs, sparse (af.*bf))
+%!xtest assert (as./bs, sparse (af./bf), 100*eps)
 %!test
 %! sv = as.^bs;
 %! fv = af.^bf;
-%! idx = find(af~=0);
-%! assert(sv(:)(idx),sparse(fv(:)(idx)),100*eps)
+%! idx = find (af~=0);
+%! assert(sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_divop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as/bf,af/bf,100*eps)
-%!assert(af/bs,af/bf,100*eps)
-%!assert(as/bs,sparse(af/bf),100*eps)
-%!assert(bs\af',bf\af',100*eps)
-%!assert(bf\as',bf\af',100*eps)
-%!assert(bs\as',sparse(bf\af'),100*eps)
+%!assert (as/bf, af/bf, 100*eps)
+%!assert (af/bs, af/bf, 100*eps)
+%!assert (as/bs, sparse (af/bf), 100*eps)
+%!assert (bs\af', bf\af', 100*eps)
+%!assert (bf\as', bf\af', 100*eps)
+%!assert (bs\as', sparse (bf\af'), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_square_divop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as/bf,af/bf,100*eps)
-%!assert(af/bs,af/bf,100*eps)
-%!assert(as/bs,sparse(af/bf),100*eps)
-%!assert(bs\af',bf\af',100*eps)
-%!assert(bf\as',bf\af',100*eps)
-%!assert(bs\as',sparse(bf\af'),100*eps)
+%!assert (as/bf, af/bf, 100*eps)
+%!assert (af/bs, af/bf, 100*eps)
+%!assert (as/bs, sparse (af/bf), 100*eps)
+%!assert (bs\af', bf\af', 100*eps)
+%!assert (bf\as', bf\af', 100*eps)
+%!assert (bs\as', sparse (bf\af'), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix operations: uses as,af,bs,bf
 gen_matrixop_tests() {
     cat >>$TESTS <<EOF
 %% Matrix-matrix operators (uses af,as,bs,bf)
-%!assert(as*bf',af*bf')
-%!assert(af*bs',af*bf')
-%!assert(as*bs',sparse(af*bf'))
+%!assert (as*bf', af*bf')
+%!assert (af*bs', af*bf')
+%!assert (as*bs', sparse (af*bf'))
 
 EOF
 }
 
 # test diagonal operations
 gen_matrixdiag_tests() {
     cat >>$TESTS <<EOF
 %% Matrix diagonal tests (uses af,as,bf,bs)
-%!assert(diag(as),sparse(diag(af)))
-%!assert(diag(bs),sparse(diag(bf)))
-%!assert(diag(as,1),sparse(diag(af,1)))
-%!assert(diag(bs,1),sparse(diag(bf,1)))
-%!assert(diag(as,-1),sparse(diag(af,-1)))
-%!assert(diag(bs,-1),sparse(diag(bf,-1)))
-%!assert(diag(as(:)),sparse(diag(af(:))))
-%!assert(diag(as(:),1),sparse(diag(af(:),1)))
-%!assert(diag(as(:),-1),sparse(diag(af(:),-1)))
-%!assert(diag(as(:)'),sparse(diag(af(:)')))
-%!assert(diag(as(:)',1),sparse(diag(af(:)',1)))
-%!assert(diag(as(:)',-1),sparse(diag(af(:)',-1)))
-%!assert(spdiags(as,[0,1]),[diag(af,0),diag(af,1)])
-%!test [tb,tc]=spdiags(as); 
-%! assert(spdiags(tb,tc,sparse(zeros(size(as)))),as)
-%! assert(spdiags(tb,tc,size(as,1),size(as,2)),as)
+%!assert (diag (as), sparse (diag (af)))
+%!assert (diag (bs), sparse (diag (bf)))
+%!assert (diag (as,1), sparse (diag (af,1)))
+%!assert (diag (bs,1), sparse (diag (bf,1)))
+%!assert (diag (as,-1), sparse (diag (af,-1)))
+%!assert (diag (bs,-1), sparse (diag (bf,-1)))
+%!assert (diag (as(:)), sparse (diag (af(:))))
+%!assert (diag (as(:),1), sparse (diag (af(:),1)))
+%!assert (diag (as(:),-1), sparse (diag (af(:),-1)))
+%!assert (diag (as(:)'), sparse (diag (af(:)')))
+%!assert (diag (as(:)',1), sparse (diag (af(:)',1)))
+%!assert (diag (as(:)',-1), sparse (diag (af(:)',-1)))
+%!assert (spdiags (as,[0,1]), [diag(af,0), diag(af,1)])
+%!test
+%! [tb,tc]=spdiags(as); 
+%! assert (spdiags (tb,tc,sparse (zeros (size (as)))), as);
+%! assert (spdiags (tb,tc,size (as,1),size (as,2)), as);
 
 EOF
 }
 
 # test matrix reshape operations
 gen_matrixreshape_tests() {
     cat >>$TESTS <<EOF
 %% Matrix diagonal tests (uses af,as,bf,bs)
@@ -420,29 +423,29 @@ gen_matrixreshape_tests() {
 %!assert(reshape(bs,prod(size(as)),1),sparse(reshape(bf,prod(size(af)),1)))
 %!assert(reshape(bs,fliplr(size(as))),sparse(reshape(bf,fliplr(size(af)))))
 
 EOF
 }
 
 # test mapper matrix operations: uses as,af
 print_mapper_test() {
-echo "%!assert($1(as),sparse($1(af)))" >>$TESTS
+echo "%!assert ($1(as), sparse ($1(af)))" >>$TESTS
 }
 
 print_real_mapper_test() {
     cat >>$TESTS <<EOF
 %!test
 %! wn2s = warning ("query", "Octave:num-to-str");
 %! warning ("off", "Octave:num-to-str");
-%! if isreal(af)
+%! if (isreal (af))
 %!   if ($2)
-%!     assert($1(as),sparse($1(af)))
+%!     assert ($1(as), sparse ($1(af)));
 %!   else
-%!     assert($1(as),$1(af))
+%!     assert ($1(as), $1(af));
 %!   endif
 %! endif
 %! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 gen_mapper_tests() {
@@ -476,19 +479,19 @@ print_mapper_test sign
 print_mapper_test sin
 print_mapper_test sinh
 print_mapper_test sqrt
 print_mapper_test tan
 print_mapper_test tanh
 
 # Specific tests for certain mapper functions
     cat >>$TESTS <<EOF
-%!assert(issparse(abs(as))&&isreal(abs(as)))
-%!assert(issparse(real(as))&&isreal(real(as)))
-%!assert(issparse(imag(as))&&isreal(imag(as)))
+%!assert (issparse (abs (as))  && isreal (abs (as)))
+%!assert (issparse (real (as)) && isreal (real (as)))
+%!assert (issparse (imag (as)) && isreal (imag (as)))
 
 EOF
 }
 
 gen_real_mapper_tests() {
 echo "%% Unary matrix tests (uses af,as)">>$TESTS
 print_real_mapper_test erf 1
 print_real_mapper_test erfc 1
@@ -509,220 +512,220 @@ print_real_mapper_test isxdigit 0
 
 # Specific tests for certain mapper functions
     cat >>$TESTS <<EOF
 
 %% These mapper functions always return a full matrix
 %!test
 %! wn2s = warning ("query", "Octave:num-to-str");
 %! warning ("off", "Octave:num-to-str");
-%! if isreal(af)
-%!    assert(toascii(as),toascii(af))
-%!    assert(tolower(as),tolower(af))
-%!    assert(toupper(as),toupper(af))
+%! if (isreal (af))
+%!   assert (toascii (as), toascii (af));
+%!   assert (tolower (as), tolower (af));
+%!   assert (toupper (as), toupper (af));
 %! endif
 %! warning (wn2s.state, "Octave:num-to-str");
 
 EOF
 }
 
 # test matrix operations: uses as,af
 gen_unaryop_tests() {
     cat >>$TESTS <<EOF
 %% Unary matrix tests (uses af,as)
-%!assert(issparse(as))
-%!assert(!issparse(af))
-%!assert(!(issparse(af)&&iscomplex(af)))
-%!assert(!(issparse(af)&&isreal(af)))
-%!assert(sum(as),sparse(sum(af)))
-%!assert(sum(as,1),sparse(sum(af,1)))
-%!assert(sum(as,2),sparse(sum(af,2)))
-%!assert(cumsum(as),sparse(cumsum(af)))
-%!assert(cumsum(as,1),sparse(cumsum(af,1)))
-%!assert(cumsum(as,2),sparse(cumsum(af,2)))
-%!assert(sumsq(as),sparse(sumsq(af)))
-%!assert(sumsq(as,1),sparse(sumsq(af,1)))
-%!assert(sumsq(as,2),sparse(sumsq(af,2)))
-%!assert(prod(as),sparse(prod(af)))
-%!assert(prod(as,1),sparse(prod(af,1)))
-%!assert(prod(as,2),sparse(prod(af,2)))
-%!assert(cumprod(as),sparse(cumprod(af)))
-%!assert(cumprod(as,1),sparse(cumprod(af,1)))
-%!assert(cumprod(as,2),sparse(cumprod(af,2)))
+%!assert (issparse (as))
+%!assert (!issparse (af))
+%!assert (! (issparse (af) && iscomplex (af)))
+%!assert (! (issparse (af) && isreal (af)))
+%!assert (sum (as), sparse (sum (af)))
+%!assert (sum (as,1), sparse (sum (af,1)))
+%!assert (sum (as,2), sparse (sum (af,2)))
+%!assert (cumsum (as), sparse (cumsum (af)))
+%!assert (cumsum (as,1), sparse (cumsum (af,1)))
+%!assert (cumsum (as,2), sparse (cumsum (af,2)))
+%!assert (sumsq (as), sparse (sumsq (af)))
+%!assert (sumsq (as,1), sparse (sumsq (af,1)))
+%!assert (sumsq (as,2), sparse (sumsq (af,2)))
+%!assert (prod (as), sparse (prod (af)))
+%!assert (prod (as,1), sparse (prod (af,1)))
+%!assert (prod (as,2), sparse (prod (af,2)))
+%!assert (cumprod (as), sparse (cumprod (af)))
+%!assert (cumprod (as,1), sparse (cumprod (af,1)))
+%!assert (cumprod (as,2), sparse (cumprod (af,2)))
 
-%!assert(min(as),sparse(min(af)))
-%!assert(full(min(as(:))),min(af(:)))
-%!assert(min(as,[],1),sparse(min(af,[],1)))
-%!assert(min(as,[],2),sparse(min(af,[],2)))
-%!assert(min(as,[],1),sparse(min(af,[],1)))
-%!assert(min(as,0),sparse(min(af,0)))
-%!assert(min(as,bs),sparse(min(af,bf)))
-%!assert(max(as),sparse(max(af)))
-%!assert(full(max(as(:))),max(af(:)))
-%!assert(max(as,[],1),sparse(max(af,[],1)))
-%!assert(max(as,[],2),sparse(max(af,[],2)))
-%!assert(max(as,[],1),sparse(max(af,[],1)))
-%!assert(max(as,0),sparse(max(af,0)))
-%!assert(max(as,bs),sparse(max(af,bf)))
+%!assert (min (as), sparse (min (af)))
+%!assert (full (min (as(:))),min (af(:)))
+%!assert (min (as,[],1), sparse (min (af,[],1)))
+%!assert (min (as,[],2), sparse (min (af,[],2)))
+%!assert (min (as,[],1), sparse (min (af,[],1)))
+%!assert (min (as,0), sparse (min (af,0)))
+%!assert (min (as,bs), sparse (min (af,bf)))
+%!assert (max (as), sparse (max (af)))
+%!assert (full (max (as(:))), max (af(:)))
+%!assert (max (as,[],1), sparse (max (af,[],1)))
+%!assert (max (as,[],2), sparse (max (af,[],2)))
+%!assert (max (as,[],1), sparse (max (af,[],1)))
+%!assert (max (as,0), sparse (max (af,0)))
+%!assert (max (as,bs), sparse (max (af,bf)))
 
-%!assert(as==as)
-%!assert(as==af)
-%!assert(af==as)
+%!assert (as==as)
+%!assert (as==af)
+%!assert (af==as)
 %!test
-%! [ii,jj,vv,nr,nc] = find(as);
-%! assert(af,full(sparse(ii,jj,vv,nr,nc)));
-%!assert(nnz(as),sum(af(:)!=0))
-%!assert(nnz(as),nnz(af))
-%!assert(issparse(as.'))
-%!assert(issparse(as'))
-%!assert(issparse(-as))
-%!assert(~as,sparse(~af))
-%!assert(as.', sparse(af.'));
-%!assert(as',  sparse(af'));
-%!assert(-as, sparse(-af));
-%!assert(~as, sparse(~af));
-%!error [i,j]=size(af);as(i-1,j+1);
-%!error [i,j]=size(af);as(i+1,j-1);
+%! [ii,jj,vv,nr,nc] = find (as);
+%! assert (af, full (sparse (ii,jj,vv,nr,nc)));
+%!assert (nnz (as), sum (af(:)!=0))
+%!assert (nnz (as), nnz (af))
+%!assert (issparse (as.'))
+%!assert (issparse (as'))
+%!assert (issparse (-as))
+%!assert (~as, sparse (~af))
+%!assert (as.', sparse (af.'));
+%!assert (as',  sparse (af'));
+%!assert (-as, sparse (-af));
+%!assert (~as, sparse (~af));
+%!error [i,j]=size (af);as(i-1,j+1);
+%!error [i,j]=size (af);as(i+1,j-1);
 %!test
-%! [Is,Js,Vs] = find(as);
-%! [If,Jf,Vf] = find(af);
-%! assert(Is,If);
-%! assert(Js,Jf);
-%! assert(Vs,Vf);
+%! [Is,Js,Vs] = find (as);
+%! [If,Jf,Vf] = find (af);
+%! assert (Is, If);
+%! assert (Js, Jf);
+%! assert (Vs, Vf);
 %!error as(0,1);
 %!error as(1,0);
-%!assert(find(as),find(af))
+%!assert (find (as), find (af))
 %!test
-%! [i,j,v] = find(as);
-%! [m,n] = size(as);
-%! x = sparse(i,j,v,m,n);
-%! assert(x,as);
+%! [i,j,v] = find (as);
+%! [m,n] = size (as);
+%! x = sparse (i,j,v,m,n);
+%! assert (x, as);
 %!test
-%! [i,j,v,m,n] = find(as);
-%! x = sparse(i,j,v,m,n);
-%! assert(x,as);
-%!assert(issparse(horzcat(as,as)));
-%!assert(issparse(vertcat(as,as)));
-%!assert(issparse(cat(1,as,as)));
-%!assert(issparse(cat(2,as,as)));
-%!assert(issparse([as,as]));
-%!assert(issparse([as;as]));
-%!assert(horzcat(as,as), sparse([af,af]));
-%!assert(vertcat(as,as), sparse([af;af]));
-%!assert(horzcat(as,as,as), sparse([af,af,af]));
-%!assert(vertcat(as,as,as), sparse([af;af;af]));
-%!assert([as,as], sparse([af,af]));
-%!assert([as;as], sparse([af;af]));
-%!assert([as,as,as], sparse([af,af,af]));
-%!assert([as;as;as], sparse([af;af;af]));
-%!assert(cat(2,as,as), sparse([af,af]));
-%!assert(cat(1,as,as), sparse([af;af]));
-%!assert(cat(2,as,as,as), sparse([af,af,af]));
-%!assert(cat(1,as,as,as), sparse([af;af;af]));
-%!assert(issparse([as,af]));
-%!assert(issparse([af,as]));
-%!assert([as,af], sparse([af,af]));
-%!assert([as;af], sparse([af;af]));
+%! [i,j,v,m,n] = find (as);
+%! x = sparse (i,j,v,m,n);
+%! assert (x, as);
+%!assert (issparse (horzcat (as,as)));
+%!assert (issparse (vertcat (as,as)));
+%!assert (issparse (cat (1,as,as)));
+%!assert (issparse (cat (2,as,as)));
+%!assert (issparse ([as,as]));
+%!assert (issparse ([as;as]));
+%!assert (horzcat (as,as), sparse ([af,af]));
+%!assert (vertcat (as,as), sparse ([af;af]));
+%!assert (horzcat (as,as,as), sparse ([af,af,af]));
+%!assert (vertcat (as,as,as), sparse ([af;af;af]));
+%!assert ([as,as], sparse ([af,af]));
+%!assert ([as;as], sparse ([af;af]));
+%!assert ([as,as,as], sparse ([af,af,af]));
+%!assert ([as;as;as], sparse ([af;af;af]));
+%!assert (cat (2,as,as), sparse ([af,af]));
+%!assert (cat (1,as,as), sparse ([af;af]));
+%!assert (cat (2,as,as,as), sparse ([af,af,af]));
+%!assert (cat (1,as,as,as), sparse ([af;af;af]));
+%!assert (issparse ([as,af]));
+%!assert (issparse ([af,as]));
+%!assert ([as,af], sparse ([af,af]));
+%!assert ([as;af], sparse ([af;af]));
 
 EOF
 }
 
 # operations which require square matrices.
 gen_square_tests() {
 # The \ and / operator tests on square matrices
     gen_square_divop_tests
 
     cat >>$TESTS <<EOF
 %!testif HAVE_UMFPACK
 %! assert(det(bs+speye(size(bs))),det(bf+eye(size(bf))),100*eps*abs(det(bf+eye(size(bf)))))
 
 %!testif HAVE_UMFPACK 
-%! [l,u]=lu(sparse([1,1;1,1]));
-%! assert(l*u,[1,1;1,1],10*eps);
+%! [l,u] = lu (sparse ([1,1;1,1]));
+%! assert (l*u, [1,1;1,1], 10*eps);
 
 %!testif HAVE_UMFPACK
-%! [l,u]=lu(sparse([1,1;1,1+i]));
-%! assert(l,sparse([1,2,2],[1,1,2],1),10*eps);
-%! assert(u,sparse([1,1,2],[1,2,2],[1,1,1i]),10*eps);
+%! [l,u] = lu (sparse ([1,1;1,1+i]));
+%! assert (l, sparse ([1,2,2],[1,1,2],1), 10*eps);
+%! assert (u, sparse ([1,1,2],[1,2,2],[1,1,1i]), 10*eps);
 
-%!testif HAVE_UMFPACK ;# permuted LU
-%! [L,U] = lu(bs);
-%! assert(L*U,bs,1e-10);
+%!testif HAVE_UMFPACK   # permuted LU
+%! [L,U] = lu (bs);
+%! assert (L*U, bs, 1e-10);
 
-%!testif HAVE_UMFPACK ;# simple LU + row permutations
-%! [L,U,P] = lu(bs);
-%! assert(P'*L*U,bs,1e-10);
+%!testif HAVE_UMFPACK   # simple LU + row permutations
+%! [L,U,P] = lu (bs);
+%! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# simple LU + row/col permutations
-%! [L,U,P,Q] = lu(bs);
-%! assert(P'*L*U*Q',bs,1e-10);
+%!testif HAVE_UMFPACK   # simple LU + row/col permutations
+%! [L,U,P,Q] = lu (bs);
+%! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with vector permutations
-%! [L,U,P,Q] = lu(bs,'vector');
-%! assert(L(P,:)*U(:,Q),bs,1e-10);
+%!testif HAVE_UMFPACK   # LU with vector permutations
+%! [L,U,P,Q] = lu (bs,'vector');
+%! assert (L(P,:)*U(:,Q), bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with scaling
-%! [L,U,P,Q,R] = lu(bs);
-%! assert(R*P'*L*U*Q',bs,1e-10);
+%!testif HAVE_UMFPACK   # LU with scaling
+%! [L,U,P,Q,R] = lu (bs);
+%! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# inverse
-%! assert(inv(bs)*bs,sparse(eye(rows(bs))),1e-10);
+%!testif HAVE_UMFPACK   # inverse
+%! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
-%!assert(bf\as',bf\af',100*eps);
-%!assert(bs\af',bf\af',100*eps);
-%!assert(bs\as',sparse(bf\af'),100*eps);
+%!assert (bf\as', bf\af', 100*eps);
+%!assert (bs\af', bf\af', 100*eps);
+%!assert (bs\as', sparse (bf\af'), 100*eps);
 
 EOF
 }
 
 # Cholesky tests
 gen_cholesky_tests() {
     cat >>$TESTS <<EOF
 %!testif HAVE_CHOLMOD
-%! assert(chol(bs)'*chol(bs),bs,1e-10);
+%! assert (chol (bs)'*chol (bs), bs, 1e-10);
 %!testif HAVE_CHOLMOD 
-%! assert(chol(bs,'lower')*chol(bs,'lower')',bs,1e-10);
+%! assert (chol (bs,'lower')*chol (bs,'lower')', bs, 1e-10);
 %!testif HAVE_CHOLMOD
-%! assert(chol(bs,'lower'),chol(bs)',1e-10);
+%! assert (chol (bs,'lower'), chol (bs)', 1e-10);
 
-%!testif HAVE_CHOLMOD ;# Return Partial Cholesky factorization
-%! [RS,PS] = chol(bs);
-%! assert(RS'*RS,bs,1e-10);
-%! assert(PS,0);
-%! [LS,PS] = chol(bs,'lower');
-%! assert(LS*LS',bs,1e-10);
-%! assert(PS,0);
+%!testif HAVE_CHOLMOD   # Return Partial Cholesky factorization
+%! [RS,PS] = chol (bs);
+%! assert (RS'*RS, bs, 1e-10);
+%! assert (PS, 0);
+%! [LS,PS] = chol (bs,'lower');
+%! assert (LS*LS', bs, 1e-10);
+%! assert (PS, 0);
 
-%!testif HAVE_CHOLMOD ;# Permuted Cholesky factorization
-%! [RS,PS,QS] = chol(bs);
-%! assert(RS'*RS,QS*bs*QS',1e-10);
-%! assert(PS,0);
-%! [LS,PS,QS] = chol(bs,'lower');
-%! assert(LS*LS',QS*bs*QS',1e-10);
-%! assert(PS,0);
+%!testif HAVE_CHOLMOD   # Permuted Cholesky factorization
+%! [RS,PS,QS] = chol (bs);
+%! assert (RS'*RS, QS*bs*QS', 1e-10);
+%! assert (PS, 0);
+%! [LS,PS,QS] = chol (bs,'lower');
+%! assert (LS*LS', QS*bs*QS', 1e-10);
+%! assert (PS, 0);
 
 EOF
 }
 
 # test scalar operations: uses af and real scalar bf; modifies as,bf,bs
 gen_scalar_tests() {
     echo '%!test as=sparse(af);' >> $TESTS
     echo '%!test bs=bf;' >> $TESTS
@@ -742,382 +745,401 @@ gen_rectangular_tests() {
     gen_unaryop_tests
     gen_elementop_tests
     gen_sparsesparse_elementop_tests
     gen_matrixop_tests
     # gen_divop_tests # Disable rectangular \ and / for now
     gen_matrixdiag_tests
     gen_matrixreshape_tests
     cat >>$TESTS <<EOF
-%!testif HAVE_UMFPACK ;# permuted LU
-%! [L,U] = lu(bs);
-%! assert(L*U,bs,1e-10);
+%!testif HAVE_UMFPACK   # permuted LU
+%! [L,U] = lu (bs);
+%! assert (L*U, bs, 1e-10);
 
-%!testif HAVE_UMFPACK ;# simple LU + row permutations
-%! [L,U,P] = lu(bs);
-%! assert(P'*L*U,bs,1e-10);
+%!testif HAVE_UMFPACK   # simple LU + row permutations
+%! [L,U,P] = lu (bs);
+%! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# simple LU + row/col permutations
-%! [L,U,P,Q] = lu(bs);
-%! assert(P'*L*U*Q',bs,1e-10);
+%!testif HAVE_UMFPACK   # simple LU + row/col permutations
+%! [L,U,P,Q] = lu (bs);
+%! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with vector permutations
-%! [L,U,P,Q] = lu(bs,'vector');
-%! assert(L(P,:)*U(:,Q),bs,1e-10);
+%!testif HAVE_UMFPACK   # LU with vector permutations
+%! [L,U,P,Q] = lu (bs,'vector');
+%! assert (L (P,:)*U (:,Q), bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with scaling
-%! [L,U,P,Q,R] = lu(bs);
-%! assert(R*P'*L*U*Q',bs,1e-10);
+%!testif HAVE_UMFPACK   # LU with scaling
+%! [L,U,P,Q,R] = lu (bs);
+%! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
-%! [i,j,v]=find(L);
-%! assert(i-j>=0);
-%! [i,j,v]=find(U);
-%! assert(j-i>=0);
+%! [i,j,v] = find (L);
+%! assert (i-j>=0);
+%! [i,j,v] = find (U);
+%! assert (j-i>=0);
 
 EOF
 }
 
 
 # =======================================================
 # sparse assembly tests
 
 gen_assembly_tests() {
 cat >>$TESTS <<EOF
 %%Assembly tests
 %!test
-%! m=max([m;r(:)]);
-%! n=max([n;c(:)]);
-%! funiq=fsum=zeros(m,n);
-%! funiq(r(:) + m*(c(:)-1) ) = ones(size(r(:)));
-%! funiq = sparse(funiq);
-%! for k=1:length(r), fsum(r(k),c(k)) += 1; end
-%! fsum = sparse(fsum);
-%!assert(sparse(r,c,1),sparse(fsum(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,"sum"),sparse(fsum(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,"unique"),sparse(funiq(1:max(r),1:max(c))));
-%!assert(sparse(r,c,1,m,n),sparse(fsum));
-%!assert(sparse(r,c,1,m,n,"sum"),sparse(fsum));
-%!assert(sparse(r,c,1,m,n,"unique"),sparse(funiq));
+%! m = max ([m;r(:)]);
+%! n = max ([n;c(:)]);
+%! funiq = fsum = zeros (m,n);
+%! funiq(r(:) + m*(c(:)-1) ) = ones (size (r(:)));
+%! funiq = sparse (funiq);
+%! for k=1:length(r)
+%!   fsum(r(k),c(k)) += 1;
+%! endfor
+%! fsum = sparse (fsum);
+%!assert (sparse (r,c,1), sparse (fsum(1:max(r), 1:max(c))))
+%!assert (sparse (r,c,1,"sum"), sparse (fsum(1:max (r),1:max (c))))
+%!assert (sparse (r,c,1,"unique"), sparse (funiq(1:max (r),1:max (c))))
+%!assert (sparse (r,c,1,m,n), sparse (fsum))
+%!assert (sparse (r,c,1,m,n,"sum"), sparse (fsum))
+%!assert (sparse (r,c,1,m,n,"unique"), sparse (funiq))
 
-%!assert(sparse(r,c,1i),sparse(fsum(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,"sum"),sparse(fsum(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,"unique"),sparse(funiq(1:max(r),1:max(c))*1i));
-%!assert(sparse(r,c,1i,m,n),sparse(fsum*1i));
-%!assert(sparse(r,c,1i,m,n,"sum"),sparse(fsum*1i));
-%!assert(sparse(r,c,1i,m,n,"unique"),sparse(funiq*1i));
+%!assert (sparse (r,c,1i), sparse (fsum(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,"sum"), sparse (fsum(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,"unique"), sparse (funiq(1:max (r),1:max (c))*1i))
+%!assert (sparse (r,c,1i,m,n), sparse (fsum*1i))
+%!assert (sparse (r,c,1i,m,n,"sum"), sparse (fsum*1i))
+%!assert (sparse (r,c,1i,m,n,"unique"), sparse (funiq*1i))
 
 %!test
-%! if (issparse(funiq))
-%!  assert(sparse(full(1i*funiq)),sparse(1i*funiq));
+%! if (issparse (funiq))
+%!   assert (sparse (full (1i*funiq)), sparse (1i*funiq));
 %! endif
 
-%!assert(sparse(full(funiq)),funiq);
+%!assert (sparse (full (funiq)), funiq)
 
 
 EOF
 }
 
 # =======================================================
 # sparse selection tests
 
 gen_scalar_select_tests () {
     cat >>$TESTS <<EOF
-%!assert (sparse(42)([1,1]),sparse([42,42]))
-%!assert (sparse(42*1i)([1,1]),sparse([42,42].*1i))
+%!assert (sparse (42)([1,1]), sparse ([42,42]))
+%!assert (sparse (42*1i)([1,1]), sparse ([42,42].*1i))
 EOF
 }
 
 gen_select_tests() {
     cat >>$TESTS <<EOF
 %!test as=sparse(af);
 
 %% Point tests
-%!test idx=ridx(:)+rows(as)*(cidx(:)-1);
-%!assert(sparse(as(idx)),sparse(af(idx)));
-%!assert(as(idx),sparse(af(idx)));
-%!assert(as(idx'),sparse(af(idx')));
-%!assert(as(flipud(idx(:))),sparse(af(flipud(idx(:)))))
-%!assert(as([idx,idx]),sparse(af([idx,idx])));
-%!error(as(reshape([idx;idx],[1,length(idx),2])));
+%!test idx = ridx(:) + rows (as) * (cidx (:)-1);
+%!assert (sparse (as(idx)), sparse (af(idx)))
+%!assert (as(idx), sparse (af(idx)));
+%!assert (as(idx'), sparse (af(idx')));
+%!assert (as(flipud (idx(:))), sparse (af(flipud (idx(:)))))
+%!assert (as([idx,idx]), sparse (af([idx,idx])))
+%!error (as(reshape ([idx;idx], [1,length(idx),2])))
 
 %% Slice tests
-%!assert(as(ridx,cidx), sparse(af(ridx,cidx)))
-%!assert(as(ridx,:), sparse(af(ridx,:)))
-%!assert(as(:,cidx), sparse(af(:,cidx)))
-%!assert(as(:,:), sparse(af(:,:)))
-%!assert(as((size(as,1):-1:1),:),sparse(af((size(af,1):-1:1),:)))
-%!assert(as(:,(size(as,2):-1:1)),sparse(af(:,(size(af,2):-1:1))))
+%!assert (as(ridx,cidx), sparse (af(ridx,cidx)))
+%!assert (as(ridx,:), sparse (af(ridx,:)))
+%!assert (as(:,cidx), sparse (af(:,cidx)))
+%!assert (as(:,:), sparse (af(:,:)))
+%!assert (as((size (as,1):-1:1),:), sparse (af((size (af,1):-1:1),:)))
+%!assert (as(:,(size (as,2):-1:1)), sparse (af(:, (size (af,2):-1:1))))
 
 %% Indexing tests
-%!assert(full(as([1,1],:)), af([1,1],:))
-%!assert(full(as(:,[1,1])), af(:,[1,1]))
+%!assert (full (as([1,1],:)), af([1,1],:))
+%!assert (full (as(:,[1,1])), af(:,[1,1]))
 %!test
 %! [i,j,v] = find (as);
-%! assert (as(i(1),j(1))([1,1]), sparse([v(1),v(1)]))
+%! assert (as(i(1),j(1))([1,1]), sparse ([v(1), v(1)]))
 
 %% Assignment test
 %!test
-%! ts=as;ts(:,:)=ts(fliplr(1:size(as,1)),:);
-%! tf=af;tf(:,:)=tf(fliplr(1:size(af,1)),:);
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,:) = ts(fliplr (1:size (as,1)),:);
+%! tf=af; tf(:,:) = tf(fliplr (1:size (af,1)),:);
+%! assert (ts, sparse (tf));
+%!test
+%! ts=as; ts(fliplr (1:size (as,1)),:) = ts;
+%! tf=af; tf(fliplr (1:size (af,1)),:) = tf;
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(fliplr(1:size(as,1)),:)=ts;
-%! tf=af;tf(fliplr(1:size(af,1)),:)=tf;
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,fliplr (1:size (as,2))) = ts;
+%! tf=af; tf(:,fliplr (1:size (af,2))) = tf;
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(:,fliplr(1:size(as,2)))=ts;
-%! tf=af;tf(:,fliplr(1:size(af,2)))=tf;
-%! assert(ts,sparse(tf));
-%!test
-%! ts(fliplr(1:size(as,1)))=as(:,1);tf(fliplr(1:size(af,1)))=af(:,1);
-%! assert(ts,sparse(tf));
+%! ts(fliplr (1:size (as,1))) = as(:,1);
+%! tf(fliplr (1:size (af,1))) = af(:,1);
+%! assert (ts, sparse (tf));
 
 %% Deletion tests
 %!test
-%! ts=as;ts(1,:)=[];tf=af;tf(1,:)=[];
-%! assert(ts,sparse(tf));
+%! ts=as; ts(1,:)=[]; tf=af; tf(1,:)=[];
+%! assert (ts, sparse (tf));
 %!test
-%! ts=as;ts(:,1)=[];tf=af;tf(:,1)=[];
-%! assert(ts,sparse(tf));
+%! ts=as; ts(:,1)=[]; tf=af; tf(:,1)=[];
+%! assert (ts, sparse (tf));
 
-%% Test 'end' keyword
-%!assert(full(as(end)), af(end))
-%!assert(full(as(1,end)), af(1,end))
-%!assert(full(as(end,1)), af(end,1))
-%!assert(full(as(end,end)), af(end,end))
-%!assert(as(2:end,2:end), sparse(af(2:end,2:end)))
-%!assert(as(1:end-1,1:end-1), sparse(af(1:end-1,1:end-1)))
+%% Test "end" keyword
+%!assert (full (as(end)), af(end))
+%!assert (full (as(1,end)), af(1,end))
+%!assert (full (as(end,1)), af(end,1))
+%!assert (full (as(end,end)), af(end,end))
+%!assert (as(2:end,2:end), sparse (af(2:end,2:end)))
+%!assert (as(1:end-1,1:end-1), sparse (af(1:end-1,1:end-1)))
 EOF
 }
 
 # =======================================================
 # sparse save and load tests
 
 gen_save_tests() {
     cat >>$TESTS <<EOF
 %!test # save ascii
-%! savefile= tmpnam();
-%! as_save=as; save("-text",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-text", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
 %!test # save binary
-%! savefile= tmpnam();
-%! as_save=as; save("-binary",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-binary", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
-%!testif HAVE_HDF5 # save hdf5
-%! savefile= tmpnam();
-%! as_save=as; save("-hdf5",savefile,"bf","as_save","af");
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
+%!testif HAVE_HDF5   # save hdf5
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-hdf5", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
-## FIXME -- we should skip (or mark as an expected failure) the test for
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
+## FIXME: We should skip (or mark as an expected failure) the test for
 ## saving sparse matrices to MAT files when using 64-bit indexing since
 ## that is not implemented yet.
 %!test # save matlab
-%! savefile= tmpnam();
-%! as_save=as; save("-mat",savefile,"bf","as_save","af");
+%! savefile = tmpnam ();
+%! as_save = as;
+%! save ("-mat", savefile, "bf", "as_save", "af");
 %! clear as_save;
-%! load(savefile,"as_save");
-%! unlink(savefile);
-%! assert(as_save,sparse(af));
+%! load (savefile, "as_save");
+%! unlink (savefile);
+%! assert (as_save, sparse(af));
 EOF
 }
 
 # =============================================================
 # Specific solver tests for matrices that will test all of the solver
 # code. Uses alpha and beta
 gen_solver_tests() {
 
 if $preset; then
   cat >>$TESTS <<EOF
 %! n=8;
-%! lf=diag(1:n);lf(n-1,1)=0.5*alpha;lf(n,2)=0.25*alpha;ls=sparse(lf);
-%! uf=diag(1:n);uf(1,n-1)=2*alpha;uf(2,n)=alpha;us=sparse(uf);
-%! ts=spdiags(ones(n,3),-1:1,n,n)+diag(1:n); tf = full(ts);
+%! lf=diag (1:n); lf(n-1,1)=0.5*alpha; lf(n,2)=0.25*alpha; ls=sparse (lf);
+%! uf=diag (1:n); uf(1,n-1)=2*alpha; uf(2,n)=alpha; us=sparse (uf);
+%! ts=spdiags (ones (n,3),-1:1,n,n) + diag (1:n); tf = full (ts);
 EOF
 else
   cat >>$TESTS <<EOF
-%! n=floor(lognrnd(8,2)+1)'
-%! ls = tril(sprandn(8,8,0.2),-1).*alpha + n*speye(8); lf = full(ls);
-%! us = triu(sprandn(8,8,0.2),1).*alpha + n*speye(8); uf = full(us);
-%! ts = spdiags(randn(8,3),-1:1,8,8).*alpha; tf = full(ts);
+%! n = floor (lognrnd (8,2)+1)';
+%! ls = tril (sprandn (8,8,0.2),-1).*alpha + n*speye (8); lf = full (ls);
+%! us = triu (sprandn (8,8,0.2),1).*alpha + n*speye (8); uf = full (us);
+%! ts = spdiags (randn (8,3),-1:1,8,8).*alpha; tf = full (ts);
 EOF
 fi
 
 cat >>$TESTS <<EOF
-%! df = diag(1:n).* alpha; ds = sparse(df);
-%! pdf = df(randperm(n),randperm(n)); pds = sparse(pdf);
-%! plf = lf(randperm(n),randperm(n)); pls = sparse(plf);
-%! puf = uf(randperm(n),randperm(n)); pus = sparse(puf);
-%! bs = spdiags(repmat([1:n]',1,4),-2:1,n,n).*alpha; bf = full(bs);
-%! cf = lf + lf'; cs = sparse(cf);
-%! bcf = bf + bf'; bcs = sparse(bcf);
-%! tcf = tf + tf'; tcs = sparse(tcf);
-%! xf = diag(1:n) + fliplr(diag(1:n)).*beta; xs = sparse(xf);
-%!assert(ds\xf,df\xf,1e-10);
-%!assert(ds\xs,sparse(df\xf),1e-10);
-%!assert(pds\xf,pdf\xf,1e-10);
-%!assert(pds\xs,sparse(pdf\xf),1e-10);
-%!assert(ls\xf,lf\xf,1e-10);
-%!assert(sparse(ls\xs),sparse(lf\xf),1e-10);
-%!testif HAVE_UMFPACK
-%! assert(pls\xf,plf\xf,1e-10);
+%! df = diag (1:n).* alpha; ds = sparse (df);
+%! pdf = df(randperm (n),randperm (n));
+%! pds = sparse (pdf);
+%! plf = lf(randperm (n),randperm (n));
+%! pls = sparse (plf);
+%! puf = uf(randperm (n),randperm (n));
+%! pus = sparse (puf);
+%! bs = spdiags (repmat ([1:n]',1,4),-2:1,n,n).*alpha;
+%! bf = full (bs);
+%! cf = lf + lf'; cs = sparse (cf);
+%! bcf = bf + bf'; bcs = sparse (bcf);
+%! tcf = tf + tf'; tcs = sparse (tcf);
+%! xf = diag (1:n) + fliplr (diag (1:n)).*beta;
+%! xs = sparse (xf);
+%!assert (ds\xf, df\xf, 1e-10);
+%!assert (ds\xs, sparse (df\xf), 1e-10);
+%!assert (pds\xf, pdf\xf, 1e-10);
+%!assert (pds\xs, sparse (pdf\xf), 1e-10);
+%!assert (ls\xf, lf\xf, 1e-10);
+%!assert (sparse (ls\xs), sparse (lf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(pls\xs),sparse(plf\xf),1e-10);
-%!assert(us\xf,uf\xf,1e-10);
-%!assert(sparse(us\xs),sparse(uf\xf),1e-10);
+%! assert (pls\xf, plf\xf, 1e-10);
+%!testif HAVE_UMFPACK
+%! assert (sparse (pls\xs), sparse (plf\xf), 1e-10);
+%!assert (us\xf, uf\xf, 1e-10);
+%!assert (sparse (us\xs), sparse (uf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(pus\xf,puf\xf,1e-10);
+%! assert (pus\xf, puf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(pus\xs),sparse(puf\xf),1e-10);
-%!assert(bs\xf,bf\xf,1e-10);
-%!assert(sparse(bs\xs),sparse(bf\xf),1e-10);
+%! assert (sparse (pus\xs), sparse (puf\xf), 1e-10);
+%!assert (bs\xf, bf\xf, 1e-10);
+%!assert (sparse (bs\xs), sparse (bf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(cs\xf,cf\xf,1e-10);
+%! assert (cs\xf, cf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(cs\xs),sparse(cf\xf),1e-10);
+%! assert (sparse (cs\xs), sparse (cf\xf), 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(bcs\xf,bcf\xf,1e-10);
+%! assert (bcs\xf, bcf\xf, 1e-10);
 %!testif HAVE_UMFPACK
-%! assert(sparse(bcs\xs),sparse(bcf\xf),1e-10);
-%!assert(ts\xf,tf\xf,1e-10);
-%!assert(sparse(ts\xs),sparse(tf\xf),1e-10);
-%!assert(tcs\xf,tcf\xf,1e-10);
-%!assert(sparse(tcs\xs),sparse(tcf\xf),1e-10);
+%! assert (sparse (bcs\xs), sparse (bcf\xf), 1e-10);
+%!assert (ts\xf, tf\xf, 1e-10);
+%!assert (sparse (ts\xs), sparse (tf\xf), 1e-10);
+%!assert (tcs\xf, tcf\xf, 1e-10);
+%!assert (sparse (tcs\xs), sparse (tcf\xf), 1e-10);
 
 EOF
 
 cat >>$TESTS <<EOF
 %% QR solver tests
 
 %!function f(a, sz, feps)
-%! b = randn(sz); x = a \b; 
+%! b = randn (sz);
+%! x = a \ b; 
 %! assert (a * x, b, feps);
-%! b = randn(sz)+1i*randn(sz); x = a \ b;  
+%! b = randn (sz) + 1i*randn (sz);
+%! x = a \ b;  
 %! assert (a * x, b, feps);
-%! b = sprandn(sz(1),sz(2),0.2); x = a \b;
-%! assert (sparse(a * x), b, feps);
-%! b = sprandn(sz(1),sz(2),0.2)+1i*sprandn(sz(1),sz(2),0.2); x = a \b; 
-%! assert (sparse(a * x), b, feps);
+%! b = sprandn (sz(1),sz(2),0.2);
+%! x = a \ b;
+%! assert (sparse (a * x), b, feps);
+%! b = sprandn (sz(1),sz(2),0.2) + 1i*sprandn (sz(1),sz(2),0.2);
+%! x = a \ b; 
+%! assert (sparse (a * x), b, feps);
+%!endfunction
 %!testif HAVE_UMFPACK
-%! a = alpha*sprandn(10,11,0.2)+speye(10,11); f(a,[10,2],1e-10);
+%! a = alpha*sprandn (10,11,0.2) + speye (10,11);
+%! f(a,[10,2],1e-10);
 %! ## Test this by forcing matrix_type, as can't get a certain 
 %! ## result for over-determined systems.
-%! a = alpha*sprandn(10,10,0.2)+speye(10,10); matrix_type(a, "Singular");
+%! a = alpha*sprandn(10,10,0.2) + speye(10,10);
+%! matrix_type (a, "Singular");
 %! f(a,[10,2],1e-10);
 
 %% Rectanguar solver tests that don't use QR
 
 %!test
-%! ds = alpha * spdiags([1:11]',0,10,11);
-%! df = full(ds);
-%! xf = beta * ones(10,2);
-%! xs = speye(10,10);
-%!assert(ds\xf,df\xf,100*eps)
-%!assert(ds\xs,sparse(df\xs),100*eps)
+%! ds = alpha * spdiags ([1:11]',0,10,11);
+%! df = full (ds);
+%! xf = beta * ones (10,2);
+%! xs = speye (10,10);
+%!assert (ds\xf, df\xf, 100*eps)
+%!assert (ds\xs, sparse (df\xs), 100*eps)
 %!test
 %! pds = ds([2,1,3:10],:);
-%! pdf = full(pds);
-%!assert(pds\xf,pdf\xf,100*eps)
-%!assert(pds\xs,sparse(pdf\xs),100*eps)
+%! pdf = full (pds);
+%!assert (pds\xf, pdf\xf, 100*eps)
+%!assert (pds\xs, sparse (pdf\xs), 100*eps)
 %!test
-%! ds = alpha * spdiags([1:11]',0,11,10);
-%! df = full(ds);
-%! xf = beta * ones(11,2);
-%! xs = speye(11,11);
-%!assert(ds\xf,df\xf,100*eps)
-%!assert(ds\xs,sparse(df\xs),100*eps)
+%! ds = alpha * spdiags ([1:11]',0,11,10);
+%! df = full (ds);
+%! xf = beta * ones (11,2);
+%! xs = speye (11,11);
+%!assert (ds\xf, df\xf, 100*eps)
+%!assert (ds\xs, sparse (df\xs), 100*eps)
 %!test
 %! pds = ds([2,1,3:11],:);
-%! pdf = full(pds);
-%!assert(pds\xf,pdf\xf,100*eps)
-%!assert(pds\xs,sparse(pdf\xs),100*eps)
+%! pdf = full (pds);
+%!assert (pds\xf, pdf\xf, 100*eps)
+%!assert (pds\xs, sparse (pdf\xs), 100*eps)
 %!test
 %! us = alpha*[[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]];
 %!testif HAVE_UMFPACK
-%! assert(us*(us\xf),xf,100*eps)
+%! assert (us*(us\xf), xf, 100*eps)
 %!testif HAVE_UMFPACK
-%! assert(us*(us\xs),xs,100*eps)
+%! assert (us*(us\xs), xs, 100*eps)
 %!test
 %! pus = us(:,[2,1,3:12]);
 %!testif HAVE_UMFPACK
-%! assert(pus*(pus\xf),xf,100*eps)
+%! assert (pus*(pus\xf), xf, 100*eps)
 %!testif HAVE_UMFPACK
-%! assert(pus*(pus\xs),xs,100*eps)
+%! assert (pus*(pus\xs), xs, 100*eps)
 %!test
 %! us = alpha*[speye(11,9),[1;sparse(8,1);1;0]];
 %!testif HAVE_CXSPARSE
 %! [c,r] = qr (us, xf);
-%! assert(us\xf,r\c,100*eps)
+%! assert (us\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (us, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(us\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (us\xs, r\c, 100*eps)
 %!test
 %! pus = us(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xf);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pus\xf,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pus\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pus, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pus\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pus\xs, r\c, 100*eps)
 %!test
-%! ls = alpha*[speye(9,11);[1,sparse(1,8),1,0]];
-%! xf = beta * ones(10,2);
-%! xs = speye(10,10);
-%!assert(ls*(ls\xf),xf,100*eps)
-%!assert(ls*(ls\xs),xs,100*eps)
+%! ls = alpha*[speye(9,11);[1, sparse(1,8),1,0]];
+%! xf = beta * ones (10,2);
+%! xs = speye (10,10);
+%!assert (ls*(ls\xf), xf, 100*eps)
+%!assert (ls*(ls\xs), xs, 100*eps)
 %!test
 %! pls = ls([1:8,10,9],:);
-%!assert(pls*(pls\xf),xf,100*eps)
-%!assert(pls*(pls\xs),xs,100*eps)
+%!assert (pls*(pls\xf), xf, 100*eps)
+%!assert (pls*(pls\xs), xs, 100*eps)
 %!test
-%! ls = alpha*[speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]];
-%! xf = beta * ones(12,2);
-%! xs = speye(12,12);
+%! ls = alpha*[speye(10,10), sparse(10,1);[1;1], sparse(2,9),[1;1]];
+%! xf = beta * ones (12,2);
+%! xs = speye (12,12);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xf);
-%! assert(ls\xf,r\c,100*eps)
+%! assert (ls\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (ls, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(ls\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (ls\xs, r\c, 100*eps)
 %!testif HAVE_CXSPARSE
 %! pls = ls(:,[1:8,10,9]);
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xf);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pls\xf,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pls\xf, r\c, 100*eps)
 %!testif HAVE_UMFPACK
 %! [c,r] = qr (pls, xs);
-%! r = matrix_type(r,"Singular"); ## Force Matrix Type
-%! assert(pls\xs,r\c,100*eps)
+%! r = matrix_type (r, "Singular"); ## Force Matrix Type
+%! assert (pls\xs, r\c, 100*eps)
 
 EOF
 }
 
 
 # =============================================================
 # Putting it all together: defining the combined tests
 
@@ -1136,37 +1158,40 @@ fi
 echo '%!shared as,af,bs,bf' >> $TESTS
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%!test bf=3;' >>$TESTS
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
 %! bf = randn;
 EOF
 fi
 
 gen_scalar_tests
 gen_section
 
 # rectangular operations
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%!test bf=[0,1-1i,0,0;2+1i,0,0,0;3-1i,2+3i,0,0];' >> $TESTS
 else
     cat >>$TESTS <<EOF
 %!test
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! bs=sprandn(m,n,0.3); bf = full(bs+1i*sprandn(bs));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! bs = sprandn (m,n,0.3);
+%! bf = full (bs + 1i*sprandn (bs));
 EOF
 fi
 
 gen_rectangular_tests
 gen_section
 gen_save_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
@@ -1186,27 +1211,29 @@ gen_section
 # square operations
 if $preset; then
     echo '%!test af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%! as=sparse(af);' >> $TESTS
     echo '%!test bf=[0,1-1i,0,0;2+1i,0,0,0;3-1i,2+3i,0,0];' >> $TESTS
 else
     cat >>$TESTS <<EOF
 %!test
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! bs=sprandn(m,n,0.3); bf = full(bs+1i*sprandn(bs));
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! bs = sprandn (m,n,0.3);
+%! bf = full (bs + 1i*sprandn (bs));
 EOF
 fi
 
 cat >>$TESTS <<EOF
 %!test ;# invertible matrix
-%! bf=af'*bf+max(abs([af(:);bf(:)]))*sparse(eye(columns(as)));
-%! bs=sparse(bf);
+%! bf = af'*bf+max (abs ([af(:);bf(:)]))*sparse (eye (columns (as)));
+%! bs = sparse (bf);
 
 EOF
 
 gen_square_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
 echo '%! bs=sparse(bf);' >> $TESTS
 gen_square_tests
@@ -1221,67 +1248,70 @@ gen_square_tests
 gen_section
 
 # cholesky tests
 if $preset; then
   echo '%!test bf=[5,0,1+1i,0;0,5,0,1-2i;1-1i,0,5,0;0,1+2i,0,5];' >> $TESTS
   echo '%! bs=sparse(bf);' >> $TESTS
 else
   echo '# This has a small chance of failing to create a positive definite matrix' >> $TESTS
-  echo '%!test n=floor(lognrnd(8,2)+1)' >> $TESTS
-  echo '%! bs = n*speye(n,n) + sprandn(n,n,0.3); bf = full(bs);' >> $TESTS
+  echo '%!test n=floor (lognrnd (8,2)+1)' >> $TESTS
+  echo '%! bs = n*speye (n,n) + sprandn (n,n,0.3);' >> $TESTS
+  echo '%! bf = full (bs);' >> $TESTS
 fi
 
 gen_cholesky_tests
 gen_section
 echo '%!test bf=real(bf);' >> $TESTS
 echo '%! bs=sparse(bf);' >> $TESTS
 gen_cholesky_tests
 gen_section
 
 # assembly tests
 echo '%!shared r,c,m,n,fsum,funiq' >>$TESTS
 if $use_preset; then
     cat >>$TESTS <<EOF
 %!test
-%! r=[1,1,2,1,2,3];
-%! c=[2,1,1,1,2,1];
-%! m=n=0;
+%! r = [1,1,2,1,2,3];
+%! c = [2,1,1,1,2,1];
+%! m = n = 0;
 EOF
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! nz=ceil((m+n)/2);
-%! r=floor(rand(5,nz)*n)+1;
-%! c=floor(rand(5,nn)*m)+1;
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! nz = ceil ((m+n)/2);
+%! r = floor (rand (5,nz)*n)+1;
+%! c = floor (rand (5,nn)*m)+1;
 EOF
 fi
 gen_assembly_tests #includes real and complex tests
 gen_section
 
 # slicing tests
 echo '%!shared ridx,cidx,idx,as,af' >>$TESTS
 if $use_preset; then
     cat >>$TESTS <<EOF
 %!test
-%! af=[1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];
-%! ridx=[1,3]; cidx=[2,3];
+%! af = [1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];
+%! ridx = [1,3];
+%! cidx = [2,3];
 EOF
 else
     cat >>$TESTS <<EOF
 %!test
 %! % generate m,n from 1 to <5000
-%! m=floor(lognrnd(8,2)+1);
-%! n=floor(lognrnd(8,2)+1);
-%! as=sprandn(m,n,0.3); af = full(as+1i*sprandn(as));
-%! ridx = ceil(m*rand(1,ceil(rand*m))
-%! cidx = ceil(n*rand(1,ceil(rand*n))
+%! m = floor (lognrnd (8,2)+1);
+%! n = floor (lognrnd (8,2)+1);
+%! as = sprandn (m,n,0.3);
+%! af = full (as + 1i*sprandn (as));
+%! ridx = ceil (m*rand (1,ceil (rand*m));
+%! cidx = ceil (n*rand (1,ceil (rand*n));
 EOF
 fi
 gen_scalar_select_tests
 gen_select_tests
 echo '%!test af=real(af);' >> $TESTS
 gen_select_tests
 gen_section
 echo '%!shared alpha,beta,df,pdf,lf,plf,uf,puf,bf,cf,bcf,tf,tcf,xf,ds,pds,ls,pls,us,pus,bs,cs,bcs,ts,tcs,xs' >>$TESTS
diff --git a/test/classes/test_classes.m b/test/classes/test_classes.m
--- a/test/classes/test_classes.m
+++ b/test/classes/test_classes.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 Robert T. Short
+## Copyright (C) 2009-2012 Robert T. Short
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/ctor-vs-method/test_ctor_vs_method.m b/test/ctor-vs-method/test_ctor_vs_method.m
--- a/test/ctor-vs-method/test_ctor_vs_method.m
+++ b/test/ctor-vs-method/test_ctor_vs_method.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m b/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
--- a/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
+++ b/test/fcn-handle-derived-resolution/test_fcn_handle_derived_resolution.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2011 John W. Eaton
+## Copyright (C) 2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2011 David Bateman
+## Copyright (C) 2005-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/test/test_args.m b/test/test_args.m
--- a/test/test_args.m
+++ b/test/test_args.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,192 +18,219 @@
 
 ########################################
 ## No inputs or no outputs
 
 ## no input or output arguments
 %!function f ()
 %!  assert (nargin, 0);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f;
 
 ## one input with two possible inputs
 %!function f (x, y)
 %!  assert (nargin, 1);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f (1);
 
 ## no inputs, one of multiple outputs
 %!function [x, y] = f ()
 %!  assert (nargin, 0);
 %!  assert (nargout, 1);
 %!  x = 2;
+%!endfunction
 %!test
 %! assert (f (), 2);
 
 ## one of multiple inputs, one of multiple outputs
 %!function [x, y] = f (a, b)
 %!  assert (nargin, 1);
 %!  assert (nargout, 1);
 %!  x = a;
+%!endfunction
 %!test
 %! assert (f (1), 1);
 
 ########################################
 ## Varargin, varargout
 
 ## varargin and varargout with no inputs or outputs
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 0);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f;
 
 ## varargin and varargout with one input
 %!function [varargout] = f (x, varargin)
 %!  assert (nargin, 1);
 %!  assert (nargout, 0);
+%!endfunction
 %!test
 %! f (1);
 
 ## varargin and varargout with one output
 %!function [x, varargout] = f (varargin)
 %!  assert (nargin, 0);
 %!  assert (nargout, 1);
 %!  x = 2;
+%!endfunction
 %!test
 %! assert (f (), 2);
 
 ## varargin and varargout with one input and output
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 1);
 %!  assert (nargout, 1);
 %!  varargout{1} = varargin{1};
+%!endfunction
 %!test
 %! assert (f (1), 1);
 
 ## multiple inputs, multiple outputs, but not all of either
 ## WARNING: The original test did not assign the outputs, it just
 ## requested them, and I think that is supposed to be an error.  It also
 ## still has a non-assigned output argument.
 %!function [x, y, z] = f (a, b, c, d, e)
 %!  assert (nargin, 4);
 %!  assert (nargout, 2);
 %!  x = a;
 %!  y = b;
+%!endfunction
 %!test
 %! [s, t] = f (1, 2, 3, 4);
-%! assert([s t], [1 2]);
+%! assert ([s t], [1 2]);
 
 ## Fully used varargin and varargout
 %!function [varargout] = f (varargin)
 %!  assert (nargin, 3);
 %!  assert (nargout, 4);
 %!  varargout{1} = varargin{1};
 %!  varargout{2} = varargin{2};
 %!  varargout{3} = varargin{3};
 %!  varargout{4} = 4;
+%!endfunction
 %!test
 %! [s, t, u, v] = f (1, 2, 3);
-%! assert([s t u v], [1 2 3 4]);
+%! assert ([s t u v], [1 2 3 4]);
 
 ## Test default arguments
 ## numeric
 %!function f (x = 0)
-%!  assert (x, 0)
+%!  assert (x, 0);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (spaces)
 %!function f (x = [0 1 2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (range)
 %!function f (x = 1:3)
-%!  assert (x, 1:3)
+%!  assert (x, 1:3);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (commas)
 %!function f (x = [0,1,2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric vector (commas and spaces)
 %!function f (x = [0, 1, 2])
-%!  assert (x, [0 1 2])
+%!  assert (x, [0 1 2]);
+%!endfunction
 %!test
 %!  f()
 
 ## numeric matrix
 %!function f (x = [0, 1, 2;3, 4, 5])
-%!  assert (x, [0 1 2;3 4 5])
+%!  assert (x, [0 1 2;3 4 5]);
+%!endfunction
 %!test
 %!  f()
 
 ## empty cell
 %!function f (x = {})
-%!  assert (x, {})
+%!  assert (x, {});
+%!endfunction
 %!test
 %!  f()
 
 ## full cell
 %!function f (x = {1})
-%!  assert (x, {1})
+%!  assert (x, {1});
+%!endfunction
 %!test
 %!  f()
 
 ## many cells
 %!function f (x = {1 'a' "b" 2.0 struct("a", 3)})
-%!  assert (x, {1 'a' "b" 2.0 struct("a", 3)})
+%!  assert (x, {1 'a' "b" 2.0 struct("a", 3)});
+%!endfunction
 %!test
 %!  f()
 
 ## struct
 %!function f (x = struct("a", 3))
-%!  assert (x, struct ("a", 3))
+%!  assert (x, struct ("a", 3));
+%!endfunction
 %!test
 %!  f()
 
 ## char (double quotes)
 %!function f (x = "a")
-%!  assert (x, "a")
+%!  assert (x, "a");
+%!endfunction
 %!test
 %!  f()
 
 ## char (single quotes)
 %!function f (x = 'a')
-%!  assert (x, "a")
+%!  assert (x, "a");
+%!endfunction
 %!test
 %!  f()
 
 ## char (string, double quotes)
 %!function f (x = "abc123")
-%!  assert (x, "abc123")
+%!  assert (x, "abc123");
+%!endfunction
 %!test
 %!  f()
 
 ## char (string, double quotes, punctuation)
 %!function f (x = "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\")
-%!  assert (x, "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\")
+%!  assert (x, "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\");
+%!endfunction
 %!test
 %!  f()
 
 ## Function handle (builtin)
 %!function f (x = @sin)
 %!  finfo = functions (x);
 %!  fname = finfo.function;
 %!  assert (isa (x, "function_handle") && strcmp (fname, "sin"));
+%!endfunction
 %!test
 %!  f()
 
 ## Function handle (anonymous)
 %!function f (x = @(x) x.^2)
 %!  finfo = functions (x);
 %!  ftype = finfo.type;
 %!  assert (isa (x, "function_handle") && strcmp (ftype, "anonymous"));
+%!endfunction
 %!test
 %!  f()
+
diff --git a/test/test_diag_perm.m b/test/test_diag_perm.m
--- a/test/test_diag_perm.m
+++ b/test/test_diag_perm.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2011 E. Jason Riedy
+## Copyright (C) 2009-2012 E. Jason Riedy
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -214,52 +214,52 @@
 %! assert (full (Dr \ A), full (A) ./ repmat (scalefact, 1, n));
 
 ## narrow sparse inverse row scaling
 %!test
 %! n = 8;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (n-2, 1);
 %! Dr = diag (scalefact, n, n-2);
-%! assert (full (Dr \ A), Dr \ full(A))
+%! assert (full (Dr \ A), Dr \ full(A));
 
 ## sparse inverse column scaling with a zero factor
 %!test
 %! n = 11;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (1, n);
 %! Dc = diag (scalefact);
 %! scalefact(n-1) = Inf;
 %! Dc(n-1, n-1) = 0;
-%! assert (full (A / Dc), full(A) / Dc)
+%! assert (full (A / Dc), full(A) / Dc);
 
 ## short sparse inverse column scaling
 %!test
 %! n = 7;
 %! A = sprand (n, n, .5);
 %! scalefact = rand (1, n-2) + I () * rand(1, n-2);
 %! Dc = diag (scalefact, n-2, n);
-%! assert (full (A / Dc), full(A) / Dc)
+%! assert (full (A / Dc), full(A) / Dc);
 
 ## adding sparse and diagonal stays sparse
 %!test
 %! n = 9;
 %! A = sprand (n, n, .5);
 %! D = 2 * eye (n);
-%! assert (typeinfo (A + D), "sparse matrix")
-%! assert (typeinfo (A - D), "sparse matrix")
+%! assert (typeinfo (A + D), "sparse matrix");
+%! assert (typeinfo (A - D), "sparse matrix");
 %! D = D * I () + D;
-%! assert (typeinfo (A - D), "sparse complex matrix")
+%! assert (typeinfo (A - D), "sparse complex matrix");
 %! A = A * I () + A;
-%! assert (typeinfo (D - A), "sparse complex matrix")
+%! assert (typeinfo (D - A), "sparse complex matrix");
 
 ## adding sparse and diagonal stays sparse
 %!test
 %! n = 9;
 %! A = sprand (n, n, .5);
 %! D = 2 * eye (n);
-%! assert (full (A + D), full (A) + D)
-%! assert (full (A - D), full (A) - D)
+%! assert (full (A + D), full (A) + D);
+%! assert (full (A - D), full (A) - D);
 %! D = D * I () + D;
-%! assert (full (D + A), D + full (A))
+%! assert (full (D + A), D + full (A));
 %! A = A * I () + A;
 %! A(6, 4) = nan ();
-%! assert (full (D - A), D - full (A))
+%! assert (full (D - A), D - full (A));
diff --git a/test/test_error.m b/test/test_error.m
--- a/test/test_error.m
+++ b/test/test_error.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,73 +11,83 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
+## Test %!error usage
+
 %% test/octave.test/error/error-1.m
 %!function g () 
-%! error ("foo");
+%!  error ("foo");
+%!endfunction
 %!function f () 
-%! g (); 
-%!error <foo> f ();
+%!  g (); 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/error-2.m
 %!function g () 
-%! error ("foo\n");
+%!  error ("foo\n");
+%!endfunction
 %!function f () 
-%! g 
-%!error <foo> f ();
+%!  g 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/error-3.m
-%!error error ();
+%!error error ()
 
 %% test/octave.test/error/error-4.m
-%!error <foo> error ("foo\n");
+%!error <foo> error ("foo\n")
 
-%% FIXME Why can't I use %!warning <foo> f;
+## Test %!warning usage
+
 %% test/octave.test/error/warning-1.m
 %!function g ()
-%! warning ("foo");
+%!  warning ("foo");
+%!endfunction
 %!function f ()
-%! g;
-%!test
-%! fail("f","warning","foo");
+%!  g;
+%!endfunction
+%!warning <foo> f ()
 
 %% test/octave.test/error/warning-2.m
 %!test
 %! st.identifier = "backtrace";
-%! ws = warning ("query","backtrace");
-%! warning ("on","backtrace");
+%! ws = warning ("query", "backtrace");
+%! warning ("on", "backtrace");
 %! st.state = "on";
-%! assert(warning ("query","backtrace"),st);
-%! warning ("off","backtrace");
+%! assert(warning ("query", "backtrace"), st);
+%! warning ("off", "backtrace");
 %! st.state = "off";
-%! assert(warning ("query","backtrace"),st);
-%! warning (ws.state,"backtrace");
+%! assert(warning ("query", "backtrace"), st);
+%! warning (ws.state, "backtrace");
 
-%% FIXME This test no longer makes sense with new warning syntax
-%% test/octave.test/error/warning-3.m
-%!#warning <foo> warning ("foo", 1);
+## Test usage() function
 
 %% test/octave.test/error/usage-1.m
 %!function g () 
-%! usage ("foo");
+%!  usage ("foo");
+%!endfunction
 %!function f () 
-%! g (); 
-%!error <foo> f ();
+%!  g (); 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/usage-2.m
 %!function g () 
-%! usage ("foo");
+%!  usage ("foo");
+%!endfunction
 %!function f () 
-%! g 
-%!error <foo> f ();
+%!  g 
+%!endfunction
+%!error <foo> f ()
 
 %% test/octave.test/error/usage-3.m
-%!error usage ();
+%!error usage ()
 
 %% test/octave.test/error/usage-4.m
-%!error <foo> usage ("foo\n");
+%!error <foo> usage ("foo\n")
 
diff --git a/test/test_eval-catch.m b/test/test_eval-catch.m
--- a/test/test_eval-catch.m
+++ b/test/test_eval-catch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -17,58 +17,57 @@
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/eval-catch/eval-catch-1.m
 %!test
 %! eval ("clear a; a;", "");
 
 %% test/octave.test/eval-catch/eval-catch-2.m
 %!test
-%! eval ("", "error('Shouldn't get here');");
+%! eval ("", "error ('Should not get here');");
 
 %% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
-%% FIXME This is redundant with the changes to the above
-%% test/octave.test/eval-catch/eval-catch-4.m
-
 %% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
-%! assert(lasterr()(1:13),"`a' undefined");
-%! assert(str(1:13),"`a' undefined");
+%! assert (lasterr()(1:13), "`a' undefined");
+%! assert (str(1:13), "`a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-6.m
 %!test
-%! eval ("error (\"user-defined error\"); str = '';", "str = lasterr;");
-%! assert(lasterr()(1:18),"user-defined error");
-%! assert(str(1:18),"user-defined error");
+%! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
+%! assert (lasterr()(1:18), "user-defined error");
+%! assert (str(1:18), "user-defined error");
 
 %% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
+%!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
-%! assert(mangle(lasterr)(1:14),"<`a' undefined");
-%! assert(str(1:14),"<`a' undefined");
+%! assert (mangle(lasterr)(1:14), "<`a' undefined");
+%! assert (str(1:14), "<`a' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
 %! "str2 = lasterr;");
-%! assert(str1(1:13),"`a' undefined");
-%! assert(str2(1:13),"`b' undefined");
+%! assert (str1(1:13), "`a' undefined");
+%! assert (str2(1:13), "`b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-9.m
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
-%! assert(str1(1:13),"`b' undefined");
-%! assert(str2(1:13),"`b' undefined");
+%! assert (str1(1:13), "`b' undefined");
+%! assert (str2(1:13), "`b' undefined");
 
 %% test/octave.test/eval-catch/eval-catch-10.m
 %!test
 %! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
-%! assert(str(1:22),"rethrow: `a' undefined");
+%! assert (str(1:22), "rethrow: `a' undefined");
+
diff --git a/test/test_for.m b/test/test_for.m
--- a/test/test_for.m
+++ b/test/test_for.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,98 +14,98 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/for/for-1.m
 %!test
 %! for i = 1
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! end
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/for/for-2.m
 %!test
 %! for i = 1:4
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-3.m
 %!test
 %! for i = [1,2,3,4]
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-4.m
 %!test
 %! for i = [1,2;3,4]
-%! printf_assert ("%d", i(1,1));
-%! printf_assert ("%d", i(2,1));
+%!   printf_assert ("%d", i(1,1));
+%!   printf_assert ("%d", i(2,1));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1324"));
+%! assert (prog_output_assert ("1324"));
 
 %% test/octave.test/for/for-5.m
 %!test
 %! for i = I
-%! printf_assert ("%d", imag (i));
+%!   printf_assert ("%d", imag (i));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/for/for-6.m
 %!test
 %! for i = [1,2,3,4]*I
-%! printf_assert ("%d", imag (i));
+%!   printf_assert ("%d", imag (i));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1234"));
+%! assert (prog_output_assert ("1234"));
 
 %% test/octave.test/for/for-7.m
 %!test
 %! for i = [1,2;3,4]*I
-%! printf_assert ("%d", imag (i(1,1)));
-%! printf_assert ("%d", imag (i(2,1)));
+%!   printf_assert ("%d", imag (i(1,1)));
+%!   printf_assert ("%d", imag (i(2,1)));
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("1324"));
+%! assert (prog_output_assert ("1324"));
 
 %% test/octave.test/for/for-8.m
 %!test
 %! for i = [1,2,3,4]
-%! if (i > 2)
-%! break;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i > 2)
+%!     break;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("12"));
+%! assert (prog_output_assert ("12"));
 
 %% test/octave.test/for/for-9.m
 %!test
 %! for i = [1,2,3,4]
-%! if (i < 3)
-%! continue;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i < 3)
+%!     continue;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endfor
 %! printf_assert ("\n");
-%! assert(prog_output_assert("34"));
+%! assert (prog_output_assert ("34"));
 
 %!test
 %! a = [1,3;2,4];
 %! j = 0;
 %! for i = cat (3, a, 4 + a)
 %!   assert (i, [1;2] + 2*j++)
 %! endfor
 
 %!test
 %! a = {1,3;2,4};
 %! j = 0;
-%! for i = cat (3, a, cellfun(@(x) 4 + x, a, 'UniformOutput', 0))
+%! for i = cat (3, a, cellfun(@(x) 4 + x, a, "UniformOutput", 0))
 %!   assert (i, {1 + 2*j; 2 + 2*j++})
 %! endfor
diff --git a/test/test_func.m b/test/test_func.m
--- a/test/test_func.m
+++ b/test/test_func.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 David Bateman
+## Copyright (C) 2008-2012 David Bateman
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -18,175 +18,175 @@
 
 ## This piece of test code ensures that all operations which work on 
 ## dimensions alone (squeeze, triu, etc.) work for all objects and 
 ## preserve type. Even if the object is an empty matrix. This code is
 ## not to check that the function itself returns teh correct result,
 ## just that the results are consistent for all types.
 
 %!function __fntestfunc__ (fn, mn, varargin)
-%!  typ = {'double', 'complex', 'logical', 'sparse', 'complex sparse', ...
-%!         'logical sparse', 'int8', 'int16', 'int32', 'int64', 'uint8', ...
-%!         'uint16', 'uint32', 'uint64', 'char', 'cell', 'struct', ...
-%!         'single', 'single complex'};
+%!  typ = {"double", "complex", "logical", "sparse", "complex sparse", ...
+%!         "logical sparse", "int8", "int16", "int32", "int64", "uint8", ...
+%!         "uint16", "uint32", "uint64", "char", "cell", "struct", ...
+%!         "single", "single complex"};
 %!
 %!  cmplx = [2, 5, 18];
 %!  nlogical = [3, 6];
 %!  ninteger = [7, 8, 9, 10, 11, 12, 13, 14];
 %!  nsparse = [4, 5, 6];
 %!  skip = {};
 %!
 %!  if (length (varargin) > 0 && iscell (varargin{1}))
 %!    skip = varargin{1};
 %!    varargin(1) = [];
 %!  endif
 %!
-%!  for i = 1 : length(typ)
+%!  for i = 1 : length (typ)
 %!    if (any (strcmp (skip, typ {i})))
 %!      continue;
 %!    endif
 %!    m = mn;
 %!
 %!    if (any (nsparse == i))
 %!      if (ndims (m) > 2)
 %!        sz = size (m);
-%!        m = reshape (m, [sz(1), prod(sz (2:end))]);
+%!        m = reshape (m, [sz(1), prod(sz(2:end))]);
 %!      endif
 %!      if (any (cmplx == i))
 %!        m = sparse ((1 + 1i) * m);
 %!      else
 %!        m = sparse (m);
 %!      endif
 %!    else
 %!      if (any (cmplx == i))
 %!        m = (1 + 1i) * m;
 %!      endif
 %!    endif
 %!    if (any (nlogical == i))
-%!      m = cast (m, 'logical');
+%!      m = cast (m, "logical");
 %!    endif
 %!    if (any (ninteger == i))
 %!      m = cast (m, typ{i});
 %!    endif
-%!    if (strcmp (typ{i}, 'cell'))
+%!    if (strcmp (typ{i}, "cell"))
 %!      m = num2cell (m);
-%!    elseif (strcmp (typ{i}, 'struct'))
-%!      m = struct ('fld', num2cell (m));
+%!    elseif (strcmp (typ{i}, "struct"))
+%!      m = struct ("fld", num2cell (m));
 %!    endif
 %!
 %!    y = feval (fn, m, varargin{:});
 %!    y2 = feval (fn, reshape (mn, size (m)), varargin{:});
 %!    if (!strcmp (class (y), class (m)) ||
 %!         issparse (y) != issparse (m) || !size_equal (y, y2))
-%!      error ('failed for type %s\n', typ{i});
+%!      error ("failed for type %s\n", typ{i});
 %!    endif
-%!    if (!(strcmp (typ{i}, 'cell') || strcmp (typ{i}, 'struct')) &&
-%!        any (vec (cast (real (y), 'double')) !=
-%!             vec (feval (fn , cast (real (m), 'double'), varargin{:}))))
-%!      error ('failed for type %s\n', typ{i});
+%!    if (!(strcmp (typ{i}, "cell") || strcmp (typ{i}, "struct")) &&
+%!        any (vec (cast (real (y), "double")) !=
+%!             vec (feval (fn , cast (real (m), "double"), varargin{:}))))
+%!      error ("failed for type %s\n", typ{i});
 %!    endif
 %!  endfor
-%! endfunction
+%!endfunction
 
 %!shared m0, m1, m2, m3
 %! m0 = [1:5];
 %! m1 = reshape ([1 : 30], [5, 6]);
 %! m2 = reshape ([1 : 30], [5, 1, 6]);
 %! m3 = [];
 
 %!test
-%! __fntestfunc__('triu', m1, {'struct'});
+%! __fntestfunc__("triu", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('triu', m1, {'struct'}, -1);
+%! __fntestfunc__ ("triu", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('triu', m1, {'struct'}, 1);
+%! __fntestfunc__ ("triu", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__('triu', m3, {'struct'});
+%! __fntestfunc__("triu", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'});
+%! __fntestfunc__ ("tril", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'}, -1);
+%! __fntestfunc__ ("tril", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('tril', m1, {'struct'}, 1);
+%! __fntestfunc__ ("tril", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__('tril', m3, {'struct'});
+%! __fntestfunc__("tril", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('squeeze', m2);
+%! __fntestfunc__ ("squeeze", m2);
 %!test
-%! __fntestfunc__ ('squeeze', m3);
+%! __fntestfunc__ ("squeeze", m3);
 %!test
-%! __fntestfunc__ ('permute', m1, [2, 1]);
+%! __fntestfunc__ ("permute", m1, [2, 1]);
 %!test
-%! __fntestfunc__ ('permute', m2, {'sparse', 'logical sparse', 'complex sparse'}, [3, 1, 2]);
+%! __fntestfunc__ ("permute", m2, {"sparse", "logical sparse", "complex sparse"}, [3, 1, 2]);
 %!test
-%! __fntestfunc__ ('permute', m3, [2, 1]);
+%! __fntestfunc__ ("permute", m3, [2, 1]);
 %!test
-%! __fntestfunc__ ('ipermute', m1, [2, 1]);
+%! __fntestfunc__ ("ipermute", m1, [2, 1]);
 %!test
-%! __fntestfunc__ ('ipermute', m2, {'sparse', 'logical sparse', 'complex sparse'}, [3, 1, 2]);
+%! __fntestfunc__ ("ipermute", m2, {"sparse", "logical sparse", "complex sparse"}, [3, 1, 2]);
 %!test
-%! __fntestfunc__ ('ipermute', m3, [2, 1]);
+%! __fntestfunc__ ("ipermute", m3, [2, 1]);
 %!test
-%! __fntestfunc__ ('shiftdim', m2, 1);
+%! __fntestfunc__ ("shiftdim", m2, 1);
 %!test
-%! __fntestfunc__ ('shiftdim', m2, {'sparse', 'logical sparse', 'complex sparse'}, -1);
+%! __fntestfunc__ ("shiftdim", m2, {"sparse", "logical sparse", "complex sparse"}, -1);
 %!test
-%! __fntestfunc__ ('shiftdim', m3, 1);
+%! __fntestfunc__ ("shiftdim", m3, 1);
 %!test
-%! __fntestfunc__ ('circshift', m2, 1);
+%! __fntestfunc__ ("circshift", m2, 1);
 %!test
-%! __fntestfunc__ ('circshift', m2, [1, -1]);
+%! __fntestfunc__ ("circshift", m2, [1, -1]);
 %!test
-%! __fntestfunc__ ('circshift', m3, 1);
+%! __fntestfunc__ ("circshift", m3, 1);
 %!test
-%! __fntestfunc__ ('reshape', m2, [6, 5]);
+%! __fntestfunc__ ("reshape", m2, [6, 5]);
 %!test
-%! __fntestfunc__ ('reshape', m3, [1, 0]);
+%! __fntestfunc__ ("reshape", m3, [1, 0]);
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'});
+%! __fntestfunc__ ("diag", m0, {"struct"});
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'}, 1);
+%! __fntestfunc__ ("diag", m0, {"struct"}, 1);
 %!test
-%! __fntestfunc__ ('diag', m0, {'struct'}, -1);
+%! __fntestfunc__ ("diag", m0, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'});
+%! __fntestfunc__ ("diag", m1, {"struct"});
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'}, 1);
+%! __fntestfunc__ ("diag", m1, {"struct"}, 1);
 %!test
-%! __fntestfunc__ ('diag', m1, {'struct'}, -1);
+%! __fntestfunc__ ("diag", m1, {"struct"}, -1);
 %!test
-%! __fntestfunc__ ('diag', m3, {'struct'});
+%! __fntestfunc__ ("diag", m3, {"struct"});
 %!test
-%! __fntestfunc__ ('fliplr', m1);
+%! __fntestfunc__ ("fliplr", m1);
 %!test
-%! __fntestfunc__ ('fliplr', m3);
+%! __fntestfunc__ ("fliplr", m3);
 %!test
-%! __fntestfunc__ ('flipud', m1);
+%! __fntestfunc__ ("flipud", m1);
 %!test
-%! __fntestfunc__ ('flipud', m3);
+%! __fntestfunc__ ("flipud", m3);
 %!test
-%! __fntestfunc__ ('flipdim', m1, 2);
+%! __fntestfunc__ ("flipdim", m1, 2);
 %!test
-%! __fntestfunc__ ('flipdim', m3, 2);
+%! __fntestfunc__ ("flipdim", m3, 2);
 %!test
-%! __fntestfunc__ ('transpose', m1);
+%! __fntestfunc__ ("transpose", m1);
 %!test
-%! __fntestfunc__ ('transpose', m3);
+%! __fntestfunc__ ("transpose", m3);
 %!test
-%! __fntestfunc__ ('ctranspose', m1);
+%! __fntestfunc__ ("ctranspose", m1);
 %!test
-%! __fntestfunc__ ('ctranspose', m3);
+%! __fntestfunc__ ("ctranspose", m3);
 %!test
-%! __fntestfunc__ ('rot90', m1);
+%! __fntestfunc__ ("rot90", m1);
 %!test
-%! __fntestfunc__ ('rot90', m1, 2);
+%! __fntestfunc__ ("rot90", m1, 2);
 %!test
-%! __fntestfunc__ ('rot90', m1, -1);
+%! __fntestfunc__ ("rot90", m1, -1);
 %!test
-%! __fntestfunc__ ('rot90', m3);
+%! __fntestfunc__ ("rot90", m3);
 %!test
-%! __fntestfunc__ ('rotdim', m2, 1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, 1, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m2, 2, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, 2, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m2, -1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m2, -1, [1, 2]);
 %!test
-%! __fntestfunc__ ('rotdim', m3, 1, [1, 2]);
+%! __fntestfunc__ ("rotdim", m3, 1, [1, 2]);
diff --git a/test/test_global.m b/test/test_global.m
--- a/test/test_global.m
+++ b/test/test_global.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,69 +14,78 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/global/global-1.m
 %!test
 %! global G = 1;
-%! assert(G,1)
+%! assert (G,1);
 
 %% test/octave.test/global/global-2.m
 %!function f ()
 %!  global G;
-%!  assert(G,1);
+%!  assert (G,1);
+%!endfunction
 %!test
 %! global G = 1;
 %! f;
 
 %% test/octave.test/global/global-3.m
 %!function f ()
-%!  fail("G");
+%!  fail ("G");
+%!endfunction
 %!test
 %! global G = 1;
 %! f();
 
 %% test/octave.test/global/global-4.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
 %!  f;
-%!  fail("H");
+%!  fail ("H");
 
 %% test/octave.test/global/global-5.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
 %!function g ()
-%!  fail("H");
+%!  fail ("H");
 %!test
 %! g();
 
 %% test/octave.test/global/global-6.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!function g ()
 %!  global H;
-%!  assert(H,1);
+%!  assert (H,1);
+%!endfunction
 %!test
 %! f();
 %! g();
 
 %% test/octave.test/global/global-7.m
 %!test
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!test
-%! fail("H");
+%! fail ("H");
 
 %% test/octave.test/global/global-8.m
 %!function f ()
 %!  global H = 1;
+%!endfunction
 %!function g ()
 %!  global H;
-%!  assert(H,1)
+%!  assert (H,1);
+%!endfunction
 %!test
 %! f;
-%! clear H
+%! clear H;
 %! g;
 
diff --git a/test/test_if.m b/test/test_if.m
--- a/test/test_if.m
+++ b/test/test_if.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,73 +15,73 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/if/if-1.m
 %!test
 %! i = 0;
 %! if (i == 0)
-%! i++;
-%! printf_assert ("%d\n", i);
+%!   i++;
+%!   printf_assert ("%d\n", i);
 %! endif
-%! assert(prog_output_assert("1"));
+%! assert (prog_output_assert ("1"));
 
 %% test/octave.test/if/if-2.m
 %!test
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! else
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-3.m
 %!test
 %! x = 2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! endif
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-4.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (y)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-5.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! else
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! endif
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
 %% test/octave.test/if/if-6.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (y)
-%! printf_assert ("pass\n");
+%!   printf_assert ("pass\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! elseif (x)
-%! printf_assert ("fail\n");
+%!   printf_assert ("fail\n");
 %! end
-%! assert(prog_output_assert("pass"));
+%! assert (prog_output_assert ("pass"));
 
diff --git a/test/test_index-wfi-t.m b/test/test_index-wfi-t.m
deleted file mode 100644
--- a/test/test_index-wfi-t.m
+++ /dev/null
@@ -1,262 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/index-wfi-t/s-1.m
-%!test
-%! a = [];
-%! assert(isempty (a));
-
-%% test/octave.test/index-wfi-t/s-2.m
-%!test
-%! a = 1;
-%! assert(a(1),1);
-
-%% test/octave.test/index-wfi-t/s-3.m
-%!test
-%! a = 1;
-%! assert(a(:),1);
-
-%% test/octave.test/index-wfi-t/s-4.m
-%!test
-%! a = 1;
-%! assert(a(:,:),1);
-
-%% test/octave.test/index-wfi-t/s-5.m
-%!test
-%! a = 1;
-%! assert(a(1,:),1);
-
-%% test/octave.test/index-wfi-t/s-6.m
-%!test
-%! a = 1;
-%! assert(a(:,1),1);
-
-%% test/octave.test/index-wfi-t/s-7.m
-%!test
-%! a = 1;
-%! assert(isempty (a(logical (0))));
-
-%% test/octave.test/index-wfi-t/s-8.m
-%!test
-%! a = 1;
-%! fail("a(-1);");
-
-%% test/octave.test/index-wfi-t/s-9.m
-%!test
-%! a = 1;
-%! fail("a(2);");
-
-%% test/octave.test/index-wfi-t/s-10.m
-%!test
-%! a = 1;
-%! fail("a(2,:);");
-
-%% test/octave.test/index-wfi-t/s-11.m
-%!test
-%! a = 1;
-%! fail("a(:,2);");
-
-%% test/octave.test/index-wfi-t/s-12.m
-%!test
-%! a = 1;
-%! fail("a(-1,:);");
-
-%% test/octave.test/index-wfi-t/s-13.m
-%!test
-%! a = 1;
-%! fail("a(:,-1);");
-
-%% test/octave.test/index-wfi-t/s-14.m
-%!test
-%! a = 1;
-%! fail("a([1,2,3]);");
-
-%% test/octave.test/index-wfi-t/s-15.m
-%!test
-%! a = 1;
-%! fail("a([1;2;3]);");
-
-%% test/octave.test/index-wfi-t/s-16.m
-%!test
-%! a = 1;
-%! fail("a([1,2;3,4]);");
-
-%% test/octave.test/index-wfi-t/s-17.m
-%!test
-%! a = 1;
-%! fail("a([0,1]);");
-
-%% test/octave.test/index-wfi-t/s-18.m
-%!test
-%! a = 1;
-%! fail("a([0;1]);");
-
-%% test/octave.test/index-wfi-t/s-19.m
-%!test
-%! a = 1;
-%! fail("a([-1,0]);");
-
-%% test/octave.test/index-wfi-t/s-20.m
-%!test
-%! a = 1;
-%! fail("a([-1;0]);");
-
-%% test/octave.test/index-wfi-t/v-1.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(1),4);
-
-%% test/octave.test/index-wfi-t/v-2.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(2),3);
-
-%% test/octave.test/index-wfi-t/v-3.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:) == a_prime));
-
-%% test/octave.test/index-wfi-t/v-4.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(1,:) == a));
-
-%% test/octave.test/index-wfi-t/v-5.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(:,3),2);
-
-%% test/octave.test/index-wfi-t/v-6.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:,:) == a));
-
-%% test/octave.test/index-wfi-t/v-7.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(logical ([0,1,1,0])) == mid_a));
-
-%% test/octave.test/index-wfi-t/v-8.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/v-9.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(5);");
-
-%% test/octave.test/index-wfi-t/v-10.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0,1);");
-
-%% test/octave.test/index-wfi-t/v-11.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(logical (0),:)));
-
-%% test/octave.test/index-wfi-t/v-12.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(:,0);");
-
-%% test/octave.test/index-wfi-t/v-13.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([])));
-
-%% test/octave.test/index-wfi-t/v-14.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([],:)));
-
-%% test/octave.test/index-wfi-t/v-15.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(:,[])));
-
-%% test/octave.test/index-wfi-t/m-1.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (all (a(:,:) == a)));
-
-%% test/octave.test/index-wfi-t/m-2.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (a(:) == a_fvec));
-
-%% test/octave.test/index-wfi-t/m-3.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-t/m-4.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(2);","warning");
diff --git a/test/test_index-wfi-f.m b/test/test_index.m
rename from test/test_index-wfi-f.m
rename to test/test_index.m
--- a/test/test_index-wfi-f.m
+++ b/test/test_index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,316 +11,132 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/index-wfi-f/s-1.m
 %!test
 %! a = [];
-%! assert(isempty (a));
-
-%% test/octave.test/index-wfi-f/s-2.m
-%!test
-%! a = 1;
-%! assert(a(1),1);
-
-%% test/octave.test/index-wfi-f/s-3.m
-%!test
-%! a = 1;
-%! assert(a(:),1);
-
-%% test/octave.test/index-wfi-f/s-4.m
-%!test
-%! a = 1;
-%! assert(a(:,:),1);
-
-%% test/octave.test/index-wfi-f/s-5.m
-%!test
-%! a = 1;
-%! assert(a(1,:),1);
+%! assert (isempty (a));
 
-%% test/octave.test/index-wfi-f/s-6.m
-%!test
-%! a = 1;
-%! assert(a(:,1),1);
-
-%% test/octave.test/index-wfi-f/s-7.m
-%!test
-%! a = 1;
-%! assert(isempty (a(logical (0))));
-
-%% test/octave.test/index-wfi-f/s-8.m
-%!test
-%! a = 1;
-%! fail("a(-1)");
-
-%% test/octave.test/index-wfi-f/s-9.m
-%!test
-%! a = 1;
-%! fail("a(2);");
-
-%% test/octave.test/index-wfi-f/s-10.m
-%!test
-%! a = 1;
-%! fail("a(2,:);");
-
-%% test/octave.test/index-wfi-f/s-11.m
-%!test
+%!shared a
 %! a = 1;
-%! fail("a(:,2);");
-
-%% test/octave.test/index-wfi-f/s-12.m
-%!test
-%! a = 1;
-%! fail("a(-1,:);");
-
-%% test/octave.test/index-wfi-f/s-13.m
-%!test
-%! a = 1;
-%! fail("a(:,-1);");
-
-%% test/octave.test/index-wfi-f/s-14.m
-%!test
-%! a = 1;
-%! fail("a([1,2,3]);");
-
-%% test/octave.test/index-wfi-f/s-15.m
-%!test
-%! a = 1;
-%! fail("a([1;2;3]);");
+%!assert (a(1), 1)
+%!assert (a(:), 1)
+%!assert (a(:,:), 1)
+%!assert (a(1,:), 1)
+%!assert (a(:,1),1)
+%!assert (isempty (a(logical (0))))
+%!error a(-1)
+%!error a(2)
+%!error a(2,:)
+%!error a(:,2)
+%!error a(-1,:)
+%!error a(:,-1)
+%!error a([1,2,3])
+%!error a([1;2;3])
+%!error a([1,2;3,4])
+%!error a([0,1])
+%!error a([0;1])
+%!error a([-1,0])
+%!error a([-1;0])
 
-%% test/octave.test/index-wfi-f/s-16.m
-%!test
-%! a = 1;
-%! fail("a([1,2;3,4]);");
-
-%% test/octave.test/index-wfi-f/s-17.m
-%!test
-%! a = 1;
-%! fail("a([0,1]);");
-
-%% test/octave.test/index-wfi-f/s-18.m
-%!test
-%! a = 1;
-%! fail("a([0;1]);");
-
-%% test/octave.test/index-wfi-f/s-19.m
-%!test
-%! a = 1;
-%! fail("a([-1,0]);");
-
-%% test/octave.test/index-wfi-f/s-20.m
-%!test
-%! a = 1;
-%! fail("a([-1;0]);");
-
-%% test/octave.test/index-wfi-f/v-1.m
-%!test
+%!shared a, a_prime, mid_a
 %! a = [4,3,2,1];
 %! a_prime = [4;3;2;1];
 %! mid_a = [3,2];
-%! assert(a(1),4);
-
-%% test/octave.test/index-wfi-f/v-2.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(2),3);
-
-%% test/octave.test/index-wfi-f/v-3.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:) == a_prime));
-
-%% test/octave.test/index-wfi-f/v-4.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(1,:) == a));
-
-%% test/octave.test/index-wfi-f/v-5.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(a(:,3),2);
-
-%% test/octave.test/index-wfi-f/v-6.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(:,:) == a));
-
-%% test/octave.test/index-wfi-f/v-7.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(all (a(logical ([0,1,1,0])) == mid_a));
-
-%% test/octave.test/index-wfi-f/v-8.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0);");
 
-%% test/octave.test/index-wfi-f/v-9.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(5);");
-
-%% test/octave.test/index-wfi-f/v-10.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(0,1);");
-
-%% test/octave.test/index-wfi-f/v-11.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(logical (0),:)));
+%!assert (a(1),4)
+%!assert (a(2),3)
+%!assert (all (a(:) == a_prime))
+%!assert (all (a(1,:) == a))
+%!assert (a(:,3),2)
+%!assert (all (a(:,:) == a))
+%!assert (all (a(logical ([0,1,1,0])) == mid_a))
+%!error a(0)
+%!error a(5)
+%!error a(0,1)
+%!assert (isempty (a(logical (0),:)))
+%!error a(:,0)
+%!assert (isempty (a([])))
+%!assert (isempty (a([],:)))
+%!assert (isempty (a(:,[])))
 
-%% test/octave.test/index-wfi-f/v-12.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! fail("a(:,0);");
-
-%% test/octave.test/index-wfi-f/v-13.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([])));
-
-%% test/octave.test/index-wfi-f/v-14.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a([],:)));
-
-%% test/octave.test/index-wfi-f/v-15.m
-%!test
-%! a = [4,3,2,1];
-%! a_prime = [4;3;2;1];
-%! mid_a = [3,2];
-%! assert(isempty (a(:,[])));
-
-%% test/octave.test/index-wfi-f/m-1.m
-%!test
+%!shared a, a_fvec, a_col_1, a_col_2, a_row_1, a_row_2
 %! a = [1,2;3,4];
 %! a_fvec = [1;3;2;4];
 %! a_col_1 = [1;3];
 %! a_col_2 = [2;4];
 %! a_row_1 = [1,2];
 %! a_row_2 = [3,4];
-%! assert(all (all (a(:,:) == a)));
 
-%% test/octave.test/index-wfi-f/m-2.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(all (a(:) == a_fvec));
-
-%% test/octave.test/index-wfi-f/m-3.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! fail("a(0);");
-
-%% test/octave.test/index-wfi-f/m-4.m
-%!test
-%! a = [1,2;3,4];
-%! a_fvec = [1;3;2;4];
-%! a_col_1 = [1;3];
-%! a_col_2 = [2;4];
-%! a_row_1 = [1,2];
-%! a_row_2 = [3,4];
-%! assert(a(2),3);
+%!assert (all (all (a(:,:) == a)))
+%!assert (all (a(:) == a_fvec))
+%!error a(0)
+%!assert (a(2), 3)
 
 %% Additional tests
+
 %!shared a, b
 %! a = [1,2;3,4];
 %! b = a;
 %! b(:,:,2) = [5,6;7,8];
 
-%!assert (a(:), [1;3;2;4]);
-%!assert (a(1:2), [1,3]);
-%!assert (a(:,:), [1,2;3,4]);
-%!assert (a(:,1), [1;3]);
-%!assert (a(1,1), 1);
-%!assert (a(1:2,1), [1;3]);
-%!assert (a(:,:,1), [1,2;3,4]);
+%!assert (a(:), [1;3;2;4])
+%!assert (a(1:2), [1,3])
+%!assert (a(:,:), [1,2;3,4])
+%!assert (a(:,1), [1;3])
+%!assert (a(1,1), 1)
+%!assert (a(1:2,1), [1;3])
+%!assert (a(:,:,1), [1,2;3,4])
 
 %!test
 %! c(:,:,1) = [1,2;3,4];
 %! c(:,:,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1]),c)
+%! assert (a(:,:,[1,1]), c)
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
-%! assert (a(:,:,1,[1,1]),c)
+%! assert (a(:,:,1,[1,1]), c)
 
 %!test
 %! c(:,:,1,1) = [1,2;3,4];
 %! c(:,:,2,1) = [1,2;3,4];
 %! c(:,:,1,2) = [1,2;3,4];
 %! c(:,:,2,2) = [1,2;3,4];
-%! assert (a(:,:,[1,1],[1,1]),c)
+%! assert (a(:,:,[1,1],[1,1]), c)
 
-%!assert (a(1,[]), zeros(1,0));
-%!assert (a(1,[],[1,1]), zeros(1,0,2));
-%!assert (a(1,1,[]), zeros(1,1,0));
+%!assert (a(1,[]), zeros (1,0))
+%!assert (a(1,[],[1,1]), zeros (1,0,2))
+%!assert (a(1,1,[]), zeros (1,1,0))
 
 %!test
 %! c (1:10,1) = 1:10;
 %! assert (c, [1:10]');
 
-%!assert (b(:), [1; 3; 2; 4; 5; 7; 6; 8]);
-%!assert (b(:,:), [1, 2, 5, 6; 3, 4, 7, 8]);
-%!assert (b(:,1), [1;3]);
-%!assert (b(:,:,:), reshape ([1,3,2,4,5,7,6,8],[2,2,2]));
-%!assert (b(:,1,1), [1;3]);
-%!assert (b(:,1,1,[1,1]),reshape([1,3,1,3],[2,1,1,2]));
-%!assert (b(1,3), 5);
-%!assert (b(1,[3,4]), [5,6]);
-%!assert (b(1,1:4), [1,2,5,6]);
-%!assert (b(1,[],:), zeros (1,0,2));
-%!assert (b(1,[]), zeros(1,0));
+%!assert (b(:), [1; 3; 2; 4; 5; 7; 6; 8])
+%!assert (b(:,:), [1, 2, 5, 6; 3, 4, 7, 8])
+%!assert (b(:,1), [1;3])
+%!assert (b(:,:,:), reshape ([1,3,2,4,5,7,6,8],[2,2,2]))
+%!assert (b(:,1,1), [1;3])
+%!assert (b(:,1,1,[1,1]),reshape ([1,3,1,3],[2,1,1,2]))
+%!assert (b(1,3), 5)
+%!assert (b(1,[3,4]), [5,6])
+%!assert (b(1,1:4), [1,2,5,6])
+%!assert (b(1,[],:), zeros (1,0,2))
+%!assert (b(1,[]), zeros(1,0))
 %!assert (b(:,3), [5;7])
 %!assert (b([1,2],3), [5;7])
 %!assert (b(true(2,1),3), [5;7])
 %!assert (b(false(2,1),3), zeros(0,1))
-%!assert (b([],3), zeros(0,1));
+%!assert (b([],3), zeros(0,1))
 
 %!shared x
 %! # Dummy shared block to clear any previous definitions
 %! x = 1;
 
 %!test
 %! a(1,:) = [1,3];
 %! assert (a, [1,3]);
@@ -351,40 +167,46 @@
 %! a(:,:,1) = 1:4;;
 %! assert (a, [1:4]);
 
 %!test
 %! a(:,:,1) = [1:4]';
 %! assert (a, [1:4]');
 
 %!test
-%! a(:,:,1) = reshape(1:4,[1,1,4]);
+%! a(:,:,1) = reshape (1:4,[1,1,4]);
 %! assert (a, [1:4]');
 
 %!test
 %! a(:,1,:) = 1:4;
 %! assert (a, reshape (1:4,[1,1,4]));
 
 %!test
 %! a(:,1,:) = [1:4]';
 %! assert (a, [1:4]');
 
 %!test
-%! a(:,1,:) = reshape(1:4,[1,1,4]);;
+%! a(:,1,:) = reshape (1:4,[1,1,4]);;
 %! assert (a, [1:4]');
 
 %!test
 %! a(1,:,:) = 1:4;
 %! assert (a, reshape (1:4,[1,1,4]));
 
 %!test
 %! a(1,:,:) = [1:4]';
 %! assert (a, [1:4]);
 
 %!test
-%! a(1,:,:) = reshape(1:4,[1,1,4]);
+%! a(1,:,:) = reshape (1:4,[1,1,4]);
 %! assert (a, [1:4]);
 
 %!test
-%! a(1,:,:,:) = reshape(1:4,[1,1,4]);
+%! a(1,:,:,:) = reshape (1:4,[1,1,4]);
 %! assert (a, reshape (1:4,[1,1,1,4]));
 
 %!error (a(1:2,1:2) = 1:4)
+
+%!shared x
+%! x = 1:5;
+%!error <attempted to use a complex scalar as an index> x(i)
+%!error <attempted to use a complex scalar as an index> x(j)
+%!error <attempted to use a complex scalar as an index> x(1+i)
diff --git a/test/test_io.m b/test/test_io.m
--- a/test/test_io.m
+++ b/test/test_io.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -38,45 +38,45 @@
 %!  persistent a2 = hilb(3);
 %!  ## complex scalar
 %!  persistent a3 = 1 + 1i;
 %!  ## complex matrix
 %!  persistent a4 = hilb(3) + 1i*hilb(3);
 %!  ## bool
 %!  persistent a5 = (1 == 1);
 %!  ## bool matrix
-%!  persistent a6 = ([ones(1,5), zeros(1,5)] == ones(1,10));
+%!  persistent a6 = ([ones(1,5), zeros(1,5)] == ones (1,10));
 %!  ## range
 %!  persistent a7 = 1:10;
 %!  ## structure
 %!  persistent a8 = struct ("a", a1, "b", a3);
 %!  ## cell array
 %!  persistent a9 = {a1, a3};
 %!  ## string
 %!  persistent a10 = ["test"; "strings"];
 %!  ## int8 array
-%!  persistent a11 = int8(floor(256*rand(2,2)));
+%!  persistent a11 = int8 (floor (256*rand (2,2)));
 %!  ## int16 array
-%!  persistent a12 = int16(floor(65536*rand(2,2)));
+%!  persistent a12 = int16 (floor (65536*rand (2,2)));
 %!  ## int32 array
-%!  persistent a13 = int32(floor(1e6*rand(2,2)));
+%!  persistent a13 = int32 (floor (1e6*rand (2,2)));
 %!  ## int64 array
-%!  persistent a14 = int64(floor(10*rand(2,2)));
+%!  persistent a14 = int64 (floor (10*rand (2,2)));
 %!  ## uint8 array
-%!  persistent a15 = uint8(floor(256*rand(2,2)));
+%!  persistent a15 = uint8 (floor (256*rand (2,2)));
 %!  ## uint16 array
-%!  persistent a16 = uint16(floor(65536*rand(2,2)));
+%!  persistent a16 = uint16 (floor (65536*rand (2,2)));
 %!  ## int32 array
-%!  persistent a17 = uint32(floor(1e6*rand(2,2)));
+%!  persistent a17 = uint32 (floor (1e6*rand (2,2)));
 %!  ## uint64 array
-%!  persistent a18 = uint64(floor(10*rand(2,2)));
+%!  persistent a18 = uint64 (floor (10*rand (2,2)));
 %!  ## sparse
-%!  persistent a19 = sprandn(100,100,0.01);
+%!  persistent a19 = sprandn (100,100,0.01);
 %!  ## complex sparse
-%!  persistent a20 = sprandn(100,100,0.01) + 1i * sprandn(100,100,0.01);
+%!  persistent a20 = sprandn (100,100,0.01) + 1i * sprandn (100,100,0.01);
 %!
 %!  ret = 0;
 %!
 %!  files = {"text.mat", "binary.mat", "mat5.mat", "mat7.mat"};
 %!  opts = {"-z -text", "-z -binary", "-z -mat", "-v7"};
 %!  tols = {2*eps, 0, 0, 0};
 %!
 %!  vars = "a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20";
@@ -172,85 +172,86 @@
 %!          || isglobal ("a16") || isglobal ("a17") || isglobal ("a18")
 %!          || isglobal ("a19") || isglobal ("a20"))
 %!        error ("failed: %s global test", file); 
 %!      endif
 %!    endfor
 %!  endif
 %!
 %!  ret = 1;
-%!
+%!endfunction
+
 %!test
 %! 
 %! [save_status, save_files] = testls (0);
 %! [load_status, load_files] = testls (1);
 %! 
 %! for f = [save_files, load_files]
 %!   unlink (f{1});
 %! endfor
 %! 
-%! assert(save_status && load_status);
-%!
+%! assert (save_status && load_status);
+
 %!test
 %! 
 %! STR.scalar_fld = 1;
 %! STR.matrix_fld = [1.1,2;3,4];
 %! STR.string_fld = "Octave";
 %! STR.struct_fld.x = 0;
 %! STR.struct_fld.y = 1;
 %! 
 %! save struct.dat -struct STR;
 %! STR = load ("struct.dat");
 %!
-%! assert(STR.scalar_fld == 1 && ...
-%!        STR.matrix_fld == [1.1,2;3,4] && ...
-%!        STR.string_fld == "Octave" && ...
-%!        STR.struct_fld.x == 0 && ...
-%!        STR.struct_fld.y == 1 );
+%! assert (STR.scalar_fld == 1 && ...
+%!         STR.matrix_fld == [1.1,2;3,4] && ...
+%!         STR.string_fld == "Octave" && ...
+%!         STR.struct_fld.x == 0 && ...
+%!         STR.struct_fld.y == 1 );
 %!
 %!
 %! save -binary struct.dat -struct STR matrix_fld str*_fld;
 %! STR = load ("struct.dat");
 %!
-%! assert(!isfield(STR,"scalar_fld") && ...
-%!        STR.matrix_fld == [1.1,2;3,4] && ...
-%!        STR.string_fld == "Octave" && ...
-%!        STR.struct_fld.x == 0 && ...
-%!        STR.struct_fld.y == 1);
+%! assert (!isfield(STR,"scalar_fld") && ...
+%!         STR.matrix_fld == [1.1,2;3,4] && ...
+%!         STR.string_fld == "Octave" && ...
+%!         STR.struct_fld.x == 0 && ...
+%!         STR.struct_fld.y == 1);
 %!
 %! delete struct.dat;
-%!
+
 %!test
-%! matrix1 = rand(100, 2);
+%! matrix1 = rand (100, 2);
 %! save -ascii matrix.ascii matrix1
 %! matrix2 = load ("matrix.ascii");
 %! assert (matrix1, matrix2, 1e-9)
 %!
 %! delete matrix.ascii;
 
-%% FIXME Disable this test as it writes to stdout and there is no easy
-%% way to recover output. Need to spawn new octave process and pipe stdout
-%% somewhere to treat this case
+%% FIXME: This test is disabled as it writes to stdout and there is no easy
+%% way to recover output.  Need to spawn new octave process and pipe stdout
+%% somewhere to treat this case.
 %% test/octave.test/io/puts-1.m
 %!#test
 %! puts ("foo\n");
 
 %% test/octave.test/io/puts-2.m
-%!assert(puts (1),-1);
+%!assert (puts (1),-1)
 
 %% test/octave.test/io/puts-3.m
-%!error <Invalid call to puts> puts ();
+%!error <Invalid call to puts> puts ()
 
 %% test/octave.test/io/puts-4.m
-%!error <Invalid call to puts> puts (1, 2);
+%!error <Invalid call to puts> puts (1, 2)
 
 %!assert (sscanf ('123456', '%10c'), '123456')
 %!assert (sscanf ('123456', '%10s'), '123456')
 
-%!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd');
+%!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd')
 
 %!test
 %! [val, count, msg, pos] = sscanf ("3I2", "%f");
 %! assert (val, 3);
 %! assert (count, 1);
 %! assert (msg, "");
 %! assert (pos, 2);
 
@@ -269,65 +270,65 @@
 %! assert (pos, 6);
 
 %% test/octave.test/io/sscanf-1.m
 %!test
 %! [a, b, c] = sscanf ("1.2 3 foo", "%f%d%s", "C");
 %! [v1, c1, m1] = sscanf ("1 2 3 4 5 6", "%d");
 %! [v2, c2, m2] = sscanf ("1 2 bar 3 4 5 6", "%d");
 %! 
-%! assert((a == 1.2 && b == 3 && c == "foo"
+%! assert ((a == 1.2 && b == 3 && c == "foo"
 %! && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
 %! && v2 == [1; 2] && c2 == 2 && ischar (m2)));
 
 %% test/octave.test/io/sscanf-2.m
-%!error <Invalid call to sscanf> sscanf ();
+%!error <Invalid call to sscanf> sscanf ()
 
 %% test/octave.test/io/sscanf-3.m
-%!error sscanf (1, 2);
+%!error sscanf (1, 2)
 
 %% test/octave.test/io/sscanf-4.m
-%!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1);
+%!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1)
 
 %% test/octave.test/io/sscanf-5.m
 %!test
-%! [x, n] = sscanf("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
-%! assert(rows (x) == n);
+%! [x, n] = sscanf ("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
+%! assert (rows (x) == n);
 
 %% Note use fprintf so output not sent to stdout
 %% test/octave.test/io/printf-1.m
 %!test
-%! nm = tmpnam();
+%! nm = tmpnam ();
 %! fid1 = fopen(nm,"w");
 %! x = fprintf (fid1, "%s: %d\n", "test", 1);
 %! fclose(fid1);
 %! fid2 = fopen(nm,"r");
 %! str = fscanf(fid2,"%s");
 %! fclose(fid2);
 %! unlink(nm);
-%! assert(x,8);
-%! assert(str,"test:1");
+%! assert (x, 8);
+%! assert (str, "test:1");
 
 %% test/octave.test/io/printf-2.m
-%!error printf (1);
+%!error printf (1)
 
 %% test/octave.test/io/printf-3.m
-%!error <Invalid call to printf> printf ();
+%!error <Invalid call to printf> printf ()
 
 %% test/octave.test/io/sprintf-1.m
 %!test
 %! [s, msg, status] = sprintf ("%s: %d\n", "test", 1);
 %! 
-%! assert(s == "test: 1\n" && ischar (msg) && status == 8);
+%! assert (s == "test: 1\n" && ischar (msg) && status == 8);
 
 %% test/octave.test/io/sprintf-2.m
-%!error sprintf (1);
+%!error sprintf (1)
 
 %% test/octave.test/io/sprintf-3.m
-%!error <Invalid call to sprintf> sprintf ();
+%!error <Invalid call to sprintf> sprintf ()
 
 %% test/octave.test/io/fopen-1.m
 %!test
 %! arch_list = ["native"; "ieee-le"; "ieee-be"; "vaxd"; "vaxg"; "cray"];
 %! 
 %! status = 1;
 %! 
 %! for i = 1:6
@@ -373,97 +374,88 @@
 %!       break;
 %!     endif
 %!   endfor
 %!   if (status == 0)
 %!     break;
 %!   endif
 %! endfor
 %! 
-%! assert(status == 1);
+%! assert (status == 1);
 
 %% test/octave.test/io/fopen-2.m
 %!test
 %! s.a = 1;
-%! fail("fopen (s)");
+%! fail ("fopen (s)");
 
 %% test/octave.test/io/fopen-3.m
-%!error fopen ("foo", "x");
+%!error fopen ("foo", "x")
 
 %% test/octave.test/io/fopen-4.m
 %! fopen ("foo", "wb", "noodle");
-%! assert(prog_output_assert("error:.*"));
+%! assert (prog_output_assert ("error:"));
 
 %% test/octave.test/io/fopen-5.m
-%!error <Invalid call to fopen> fopen ();
+%!error <Invalid call to fopen> fopen ()
 
 %% test/octave.test/io/fopen-6.m
-%!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1);
+%!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1)
 
 %% test/octave.test/io/fclose-1.m
-%!error fclose (0);
+%!error fclose (0)
 
 %% test/octave.test/io/fclose-2.m
-%!error <Invalid call to fclose> fclose (1, 2);
+%!error <Invalid call to fclose> fclose (1, 2)
 
 %% test/octave.test/io/tmpnam-1.m
-%!assert(ischar (tmpnam ()));
+%!assert (ischar (tmpnam ()))
 
 %% test/octave.test/io/tmpnam-2.m
 %!warning tmpnam (1);
 
 %% test/octave.test/io/tmpnam-3.m
 %!warning tmpnam ("foo", 1);
 
 %% test/octave.test/io/tmpnam-4.m
-%!error <Invalid call to tmpnam> tmpnam (1, 2, 3);
+%!error <Invalid call to tmpnam> tmpnam (1, 2, 3)
 
 %% test/octave.test/io/binary-io-1.m
 %!test
 %! type_list = ["char"; "char*1"; "integer*1"; "int8";
 %! "schar"; "signed char"; "uchar"; "unsigned char";
 %! "short"; "ushort"; "unsigned short"; "int";
 %! "uint"; "unsigned int"; "long"; "ulong"; "unsigned long";
 %! "float"; "float32"; "real*4"; "double"; "float64";
 %! "real*8"; "int16"; "integer*2"; "int32"; "integer*4"];
 %! 
 %! n = rows (type_list);
-%! 
 %! nm = tmpnam ();
-%! 
 %! id = fopen (nm, "wb");
-%! 
 %! if (id > 0)
-%! 
-%! for i = 1:n
-%! fwrite (id, i, deblank (type_list(i,:)));
-%! endfor
-%! 
-%! fclose (id);
-%! 
-%! id = fopen (nm, "rb");
-%! 
-%! if (id > 0)
-%! 
-%! x = zeros (1, n);
-%! 
-%! for i = 1:n
-%! x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
-%! endfor
-%! 
-%! if (x == 1:n)
-%! printf_assert ("ok\n");
-%! endif
-%! 
-%! endif
-%! 
+%!   for i = 1:n
+%!     fwrite (id, i, deblank (type_list(i,:)));
+%!   endfor
+%!
+%!   fclose (id);
+%!   
+%!   id = fopen (nm, "rb");
+%!   if (id > 0)
+%!     x = zeros (1, n);
+%!     for i = 1:n
+%!       x(i) = fread (id, [1, 1], deblank (type_list(i,:)));
+%!     endfor
+%!     
+%!     if (x == 1:n)
+%!       printf_assert ("ok\n");
+%!     endif
+%!   endif
 %! endif
 %! 
 %! unlink (nm);
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/io/file-pos-1.m
 %!test
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! if (id > 0)
 %!   fprintf (id, "%d\n", 1:100);
 %!   fclose (id);
@@ -485,136 +477,132 @@
 %!       fseek (id, pos_one, SEEK_SET);
 %!       s_one_x = fgets (id);
 %!       fseek (id, pos_fifty, SEEK_SET);
 %!       s_fifty_x = fgets (id);
 %!       if (s_one == s_one_x && s_fifty == s_fifty_x)
 %!         frewind (id);
 %!         s_one_x = fgets (id);
 %!         if (s_one != s_one_x)
-%!           error("bombed!!");
+%!           error ("bombed!!");
 %!         endif
 %!       endif
 %!     endif
 %!   endif
 %! endif
 %! unlink (nm);
 
 %% test/octave.test/io/fputs-1.m
-%!error <Invalid call to fputs> fputs ();
+%!error <Invalid call to fputs> fputs ()
 
 %% test/octave.test/io/fputs-2.m
-%!error <Invalid call to fputs> fputs (1, "foo", 1);
+%!error <Invalid call to fputs> fputs (1, "foo", 1)
 
 %% test/octave.test/io/fputs-3.m
-%!assert(fputs (1, 1),-1);
+%!assert (fputs (1, 1),-1)
 
 %% test/octave.test/io/fgetl-1.m
-%!error <Invalid call to fgetl> fgetl ();
+%!error <Invalid call to fgetl> fgetl ()
 
 %% test/octave.test/io/fgetl-2.m
-%!error <Invalid call to fgetl> fgetl (1, 2, 3);
+%!error <Invalid call to fgetl> fgetl (1, 2, 3)
 
 %% test/octave.test/io/fgetl-3.m
-%!error fgetl ("foo", 1);
+%!error fgetl ("foo", 1)
 
 %% test/octave.test/io/fgets-1.m
-%!error <Invalid call to fgets> fgets ();
+%!error <Invalid call to fgets> fgets ()
 
 %% test/octave.test/io/fgets-2.m
-%!error <Invalid call to fgets> fgets (1, 2, 3);
+%!error <Invalid call to fgets> fgets (1, 2, 3)
 
 %% test/octave.test/io/fgets-3.m
-%!error fgets ("foo", 1);
+%!error fgets ("foo", 1)
 
 %% test/octave.test/io/fprintf-1.m
-%!error <Invalid call to fprintf> fprintf ();
+%!error <Invalid call to fprintf> fprintf ()
 
 %% test/octave.test/io/fprintf-2.m
-%!error <Invalid call to fprintf> fprintf (1);
+%!error <Invalid call to fprintf> fprintf (1)
 
 %% test/octave.test/io/fprintf-3.m
 %!test
 %! s.a = 1;
-%! fail("fprintf (s)","Invalid call to fprintf.*");
+%! fail ("fprintf (s)", "Invalid call to fprintf");
 
 %% test/octave.test/io/fprintf-4.m
-%!error fprintf (1, 1);
+%!error fprintf (1, 1)
 
 %% test/octave.test/io/fprintf-5.m
-%!error fprintf (-1, "foo");
+%!error fprintf (-1, "foo")
 
 %% test/octave.test/io/fscanf-1.m
-%!error <Invalid call to fscanf> fscanf ();
+%!error <Invalid call to fscanf> fscanf ()
 
 %% test/octave.test/io/fscanf-2.m
-%!error <Invalid call to fscanf> fscanf (1);
+%!error <Invalid call to fscanf> fscanf (1)
 
 %% test/octave.test/io/fscanf-3.m
-%!error fscanf ("foo", "bar");
+%!error fscanf ("foo", "bar")
 
 %% test/octave.test/io/fread-1.m
-%!error <Invalid call to fread> fread ();
+%!error <Invalid call to fread> fread ()
 
 %% test/octave.test/io/fread-2.m
-%!error <Invalid call to fread> fread (1, 2, "char", 1, "native", 2);
+%!error <Invalid call to fread> fread (1, 2, "char", 1, "native", 2)
 
 %% test/octave.test/io/fread-3.m
-%!error fread ("foo");
+%!error fread ("foo")
 
 %% test/octave.test/io/fwrite-1.m
-%!error <Invalid call to fwrite> fwrite ();
+%!error <Invalid call to fwrite> fwrite ()
 
 %% test/octave.test/io/fwrite-2.m
-%!error <Invalid call to fwrite> fwrite (1, rand (10), "char", 1, "native", 2);
+%!error <Invalid call to fwrite> fwrite (1, rand (10), "char", 1, "native", 2)
 
 %% test/octave.test/io/fwrite-3.m
-%!error fwrite ("foo", 1);
+%!error fwrite ("foo", 1)
 
 %% test/octave.test/io/feof-1.m
-%!error <Invalid call to feof> feof ();
+%!error <Invalid call to feof> feof ()
 
 %% test/octave.test/io/feof-2.m
-%!error <Invalid call to feof> feof (1, 2);
+%!error <Invalid call to feof> feof (1, 2)
 
 %% test/octave.test/io/feof-3.m
-%!error feof ("foo");
+%!error feof ("foo")
 
-%% FIXME trimerr in test.m finds and strips ".*ferror:"!!
-%% So use fail for the next two tests instead.
 %% test/octave.test/io/ferror-1.m
-%!test
-%! fail("ferror ();","Invalid call to ferror.*");
+%!error <Invalid call to ferror> ferror ()
 
 %% test/octave.test/io/ferror-2.m
-%!test
-%! fail("ferror (1, \"clear\", 2);","Invalid call to ferror.*"); 
+%!error <Invalid call to ferror> ferror (1, 'clear', 2)
 
 %% test/octave.test/io/ferror-3.m
-%!error ferror ("foo");
+%!error ferror ("foo")
 
 %% test/octave.test/io/ftell-1.m
-%!error <Invalid call to ftell> ftell ();
+%!error <Invalid call to ftell> ftell ()
 
 %% test/octave.test/io/ftell-2.m
-%!error <Invalid call to ftell> ftell (1, 2);
+%!error <Invalid call to ftell> ftell (1, 2)
 
 %% test/octave.test/io/ftell-3.m
-%!error ftell ("foo");
+%!error ftell ("foo")
 
 %% test/octave.test/io/fseek-1.m
-%!error <Invalid call to fseek> fseek ();
+%!error <Invalid call to fseek> fseek ()
 
 %% test/octave.test/io/fseek-2.m
-%!error <Invalid call to fseek> fseek (1, 0, SEEK_SET, 1);
+%!error <Invalid call to fseek> fseek (1, 0, SEEK_SET, 1)
 
 %% test/octave.test/io/fseek-3.m
-%!error fseek ("foo", 0, SEEK_SET);
+%!error fseek ("foo", 0, SEEK_SET)
 
 %% test/octave.test/io/frewind-1.m
-%!error <Invalid call to frewind> frewind ();
+%!error <Invalid call to frewind> frewind ()
 
 %% test/octave.test/io/frewind-2.m
-%!error <Invalid call to frewind> frewind (1, 2);
+%!error <Invalid call to frewind> frewind (1, 2)
 
 %% test/octave.test/io/frewind-3.m
-%!error frewind ("foo");
+%!error frewind ("foo")
 
diff --git a/test/test_contin.m b/test/test_line_continue.m
rename from test/test_contin.m
rename to test/test_line_continue.m
--- a/test/test_contin.m
+++ b/test/test_line_continue.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,153 +11,70 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/contin/contin-1.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-2.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-3.m
-%!test
+%!shared x, a, b
 %! x = [1,2];
 %! a = 1;
 %! b = 2;
+
+%!test
 %! y = [a... # comments here ok
 %! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-4.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments ok here
-%! b];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-5.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-6.m
-%!test
-%! x = [1,2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-7.m
 %!test
 %! x = [1;2];
-%! a = 1;
-%! b = 2;
 %! y = [a... # comments here ok
 %! ;\
 %! 
 %! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-8.m
-%!test
-%! x = [1;2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! ;\
-%! 
-%! b];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-9.m
-%!test
-%! x = [1;2];
-%! a = 1;
-%! b = 2;
-%! y = [a... # comments here ok
-%! ;\
-%! 
-%! b];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-10.m
-%!assert(1 + ...
+%!assert (1 + ...
 %! 2 - \# comments here ok
 %! 3 / ... # comments here ok
 %! -1,6);
 
-%% test/octave.test/contin/contin-11.m
 %!function y = f (a,...
 %!                b,  ...
 %!                c,  ...   % comments ok
 %!                x,  # continuation characters not required in parens
 %!                y,  \# but they should work too.
 %!                z)
 %!
 %!  y = 1;
-%!test
-%! assert(f (),1);
+%!endfunction
+%!
+%!assert (f (), 1)
 
-%% test/octave.test/contin/contin-12.m
 %!test
-%!assert(1 == 1
+%!assert (1 == 1
 %! && 2 == 2
 %! || 3 == 5);
 
-%% test/octave.test/contin/contin-13.m
 %!test
 %! x = [1, ...
 %! 
 %! ...
 %! 
 %! 2];
 %! y = [1;2];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-14.m
 %!test
-%! x = [1, ...
-%! 
-%! ...
-%! 
-%! 2];
-%! y = [1;2];
-%! assert(all (y == x));
-
-%% test/octave.test/contin/contin-15.m
-%!test
-%! x = [1,...
+%! x = [1 ,...
 %! 2];
 %! y = [1,2];
-%! assert(all (y == x));
+%! assert (y, x);
 
-%% test/octave.test/contin/contin-16.m
+%% test/oc tave.test/contin/contin-16.m
 %!test
 %! x = [ 1 , ...
 %! 2];
 %! y = [1,2];
-%! assert(all (y == x));
+%! assert  (y, x);
 
diff --git a/test/test_logical-wfi-t.m b/test/test_logical-wfi-t.m
deleted file mode 100644
--- a/test/test_logical-wfi-t.m
+++ /dev/null
@@ -1,239 +0,0 @@
-## Copyright (C) 2006-2011 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-%% test/octave.test/logical-wfi-t/s-1.m
-%!test
-%! a = [];
-%! fail("a(0);");
-
-%% test/octave.test/logical-wfi-t/s-2.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-3.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-t/s-4.m
-%!test
-%!shared a
-%! a = 2;
-%!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-
-%% test/octave.test/logical-wfi-t/v-1.m
-%!test
-%! a = [9,8,7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
-
-%% test/octave.test/logical-wfi-t/v-2.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-
-%% test/octave.test/logical-wfi-t/v-3.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-
-%% test/octave.test/logical-wfi-t/v-4.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-1.m
-%!test
-%! a = [9,8;7,6];
-%! isempty (a(logical ([0,0,0,0])));
-
-%% test/octave.test/logical-wfi-t/m-2.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([1,1,1,1])) == [9,7,8,6]);
-
-%% test/octave.test/logical-wfi-t/m-3.m
-%!test
-%! a = [9,8;7,6];
-%! all (a(logical ([0,1,1,0])) == [7,8]);
-
-%% test/octave.test/logical-wfi-t/m-4.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-5.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-6.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-7.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-8.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-9.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-10.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-11.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-12.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-13.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-14.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-t/m-15.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-16.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-t/m-17.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-t/m-18.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-19.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),1) == 7);
-
-%% test/octave.test/logical-wfi-t/m-20.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-t/m-21.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-22.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-t/m-23.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-t/m-24.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-25.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-26.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-27.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical (0:1)) == 8);
-
-%% test/octave.test/logical-wfi-t/m-28.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical ([0,1])) == 8);
-
-%% test/octave.test/logical-wfi-t/m-29.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(1,logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-t/m-30.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-31.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-32.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-t/m-33.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-t/m-34.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-t/m-35.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),1) == [9;7]));
-
-%% test/octave.test/logical-wfi-t/m-36.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-
diff --git a/test/test_logical-wfi-f.m b/test/test_logical_index.m
rename from test/test_logical-wfi-f.m
rename to test/test_logical_index.m
--- a/test/test_logical-wfi-f.m
+++ b/test/test_logical_index.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,229 +11,63 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/logical-wfi-f/s-1.m
 %!test
 %! a = [];
-%! fail("a(0);");
-
-%% test/octave.test/logical-wfi-f/s-2.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-f/s-3.m
-%!test
-%! a = 2;
-%! assert(a(1) == 2);
-
-%% test/octave.test/logical-wfi-f/s-4.m
-%!test
-%!shared a
-%!  a = 2;
-%!error id=Octave:index-out-of-bounds a(logical ([1,1]));
-
-%% test/octave.test/logical-wfi-f/v-1.m
-%!test
-%! a = [9,8,7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
+%! fail ("a(0);");
 
-%% test/octave.test/logical-wfi-f/v-2.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,8,7,6]));
-
-%% test/octave.test/logical-wfi-f/v-3.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [8,7]));
-
-%% test/octave.test/logical-wfi-f/v-4.m
-%!test
-%! a = [9,8,7,6];
-%! assert(all (a(logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-f/m-1.m
-%!test
-%! a = [9,8;7,6];
-%! assert(isempty (a(logical ([0,0,0,0]))));
-
-%% test/octave.test/logical-wfi-f/m-2.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1,1,1])) == [9,7,8,6]));
-
-%% test/octave.test/logical-wfi-f/m-3.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1,1,0])) == [7,8]));
+%!shared a
+%! a = 2;
+%!assert (a(1), 2);
+%!error id=Octave:index-out-of-bounds a(logical ([1,1]))
 
-%% test/octave.test/logical-wfi-f/m-4.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical (0:1)) == 6);
-
-%% test/octave.test/logical-wfi-f/m-5.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-6.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-f/m-7.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-8.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-9.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical (0:1),1) == 7);
-
-%% test/octave.test/logical-wfi-f/m-10.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical (0:1),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-11.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-12.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(2:-1:1,logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-13.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(2:-1:1,logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-f/m-14.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical (0:1)) == 6);
+%!shared a
+%! a = [9,8,7,6];
+%!assert (isempty (a(logical ([0,0,0,0]))))
+%!assert (a(logical ([1,1,1,1])), [9,8,7,6])
+%!assert (a(logical ([0,1,1,0])), [8,7])
+%!assert (a(logical ([1,1])), [9,8])
 
-%% test/octave.test/logical-wfi-f/m-15.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),2:-1:1) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-16.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),logical ([0,1])) == 6);
-
-%% test/octave.test/logical-wfi-f/m-17.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),[2,1]) == [6,7]));
-
-%% test/octave.test/logical-wfi-f/m-18.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),:) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-19.m
-%!test
+%!shared a
 %! a = [9,8;7,6];
-%! assert(a(logical ([0,1]),1) == 7);
-
-%% test/octave.test/logical-wfi-f/m-20.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([0,1]),logical ([1,1])) == [7,6]));
-
-%% test/octave.test/logical-wfi-f/m-21.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical (0:1)) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-22.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a([2,1],logical ([0,1])) == [6;8]));
-
-%% test/octave.test/logical-wfi-f/m-23.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a([2,1],logical ([1,1])) == [7,6;9,8])));
-
-%% test/octave.test/logical-wfi-f/m-24.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-25.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(:,logical ([0,1])) == [8;6]));
+%!assert (isempty (a(logical ([0,0,0,0]))))
+%!assert (a(logical ([1,1,1,1])), [9,7,8,6])
+%!assert (a(logical ([0,1,1,0])), [7,8])
+%!assert (a(logical (0:1),logical (0:1)), 6)
+%!assert (a(logical (0:1),2:-1:1), [6,7])
+%!assert (a(logical (0:1),logical ([0,1])), 6)
+%!assert (a(logical (0:1),[2,1]), [6,7])
+%!assert (a(logical (0:1),:), [7,6])
+%!assert (a(logical (0:1),1), 7)
+%!assert (a(logical (0:1),logical ([1,1])), [7,6])
+%!assert (a(2:-1:1,logical (0:1)), [6;8])
+%!assert (a(2:-1:1,logical ([0,1])), [6;8])
+%!assert (a(2:-1:1,logical ([1,1])), [7,6;9,8])
+%!assert (a(logical ([0,1]),logical (0:1)), 6)
+%!assert (a(logical ([0,1]),2:-1:1), [6,7])
+%!assert (a(logical ([0,1]),logical ([0,1])), 6)
+%!assert (a(logical ([0,1]),[2,1]), [6,7])
+%!assert (a(logical ([0,1]),:), [7,6])
+%!assert (a(logical ([0,1]),1), 7)
+%!assert (a(logical ([0,1]),logical ([1,1])), [7,6])
+%!assert (a([2,1],logical (0:1)), [6;8])
+%!assert (a([2,1],logical ([0,1])), [6;8])
+%!assert (a([2,1],logical ([1,1])), [7,6;9,8])
+%!assert (a(:,logical (0:1)), [8;6])
+%!assert (a(:,logical ([0,1])), [8;6])
+%!assert (a(:,logical ([1,1])), [9,8;7,6])
+%!assert (a(1,logical (0:1)), 8)
+%!assert (a(1,logical ([0,1])), 8)
+%!assert (a(1,logical ([1,1])), [9,8])
+%!assert (a(logical ([1,1]),logical (0:1)), [8;6])
+%!assert (a(logical ([1,1]),2:-1:1), [8,9;6,7])
+%!assert (a(logical ([1,1]),logical ([0,1])), [8;6])
+%!assert (a(logical ([1,1]),[2,1]), [8,9;6,7])
+%!assert (a(logical ([1,1]),:), [9,8;7,6])
+%!assert (a(logical ([1,1]),1), [9;7])
+%!assert (a(logical ([1,1]),logical ([1,1])), [9,8;7,6])
 
-%% test/octave.test/logical-wfi-f/m-26.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(:,logical ([1,1])) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-f/m-27.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical (0:1)) == 8);
-
-%% test/octave.test/logical-wfi-f/m-28.m
-%!test
-%! a = [9,8;7,6];
-%! assert(a(1,logical ([0,1])) == 8);
-
-%% test/octave.test/logical-wfi-f/m-29.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(1,logical ([1,1])) == [9,8]));
-
-%% test/octave.test/logical-wfi-f/m-30.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical (0:1)) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-31.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),2:-1:1) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-f/m-32.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),logical ([0,1])) == [8;6]));
-
-%% test/octave.test/logical-wfi-f/m-33.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),[2,1]) == [8,9;6,7])));
-
-%% test/octave.test/logical-wfi-f/m-34.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),:) == [9,8;7,6])));
-
-%% test/octave.test/logical-wfi-f/m-35.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (a(logical ([1,1]),1) == [9;7]));
-
-%% test/octave.test/logical-wfi-f/m-36.m
-%!test
-%! a = [9,8;7,6];
-%! assert(all (all (a(logical ([1,1]),logical ([1,1])) == [9,8;7,6])));
-
diff --git a/test/test_null_assign.m b/test/test_null_assign.m
--- a/test/test_null_assign.m
+++ b/test/test_null_assign.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2012 Jaroslav Hajek
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -28,36 +28,36 @@
 %! a = ones (3); a(1:3,:) = []; assert (size (a), [0, 3])
 %!test
 %! a = ones (3); a(:,1:3) = []; assert (size (a), [3, 0])
 %!test
 %! a = ones (3); fail ("a(1:2,1:2) = []", ".*");
 %!test
 %! a = ones (3); fail ("a(1:3,1:3) = []", ".*");
 
-% null strings should delete. [,] and [;] should delete.
+## null strings should delete. [,] and [;] should delete.
 %!test
 %! a = ones (3); a(1:2,:) = [,]; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = [;]; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = ''; assert (size (a), [1,3])
 %!test
 %! a = ones (3); a(1:2,:) = ""; assert (size (a), [1,3])
 
-% null matrix stored anywhere should lose its special status
+## null matrix stored anywhere should lose its special status
 %!test
 %! a = ones (3); b = []; fail ("a(:,1:3) = b", ".")
 %!test
 %! a = ones (3); b{1} = []; fail ("a(:,1:3) = b{1}", ".")
 %!test
 %! a = ones (3); b.x = []; fail ("a(:,1:3) = b.x", ".")
 
-% filtering a null matrix through a function should not delete
+## filtering a null matrix through a function should not delete
 %!test
 %! a = ones (3); fail ("a(:,1:3) = double ([])")
 
-% subsasgn should work the same way
+## subsasgn should work the same way
 %!test
 %! a = ones (3); a = subsasgn (a, substruct ('()', {':',1:2}), []); assert (size (a), [3,1])
 %!test
 %! a = ones (3); b = []; fail ("subsasgn (a, substruct ('()', {':',1:2}), b)", ".")
 
diff --git a/test/test_parser.m b/test/test_parser.m
--- a/test/test_parser.m
+++ b/test/test_parser.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2010-2011 John W. Eaton
+## Copyright (C) 2010-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,18 +11,18 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## Tests for parser problems belong in this file.  We need many more
-## tests here!
+## Tests for parser problems belong in this file.
+## We need many more tests here!
 
 %!assert ({1 2 {3 4}}, {1,2,{3,4}})
 %!assert ({1, 2 {3 4}}, {1,2,{3,4}})
 %!assert ({1 2, {3 4}}, {1,2,{3,4}})
 %!assert ({1 2 {3, 4}}, {1,2,{3,4}})
 %!assert ({1, 2, {3 4}}, {1,2,{3,4}})
 %!assert ({1 2,{3 4}}, {1,2,{3,4}})
 %!assert ({1 2,{3,4}}, {1,2,{3,4}})
@@ -242,15 +242,18 @@
 %!  assert (0 || 1 || ++a, true)
 %!  assert (a, 1)
 ## Level 1 (assignment)
 %!test
 %! a = 2; b = 5; c = 7;
 %! assert (a += b *= c += 1, 42)
 %! assert (b == 40 && c == 8)
 
+## Test creation of anonymous functions
+
 %!test
 %! af_in_cell = {@(x) [1 2]};
 %! assert (af_in_cell{1}(), [1, 2]);
 
 %!test
 %! R = @(rot) [cos(rot) -sin(rot); sin(rot) cos(rot)];
 %! assert (R(pi/2), [cos(pi/2), -sin(pi/2); sin(pi/2),cos(pi/2)]);
+
diff --git a/test/test_prefer.m b/test/test_prefer.m
--- a/test/test_prefer.m
+++ b/test/test_prefer.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,123 +14,102 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/prefer/prefer-1.m
 %!test
 %! m = [3 2];
-%! assert(all (m == (3:-1:2)));
+%! assert (all (m == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-2.m
 %!test
 %! m = [3,
 %! 2];
-%! assert(all (m == (3:-1:2)'));
+%! assert (all (m == (3:-1:2)'));
 
 %% test/octave.test/prefer/prefer-3.m
 %!test
 %! a = 2;
-%! assert([a - 1],1);
+%! assert ([a - 1], 1);
 
 %% test/octave.test/prefer/prefer-4.m
 %!test
 %! m = [3,2];
-%! fail("[m ']");
+%! fail ("[m ']");
 
 %% test/octave.test/prefer/prefer-5.m
-%!assert(all ([3 2] == (3:-1:2)));
+%!assert (all ([3 2] == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-6.m
-%!assert(all ([3, 2] == (3:-1:2)));
+%!assert (all ([3, 2] == (3:-1:2)));
 
 %% test/octave.test/prefer/prefer-7.m
 %!test
 %! m = [3,2];
-%! assert(all ([m (1)] == (3:-1:1)));
+%! assert (all ([m (1)] == (3:-1:1)));
 
 %% test/octave.test/prefer/prefer-8.m
 %!test
 %! m = [3,2];
-%! assert([m(1)],3);
-
-%% test/octave.test/prefer/prefer-9.m
-%!test
-%! m = [3,2];
-%! assert(all ([m (1)] == (3:-1:1)));
+%! assert ([m(1)],3);
 
 %% test/octave.test/prefer/prefer-10.m
 %!test
 %! a = 2;
-%! assert([a- 1],1);
+%! assert ([a- 1], 1);
 
 %% test/octave.test/prefer/prefer-11.m
 %!test
 %! a = 1;
-%! assert(all ([a -1] == (1:-2:-1)));
+%! assert (all ([a -1] == (1:-2:-1)));
 
 %% test/octave.test/prefer/prefer-12.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("off", "Octave:str-to-num");
-%! assert("d" + 0,100);
+%! assert ("d" + 0, 100);
 %! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-13.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("on", "Octave:str-to-num");
-%! fail("'d' + 0","warning");
+%! fail ("'d' + 0", "warning");
 %! warning (wsn.state, "Octave:str-to-num");
 
 %% test/octave.test/prefer/prefer-14.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("off", "Ocave:imag-to-real");
-%! assert(eye (1+i),1);
+%! assert (eye (1+i), 1);
 %! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-15.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("on", "Ocave:imag-to-real");
-%! fail("eye (1+i)","warning");
+%! fail ("eye (1+i)", "warning");
 %! warning (wir.state, "Ocave:imag-to-real");
 
 %% test/octave.test/prefer/prefer-17.m
 %!test
 %! wrre = warning ("query", "Octave:resize-on-range-error");
 %! warning ("off", "Octave:resize-on-range-error");
 %! clear a; 
 %! a(2) = 1; a(3) = 2; 
-%! assert(all (a == [0,1,2]));
+%! assert (all (a == [0,1,2]));
 %! warning (wrre.state, "Octave:resize-on-range-error");
 
 %% test/octave.test/prefer/prefer-18.m
 %!test
 %! clear a; 
 %! a(1) = 1; a(2) = 2;
-%! assert(all (a == [1,2]));
-
-%% FIXME How the hell do I test this one in test/assert 
-%% test/octave.test/prefer/prefer-19.m
-%!#test
-%! pid = print_answer_id_name ();
-%! print_answer_id_name (0);
-%! a = 1
-%! print_answer_id_name (pid);
-
-%% FIXME How the hell do I test this one in test/assert 
-%% test/octave.test/prefer/prefer-20.m
-%!#test
-%! pid = print_answer_id_name ();
-%! print_answer_id_name (1);
-%! a = 1
-%! print_answer_id_name (pid);
+%! assert (all (a == [1,2]));
 
 %% test/octave.test/prefer/prefer-21.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (0);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[]")));
@@ -142,105 +121,107 @@
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (1);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[](0x0)")));
 %! print_empty_dimensions (ped);
 
 %% test/octave.test/prefer/prefer-23.m
-%!assert(all (size (inv ([])) == [0, 0]));
+%!assert (all (size (inv ([])) == [0, 0]));
 
 %% test/octave.test/prefer/prefer-24.m
-%!assert(all (svd ([]) == zeros (0, 1)));
+%!assert (all (svd ([]) == zeros (0, 1)));
 
 %% test/octave.test/prefer/prefer-27.m
 %!test
 %! sp = save_precision ();
 %! save_precision (1);
 %! x = pi;
-%! nm = tmpnam();
-%! save("-text",nm,"x");
+%! nm = tmpnam ();
+%! save("-text", nm, "x");
 %! clear x;
-%! load(nm);
-%! unlink(nm);
-%! assert(x,3);
+%! load (nm);
+%! unlink (nm);
+%! assert (x,3);
 %! save_precision (sp);
 
 %% test/octave.test/prefer/prefer-28.m
 %!test
 %! sp = save_precision ();
 %! save_precision (5);
 %! x = pi;
-%! nm = tmpnam();
-%! save("-text",nm,"x");
+%! nm = tmpnam ();
+%! save("-text", nm, "x");
 %! clear x;
-%! load(nm);
-%! unlink(nm);
-%! assert(x,3.1416);
+%! load (nm);
+%! unlink (nm);
+%! assert (x, 3.1416);
 %! save_precision (sp);
 
-%% FIXME Same problem as above!!!
+%% FIXME: How to capture standard output for comparison? 
 %% test/octave.test/prefer/prefer-29.m
 %!function f ()
 %! 1
+%!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (0);
 %! f
-%! assert(??);
+%! assert (??);
 %! silent_functions (sf);
 
 %% FIXME Same problem as above!!!
 %% test/octave.test/prefer/prefer-30.m
 %!function f ()
 %! 1
+%!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (1);
 %! f
-%! assert(??);
+%! assert (??);
 %! silent_functions (sf);
 
 %% test/octave.test/prefer/prefer-32.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("on", "Octave:neg-dim-as-zero");
-%! fail("eye (-1) == []","warning");
+%! fail ("eye (-1) == []", "warning");
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-33.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("off", "Octave:neg-dim-as-zero");
-%! assert(all (size (eye (-1)) == [0, 0]));
+%! assert (all (size (eye (-1)) == [0, 0]));
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
 %% test/octave.test/prefer/prefer-34.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("off", "Octave:assign-as-truth-value");
 %! if (x = 1) 1; endif
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-35.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("on", "Octave:assign-as-truth-value");
-%! fail("if (x = 1) 1; endif","warning");
+%! fail ("if (x = 1) 1; endif", "warning");
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
 %% test/octave.test/prefer/prefer-38.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("off", "Octave:divide-by-zero");
-%! assert(isinf (1/0));
+%! assert (isinf (1/0));
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
 %% test/octave.test/prefer/prefer-39.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("on", "Octave:divide-by-zero");
 %! a = 1;
 %! b = 0;
-%! fail("isinf (a/b);","warning")
+%! fail ("isinf (a/b);", "warning")
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
diff --git a/test/test_range.m b/test/test_range.m
--- a/test/test_range.m
+++ b/test/test_range.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,62 +13,62 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Test values of range
 
-%!assert(full(1:9), [ 1 2 3 4 5 6 7 8 9 ])
-%!assert(full(1:0.4:3), [ 1.0 1.4 1.8 2.2 2.6 3.0 ])
-%!assert(full(9:1), zeros(1,0))
-%!assert(full(9:-1:1), [ 9 8 7 6 5 4 3 2 1 ])
-%!assert(full(1:-1:9), zeros(1,0))
-
+%!assert (full (1:9), [ 1 2 3 4 5 6 7 8 9 ])
+%!assert (full (1:0.4:3), [ 1.0 1.4 1.8 2.2 2.6 3.0 ])
+%!assert (full (9:1), zeros (1,0))
+%!assert (full (9:-1:1), [ 9 8 7 6 5 4 3 2 1 ])
+%!assert (full (1:-1:9), zeros (1,0))
+%!assert (full (1:1:1), 1)
+%!assert (full (i:2i:10i), zeros (1,0))
 
 ## Test mixing integer range with other types
 
 %!shared expect, r, z
 %! expect = [ 1 2 3 4 5 6 7 8 9
 %!            0 0 0 0 0 0 0 0 0 ];
-%! z = zeros(1,9);
+%! z = zeros (1,9);
 %! r = 1:9;
 
-%!assert([ r ; z                  ], expect)
-%!assert([ r ; single(z)          ], single (expect))
-%!assert([ r ; logical(z)         ], expect)
-%!assert([ r ; sparse(z)          ], sparse (expect))
-%!assert([ r ; sparse(logical(z)) ], sparse (expect))
+%!assert ([ r ; z                  ], expect)
+%!assert ([ r ; single(z)          ], single (expect))
+%!assert ([ r ; logical(z)         ], expect)
+%!assert ([ r ; sparse(z)          ], sparse (expect))
+%!assert ([ r ; sparse(logical(z)) ], sparse (expect))
 
-%!assert([ r ; int8(z)            ], int8(expect))
-%!assert([ r ; int16(z)           ], int16(expect))
-%!assert([ r ; int32(z)           ], int32(expect))
-%!assert([ r ; int64(z)           ], int64(expect))
-%!assert([ r ; uint8(z)           ], uint8(expect))
-%!assert([ r ; uint16(z)          ], uint16(expect))
-%!assert([ r ; uint32(z)          ], uint32(expect))
-%!assert([ r ; uint64(z)          ], uint64(expect))
+%!assert ([ r ; int8(z)            ], int8(expect))
+%!assert ([ r ; int16(z)           ], int16(expect))
+%!assert ([ r ; int32(z)           ], int32(expect))
+%!assert ([ r ; int64(z)           ], int64(expect))
+%!assert ([ r ; uint8(z)           ], uint8(expect))
+%!assert ([ r ; uint16(z)          ], uint16(expect))
+%!assert ([ r ; uint32(z)          ], uint32(expect))
+%!assert ([ r ; uint64(z)          ], uint64(expect))
 
-
-## Test mixing non integer range with other types
+## Test mixing non-integer range with other types
 
 %!shared expect, r, z
 %! expect = [ 1.0 1.4 1.8 2.2 2.6 3.0
 %!            0   0   0   0   0   0   ];
-%! z = zeros(1,6);
+%! z = zeros (1,6);
 %! r = 1:0.4:3;
 
-%!assert([ r ; z                  ], expect)
-%!assert([ r ; single(z)          ], single (expect))
-%!assert([ r ; logical(z)         ], expect)
-%!assert([ r ; sparse(z)          ], sparse (expect))
-%!assert([ r ; sparse(logical(z)) ], sparse (expect))
+%!assert ([ r ; z                  ], expect)
+%!assert ([ r ; single(z)          ], single (expect))
+%!assert ([ r ; logical(z)         ], expect)
+%!assert ([ r ; sparse(z)          ], sparse (expect))
+%!assert ([ r ; sparse(logical(z)) ], sparse (expect))
 
-%!assert([ r ; int8(z)            ], int8(expect))
-%!assert([ r ; int16(z)           ], int16(expect))
-%!assert([ r ; int32(z)           ], int32(expect))
-%!assert([ r ; int64(z)           ], int64(expect))
-%!assert([ r ; uint8(z)           ], uint8(expect))
-%!assert([ r ; uint16(z)          ], uint16(expect))
-%!assert([ r ; uint32(z)          ], uint32(expect))
-%!assert([ r ; uint64(z)          ], uint64(expect))
+%!assert ([ r ; int8(z)            ], int8(expect))
+%!assert ([ r ; int16(z)           ], int16(expect))
+%!assert ([ r ; int32(z)           ], int32(expect))
+%!assert ([ r ; int64(z)           ], int64(expect))
+%!assert ([ r ; uint8(z)           ], uint8(expect))
+%!assert ([ r ; uint16(z)          ], uint16(expect))
+%!assert ([ r ; uint32(z)          ], uint32(expect))
+%!assert ([ r ; uint64(z)          ], uint64(expect))
 
diff --git a/test/test_recursion.m b/test/test_recursion.m
--- a/test/test_recursion.m
+++ b/test/test_recursion.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,22 +19,25 @@
 %% test/octave.test/recursion/recursion-1.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = x * f (x-1);
 %!  endif
-%!test
-%! assert(f (5),120);
+%!endfunction
+%!
+%!assert(f (5), 120);
 
 %% test/octave.test/recursion/recursion-2.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = f (x-1) * x;
 %!  endif
-%!test
-%! assert(f (5),120);
+%!endfunction
+%!
+%!assert(f (5), 120);
 
+%%FIXME: Need test for maximum recursion depth
diff --git a/test/test_return.m b/test/test_return.m
--- a/test/test_return.m
+++ b/test/test_return.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,16 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/return/return-1.m
 %!function y = f ()
 %!  y = 1;
-%!  return
+%!  return;
 %!  y = 2;
-%!assert(f(),1)
+%!endfunction
+%!
+%!assert(f(), 1)
 
 %% test/octave.test/return/return-2.m
 %!test
 %! return;
 
diff --git a/test/test_slice.m b/test/test_slice.m
--- a/test/test_slice.m
+++ b/test/test_slice.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2007-2011 John W. Eaton
+## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,170 +11,170 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%!function x = set_slice(size, dim, slice)
-%!  x = ones(size);
+%!function x = set_slice (size, dim, slice)
+%!  x = ones (size);
 %!  switch dim
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    case 31
 %!      x(slice, :, :) = 2;
 %!    case 32
 %!      x(:, slice, :) = 2;
 %!    case 33
 %!      x(:, :, slice) = 2;
 %!    otherwise
 %!      error("invalid dim, '%d'", dim);
 %!  endswitch
-%! endfunction
+%!endfunction
 
 ## size = [2 0]
-%!assert(set_slice([2 0], 11, []), zeros([2 0]));
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 1)
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 2)
-%!error id=Octave:invalid-resize set_slice([2 0], 11, 3)
-%!assert(set_slice([2 0], 21, []), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 2), zeros([2 0]));
-%!assert(set_slice([2 0], 21, 3), zeros([3 0]));
-%!assert(set_slice([2 0], 22, []), zeros([2 0]));
-%!assert(set_slice([2 0], 22, 1), [2 2]');
-%!assert(set_slice([2 0], 22, 2), [0 0;2 2]');
-%!assert(set_slice([2 0], 22, 3), [0 0;0 0;2 2]');
-%!assert(set_slice([2 0], 31, []), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 2), zeros([2 0]));
-%!assert(set_slice([2 0], 31, 3), zeros([3 0]));
-%!assert(set_slice([2 0], 32, []), zeros([2 0]));
-%!assert(set_slice([2 0], 32, 1), [2 2]');
-%!assert(set_slice([2 0], 32, 2), [0 0;2 2]');
-%!assert(set_slice([2 0], 32, 3), [0 0;0 0;2 2]');
-%!assert(set_slice([2 0], 33, []), zeros([2 0]));
-%!assert(set_slice([2 0], 33, 1), zeros([2 0]));
-%!assert(set_slice([2 0], 33, 2), zeros([2 0 2]));
-%!assert(set_slice([2 0], 33, 3), zeros([2 0 3]));
+%!assert (set_slice ([2 0], 11, []), zeros ([2 0]))
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 1)
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 2)
+%!error id=Octave:invalid-resize set_slice ([2 0], 11, 3)
+%!assert (set_slice ([2 0], 21, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 2), zeros ([2 0]))
+%!assert (set_slice ([2 0], 21, 3), zeros ([3 0]))
+%!assert (set_slice ([2 0], 22, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 22, 1), [2 2]')
+%!assert (set_slice ([2 0], 22, 2), [0 0;2 2]')
+%!assert (set_slice ([2 0], 22, 3), [0 0;0 0;2 2]')
+%!assert (set_slice ([2 0], 31, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 2), zeros ([2 0]))
+%!assert (set_slice ([2 0], 31, 3), zeros ([3 0]))
+%!assert (set_slice ([2 0], 32, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 32, 1), [2 2]')
+%!assert (set_slice ([2 0], 32, 2), [0 0;2 2]')
+%!assert (set_slice ([2 0], 32, 3), [0 0;0 0;2 2]')
+%!assert (set_slice ([2 0], 33, []), zeros ([2 0]))
+%!assert (set_slice ([2 0], 33, 1), zeros ([2 0]))
+%!assert (set_slice ([2 0], 33, 2), zeros ([2 0 2]))
+%!assert (set_slice ([2 0], 33, 3), zeros ([2 0 3]))
 
 ## size = [0 2]
-%!assert(set_slice([0 2], 11, []), zeros([0 2]));
-%!assert(set_slice([0 2], 11, 1), 2);
-%!assert(set_slice([0 2], 11, 2), [0, 2]);
-%!assert(set_slice([0 2], 11, 3), [0, 0, 2]);
-%!assert(set_slice([0 2], 21, []), zeros([0 2]));
-%!assert(set_slice([0 2], 21, 1), [2 2]);
-%!assert(set_slice([0 2], 21, 2), [0 0;2 2]);
-%!assert(set_slice([0 2], 21, 3), [0 0;0 0;2 2]);
-%!assert(set_slice([0 2], 22, []), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 2), zeros([0 2]));
-%!assert(set_slice([0 2], 22, 3), zeros([0 3]));
-%!assert(set_slice([0 2], 31, []), zeros([0 2]));
-%!assert(set_slice([0 2], 31, 1), [2 2]);
-%!assert(set_slice([0 2], 31, 2), [0 0;2 2]);
-%!assert(set_slice([0 2], 31, 3), [0 0;0 0;2 2]);
-%!assert(set_slice([0 2], 32, []), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 2), zeros([0 2]));
-%!assert(set_slice([0 2], 32, 3), zeros([0 3]));
-%!assert(set_slice([0 2], 33, []), zeros([0 2]));
-%!assert(set_slice([0 2], 33, 1), zeros([0 2]));
-%!assert(set_slice([0 2], 33, 2), zeros([0 2 2]));
-%!assert(set_slice([0 2], 33, 3), zeros([0 2 3]));
+%!assert (set_slice ([0 2], 11, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 11, 1), 2)
+%!assert (set_slice ([0 2], 11, 2), [0, 2])
+%!assert (set_slice ([0 2], 11, 3), [0, 0, 2])
+%!assert (set_slice ([0 2], 21, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 21, 1), [2 2])
+%!assert (set_slice ([0 2], 21, 2), [0 0;2 2])
+%!assert (set_slice ([0 2], 21, 3), [0 0;0 0;2 2])
+%!assert (set_slice ([0 2], 22, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 2), zeros ([0 2]))
+%!assert (set_slice ([0 2], 22, 3), zeros ([0 3]))
+%!assert (set_slice ([0 2], 31, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 31, 1), [2 2])
+%!assert (set_slice ([0 2], 31, 2), [0 0;2 2])
+%!assert (set_slice ([0 2], 31, 3), [0 0;0 0;2 2])
+%!assert (set_slice ([0 2], 32, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 2), zeros ([0 2]))
+%!assert (set_slice ([0 2], 32, 3), zeros ([0 3]))
+%!assert (set_slice ([0 2], 33, []), zeros ([0 2]))
+%!assert (set_slice ([0 2], 33, 1), zeros ([0 2]))
+%!assert (set_slice ([0 2], 33, 2), zeros ([0 2 2]))
+%!assert (set_slice ([0 2], 33, 3), zeros ([0 2 3]))
 
 ## size = [2 1]
-%!assert(set_slice([2 1], 11, []), ones([2 1]));
-%!assert(set_slice([2 1], 11, 1), [2 1]');
-%!assert(set_slice([2 1], 11, 2), [1 2]');
-%!assert(set_slice([2 1], 11, 3), [1 1 2]');
-%!assert(set_slice([2 1], 11, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 21, []), ones([2 1]));
-%!assert(set_slice([2 1], 21, 1), [2 1]');
-%!assert(set_slice([2 1], 21, 2), [1 2]');
-%!assert(set_slice([2 1], 21, 3), [1 1 2]');
-%!assert(set_slice([2 1], 21, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 22, []), ones([2 1]));
-%!assert(set_slice([2 1], 22, 1), [2 2]');
-%!assert(set_slice([2 1], 22, 2), [1 1;2 2]');
-%!assert(set_slice([2 1], 22, 3), [1 1;0 0;2 2]');
-%!assert(set_slice([2 1], 31, []), ones([2 1]));
-%!assert(set_slice([2 1], 31, 1), [2 1]');
-%!assert(set_slice([2 1], 31, 2), [1 2]');
-%!assert(set_slice([2 1], 31, 3), [1 1 2]');
-%!assert(set_slice([2 1], 31, 4), [1 1 0 2]');
-%!assert(set_slice([2 1], 32, []), ones([2 1]));
-%!assert(set_slice([2 1], 32, 1), [2 2]');
-%!assert(set_slice([2 1], 32, 2), [1 1;2 2]');
-%!assert(set_slice([2 1], 32, 3), [1 1;0 0;2 2]');
-%!assert(set_slice([2 1], 33, []), ones([2 1]));
-%!assert(set_slice([2 1], 33, 1), [2 2]');
-%!assert(set_slice([2 1], 33, 2), reshape([1 1 2 2],[2 1 2]));
-%!assert(set_slice([2 1], 33, 3), reshape([1 1 0 0 2 2],[2 1 3]));
+%!assert (set_slice ([2 1], 11, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 11, 1), [2 1]')
+%!assert (set_slice ([2 1], 11, 2), [1 2]')
+%!assert (set_slice ([2 1], 11, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 11, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 21, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 21, 1), [2 1]')
+%!assert (set_slice ([2 1], 21, 2), [1 2]')
+%!assert (set_slice ([2 1], 21, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 21, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 22, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 22, 1), [2 2]')
+%!assert (set_slice ([2 1], 22, 2), [1 1;2 2]')
+%!assert (set_slice ([2 1], 22, 3), [1 1;0 0;2 2]')
+%!assert (set_slice ([2 1], 31, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 31, 1), [2 1]')
+%!assert (set_slice ([2 1], 31, 2), [1 2]')
+%!assert (set_slice ([2 1], 31, 3), [1 1 2]')
+%!assert (set_slice ([2 1], 31, 4), [1 1 0 2]')
+%!assert (set_slice ([2 1], 32, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 32, 1), [2 2]')
+%!assert (set_slice ([2 1], 32, 2), [1 1;2 2]')
+%!assert (set_slice ([2 1], 32, 3), [1 1;0 0;2 2]')
+%!assert (set_slice ([2 1], 33, []), ones ([2 1]))
+%!assert (set_slice ([2 1], 33, 1), [2 2]')
+%!assert (set_slice ([2 1], 33, 2), reshape ([1 1 2 2],[2 1 2]))
+%!assert (set_slice ([2 1], 33, 3), reshape ([1 1 0 0 2 2],[2 1 3]))
 
 ## size = [1 2]
-%!assert(set_slice([1 2], 11, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 11, 1), [2 1]);
-%!assert(set_slice([1 2], 11, 2), [1 2]);
-%!assert(set_slice([1 2], 11, 3), [1 1 2]);
-%!assert(set_slice([1 2], 11, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 21, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 21, 1), [2 2]);
-%!assert(set_slice([1 2], 21, 2), [1 1;2 2]);
-%!assert(set_slice([1 2], 21, 3), [1 1;0 0;2 2]);
-%!assert(set_slice([1 2], 22, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 22, 1), [2 1]);
-%!assert(set_slice([1 2], 22, 2), [1 2]);
-%!assert(set_slice([1 2], 22, 3), [1 1 2]);
-%!assert(set_slice([1 2], 22, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 31, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 31, 1), [2 2]);
-%!assert(set_slice([1 2], 31, 2), [1 1;2 2]);
-%!assert(set_slice([1 2], 31, 3), [1 1;0 0;2 2]);
-%!assert(set_slice([1 2], 32, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 32, 1), [2 1]);
-%!assert(set_slice([1 2], 32, 2), [1 2]);
-%!assert(set_slice([1 2], 32, 3), [1 1 2]);
-%!assert(set_slice([1 2], 32, 4), [1 1 0 2]);
-%!assert(set_slice([1 2], 33, []), full(ones([1 2])));
-%!assert(set_slice([1 2], 33, 1), [2 2]);
-%!assert(set_slice([1 2], 33, 2), reshape([1 1 2 2],[1 2 2]));
-%!assert(set_slice([1 2], 33, 3), reshape([1 1 0 0 2 2],[1 2 3]));
+%!assert (set_slice ([1 2], 11, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 11, 1), [2 1])
+%!assert (set_slice ([1 2], 11, 2), [1 2])
+%!assert (set_slice ([1 2], 11, 3), [1 1 2])
+%!assert (set_slice ([1 2], 11, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 21, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 21, 1), [2 2])
+%!assert (set_slice ([1 2], 21, 2), [1 1;2 2])
+%!assert (set_slice ([1 2], 21, 3), [1 1;0 0;2 2])
+%!assert (set_slice ([1 2], 22, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 22, 1), [2 1])
+%!assert (set_slice ([1 2], 22, 2), [1 2])
+%!assert (set_slice ([1 2], 22, 3), [1 1 2])
+%!assert (set_slice ([1 2], 22, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 31, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 31, 1), [2 2])
+%!assert (set_slice ([1 2], 31, 2), [1 1;2 2])
+%!assert (set_slice ([1 2], 31, 3), [1 1;0 0;2 2])
+%!assert (set_slice ([1 2], 32, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 32, 1), [2 1])
+%!assert (set_slice ([1 2], 32, 2), [1 2])
+%!assert (set_slice ([1 2], 32, 3), [1 1 2])
+%!assert (set_slice ([1 2], 32, 4), [1 1 0 2])
+%!assert (set_slice ([1 2], 33, []), full (ones ([1 2])))
+%!assert (set_slice ([1 2], 33, 1), [2 2])
+%!assert (set_slice ([1 2], 33, 2), reshape ([1 1 2 2],[1 2 2]))
+%!assert (set_slice ([1 2], 33, 3), reshape ([1 1 0 0 2 2],[1 2 3]))
 
 ## size = [2 2]
-%!assert(set_slice([2 2], 11, []), ones([2 2]));
-%!assert(set_slice([2 2], 11, 1), [2 1;1 1]);
-%!assert(set_slice([2 2], 11, 2), [1 1;2 1]);
-%!assert(set_slice([2 2], 11, 3), [1 2;1 1]);
-%!assert(set_slice([2 2], 11, 4), [1 1;1 2]);
-%!error id=Octave:invalid-resize set_slice([2 2], 11, 5)
-%!error id=Octave:invalid-resize set_slice([2 2], 11, 6)
-%!assert(set_slice([2 2], 21, []), ones([2 2]));
-%!assert(set_slice([2 2], 21, 1), [2 2;1 1]);
-%!assert(set_slice([2 2], 21, 2), [1 1;2 2]);
-%!assert(set_slice([2 2], 21, 3), [1 1;1 1;2 2]);
-%!assert(set_slice([2 2], 21, 4), [1 1;1 1;0 0;2 2]);
-%!assert(set_slice([2 2], 22, []), ones([2 2]));
-%!assert(set_slice([2 2], 22, 1), [2 2;1 1]');
-%!assert(set_slice([2 2], 22, 2), [1 1;2 2]');
-%!assert(set_slice([2 2], 22, 3), [1 1;1 1;2 2]');
-%!assert(set_slice([2 2], 22, 4), [1 1;1 1;0 0;2 2]');
-%!assert(set_slice([2 2], 31, []), ones([2 2]));
-%!assert(set_slice([2 2], 31, 1), [2 2;1 1]);
-%!assert(set_slice([2 2], 31, 2), [1 1;2 2]);
-%!assert(set_slice([2 2], 31, 3), [1 1;1 1;2 2]);
-%!assert(set_slice([2 2], 31, 4), [1 1;1 1;0 0;2 2]);
-%!assert(set_slice([2 2], 32, []), ones([2 2]));
-%!assert(set_slice([2 2], 32, 1), [2 2;1 1]');
-%!assert(set_slice([2 2], 32, 2), [1 1;2 2]');
-%!assert(set_slice([2 2], 32, 3), [1 1;1 1;2 2]');
-%!assert(set_slice([2 2], 32, 4), [1 1;1 1;0 0;2 2]');
-%!assert(set_slice([2 2], 33, []), ones([2 2]));
-%!assert(set_slice([2 2], 33, 1), [2 2;2 2]);
-%!assert(set_slice([2 2], 33, 2), reshape([1 1 1 1 2 2 2 2],[2 2 2]));
-%!assert(set_slice([2 2], 33, 3), reshape([1 1 1 1 0 0 0 0 2 2 2 2],[2 2 3]));
+%!assert (set_slice ([2 2], 11, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 11, 1), [2 1;1 1])
+%!assert (set_slice ([2 2], 11, 2), [1 1;2 1])
+%!assert (set_slice ([2 2], 11, 3), [1 2;1 1])
+%!assert (set_slice ([2 2], 11, 4), [1 1;1 2])
+%!error id=Octave:invalid-resize set_slice ([2 2], 11, 5)
+%!error id=Octave:invalid-resize set_slice ([2 2], 11, 6)
+%!assert (set_slice ([2 2], 21, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 21, 1), [2 2;1 1])
+%!assert (set_slice ([2 2], 21, 2), [1 1;2 2])
+%!assert (set_slice ([2 2], 21, 3), [1 1;1 1;2 2])
+%!assert (set_slice ([2 2], 21, 4), [1 1;1 1;0 0;2 2])
+%!assert (set_slice ([2 2], 22, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 22, 1), [2 2;1 1]')
+%!assert (set_slice ([2 2], 22, 2), [1 1;2 2]')
+%!assert (set_slice ([ 2 2], 22, 3), [1 1;1 1;2 2]')
+%!assert (set_slice ([2 2], 22, 4), [1 1;1 1;0 0;2 2]')
+%!assert (set_slice ([2 2], 31, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 31, 1), [2 2;1 1])
+%!assert (set_slice ([2 2], 31, 2), [1 1;2 2])
+%!assert (set_slice ( [2 2], 31, 3), [1 1;1 1;2 2])
+%!assert (set_slice ([2 2], 31, 4), [1 1;1 1;0 0;2 2])
+%!assert (set_slice ([2 2], 32, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 32, 1), [2 2;1 1]')
+%!assert (set_slice ([2 2], 32, 2), [1 1;2 2]')
+%!assert (set_slice ([ 2 2], 32, 3), [1 1;1 1;2 2]')
+%!assert (set_slice ([2 2], 32, 4), [1 1;1 1;0 0;2 2]')
+%!assert (set_slice ([2 2], 33, []), ones ([2 2]))
+%!assert (set_slice ([2 2], 33, 1), [2 2;2 2])
+%!assert (set_slice ([2 2], 33, 2), reshape ([1 1 1 1 2 2 2 2],[2 2 2]))
+%!assert (set_slice ([ 2 2], 33, 3), reshape ([1 1 1 1 0 0 0 0 2 2 2 2],[2 2 3]))
diff --git a/test/test_struct.m b/test/test_struct.m
--- a/test/test_struct.m
+++ b/test/test_struct.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,250 +15,252 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/struct/fieldnames-1.m
 %!test
 %! s.a = 1;
 %! c = fieldnames (s);
-%! assert(iscell (c) && strcmp (c{1}, "a"));
+%! assert (iscell (c) && strcmp (c{1}, "a"));
 
 %% test/octave.test/struct/fieldnames-2.m
 %!test
 %! s.a.b = 1;
 %! c = fieldnames (s.a);
-%! assert(iscell (c) && strcmp (c{1}, "b"));
+%! assert (iscell (c) && strcmp (c{1}, "b"));
 
 %% test/octave.test/struct/fieldnames-3.m
 %!error <Invalid call to fieldnames> fieldnames ();
 
 %% test/octave.test/struct/fieldnames-4.m
 %!test
 %! s.a = 1;
-%! fail("fieldnames (s, 1)","Invalid call to fieldnames.*");
+%! fail ("fieldnames (s, 1)", "Invalid call to fieldnames");
 
 %% test/octave.test/struct/fieldnames-5.m
 %!error fieldnames (1);
 
 %% test/octave.test/struct/isfield-1.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! assert(isfield (s, "a"));
+%! assert (isfield (s, "a"));
 
 %% test/octave.test/struct/isfield-2.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! assert(!(isfield (s, "b")));
+%! assert (!(isfield (s, "b")));
 
 %% test/octave.test/struct/isfield-3.m
 %!error <Invalid call to isfield> isfield ();
 
 %% test/octave.test/struct/isfield-4.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
-%! fail("isfield (s, 'a', 3);","Invalid call to isfield.*");
+%! fail ("isfield (s, 'a', 3);", "Invalid call to isfield");
 
 %% test/octave.test/struct/isfield-5.m
-%!assert(isfield (1, "m") == 0);
+%!assert (isfield (1, "m") == 0);
 
 %% test/octave.test/struct/isfield-6.m
 %!test
 %! s.a = 2;
-%! assert(isfield (s, 2) == 0);
+%! assert (isfield (s, 2) == 0);
 
 %% test/octave.test/struct/isstruct-1.m
-%!assert(!(isstruct (1)));
+%!assert (!(isstruct (1)))
 
 %% test/octave.test/struct/isstruct-2.m
-%!assert(!(isstruct ([1, 2])));
+%!assert (!(isstruct ([1, 2])))
 
 %% test/octave.test/struct/isstruct-3.m
-%!assert(!(isstruct ([])));
+%!assert (!(isstruct ([])))
 
 %% test/octave.test/struct/isstruct-4.m
-%!assert(!(isstruct ([1, 2; 3, 4])));
+%!assert (!(isstruct ([1, 2; 3, 4])))
 
 %% test/octave.test/struct/isstruct-5.m
-%!assert(!(isstruct ("t")));
+%!assert (!(isstruct ("t")))
 
 %% test/octave.test/struct/isstruct-6.m
-%!assert(!(isstruct ("test")));
+%!assert (!(isstruct ("test")))
 
 %% test/octave.test/struct/isstruct-7.m
-%!assert(!(isstruct (["test"; "ing"])));
+%!assert (!(isstruct (["test"; "ing"])))
+
+%!assert (!(isstruct ({1})))
 
 %% test/octave.test/struct/isstruct-8.m
 %!test
 %! s.a = 1;
-%! assert(isstruct (s));
+%! assert (isstruct (s));
 
 %% test/octave.test/struct/isstruct-9.m
 %!test
 %! s.a.b = 1;
-%! assert(isstruct (s.a));
+%! assert (isstruct (s.a));
 
 %% test/octave.test/struct/isstruct-10.m
 %!error <Invalid call to isstruct> isstruct ();
 
 %% test/octave.test/struct/isstruct-11.m
 %!test
 %! s.a = 1;
-%! fail("isstruct (s, 1)","Invalid call to isstruct.*");
+%! fail ("isstruct (s, 1)", "Invalid call to isstruct");
 
 ## increment element of matrix stored in struct array field
 %!test
-%!  a = struct("c", {[1, 2, 3], [4, 5, 6], [7, 8, 9]});
-%!  a(2).c(3)++;
-%!  assert(a(2).c, [4, 5, 7]);
+%! a = struct ("c", {[1, 2, 3], [4, 5, 6], [7, 8, 9]});
+%! a(2).c(3)++;
+%! assert (a(2).c, [4, 5, 7]);
 
 ## create struct array by assignment to cs-list
 %!test
-%!  [a(1:2).x] = deal (1, 3);
-%!  assert(a, struct("x", {1, 3}));
-%!  assert({a(1:2).x}, {1, 3});
+%! [a(1:2).x] = deal (1, 3);
+%! assert (a, struct ("x", {1, 3}));
+%! assert ({a(1:2).x}, {1, 3});
 
 ## assign to subrange of struct array field
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
-%!  [b(1:2, [1,3]).name] = deal("aaa", "ddd", "ccc", "fff");
-%!  assert ({b.name}, {"aaa", "ddd", "b", "e", "ccc", "fff"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
+%! [b(1:2, [1,3]).name] = deal ("aaa", "ddd", "ccc", "fff");
+%! assert ({b.name}, {"aaa", "ddd", "b", "e", "ccc", "fff"});
 
 ## index into nested struct arrays
 %!test
-%!  a = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  a(2).value = a;
-%!  assert (a(2).value(2,3).name, "f");
+%! a = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! a(2).value = a;
+%! assert (a(2).value(2,3).name, "f");
 
 ## assign to subrange of field in nested struct array
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  b(3, 1).value = b;
-%!  [b(3, 1).value(1, [1, 3]).name] = deal ("aaa", "ccc");
-%!  assert (size (b), [3, 3]);
-%!  assert (b(3,1).value(1, 3).name, "ccc");
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! b(3, 1).value = b;
+%! [b(3, 1).value(1, [1, 3]).name] = deal ("aaa", "ccc");
+%! assert (size (b), [3, 3]);
+%! assert (b(3,1).value(1, 3).name, "ccc");
 
-## test 4 dimensional struct array
+## test 4-dimensional struct array
 %!test
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  assert (c(2,2,2,2), struct ("name", [], "value", []));
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! assert (c(2,2,2,2), struct ("name", [], "value", []));
 
-## assign to subrange of field in 4d struct array
+## assign to subrange of field in 4D struct array
 %!test
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  [c([1, 3], 2, :, [3, 4]).value] = deal (1);
-%!  assert (length(find([c.value] == 1)), 17);
-%!  assert (length(find([c.value])), 17);
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! [c([1, 3], 2, :, [3, 4]).value] = deal (1);
+%! assert (length(find([c.value] == 1)), 17);
+%! assert (length(find([c.value])), 17);
 
 ## swap elements of struct array
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
-%!  [b([2, 1], [3, 1]).name] = deal(b([1, 2], [1, 2]).name);
-%!  assert ({b.name}, {"e", "b", "b", "e", "d", "a"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 0);
+%! [b([2, 1], [3, 1]).name] = deal (b([1, 2], [1, 2]).name);
+%! assert ({b.name}, {"e", "b", "b", "e", "d", "a"});
 
 ## test internal ordering of struct array fields
 %!test
-%!  c(4, 4, 4, 4).value = 3;
-%!  c(1, 2, 3, 4).value = 2;
-%!  c(3, 3, 3, 3).value = 1;
-%!  d = reshape ({c.value}, size(c));
-%!  assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}],
-%!          [3, 2, 1]);
+%! c(4, 4, 4, 4).value = 3;
+%! c(1, 2, 3, 4).value = 2;
+%! c(3, 3, 3, 3).value = 1;
+%! d = reshape ({c.value}, size(c));
+%! assert ([d{4, 4, 4, 4}, d{1, 2, 3, 4}, d{3, 3, 3, 3}],
+%!         [3, 2, 1]);
 
 ## test assignment to mixed cs-list of field element subranges
 %!test
-%!  b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
-%!  [b(1:2, [1, 3]).name, b(2, 1:3).value] = ...
-%!    deal (1, 2, 3, 4, "5", "6", "7");
-%!  assert ({b.name}, {1, 2, "b", "e", 3, 4});
-%!  assert ({b.value}, {100, "5", 100, "6", 100, "7"});
+%! b = struct ("name", {"a", "b", "c"; "d", "e", "f"}, "value", 100);
+%! [b(1:2, [1, 3]).name, b(2, 1:3).value] = ...
+%!   deal (1, 2, 3, 4, "5", "6", "7");
+%! assert ({b.name}, {1, 2, "b", "e", 3, 4});
+%! assert ({b.value}, {100, "5", 100, "6", 100, "7"});
 
 %!error <a cs-list cannot be further indexed>
-%!  [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
-%!  [a(2:3).x(2)] = deal (10, 11);
+%! [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
+%! [a(2:3).x(2)] = deal (10, 11);
 
 %!error <a cs-list cannot be further indexed>
-%!  [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
-%!  a(2:3).x(2);
+%! [a(1:3).x] = deal ([1, 5], [3, 7], [8, 9]);
+%! a(2:3).x(2);
 
 %!error id=Octave:index-out-of-bounds
-%!  a(1).x.x = 1;
-%!  a(2).x;
+%! a(1).x.x = 1;
+%! a(2).x;
 
 %!error <invalid number of output arguments for constant expression>
-%!  a = struct ("value", {1, 2, 3, 4, 5});
-%!  [a(2:4).value] = 1;
+%! a = struct ("value", {1, 2, 3, 4, 5});
+%! [a(2:4).value] = 1;
 
 %!error <invalid assignment to cs-list outside multiple assignment>
-%!  c(4, 4, 4, 4).name  = "a";
-%!  c(3, 3, 3, 3).value = 1;
-%!  c([1, 3], 2, :, [3, 4]).value = 1;
+%! c(4, 4, 4, 4).name  = "a";
+%! c(3, 3, 3, 3).value = 1;
+%! c([1, 3], 2, :, [3, 4]).value = 1;
 
 ## test lazy copying in structs: nested assignment to self
 %!test
-%!  a.a = 1;
-%!  a.b = a;
-%!  a.b.c = a;
-%!  assert (a.b.c.b, struct ("a", 1));
+%! a.a = 1;
+%! a.b = a;
+%! a.b.c = a;
+%! assert (a.b.c.b, struct ("a", 1));
 
 ## test lazy copying in structs: indirect nested assignment to self
 %!test
-%!  a.a = 1;
-%!  a.b = 2;
-%!  b.c = a;
-%!  b.d = 3;
-%!  c.d = b;
-%!  c.e = 4;
-%!  a.b = c;
-%!  a.b.e = a;
-%!  assert (a.b.e.b.d.c, struct ("a", 1, "b", 2));
+%! a.a = 1;
+%! a.b = 2;
+%! b.c = a;
+%! b.d = 3;
+%! c.d = b;
+%! c.e = 4;
+%! a.b = c;
+%! a.b.e = a;
+%! assert (a.b.e.b.d.c, struct ("a", 1, "b", 2));
 
 ## test lazy copying in structs: nested assignment via function
 %!function aa = do_nest (a);
 %!  aa   = a;
 %!  aa.b = a;
-%! endfunction
+%!endfunction
 %!test
-%!  a.c = 1;
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  assert (a.b.b.b, struct ("c", 1));
+%! a.c = 1;
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! assert (a.b.b.b, struct ("c", 1));
 
 ## test lazy copying in structs: nested assignment via function
 %!function aa = do_nest (a);
 %!  aa   = a;
 %!  aa.b = a;
 %!  aa.b.c = aa;
-%! endfunction
+%!endfunction
 %!test
-%!  a.c = 1;
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  a = do_nest (a);
-%!  assert (a.b.c.b.b.c.b.b.c.b, struct ("c", 1));
+%! a.c = 1;
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! a = do_nest (a);
+%! assert (a.b.c.b.b.c.b.b.c.b, struct ("c", 1));
 
 ## test lazy copying in structs: nested assignment on different levels.
 %!test
-%!  a.b = 1;
-%!  b.c = a;
-%!  b.d.e = a;
-%!  b.f.g.h = a;
-%!  b.i.j.k.l = a;
-%!  a.m = b;
-%!  a.m.c.b = a;
-%!  assert (a.m.c.b.m.i.j.k.l, struct ("b", 1));
+%! a.b = 1;
+%! b.c = a;
+%! b.d.e = a;
+%! b.f.g.h = a;
+%! b.i.j.k.l = a;
+%! a.m = b;
+%! a.m.c.b = a;
+%! assert (a.m.c.b.m.i.j.k.l, struct ("b", 1));
 
 ## test indexed assignment into empty struct array
 %!test
-%!  s = resize(struct(),3,2);
-%!  s(3).foo = 42;
-%!  assert (s(3), struct ("foo", 42));
+%! s = resize (struct (), 3,2);
+%! s(3).foo = 42;
+%! assert (s(3), struct ("foo", 42));
 
 %!error id=Octave:index-out-of-bounds
-%!  s = resize(struct(),3,2);
-%!  s(3).foo = 42;
-%!  s(7);
+%! s = resize (struct (),3,2);
+%! s(3).foo = 42;
+%! s(7);
diff --git a/test/test_switch.m b/test/test_switch.m
--- a/test/test_switch.m
+++ b/test/test_switch.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -22,74 +22,74 @@
 %! b = 2;
 %! c = 3;
 %! 
 %! switch 0 case 1 x = a; case 2 x = b; otherwise x = c; endswitch
 %! switch 1 case 1 y = a; case 2 y = b; otherwise y = c; endswitch
 %! switch 2 case 1 z = a; case 2 z = b; otherwise z = c; endswitch
 %! switch 3 case 1 p = a; case 2 p = b; otherwise p = c; endswitch
 %! 
-%! assert(x == c && y == a && z == b && p == c);
+%! assert (x == c && y == a && z == b && p == c);
 
 %% test/octave.test/switch/switch-2.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %! 
 %! x = zeros (1, 4);
 %! 
 %! k = 1;
 %! 
 %! for i = 0:3
 %! switch (i)
-%! case a
-%! x(k) = a;
-%! case b
-%! x(k) = b;
-%! otherwise
-%! x(k) = c;
-%! endswitch
-%! k++;
+%!   case a
+%!    x(k) = a;
+%!   case b
+%!    x(k) = b;
+%!   otherwise
+%!    x(k) = c;
+%!   endswitch
+%!   k++;
 %! endfor
 %! 
-%! assert(all (x == [3, 1, 2, 3]));
+%! assert (all (x == [3, 1, 2, 3]));
 
 %% test/octave.test/switch/switch-3.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %! 
 %! x = zeros (1, 4);
 %! 
 %! k = 1;
 %! 
 %! for i = 0:3
-%! switch (i)
-%! case a
-%! x(k) = a;
-%! endswitch
-%! k++;
+%!   switch (i)
+%!   case a
+%!    x(k) = a;
+%!   endswitch
+%!   k++;
 %! endfor
 %! 
-%! assert(all (x == [0, 1, 0, 0]));
+%! assert (all (x == [0, 1, 0, 0]));
 
 %!test
 %! a = 1;
 %!
 %! switch 1
 %! otherwise
 %!   a = 2;
 %! endswitch
 %! 
-%! assert(a == 2);
+%! assert (a == 2);
 
 
 %% test/octave.test/switch/switch-4.m
-%!error <syntax error> eval("switch endswitch");
+%!error <syntax error> eval ("switch endswitch")
 
 %% test/octave.test/switch/switch-5.m
-%!error <syntax error> eval("switch case endswitch");
+%!error <syntax error> eval ("switch case endswitch")
 
 %% test/octave.test/switch/switch-6.m
-%!error <syntax error> eval("switch 1 default 1; endswitch");
+%!error <syntax error> eval ("switch 1 default 1; endswitch")
 
diff --git a/test/test_system.m b/test/test_system.m
--- a/test/test_system.m
+++ b/test/test_system.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,469 +15,475 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/system/cputime-1.m
 %!test
 %! [t1, u1, s1] = cputime ();
 %! for i = 1:200
-%! sin (i);
+%!   sin (i);
 %! endfor
 %! [t2, u2, s2] = cputime ();
-%! assert(t1 == u1 + s1 && t2 == u2 + s2 && t2 >= t1 && u2 >= u2 && s2 >= s2);
-
+%! assert (t1, u1 + s1);
+%! assert (t2 == u2 + s2);
+%! assert (t2 >= t1);
+%! assert (u2 >= u2);
+%! assert (s2 >= s2);
+%!#assert (t1 == u1 + s1 && t2 == u2 + s2 && t2 >= t1 && u2 >= u2 && s2 >= s2);
 
 %% test/octave.test/system/tic-toc-1.m
 %!test
 %! tic ();
 %! sleep (2);
-%! assert(toc () > 0);
+%! assert (toc () > 0);
 
 %% test/octave.test/system/pause-1.m
 %!test
 %! pause (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/pause-2.m
-%!error <Invalid call to pause> pause (1, 2);
+%!error <Invalid call to pause> pause (1, 2)
 
 %% test/octave.test/system/sleep-1.m
 %!test
 %! sleep (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/sleep-2.m
-%!error <Invalid call to sleep> sleep ();
+%!error <Invalid call to sleep> sleep ()
 
 %% test/octave.test/system/sleep-3.m
-%!error <Invalid call to sleep> sleep (1, 2);
+%!error <Invalid call to sleep> sleep (1, 2)
 
 %% test/octave.test/system/usleep-1.m
 %!test
 %! usleep (0);
 %! printf_assert ("ok\n");
-%! assert(prog_output_assert("ok"));
+%! assert (prog_output_assert ("ok"));
 
 %% test/octave.test/system/usleep-2.m
-%!error <Invalid call to usleep> usleep ();
+%!error <Invalid call to usleep> usleep ()
 
 %% test/octave.test/system/usleep-3.m
-%!error <Invalid call to usleep> usleep (1, 2);
+%!error <Invalid call to usleep> usleep (1, 2)
 
 %% test/octave.test/system/rename-1.m
 %!test
 %! from = tmpnam ();
 %! to = tmpnam ();
 %! id = fopen (from, "wb");
 %! if (id > 0 && fclose (id) == 0)
 %!   [s, e] = stat (from);
 %!   if (! e)
 %!     if (rename (from, to) == 0)
 %!       [s, e] = stat (from);
 %!       if (e < 0)
 %!         [s, e] = stat (to);
-%!         assert(e == 0);
+%!         assert (e == 0);
 %!         unlink (to);
 %!       endif
 %!     endif
 %!   endif
 %! endif
 
 %% test/octave.test/system/rename-2.m
-%!error <Invalid call to rename> rename ();
+%!error <Invalid call to rename> rename ()
 
 %% test/octave.test/system/rename-3.m
-%!error <Invalid call to rename> rename ("foo", "bar", 1);
+%!error <Invalid call to rename> rename ("foo", "bar", 1)
 
 %% test/octave.test/system/unlink-1.m
 %!test
 %! nm = tmpnam ();
 %! if ((id = fopen (nm, "wb")) > 0)
 %!   [s, err] = stat (nm);
 %!   if (! err && fclose (id) == 0 && unlink (nm) == 0)
 %!     [s, err] = stat (nm);
-%!     assert(err < 0);
+%!     assert (err < 0);
 %!   endif
 %! endif
 
 %% test/octave.test/system/unlink-2.m
-%!error <Invalid call to unlink> unlink ();
+%!error <Invalid call to unlink> unlink ()
 
 %% test/octave.test/system/unlink-3.m
-%!error <Invalid call to unlink> unlink ("foo", 1);
+%!error <Invalid call to unlink> unlink ("foo", 1)
 
 %% test/octave.test/system/readdir-1.m
 %!test
 %! [files, status, msg] = readdir (filesep);
-%! assert(iscell (files) && status == 0 && strcmp (msg, ""));
+%! assert (iscell (files) && status == 0 && strcmp (msg, ""));
 
 %% test/octave.test/system/readdir-2.m
-%!error <Invalid call to readdir> readdir ();
+%!error <Invalid call to readdir> readdir ()
 
 %% test/octave.test/system/readdir-3.m
-%!error <Invalid call to readdir> readdir ("foo", 1);
+%!error <Invalid call to readdir> readdir ("foo", 1)
 
 %% test/octave.test/system/mk-rm-dir-1.m
 %!test
 %! nm = tmpnam ();
 %! e1 = mkdir (nm);
 %! [s2, e2] = stat (nm);
 %! e3 = rmdir (nm);
 %! [s4, e4] = stat (nm);
-%! assert((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
+%! assert ((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
 
 %% test/octave.test/system/mkdir-1.m
-%!error <Invalid call to mkdir> mkdir ();
+%!error <Invalid call to mkdir> mkdir ()
 
 %% test/octave.test/system/mkdir-2.m
-%!error <Invalid call to mkdir> mkdir ("foo", 1, 2);
+%!error <Invalid call to mkdir> mkdir ("foo", 1, 2)
 
 %% test/octave.test/system/rmdir-1.m
-%!error <Invalid call to rmdir> rmdir ();
+%!error <Invalid call to rmdir> rmdir ()
 
 %% test/octave.test/system/rmdir-2.m
 %!test
 %! crr = confirm_recursive_rmdir ();
 %! confirm_recursive_rmdir (0);
-%! assert(!rmdir ("foo", "s"));
+%! assert (!rmdir ("foo", "s"));
 %! confirm_recursive_rmdir (crr);
 
-%% FIXME This test messes up the path it seems!! Why?
 %% test/octave.test/system/umask-1.m
-%!#test
-%! umask (0);
+%!test
+%! orig_umask = umask (0);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s1 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %! 
 %! umask (777);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s2 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %! 
-%! assert(strcmp (s1.modestr, "-rw-rw-rw-") && strcmp (s2.modestr, "----------"));
+%! assert (deblank (s1.modestr), "-rw-rw-rw-");
+%! assert (deblank (s2.modestr), "----------");
+%! # Restore original umask value
+%! umask (orig_umask);
 
 %% test/octave.test/system/umask-2.m
-%!error <Invalid call to umask> umask ();
+%!error <Invalid call to umask> umask ()
 
 %% test/octave.test/system/umask-3.m
-%!error <Invalid call to umask> umask (1, 2);
+%!error <Invalid call to umask> umask (1, 2)
 
 %% test/octave.test/system/stat-1.m
 %!test
 %! [s, err, msg] = stat (filesep);
-%! assert((err == 0
+%! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
 %% test/octave.test/system/stat-2.m
-%!error <Invalid call to stat> stat ();
+%!error <Invalid call to stat> stat ()
 
 %% test/octave.test/system/stat-3.m
-%!error <Invalid call to stat> stat ("foo", 1);
+%!error <Invalid call to stat> stat ("foo", 1)
 
 %% test/octave.test/system/lstat-1.m
 %!test
 %! [s, err, msg] = lstat (filesep);
-%! assert((err == 0
+%! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
 %% test/octave.test/system/lstat-2.m
-%!error <Invalid call to lstat> lstat ();
+%!error <Invalid call to lstat> lstat ()
 
 %% test/octave.test/system/lstat-3.m
-%!error <Invalid call to lstat> lstat ("foo", 1);
+%!error <Invalid call to lstat> lstat ("foo", 1)
 
 %% test/octave.test/system/glob-1.m
-%!assert(iscell (glob ([filesep "*"])));
+%!assert (iscell (glob ([filesep "*"])))
 
 %% test/octave.test/system/glob-2.m
-%!error <Invalid call to glob*> glob ();
+%!error <Invalid call to glob> glob ()
 
 %% test/octave.test/system/glob-3.m
-%!error <Invalid call to glob> glob ("foo", 1);
+%!error <Invalid call to glob> glob ("foo", 1)
 
 %% test/octave.test/system/fnmatch-1.m
 %!test
 %! string_fill_char = setstr (0);
-%! assert((fnmatch ("a*a", {"aba"; "xxxba"; "aa"}) == [1; 0; 1]
+%! assert ((fnmatch ("a*a", {"aba"; "xxxba"; "aa"}) == [1; 0; 1]
 %! && fnmatch ({"a*a"; "b*b"}, "bob")
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"}) == [1; 0]
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"; "x001"}) == [1; 0; 1]
 %! && fnmatch ("x???y", {"xabcy"; "xy"}) == [1; 0]));
 
 %% test/octave.test/system/fnmatch-2.m
-%!error <Invalid call to fnmatch> fnmatch ();
+%!error <Invalid call to fnmatch> fnmatch ()
 
 %% test/octave.test/system/fnmatch-3.m
-%!error <Invalid call to fnmatch> fnmatch ("foo", "bar", 3);
+%!error <Invalid call to fnmatch> fnmatch ("foo", "bar", 3)
 
 %% test/octave.test/system/file_in_path-1.m
-%!assert(ischar (file_in_path (path (), "date.m")));
+%!assert (ischar (file_in_path (path (), "date.m")))
 
 %% test/octave.test/system/file_in_path-2.m
-%!error <invalid option> file_in_path ("foo", "bar", 1);
+%!error <invalid option> file_in_path ("foo", "bar", 1)
 
 %% test/octave.test/system/file_in_path-3.m
-%!error <Invalid call to file_in_path> file_in_path ();
+%!error <Invalid call to file_in_path> file_in_path ()
 
 %% test/octave.test/system/file_in_path-4.m
-%!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka");
+%!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka")
 
 %% test/octave.test/system/tilde_expand-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwuid (getuid ());
-%! assert((strcmp (x.dir, tilde_expand ("~"))
+%! assert ((strcmp (x.dir, tilde_expand ("~"))
 %! && strcmp (x.dir, tilde_expand (sprintf ("~%s", x.name)))
 %! && strcmp ("foobar", tilde_expand ("foobar"))));
 
 %% test/octave.test/system/tilde_expand-2.m
-%!error <Invalid call to tilde_expand> tilde_expand ();
+%!error <Invalid call to tilde_expand> tilde_expand ()
 
 %% test/octave.test/system/tilde_expand-3.m
-%!error <Invalid call to tilde_expand> tilde_expand ("str", 2);
+%!error <Invalid call to tilde_expand> tilde_expand ("str", 2)
 
 %% test/octave.test/system/getpgrp-1.m
 %!testif HAVE_GETPGRP
-%! assert(getpgrp () > 0);
+%! assert (getpgrp () > 0);
 
 %% test/octave.test/system/getpgrp-2.m
-%!error <... getpgrp> getpgrp (1);
+%!error <... getpgrp> getpgrp (1)
 
 %% test/octave.test/system/getpid-1.m
-%!assert(getpid () > 0);
+%!assert (getpid () > 0)
 
 %% test/octave.test/system/getpid-2.m
-%!error <... getpid> getpid (1);
+%!error <... getpid> getpid (1)
 
 %% test/octave.test/system/getppid-1.m
 %!testif HAVE_GETPPID
-%! assert(getppid () > 0);
+%! assert (getppid () > 0);
 
 %% test/octave.test/system/getppid-2.m
-%!error <... getppid> getppid (1);
+%!error <... getppid> getppid (1)
 
 %% test/octave.test/system/geteuid-1.m
-%!assert(geteuid () >= 0);
+%!assert (geteuid () >= 0)
 
 %% test/octave.test/system/geteuid-2.m
-%!error <... geteuid> geteuid (1);
+%!error <... geteuid> geteuid (1)
 
 %% test/octave.test/system/getuid-1.m
-%!assert(getuid () >= 0);
+%!assert (getuid () >= 0)
 
 %% test/octave.test/system/getuid-2.m
-%!error <... getuid> getuid (1);
+%!error <... getuid> getuid (1)
 
 %% test/octave.test/system/getegid-1.m
-%!assert(getegid () >= 0);
+%!assert (getegid () >= 0)
 
 %% test/octave.test/system/getegid-2.m
-%!error <... getegid> getegid (1);
+%!error <... getegid> getegid (1)
 
 %% test/octave.test/system/getgid-1.m
-%!assert(getgid () >= 0);
+%!assert (getgid () >= 0)
 
 %% test/octave.test/system/getgid-2.m
-%!error <... getgid> getgid (1);
+%!error <... getgid> getgid (1)
 
 %% test/octave.test/system/getenv-1.m
-%!assert(strcmp (getenv ("HOME"), tilde_expand ("~")));
+%!assert (getenv ("HOME"), tilde_expand ("~"))
 
 %% test/octave.test/system/getenv-2.m
-%!error <Invalid call to getenv> getenv ();
+%!error <Invalid call to getenv> getenv ()
 
 %% test/octave.test/system/getenv-3.m
-%!error <Invalid call to getenv> getenv ("foo", 1);
+%!error <Invalid call to getenv> getenv ("foo", 1)
 
 %% test/octave.test/system/getenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
-%! fail("getenv (1)","warning");
+%! fail ("getenv (1)", "warning");
 %! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/putenv-1.m
 %!test
 %! putenv ("foobar", "baz");
-%! assert(strcmp (getenv ("foobar"), "baz"));
+%! assert (getenv ("foobar"), "baz");
 
 %% test/octave.test/system/putenv-2.m
-%!error <Invalid call to putenv> putenv ();
+%!error <Invalid call to putenv> putenv ()
 
 %% test/octave.test/system/putenv-3.m
-%!error <Invalid call to putenv> putenv ("foo", "bar", 1);
+%!error <Invalid call to putenv> putenv ("foo", "bar", 1)
 
 %% test/octave.test/system/putenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
-%! fail("putenv (1, 2)","warning");
+%! fail ("putenv (1, 2)","warning");
 %! warning (wns.state, "Octave:num-to-str");
 
 %% test/octave.test/system/cd-1.m
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! if (ispc () && ! isunix ())
 %!   # should be a drive letter
-%!   assert(length (d1), 3);
-%!   assert(d1(2), ":");
-%!   assert(d1(3), "\\");
+%!   assert (length (d1), 3);
+%!   assert (d1(2), ":");
+%!   assert (d1(3), "\\");
 %! else
-%!   assert("/", d1);
+%!   assert ("/", d1);
 %! endif
-%! assert(pwd(), xdir);
+%! assert (pwd(), xdir);
 
 %% test/octave.test/system/cd-2.m
-%!error cd (1);
+%!error cd (1)
 
 %% test/octave.test/system/pwd-1.m
-%!assert(ischar (pwd ()));
+%!assert (ischar (pwd ()))
 
 %% test/octave.test/system/getpwent-1.m
 %!testif HAVE_GETPWENT
 %! s = getpwent ();
 %! endpwent (); 
-%! assert((isstruct (s)
+%! assert ((isstruct (s)
 %! && isfield (s, "name")
 %! && isfield (s, "passwd")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "gecos")
 %! && isfield (s, "dir")
 %! && isfield (s, "shell")));
 
 %% test/octave.test/system/getpwent-2.m
-%!error <Invalid call to getpwent> getpwent (1);
+%!error <Invalid call to getpwent> getpwent (1)
 
 %% test/octave.test/system/getpwuid-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwent ();
 %! y = getpwuid (x.uid);
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/getpwuid-2.m
-%!error <Invalid call to getpwuid> getpwuid ();
+%!error <Invalid call to getpwuid> getpwuid ()
 
 %% test/octave.test/system/getpwuid-3.m
-%!error <Invalid call to getpwuid> getpwuid (1, 2);
+%!error <Invalid call to getpwuid> getpwuid (1, 2)
 
 %% test/octave.test/system/getpwnam-1.m
 %!testif HAVE_GETPWNAM
 %! x = getpwent ();
 %! y = getpwnam (x.name);
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/getpwnam-2.m
-%!error <Invalid call to getpwnam> getpwnam ();
+%!error <Invalid call to getpwnam> getpwnam ()
 
 %% test/octave.test/system/getpwnam-3.m
-%!error <Invalid call to getpwnam> getpwnam ("foo", 1);
+%!error <Invalid call to getpwnam> getpwnam ("foo", 1)
 
 %% test/octave.test/system/setpwent-1.m
 %!testif HAVE_SETPWENT
 %! x = getpwent ();
 %! setpwent ();
 %! y = getpwent ();
 %! endpwent (); 
-%! assert(strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
 %% test/octave.test/system/setpwent-2.m
-%!error <Invalid call to setpwent> setpwent (1);
+%!error <Invalid call to setpwent> setpwent (1)
 
 %% test/octave.test/system/endpwent-1.m
-%!error <Invalid call to endpwent> endpwent (1);
+%!error <Invalid call to endpwent> endpwent (1)
 
 %% test/octave.test/system/getgrent-1.m
 %!testif HAVE_GETGRENT
 %! x = getgrent ();
 %! endgrent ();
-%! assert((isstruct (x)
+%! assert ((isstruct (x)
 %! && isfield (x, "name")
 %! && isfield (x, "passwd")
 %! && isfield (x, "gid")
 %! && isfield (x, "mem")));
 
 %% test/octave.test/system/getgrent-2.m
-%!error <Invalid call to getgrent> getgrent (1);
+%!error <Invalid call to getgrent> getgrent (1)
 
 %% test/octave.test/system/getgrgid-1.m
 %!testif HAVE_GETGRGID
 %! x = getgrent ();
 %! y = getgrgid (x.gid);
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/getgrgid-2.m
-%!error <Invalid call to getgrgid> getgrgid ();
+%!error <Invalid call to getgrgid> getgrgid ()
 
 %% test/octave.test/system/getgrgid-3.m
-%!error <Invalid call to getgrgid> getgrgid (1, 2);
+%!error <Invalid call to getgrgid> getgrgid (1, 2)
 
 %% test/octave.test/system/getgrnam-1.m
 %!testif HAVE_GETGRNAM
 %! x = getgrent ();
 %! y = getgrnam (x.name);
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/getgrnam-2.m
-%!error <Invalid call to getgrnam> getgrnam ();
+%!error <Invalid call to getgrnam> getgrnam ()
 
 %% test/octave.test/system/getgrnam-3.m
-%!error <Invalid call to getgrnam> getgrnam ("foo", 1);
+%!error <Invalid call to getgrnam> getgrnam ("foo", 1)
 
 %% test/octave.test/system/setgrent-1.m
 %!testif HAVE_SETGRENT
 %! x = getgrent ();
 %! setgrent ();
 %! y = getgrent ();
 %! endgrent ();
-%! assert(strcmp (x.name, y.name) && x.gid == y.gid);
+%! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
 %% test/octave.test/system/setgrent-2.m
-%!error <Invalid call to setgrent> setgrent (1);
+%!error <Invalid call to setgrent> setgrent (1)
 
 %% test/octave.test/system/endgrent-1.m
-%!error <Invalid call to endgrent> endgrent (1);
+%!error <Invalid call to endgrent> endgrent (1)
 
 %% test/octave.test/system/isieee-1.m
-%!assert(isieee () == 1 || isieee () == 0);
+%!assert (isieee () == 1 || isieee () == 0)
 
 %% test/octave.test/system/octave_config_info-1.m
-%!assert(isstruct (octave_config_info ()));
+%!assert (isstruct (octave_config_info ()))
 
 %% test/octave.test/system/getrusage-1.m
-%!assert(isstruct (getrusage ()));
+%!assert (isstruct (getrusage ()))
 
diff --git a/test/test_transpose.m b/test/test_transpose.m
--- a/test/test_transpose.m
+++ b/test/test_transpose.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,28 +11,76 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/transpose/transpose-1.m
+%% Basic tests
 %!test
 %! scalar = 2;
-%! assert(scalar',2);
+%! assert (scalar', 2);
 
-%% test/octave.test/transpose/transpose-2.m
 %!test
 %! range = 1:4;
-%! assert(range',[1;2;3;4]);
+%! assert (range', [1;2;3;4]);
 
-%% test/octave.test/transpose/transpose-3.m
 %!test
 %! vector = [1;2;3;4];
-%! assert(vector',[1,2,3,4]);
+%! assert (vector', [1,2,3,4]);
 
-%% test/octave.test/transpose/transpose-4.m
 %!test
 %! matrix = [1,2;3,4];
-%! assert(matrix',[1,3;2,4]);
+%! assert (matrix', [1,3;2,4]);
+
+%% Basic tests on complex numbers
+%!test
+%! scalar = 2i;
+%! assert (scalar', -2i);
+
+%!test
+%! range = (1:4)*i;
+%! assert (range', [-1i;-2i;-3i;-4i]);
+
+%!test
+%! vector = [1;2;3;4]*i;
+%! assert (vector', [-1i,-2i,-3i,-4i]);
+
+%!test
+%! matrix = [1,2;3,4]*i;
+%! assert (matrix', [-1i,-3i;-2i,-4i]);
+
+%% Test non-Hermitian transpose
+%!test
+%! scalar = 2i;
+%! assert (scalar.', 2i);
 
+%!test
+%! range = (1:4)*i;
+%! assert (range.', [1i;2i;3i;4i]);
+
+%!test
+%! vector = [1;2;3;4]*i;
+%! assert (vector.', [1i,2i,3i,4i]);
+
+%!test
+%! matrix = [1,2;3,4]*i;
+%! assert (matrix.', [1i,3i;2i,4i]);
+
+%% Basic tests on float complex numbers
+%!test
+%! scalar = single (2i);
+%! assert (scalar', single (-2i));
+
+%!test
+%! range = single ((1:4)*i);
+%! assert (range', single ([-1i;-2i;-3i;-4i]));
+
+%!test
+%! vector = single ([1;2;3;4]*i);
+%! assert (vector', single ([-1i,-2i,-3i,-4i]));
+
+%!test
+%! matrix = single ([1,2;3,4]*i);
+%! assert (matrix', single ([-1i,-3i;-2i,-4i]));
+
diff --git a/test/test_try.m b/test/test_try.m
--- a/test/test_try.m
+++ b/test/test_try.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,125 +15,125 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/try/try-1.m
 %!test
 %! try
 %! catch
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! end_try_catch
 
 %% test/octave.test/try/try-2.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %! catch
 %! end_try_catch
 %! a = 1;
-%! assert(a,1);
+%! assert (a,1);
 
 %% test/octave.test/try/try-3.m
 %!test
 %! clear x;
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %!   x = 1;
 %! catch
 %! end_try_catch
 %! a = 2;
-%! assert(!exist('x'))
-%! assert(a,2)
+%! assert (!exist ('x'));
+%! assert (a,2);
 
 %% test/octave.test/try/try-4.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
 %! catch
 %!   x = 1;
 %! end_try_catch
-%! assert(exist('x'))
+%! assert (exist ('x'));
 
 %% test/octave.test/try/try-5.m
 %!test
 %! try
 %!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert (strcmp(lasterr()(1:13), "`a' undefined"))
+%!   assert (lasterr()(1:13), "`a' undefined");
 %! end_try_catch
-%! assert (strcmp(lasterr()(1:13), "`a' undefined"))
+%! assert (lasterr()(1:13), "`a' undefined");
 
 %% test/octave.test/try/try-6.m
 %!test 
 %! try
-%!   error ("user-defined error")
+%!   error ("user-defined error");
 %! catch
-%!   assert(lasterr,"user-defined error");
+%!   assert (lasterr, "user-defined error");
 %! end_try_catch
 
 %% test/octave.test/try/try-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
 %!  ms = cstrcat ("<", s, ">");
+%!endfunction
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert(strcmp(mangle (lasterr)(1:14),"<`a' undefined"))
+%!   assert (mangle (lasterr)(1:14), "<`a' undefined");
 %! end_try_catch
 
-
 %% test/octave.test/try/try-8.m
 %!test
 %! try
 %!   try
-%!     clear a
+%!     clear a;
 %!     a;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     assert(strcmp(lasterr()(1:13), "`a' undefined"))
+%!     assert (lasterr()(1:13), "`a' undefined");
 %!   end_try_catch
-%!   clear b
+%!   clear b;
 %!   b;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
-%!   assert(strcmp(lasterr()(1:13), "`b' undefined"))
+%!   assert (lasterr()(1:13), "`b' undefined");
 %! end_try_catch
 
 %% test/octave.test/try/try-9.m
 %!test
 %! try
-%!   clear a
+%!   clear a;
 %!   a;
-%!   error("Shoudn't get here");
+%!   error ("Shoudn't get here");
 %! catch
 %!   try
-%!     assert(strcmp(lasterr()(1:13), "`a' undefined"))
-%!     clear b
+%!     assert (lasterr()(1:13), "`a' undefined");
+%!     clear b;
 %!     b;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     assert(strcmp(lasterr()(1:13), "`b' undefined"))
+%!     assert (lasterr()(1:13), "`b' undefined");
 %!   end_try_catch
 %! end_try_catch
 
 %% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
-%!     clear a
+%!     clear a;
 %!     a;
-%!     error("Shoudn't get here");
+%!     error ("Shoudn't get here");
 %!   catch
-%!     error(cstrcat("rethrow: ",lasterr));
+%!     error (cstrcat ("rethrow: ", lasterr));
 %!   end_try_catch
 %! catch
-%!   assert(strcmp(lasterr()(1:22), "rethrow: `a' undefined"))
+%!   assert (lasterr()(1:22), "rethrow: `a' undefined");
 %! end_try_catch
 
diff --git a/test/test_unwind.m b/test/test_unwind.m
--- a/test/test_unwind.m
+++ b/test/test_unwind.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,32 +25,36 @@
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
 %!    y = [y, g];
 %!  unwind_protect_cleanup
 %!    g = save_g;
 %!    y = [y, g];
 %!  end_unwind_protect
+%!endfunction
+%!
 %!test
 %! global g = -1;
 %! y = f ([3,4]);
-%! assert(y,[0,1,-1]);
+%! assert (y, [0,1,-1]);
 
 %% test/octave.test/unwind/unwind-2.m
 %!function y = f (x)
 %!  global g;
 %!  save_g = g;
 %!  unwind_protect
 %!    g = 0;
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
 %!    y = [y, g];
 %!  unwind_protect_cleanup
 %!    g = save_g;
 %!    y = [y, g];
-%!    assert(y,[0,-1]);
+%!    assert (y, [0,-1]);
 %!  end_unwind_protect
+%!endfunction
+%!
 %!test
 %! global g = -1;
-%! fail("y = f (3);","mismatch");
+%! fail ("y = f (3);", "mismatch");
 
diff --git a/test/test_while.m b/test/test_while.m
--- a/test/test_while.m
+++ b/test/test_while.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2006-2011 John W. Eaton
+## Copyright (C) 2006-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,56 +15,56 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %% test/octave.test/while/while-1.m
 %!test
 %! i = 0;
 %! while (eye (2))
-%! i++;
-%! printf_assert ("%d\n", i);
-%! endwhile;
-%! assert(prog_output_assert(""));
+%!   i++;
+%!   printf_assert ("%d\n", i);
+%! endwhile
+%! assert (prog_output_assert (""));
 
 %% test/octave.test/while/while-2.m
 %!test
 %! i = 5;
 %! while (--i)
-%! printf_assert ("%d", i);
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("4321"));
+%! assert (prog_output_assert ("4321"));
 
 %% test/octave.test/while/while-3.m
 %!test
 %! i = 5;
 %! while (i)
-%! i--;
-%! printf_assert ("%d", i);
+%!   i--;
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("43210"));
+%! assert (prog_output_assert ("43210"));
 
 %% test/octave.test/while/while-4.m
 %!test
 %! i = 0;
 %! while (i++ < 20)
-%! if (i > 2)
-%! break;
-%! endif
-%! printf_assert ("%d", i);
-%! endwhile;
+%!   if (i > 2)
+%!     break;
+%!   endif
+%!   printf_assert ("%d", i);
+%! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("12"));
+%! assert (prog_output_assert ("12"));
 
 %% test/octave.test/while/while-5.m
 %!test
 %! i = 0;
 %! while (++i < 5)
-%! if (i < 3)
-%! continue;
-%! endif
-%! printf_assert ("%d", i);
+%!   if (i < 3)
+%!     continue;
+%!   endif
+%!   printf_assert ("%d", i);
 %! endwhile
 %! printf_assert ("\n");
-%! assert(prog_output_assert("34"));
+%! assert (prog_output_assert ("34"));
 
