# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1550849322 0
#      Fri Feb 22 15:28:42 2019 +0000
# Node ID d1419ac095647fa3181eaf7fcd126a9f8eb5003d
# Parent  b55f4781fc6e75c80c9ce1e8086ed9e95744d661
split method, package, and property classes from cdef-class file

* cdef-method.cc, cdef-method.h, cdef-package.cc, cdef-package.h,
cdef-property.cc, cdef-property.h: New files.

* libinterp/octave-value/module.mk: Update.

* cdef-class.cc, cdef-class.h, cdef-manager.h, cdef-object.cc,
cdef-utils.cc, cdef-utils.h, ov-classdef.cc: Adapt as needed for new
file arrangement.

diff --git a/libinterp/octave-value/cdef-class.cc b/libinterp/octave-value/cdef-class.cc
--- a/libinterp/octave-value/cdef-class.cc
+++ b/libinterp/octave-value/cdef-class.cc
@@ -45,229 +45,27 @@ along with Octave; see the file COPYING.
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
 
-OCTAVE_NORETURN static
-void
-err_method_access (const std::string& from, const cdef_method& meth)
-{
-  octave_value acc = meth.get ("Access");
-  std::string acc_s;
-
-  if (acc.is_string ())
-    acc_s = acc.string_value ();
-  else
-    acc_s = "class-restricted";
-
-  error ("%s: method `%s' has %s access and cannot be run in this context",
-         from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
-}
-
-OCTAVE_NORETURN static
-void
-err_property_access (const std::string& from, const cdef_property& prop,
-                     bool is_set = false)
-{
-  octave_value acc = (prop.get (is_set ? "SetAccess" : "GetAccess"));
-  std::string acc_s;
-
-  if (acc.is_string ())
-    acc_s = acc.string_value ();
-  else
-    acc_s = "class-restricted";
-
-  if (is_set)
-    error ("%s: property `%s' has %s access and cannot be set in this context",
-           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
-  else
-    error ("%s: property `%s' has %s access and cannot be obtained in this context",
-           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
-}
-
 static octave_value
 make_fcn_handle (const octave_value& fcn, const std::string& nm)
 {
   octave_value retval;
 
   if (fcn.is_defined ())
     retval = octave_value (new octave_fcn_handle (fcn, nm));
 
   return retval;
 }
 
-static bool
-check_access (const cdef_class& cls, const octave_value& acc,
-              const std::string& meth_name = "",
-              const std::string& prop_name = "",
-              bool is_prop_set = false)
-{
-  if (acc.is_string ())
-    {
-      std::string acc_s = acc.string_value ();
-
-      if (acc_s == "public")
-        return true;
-
-      cdef_class ctx = get_class_context ();
-
-      // The access is private or protected, this requires a
-      // valid class context.
-
-      if (ctx.ok ())
-        {
-          if (acc_s == "private")
-            return (ctx == cls);
-          else if (acc_s == "protected")
-            {
-              if (is_superclass (cls, ctx))
-                // Calling a protected method in a superclass.
-                return true;
-              else if (is_strict_superclass (ctx, cls))
-                {
-                  // Calling a protected method or property in a derived class.
-                  // This is only allowed if the context class knows about it
-                  // and has access to it.
-
-                  if (! meth_name.empty ())
-                    {
-                      cdef_method m = ctx.find_method (meth_name);
-
-                      if (m.ok ())
-                        return check_access (ctx, m.get ("Access"), meth_name);
-
-                      return false;
-                    }
-                  else if (! prop_name.empty ())
-                    {
-                      cdef_property p = ctx.find_property (prop_name);
-
-                      if (p.ok ())
-                        {
-                          octave_value p_access = p.get (is_prop_set ?
-                                                         "SetAccess" :
-                                                         "GetAccess");
-
-                          return check_access (ctx, p_access, meth_name,
-                                               prop_name, is_prop_set);
-                        }
-
-                      return false;
-                    }
-                  else
-                    panic_impossible ();
-                }
-
-              return false;
-            }
-          else
-            panic_impossible ();
-        }
-    }
-  else if (acc.isobject ())
-    {
-      cdef_class ctx = get_class_context ();
-
-      // At this point, a class context is always required.
-      if (ctx.ok ())
-        {
-          if (ctx == cls)
-            return true;
-
-          cdef_class acc_cls (to_cdef (acc));
-
-          if (is_superclass (acc_cls, ctx))
-            return true;
-        }
-    }
-  else if (acc.iscell ())
-    {
-      Cell acc_c = acc.cell_value ();
-
-      cdef_class ctx = get_class_context ();
-
-      // At this point, a class context is always required.
-
-      if (ctx.ok ())
-        {
-          if (ctx == cls)
-            return true;
-
-          for (int i = 0; i < acc.numel (); i++)
-            {
-              cdef_class acc_cls (to_cdef (acc_c(i)));
-
-              if (is_superclass (acc_cls, ctx))
-                return true;
-            }
-        }
-    }
-  else
-    error ("invalid property/method access in class `%s'",
-           cls.get_name ().c_str ());
-
-  return false;
-}
-
-static bool
-is_method_executing (const octave_value& ov, const cdef_object& obj)
-{
-  octave::tree_evaluator& tw
-    = octave::__get_evaluator__ ("is_method_executing");
-
-  octave::call_stack& cs = octave::__get_call_stack__ ("is_method_executing");
-
-  octave_function *stack_fcn = cs.current ();
-
-  octave_function *method_fcn = ov.function_value (true);
-
-  // Does the top of the call stack match our target function?
-
-  if (stack_fcn && stack_fcn == method_fcn)
-    {
-      octave_user_function *uf = method_fcn->user_function_value (true);
-
-      // We can only check the context object for user-function (not builtin),
-      // where we have access to the parameters (arguments and return values).
-      // That's ok as there's no need to call this function for builtin
-      // methods.
-
-      if (uf)
-        {
-          // At this point, the method is executing, but we still need to
-          // check the context object for which the method is executing.  For
-          // methods, it's the first argument of the function; for ctors, it
-          // is the first return value.
-
-          octave::tree_parameter_list *pl = uf->is_classdef_constructor ()
-            ? uf->return_list () : uf->parameter_list ();
-
-          if (pl && pl->size () > 0)
-            {
-              octave::tree_decl_elt *elt = pl->front ();
-
-              octave_value arg0 = tw.evaluate (elt);
-
-              if (arg0.is_defined () && arg0.type_name () == "object")
-                {
-                  cdef_object arg0_obj = to_cdef (arg0);
-
-                  return obj.is (arg0_obj);
-                }
-            }
-        }
-    }
-
-  return false;
-}
-
 cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>& superclasses)
   : cdef_meta_object_rep (), member_count (0), handle_class (false),
     object_count (0), meta (false)
 {
   put ("SuperClasses", to_ov (superclasses));
   implicit_ctor_list = superclasses;
 }
 
@@ -1311,422 +1109,8 @@ cdef_class::make_meta_class (octave::int
 
 octave_function*
 cdef_class::get_method_function (const std::string& /* nm */)
 {
   octave_classdef_meta *p = new octave_classdef_meta (*this);
 
   return p;
 }
-
-octave_value
-cdef_property::cdef_property_rep::get_value (const cdef_object& obj,
-                                             bool do_check_access,
-                                             const std::string& who)
-{
-  octave_value retval;
-
-  if (do_check_access && ! check_get_access ())
-    err_property_access (who, wrap (), false);
-
-  if (! obj.is_constructed ())
-    {
-      cdef_class cls (to_cdef (get ("DefiningClass")));
-
-      if (! obj.is_partially_constructed_for (cls))
-        error ("cannot reference properties of class `%s' for non-constructed object",
-               cls.get_name ().c_str ());
-    }
-
-  octave_value get_fcn = get ("GetMethod");
-
-  // FIXME: should check whether we're already in get accessor method
-
-  if (get_fcn.isempty () || is_method_executing (get_fcn, obj))
-    retval = obj.get (get ("Name").string_value ());
-  else
-    {
-      octave_value_list args;
-
-      args(0) = to_ov (obj);
-
-      args = octave::feval (get_fcn, args, 1);
-
-      retval = args(0);
-    }
-
-  return retval;
-}
-
-octave_value
-cdef_property::cdef_property_rep::get_value (bool do_check_access,
-                                             const std::string& who)
-{
-  if (do_check_access && ! check_get_access ())
-    err_property_access (who, wrap (), false);
-
-  return get ("DefaultValue");
-}
-
-bool
-cdef_property::cdef_property_rep::is_recursive_set (const cdef_object& /* obj */) const
-{
-  // FIXME: implement
-  return false;
-}
-
-void
-cdef_property::cdef_property_rep::set_value (cdef_object& obj,
-                                             const octave_value& val,
-                                             bool do_check_access,
-                                             const std::string& who)
-{
-  if (do_check_access && ! check_set_access ())
-    err_property_access (who, wrap (), true);
-
-  if (! obj.is_constructed ())
-    {
-      cdef_class cls (to_cdef (get ("DefiningClass")));
-
-      if (! obj.is_partially_constructed_for (cls))
-        error ("cannot reference properties of class `%s' for non-constructed object",
-               cls.get_name ().c_str ());
-    }
-
-  octave_value set_fcn = get ("SetMethod");
-
-  if (set_fcn.isempty () || is_method_executing (set_fcn, obj))
-    obj.put (get ("Name").string_value (), val);
-  else
-    {
-      octave_value_list args;
-
-      args(0) = to_ov (obj);
-      args(1) = val;
-
-      args = octave::feval (set_fcn, args, 1);
-
-      if (args.length () > 0 && args(0).is_defined ())
-        {
-          if (args (0).is_classdef_object ())
-            {
-              cdef_object new_obj = to_cdef (args(0));
-
-              obj = new_obj;
-            }
-          else
-            ::warning ("set-method of property `%s' returned a non-classdef object",
-                       get_name ().c_str ());
-        }
-    }
-}
-
-bool
-cdef_property::cdef_property_rep::check_get_access (void) const
-{
-  cdef_class cls (to_cdef (get ("DefiningClass")));
-
-  return ::check_access (cls, get ("GetAccess"), "",
-                         get_name (), false);
-
-  return false;
-}
-
-bool
-cdef_property::cdef_property_rep::check_set_access (void) const
-{
-  cdef_class cls (to_cdef (get ("DefiningClass")));
-
-  return ::check_access (cls, get ("SetAccess"), "",
-                         get_name (), true);
-
-  return false;
-}
-
-void
-cdef_method::cdef_method_rep::check_method (void)
-{
-  if (is_external ())
-    {
-      if (is_dummy_method (function))
-        {
-          octave::load_path& lp
-            = octave::__get_load_path__ ("cdef_method::cdef_method_rep::check_method");
-
-          std::string name = get_name ();
-          std::string cls_name = dispatch_type;
-          std::string pack_name;
-
-          size_t pos = cls_name.rfind ('.');
-
-          if (pos != std::string::npos)
-            {
-              pack_name = cls_name.substr (0, pos);
-              cls_name = cls_name.substr (pos + 1);
-            }
-
-          std::string dir_name;
-          std::string file_name = lp.find_method (cls_name, name,
-                                                  dir_name, pack_name);
-
-          if (! file_name.empty ())
-            {
-              octave_value ov_fcn
-                = octave::load_fcn_from_file (file_name, dir_name,
-                                              dispatch_type, pack_name);
-
-              if (ov_fcn.is_defined ())
-                {
-                  function = ov_fcn;
-
-                  make_function_of_class (dispatch_type, function);
-                }
-            }
-        }
-      else
-        {
-          // FIXME: check out-of-date status
-        }
-
-      if (is_dummy_method (function))
-        error ("no definition found for method `%s' of class `%s'",
-               get_name ().c_str (), dispatch_type.c_str ());
-    }
-}
-
-octave_value_list
-cdef_method::cdef_method_rep::execute (const octave_value_list& args,
-                                       int nargout, bool do_check_access,
-                                       const std::string& who)
-{
-  octave_value_list retval;
-
-  if (do_check_access && ! check_access ())
-    err_method_access (who, wrap ());
-
-  if (get ("Abstract").bool_value ())
-    error ("%s: cannot execute abstract method",
-           get ("Name").string_value ().c_str ());
-
-  check_method ();
-
-  if (function.is_defined ())
-    retval = octave::feval (function, args, nargout);
-
-  return retval;
-}
-
-octave_value_list
-cdef_method::cdef_method_rep::execute (const cdef_object& obj,
-                                       const octave_value_list& args,
-                                       int nargout, bool do_check_access,
-                                       const std::string& who)
-{
-  octave_value_list retval;
-
-  if (do_check_access && ! check_access ())
-    err_method_access (who, wrap ());
-
-  if (get ("Abstract").bool_value ())
-    error ("%s: cannot execute abstract method",
-           get ("Name").string_value ().c_str ());
-
-  check_method ();
-
-  if (function.is_defined ())
-    {
-      octave_value_list new_args;
-
-      new_args.resize (args.length () + 1);
-
-      new_args(0) = to_ov (obj);
-      for (int i = 0; i < args.length (); i++)
-        new_args(i+1) = args(i);
-
-      retval = octave::feval (function, new_args, nargout);
-    }
-
-  return retval;
-}
-
-bool
-cdef_method::cdef_method_rep::is_constructor (void) const
-{
-  if (function.is_function())
-    return function.function_value ()->is_classdef_constructor ();
-
-  return false;
-}
-
-bool
-cdef_method::cdef_method_rep::check_access (void) const
-{
-  cdef_class cls (to_cdef (get ("DefiningClass")));
-
-  return ::check_access (cls, get ("Access"), get_name ());
-}
-
-octave_value_list
-cdef_method::cdef_method_rep::meta_subsref
-  (const std::string& type, const std::list<octave_value_list>& idx,
-   int nargout)
-{
-  octave_value_list retval;
-
-  switch (type[0])
-    {
-    case '(':
-      retval = (execute (idx.front (), type.length () > 1 ? 1 : nargout, true));
-      break;
-
-    default:
-      error ("invalid meta.method indexing");
-      break;
-    }
-
-  if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
-    retval = retval(0).next_subsref (nargout, type, idx, 1);
-
-  return retval;
-}
-
-void
-cdef_package::cdef_package_rep::install_class (const cdef_class& cls,
-                                               const std::string& nm)
-{
-  class_map[nm] = cls;
-
-  member_count++;
-}
-
-void
-cdef_package::cdef_package_rep::install_function (const octave_value& fcn,
-                                                  const std::string& nm)
-{
-  function_map[nm] = fcn;
-}
-
-void
-cdef_package::cdef_package_rep::install_package (const cdef_package& pack,
-                                                 const std::string& nm)
-{
-  package_map[nm] = pack;
-
-  member_count++;
-}
-
-template <typename T1, typename T2>
-Cell
-map2Cell (const std::map<T1, T2>& m)
-{
-  Cell retval (1, m.size ());
-  int i = 0;
-
-  for (auto it = m.begin (); it != m.end (); ++it, ++i)
-    retval(i) = to_ov (it->second);
-
-  return retval;
-}
-
-Cell
-cdef_package::cdef_package_rep::get_classes (void) const
-{ return map2Cell (class_map); }
-
-Cell
-cdef_package::cdef_package_rep::get_functions (void) const
-{ return map2Cell (function_map); }
-
-Cell
-cdef_package::cdef_package_rep::get_packages (void) const
-{ return map2Cell (package_map); }
-
-octave_value
-cdef_package::cdef_package_rep::find (const std::string& nm)
-{
-  std::string symbol_name = get_name () + '.' + nm;
-
-  octave::interpreter& interp
-    = octave::__get_interpreter__ ("cdef_package::cdef_package_rep::find");
-
-  return interp.find (symbol_name);
-}
-
-octave_value_list
-cdef_package::cdef_package_rep::meta_subsref
-  (const std::string& type, const std::list<octave_value_list>& idx,
-   int nargout)
-{
-  octave_value_list retval;
-
-  switch (type[0])
-    {
-    case '.':
-      {
-        if (idx.front ().length () != 1)
-          error ("invalid meta.package indexing");
-
-        std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
-
-#if DEBUG_TRACE
-        std::cerr << "meta.package query: " << nm << std::endl;
-#endif
-
-        octave_value o = find (nm);
-
-        if (! o.is_defined ())
-          error ("member `%s' in package `%s' does not exist",
-                 nm.c_str (), get_name ().c_str ());
-
-        if (o.is_function ())
-          {
-            octave_function *fcn = o.function_value ();
-
-            // NOTE: the case where the package query is the last
-            // part of this subsref index is handled in the parse
-            // tree, because there is some logic to handle magic
-            // "end" that makes it impossible to execute the
-            // function call at this stage.
-
-            if (type.size () > 1
-                && ! fcn->accepts_postfix_index (type[1]))
-              {
-                octave_value_list tmp_args;
-
-                retval = octave::feval (o, tmp_args, nargout);
-              }
-            else
-              retval(0) = o;
-
-            if (type.size () > 1 && idx.size () > 1)
-              retval = retval(0).next_subsref (nargout, type,
-                                               idx, 1);
-          }
-        else if (type.size () > 1 && idx.size () > 1)
-          retval = o.next_subsref (nargout, type, idx, 1);
-        else
-          retval(0) = o;
-      }
-      break;
-
-    default:
-      error ("invalid meta.package indexing");
-      break;
-    }
-
-  return retval;
-}
-
-void
-cdef_package::cdef_package_rep::meta_release (void)
-{
-  // FIXME: Do we really want to unregister the package, as it
-  //        could still be referenced by classes or sub-packages?
-  //        If the package object is recreated later on, it won't
-  //        match the one already referenced by those classes or
-  //        sub-packages.
-
-  cdef_manager& cdm
-    = octave::__get_cdef_manager__ ("cdef_package::cdef_package_rep::meta_release");
-
-  // Don't delete the "meta" package.
-  if (this != cdm.meta ().get_rep ())
-    cdm.unregister_package (wrap ());
-}
diff --git a/libinterp/octave-value/cdef-class.h b/libinterp/octave-value/cdef-class.h
--- a/libinterp/octave-value/cdef-class.h
+++ b/libinterp/octave-value/cdef-class.h
@@ -26,30 +26,27 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <map>
 #include <set>
 #include <string>
 
 #include "oct-refcount.h"
 
+#include "cdef-method.h"
 #include "cdef-object.h"
-#include "ov-base.h"
-#include "ov-builtin.h"
-
-class cdef_object;
-class cdef_property;
-class cdef_method;
-class cdef_package;
+#include "cdef-package.h"
+#include "cdef-property.h"
+#include "ov.h"
+#include "ovl.h"
 
 namespace octave
 {
   class interpreter;
   class tree_classdef;
-  class type_info;
 }
 
 class
 cdef_class : public cdef_meta_object
 {
 private:
 
   class
@@ -370,436 +367,17 @@ inline bool
 operator != (const cdef_class& clsa, const cdef_class& clsb)
 { return ! (clsa == clsb); }
 
 // This is only to be able to use cdef_class as map keys.
 inline bool
 operator < (const cdef_class& clsa, const cdef_class& clsb)
 { return clsa.get_rep () < clsb.get_rep (); }
 
-class
-cdef_property : public cdef_meta_object
-{
-  friend class cdef_class;
-
-private:
-
-  class
-  cdef_property_rep : public cdef_meta_object_rep
-  {
-  public:
-    cdef_property_rep (void)
-      : cdef_meta_object_rep () { }
-
-    cdef_property_rep& operator = (const cdef_property_rep& p) = delete;
-
-    ~cdef_property_rep (void) = default;
-
-    cdef_object_rep * copy (void) const { return new cdef_property_rep (*this); }
-
-    bool is_property (void) const { return true; }
-
-    std::string get_name (void) const { return get("Name").string_value (); }
-
-    void set_name (const std::string& nm) { put ("Name", nm); }
-
-    bool is_constant (void) const { return get("Constant").bool_value (); }
-
-    octave_value get_value (bool do_check_access = true,
-                            const std::string& who = "");
-
-    octave_value get_value (const cdef_object& obj,
-                            bool do_check_access = true,
-                            const std::string& who = "");
-
-    void set_value (cdef_object& obj, const octave_value& val,
-                    bool do_check_access = true,
-                    const std::string& who = "");
-
-    bool check_get_access (void) const;
-
-    bool check_set_access (void) const;
-
-  private:
-    cdef_property_rep (const cdef_property_rep& p)
-      : cdef_meta_object_rep (p) { }
-
-    bool is_recursive_set (const cdef_object& obj) const;
-
-    cdef_property wrap (void)
-    {
-      refcount++;
-      return cdef_property (this);
-    }
-  };
-
-public:
-  cdef_property (void) : cdef_meta_object () { }
-
-  cdef_property (const std::string& nm)
-    : cdef_meta_object (new cdef_property_rep ())
-  { get_rep ()->set_name (nm); }
-
-  cdef_property (const cdef_property& prop)
-    : cdef_meta_object (prop) { }
-
-  cdef_property (const cdef_object& obj)
-    : cdef_meta_object (obj)
-  {
-    // This should never happen...
-    if (! is_property ())
-      error ("internal error: invalid assignment from %s to meta.property object",
-             class_name ().c_str ());
-  }
-
-  cdef_property& operator = (const cdef_property& prop)
-  {
-    cdef_object::operator = (prop);
-
-    return *this;
-  }
-
-  ~cdef_property (void) = default;
-
-  octave_value get_value (const cdef_object& obj, bool do_check_access = true,
-                          const std::string& who = "")
-  { return get_rep ()->get_value (obj, do_check_access, who); }
-
-  octave_value get_value (bool do_check_access = true,
-                          const std::string& who = "")
-  { return get_rep ()->get_value (do_check_access, who); }
-
-  void set_value (cdef_object& obj, const octave_value& val,
-                  bool do_check_access = true,
-                  const std::string& who = "")
-  { get_rep ()->set_value (obj, val, do_check_access, who); }
-
-  bool check_get_access (void) const
-  { return get_rep ()->check_get_access (); }
-
-  bool check_set_access (void) const
-  { return get_rep ()->check_set_access (); }
-
-  std::string get_name (void) const { return get_rep ()->get_name (); }
-
-  bool is_constant (void) const { return get_rep ()->is_constant (); }
-
-private:
-  cdef_property_rep * get_rep (void)
-  { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
-
-  const cdef_property_rep * get_rep (void) const
-  { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
-};
-
-class
-cdef_method : public cdef_meta_object
-{
-  friend class cdef_class;
-
-private:
-
-  class
-  cdef_method_rep : public cdef_meta_object_rep
-  {
-  public:
-    cdef_method_rep (void)
-      : cdef_meta_object_rep (), function (), dispatch_type ()
-    { }
-
-    cdef_method_rep& operator = (const cdef_method_rep& m) = delete;
-
-    ~cdef_method_rep (void) = default;
-
-    cdef_object_rep * copy (void) const { return new cdef_method_rep(*this); }
-
-    bool is_method (void) const { return true; }
-
-    std::string get_name (void) const { return get("Name").string_value (); }
-
-    void set_name (const std::string& nm) { put ("Name", nm); }
-
-    bool is_static (void) const { return get("Static").bool_value (); }
-
-    octave_value get_function (void) const { return function; }
-
-    void set_function (const octave_value& fcn) { function = fcn; }
-
-    bool check_access (void) const;
-
-    bool is_external (void) const { return ! dispatch_type.empty (); }
-
-    void mark_as_external (const std::string& dtype)
-    { dispatch_type = dtype; }
-
-    octave_value_list execute (const octave_value_list& args, int nargout,
-                               bool do_check_access = true,
-                               const std::string& who = "");
-
-    octave_value_list execute (const cdef_object& obj,
-                               const octave_value_list& args, int nargout,
-                               bool do_check_access = true,
-                               const std::string& who = "");
-
-    bool is_constructor (void) const;
-
-    octave_value_list
-    meta_subsref (const std::string& type,
-                  const std::list<octave_value_list>& idx, int nargout);
-
-    bool meta_accepts_postfix_index (char type) const
-    { return (type == '(' || type == '.'); }
-
-  private:
-    cdef_method_rep (const cdef_method_rep& m)
-      : cdef_meta_object_rep (m), function (m.function),
-        dispatch_type (m.dispatch_type)
-    { }
-
-    void check_method (void);
-
-    cdef_method wrap (void)
-    {
-      refcount++;
-      return cdef_method (this);
-    }
-
-    octave_value function;
-
-    // When non-empty, the method is externally defined and this member
-    // is used to cache the dispatch type to look for the method.
-    std::string dispatch_type;
-  };
-
-public:
-  cdef_method (void) : cdef_meta_object () { }
-
-  cdef_method (const std::string& nm)
-    : cdef_meta_object (new cdef_method_rep ())
-  { get_rep ()->set_name (nm); }
-
-  cdef_method (const cdef_method& meth)
-    : cdef_meta_object (meth) { }
-
-  cdef_method (const cdef_object& obj)
-    : cdef_meta_object (obj)
-  {
-    // This should never happen...
-    if (! is_method ())
-      error ("internal error: invalid assignment from %s to meta.method object",
-             class_name ().c_str ());
-  }
-
-  cdef_method& operator = (const cdef_method& meth)
-  {
-    cdef_object::operator = (meth);
-
-    return *this;
-  }
-
-  ~cdef_method (void) = default;
-
-  // normal invocation
-  octave_value_list execute (const octave_value_list& args, int nargout,
-                             bool do_check_access = true,
-                             const std::string& who = "")
-  { return get_rep ()->execute (args, nargout, do_check_access, who); }
-
-  // dot-invocation: object is pushed as 1st argument
-  octave_value_list execute (const cdef_object& obj,
-                             const octave_value_list& args, int nargout,
-                             bool do_check_access = true,
-                             const std::string& who = "")
-  { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
-
-  bool check_access (void) const { return get_rep ()->check_access (); }
-
-  std::string get_name (void) const { return get_rep ()->get_name (); }
-
-  bool is_static (void) const { return get_rep ()->is_static (); }
-
-  void set_function (const octave_value& fcn)
-  { get_rep ()->set_function (fcn); }
-
-  octave_value get_function (void) const
-  { return get_rep ()->get_function (); }
-
-  bool is_constructor (void) const
-  { return get_rep ()->is_constructor (); }
-
-  bool is_external (void) const { return get_rep ()->is_external (); }
-
-  void mark_as_external (const std::string& dtype)
-  { get_rep ()->mark_as_external (dtype); }
-
-private:
-  cdef_method_rep * get_rep (void)
-  { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
-
-  const cdef_method_rep * get_rep (void) const
-  { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
-};
-
 inline cdef_method
 cdef_class::find_method (const std::string& nm, bool local)
 { return get_rep ()->find_method (nm, local); }
 
 inline cdef_property
 cdef_class::find_property (const std::string& nm)
 { return get_rep ()->find_property (nm); }
 
-class
-cdef_package : public cdef_meta_object
-{
-  friend class cdef_class;
-
-private:
-
-  class
-  cdef_package_rep : public cdef_meta_object_rep
-  {
-  public:
-    cdef_package_rep (void)
-      : cdef_meta_object_rep (), member_count (0) { }
-
-    cdef_package_rep& operator = (const cdef_package_rep&) = delete;
-
-    ~cdef_package_rep (void) = default;
-
-    cdef_object_rep * copy (void) const { return new cdef_package_rep (*this); }
-
-    bool is_package (void) const { return true; }
-
-    std::string get_name (void) const { return get("Name").string_value (); }
-
-    void set_name (const std::string& nm) { put ("Name", nm); }
-
-    void install_class (const cdef_class& cls, const std::string& nm);
-
-    void install_function (const octave_value& fcn, const std::string& nm);
-
-    void install_package (const cdef_package& pack, const std::string& nm);
-
-    Cell get_classes (void) const;
-
-    Cell get_functions (void) const;
-
-    Cell get_packages (void) const;
-
-    octave_idx_type static_count (void) const { return member_count; }
-
-    void destroy (void)
-    {
-      if (member_count)
-        {
-          refcount++;
-          cdef_package lock (this);
-
-          member_count = 0;
-          class_map.clear ();
-          package_map.clear ();
-        }
-      else
-        delete this;
-    }
-
-    octave_value_list
-    meta_subsref (const std::string& type,
-                  const std::list<octave_value_list>& idx, int nargout);
-
-    void meta_release (void);
-
-    bool meta_accepts_postfix_index (char type) const
-    { return (type == '.'); }
-
-    octave_value find (const std::string& nm);
-
-  private:
-    std::string full_name;
-    std::map<std::string, cdef_class> class_map;
-    std::map<std::string, octave_value> function_map;
-    std::map<std::string, cdef_package> package_map;
-
-    // The number of registered members in this package (classes, packages).
-    // This only accounts for the members that back-reference to this package.
-    octave_idx_type member_count;
-
-    typedef std::map<std::string, cdef_class>::iterator class_iterator;
-    typedef std::map<std::string, cdef_class>::const_iterator class_const_iterator;
-    typedef std::map<std::string, octave_value>::iterator function_iterator;
-    typedef std::map<std::string, octave_value>::const_iterator function_const_iterator;
-    typedef std::map<std::string, cdef_package>::iterator package_iterator;
-    typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
-
-    cdef_package_rep (const cdef_package_rep& p)
-      : cdef_meta_object_rep (p), full_name (p.full_name),
-        class_map (p.class_map), function_map (p.function_map),
-        package_map (p.package_map), member_count (p.member_count)
-    { }
-
-    cdef_package wrap (void)
-    {
-      refcount++;
-      return cdef_package (this);
-    }
-  };
-
-public:
-  cdef_package (void) : cdef_meta_object () { }
-
-  cdef_package (const std::string& nm)
-    : cdef_meta_object (new cdef_package_rep ())
-  { get_rep ()->set_name (nm); }
-
-  cdef_package (const cdef_package& pack)
-    : cdef_meta_object (pack) { }
-
-  cdef_package (const cdef_object& obj)
-    : cdef_meta_object (obj)
-  {
-    // This should never happen...
-    if (! is_package ())
-      error ("internal error: invalid assignment from %s to meta.package object",
-             class_name ().c_str ());
-  }
-
-  cdef_package& operator = (const cdef_package& pack)
-  {
-    cdef_object::operator = (pack);
-
-    return *this;
-  }
-
-  ~cdef_package (void) = default;
-
-  void install_class (const cdef_class& cls, const std::string& nm)
-  { get_rep ()->install_class (cls, nm); }
-
-  void install_function (const octave_value& fcn, const std::string& nm)
-  { get_rep ()->install_function (fcn, nm); }
-
-  void install_package (const cdef_package& pack, const std::string& nm)
-  { get_rep ()->install_package (pack, nm); }
-
-  Cell get_classes (void) const
-  { return get_rep ()->get_classes (); }
-
-  Cell get_functions (void) const
-  { return get_rep ()->get_functions (); }
-
-  Cell get_packages (void) const
-  { return get_rep ()->get_packages (); }
-
-  std::string get_name (void) const { return get_rep ()->get_name (); }
-
-  octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
-
-private:
-  cdef_package_rep * get_rep (void)
-  { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
-
-  const cdef_package_rep * get_rep (void) const
-  { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
-
-  friend void install_classdef (octave::interpreter& interp);
-};
-
 #endif
diff --git a/libinterp/octave-value/cdef-manager.h b/libinterp/octave-value/cdef-manager.h
--- a/libinterp/octave-value/cdef-manager.h
+++ b/libinterp/octave-value/cdef-manager.h
@@ -21,16 +21,20 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_cdef_manager_h)
 #define octave_cdef_manager_h 1
 
 #include "octave-config.h"
 
 #include "cdef-class.h"
+#include "cdef-method.h"
+#include "cdef-package.h"
+#include "cdef-property.h"
+#include "ov-builtin.h"
 
 namespace octave
 {
   class interpreter;
 }
 
 class
 cdef_manager
diff --git a/libinterp/octave-value/cdef-method.cc b/libinterp/octave-value/cdef-method.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-method.cc
@@ -0,0 +1,211 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <algorithm>
+#include <iomanip>
+
+#include "cdef-class.h"
+#include "cdef-manager.h"
+#include "cdef-utils.h"
+#include "errwarn.h"
+#include "interpreter-private.h"
+#include "interpreter.h"
+#include "load-path.h"
+#include "ov-builtin.h"
+#include "ov-classdef.h"
+#include "ov-fcn-handle.h"
+#include "ov-usr-fcn.h"
+#include "parse.h"
+#include "pt-assign.h"
+#include "pt-classdef.h"
+#include "pt-eval.h"
+#include "pt-idx.h"
+#include "pt-misc.h"
+#include "pt-stmt.h"
+#include "pt-walk.h"
+
+OCTAVE_NORETURN static
+void
+err_method_access (const std::string& from, const cdef_method& meth)
+{
+  octave_value acc = meth.get ("Access");
+  std::string acc_s;
+
+  if (acc.is_string ())
+    acc_s = acc.string_value ();
+  else
+    acc_s = "class-restricted";
+
+  error ("%s: method `%s' has %s access and cannot be run in this context",
+         from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
+}
+
+void
+cdef_method::cdef_method_rep::check_method (void)
+{
+  if (is_external ())
+    {
+      if (is_dummy_method (function))
+        {
+          octave::load_path& lp
+            = octave::__get_load_path__ ("cdef_method::cdef_method_rep::check_method");
+
+          std::string name = get_name ();
+          std::string cls_name = dispatch_type;
+          std::string pack_name;
+
+          size_t pos = cls_name.rfind ('.');
+
+          if (pos != std::string::npos)
+            {
+              pack_name = cls_name.substr (0, pos);
+              cls_name = cls_name.substr (pos + 1);
+            }
+
+          std::string dir_name;
+          std::string file_name = lp.find_method (cls_name, name,
+                                                  dir_name, pack_name);
+
+          if (! file_name.empty ())
+            {
+              octave_value ov_fcn
+                = octave::load_fcn_from_file (file_name, dir_name,
+                                              dispatch_type, pack_name);
+
+              if (ov_fcn.is_defined ())
+                {
+                  function = ov_fcn;
+
+                  make_function_of_class (dispatch_type, function);
+                }
+            }
+        }
+      else
+        {
+          // FIXME: check out-of-date status
+        }
+
+      if (is_dummy_method (function))
+        error ("no definition found for method `%s' of class `%s'",
+               get_name ().c_str (), dispatch_type.c_str ());
+    }
+}
+
+octave_value_list
+cdef_method::cdef_method_rep::execute (const octave_value_list& args,
+                                       int nargout, bool do_check_access,
+                                       const std::string& who)
+{
+  octave_value_list retval;
+
+  if (do_check_access && ! check_access ())
+    err_method_access (who, wrap ());
+
+  if (get ("Abstract").bool_value ())
+    error ("%s: cannot execute abstract method",
+           get ("Name").string_value ().c_str ());
+
+  check_method ();
+
+  if (function.is_defined ())
+    retval = octave::feval (function, args, nargout);
+
+  return retval;
+}
+
+octave_value_list
+cdef_method::cdef_method_rep::execute (const cdef_object& obj,
+                                       const octave_value_list& args,
+                                       int nargout, bool do_check_access,
+                                       const std::string& who)
+{
+  octave_value_list retval;
+
+  if (do_check_access && ! check_access ())
+    err_method_access (who, wrap ());
+
+  if (get ("Abstract").bool_value ())
+    error ("%s: cannot execute abstract method",
+           get ("Name").string_value ().c_str ());
+
+  check_method ();
+
+  if (function.is_defined ())
+    {
+      octave_value_list new_args;
+
+      new_args.resize (args.length () + 1);
+
+      new_args(0) = to_ov (obj);
+      for (int i = 0; i < args.length (); i++)
+        new_args(i+1) = args(i);
+
+      retval = octave::feval (function, new_args, nargout);
+    }
+
+  return retval;
+}
+
+bool
+cdef_method::cdef_method_rep::is_constructor (void) const
+{
+  if (function.is_function())
+    return function.function_value ()->is_classdef_constructor ();
+
+  return false;
+}
+
+bool
+cdef_method::cdef_method_rep::check_access (void) const
+{
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  return ::check_access (cls, get ("Access"), get_name ());
+}
+
+octave_value_list
+cdef_method::cdef_method_rep::meta_subsref
+  (const std::string& type, const std::list<octave_value_list>& idx,
+   int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = (execute (idx.front (), type.length () > 1 ? 1 : nargout, true));
+      break;
+
+    default:
+      error ("invalid meta.method indexing");
+      break;
+    }
+
+  if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
+    retval = retval(0).next_subsref (nargout, type, idx, 1);
+
+  return retval;
+}
diff --git a/libinterp/octave-value/cdef-method.h b/libinterp/octave-value/cdef-method.h
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-method.h
@@ -0,0 +1,185 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_cdef_method_h)
+#define octave_cdef_method_h 1
+
+#include "octave-config.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "oct-refcount.h"
+
+#include "cdef-object.h"
+#include "ov.h"
+
+class
+cdef_method : public cdef_meta_object
+{
+  friend class cdef_class;
+
+private:
+
+  class
+  cdef_method_rep : public cdef_meta_object_rep
+  {
+  public:
+    cdef_method_rep (void)
+      : cdef_meta_object_rep (), function (), dispatch_type ()
+    { }
+
+    cdef_method_rep& operator = (const cdef_method_rep& m) = delete;
+
+    ~cdef_method_rep (void) = default;
+
+    cdef_object_rep * copy (void) const { return new cdef_method_rep(*this); }
+
+    bool is_method (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
+    bool is_static (void) const { return get("Static").bool_value (); }
+
+    octave_value get_function (void) const { return function; }
+
+    void set_function (const octave_value& fcn) { function = fcn; }
+
+    bool check_access (void) const;
+
+    bool is_external (void) const { return ! dispatch_type.empty (); }
+
+    void mark_as_external (const std::string& dtype)
+    { dispatch_type = dtype; }
+
+    octave_value_list execute (const octave_value_list& args, int nargout,
+                               bool do_check_access = true,
+                               const std::string& who = "");
+
+    octave_value_list execute (const cdef_object& obj,
+                               const octave_value_list& args, int nargout,
+                               bool do_check_access = true,
+                               const std::string& who = "");
+
+    bool is_constructor (void) const;
+
+    octave_value_list
+    meta_subsref (const std::string& type,
+                  const std::list<octave_value_list>& idx, int nargout);
+
+    bool meta_accepts_postfix_index (char type) const
+    { return (type == '(' || type == '.'); }
+
+  private:
+    cdef_method_rep (const cdef_method_rep& m)
+      : cdef_meta_object_rep (m), function (m.function),
+        dispatch_type (m.dispatch_type)
+    { }
+
+    void check_method (void);
+
+    cdef_method wrap (void)
+    {
+      refcount++;
+      return cdef_method (this);
+    }
+
+    octave_value function;
+
+    // When non-empty, the method is externally defined and this member
+    // is used to cache the dispatch type to look for the method.
+    std::string dispatch_type;
+  };
+
+public:
+  cdef_method (void) : cdef_meta_object () { }
+
+  cdef_method (const std::string& nm)
+    : cdef_meta_object (new cdef_method_rep ())
+  { get_rep ()->set_name (nm); }
+
+  cdef_method (const cdef_method& meth)
+    : cdef_meta_object (meth) { }
+
+  cdef_method (const cdef_object& obj)
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_method ())
+      error ("internal error: invalid assignment from %s to meta.method object",
+             class_name ().c_str ());
+  }
+
+  cdef_method& operator = (const cdef_method& meth)
+  {
+    cdef_object::operator = (meth);
+
+    return *this;
+  }
+
+  ~cdef_method (void) = default;
+
+  // normal invocation
+  octave_value_list execute (const octave_value_list& args, int nargout,
+                             bool do_check_access = true,
+                             const std::string& who = "")
+  { return get_rep ()->execute (args, nargout, do_check_access, who); }
+
+  // dot-invocation: object is pushed as 1st argument
+  octave_value_list execute (const cdef_object& obj,
+                             const octave_value_list& args, int nargout,
+                             bool do_check_access = true,
+                             const std::string& who = "")
+  { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
+
+  bool check_access (void) const { return get_rep ()->check_access (); }
+
+  std::string get_name (void) const { return get_rep ()->get_name (); }
+
+  bool is_static (void) const { return get_rep ()->is_static (); }
+
+  void set_function (const octave_value& fcn)
+  { get_rep ()->set_function (fcn); }
+
+  octave_value get_function (void) const
+  { return get_rep ()->get_function (); }
+
+  bool is_constructor (void) const
+  { return get_rep ()->is_constructor (); }
+
+  bool is_external (void) const { return get_rep ()->is_external (); }
+
+  void mark_as_external (const std::string& dtype)
+  { get_rep ()->mark_as_external (dtype); }
+
+private:
+  cdef_method_rep * get_rep (void)
+  { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
+
+  const cdef_method_rep * get_rep (void) const
+  { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
+};
+
+#endif
diff --git a/libinterp/octave-value/cdef-object.cc b/libinterp/octave-value/cdef-object.cc
--- a/libinterp/octave-value/cdef-object.cc
+++ b/libinterp/octave-value/cdef-object.cc
@@ -19,17 +19,19 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "cdef-class.h"
 #include "cdef-object.h"
+#include "cdef-property.h"
 #include "cdef-utils.h"
 #include "interpreter.h"
 #include "ov-classdef.h"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
 
 void
diff --git a/libinterp/octave-value/cdef-package.cc b/libinterp/octave-value/cdef-package.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-package.cc
@@ -0,0 +1,194 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <algorithm>
+#include <iomanip>
+
+#include "cdef-class.h"
+#include "cdef-manager.h"
+#include "cdef-utils.h"
+#include "errwarn.h"
+#include "interpreter-private.h"
+#include "interpreter.h"
+#include "load-path.h"
+#include "ov-builtin.h"
+#include "ov-classdef.h"
+#include "ov-fcn-handle.h"
+#include "ov-usr-fcn.h"
+#include "parse.h"
+#include "pt-assign.h"
+#include "pt-classdef.h"
+#include "pt-eval.h"
+#include "pt-idx.h"
+#include "pt-misc.h"
+#include "pt-stmt.h"
+#include "pt-walk.h"
+
+// Define to 1 to enable debugging statements.
+#define DEBUG_TRACE 0
+
+void
+cdef_package::cdef_package_rep::install_class (const cdef_class& cls,
+                                               const std::string& nm)
+{
+  class_map[nm] = cls;
+
+  member_count++;
+}
+
+void
+cdef_package::cdef_package_rep::install_function (const octave_value& fcn,
+                                                  const std::string& nm)
+{
+  function_map[nm] = fcn;
+}
+
+void
+cdef_package::cdef_package_rep::install_package (const cdef_package& pack,
+                                                 const std::string& nm)
+{
+  package_map[nm] = pack;
+
+  member_count++;
+}
+
+template <typename T1, typename T2>
+Cell
+map2Cell (const std::map<T1, T2>& m)
+{
+  Cell retval (1, m.size ());
+  int i = 0;
+
+  for (auto it = m.begin (); it != m.end (); ++it, ++i)
+    retval(i) = to_ov (it->second);
+
+  return retval;
+}
+
+Cell
+cdef_package::cdef_package_rep::get_classes (void) const
+{ return map2Cell (class_map); }
+
+Cell
+cdef_package::cdef_package_rep::get_functions (void) const
+{ return map2Cell (function_map); }
+
+Cell
+cdef_package::cdef_package_rep::get_packages (void) const
+{ return map2Cell (package_map); }
+
+octave_value
+cdef_package::cdef_package_rep::find (const std::string& nm)
+{
+  std::string symbol_name = get_name () + '.' + nm;
+
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("cdef_package::cdef_package_rep::find");
+
+  return interp.find (symbol_name);
+}
+
+octave_value_list
+cdef_package::cdef_package_rep::meta_subsref
+  (const std::string& type, const std::list<octave_value_list>& idx,
+   int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '.':
+      {
+        if (idx.front ().length () != 1)
+          error ("invalid meta.package indexing");
+
+        std::string nm = idx.front ()(0).xstring_value ("invalid meta.package indexing, expected a symbol name");
+
+#if DEBUG_TRACE
+        std::cerr << "meta.package query: " << nm << std::endl;
+#endif
+
+        octave_value o = find (nm);
+
+        if (! o.is_defined ())
+          error ("member `%s' in package `%s' does not exist",
+                 nm.c_str (), get_name ().c_str ());
+
+        if (o.is_function ())
+          {
+            octave_function *fcn = o.function_value ();
+
+            // NOTE: the case where the package query is the last
+            // part of this subsref index is handled in the parse
+            // tree, because there is some logic to handle magic
+            // "end" that makes it impossible to execute the
+            // function call at this stage.
+
+            if (type.size () > 1
+                && ! fcn->accepts_postfix_index (type[1]))
+              {
+                octave_value_list tmp_args;
+
+                retval = octave::feval (o, tmp_args, nargout);
+              }
+            else
+              retval(0) = o;
+
+            if (type.size () > 1 && idx.size () > 1)
+              retval = retval(0).next_subsref (nargout, type,
+                                               idx, 1);
+          }
+        else if (type.size () > 1 && idx.size () > 1)
+          retval = o.next_subsref (nargout, type, idx, 1);
+        else
+          retval(0) = o;
+      }
+      break;
+
+    default:
+      error ("invalid meta.package indexing");
+      break;
+    }
+
+  return retval;
+}
+
+void
+cdef_package::cdef_package_rep::meta_release (void)
+{
+  // FIXME: Do we really want to unregister the package, as it
+  //        could still be referenced by classes or sub-packages?
+  //        If the package object is recreated later on, it won't
+  //        match the one already referenced by those classes or
+  //        sub-packages.
+
+  cdef_manager& cdm
+    = octave::__get_cdef_manager__ ("cdef_package::cdef_package_rep::meta_release");
+
+  // Don't delete the "meta" package.
+  if (this != cdm.meta ().get_rep ())
+    cdm.unregister_package (wrap ());
+}
diff --git a/libinterp/octave-value/cdef-package.h b/libinterp/octave-value/cdef-package.h
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-package.h
@@ -0,0 +1,198 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_cdef_package_h)
+#define octave_cdef_package_h 1
+
+#include "octave-config.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "oct-refcount.h"
+
+#include "cdef-object.h"
+#include "ov.h"
+
+namespace octave
+{
+  class interpreter;
+}
+
+class
+cdef_package : public cdef_meta_object
+{
+  friend class cdef_class;
+
+private:
+
+  class
+  cdef_package_rep : public cdef_meta_object_rep
+  {
+  public:
+    cdef_package_rep (void)
+      : cdef_meta_object_rep (), member_count (0) { }
+
+    cdef_package_rep& operator = (const cdef_package_rep&) = delete;
+
+    ~cdef_package_rep (void) = default;
+
+    cdef_object_rep * copy (void) const { return new cdef_package_rep (*this); }
+
+    bool is_package (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
+    void install_class (const cdef_class& cls, const std::string& nm);
+
+    void install_function (const octave_value& fcn, const std::string& nm);
+
+    void install_package (const cdef_package& pack, const std::string& nm);
+
+    Cell get_classes (void) const;
+
+    Cell get_functions (void) const;
+
+    Cell get_packages (void) const;
+
+    octave_idx_type static_count (void) const { return member_count; }
+
+    void destroy (void)
+    {
+      if (member_count)
+        {
+          refcount++;
+          cdef_package lock (this);
+
+          member_count = 0;
+          class_map.clear ();
+          package_map.clear ();
+        }
+      else
+        delete this;
+    }
+
+    octave_value_list
+    meta_subsref (const std::string& type,
+                  const std::list<octave_value_list>& idx, int nargout);
+
+    void meta_release (void);
+
+    bool meta_accepts_postfix_index (char type) const
+    { return (type == '.'); }
+
+    octave_value find (const std::string& nm);
+
+  private:
+    std::string full_name;
+    std::map<std::string, cdef_class> class_map;
+    std::map<std::string, octave_value> function_map;
+    std::map<std::string, cdef_package> package_map;
+
+    // The number of registered members in this package (classes, packages).
+    // This only accounts for the members that back-reference to this package.
+    octave_idx_type member_count;
+
+    typedef std::map<std::string, cdef_class>::iterator class_iterator;
+    typedef std::map<std::string, cdef_class>::const_iterator class_const_iterator;
+    typedef std::map<std::string, octave_value>::iterator function_iterator;
+    typedef std::map<std::string, octave_value>::const_iterator function_const_iterator;
+    typedef std::map<std::string, cdef_package>::iterator package_iterator;
+    typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
+
+    cdef_package_rep (const cdef_package_rep& p)
+      : cdef_meta_object_rep (p), full_name (p.full_name),
+        class_map (p.class_map), function_map (p.function_map),
+        package_map (p.package_map), member_count (p.member_count)
+    { }
+
+    cdef_package wrap (void)
+    {
+      refcount++;
+      return cdef_package (this);
+    }
+  };
+
+public:
+  cdef_package (void) : cdef_meta_object () { }
+
+  cdef_package (const std::string& nm)
+    : cdef_meta_object (new cdef_package_rep ())
+  { get_rep ()->set_name (nm); }
+
+  cdef_package (const cdef_package& pack)
+    : cdef_meta_object (pack) { }
+
+  cdef_package (const cdef_object& obj)
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_package ())
+      error ("internal error: invalid assignment from %s to meta.package object",
+             class_name ().c_str ());
+  }
+
+  cdef_package& operator = (const cdef_package& pack)
+  {
+    cdef_object::operator = (pack);
+
+    return *this;
+  }
+
+  ~cdef_package (void) = default;
+
+  void install_class (const cdef_class& cls, const std::string& nm)
+  { get_rep ()->install_class (cls, nm); }
+
+  void install_function (const octave_value& fcn, const std::string& nm)
+  { get_rep ()->install_function (fcn, nm); }
+
+  void install_package (const cdef_package& pack, const std::string& nm)
+  { get_rep ()->install_package (pack, nm); }
+
+  Cell get_classes (void) const
+  { return get_rep ()->get_classes (); }
+
+  Cell get_functions (void) const
+  { return get_rep ()->get_functions (); }
+
+  Cell get_packages (void) const
+  { return get_rep ()->get_packages (); }
+
+  std::string get_name (void) const { return get_rep ()->get_name (); }
+
+  octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
+
+private:
+  cdef_package_rep * get_rep (void)
+  { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
+
+  const cdef_package_rep * get_rep (void) const
+  { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
+
+  friend void install_classdef (octave::interpreter& interp);
+};
+
+#endif
diff --git a/libinterp/octave-value/cdef-property.cc b/libinterp/octave-value/cdef-property.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-property.cc
@@ -0,0 +1,245 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#include <algorithm>
+#include <iomanip>
+
+#include "cdef-class.h"
+#include "cdef-manager.h"
+#include "cdef-utils.h"
+#include "errwarn.h"
+#include "interpreter-private.h"
+#include "interpreter.h"
+#include "load-path.h"
+#include "ov-builtin.h"
+#include "ov-classdef.h"
+#include "ov-fcn-handle.h"
+#include "ov-usr-fcn.h"
+#include "parse.h"
+#include "pt-assign.h"
+#include "pt-classdef.h"
+#include "pt-eval.h"
+#include "pt-idx.h"
+#include "pt-misc.h"
+#include "pt-stmt.h"
+#include "pt-walk.h"
+
+OCTAVE_NORETURN static
+void
+err_property_access (const std::string& from, const cdef_property& prop,
+                     bool is_set = false)
+{
+  octave_value acc = (prop.get (is_set ? "SetAccess" : "GetAccess"));
+  std::string acc_s;
+
+  if (acc.is_string ())
+    acc_s = acc.string_value ();
+  else
+    acc_s = "class-restricted";
+
+  if (is_set)
+    error ("%s: property `%s' has %s access and cannot be set in this context",
+           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
+  else
+    error ("%s: property `%s' has %s access and cannot be obtained in this context",
+           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
+}
+
+static bool
+is_method_executing (const octave_value& ov, const cdef_object& obj)
+{
+  octave::tree_evaluator& tw
+    = octave::__get_evaluator__ ("is_method_executing");
+
+  octave::call_stack& cs = octave::__get_call_stack__ ("is_method_executing");
+
+  octave_function *stack_fcn = cs.current ();
+
+  octave_function *method_fcn = ov.function_value (true);
+
+  // Does the top of the call stack match our target function?
+
+  if (stack_fcn && stack_fcn == method_fcn)
+    {
+      octave_user_function *uf = method_fcn->user_function_value (true);
+
+      // We can only check the context object for user-function (not builtin),
+      // where we have access to the parameters (arguments and return values).
+      // That's ok as there's no need to call this function for builtin
+      // methods.
+
+      if (uf)
+        {
+          // At this point, the method is executing, but we still need to
+          // check the context object for which the method is executing.  For
+          // methods, it's the first argument of the function; for ctors, it
+          // is the first return value.
+
+          octave::tree_parameter_list *pl = uf->is_classdef_constructor ()
+            ? uf->return_list () : uf->parameter_list ();
+
+          if (pl && pl->size () > 0)
+            {
+              octave::tree_decl_elt *elt = pl->front ();
+
+              octave_value arg0 = tw.evaluate (elt);
+
+              if (arg0.is_defined () && arg0.type_name () == "object")
+                {
+                  cdef_object arg0_obj = to_cdef (arg0);
+
+                  return obj.is (arg0_obj);
+                }
+            }
+        }
+    }
+
+  return false;
+}
+
+octave_value
+cdef_property::cdef_property_rep::get_value (const cdef_object& obj,
+                                             bool do_check_access,
+                                             const std::string& who)
+{
+  octave_value retval;
+
+  if (do_check_access && ! check_get_access ())
+    err_property_access (who, wrap (), false);
+
+  if (! obj.is_constructed ())
+    {
+      cdef_class cls (to_cdef (get ("DefiningClass")));
+
+      if (! obj.is_partially_constructed_for (cls))
+        error ("cannot reference properties of class `%s' for non-constructed object",
+               cls.get_name ().c_str ());
+    }
+
+  octave_value get_fcn = get ("GetMethod");
+
+  // FIXME: should check whether we're already in get accessor method
+
+  if (get_fcn.isempty () || is_method_executing (get_fcn, obj))
+    retval = obj.get (get ("Name").string_value ());
+  else
+    {
+      octave_value_list args;
+
+      args(0) = to_ov (obj);
+
+      args = octave::feval (get_fcn, args, 1);
+
+      retval = args(0);
+    }
+
+  return retval;
+}
+
+octave_value
+cdef_property::cdef_property_rep::get_value (bool do_check_access,
+                                             const std::string& who)
+{
+  if (do_check_access && ! check_get_access ())
+    err_property_access (who, wrap (), false);
+
+  return get ("DefaultValue");
+}
+
+bool
+cdef_property::cdef_property_rep::is_recursive_set (const cdef_object& /* obj */) const
+{
+  // FIXME: implement
+  return false;
+}
+
+void
+cdef_property::cdef_property_rep::set_value (cdef_object& obj,
+                                             const octave_value& val,
+                                             bool do_check_access,
+                                             const std::string& who)
+{
+  if (do_check_access && ! check_set_access ())
+    err_property_access (who, wrap (), true);
+
+  if (! obj.is_constructed ())
+    {
+      cdef_class cls (to_cdef (get ("DefiningClass")));
+
+      if (! obj.is_partially_constructed_for (cls))
+        error ("cannot reference properties of class `%s' for non-constructed object",
+               cls.get_name ().c_str ());
+    }
+
+  octave_value set_fcn = get ("SetMethod");
+
+  if (set_fcn.isempty () || is_method_executing (set_fcn, obj))
+    obj.put (get ("Name").string_value (), val);
+  else
+    {
+      octave_value_list args;
+
+      args(0) = to_ov (obj);
+      args(1) = val;
+
+      args = octave::feval (set_fcn, args, 1);
+
+      if (args.length () > 0 && args(0).is_defined ())
+        {
+          if (args (0).is_classdef_object ())
+            {
+              cdef_object new_obj = to_cdef (args(0));
+
+              obj = new_obj;
+            }
+          else
+            ::warning ("set-method of property `%s' returned a non-classdef object",
+                       get_name ().c_str ());
+        }
+    }
+}
+
+bool
+cdef_property::cdef_property_rep::check_get_access (void) const
+{
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  return ::check_access (cls, get ("GetAccess"), "",
+                         get_name (), false);
+
+  return false;
+}
+
+bool
+cdef_property::cdef_property_rep::check_set_access (void) const
+{
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  return ::check_access (cls, get ("SetAccess"), "",
+                         get_name (), true);
+
+  return false;
+}
diff --git a/libinterp/octave-value/cdef-property.h b/libinterp/octave-value/cdef-property.h
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/cdef-property.h
@@ -0,0 +1,152 @@
+/*
+
+Copyright (C) 2012-2019 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software: you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<https://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_cdef_property_h)
+#define octave_cdef_property_h 1
+
+#include "octave-config.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "oct-refcount.h"
+
+#include "cdef-object.h"
+#include "ov.h"
+
+class
+cdef_property : public cdef_meta_object
+{
+  friend class cdef_class;
+
+private:
+
+  class
+  cdef_property_rep : public cdef_meta_object_rep
+  {
+  public:
+    cdef_property_rep (void)
+      : cdef_meta_object_rep () { }
+
+    cdef_property_rep& operator = (const cdef_property_rep& p) = delete;
+
+    ~cdef_property_rep (void) = default;
+
+    cdef_object_rep * copy (void) const { return new cdef_property_rep (*this); }
+
+    bool is_property (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
+    bool is_constant (void) const { return get("Constant").bool_value (); }
+
+    octave_value get_value (bool do_check_access = true,
+                            const std::string& who = "");
+
+    octave_value get_value (const cdef_object& obj,
+                            bool do_check_access = true,
+                            const std::string& who = "");
+
+    void set_value (cdef_object& obj, const octave_value& val,
+                    bool do_check_access = true,
+                    const std::string& who = "");
+
+    bool check_get_access (void) const;
+
+    bool check_set_access (void) const;
+
+  private:
+    cdef_property_rep (const cdef_property_rep& p)
+      : cdef_meta_object_rep (p) { }
+
+    bool is_recursive_set (const cdef_object& obj) const;
+
+    cdef_property wrap (void)
+    {
+      refcount++;
+      return cdef_property (this);
+    }
+  };
+
+public:
+  cdef_property (void) : cdef_meta_object () { }
+
+  cdef_property (const std::string& nm)
+    : cdef_meta_object (new cdef_property_rep ())
+  { get_rep ()->set_name (nm); }
+
+  cdef_property (const cdef_property& prop)
+    : cdef_meta_object (prop) { }
+
+  cdef_property (const cdef_object& obj)
+    : cdef_meta_object (obj)
+  {
+    // This should never happen...
+    if (! is_property ())
+      error ("internal error: invalid assignment from %s to meta.property object",
+             class_name ().c_str ());
+  }
+
+  cdef_property& operator = (const cdef_property& prop)
+  {
+    cdef_object::operator = (prop);
+
+    return *this;
+  }
+
+  ~cdef_property (void) = default;
+
+  octave_value get_value (const cdef_object& obj, bool do_check_access = true,
+                          const std::string& who = "")
+  { return get_rep ()->get_value (obj, do_check_access, who); }
+
+  octave_value get_value (bool do_check_access = true,
+                          const std::string& who = "")
+  { return get_rep ()->get_value (do_check_access, who); }
+
+  void set_value (cdef_object& obj, const octave_value& val,
+                  bool do_check_access = true,
+                  const std::string& who = "")
+  { get_rep ()->set_value (obj, val, do_check_access, who); }
+
+  bool check_get_access (void) const
+  { return get_rep ()->check_get_access (); }
+
+  bool check_set_access (void) const
+  { return get_rep ()->check_set_access (); }
+
+  std::string get_name (void) const { return get_rep ()->get_name (); }
+
+  bool is_constant (void) const { return get_rep ()->is_constant (); }
+
+private:
+  cdef_property_rep * get_rep (void)
+  { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
+
+  const cdef_property_rep * get_rep (void) const
+  { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
+};
+
+#endif
diff --git a/libinterp/octave-value/cdef-utils.cc b/libinterp/octave-value/cdef-utils.cc
--- a/libinterp/octave-value/cdef-utils.cc
+++ b/libinterp/octave-value/cdef-utils.cc
@@ -20,17 +20,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "call-stack.h"
+#include "cdef-class.h"
 #include "cdef-manager.h"
+#include "cdef-method.h"
+#include "cdef-package.h"
+#include "cdef-property.h"
 #include "cdef-utils.h"
 #include "interpreter-private.h"
 #include "ov-classdef.h"
 #include "ov-usr-fcn.h"
 
 std::string
 get_base_name (const std::string& nm)
 {
@@ -225,8 +229,120 @@ get_class_context (std::string& name, bo
 cdef_class
 get_class_context (void)
 {
   std::string dummy_string;
   bool dummy_bool;
 
   return get_class_context (dummy_string, dummy_bool);
 }
+
+bool
+check_access (const cdef_class& cls, const octave_value& acc,
+              const std::string& meth_name, const std::string& prop_name,
+              bool is_prop_set)
+{
+  if (acc.is_string ())
+    {
+      std::string acc_s = acc.string_value ();
+
+      if (acc_s == "public")
+        return true;
+
+      cdef_class ctx = get_class_context ();
+
+      // The access is private or protected, this requires a
+      // valid class context.
+
+      if (ctx.ok ())
+        {
+          if (acc_s == "private")
+            return (ctx == cls);
+          else if (acc_s == "protected")
+            {
+              if (is_superclass (cls, ctx))
+                // Calling a protected method in a superclass.
+                return true;
+              else if (is_strict_superclass (ctx, cls))
+                {
+                  // Calling a protected method or property in a derived class.
+                  // This is only allowed if the context class knows about it
+                  // and has access to it.
+
+                  if (! meth_name.empty ())
+                    {
+                      cdef_method m = ctx.find_method (meth_name);
+
+                      if (m.ok ())
+                        return check_access (ctx, m.get ("Access"), meth_name);
+
+                      return false;
+                    }
+                  else if (! prop_name.empty ())
+                    {
+                      cdef_property p = ctx.find_property (prop_name);
+
+                      if (p.ok ())
+                        {
+                          octave_value p_access = p.get (is_prop_set ?
+                                                         "SetAccess" :
+                                                         "GetAccess");
+
+                          return check_access (ctx, p_access, meth_name,
+                                               prop_name, is_prop_set);
+                        }
+
+                      return false;
+                    }
+                  else
+                    panic_impossible ();
+                }
+
+              return false;
+            }
+          else
+            panic_impossible ();
+        }
+    }
+  else if (acc.isobject ())
+    {
+      cdef_class ctx = get_class_context ();
+
+      // At this point, a class context is always required.
+      if (ctx.ok ())
+        {
+          if (ctx == cls)
+            return true;
+
+          cdef_class acc_cls (to_cdef (acc));
+
+          if (is_superclass (acc_cls, ctx))
+            return true;
+        }
+    }
+  else if (acc.iscell ())
+    {
+      Cell acc_c = acc.cell_value ();
+
+      cdef_class ctx = get_class_context ();
+
+      // At this point, a class context is always required.
+
+      if (ctx.ok ())
+        {
+          if (ctx == cls)
+            return true;
+
+          for (int i = 0; i < acc.numel (); i++)
+            {
+              cdef_class acc_cls (to_cdef (acc_c(i)));
+
+              if (is_superclass (acc_cls, ctx))
+                return true;
+            }
+        }
+    }
+  else
+    error ("invalid property/method access in class `%s'",
+           cls.get_name ().c_str ());
+
+  return false;
+}
diff --git a/libinterp/octave-value/cdef-utils.h b/libinterp/octave-value/cdef-utils.h
--- a/libinterp/octave-value/cdef-utils.h
+++ b/libinterp/octave-value/cdef-utils.h
@@ -76,9 +76,15 @@ lookup_package (const std::string& name,
                 bool load_if_not_found = true);
 
 extern cdef_class
 get_class_context (std::string& name, bool& in_constructor);
 
 extern cdef_class
 get_class_context (void);
 
+extern bool
+check_access (const cdef_class& cls, const octave_value& acc,
+              const std::string& meth_name = "",
+              const std::string& prop_name = "",
+              bool is_prop_set = false);
+
 #endif
diff --git a/libinterp/octave-value/module.mk b/libinterp/octave-value/module.mk
--- a/libinterp/octave-value/module.mk
+++ b/libinterp/octave-value/module.mk
@@ -15,17 +15,20 @@ OV_SPARSE_INC = \
   %reldir%/ov-base-sparse.h \
   %reldir%/ov-bool-sparse.h \
   %reldir%/ov-cx-sparse.h \
   %reldir%/ov-re-sparse.h
 
 OCTAVE_VALUE_INC = \
   %reldir%/cdef-class.h \
   %reldir%/cdef-manager.h \
+  %reldir%/cdef-method.h \
   %reldir%/cdef-object.h \
+  %reldir%/cdef-package.h \
+  %reldir%/cdef-property.h \
   %reldir%/cdef-utils.h \
   %reldir%/ov-base-diag.h \
   %reldir%/ov-base-mat.h \
   %reldir%/ov-base-scalar.h \
   %reldir%/ov-base.h \
   %reldir%/ov-bool-mat.h \
   %reldir%/ov-bool.h \
   %reldir%/ov-builtin.h \
@@ -80,17 +83,20 @@ OV_INTTYPE_SRC = \
 OV_SPARSE_SRC = \
   %reldir%/ov-bool-sparse.cc \
   %reldir%/ov-cx-sparse.cc \
   %reldir%/ov-re-sparse.cc
 
 OCTAVE_VALUE_SRC = \
   %reldir%/cdef-class.cc \
   %reldir%/cdef-manager.cc \
+  %reldir%/cdef-method.cc \
   %reldir%/cdef-object.cc \
+  %reldir%/cdef-package.cc \
+  %reldir%/cdef-property.cc \
   %reldir%/cdef-utils.cc \
   %reldir%/ov-base.cc \
   %reldir%/ov-bool-mat.cc \
   %reldir%/ov-bool.cc \
   %reldir%/ov-builtin.cc \
   %reldir%/ov-cell.cc \
   %reldir%/ov-ch-mat.cc \
   %reldir%/ov-class.cc \
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -23,16 +23,20 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <algorithm>
 #include <iomanip>
 
 #include "call-stack.h"
+#include "cdef-class.h"
+#include "cdef-method.h"
+#include "cdef-package.h"
+#include "cdef-property.h"
 #include "cdef-utils.h"
 #include "defun.h"
 #include "errwarn.h"
 #include "interpreter-private.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
